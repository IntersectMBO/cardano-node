-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Convenience functions and TH for working with constraints. See
--   <a>README.md</a> for example usage.
@package constraints-extras
@version 0.4.0.2

module Data.Constraint.Compose

-- | Composition for constraints.
class p (f a) => ComposeC (p :: k2 -> Constraint) (f :: k1 -> k2) (a :: k1)
instance forall k2 k1 (p :: k2 -> GHC.Types.Constraint) (f :: k1 -> k2) (a :: k1). p (f a) => Data.Constraint.Compose.ComposeC p f a

module Data.Constraint.Flip

-- | Flip for constraints.
class c h g => FlipC (c :: k -> k' -> Constraint) (g :: k') (h :: k)
instance forall k k' (c :: k -> k' -> GHC.Types.Constraint) (h :: k) (g :: k'). c h g => Data.Constraint.Flip.FlipC c g h


-- | Throughout this module, we use the following GADT and <tt>ArgDict</tt>
--   instance in our examples:
--   
--   <pre>
--   {-# LANGUAGE StandaloneDeriving #-}
--   
--   data Tag a where
--     I :: Tag Int
--     B :: Tag Bool
--   deriving instance Show (Tag a)
--   
--   $(deriveArgDict ''Tag)
--   </pre>
--   
--   The constructors of <tt>Tag</tt> mean that a type variable <tt>a</tt>
--   in <tt>Tag a</tt> must come from the set { <tt>Int</tt>, <tt>Bool</tt>
--   }. We call this the "set of types <tt>a</tt> that could be applied to
--   <tt>Tag</tt>".
module Data.Constraint.Extras

-- | The constraint <tt>Has c f</tt> means that given any value of type
--   <tt>f a</tt>, we can determine that there is an instance of <tt>c
--   a</tt>. For example, <tt>Has Show Tag</tt> means that given any <tt>x
--   :: Tag a</tt>, we can conclude <tt>Show a</tt>. Most commonly, the
--   type <tt>f</tt> will be a GADT, where we can enumerate all the
--   possible index types through pattern matching, and discover that there
--   is an appropriate instance in each case. In this sort of situation,
--   the <tt>c</tt> can be left entirely polymorphic in the instance for
--   <tt>Has</tt>, and this is the sort of instance that the provided
--   Template Haskell code writes.
class Has c f

-- | Use the <tt>f a</tt> to show that there is an instance of <tt>c
--   a</tt>, and bring it into scope.
--   
--   The order of type variables is chosen to work with
--   <tt>-XTypeApplications</tt>.
--   
--   <pre>
--   -- Hold a value of type a, along with a tag identifying the a.
--   data SomeTagged tag where
--     SomeTagged :: a -&gt; tag a -&gt; SomeTagged tag
--   
--   -- Use the stored tag to identify the thing we have, allowing us to call 'show'. Note that we
--   -- have no knowledge of the tag type.
--   showSomeTagged :: Has Show tag =&gt; SomeTagged tag -&gt; String
--   showSomeTagged (SomeTagged a tag) = has @Show tag $ show a
--   </pre>
has :: forall a r. Has c f => f a -> (c a => r) -> r

-- | Use an <tt>f a</tt> to obtain a dictionary for <tt>c a</tt>
--   
--   <pre>
--   argDict @Show I :: Dict (Show Int)
--   </pre>
argDict :: forall a. Has c f => f a -> Dict (c a)

-- | Get a dictionary for <tt>c (g a)</tt>, using a value of type <tt>f
--   a</tt>.
--   
--   <pre>
--   argDict' @Show @Identity B :: Dict (Show (Identity Bool))
--   </pre>
argDict' :: forall c g f a. Has' c f g => f a -> Dict (c (g a))

-- | Get a dictionary for <tt>c (v g)</tt>, using a value of type <tt>f
--   v</tt>.
argDictV :: forall f c g v. HasV c f g => f v -> Dict (c (v g))

-- | The constraint <tt>Has' c f g</tt> means that given a value of type
--   <tt>f a</tt>, we can satisfy the constraint <tt>c (g a)</tt>.
type Has' (c :: k -> Constraint) f (g :: k' -> k) = Has (ComposeC c g) f

-- | Like <a>has</a>, but we get a <tt>c (g a)</tt> instance brought into
--   scope instead. Use <tt>-XTypeApplications</tt> to specify <tt>c</tt>
--   and <tt>g</tt>.
--   
--   <pre>
--   -- From dependent-sum:Data.Dependent.Sum
--   data DSum tag f = forall a. !(tag a) :=&gt; f a
--   
--   -- Show the value from a dependent sum. (We'll need 'whichever', discussed later, to show the key.)
--   showDSumVal :: forall tag f . Has' Show tag f =&gt; DSum tag f -&gt; String
--   showDSumVal (tag :=&gt; fa) = has' @Show @f tag $ show fa
--   </pre>
has' :: forall c g f a r. Has' c f g => f a -> (c (g a) => r) -> r

-- | The constraint <tt>HasV c f g</tt> means that given a value of type
--   <tt>f v</tt>, we can satisfy the constraint <tt>c (v g)</tt>.
type HasV c f g = Has (FlipC (ComposeC c) g) f

-- | Similar to <a>has</a>, but given a value of type <tt>f v</tt>, we get
--   a <tt>c (v g)</tt> instance brought into scope instead.
hasV :: forall c g f v r. HasV c f g => f v -> (c (v g) => r) -> r

-- | Given "forall a. <tt>c (t a)</tt>" (the <tt>ForallF c t</tt>
--   constraint), select a specific <tt>a</tt>, and bring <tt>c (t a)</tt>
--   into scope. Use <tt>-XTypeApplications</tt> to specify <tt>c</tt>,
--   <tt>t</tt> and <tt>a</tt>.
--   
--   <pre>
--   -- Show the tag of a dependent sum, even though we don't know the tag type.
--   showDSumKey :: forall tag f . ForallF Show tag =&gt; DSum tag f -&gt; String
--   showDSumKey ((tag :: tag a) :=&gt; fa) = whichever @Show @tag @a $ show tag
--   </pre>
whichever :: forall c t a r. ForallF c t => (c (t a) => r) -> r

-- | Allows explicit specification of constraint implication.
class Implies1 c d
implies1 :: Implies1 c d => c a :- d a
instance forall k (c :: k -> GHC.Types.Constraint) (f :: k -> *) (g :: k -> *). (Data.Constraint.Extras.Has c f, Data.Constraint.Extras.Has c g) => Data.Constraint.Extras.Has c (f GHC.Generics.:+: g)
instance forall k (c :: k -> GHC.Types.Constraint) (f :: k -> *) (g :: k -> *). (Data.Constraint.Extras.Has c f, Data.Constraint.Extras.Has c g) => Data.Constraint.Extras.Has c (Data.Functor.Sum.Sum f g)

module Data.Constraint.Extras.TH
deriveArgDict :: Name -> Q [Dec]

-- | <i>Deprecated: Just use <a>deriveArgDict</a></i>
deriveArgDictV :: Name -> Q [Dec]
gadtIndices :: Name -> [Con] -> Q [Either Type Type]
