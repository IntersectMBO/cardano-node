-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ED-E is a templating language written in Haskell with a specific set
--   of features:
--   
--   <ul>
--   <li>Logicless within reason. A small set of consistent predicates and
--   expressions for formatting and presentational logic are provided.</li>
--   <li>Secure. No arbitrary code evaluation, with input data required to
--   be fully specified at render time.</li>
--   <li>Stateless. Parsing and rendering are separate steps so that
--   loading, parsing, include resolution, and embedding of the compiled
--   template can optionally be done ahead of time, amortising cost.</li>
--   <li>Markup agnostic. ED-E is used to write out everything from
--   configuration files for system services, to HTML and formatted
--   emails.</li>
--   <li>Control over purity. Users can choose pure or IO-based resolution
--   of <tt>include</tt> expressions.</li>
--   <li>No surprises. All parsing, type assurances, and rendering steps
--   report helpful error messages with line/column metadata. Variable
--   shadowing, unprintable expressions, implicit type coercion, and
--   unbound variable access are all treated as errors.</li>
--   </ul>
@package ede
@version 0.3.4.0


-- | <i>Warning</i>: this is an internal module, and does not have a stable
--   API or name. Functions in this module may not check or enforce
--   preconditions expected by public modules. Use at your own risk!
module Text.EDE.Internal.Compat
toHashMapText :: KeyMap v -> HashMap Text v
fromHashMapText :: HashMap Text v -> KeyMap v


-- | <i>Warning</i>: this is an internal module, and does not have a stable
--   API or name. Functions in this module may not check or enforce
--   preconditions expected by public modules. Use at your own risk!
module Text.EDE.Internal.Types
type AnsiDoc = Doc AnsiStyle
class AnsiPretty a
apretty :: AnsiPretty a => a -> AnsiDoc

-- | Convenience wrapper for Pretty instances.
newtype PP a
PP :: a -> PP a
[unPP] :: PP a -> a
pp :: AnsiPretty (PP a) => a -> AnsiDoc
(</>) :: Doc ann -> Doc ann -> Doc ann
bold :: AnsiDoc -> AnsiDoc
red :: AnsiDoc -> AnsiDoc

-- | The result of running parsing or rendering steps.
data Result a
Success :: a -> Result a
Failure :: AnsiDoc -> Result a
_Failure :: forall a_aea6. Prism' (Result a_aea6) AnsiDoc
_Success :: forall a_aeFf a_aea6. Prism (Result a_aeFf) (Result a_aea6) a_aeFf a_aea6

-- | Convert a <a>Result</a> to an <a>Either</a> with the <a>Left</a> case
--   holding a formatted error message, and <a>Right</a> being the
--   successful result over which <a>Result</a> is paramterised.
eitherResult :: Result a -> Either String a

-- | Perform a case analysis on a <a>Result</a>.
result :: (AnsiDoc -> b) -> (a -> b) -> Result a -> b

-- | Convenience for returning a successful <a>Result</a>.
success :: Monad m => a -> m (Result a)

-- | Convenience for returning an error <a>Result</a>.
failure :: Monad m => AnsiDoc -> m (Result a)
type Delim = (String, String)
data Syntax
Syntax :: !Delim -> !Delim -> !Delim -> !Delim -> Syntax
[_delimPragma] :: Syntax -> !Delim
[_delimInline] :: Syntax -> !Delim
[_delimComment] :: Syntax -> !Delim
[_delimBlock] :: Syntax -> !Delim
class HasSyntax c_af2l
syntax :: HasSyntax c_af2l => Lens' c_af2l Syntax
delimBlock :: HasSyntax c_af2l => Lens' c_af2l Delim
delimComment :: HasSyntax c_af2l => Lens' c_af2l Delim
delimInline :: HasSyntax c_af2l => Lens' c_af2l Delim
delimPragma :: HasSyntax c_af2l => Lens' c_af2l Delim

-- | A function to resolve the target of an <tt>include</tt> expression.
type Resolver m = Syntax -> Id -> Delta -> m (Result Template)

-- | A parsed and compiled template.
data Template
Template :: !Text -> !Exp Delta -> HashMap Id (Exp Delta) -> HashMap Id (Exp Delta) -> HashMap Id (Exp Delta) -> Template
[_tmplName] :: Template -> !Text
[_tmplExp] :: Template -> !Exp Delta
[_tmplIncl] :: Template -> HashMap Id (Exp Delta)
[_tmplExtends] :: Template -> HashMap Id (Exp Delta)
[_tmplBlocks] :: Template -> HashMap Id (Exp Delta)
type Id = Text
newtype Var
Var :: NonEmpty Id -> Var
data Collection
[Col] :: Foldable f => Int -> f (Maybe Text, Value) -> Collection
data Pat
PWild :: Pat
PVar :: !Var -> Pat
PLit :: !Value -> Pat
type Alt a = (Pat, a)
data ExpF a
ELit :: !Value -> ExpF a
EVar :: !Var -> ExpF a
EFun :: !Id -> ExpF a
EApp :: !a -> !a -> ExpF a
ELet :: !Id -> !a -> !a -> ExpF a
EBlock :: !Id -> !a -> ExpF a
EOverrideBlock :: !Id -> !a -> !a -> ExpF a
ECase :: !a -> [Alt a] -> ExpF a
ELoop :: !Id -> !a -> !a -> ExpF a
EIncl :: !Text -> ExpF a
EExt :: !Text -> ExpF a
type Exp = Cofree ExpF

-- | Unwrap a <a>Value</a> to an <a>Object</a> safely.
--   
--   See Aeson's documentation for more details.
fromValue :: Value -> Maybe (HashMap Text Value)

-- | Create an <a>Object</a> from a list of name/value <a>Pair</a>s.
--   
--   See Aeson's documentation for more details.
fromPairs :: [Pair] -> HashMap Text Value
instance GHC.Classes.Eq Text.EDE.Internal.Types.Var
instance GHC.Show.Show Text.EDE.Internal.Types.Pat
instance GHC.Classes.Eq Text.EDE.Internal.Types.Pat
instance GHC.Base.Functor Text.EDE.Internal.Types.ExpF
instance GHC.Show.Show a => GHC.Show.Show (Text.EDE.Internal.Types.ExpF a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.EDE.Internal.Types.ExpF a)
instance GHC.Classes.Eq Text.EDE.Internal.Types.Template
instance Text.Trifecta.Delta.HasDelta (Text.EDE.Internal.Types.Exp Text.Trifecta.Delta.Delta)
instance Data.Functor.Classes.Eq1 Text.EDE.Internal.Types.ExpF
instance Text.EDE.Internal.Types.AnsiPretty Text.EDE.Internal.Types.Var
instance GHC.Show.Show Text.EDE.Internal.Types.Var
instance Text.EDE.Internal.Types.HasSyntax Text.EDE.Internal.Types.Syntax
instance GHC.Base.Monad Text.EDE.Internal.Types.Result
instance GHC.Base.Applicative Text.EDE.Internal.Types.Result
instance GHC.Base.Alternative Text.EDE.Internal.Types.Result
instance GHC.Show.Show a => Text.EDE.Internal.Types.AnsiPretty (Text.EDE.Internal.Types.Result a)
instance Data.Traversable.Traversable Text.EDE.Internal.Types.Result
instance Data.Foldable.Foldable Text.EDE.Internal.Types.Result
instance GHC.Base.Functor Text.EDE.Internal.Types.Result
instance GHC.Show.Show a => GHC.Show.Show (Text.EDE.Internal.Types.Result a)
instance Text.EDE.Internal.Types.AnsiPretty (Text.EDE.Internal.Types.PP Data.Text.Internal.Text)
instance Text.EDE.Internal.Types.AnsiPretty (Text.EDE.Internal.Types.PP Data.Aeson.Types.Internal.Value)


-- | <i>Warning</i>: this is an internal module, and does not have a stable
--   API or name. Functions in this module may not check or enforce
--   preconditions expected by public modules. Use at your own risk!
module Text.EDE.Internal.Syntax

-- | The default ED-E syntax.
--   
--   Delimiters:
--   
--   <ul>
--   <li>Pragma: <tt>{! ... !}</tt></li>
--   <li>Inline: <tt>{{ ... }}</tt></li>
--   <li>Comments: <tt>{# ... #}</tt></li>
--   <li>Blocks: <tt>{% ... %}</tt></li>
--   </ul>
defaultSyntax :: Syntax

-- | An alternate syntax (based on Play/Scala templates) designed to be
--   used when the default is potentially ambiguous due to another
--   encountered smarty based syntax.
--   
--   Delimiters:
--   
--   <ul>
--   <li>Inline: <tt>&lt;@ ... @&gt;</tt></li>
--   <li>Comments: <tt>@* ... *@</tt></li>
--   <li>Blocks: <tt>@( ... )@</tt></li>
--   </ul>
alternateSyntax :: Syntax
commentStyle :: String -> String -> CommentStyle
operatorStyle :: TokenParsing m => IdentifierStyle m
variableStyle :: TokenParsing m => IdentifierStyle m
keywordStyle :: TokenParsing m => IdentifierStyle m
keywordSet :: HashSet String
pragmaStyle :: TokenParsing m => IdentifierStyle m
pragmaSet :: HashSet String


-- | <i>Warning</i>: this is an internal module, and does not have a stable
--   API or name. Functions in this module may not check or enforce
--   preconditions expected by public modules. Use at your own risk!
module Text.EDE.Internal.Quoting

-- | A HOAS representation of (possibly partially applied) values in the
--   environment.
data Term
TVal :: !Value -> Term
TLam :: (Term -> Result Term) -> Term

-- | Fully apply two <a>Term</a>s.
qapply :: Delta -> Term -> Term -> Result Term

-- | Quote a primitive <a>Value</a> from the top-level.
qprim :: (ToJSON a, Quote a) => a -> Term
class Unquote a
unquote :: Unquote a => Id -> Int -> Term -> Result a
unquote :: (Unquote a, FromJSON a) => Id -> Int -> Term -> Result a
class Quote a
quote :: Quote a => Id -> Int -> a -> Term
quote :: (Quote a, ToJSON a) => Id -> Int -> a -> Term
typeErr :: Id -> Int -> AnsiDoc -> AnsiDoc -> Result a
argumentErr :: Pretty a => Id -> Int -> a -> Result b
instance (Text.EDE.Internal.Quoting.Unquote a, Text.EDE.Internal.Quoting.Quote b) => Text.EDE.Internal.Quoting.Quote (a -> b)
instance Text.EDE.Internal.Quoting.Quote Text.EDE.Internal.Quoting.Term
instance Text.EDE.Internal.Quoting.Quote Data.Aeson.Types.Internal.Value
instance Text.EDE.Internal.Quoting.Quote (Data.Aeson.KeyMap.KeyMap Data.Aeson.Types.Internal.Value)
instance Text.EDE.Internal.Quoting.Quote (Data.HashMap.Internal.HashMap Data.Text.Internal.Text Data.Aeson.Types.Internal.Value)
instance Text.EDE.Internal.Quoting.Quote (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
instance Text.EDE.Internal.Quoting.Quote [Data.Aeson.Types.Internal.Value]
instance Text.EDE.Internal.Quoting.Quote Data.Text.Internal.Text
instance Text.EDE.Internal.Quoting.Quote [Data.Text.Internal.Text]
instance Text.EDE.Internal.Quoting.Quote Data.Text.Internal.Lazy.Text
instance Text.EDE.Internal.Quoting.Quote GHC.Types.Bool
instance Text.EDE.Internal.Quoting.Quote GHC.Types.Int
instance Text.EDE.Internal.Quoting.Quote GHC.Num.Integer.Integer
instance Text.EDE.Internal.Quoting.Quote GHC.Types.Double
instance Text.EDE.Internal.Quoting.Quote Data.Scientific.Scientific
instance Text.EDE.Internal.Quoting.Quote Data.Text.Internal.Builder.Builder
instance Text.EDE.Internal.Quoting.Unquote Data.Aeson.Types.Internal.Value
instance Text.EDE.Internal.Quoting.Unquote (Data.Aeson.KeyMap.KeyMap Data.Aeson.Types.Internal.Value)
instance Text.EDE.Internal.Quoting.Unquote (Data.HashMap.Internal.HashMap Data.Text.Internal.Text Data.Aeson.Types.Internal.Value)
instance Text.EDE.Internal.Quoting.Unquote (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
instance Text.EDE.Internal.Quoting.Unquote Data.Text.Internal.Text
instance Text.EDE.Internal.Quoting.Unquote [Data.Text.Internal.Text]
instance Text.EDE.Internal.Quoting.Unquote Data.Text.Internal.Lazy.Text
instance Text.EDE.Internal.Quoting.Unquote GHC.Types.Bool
instance Text.EDE.Internal.Quoting.Unquote GHC.Types.Double
instance Text.EDE.Internal.Quoting.Unquote Data.Scientific.Scientific
instance Text.EDE.Internal.Quoting.Unquote GHC.Types.Int
instance Text.EDE.Internal.Quoting.Unquote GHC.Num.Integer.Integer
instance Text.EDE.Internal.Quoting.Unquote Text.EDE.Internal.Types.Collection
instance Text.EDE.Internal.Types.AnsiPretty Text.EDE.Internal.Quoting.Term


-- | <i>Warning</i>: this is an internal module, and does not have a stable
--   API or name. Functions in this module may not check or enforce
--   preconditions expected by public modules. Use at your own risk!
module Text.EDE.Internal.Filters
stdlib :: HashMap Text Term
(@:) :: Quote a => Id -> a -> (Id, Term)

-- | Quote a binary function which takes the most general binding value.
qpoly2 :: Quote a => Id -> (Value -> Value -> a) -> (Id, Term)

-- | Quote an unary numeric function.
qnum1 :: Id -> (Scientific -> Scientific) -> (Id, Term)

-- | Quote a binary numeric function.
qnum2 :: Quote a => Id -> (Scientific -> Scientific -> a) -> (Id, Term)

-- | Quote a comprehensive set of unary functions to create a binding that
--   supports list collection types.
qlist1 :: (Quote a, Quote b) => Id -> (Text -> a) -> (Vector Value -> b) -> (Id, Term)

-- | Quote a comprehensive set of unary functions to create a binding that
--   supports all collection types.
qcol1 :: (Quote a, Quote b, Quote c) => Id -> (Text -> a) -> (HashMap Text Value -> b) -> (Vector Value -> c) -> (Id, Term)
headT :: Text -> Value
lastT :: Text -> Value
tailT :: Text -> Value
initT :: Text -> Value
headV :: Vector Value -> Value
lastV :: Vector Value -> Value
tailV :: Vector Value -> Value
initV :: Vector Value -> Value
text :: (Text -> Text) -> Text -> Value
vec :: (Vector Value -> Value) -> Vector Value -> Value
safe :: b -> (a -> Bool) -> (a -> b) -> a -> b


-- | The means to construct your own filters.
module Text.EDE.Filters

-- | A HOAS representation of (possibly partially applied) values in the
--   environment.
data Term
TVal :: !Value -> Term
TLam :: (Term -> Result Term) -> Term
class Quote a
quote :: Quote a => Id -> Int -> a -> Term
quote :: (Quote a, ToJSON a) => Id -> Int -> a -> Term
class Unquote a
unquote :: Unquote a => Id -> Int -> Term -> Result a
unquote :: (Unquote a, FromJSON a) => Id -> Int -> Term -> Result a
(@:) :: Quote a => Id -> a -> (Id, Term)

-- | Fully apply two <a>Term</a>s.
qapply :: Delta -> Term -> Term -> Result Term

-- | Quote a binary function which takes the most general binding value.
qpoly2 :: Quote a => Id -> (Value -> Value -> a) -> (Id, Term)

-- | Quote an unary numeric function.
qnum1 :: Id -> (Scientific -> Scientific) -> (Id, Term)

-- | Quote a binary numeric function.
qnum2 :: Quote a => Id -> (Scientific -> Scientific -> a) -> (Id, Term)

-- | Quote a comprehensive set of unary functions to create a binding that
--   supports all collection types.
qcol1 :: (Quote a, Quote b, Quote c) => Id -> (Text -> a) -> (HashMap Text Value -> b) -> (Vector Value -> c) -> (Id, Term)
typeErr :: Id -> Int -> AnsiDoc -> AnsiDoc -> Result a
argumentErr :: Pretty a => Id -> Int -> a -> Result b


-- | <i>Warning</i>: this is an internal module, and does not have a stable
--   API or name. Functions in this module may not check or enforce
--   preconditions expected by public modules. Use at your own risk!
module Text.EDE.Internal.Eval
data Env
Env :: Bool -> HashMap Id (Exp Delta) -> HashMap Id Term -> HashMap Id Value -> HashMap Id (Exp Delta) -> Env
[_extends] :: Env -> Bool
[_templates] :: Env -> HashMap Id (Exp Delta)
[_quoted] :: Env -> HashMap Id Term
[_values] :: Env -> HashMap Id Value
[_blocks] :: Env -> HashMap Id (Exp Delta)
type Context = ReaderT Env Result
render :: HashMap Id (Exp Delta) -> HashMap Id Term -> Exp Delta -> HashMap Id Value -> Result Builder
eval :: Exp Delta -> Context Term
bind :: (HashMap Text Value -> HashMap Text Value) -> Context a -> Context a
bindBlock :: (HashMap Id (Exp Delta) -> HashMap Id (Exp Delta)) -> Context a -> Context a
setExtended :: Bool -> Context a -> Context a
variable :: Delta -> Var -> Context Value

-- | A variable can be tested for truthiness, but a non-whnf expr cannot.
predicate :: Exp Delta -> Context Term
binding :: Delta -> Term -> Term -> Context Term
build :: Delta -> Value -> Context Builder
throwError :: Delta -> AnsiDoc -> Context a


-- | <i>Warning</i>: this is an internal module, and does not have a stable
--   API or name. Functions in this module may not check or enforce
--   preconditions expected by public modules. Use at your own risk!
--   
--   AST smart constructors.
module Text.EDE.Internal.AST
newtype Fix f
Fix :: f (Fix f) -> Fix f
cofreeFix :: Functor f => a -> Fix f -> Cofree f a
var :: Id -> Var
eapp :: a -> [Exp a] -> Exp a
efun :: Id -> Exp a -> Exp a
efilter :: Exp a -> (Id, [Exp a]) -> Exp a
elet :: Maybe (Id, Exp a) -> Exp a -> Exp a
eset :: Id -> Exp a -> Exp a -> Exp a
eblock :: Id -> Exp a -> Exp a
eOverrideBlock :: Id -> Exp a -> Exp a -> Exp a
ecase :: Exp a -> [Alt (Exp a)] -> Maybe (Exp a) -> Exp a
eif :: (Exp a, Exp a) -> [(Exp a, Exp a)] -> Maybe (Exp a) -> Exp a
eempty :: Exp a -> Exp a -> Maybe (Exp a) -> Exp a
true :: Exp a -> Alt (Exp a)
false :: Exp a -> Alt (Exp a)
wild :: Exp a -> Alt (Exp a)
blank :: Fix ExpF


-- | <i>Warning</i>: this is an internal module, and does not have a stable
--   API or name. Functions in this module may not check or enforce
--   preconditions expected by public modules. Use at your own risk!
module Text.EDE.Internal.Parser
data Env
Env :: !Syntax -> HashMap Text (NonEmpty Delta) -> HashMap Text (NonEmpty Delta) -> HashMap Text (Exp Delta) -> Env
[_settings] :: Env -> !Syntax
[_includes] :: Env -> HashMap Text (NonEmpty Delta)
[_extends] :: Env -> HashMap Text (NonEmpty Delta)
[_blocks] :: Env -> HashMap Text (Exp Delta)
settings :: Lens' Env Syntax
includes :: Lens' Env (HashMap Text (NonEmpty Delta))
extends :: Lens' Env (HashMap Text (NonEmpty Delta))
blocks :: Lens' Env (HashMap Text (Exp Delta))
type Parser m = (Monad m, MonadFail m, MonadState Env m, TokenParsing m, DeltaParsing m, LookAheadParsing m, Errable m)
newtype EDE a
EDE :: Parser a -> EDE a
[runEDE] :: EDE a -> Parser a
runParser :: Syntax -> Text -> ByteString -> Result (Exp Delta, HashMap Text (NonEmpty Delta), HashMap Text (NonEmpty Delta), HashMap Text (Exp Delta))
pragma :: Parser m => m ()
document :: Parser m => m (Exp Delta)
inline :: Parser m => m (Exp Delta)
fragment :: Parser m => m (Exp Delta)
statement :: Parser m => m (Exp Delta)
block :: Parser m => String -> m a -> m a
multiLine :: Parser m => m b -> m a -> m a
singleLine :: Parser m => m b -> m a -> m a
blankLine :: Parser m => m (Exp Delta)
ifelif :: Parser m => m (Exp Delta)
cases :: Parser m => m (Exp Delta)
loop :: Parser m => m (Exp Delta)
include :: Parser m => m (Exp Delta)
extends' :: Parser m => m (Exp Delta)
binding :: Parser m => m (Exp Delta)
set :: Parser m => m (Exp Delta)
block' :: Parser m => m (Exp Delta)
raw :: Parser m => m (Exp Delta)
comment :: Parser m => m (Exp Delta)
else' :: Parser m => m (Maybe (Exp Delta))
exit :: Parser m => String -> m ()
pattern :: Parser m => m Pat
term :: Parser m => m (Exp Delta)
term0 :: Parser m => m (Exp Delta)
filter' :: Parser m => m (Id, [Exp Delta])
collection :: Parser m => m (Exp Delta)
literal :: Parser m => m Value
number :: Parser m => m Scientific
bool :: Parser m => m Bool
object :: Parser m => m (HashMap Text Value)
array :: Parser m => m (Vector Value)
operator :: Parser m => Text -> m Delta
keyword :: Parser m => String -> m Delta
variable :: (Monad m, TokenParsing m) => m Var
identifier :: (Monad m, TokenParsing m) => m Id
spaces :: (Monad m, TokenParsing m) => m ()
manyTill1 :: Alternative m => m a -> m b -> m [a]
manyEndBy1 :: Alternative m => m a -> m a -> m [a]
chainl1' :: Alternative m => m a -> m b -> m (a -> b -> a) -> m a
ann :: (DeltaParsing m, Functor f) => m (f (Fix f)) -> m (Cofree f Delta)
pack :: Functor f => f String -> f Value
triml :: Parser m => m a -> m a
trimr :: Parser m => m a -> m a
pragmak :: Parser m => String -> m ()
pragmal :: Parser m => m String
pragmar :: Parser m => m String
commentl :: MonadState Env m => m String
commentr :: MonadState Env m => m String
inlinel :: Parser m => m String
inliner :: Parser m => m String
blockl :: Parser m => m String
blockr :: Parser m => m String
left :: MonadState s m => Getter s Delim -> m String
right :: MonadState s m => Getter s Delim -> m String
instance Text.Trifecta.Result.Errable Text.EDE.Internal.Parser.EDE
instance Text.Parser.LookAhead.LookAheadParsing Text.EDE.Internal.Parser.EDE
instance Text.Trifecta.Combinators.DeltaParsing Text.EDE.Internal.Parser.EDE
instance Text.Parser.Char.CharParsing Text.EDE.Internal.Parser.EDE
instance Text.Parser.Combinators.Parsing Text.EDE.Internal.Parser.EDE
instance GHC.Base.MonadPlus Text.EDE.Internal.Parser.EDE
instance Control.Monad.Fail.MonadFail Text.EDE.Internal.Parser.EDE
instance GHC.Base.Monad Text.EDE.Internal.Parser.EDE
instance GHC.Base.Alternative Text.EDE.Internal.Parser.EDE
instance GHC.Base.Applicative Text.EDE.Internal.Parser.EDE
instance GHC.Base.Functor Text.EDE.Internal.Parser.EDE
instance Text.Parser.Token.TokenParsing Text.EDE.Internal.Parser.EDE
instance Text.Trifecta.Result.Errable (Control.Monad.Trans.State.Strict.StateT Text.EDE.Internal.Parser.Env Text.EDE.Internal.Parser.EDE)
instance Text.EDE.Internal.Types.HasSyntax Text.EDE.Internal.Parser.Env


-- | A (mostly) logic-less textual templating language with similar syntax
--   to <a>Liquid</a> or <a>Jinja2</a>.
--   
--   (ED-E is a character from Fallout New Vegas, pronounced
--   <tt>Eddie</tt>.)
module Text.EDE

-- | A parsed and compiled template.
data Template

-- | Parse a <a>ByteString</a> into a compiled <a>Template</a>.
--   
--   Because this function is pure and does not resolve <tt>include</tt>s,
--   encountering an <tt>include</tt> expression during parsing will result
--   in an <tt>Error</tt>.
--   
--   See <a>parseFile</a> or <a>parseWith</a> for mechanisms to deal with
--   <tt>include</tt> dependencies.
parse :: ByteString -> Result Template

-- | Parse a <a>ByteString</a> into a compiled <a>Template</a>.
--   
--   This function handles all <tt>include</tt> expressions as
--   <a>FilePath</a>s and performs recursive loading/parsing.
parseIO :: FilePath -> ByteString -> IO (Result Template)

-- | Load and parse a <a>Template</a> from a file.
--   
--   This function handles all <tt>include</tt> expressions as
--   <a>FilePath</a>s and performs recursive loading/parsing, with pathing
--   of <tt>include</tt>s relatively to the target (unless absolute paths
--   are used).
parseFile :: FilePath -> IO (Result Template)

-- | <i>See:</i> <a>parseFile</a>.
parseFileWith :: Syntax -> FilePath -> IO (Result Template)

-- | Parse a <a>Template</a> from a Strict <a>ByteString</a> using a custom
--   function for resolving <tt>include</tt> expressions.
--   
--   Two custom <tt>include</tt> resolvers are supplied:
--   
--   <ul>
--   <li><a>includeMap</a></li>
--   <li><a>includeFile</a></li>
--   </ul>
--   
--   <a>parseFile</a> for example, is defined as: <a>parseWith</a>
--   <a>includeFile</a>.
parseWith :: Monad m => Syntax -> Resolver m -> Text -> ByteString -> m (Result Template)

-- | A function to resolve the target of an <tt>include</tt> expression.
type Resolver m = Syntax -> Id -> Delta -> m (Result Template)
type Id = Text

-- | <a>HashMap</a> resolver for <tt>include</tt> expressions.
--   
--   The <tt>identifier</tt> component of the <tt>include</tt> expression
--   is treated as a lookup key into the supplied <a>HashMap</a>. If the
--   <tt>identifier</tt> doesn't exist in the <a>HashMap</a>, an
--   <tt>Error</tt> is returned.
includeMap :: Monad m => HashMap Id Template -> Resolver m

-- | <a>FilePath</a> resolver for <tt>include</tt> expressions.
--   
--   The <tt>identifier</tt> component of the <tt>include</tt> expression
--   is treated as a relative <a>FilePath</a> and the template is loaded
--   and parsed using <a>parseFile</a>. If the <tt>identifier</tt> doesn't
--   exist as a valid <a>FilePath</a>, an <tt>Error</tt> is returned.
includeFile :: FilePath -> Resolver IO

-- | Render an 'HashMap Text Value' using the supplied <a>Template</a>.
render :: Template -> HashMap Text Value -> Result Text

-- | Render an 'HashMap Text Value' using the supplied <a>Template</a>.
renderWith :: HashMap Id Term -> Template -> HashMap Text Value -> Result Text

-- | <i>See:</i> <a>parse</a>
eitherParse :: ByteString -> Either String Template

-- | <i>See:</i> <a>parseFile</a>
eitherParseFile :: FilePath -> IO (Either String Template)

-- | <i>See:</i> <a>parseWith</a>
eitherParseWith :: (Functor m, Monad m) => Syntax -> Resolver m -> Text -> ByteString -> m (Either String Template)

-- | <i>See:</i> <a>render</a>
eitherRender :: Template -> HashMap Text Value -> Either String Text

-- | <i>See:</i> <a>renderWith</a>
eitherRenderWith :: HashMap Id Term -> Template -> HashMap Text Value -> Either String Text
data () => Delta
Columns :: {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta
Tab :: {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta
Lines :: {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta
Directed :: !ByteString -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta

-- | The result of running parsing or rendering steps.
data Result a
Success :: a -> Result a
Failure :: AnsiDoc -> Result a

-- | Convert a <a>Result</a> to an <a>Either</a> with the <a>Left</a> case
--   holding a formatted error message, and <a>Right</a> being the
--   successful result over which <a>Result</a> is paramterised.
eitherResult :: Result a -> Either String a

-- | Perform a case analysis on a <a>Result</a>.
result :: (AnsiDoc -> b) -> (a -> b) -> Result a -> b

-- | Convenience for returning a successful <a>Result</a>.
success :: Monad m => a -> m (Result a)

-- | Convenience for returning an error <a>Result</a>.
failure :: Monad m => AnsiDoc -> m (Result a)

-- | Unwrap a <a>Value</a> to an <a>Object</a> safely.
--   
--   See Aeson's documentation for more details.
fromValue :: Value -> Maybe (HashMap Text Value)

-- | Create an <a>Object</a> from a list of name/value <a>Pair</a>s.
--   
--   See Aeson's documentation for more details.
fromPairs :: [Pair] -> HashMap Text Value
(.=) :: (KeyValue e kv, ToJSON v) => Key -> v -> kv

-- | ED-E Version.
version :: Version
type Delim = (String, String)
data Syntax
delimPragma :: HasSyntax c_af2l => Lens' c_af2l Delim
delimInline :: HasSyntax c_af2l => Lens' c_af2l Delim
delimComment :: HasSyntax c_af2l => Lens' c_af2l Delim
delimBlock :: HasSyntax c_af2l => Lens' c_af2l Delim

-- | The default ED-E syntax.
--   
--   Delimiters:
--   
--   <ul>
--   <li>Pragma: <tt>{! ... !}</tt></li>
--   <li>Inline: <tt>{{ ... }}</tt></li>
--   <li>Comments: <tt>{# ... #}</tt></li>
--   <li>Blocks: <tt>{% ... %}</tt></li>
--   </ul>
defaultSyntax :: Syntax

-- | An alternate syntax (based on Play/Scala templates) designed to be
--   used when the default is potentially ambiguous due to another
--   encountered smarty based syntax.
--   
--   Delimiters:
--   
--   <ul>
--   <li>Inline: <tt>&lt;@ ... @&gt;</tt></li>
--   <li>Comments: <tt>@* ... *@</tt></li>
--   <li>Blocks: <tt>@( ... )@</tt></li>
--   </ul>
alternateSyntax :: Syntax
