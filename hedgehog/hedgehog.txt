-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Release with confidence.
--   
--   <a>Hedgehog</a> automatically generates a comprehensive array of test
--   cases, exercising your software in ways human testers would never
--   imagine.
--   
--   Generate hundreds of test cases automatically, exposing even the most
--   insidious of corner cases. Failures are automatically simplified,
--   giving developers coherent, intelligible error messages.
--   
--   To get started quickly, see the <a>examples</a>.
@package hedgehog
@version 1.5


-- | For compatibility across different versions of the <tt>barbie</tt>
--   package.
module Hedgehog.Internal.Barbie
class () => FunctorB (b :: k -> Type -> Type)
bmap :: FunctorB b => (forall (a :: k). () => f a -> g a) -> b f -> b g
class FunctorB b => TraversableB (b :: k -> Type -> Type)
btraverse :: (TraversableB b, Applicative e) => (forall (a :: k). () => f a -> e (g a)) -> b f -> e (b g)
newtype () => Rec p a (x :: k)
Rec :: K1 R a x -> Rec p a (x :: k)
[unRec] :: Rec p a (x :: k) -> K1 R a x

module Hedgehog.Internal.Distributive
class MonadTransDistributive g where {
    type Transformer (f :: (Type -> Type) -> Type -> Type) (g :: (Type -> Type) -> Type -> Type) (m :: Type -> Type) :: Constraint;
    type Transformer f g m = (Monad m, Monad (f m), Monad (g m),
                              Monad (f (g m)), MonadTrans f, MFunctor f);
}

-- | Distribute one monad transformer over another.
distributeT :: (MonadTransDistributive g, Transformer f g m) => g (f m) a -> f (g m) a
instance Hedgehog.Internal.Distributive.MonadTransDistributive Control.Monad.Trans.Identity.IdentityT
instance Hedgehog.Internal.Distributive.MonadTransDistributive Control.Monad.Trans.Maybe.MaybeT
instance Hedgehog.Internal.Distributive.MonadTransDistributive (Control.Monad.Trans.Except.ExceptT x)
instance Hedgehog.Internal.Distributive.MonadTransDistributive (Control.Monad.Trans.Reader.ReaderT r)
instance GHC.Base.Monoid w => Hedgehog.Internal.Distributive.MonadTransDistributive (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Hedgehog.Internal.Distributive.MonadTransDistributive (Control.Monad.Trans.Writer.Strict.WriterT w)
instance Hedgehog.Internal.Distributive.MonadTransDistributive (Control.Monad.Trans.State.Lazy.StateT s)
instance Hedgehog.Internal.Distributive.MonadTransDistributive (Control.Monad.Trans.State.Strict.StateT s)
instance GHC.Base.Monoid w => Hedgehog.Internal.Distributive.MonadTransDistributive (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Hedgehog.Internal.Distributive.MonadTransDistributive (Control.Monad.Trans.RWS.Strict.RWST r w s)

module Hedgehog.Internal.Exception
tryAll :: MonadCatch m => m a -> m (Either SomeException a)
tryEvaluate :: a -> Either SomeException a

module Hedgehog.Internal.HTraversable

-- | Higher-order traversable functors.
--   
--   <i>Deprecated in favor of <a>TraversableB</a> which can be derived
--   using <a>GHC.Generics</a></i>

-- | <i>Deprecated: Replace with Hedgehog.TraversableB (defined in
--   Data.Functor.Barbie) which can be derived automatically using
--   GHC.Generics</i>
class HTraversable t
htraverse :: (HTraversable t, Applicative f) => (forall a. g a -> f (h a)) -> t g -> f (t h)

module Hedgehog.Internal.Opaque

-- | Opaque values.
--   
--   Useful if you want to put something without a <a>Show</a> instance
--   inside something which you'd like to be able to display.
--   
--   For example:
--   
--   <pre>
--   data State v =
--     State {
--         stateRefs :: [Var (Opaque (IORef Int)) v]
--       } deriving (Eq, Show)
--   </pre>
newtype Opaque a
Opaque :: a -> Opaque a
[unOpaque] :: Opaque a -> a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.Opaque.Opaque a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Opaque.Opaque a)
instance GHC.Show.Show (Hedgehog.Internal.Opaque.Opaque a)


-- | Mostly for compatibility across different base Prelude changes.
module Hedgehog.Internal.Prelude

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class () => Semigroup a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
--   
--   <h4><b>Examples</b></h4>
--   
--   For the following examples, we will assume that we have:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.List.NonEmpty (NonEmpty (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Just [1, 2, 3] :| [Nothing, Just [4, 5, 6]]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Left 1 :| [Right 2, Left 3, Right 4]
--   Right 2
--   </pre>
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   The default definition will raise an exception for a multiplier that
--   is <tt>&lt;= 0</tt>. This may be overridden with an implementation
--   that is total. For monoids it is preferred to use
--   <tt>stimesMonoid</tt>.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in &lt;math&gt; by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 4 [1]
--   [1,1,1,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 5 (putStr "hi!")
--   hi!hi!hi!hi!hi!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 3 (Right ":)")
--   Right ":)"
--   </pre>
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail (m :: Type -> Type)

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data () => Int

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data () => Float

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data () => Char

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data () => IO a
data () => Bool
False :: Bool
True :: Bool

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data () => Double

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data () => Word
data () => Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data () => Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | Lifted, homogeneous equality. By lifted, we mean that it can be bogus
--   (deferred type error). By homogeneous, the two types <tt>a</tt> and
--   <tt>b</tt> must have the same kinds.
class a ~# b => (a :: k) ~ (b :: k)
infix 4 ~

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data () => Integer

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data () => Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
--   
--   In addition, <a>toInteger</a> should be total, and <a>fromInteger</a>
--   should be a left inverse for it, i.e. <tt>fromInteger (toInteger i) =
--   i</tt>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | <a>String</a> is an alias for a list of characters.
--   
--   String constants in Haskell are values of type <a>String</a>. That
--   means if you write a string literal like <tt>"hello world"</tt>, it
--   will have the type <tt>[Char]</tt>, which is the same as
--   <tt>String</tt>.
--   
--   <b>Note:</b> You can ask the compiler to automatically infer different
--   types with the <tt>-XOverloadedStrings</tt> language extension, for
--   example <tt>"hello world" :: Text</tt>. See <a>IsString</a> for more
--   information.
--   
--   Because <tt>String</tt> is just a list of characters, you can use
--   normal list functions to do basic string manipulation. See
--   <a>Data.List</a> for operations on lists.
--   
--   <h3><b>Performance considerations</b></h3>
--   
--   <tt>[Char]</tt> is a relatively memory-inefficient type. It is a
--   linked list of boxed word-size characters, internally it looks
--   something like:
--   
--   <pre>
--   ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭────╮
--   │ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ [] │
--   ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰────╯
--           v               v               v
--          'a'             'b'             'c'
--   </pre>
--   
--   The <tt>String</tt> "abc" will use <tt>5*3+1 = 16</tt> (in general
--   <tt>5n+1</tt>) words of space in memory.
--   
--   Furthermore, operations like <a>(++)</a> (string concatenation) are
--   <tt>O(n)</tt> (in the left argument).
--   
--   For historical reasons, the <tt>base</tt> library uses <tt>String</tt>
--   in a lot of places for the conceptual simplicity, but library code
--   dealing with user-data should use the <a>text</a> package for Unicode
--   text, or the the <a>bytestring</a> package for binary data.
type String = [Char]

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class () => Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class () => Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class () => Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class () => Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class () => Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   <li><i><b>Totality of <a>toRational</a></b></i> <a>toRational</a> is
--   total</li>
--   <li><i><b>Coherence with <a>toRational</a></b></i> if the type also
--   implements <a>Real</a>, then <a>fromRational</a> is a left inverse for
--   <a>toRational</a>, i.e. <tt>fromRational (toRational i) = i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   <li><i><b>Coherence with <tt>toInteger</tt></b></i> if the type also
--   implements <a>Integral</a>, then <a>fromInteger</a> is a left inverse
--   for <a>toInteger</a>, i.e. <tt>fromInteger (toInteger i) ==
--   i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class () => Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 -
infixl 6 +
infixl 7 *

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >

-- | Real numbers.
--   
--   The Haskell report defines no laws for <a>Real</a>, however
--   <a>Real</a> instances are customarily expected to adhere to the
--   following law:
--   
--   <ul>
--   <li><i><b>Coherence with <a>fromRational</a></b></i> if the type also
--   implements <a>Fractional</a>, then <a>fromRational</a> is a left
--   inverse for <a>toRational</a>, i.e. <tt>fromRational (toRational i) =
--   i</tt></li>
--   </ul>
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class () => Foldable (t :: Type -> Type)

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <i>O(n)</i> elements
--   long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class () => Semigroup a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
even :: Integral a => a -> Bool

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is representation-polymorphic in its
--   result type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool
--   -&gt; Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching,
--   <a>uncons</a> or <a>listToMaybe</a> instead.
head :: HasCallStack => [a] -> a

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: HasCallStack => [a] -> [a]

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   WARNING: This function takes linear time in the number of elements of
--   the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt><a>seq</a> a b</tt> is bottom if <tt>a</tt> is
--   bottom, and otherwise equal to <tt>b</tt>. In other words, it
--   evaluates the first argument <tt>a</tt> to weak head normal form
--   (WHNF). <a>seq</a> is usually introduced to improve performance by
--   avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt><a>seq</a> a b</tt>
--   does <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <a>seq</a> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <a>seq</a> returns
--   a value. In particular, this means that <tt>b</tt> may be evaluated
--   before <tt>a</tt>. If you need to guarantee a specific order of
--   evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | General coercion from <a>Integral</a> types.
--   
--   WARNING: This function performs silent truncation if the result type
--   is not at least as big as the argument's type.
fromIntegral :: (Integral a, Num b) => a -> b

-- | General coercion to <a>Fractional</a> types.
--   
--   WARNING: This function goes through the <a>Rational</a> type, which
--   does not have values for <tt>NaN</tt> for example. This means it does
--   not round-trip.
--   
--   For <a>Double</a> it also behaves differently with or without -O0:
--   
--   <pre>
--   Prelude&gt; realToFrac nan -- With -O0
--   -Infinity
--   Prelude&gt; realToFrac nan
--   NaN
--   </pre>
realToFrac :: (Real a, Fractional b) => a -> b

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep) (a :: TYPE r). [Char] -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | <tt>const x y</tt> always evaluates to <tt>x</tt>, ignoring its second
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching or
--   <a>uncons</a> instead.
tail :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching, <a>uncons</a> or <a>listToMaybe</a> instead.
last :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching or <a>uncons</a> instead.
init :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>atMay</a> instead.
(!!) :: HasCallStack => [a] -> Int -> a
infixl 9 !!

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS
odd :: Integral a => a -> Bool

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
lines :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
unwords :: [String] -> String

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <tt>fail</tt> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

module Hedgehog.Internal.Range

-- | Tests are parameterized by the size of the randomly-generated data.
--   The meaning of a <a>Size</a> value depends on the particular generator
--   used, but it must always be a number between 0 and 99 inclusive.
newtype Size
Size :: Int -> Size
[unSize] :: Size -> Int

-- | A range describes the bounds of a number to generate, which may or may
--   not be dependent on a <a>Size</a>.
--   
--   The constructor takes an origin between the lower and upper bound, and
--   a function from <a>Size</a> to bounds. As the size goes towards
--   <tt>0</tt>, the values go towards the origin.
data Range a
Range :: !a -> (Size -> (a, a)) -> Range a

-- | Get the origin of a range. This might be the mid-point or the lower
--   bound, depending on what the range represents.
--   
--   The <a>bounds</a> of a range are scaled around this value when using
--   the <a>linear</a> family of combinators.
--   
--   When using a <a>Range</a> to generate numbers, the shrinking function
--   will shrink towards the origin.
origin :: Range a -> a

-- | Get the extents of a range, for a given size.
bounds :: Size -> Range a -> (a, a)

-- | Get the lower bound of a range for the given size.
lowerBound :: Ord a => Size -> Range a -> a

-- | Get the upper bound of a range for the given size.
upperBound :: Ord a => Size -> Range a -> a

-- | Construct a range which represents a constant single value.
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ singleton 5
--   (5,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ singleton 5
--   5
--   </pre>
singleton :: a -> Range a

-- | Construct a range which is unaffected by the size parameter.
--   
--   A range from <tt>0</tt> to <tt>10</tt>, with the origin at <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constant 0 10
--   (0,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constant 0 10
--   0
--   </pre>
constant :: a -> a -> Range a

-- | Construct a range which is unaffected by the size parameter with a
--   origin point which may differ from the bounds.
--   
--   A range from <tt>-10</tt> to <tt>10</tt>, with the origin at
--   <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constantFrom 0 (-10) 10
--   (-10,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constantFrom 0 (-10) 10
--   0
--   </pre>
--   
--   A range from <tt>1970</tt> to <tt>2100</tt>, with the origin at
--   <tt>2000</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constantFrom 2000 1970 2100
--   (1970,2100)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constantFrom 2000 1970 2100
--   2000
--   </pre>
constantFrom :: a -> a -> a -> Range a

-- | Construct a range which is unaffected by the size parameter using the
--   full range of a data type.
--   
--   A range from <tt>-128</tt> to <tt>127</tt>, with the origin at
--   <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x (constantBounded :: Range Int8)
--   (-128,127)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin (constantBounded :: Range Int8)
--   0
--   </pre>
constantBounded :: (Bounded a, Num a) => Range a

-- | Construct a range which scales the second bound relative to the size
--   parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ linear 0 10
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ linear 0 10
--   (0,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ linear 0 10
--   (0,10)
--   </pre>
linear :: Integral a => a -> a -> Range a

-- | Construct a range which scales the bounds relative to the size
--   parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ linearFrom 0 (-10) 10
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ linearFrom 0 (-10) 20
--   (-5,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ linearFrom 0 (-10) 20
--   (-10,20)
--   </pre>
linearFrom :: Integral a => a -> a -> a -> Range a

-- | Construct a range which scales the second bound relative to the size
--   parameter.
--   
--   <i>This works the same as <a>linear</a>, but for fractional
--   values.</i>
linearFrac :: (Fractional a, Ord a) => a -> a -> Range a

-- | Construct a range which scales the bounds relative to the size
--   parameter.
--   
--   <i>This works the same as <a>linearFrom</a>, but for fractional
--   values.</i>
linearFracFrom :: (Fractional a, Ord a) => a -> a -> a -> Range a

-- | Construct a range which is scaled relative to the size parameter and
--   uses the full range of a data type.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 (linearBounded :: Range Int8)
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 (linearBounded :: Range Int8)
--   (-64,64)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 (linearBounded :: Range Int8)
--   (-128,127)
--   </pre>
linearBounded :: (Bounded a, Integral a) => Range a

-- | Construct a range which scales the second bound exponentially relative
--   to the size parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponential 1 512
--   (1,1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 11 $ exponential 1 512
--   (1,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 22 $ exponential 1 512
--   (1,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 77 $ exponential 1 512
--   (1,128)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 88 $ exponential 1 512
--   (1,256)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponential 1 512
--   (1,512)
--   </pre>
exponential :: Integral a => a -> a -> Range a

-- | Construct a range which scales the bounds exponentially relative to
--   the size parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFrom 0 (-128) 512
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 25 $ exponentialFrom 0 (-128) 512
--   (-2,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFrom 0 (-128) 512
--   (-11,22)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 75 $ exponentialFrom 0 (-128) 512
--   (-39,112)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFrom x (-128) 512
--   (-128,512)
--   </pre>
exponentialFrom :: Integral a => a -> a -> a -> Range a

-- | Construct a range which is scaled exponentially relative to the size
--   parameter and uses the full range of a data type.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 (exponentialBounded :: Range Int8)
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 (exponentialBounded :: Range Int8)
--   (-11,11)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 (exponentialBounded :: Range Int8)
--   (-128,127)
--   </pre>
exponentialBounded :: (Bounded a, Integral a) => Range a

-- | Construct a range which scales the second bound exponentially relative
--   to the size parameter.
--   
--   <i>This works the same as <a>exponential</a>, but for floating-point
--   values.</i>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFloat 0 10
--   (0.0,0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFloat 0 10
--   (0.0,2.357035250656098)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFloat 0 10
--   (0.0,10.0)
--   </pre>
exponentialFloat :: (Floating a, Ord a) => a -> a -> Range a

-- | Construct a range which scales the bounds exponentially relative to
--   the size parameter.
--   
--   <i>This works the same as <a>exponentialFrom</a>, but for
--   floating-point values.</i>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFloatFrom 0 (-10) 20
--   (0.0,0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFloatFrom 0 (-10) 20
--   (-2.357035250656098,3.6535836249197002)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFloatFrom x (-10) 20
--   (-10.0,20.0)
--   </pre>
exponentialFloatFrom :: (Floating a, Ord a) => a -> a -> a -> Range a

-- | Truncate a value so it stays within some range.
--   
--   <pre>
--   &gt;&gt;&gt; clamp 5 10 15
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clamp 5 10 0
--   5
--   </pre>
clamp :: Ord a => a -> a -> a -> a

-- | Scale an integral linearly with the size parameter.
scaleLinear :: Integral a => Size -> a -> a -> a

-- | Scale a fractional number linearly with the size parameter.
scaleLinearFrac :: Fractional a => Size -> a -> a -> a

-- | Scale an integral exponentially with the size parameter.
scaleExponential :: Integral a => Size -> a -> a -> a

-- | Scale a floating-point number exponentially with the size parameter.
scaleExponentialFloat :: Floating a => Size -> a -> a -> a
instance GHC.Real.Integral Hedgehog.Internal.Range.Size
instance GHC.Enum.Enum Hedgehog.Internal.Range.Size
instance GHC.Real.Real Hedgehog.Internal.Range.Size
instance GHC.Num.Num Hedgehog.Internal.Range.Size
instance GHC.Classes.Ord Hedgehog.Internal.Range.Size
instance GHC.Classes.Eq Hedgehog.Internal.Range.Size
instance GHC.Base.Functor Hedgehog.Internal.Range.Range
instance GHC.Show.Show Hedgehog.Internal.Range.Size
instance GHC.Read.Read Hedgehog.Internal.Range.Size

module Hedgehog.Internal.Region
newtype Region
Region :: TVar Body -> Region
[unRegion] :: Region -> TVar Body
newEmptyRegion :: LiftRegion m => m Region
newOpenRegion :: LiftRegion m => m Region
openRegion :: LiftRegion m => Region -> String -> m ()
setRegion :: LiftRegion m => Region -> String -> m ()
displayRegions :: (MonadIO m, MonadMask m) => m a -> m a
displayRegion :: MonadIO m => MonadMask m => LiftRegion m => (Region -> m a) -> m a
moveToBottom :: Region -> STM ()
finishRegion :: LiftRegion m => Region -> m ()


-- | This is a port of "Fast Splittable Pseudorandom Number Generators" by
--   Steele et. al. [1].
--   
--   The paper's algorithm provides decent randomness for most purposes but
--   sacrifices cryptographic-quality randomness in favor of speed. The
--   original implementation is tested with DieHarder and BigCrush; see the
--   paper for details.
--   
--   This implementation, originally from [2], is a port from the paper.
--   
--   It also takes in to account the SplittableRandom.java source code in
--   OpenJDK v8u40-b25 as well as splittable_random.ml in Jane Street's
--   standard library overlay (kernel) v113.33.03, and Random.fs in FsCheck
--   v3.
--   
--   Other than the choice of initial seed for <a>from</a> this port should
--   be faithful.
--   
--   <ol>
--   <li>Guy L. Steele, Jr., Doug Lea, Christine H. Flood Fast splittable
--   pseudorandom number generators Comm ACM, 49(10), Oct 2014,
--   pp453-472.</li>
--   <li>Nikos Baxevanis
--   <a>https://github.com/moodmosaic/SplitMix/blob/master/SplitMix.hs</a></li>
--   </ol>
module Hedgehog.Internal.Seed

-- | A splittable random number generator.
data Seed
Seed :: !Word64 -> !Word64 -> Seed
[seedValue] :: Seed -> !Word64

-- | must be an odd number
[seedGamma] :: Seed -> !Word64

-- | Create a random <a>Seed</a> using an effectful source of randomness.
random :: MonadIO m => m Seed

-- | Create a <a>Seed</a> using a <a>Word64</a>.
from :: Word64 -> Seed

-- | Splits a random number generator in to two.
split :: Seed -> (Seed, Seed)

-- | Generate a random <a>Integer</a> in the [inclusive,inclusive] range.
nextInteger :: Integer -> Integer -> Seed -> (Integer, Seed)

-- | Generate a random <a>Double</a> in the [inclusive,exclusive) range.
nextDouble :: Double -> Double -> Seed -> (Double, Seed)

-- | A predefined gamma value's needed for initializing the "root"
--   instances of <a>Seed</a>. That is, instances not produced by splitting
--   an already existing instance.
--   
--   We choose: the odd integer closest to <tt>2^64/φ</tt>, where <tt>φ =
--   (1 + √5)/2</tt> is the golden ratio.
goldenGamma :: Word64

-- | Generate a random <a>Word64</a>.
nextWord64 :: Seed -> (Word64, Seed)

-- | Generate a random <a>Word32</a>.
nextWord32 :: Seed -> (Word32, Seed)
mix64 :: Word64 -> Word64
mix64variant13 :: Word64 -> Word64
mix32 :: Word64 -> Word32
mixGamma :: Word64 -> Word64
global :: IORef Seed
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Seed.Seed
instance GHC.Classes.Ord Hedgehog.Internal.Seed.Seed
instance GHC.Classes.Eq Hedgehog.Internal.Seed.Seed
instance GHC.Show.Show Hedgehog.Internal.Seed.Seed
instance GHC.Read.Read Hedgehog.Internal.Seed.Seed
instance System.Random.Internal.RandomGen Hedgehog.Internal.Seed.Seed

module Hedgehog.Internal.Show
type Name = String
data () => Value
Con :: Name -> [Value] -> Value
InfixCons :: Value -> [(Name, Value)] -> Value
Rec :: Name -> [(Name, Value)] -> Value
Tuple :: [Value] -> Value
List :: [Value] -> Value
Neg :: Value -> Value
Ratio :: Value -> Value -> Value
Integer :: String -> Value
Float :: String -> Value
Char :: String -> Value
String :: String -> Value
Date :: String -> Value
Time :: String -> Value
Quote :: String -> Value
data ValueDiff
ValueCon :: Name -> [ValueDiff] -> ValueDiff
ValueRec :: Name -> [(Name, ValueDiff)] -> ValueDiff
ValueTuple :: [ValueDiff] -> ValueDiff
ValueList :: [ValueDiff] -> ValueDiff
ValueSame :: Value -> ValueDiff
ValueDiff :: Value -> Value -> ValueDiff
data LineDiff
LineSame :: String -> LineDiff
LineRemoved :: String -> LineDiff
LineAdded :: String -> LineDiff
mkValue :: Show a => a -> Maybe Value
showPretty :: Show a => a -> String
valueDiff :: Value -> Value -> ValueDiff
lineDiff :: Value -> Value -> [LineDiff]
toLineDiff :: ValueDiff -> [LineDiff]
renderValue :: Value -> String
renderValueDiff :: ValueDiff -> String
renderLineDiff :: LineDiff -> String
takeLeft :: ValueDiff -> Value
takeRight :: ValueDiff -> Value
instance GHC.Show.Show Hedgehog.Internal.Show.ValueDiff
instance GHC.Classes.Eq Hedgehog.Internal.Show.ValueDiff
instance GHC.Show.Show Hedgehog.Internal.Show.LineDiff
instance GHC.Classes.Eq Hedgehog.Internal.Show.LineDiff
instance GHC.Show.Show Hedgehog.Internal.Show.DocDiff
instance GHC.Classes.Eq Hedgehog.Internal.Show.DocDiff

module Hedgehog.Internal.Shrink

-- | Shrink an integral number by edging towards a destination.
--   
--   <pre>
--   &gt;&gt;&gt; towards 0 100
--   [0,50,75,88,94,97,99]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; towards 500 1000
--   [500,750,875,938,969,985,993,997,999]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; towards (-50) (-26)
--   [-50,-38,-32,-29,-27]
--   </pre>
--   
--   <i>Note we always try the destination first, as that is the optimal
--   shrink.</i>
towards :: Integral a => a -> a -> [a]

-- | Shrink a floating-point number by edging towards a destination.
--   
--   <pre>
--   &gt;&gt;&gt; take 7 (towardsFloat 0.0 100)
--   [0.0,50.0,75.0,87.5,93.75,96.875,98.4375]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 7 (towardsFloat 1.0 0.5)
--   [1.0,0.75,0.625,0.5625,0.53125,0.515625,0.5078125]
--   </pre>
--   
--   <i>Note we always try the destination first, as that is the optimal
--   shrink.</i>
towardsFloat :: RealFloat a => a -> a -> [a]

-- | Shrink a list by edging towards the empty list.
--   
--   <pre>
--   &gt;&gt;&gt; list [1,2,3]
--   [[],[2,3],[1,3],[1,2]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; list "abcd"
--   ["","cd","ab","bcd","acd","abd","abc"]
--   </pre>
--   
--   <i>Note we always try the empty list first, as that is the optimal
--   shrink.</i>
list :: [a] -> [[a]]

-- | Produce a list containing the progressive halving of an integral.
--   
--   <pre>
--   &gt;&gt;&gt; halves 15
--   [15,7,3,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; halves 100
--   [100,50,25,12,6,3,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; halves (-26)
--   [-26,-13,-6,-3,-1]
--   </pre>
halves :: Integral a => a -> [a]

-- | Produce all permutations of removing <tt>k</tt> elements from a list.
--   
--   <pre>
--   &gt;&gt;&gt; removes 2 "abcdef"
--   ["cdef","abef","abcd"]
--   </pre>
removes :: Int -> [a] -> [[a]]

-- | Cons an element on to the front of a list unless it is already there.
consNub :: Eq a => a -> [a] -> [a]

module Hedgehog.Internal.Source
newtype LineNo
LineNo :: Int -> LineNo
[unLineNo] :: LineNo -> Int
newtype ColumnNo
ColumnNo :: Int -> ColumnNo
[unColumnNo] :: ColumnNo -> Int
data Span
Span :: !FilePath -> !LineNo -> !ColumnNo -> !LineNo -> !ColumnNo -> Span
[spanFile] :: Span -> !FilePath
[spanStartLine] :: Span -> !LineNo
[spanStartColumn] :: Span -> !ColumnNo
[spanEndLine] :: Span -> !LineNo
[spanEndColumn] :: Span -> !ColumnNo
getCaller :: CallStack -> Maybe Span

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   :}
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:... in interactive:Ghci...
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data () => CallStack

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | Return the current <a>CallStack</a>.
--   
--   Does *not* include the call-site of <a>callStack</a>.
callStack :: HasCallStack => CallStack

-- | Perform some computation without adding new entries to the
--   <a>CallStack</a>.
withFrozenCallStack :: HasCallStack => (HasCallStack => a) -> a
instance GHC.Real.Integral Hedgehog.Internal.Source.LineNo
instance GHC.Real.Real Hedgehog.Internal.Source.LineNo
instance GHC.Enum.Enum Hedgehog.Internal.Source.LineNo
instance GHC.Num.Num Hedgehog.Internal.Source.LineNo
instance GHC.Classes.Ord Hedgehog.Internal.Source.LineNo
instance GHC.Classes.Eq Hedgehog.Internal.Source.LineNo
instance GHC.Real.Integral Hedgehog.Internal.Source.ColumnNo
instance GHC.Real.Real Hedgehog.Internal.Source.ColumnNo
instance GHC.Enum.Enum Hedgehog.Internal.Source.ColumnNo
instance GHC.Num.Num Hedgehog.Internal.Source.ColumnNo
instance GHC.Classes.Ord Hedgehog.Internal.Source.ColumnNo
instance GHC.Classes.Eq Hedgehog.Internal.Source.ColumnNo
instance GHC.Classes.Ord Hedgehog.Internal.Source.Span
instance GHC.Classes.Eq Hedgehog.Internal.Source.Span
instance GHC.Show.Show Hedgehog.Internal.Source.Span
instance GHC.Show.Show Hedgehog.Internal.Source.ColumnNo
instance GHC.Show.Show Hedgehog.Internal.Source.LineNo

module Hedgehog.Internal.Tree

-- | A rose tree.
type Tree = TreeT Identity

-- | Pattern to ease construction / deconstruction of pure trees.
pattern Tree :: NodeT Identity a -> Tree a

-- | An effectful tree, each node in the tree can have an effect before it
--   is produced.
newtype TreeT m a
TreeT :: m (NodeT m a) -> TreeT m a
[runTreeT] :: TreeT m a -> m (NodeT m a)

-- | Extracts the <a>Node</a> from a <a>Tree</a>.
runTree :: Tree a -> Node a

-- | Map between <a>TreeT</a> computations.
mapTreeT :: (m (NodeT m a) -> m (NodeT m a)) -> TreeT m a -> TreeT m a

-- | The value at the root of the <a>Tree</a>.
treeValue :: Tree a -> a

-- | The children of the <a>Tree</a>.
treeChildren :: Tree a -> [Tree a]

-- | A node in a rose tree.
type Node = NodeT Identity

-- | Pattern to ease construction / deconstruction of pure nodes.
pattern Node :: a -> [Tree a] -> Node a

-- | A node in an effectful tree, as well as its unevaluated children.
data NodeT m a
NodeT :: a -> [TreeT m a] -> NodeT m a

-- | The value at this <a>NodeT</a> in the <a>TreeT</a>.
[nodeValue] :: NodeT m a -> a

-- | The children of this <a>NodeT</a>.
[nodeChildren] :: NodeT m a -> [TreeT m a]

-- | Create a <a>TreeT</a> from a <a>NodeT</a>
fromNodeT :: Applicative m => NodeT m a -> TreeT m a

-- | Create a tree from a value and an unfolding function.
unfold :: Monad m => (a -> [a]) -> a -> TreeT m a

-- | Create a forest from a value and an unfolding function.
unfoldForest :: Monad m => (a -> [a]) -> a -> [TreeT m a]

-- | Expand a tree using an unfolding function.
expand :: Monad m => (a -> [a]) -> TreeT m a -> TreeT m a

-- | Throw away all but the top <tt>n</tt> levels of a tree's children.
--   
--   <i><tt>prune 0</tt> will throw away all of a tree's children.</i>
prune :: Monad m => Int -> TreeT m a -> TreeT m a

-- | Takes a tree of <a>Maybe</a>s and returns a tree of all the
--   <a>Just</a> values.
--   
--   If the root of the tree is <a>Nothing</a> then <a>Nothing</a> is
--   returned.
catMaybes :: Tree (Maybe a) -> Maybe (Tree a)

-- | Returns a tree containing only elements that match the predicate.
--   
--   If the root of the tree does not match the predicate then
--   <a>Nothing</a> is returned.
filter :: (a -> Bool) -> Tree a -> Maybe (Tree a)
mapMaybe :: (a -> Maybe b) -> Tree a -> Maybe (Tree b)

-- | Returns a tree containing only elements that match the predicate.
--   
--   If the root of the tree does not match the predicate then
--   <a>Nothing</a> is returned.
filterMaybeT :: (a -> Bool) -> TreeT (MaybeT Identity) a -> TreeT (MaybeT Identity) a
mapMaybeMaybeT :: (a -> Maybe b) -> TreeT (MaybeT Identity) a -> TreeT (MaybeT Identity) b

-- | Returns a tree containing only elements that match the predicate.
--   
--   When an element does not match the predicate its node is replaced with
--   <a>empty</a>.
filterT :: (Monad m, Alternative m) => (a -> Bool) -> TreeT m a -> TreeT m a
consChild :: Monad m => a -> TreeT m a -> TreeT m a
mapMaybeT :: (Monad m, Alternative m) => (a -> Maybe b) -> TreeT m a -> TreeT m b

-- | Returns the depth of the deepest leaf node in the tree.
depth :: Tree a -> Int
interleave :: forall m a. Monad m => [NodeT m a] -> NodeT m [a]

-- | Render a tree of strings.
render :: Tree String -> String

-- | Render a tree of strings, note that this forces all the delayed
--   effects in the tree.
renderT :: Monad m => TreeT m String -> m String
instance (GHC.Classes.Eq a, Data.Functor.Classes.Eq1 m) => GHC.Classes.Eq (Hedgehog.Internal.Tree.NodeT m a)
instance Data.Foldable.Foldable Hedgehog.Internal.Tree.Tree
instance Data.Traversable.Traversable Hedgehog.Internal.Tree.Tree
instance Data.Foldable.Foldable Hedgehog.Internal.Tree.Node
instance Data.Traversable.Traversable Hedgehog.Internal.Tree.Node
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hedgehog.Internal.Tree.TreeT m)
instance (Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Hedgehog.Internal.Tree.TreeT m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Hedgehog.Internal.Tree.NodeT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hedgehog.Internal.Tree.TreeT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hedgehog.Internal.Tree.NodeT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hedgehog.Internal.Tree.TreeT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hedgehog.Internal.Tree.NodeT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hedgehog.Internal.Tree.TreeT m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Hedgehog.Internal.Tree.TreeT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Hedgehog.Internal.Tree.TreeT m)
instance GHC.Base.Monad m => Control.Monad.Zip.MonadZip (Hedgehog.Internal.Tree.TreeT m)
instance Control.Monad.Trans.Class.MonadTrans Hedgehog.Internal.Tree.TreeT
instance Control.Monad.Morph.MFunctor Hedgehog.Internal.Tree.NodeT
instance Control.Monad.Morph.MFunctor Hedgehog.Internal.Tree.TreeT
instance Control.Monad.Morph.MMonad Hedgehog.Internal.Tree.TreeT
instance Hedgehog.Internal.Distributive.MonadTransDistributive Hedgehog.Internal.Tree.TreeT
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Hedgehog.Internal.Tree.TreeT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hedgehog.Internal.Tree.TreeT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hedgehog.Internal.Tree.TreeT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hedgehog.Internal.Tree.TreeT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hedgehog.Internal.Tree.TreeT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hedgehog.Internal.Tree.TreeT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hedgehog.Internal.Tree.TreeT m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hedgehog.Internal.Tree.TreeT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hedgehog.Internal.Tree.TreeT m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Hedgehog.Internal.Tree.TreeT m)
instance (Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Hedgehog.Internal.Tree.NodeT m a)
instance (Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Hedgehog.Internal.Tree.TreeT m a)
instance Data.Functor.Classes.Show1 m => Data.Functor.Classes.Show1 (Hedgehog.Internal.Tree.NodeT m)
instance Data.Functor.Classes.Show1 m => Data.Functor.Classes.Show1 (Hedgehog.Internal.Tree.TreeT m)

module Hedgehog.Main

-- | An entry point that can be used as a main function.
defaultMain :: [IO Bool] -> IO ()

module Hedgehog.Range

-- | Tests are parameterized by the size of the randomly-generated data.
--   The meaning of a <a>Size</a> value depends on the particular generator
--   used, but it must always be a number between 0 and 99 inclusive.
newtype Size
Size :: Int -> Size
[unSize] :: Size -> Int

-- | A range describes the bounds of a number to generate, which may or may
--   not be dependent on a <a>Size</a>.
--   
--   The constructor takes an origin between the lower and upper bound, and
--   a function from <a>Size</a> to bounds. As the size goes towards
--   <tt>0</tt>, the values go towards the origin.
data Range a

-- | Get the origin of a range. This might be the mid-point or the lower
--   bound, depending on what the range represents.
--   
--   The <a>bounds</a> of a range are scaled around this value when using
--   the <a>linear</a> family of combinators.
--   
--   When using a <a>Range</a> to generate numbers, the shrinking function
--   will shrink towards the origin.
origin :: Range a -> a

-- | Get the extents of a range, for a given size.
bounds :: Size -> Range a -> (a, a)

-- | Get the lower bound of a range for the given size.
lowerBound :: Ord a => Size -> Range a -> a

-- | Get the upper bound of a range for the given size.
upperBound :: Ord a => Size -> Range a -> a

-- | Construct a range which represents a constant single value.
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ singleton 5
--   (5,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ singleton 5
--   5
--   </pre>
singleton :: a -> Range a

-- | Construct a range which is unaffected by the size parameter.
--   
--   A range from <tt>0</tt> to <tt>10</tt>, with the origin at <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constant 0 10
--   (0,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constant 0 10
--   0
--   </pre>
constant :: a -> a -> Range a

-- | Construct a range which is unaffected by the size parameter with a
--   origin point which may differ from the bounds.
--   
--   A range from <tt>-10</tt> to <tt>10</tt>, with the origin at
--   <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constantFrom 0 (-10) 10
--   (-10,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constantFrom 0 (-10) 10
--   0
--   </pre>
--   
--   A range from <tt>1970</tt> to <tt>2100</tt>, with the origin at
--   <tt>2000</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x $ constantFrom 2000 1970 2100
--   (1970,2100)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin $ constantFrom 2000 1970 2100
--   2000
--   </pre>
constantFrom :: a -> a -> a -> Range a

-- | Construct a range which is unaffected by the size parameter using the
--   full range of a data type.
--   
--   A range from <tt>-128</tt> to <tt>127</tt>, with the origin at
--   <tt>0</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; bounds x (constantBounded :: Range Int8)
--   (-128,127)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; origin (constantBounded :: Range Int8)
--   0
--   </pre>
constantBounded :: (Bounded a, Num a) => Range a

-- | Construct a range which scales the second bound relative to the size
--   parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ linear 0 10
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ linear 0 10
--   (0,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ linear 0 10
--   (0,10)
--   </pre>
linear :: Integral a => a -> a -> Range a

-- | Construct a range which scales the bounds relative to the size
--   parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ linearFrom 0 (-10) 10
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ linearFrom 0 (-10) 20
--   (-5,10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ linearFrom 0 (-10) 20
--   (-10,20)
--   </pre>
linearFrom :: Integral a => a -> a -> a -> Range a

-- | Construct a range which scales the second bound relative to the size
--   parameter.
--   
--   <i>This works the same as <a>linear</a>, but for fractional
--   values.</i>
linearFrac :: (Fractional a, Ord a) => a -> a -> Range a

-- | Construct a range which scales the bounds relative to the size
--   parameter.
--   
--   <i>This works the same as <a>linearFrom</a>, but for fractional
--   values.</i>
linearFracFrom :: (Fractional a, Ord a) => a -> a -> a -> Range a

-- | Construct a range which is scaled relative to the size parameter and
--   uses the full range of a data type.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 (linearBounded :: Range Int8)
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 (linearBounded :: Range Int8)
--   (-64,64)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 (linearBounded :: Range Int8)
--   (-128,127)
--   </pre>
linearBounded :: (Bounded a, Integral a) => Range a

-- | Construct a range which scales the second bound exponentially relative
--   to the size parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponential 1 512
--   (1,1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 11 $ exponential 1 512
--   (1,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 22 $ exponential 1 512
--   (1,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 77 $ exponential 1 512
--   (1,128)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 88 $ exponential 1 512
--   (1,256)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponential 1 512
--   (1,512)
--   </pre>
exponential :: Integral a => a -> a -> Range a

-- | Construct a range which scales the bounds exponentially relative to
--   the size parameter.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFrom 0 (-128) 512
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 25 $ exponentialFrom 0 (-128) 512
--   (-2,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFrom 0 (-128) 512
--   (-11,22)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 75 $ exponentialFrom 0 (-128) 512
--   (-39,112)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFrom x (-128) 512
--   (-128,512)
--   </pre>
exponentialFrom :: Integral a => a -> a -> a -> Range a

-- | Construct a range which is scaled exponentially relative to the size
--   parameter and uses the full range of a data type.
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 (exponentialBounded :: Range Int8)
--   (0,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 (exponentialBounded :: Range Int8)
--   (-11,11)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 (exponentialBounded :: Range Int8)
--   (-128,127)
--   </pre>
exponentialBounded :: (Bounded a, Integral a) => Range a

-- | Construct a range which scales the second bound exponentially relative
--   to the size parameter.
--   
--   <i>This works the same as <a>exponential</a>, but for floating-point
--   values.</i>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFloat 0 10
--   (0.0,0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFloat 0 10
--   (0.0,2.357035250656098)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFloat 0 10
--   (0.0,10.0)
--   </pre>
exponentialFloat :: (Floating a, Ord a) => a -> a -> Range a

-- | Construct a range which scales the bounds exponentially relative to
--   the size parameter.
--   
--   <i>This works the same as <a>exponentialFrom</a>, but for
--   floating-point values.</i>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 0 $ exponentialFloatFrom 0 (-10) 20
--   (0.0,0.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 50 $ exponentialFloatFrom 0 (-10) 20
--   (-2.357035250656098,3.6535836249197002)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bounds 99 $ exponentialFloatFrom x (-10) 20
--   (-10.0,20.0)
--   </pre>
exponentialFloatFrom :: (Floating a, Ord a) => a -> a -> a -> Range a

module Hedgehog.Internal.Gen

-- | Generator for random values of <tt>a</tt>.
type Gen = GenT Identity

-- | Monad transformer which can generate random values of <tt>a</tt>.
newtype GenT m a
GenT :: (Size -> Seed -> TreeT (MaybeT m) a) -> GenT m a
[unGenT] :: GenT m a -> Size -> Seed -> TreeT (MaybeT m) a

-- | Class of monads which can generate input data for tests.
class (Monad m, Monad (GenBase m)) => MonadGen m where {
    type GenBase m :: (Type -> Type);
}

-- | Extract a <a>GenT</a> from a <a>MonadGen</a>.
toGenT :: MonadGen m => m a -> GenT (GenBase m) a

-- | Lift a <a>GenT</a> in to a <a>MonadGen</a>.
fromGenT :: MonadGen m => GenT (GenBase m) a -> m a

-- | Lift a <tt>Gen / GenT Identity</tt> in to a <tt>Monad m =&gt; GenT
--   m</tt>
generalize :: Monad m => Gen a -> GenT m a

-- | Apply a shrinking function to a generator.
--   
--   This will give the generator additional shrinking options, while
--   keeping the existing shrinks intact.
shrink :: MonadGen m => (a -> [a]) -> m a -> m a

-- | Throw away a generator's shrink tree.
prune :: MonadGen m => m a -> m a

-- | Make a generator smaller by scaling its size parameter.
small :: MonadGen m => m a -> m a

-- | Adjust the size parameter by transforming it with the given function.
scale :: MonadGen m => (Size -> Size) -> m a -> m a

-- | Override the size parameter. Returns a generator which uses the given
--   size instead of the runtime-size parameter.
resize :: MonadGen m => Size -> m a -> m a

-- | Construct a generator that depends on the size parameter.
sized :: MonadGen m => (Size -> m a) -> m a

-- | Generates a random integral number in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   When the generator tries to shrink, it will shrink towards the
--   <a>origin</a> of the specified <a>Range</a>.
--   
--   For example, the following generator will produce a number between
--   <tt>1970</tt> and <tt>2100</tt>, but will shrink towards
--   <tt>2000</tt>:
--   
--   <pre>
--   integral (Range.<a>constantFrom</a> 2000 1970 2100) :: <a>Gen</a> <a>Int</a>
--   </pre>
--   
--   Some sample outputs from this generator might look like:
--   
--   <pre>
--   === Outcome ===
--   1973
--   === Shrinks ===
--   2000
--   1987
--   1980
--   1976
--   1974
--   </pre>
--   
--   <pre>
--   === Outcome ===
--   2061
--   === Shrinks ===
--   2000
--   2031
--   2046
--   2054
--   2058
--   2060
--   </pre>
integral :: forall m a. (MonadGen m, Integral a) => Range a -> m a

-- | Generates a random integral number in the [inclusive,inclusive] range.
--   
--   <i>This generator does not shrink.</i>
integral_ :: (MonadGen m, Integral a) => Range a -> m a

-- | Generates a random machine integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int :: MonadGen m => Range Int -> m Int

-- | Generates a random 8-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int8 :: MonadGen m => Range Int8 -> m Int8

-- | Generates a random 16-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int16 :: MonadGen m => Range Int16 -> m Int16

-- | Generates a random 32-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int32 :: MonadGen m => Range Int32 -> m Int32

-- | Generates a random 64-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int64 :: MonadGen m => Range Int64 -> m Int64

-- | Generates a random machine word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word :: MonadGen m => Range Word -> m Word

-- | Generates a random byte in the given <tt>[inclusive,inclusive]</tt>
--   range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word8 :: MonadGen m => Range Word8 -> m Word8

-- | Generates a random 16-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word16 :: MonadGen m => Range Word16 -> m Word16

-- | Generates a random 32-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word32 :: MonadGen m => Range Word32 -> m Word32

-- | Generates a random 64-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word64 :: MonadGen m => Range Word64 -> m Word64

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   <i>This generator works the same as <a>integral</a>, but for floating
--   point numbers.</i>
realFloat :: (MonadGen m, RealFloat a) => Range a -> m a

-- | Generates a random fractional number in the [inclusive,exclusive)
--   range.
--   
--   <i>This generator does not shrink.</i>
realFrac_ :: (MonadGen m, RealFrac a) => Range a -> m a

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   <i>This is a specialization of <a>realFloat</a>, offered for
--   convenience.</i>
float :: MonadGen m => Range Float -> m Float

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   <i>This is a specialization of <a>realFloat</a>, offered for
--   convenience.</i>
double :: MonadGen m => Range Double -> m Double

-- | Generates an element from an enumeration.
--   
--   This generator shrinks towards the first argument.
--   
--   For example:
--   
--   <pre>
--   enum 'a' 'z' :: <a>Gen</a> <a>Char</a>
--   </pre>
enum :: (MonadGen m, Enum a) => a -> a -> m a

-- | Generates a random value from a bounded enumeration.
--   
--   This generator shrinks towards <a>minBound</a>.
--   
--   For example:
--   
--   <pre>
--   enumBounded :: <a>Gen</a> <a>Bool</a>
--   </pre>
--   
--   <i>This is implemented in terms of the <a>Enum</a> class, and thus may
--   be</i> <i>partial for integral types larger than <a>Int</a>, e.g.
--   <a>Word64</a>.</i>
enumBounded :: (MonadGen m, Enum a, Bounded a) => m a

-- | Generates a random boolean.
--   
--   This generator shrinks to <a>False</a>.
--   
--   <i>This is a specialization of <a>enumBounded</a>, offered for
--   convenience.</i>
bool :: MonadGen m => m Bool

-- | Generates a random boolean.
--   
--   <i>This generator does not shrink.</i>
bool_ :: MonadGen m => m Bool

-- | Generates an ASCII binit: <tt>'0'..'1'</tt>
binit :: MonadGen m => m Char

-- | Generates an ASCII octit: <tt>'0'..'7'</tt>
octit :: MonadGen m => m Char

-- | Generates an ASCII digit: <tt>'0'..'9'</tt>
digit :: MonadGen m => m Char

-- | Generates an ASCII hexit: <tt>'0'..'9', 'a'..'f', 'A'..'F'</tt>
hexit :: MonadGen m => m Char

-- | Generates an ASCII lowercase letter: <tt>'a'..'z'</tt>
lower :: MonadGen m => m Char

-- | Generates an ASCII uppercase letter: <tt>'A'..'Z'</tt>
upper :: MonadGen m => m Char

-- | Generates an ASCII letter: <tt>'a'..'z', 'A'..'Z'</tt>
alpha :: MonadGen m => m Char

-- | Generates an ASCII letter or digit: <tt>'a'..'z', 'A'..'Z',
--   '0'..'9'</tt>
alphaNum :: MonadGen m => m Char

-- | Generates an ASCII character: <tt>'0'..'127'</tt>
ascii :: MonadGen m => m Char

-- | Generates a Latin-1 character: <tt>'0'..'255'</tt>
latin1 :: MonadGen m => m Char

-- | Generates a Unicode character, excluding noncharacters and invalid
--   standalone surrogates: <tt>'0'..'1114111' (excluding '55296'..'57343',
--   '65534', '65535')</tt>
unicode :: MonadGen m => m Char

-- | Generates a Unicode character, including noncharacters and invalid
--   standalone surrogates: <tt>'0'..'1114111'</tt>
unicodeAll :: MonadGen m => m Char

-- | Generates a string using <a>Range</a> to determine the length.
--   
--   <i>This is a specialization of <a>list</a>, offered for
--   convenience.</i>
string :: MonadGen m => Range Int -> m Char -> m String

-- | Generates a string using <a>Range</a> to determine the length.
text :: MonadGen m => Range Int -> m Char -> m Text

-- | Generates a UTF-8 encoded string, using <a>Range</a> to determine the
--   length.
utf8 :: MonadGen m => Range Int -> m Char -> m ByteString

-- | Generates a random <a>ByteString</a>, using <a>Range</a> to determine
--   the length.
bytes :: MonadGen m => Range Int -> m ByteString

-- | Trivial generator that always produces the same element.
--   
--   <i>This is another name for <a>pure</a> / <a>return</a>.</i>
constant :: MonadGen m => a -> m a

-- | Randomly selects one of the elements in the list.
--   
--   This generator shrinks towards the first element in the list.
--   
--   <i>The input list must be non-empty.</i>
element :: (Foldable f, MonadGen m) => f a -> m a

-- | Randomly selects one of the elements in the list.
--   
--   This generator does not shrink the choice of element.
--   
--   <i>The input list must be non-empty.</i>
element_ :: MonadGen m => [a] -> m a

-- | Randomly selects one of the generators in the list.
--   
--   This generator shrinks towards the first generator in the list.
--   
--   <i>The input list must be non-empty.</i>
choice :: MonadGen m => [m a] -> m a

-- | Uses a weighted distribution to randomly select one of the generators
--   in the list.
--   
--   This generator shrinks towards the first generator in the list.
--   
--   <i>The input list must be non-empty.</i>
frequency :: MonadGen m => [(Int, m a)] -> m a

-- | Modifies combinators which choose from a list of generators, like
--   <a>choice</a> or <a>frequency</a>, so that they can be used in
--   recursive scenarios.
--   
--   This combinator modifies its target to select one of the generators in
--   either the non-recursive or the recursive list. When a selection is
--   made from the recursive list, the <a>Size</a> is halved. When the
--   <a>Size</a> gets to one or less, selections are no longer made from
--   the recursive list, this ensures termination.
--   
--   A good example of where this might be useful is abstract syntax trees:
--   
--   <pre>
--   data Expr =
--       Var String
--     | Lam String Expr
--     | App Expr Expr
--   
--   -- Assuming we have a name generator
--   genName :: <a>MonadGen</a> m =&gt; m String
--   
--   -- We can write a generator for expressions
--   genExpr :: <a>MonadGen</a> m =&gt; m Expr
--   genExpr =
--     Gen.<a>recursive</a> Gen.<a>choice</a> [
--         -- non-recursive generators
--         Var <a>&lt;$&gt;</a> genName
--       ] [
--         -- recursive generators
--         Gen.<a>subtermM</a> genExpr (x -&gt; Lam <a>&lt;$&gt;</a> genName <a>&lt;*&gt;</a> pure x)
--       , Gen.<a>subterm2</a> genExpr genExpr App
--       ]
--   </pre>
--   
--   If we wrote the above example using only <a>choice</a>, it is likely
--   that it would fail to terminate. This is because for every call to
--   <tt>genExpr</tt>, there is a 2 in 3 chance that we will recurse again.
recursive :: MonadGen m => ([m a] -> m a) -> [m a] -> [m a] -> m a

-- | Discards the whole generator.
discard :: MonadGen m => m a

-- | Discards the generator if the generated value does not satisfy the
--   predicate.
ensure :: MonadGen m => (a -> Bool) -> m a -> m a

-- | Generates a value that satisfies a predicate.
--   
--   Shrinks of the generated value will also satisfy the predicate. From
--   the original generator's shrink tree, any values that fail the
--   predicate will be removed, but any subsequent shrinks that satisfy it
--   will be retained. Compared to <a>filter</a>, shrinking may be slower
--   but will be optimal.
--   
--   It's possible that the predicate will never pass, or will only pass at
--   a larger size than we're currently running at. To avoid looping
--   forever, we limit the number of retries, and grow the size with each
--   retry. If we retry too many times then the whole generator is
--   discarded.
filter :: (MonadGen m, GenBase m ~ Identity) => (a -> Bool) -> m a -> m a

-- | Generates a value which is the result of the given function returning
--   a <a>Just</a>.
--   
--   The original generator's shrink tree will be retained, with values
--   returning <a>Nothing</a> removed. Subsequent shrinks of those values
--   will be retained. Compared to <a>mapMaybeT</a>, shrinking may be
--   slower but will be optimal.
--   
--   It's possible that the function will never return <a>Just</a>, or will
--   only do so a larger size than we're currently running at. To avoid
--   looping forever, we limit the number of retries, and grow the size
--   with each retry. If we retry too many times then the whole generator
--   is discarded.
mapMaybe :: (MonadGen m, GenBase m ~ Identity) => (a -> Maybe b) -> m a -> m b

-- | Generates a value that satisfies a predicate.
--   
--   Shrinks of the generated value will also satisfy the predicate. From
--   the original generator's shrink tree, any values that fail the
--   predicate will be removed, along with their subsequent shrinks.
--   Compared to <a>filter</a>, shrinking may be faster but may also be
--   less optimal.
--   
--   The type is also more general, because the shrink behavior from
--   <a>filter</a> would force the entire shrink tree to be evaluated when
--   applied to an impure tree.
--   
--   This is essentially:
--   
--   <pre>
--   filterT p gen = <tt>mfilter</tt> p gen <a>&lt;|&gt;</a> filterT p gen
--   </pre>
--   
--   But that could loop forever, if the predicate will never pass or will
--   only pass at a larger size than we're currently running at. We differ
--   from the above in keeping some state to avoid that. We limit the
--   number of retries, and grow the size with each retry. If we retry too
--   many times then the whole generator is discarded.
filterT :: MonadGen m => (a -> Bool) -> m a -> m a

-- | Generates a value which is the result of the given function returning
--   a <a>Just</a>.
--   
--   The original generator's shrink tree will be retained, with values
--   returning <a>Nothing</a> removed. Subsequent shrinks of those values
--   will be retained. Compared to <a>mapMaybeT</a>, shrinking may be
--   slower but will be optimal.
--   
--   The type is also more general, because the shrink behavior from
--   <a>mapMaybe</a> would force the entire shrink tree to be evaluated
--   when applied to an impure tree.
--   
--   It's possible that the function will never return <a>Just</a>, or will
--   only do so a larger size than we're currently running at. To avoid
--   looping forever, we limit the number of retries, and grow the size
--   with each retry. If we retry too many times then the whole generator
--   is discarded.
mapMaybeT :: MonadGen m => (a -> Maybe b) -> m a -> m b

-- | Runs a <a>Maybe</a> generator until it produces a <a>Just</a>.
--   
--   <i>This is implemented using <a>filter</a> and has the same
--   caveats.</i>
just :: (MonadGen m, GenBase m ~ Identity) => m (Maybe a) -> m a

-- | Runs a <a>Maybe</a> generator until it produces a <a>Just</a>.
--   
--   <i>This is implemented using <a>filter</a> and has the same
--   caveats.</i>
justT :: MonadGen m => m (Maybe a) -> m a

-- | Generates a <a>Nothing</a> some of the time.
maybe :: MonadGen m => m a -> m (Maybe a)

-- | Generates either an <tt>a</tt> or a <tt>b</tt>.
--   
--   As the size grows, this generator generates <tt>Right</tt>s more often
--   than <tt>Left</tt>s.
either :: MonadGen m => m a -> m b -> m (Either a b)

-- | Generates either an <tt>a</tt> or a <tt>b</tt>, without bias.
--   
--   This generator generates as many <tt>Right</tt>s as it does
--   <tt>Left</tt>s.
either_ :: MonadGen m => m a -> m b -> m (Either a b)

-- | Generates a list using a <a>Range</a> to determine the length.
list :: MonadGen m => Range Int -> m a -> m [a]

-- | Generates a seq using a <a>Range</a> to determine the length.
seq :: MonadGen m => Range Int -> m a -> m (Seq a)

-- | Generates a non-empty list using a <a>Range</a> to determine the
--   length.
nonEmpty :: MonadGen m => Range Int -> m a -> m (NonEmpty a)

-- | Generates a set using a <a>Range</a> to determine the length.
--   
--   <i>This may fail to generate anything if the element generator</i>
--   <i>cannot produce a large enough number of unique items to satify</i>
--   <i>the required set size.</i>
set :: (MonadGen m, Ord a) => Range Int -> m a -> m (Set a)

-- | Generates a map using a <a>Range</a> to determine the length.
--   
--   <i>This may fail to generate anything if the keys produced by the</i>
--   <i>generator do not account for a large enough number of unique</i>
--   <i>items to satify the required map size.</i>
map :: (MonadGen m, Ord k) => Range Int -> m (k, v) -> m (Map k v)

-- | Freeze the size and seed used by a generator, so we can inspect the
--   value which it will produce.
--   
--   This is used for implementing <a>list</a> and <a>subtermMVec</a>. It
--   allows us to shrink the list itself before trying to shrink the values
--   inside the list.
freeze :: MonadGen m => m a -> m (a, m a)

-- | Constructs a generator from a sub-term generator.
--   
--   <i>Shrinks to the sub-term if possible.</i>
subterm :: MonadGen m => m a -> (a -> a) -> m a

-- | Constructs a generator from a sub-term generator.
--   
--   <i>Shrinks to the sub-term if possible.</i>
subtermM :: MonadGen m => m a -> (a -> m a) -> m a

-- | Constructs a generator from two sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subterm2 :: MonadGen m => m a -> m a -> (a -> a -> a) -> m a

-- | Constructs a generator from two sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subtermM2 :: MonadGen m => m a -> m a -> (a -> a -> m a) -> m a

-- | Constructs a generator from three sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subterm3 :: MonadGen m => m a -> m a -> m a -> (a -> a -> a -> a) -> m a

-- | Constructs a generator from three sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subtermM3 :: MonadGen m => m a -> m a -> m a -> (a -> a -> a -> m a) -> m a

-- | Generates a random subsequence of a list.
--   
--   For example:
--   
--   <pre>
--   Gen.print (Gen.subsequence [1..5])
--   </pre>
--   
--   <pre>
--   === Outcome ===
--   [1,2,4]
--   === Shrinks ===
--   []
--   [2,4]
--   [1,4]
--   [1,2]
--   </pre>
subsequence :: MonadGen m => [a] -> m [a]

-- | Generates a random subset of a set.
--   
--   <i>This shrinks towards the empty set.</i>
subset :: MonadGen m => Set a -> m (Set a)

-- | Generates a random permutation of a list.
--   
--   <i>This shrinks towards the order of the list being identical to the
--   input</i> <i>list.</i>
shuffle :: MonadGen m => [a] -> m [a]

-- | Generates a random permutation of a sequence.
--   
--   <i>This shrinks towards the order of the sequence being identical to
--   the input</i> <i>sequence.</i>
shuffleSeq :: MonadGen m => Seq a -> m (Seq a)

-- | Generate a sample from a generator.
--   
--   This function is useful for examining a <a>Gen</a> in GHCi or other
--   contexts. It is not appropriate for use in a test suite directly. You
--   will only get a single sample from this function, and it will not give
--   you a property test. The seed is random, so the test is not
--   deterministic.
--   
--   If you only want a single test to run, then use <tt><tt>withTests</tt>
--   1</tt>:
--   
--   <pre>
--   prop_OnlyRunOnce :: Property
--   prop_OnlyRunOnce =
--     <tt>withTests</tt> 1 $ <tt>property</tt> $ do
--       i &lt;- Gen.int
--       i /== 0
--   </pre>
sample :: MonadIO m => Gen a -> m a

-- | Run a generator with a random seed and print the outcome, and the
--   first level of shrinks.
--   
--   <pre>
--   Gen.print (Gen.<a>enum</a> 'a' 'f')
--   </pre>
--   
--   <pre>
--   === Outcome ===
--   'd'
--   === Shrinks ===
--   'a'
--   'b'
--   'c'
--   </pre>
print :: (MonadIO m, Show a) => Gen a -> m ()

-- | Run a generator with a random seed and print the resulting shrink
--   tree.
--   
--   <pre>
--   Gen.printTree (Gen.<a>enum</a> 'a' 'f')
--   </pre>
--   
--   <pre>
--   'd'
--    ├╼'a'
--    ├╼'b'
--    │  └╼'a'
--    └╼'c'
--       ├╼'a'
--       └╼'b'
--          └╼'a'
--   </pre>
--   
--   <i>This may not terminate when the tree is very large.</i>
printTree :: (MonadIO m, Show a) => Gen a -> m ()

-- | Print the value produced by a generator, and the first level of
--   shrinks, for the given size and seed.
--   
--   Use <a>print</a> to generate a value from a random seed.
printWith :: (MonadIO m, Show a) => Size -> Seed -> Gen a -> m ()

-- | Print the shrink tree produced by a generator, for the given size and
--   seed.
--   
--   Use <a>printTree</a> to generate a value from a random seed.
printTreeWith :: (MonadIO m, Show a) => Size -> Seed -> Gen a -> m ()

-- | Render the shrink tree produced by a generator, for the given size and
--   seed.
renderTree :: Show a => Size -> Seed -> Gen a -> String

-- | Runs a generator, producing its shrink tree.
runGenT :: Size -> Seed -> GenT m a -> TreeT (MaybeT m) a

-- | Run a generator, producing its shrink tree.
--   
--   <a>Nothing</a> means discarded, <a>Just</a> means we have a value.
evalGen :: Size -> Seed -> Gen a -> Maybe (Tree a)

-- | Runs a generator, producing its shrink tree.
evalGenT :: Monad m => Size -> Seed -> GenT m a -> TreeT m (Maybe a)

-- | Map over a generator's shrink tree.
mapGenT :: (TreeT (MaybeT m) a -> TreeT (MaybeT n) b) -> GenT m a -> GenT n b

-- | Generate a value with no shrinks from a <a>Size</a> and a <a>Seed</a>.
generate :: MonadGen m => (Size -> Seed -> a) -> m a

-- | Observe a generator's shrink tree.
toTree :: forall m a. (MonadGen m, GenBase m ~ Identity) => m a -> m (Tree a)

-- | Lift a predefined shrink tree in to a generator, ignoring the seed and
--   the size.
toTreeMaybeT :: MonadGen m => m a -> m (TreeT (MaybeT (GenBase m)) a)

-- | Lift a predefined shrink tree in to a generator, ignoring the seed and
--   the size.
fromTree :: MonadGen m => Tree a -> m a

-- | Lift a predefined shrink tree in to a generator, ignoring the seed and
--   the size.
fromTreeT :: MonadGen m => TreeT (GenBase m) a -> m a

-- | Lift a predefined shrink tree in to a generator, ignoring the seed and
--   the size.
fromTreeMaybeT :: MonadGen m => TreeT (MaybeT (GenBase m)) a -> m a

-- | Lazily run the discard effects through the tree and reify it a
--   <tt>Maybe (Tree a)</tt>.
--   
--   <a>Nothing</a> means discarded, <a>Just</a> means we have a value.
--   
--   Discards in the child nodes of the tree are simply removed.
runDiscardEffect :: TreeT (MaybeT Identity) a -> Maybe (Tree a)

-- | Run the discard effects through the tree and reify them as
--   <a>Maybe</a> values at the nodes.
--   
--   <a>Nothing</a> means discarded, <a>Just</a> means we have a value.
runDiscardEffectT :: Monad m => TreeT (MaybeT m) a -> TreeT m (Maybe a)

-- | Scale a size using the golden ratio.
--   
--   <pre>
--   golden x = x / φ
--   golden x = x / 1.61803..
--   </pre>
golden :: Size -> Size

-- | Check that list contains at least a certain number of elements.
atLeast :: Int -> [a] -> Bool

-- | Check if a character is in the surrogate category.
isSurrogate :: Char -> Bool

-- | Check if a character is one of the noncharacters '65534', '65535'.
isNoncharacter :: Char -> Bool
data Vec n a
[Nil] :: Vec 'Z a
[:.] :: a -> Vec n a -> Vec ('S n) a
infixr 5 :.
data Nat
Z :: Nat
S :: Nat -> Nat

-- | Constructs a generator from a number of sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subtermMVec :: MonadGen m => Vec n (m a) -> (Vec n a -> m a) -> m a
instance Data.Traversable.Traversable (Hedgehog.Internal.Gen.Subterms n)
instance Data.Foldable.Foldable (Hedgehog.Internal.Gen.Subterms n)
instance GHC.Base.Functor (Hedgehog.Internal.Gen.Subterms n)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hedgehog.Internal.Gen.GenT m)
instance GHC.Base.Functor (Hedgehog.Internal.Gen.Vec n)
instance Data.Foldable.Foldable (Hedgehog.Internal.Gen.Vec n)
instance Data.Traversable.Traversable (Hedgehog.Internal.Gen.Vec n)
instance GHC.Base.Monad m => Hedgehog.Internal.Gen.MonadGen (Hedgehog.Internal.Gen.GenT m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Identity.IdentityT m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Maybe.MaybeT m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Except.ExceptT x m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Reader.ReaderT r m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.State.Lazy.StateT r m)
instance Hedgehog.Internal.Gen.MonadGen m => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.State.Strict.StateT r m)
instance (Hedgehog.Internal.Gen.MonadGen m, GHC.Base.Monoid w) => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Hedgehog.Internal.Gen.MonadGen m, GHC.Base.Monoid w) => Hedgehog.Internal.Gen.MonadGen (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monad m, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Hedgehog.Internal.Gen.GenT m a)
instance (GHC.Base.Monad m, GHC.Base.Monoid a) => GHC.Base.Monoid (Hedgehog.Internal.Gen.GenT m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Hedgehog.Internal.Gen.GenT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hedgehog.Internal.Gen.GenT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hedgehog.Internal.Gen.GenT m)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Hedgehog.Internal.Gen.GenT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Hedgehog.Internal.Gen.GenT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Trans.Class.MonadTrans Hedgehog.Internal.Gen.GenT
instance Control.Monad.Morph.MFunctor Hedgehog.Internal.Gen.GenT
instance Control.Monad.Morph.MMonad Hedgehog.Internal.Gen.GenT
instance Hedgehog.Internal.Distributive.MonadTransDistributive Hedgehog.Internal.Gen.GenT
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hedgehog.Internal.Gen.GenT m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Hedgehog.Internal.Gen.GenT m)

module Hedgehog.Internal.Property

-- | A property test, along with some configurable limits like how many
--   times to run the test.
data Property
Property :: !PropertyConfig -> PropertyT IO () -> Property
[propertyConfig] :: Property -> !PropertyConfig
[propertyTest] :: Property -> PropertyT IO ()

-- | The property monad transformer allows both the generation of test
--   inputs and the assertion of expectations.
newtype PropertyT m a
PropertyT :: TestT (GenT m) a -> PropertyT m a
[unPropertyT] :: PropertyT m a -> TestT (GenT m) a

-- | The name of a property.
--   
--   Should be constructed using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   "apples" :: PropertyName
--   </pre>
newtype PropertyName
PropertyName :: String -> PropertyName
[unPropertyName] :: PropertyName -> String

-- | Configuration for a property test.
data PropertyConfig
PropertyConfig :: !DiscardLimit -> !ShrinkLimit -> !ShrinkRetries -> !TerminationCriteria -> Maybe Skip -> PropertyConfig
[propertyDiscardLimit] :: PropertyConfig -> !DiscardLimit
[propertyShrinkLimit] :: PropertyConfig -> !ShrinkLimit
[propertyShrinkRetries] :: PropertyConfig -> !ShrinkRetries
[propertyTerminationCriteria] :: PropertyConfig -> !TerminationCriteria

-- | If this is <a>Nothing</a>, we take the Skip from the environment
--   variable <tt>HEDGEHOG_SKIP</tt>.
[propertySkip] :: PropertyConfig -> Maybe Skip

-- | The number of successful tests that need to be run before a property
--   test is considered successful.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   200 :: TestLimit
--   </pre>
newtype TestLimit
TestLimit :: Int -> TestLimit

-- | The number of tests a property ran successfully.
newtype TestCount
TestCount :: Int -> TestCount

-- | The number of discards to allow before giving up.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   10000 :: DiscardLimit
--   </pre>
newtype DiscardLimit
DiscardLimit :: Int -> DiscardLimit

-- | The number of tests a property had to discard.
newtype DiscardCount
DiscardCount :: Int -> DiscardCount

-- | The number of shrinks to try before giving up on shrinking.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   1000 :: ShrinkLimit
--   </pre>
newtype ShrinkLimit
ShrinkLimit :: Int -> ShrinkLimit

-- | The numbers of times a property was able to shrink after a failing
--   test.
newtype ShrinkCount
ShrinkCount :: Int -> ShrinkCount

-- | Where to start running a property's tests.
data Skip

-- | Don't skip anything.
SkipNothing :: Skip

-- | Skip to a specific test number. If it fails, shrink as normal. If it
--   passes, move on to the next test. Coverage checks are disabled.
--   
--   We also need to count discards, since failing "after 7 tests" points
--   at a different generated value than failing "after 7 tests and 5
--   discards".
SkipToTest :: TestCount -> DiscardCount -> Skip

-- | Skip to a specific test number and shrink state. If it fails, stop
--   without shrinking further. If it passes, the property will pass
--   without running any more tests.
--   
--   Due to implementation details, all intermediate shrink states - those
--   on the direct path from the original test input to the target state -
--   will be tested too, and their results discarded.
SkipToShrink :: TestCount -> DiscardCount -> ShrinkPath -> Skip

-- | The path taken to reach a shrink state.
newtype ShrinkPath
ShrinkPath :: [Int] -> ShrinkPath

-- | The number of times to re-run a test during shrinking. This is useful
--   if you are testing something which fails non-deterministically and you
--   want to increase the change of getting a good shrink.
--   
--   If you are doing parallel state machine testing, you should probably
--   set shrink retries to something like <tt>10</tt>. This will mean that
--   during shrinking, a parallel test case requires 10 successful runs
--   before it is passes and we try a different shrink.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   0 :: ShrinkRetries
--   </pre>
newtype ShrinkRetries
ShrinkRetries :: Int -> ShrinkRetries

-- | Set the number of times a property should be executed before it is
--   considered successful.
--   
--   If you have a test that does not involve any generators and thus does
--   not need to run repeatedly, you can use <tt>withTests 1</tt> to define
--   a property that will only be checked once.
withTests :: TestLimit -> Property -> Property

-- | Set the number of times a property is allowed to discard before the
--   test runner gives up.
withDiscards :: DiscardLimit -> Property -> Property

-- | Set the number of times a property is allowed to shrink before the
--   test runner gives up and prints the counterexample.
withShrinks :: ShrinkLimit -> Property -> Property

-- | Set the number of times a property will be executed for each shrink
--   before the test runner gives up and tries a different shrink. See
--   <a>ShrinkRetries</a> for more information.
withRetries :: ShrinkRetries -> Property -> Property

-- | Set the target that a property will skip to before it starts to run.
withSkip :: Skip -> Property -> Property

-- | Creates a property with the default configuration.
property :: HasCallStack => PropertyT IO () -> Property

-- | Lift a test in to a property.
--   
--   Because both <a>TestT</a> and <a>PropertyT</a> have <a>MonadTest</a>
--   instances, this function is not often required. It can however be
--   useful for writing functions directly in <a>TestT</a> and thus gaining
--   a <a>MonadTransControl</a> instance at the expense of not being able
--   to generate additional inputs using <a>forAll</a>.
--   
--   An example where this is useful is parallel state machine testing, as
--   <a>executeParallel</a> requires <a>MonadBaseControl</a> <a>IO</a> in
--   order to be able to spawn threads in <a>MonadTest</a>.
test :: Monad m => TestT m a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
forAll :: (Monad m, Show a, HasCallStack) => Gen a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
forAllT :: (Monad m, Show a, HasCallStack) => GenT m a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
--   
--   <i>This is a the same as <a>forAll</a> but allows the user to provide
--   a custom</i> <i>rendering function. This is useful for values which
--   don't have a</i> <i><a>Show</a> instance.</i>
forAllWith :: (Monad m, HasCallStack) => (a -> String) -> Gen a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
--   
--   <i>This is a the same as <a>forAllT</a> but allows the user to provide
--   a custom</i> <i>rendering function. This is useful for values which
--   don't have a</i> <i><a>Show</a> instance.</i>
forAllWithT :: (Monad m, HasCallStack) => (a -> String) -> GenT m a -> PropertyT m a

-- | The minimum amount of tests to run for a <a>Property</a>
defaultMinTests :: TestLimit

-- | Discards the current test entirely.
discard :: Monad m => PropertyT m a

-- | Compress a Skip into a hopefully-short alphanumeric string.
--   
--   The bit that might be long is the <a>ShrinkPath</a> in
--   <a>SkipToShrink</a>. For that, we encode the path components in base
--   26, alternating between uppercase and lowercase alphabets to
--   distinguish list elements. Additionally when we have runs of equal
--   components, we use the normal base 10 encoding to indicate the length.
--   
--   This gives something which is hopefully quite short, but a human can
--   roughly interpret it by eyeball.
skipCompress :: Skip -> String

-- | Compress a <a>ShrinkPath</a> into a hopefully-short alphanumeric
--   string.
--   
--   We encode the path components in base 26, alternating between
--   uppercase and lowercase alphabets to distinguish list elements.
--   Additionally when we have runs of equal components, we use the normal
--   base 10 encoding to indicate the length.
shrinkPathCompress :: ShrinkPath -> String

-- | Decompress a <a>Skip</a>.
--   
--   This satisfies
--   
--   <pre>
--   skipDecompress (skipCompress a) == Just a
--   </pre>
skipDecompress :: String -> Maybe Skip

-- | Decompress a <a>ShrinkPath</a>.
--   
--   This satisfies
--   
--   <pre>
--   shrinkPathDecompress (shrinkPathCompress a) == Just a
--   </pre>
shrinkPathDecompress :: String -> Maybe ShrinkPath

-- | A named collection of property tests.
data Group
Group :: !GroupName -> ![(PropertyName, Property)] -> Group
[groupName] :: Group -> !GroupName
[groupProperties] :: Group -> ![(PropertyName, Property)]

-- | The name of a group of properties.
--   
--   Should be constructed using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   "fruit" :: GroupName
--   </pre>
newtype GroupName
GroupName :: String -> GroupName
[unGroupName] :: GroupName -> String

-- | The number of properties in a group.
newtype PropertyCount
PropertyCount :: Int -> PropertyCount
class Monad m => MonadTest m
liftTest :: MonadTest m => Test a -> m a

-- | A test monad allows the assertion of expectations.
type Test = TestT Identity

-- | A test monad transformer allows the assertion of expectations.
newtype TestT m a
TestT :: ExceptT Failure (WriterT Journal m) a -> TestT m a
[unTest] :: TestT m a -> ExceptT Failure (WriterT Journal m) a

-- | Log messages which are recorded during a test run.
data Log
Annotation :: Maybe Span -> String -> Log
Footnote :: String -> Log
Label :: Label Cover -> Log

-- | A record containing the details of a test run.
newtype Journal
Journal :: [Log] -> Journal
[journalLogs] :: Journal -> [Log]

-- | Details on where and why a test failed.
data Failure
Failure :: Maybe Span -> String -> Maybe Diff -> Failure

-- | The difference between some expected and actual value.
data Diff
Diff :: String -> String -> String -> String -> String -> ValueDiff -> Diff
[diffPrefix] :: Diff -> String
[diffRemoved] :: Diff -> String
[diffInfix] :: Diff -> String
[diffAdded] :: Diff -> String
[diffSuffix] :: Diff -> String
[diffValue] :: Diff -> ValueDiff

-- | Annotates the source code with a message that might be useful for
--   debugging a test failure.
annotate :: (MonadTest m, HasCallStack) => String -> m ()

-- | Annotates the source code with a value that might be useful for
--   debugging a test failure.
annotateShow :: (MonadTest m, Show a, HasCallStack) => a -> m ()

-- | Logs a message to be displayed as additional information in the footer
--   of the failure report.
footnote :: MonadTest m => String -> m ()

-- | Logs a value to be displayed as additional information in the footer
--   of the failure report.
footnoteShow :: (MonadTest m, Show a) => a -> m ()

-- | Causes a test to fail.
failure :: (MonadTest m, HasCallStack) => m a

-- | Another name for <tt>pure ()</tt>.
success :: MonadTest m => m ()

-- | Fails the test if the condition provided is <a>False</a>.
assert :: (MonadTest m, HasCallStack) => Bool -> m ()

-- | Fails the test and shows a git-like diff if the comparison operation
--   evaluates to <a>False</a> when applied to its arguments.
--   
--   The comparison function is the second argument, which may be
--   counter-intuitive to Haskell programmers. However, it allows operators
--   to be written infix for easy reading:
--   
--   <pre>
--   diff y (&lt;) 87
--   diff x (&lt;=) <tt>r</tt>
--   </pre>
--   
--   This function behaves like the unix <tt>diff</tt> tool, which gives a
--   0 exit code if the compared files are identical, or a 1 exit code code
--   otherwise. Like unix <tt>diff</tt>, if the arguments fail the
--   comparison, a /diff is shown.
diff :: (MonadTest m, Show a, Show b, HasCallStack) => a -> (a -> b -> Bool) -> b -> m ()

-- | Fails the test if the two arguments provided are not equal.
(===) :: (MonadTest m, Eq a, Show a, HasCallStack) => a -> a -> m ()
infix 4 ===

-- | Fails the test if the two arguments provided are equal.
(/==) :: (MonadTest m, Eq a, Show a, HasCallStack) => a -> a -> m ()
infix 4 /==

-- | Fails the test if the value throws an exception when evaluated to weak
--   head normal form (WHNF).
eval :: (MonadTest m, HasCallStack) => a -> m a

-- | Fails the test if the value throws an exception when evaluated to
--   normal form (NF).
evalNF :: (MonadTest m, NFData a, HasCallStack) => a -> m a

-- | Fails the test if the action throws an exception.
--   
--   <i>The benefit of using this over simply letting the exception bubble
--   up is</i> <i>that the location of the closest <a>evalM</a> will be
--   shown in the output.</i>
evalM :: (MonadTest m, MonadCatch m, HasCallStack) => m a -> m a

-- | Fails the test if the <a>IO</a> action throws an exception.
--   
--   <i>The benefit of using this over <a>liftIO</a> is that the location
--   of the</i> <i>exception will be shown in the output.</i>
evalIO :: (MonadTest m, MonadIO m, HasCallStack) => IO a -> m a

-- | Fails the test if the <a>Either</a> is <a>Left</a>, otherwise returns
--   the value in the <a>Right</a>.
evalEither :: (MonadTest m, Show x, HasCallStack) => Either x a -> m a

-- | Fails the test if the action throws an exception, or if the
--   <a>Either</a> is <a>Left</a>, otherwise returns the value in the
--   <a>Right</a>.
evalEitherM :: (MonadTest m, Show x, MonadCatch m, HasCallStack) => m (Either x a) -> m a

-- | Fails the test if the <a>ExceptT</a> is <a>Left</a>, otherwise returns
--   the value in the <a>Right</a>.
evalExceptT :: (MonadTest m, Show x, HasCallStack) => ExceptT x m a -> m a

-- | Fails the test if the <a>Maybe</a> is <a>Nothing</a>, otherwise
--   returns the value in the <a>Just</a>.
evalMaybe :: (MonadTest m, HasCallStack) => Maybe a -> m a

-- | Fails the test if the action throws an exception, or if the
--   <a>Maybe</a> is <a>Nothing</a>, otherwise returns the value in the
--   <a>Just</a>.
evalMaybeM :: (MonadTest m, MonadCatch m, HasCallStack) => m (Maybe a) -> m a

-- | The extent to which all classifiers cover a test.
--   
--   <i>When a given classification's coverage does not exceed the
--   required</i> <i>minimum, the test will be failed.</i>
newtype Coverage a
Coverage :: Map LabelName (Label a) -> Coverage a
[coverageLabels] :: Coverage a -> Map LabelName (Label a)

-- | The extent to which a test is covered by a classifier.
--   
--   <i>When a classifier's coverage does not exceed the required minimum,
--   the</i> <i>test will be failed.</i>
data Label a
MkLabel :: !LabelName -> !Maybe Span -> !CoverPercentage -> !a -> Label a
[labelName] :: Label a -> !LabelName
[labelLocation] :: Label a -> !Maybe Span
[labelMinimum] :: Label a -> !CoverPercentage
[labelAnnotation] :: Label a -> !a

-- | The name of a classifier.
--   
--   Should be constructed using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   "apples" :: LabelName
--   </pre>
newtype LabelName
LabelName :: String -> LabelName
[unLabelName] :: LabelName -> String

-- | Require a certain percentage of the tests to be covered by the
--   classifier.
--   
--   <pre>
--   prop_with_coverage :: Property
--   prop_with_coverage =
--     property $ do
--       match &lt;- forAll Gen.bool
--       cover 30 "True" $ match
--       cover 30 "False" $ not match
--   </pre>
--   
--   The example above requires a minimum of 30% coverage for both
--   classifiers. If these requirements are not met, it will fail the test.
cover :: (MonadTest m, HasCallStack) => CoverPercentage -> LabelName -> Bool -> m ()

-- | Records the proportion of tests which satisfy a given condition.
--   
--   <pre>
--   prop_with_classifier :: Property
--   prop_with_classifier =
--     property $ do
--       xs &lt;- forAll $ Gen.list (Range.linear 0 100) Gen.alpha
--       for_ xs $ \x -&gt; do
--         classify "newborns" $ x == 0
--         classify "children" $ x &gt; 0 &amp;&amp; x &lt; 13
--         classify "teens" $ x &gt; 12 &amp;&amp; x &lt; 20
--   </pre>
classify :: (MonadTest m, HasCallStack) => LabelName -> Bool -> m ()

-- | Add a label for each test run. It produces a table showing the
--   percentage of test runs that produced each label.
label :: (MonadTest m, HasCallStack) => LabelName -> m ()

-- | Like <a>label</a>, but uses <a>Show</a> to render its argument for
--   display.
collect :: (MonadTest m, Show a, HasCallStack) => a -> m ()
coverPercentage :: TestCount -> CoverCount -> CoverPercentage
labelCovered :: TestCount -> Label CoverCount -> Bool

-- | All labels are covered
coverageSuccess :: TestCount -> Coverage CoverCount -> Bool
coverageFailures :: TestCount -> Coverage CoverCount -> [Label CoverCount]
journalCoverage :: Journal -> Coverage CoverCount

-- | Whether a test is covered by a classifier, and therefore belongs to a
--   <tt>Class</tt>.
data Cover
NoCover :: Cover
Cover :: Cover

-- | The total number of tests which are covered by a classifier.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   30 :: CoverCount
--   </pre>
newtype CoverCount
CoverCount :: Int -> CoverCount
[unCoverCount] :: CoverCount -> Int

-- | The relative number of tests which are covered by a classifier.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   30 :: CoverPercentage
--   </pre>
newtype CoverPercentage
CoverPercentage :: Double -> CoverPercentage
[unCoverPercentage] :: CoverPercentage -> Double
toCoverCount :: Cover -> CoverCount

-- | The acceptable occurrence of false positives
--   
--   Example, <tt>Confidence 10^9</tt> would mean that you'd accept a false
--   positive for 1 in 10^9 tests.
newtype Confidence
Confidence :: Int64 -> Confidence
[unConfidence] :: Confidence -> Int64
data TerminationCriteria
EarlyTermination :: Confidence -> TestLimit -> TerminationCriteria
NoEarlyTermination :: Confidence -> TestLimit -> TerminationCriteria
NoConfidenceTermination :: TestLimit -> TerminationCriteria

-- | Is true when the test coverage satisfies the specified
--   <a>Confidence</a> contstraint for all 'Coverage CoverCount's
confidenceSuccess :: TestCount -> Confidence -> Coverage CoverCount -> Bool

-- | Is true when there exists a label that is sure to have failed
--   according to the <a>Confidence</a> constraint
confidenceFailure :: TestCount -> Confidence -> Coverage CoverCount -> Bool

-- | Make sure that the result is statistically significant in accordance
--   to the passed <a>Confidence</a>
withConfidence :: Confidence -> Property -> Property
verifiedTermination :: Property -> Property

-- | The default confidence allows one false positive in 10^9 tests
defaultConfidence :: Confidence

-- | The default configuration for a property test.
defaultConfig :: PropertyConfig

-- | Map a config modification function over a property.
mapConfig :: (PropertyConfig -> PropertyConfig) -> Property -> Property

-- | Fails with an error that shows the difference between two values.
failDiff :: (MonadTest m, Show a, Show b, HasCallStack) => a -> b -> m ()

-- | Fails with an error which renders the type of an exception and its
--   error message.
failException :: (MonadTest m, HasCallStack) => SomeException -> m a

-- | Fail the test with an error message, useful for building other failure
--   combinators.
failWith :: (MonadTest m, HasCallStack) => Maybe Diff -> String -> m a

-- | Log some information which might be relevant to a potential test
--   failure.
writeLog :: MonadTest m => Log -> m ()
mkTest :: (Either Failure a, Journal) -> Test a
mkTestT :: m (Either Failure a, Journal) -> TestT m a
runTest :: Test a -> (Either Failure a, Journal)
runTestT :: TestT m a -> m (Either Failure a, Journal)
wilsonBounds :: Integer -> Integer -> Double -> (Double, Double)
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.PropertyName
instance GHC.Base.Semigroup Hedgehog.Internal.Property.PropertyName
instance Data.String.IsString Hedgehog.Internal.Property.PropertyName
instance GHC.Show.Show Hedgehog.Internal.Property.PropertyName
instance GHC.Classes.Ord Hedgehog.Internal.Property.PropertyName
instance GHC.Classes.Eq Hedgehog.Internal.Property.PropertyName
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.Confidence
instance GHC.Num.Num Hedgehog.Internal.Property.Confidence
instance GHC.Show.Show Hedgehog.Internal.Property.Confidence
instance GHC.Classes.Ord Hedgehog.Internal.Property.Confidence
instance GHC.Classes.Eq Hedgehog.Internal.Property.Confidence
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.TestLimit
instance GHC.Real.Integral Hedgehog.Internal.Property.TestLimit
instance GHC.Real.Real Hedgehog.Internal.Property.TestLimit
instance GHC.Enum.Enum Hedgehog.Internal.Property.TestLimit
instance GHC.Num.Num Hedgehog.Internal.Property.TestLimit
instance GHC.Show.Show Hedgehog.Internal.Property.TestLimit
instance GHC.Classes.Ord Hedgehog.Internal.Property.TestLimit
instance GHC.Classes.Eq Hedgehog.Internal.Property.TestLimit
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.TestCount
instance GHC.Real.Integral Hedgehog.Internal.Property.TestCount
instance GHC.Real.Real Hedgehog.Internal.Property.TestCount
instance GHC.Enum.Enum Hedgehog.Internal.Property.TestCount
instance GHC.Num.Num Hedgehog.Internal.Property.TestCount
instance GHC.Classes.Ord Hedgehog.Internal.Property.TestCount
instance GHC.Classes.Eq Hedgehog.Internal.Property.TestCount
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.DiscardCount
instance GHC.Real.Integral Hedgehog.Internal.Property.DiscardCount
instance GHC.Real.Real Hedgehog.Internal.Property.DiscardCount
instance GHC.Enum.Enum Hedgehog.Internal.Property.DiscardCount
instance GHC.Num.Num Hedgehog.Internal.Property.DiscardCount
instance GHC.Show.Show Hedgehog.Internal.Property.DiscardCount
instance GHC.Classes.Ord Hedgehog.Internal.Property.DiscardCount
instance GHC.Classes.Eq Hedgehog.Internal.Property.DiscardCount
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.DiscardLimit
instance GHC.Real.Integral Hedgehog.Internal.Property.DiscardLimit
instance GHC.Real.Real Hedgehog.Internal.Property.DiscardLimit
instance GHC.Enum.Enum Hedgehog.Internal.Property.DiscardLimit
instance GHC.Num.Num Hedgehog.Internal.Property.DiscardLimit
instance GHC.Show.Show Hedgehog.Internal.Property.DiscardLimit
instance GHC.Classes.Ord Hedgehog.Internal.Property.DiscardLimit
instance GHC.Classes.Eq Hedgehog.Internal.Property.DiscardLimit
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Real.Integral Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Real.Real Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Enum.Enum Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Num.Num Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Show.Show Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Classes.Ord Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Classes.Eq Hedgehog.Internal.Property.ShrinkLimit
instance GHC.Real.Integral Hedgehog.Internal.Property.ShrinkCount
instance GHC.Real.Real Hedgehog.Internal.Property.ShrinkCount
instance GHC.Enum.Enum Hedgehog.Internal.Property.ShrinkCount
instance GHC.Num.Num Hedgehog.Internal.Property.ShrinkCount
instance GHC.Show.Show Hedgehog.Internal.Property.ShrinkCount
instance GHC.Classes.Ord Hedgehog.Internal.Property.ShrinkCount
instance GHC.Classes.Eq Hedgehog.Internal.Property.ShrinkCount
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.ShrinkPath
instance GHC.Show.Show Hedgehog.Internal.Property.ShrinkPath
instance GHC.Classes.Ord Hedgehog.Internal.Property.ShrinkPath
instance GHC.Classes.Eq Hedgehog.Internal.Property.ShrinkPath
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.Skip
instance GHC.Show.Show Hedgehog.Internal.Property.Skip
instance GHC.Classes.Ord Hedgehog.Internal.Property.Skip
instance GHC.Classes.Eq Hedgehog.Internal.Property.Skip
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Real.Integral Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Real.Real Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Enum.Enum Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Num.Num Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Show.Show Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Classes.Ord Hedgehog.Internal.Property.ShrinkRetries
instance GHC.Classes.Eq Hedgehog.Internal.Property.ShrinkRetries
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.GroupName
instance GHC.Base.Semigroup Hedgehog.Internal.Property.GroupName
instance Data.String.IsString Hedgehog.Internal.Property.GroupName
instance GHC.Show.Show Hedgehog.Internal.Property.GroupName
instance GHC.Classes.Ord Hedgehog.Internal.Property.GroupName
instance GHC.Classes.Eq Hedgehog.Internal.Property.GroupName
instance GHC.Real.Integral Hedgehog.Internal.Property.PropertyCount
instance GHC.Real.Real Hedgehog.Internal.Property.PropertyCount
instance GHC.Enum.Enum Hedgehog.Internal.Property.PropertyCount
instance GHC.Num.Num Hedgehog.Internal.Property.PropertyCount
instance GHC.Show.Show Hedgehog.Internal.Property.PropertyCount
instance GHC.Classes.Ord Hedgehog.Internal.Property.PropertyCount
instance GHC.Classes.Eq Hedgehog.Internal.Property.PropertyCount
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.TerminationCriteria
instance GHC.Show.Show Hedgehog.Internal.Property.TerminationCriteria
instance GHC.Classes.Ord Hedgehog.Internal.Property.TerminationCriteria
instance GHC.Classes.Eq Hedgehog.Internal.Property.TerminationCriteria
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Property.PropertyConfig
instance GHC.Show.Show Hedgehog.Internal.Property.PropertyConfig
instance GHC.Classes.Ord Hedgehog.Internal.Property.PropertyConfig
instance GHC.Classes.Eq Hedgehog.Internal.Property.PropertyConfig
instance GHC.Show.Show Hedgehog.Internal.Property.Diff
instance GHC.Classes.Eq Hedgehog.Internal.Property.Diff
instance GHC.Show.Show Hedgehog.Internal.Property.Failure
instance GHC.Classes.Eq Hedgehog.Internal.Property.Failure
instance GHC.Show.Show Hedgehog.Internal.Property.Cover
instance GHC.Classes.Ord Hedgehog.Internal.Property.Cover
instance GHC.Classes.Eq Hedgehog.Internal.Property.Cover
instance GHC.Num.Num Hedgehog.Internal.Property.CoverCount
instance GHC.Show.Show Hedgehog.Internal.Property.CoverCount
instance GHC.Classes.Ord Hedgehog.Internal.Property.CoverCount
instance GHC.Classes.Eq Hedgehog.Internal.Property.CoverCount
instance GHC.Real.Fractional Hedgehog.Internal.Property.CoverPercentage
instance GHC.Num.Num Hedgehog.Internal.Property.CoverPercentage
instance GHC.Show.Show Hedgehog.Internal.Property.CoverPercentage
instance GHC.Classes.Ord Hedgehog.Internal.Property.CoverPercentage
instance GHC.Classes.Eq Hedgehog.Internal.Property.CoverPercentage
instance Data.String.IsString Hedgehog.Internal.Property.LabelName
instance GHC.Show.Show Hedgehog.Internal.Property.LabelName
instance GHC.Base.Semigroup Hedgehog.Internal.Property.LabelName
instance GHC.Classes.Ord Hedgehog.Internal.Property.LabelName
instance GHC.Base.Monoid Hedgehog.Internal.Property.LabelName
instance GHC.Classes.Eq Hedgehog.Internal.Property.LabelName
instance Data.Traversable.Traversable Hedgehog.Internal.Property.Label
instance Data.Foldable.Foldable Hedgehog.Internal.Property.Label
instance GHC.Base.Functor Hedgehog.Internal.Property.Label
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Property.Label a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Property.Label a)
instance GHC.Show.Show Hedgehog.Internal.Property.Log
instance GHC.Classes.Eq Hedgehog.Internal.Property.Log
instance GHC.Base.Monoid Hedgehog.Internal.Property.Journal
instance GHC.Base.Semigroup Hedgehog.Internal.Property.Journal
instance GHC.Show.Show Hedgehog.Internal.Property.Journal
instance GHC.Classes.Eq Hedgehog.Internal.Property.Journal
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hedgehog.Internal.Property.TestT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hedgehog.Internal.Property.TestT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hedgehog.Internal.Property.PropertyT m)
instance Data.Traversable.Traversable Hedgehog.Internal.Property.Coverage
instance Data.Foldable.Foldable Hedgehog.Internal.Property.Coverage
instance GHC.Base.Functor Hedgehog.Internal.Property.Coverage
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Property.Coverage a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Property.Coverage a)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Monad m => Hedgehog.Internal.Property.MonadTest (Hedgehog.Internal.Property.TestT m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Identity.IdentityT m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Maybe.MaybeT m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Except.ExceptT x m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Reader.ReaderT r m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.State.Lazy.StateT s m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.State.Strict.StateT s m)
instance (Hedgehog.Internal.Property.MonadTest m, GHC.Base.Monoid w) => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Hedgehog.Internal.Property.MonadTest m, GHC.Base.Monoid w) => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Hedgehog.Internal.Property.MonadTest m, GHC.Base.Monoid w) => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Hedgehog.Internal.Property.MonadTest m, GHC.Base.Monoid w) => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Cont.ContT r m)
instance Hedgehog.Internal.Property.MonadTest m => Hedgehog.Internal.Property.MonadTest (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance GHC.Base.Monad m => Hedgehog.Internal.Property.MonadTest (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Hedgehog.Internal.Property.Coverage a)
instance (GHC.Base.Semigroup a, GHC.Base.Monoid a) => GHC.Base.Monoid (Hedgehog.Internal.Property.Coverage a)
instance Control.Monad.Trans.Class.MonadTrans Hedgehog.Internal.Property.PropertyT
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.Morph.MFunctor Hedgehog.Internal.Property.PropertyT
instance Hedgehog.Internal.Distributive.MonadTransDistributive Hedgehog.Internal.Property.PropertyT
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hedgehog.Internal.Property.TestT m)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Trans.Class.MonadTrans Hedgehog.Internal.Property.TestT
instance Control.Monad.Morph.MFunctor Hedgehog.Internal.Property.TestT
instance Hedgehog.Internal.Distributive.MonadTransDistributive Hedgehog.Internal.Property.TestT
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Hedgehog.Internal.Property.TestT m)
instance Control.Monad.Trans.Control.MonadTransControl Hedgehog.Internal.Property.TestT
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hedgehog.Internal.Property.TestT m)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Hedgehog.Internal.Property.Label a)
instance GHC.Base.Semigroup Hedgehog.Internal.Property.CoverCount
instance GHC.Base.Monoid Hedgehog.Internal.Property.CoverCount
instance GHC.Base.Semigroup Hedgehog.Internal.Property.Cover
instance GHC.Base.Monoid Hedgehog.Internal.Property.Cover
instance Data.String.IsString Hedgehog.Internal.Property.Skip
instance GHC.Show.Show Hedgehog.Internal.Property.TestCount

module Hedgehog.Internal.Tripping

-- | Test that a pair of encode / decode functions are compatible.
--   
--   Given a printer from some type <tt>a -&gt; b</tt>, and a parser with a
--   potential failure case <tt>b -&gt; f a</tt>. Ensure that a valid
--   <tt>a</tt> round trips through the "print" and "parse" to yield the
--   same <tt>a</tt>.
--   
--   For example, types <i>should</i> have tripping <a>Read</a> and
--   <a>Show</a> instances:
--   
--   <pre>
--   trippingShowRead :: (Show a, Read a, Eq a, MonadTest m) =&gt; a -&gt; m ()
--   trippingShowRead a = tripping a show readEither
--   </pre>
tripping :: (MonadTest m, Applicative f, Show b, Show (f a), Eq (f a), HasCallStack) => a -> (a -> b) -> (b -> f a) -> m ()

module Hedgehog.Internal.State

-- | Variables are the potential or actual result of executing an action.
--   They are parameterised by either <a>Symbolic</a> or <a>Concrete</a>
--   depending on the phase of the test.
--   
--   <a>Symbolic</a> variables are the potential results of actions. These
--   are used when generating the sequence of actions to execute. They
--   allow actions which occur later in the sequence to make use of the
--   result of an action which came earlier in the sequence.
--   
--   <a>Concrete</a> variables are the actual results of actions. These are
--   used during test execution. They provide access to the actual runtime
--   value of a variable.
--   
--   The state update <a>Callback</a> for a command needs to be polymorphic
--   in the type of variable because it is used in both the generation and
--   the execution phase.
--   
--   The order of arguments makes <a>Var</a> <a>FunctorB</a> and
--   <a>TraversableB</a>, which is how <a>Symbolic</a> values are turned
--   into <a>Concrete</a> ones.
newtype Var a v
Var :: v a -> Var a v

-- | Take the value from a concrete variable.
concrete :: Var a Concrete -> a

-- | Take the value from an opaque concrete variable.
opaque :: Var (Opaque a) Concrete -> a

-- | Concrete values: At test-execution time, <a>Symbolic</a> values from
--   generation are replaced with <a>Concrete</a> values from performing
--   actions. This type gives us something of the same kind as
--   <a>Symbolic</a> to pass as a type argument to <a>Var</a>.
newtype Concrete a
[Concrete] :: a -> Concrete a

-- | Symbolic values: Because hedgehog generates actions in a separate
--   phase before execution, you will sometimes need to refer to the result
--   of a previous action in a generator without knowing the value of the
--   result (e.g., to get the ID of a previously-created user).
--   
--   Symbolic variables provide a token to stand in for the actual
--   variables at generation time (and in <a>Require</a>/<a>Update</a>
--   callbacks). At execution time, real values are available, so your
--   execute actions work on <a>Concrete</a> variables.
--   
--   See also: <a>Command</a>, <a>Var</a>
data Symbolic a
[Symbolic] :: Typeable a => Name -> Symbolic a

-- | Symbolic variable names.
newtype Name
Name :: Int -> Name

-- | A mapping of symbolic values to concrete values.
newtype Environment
Environment :: Map Name Dynamic -> Environment
[unEnvironment] :: Environment -> Map Name Dynamic

-- | Environment errors.
data EnvironmentError
EnvironmentValueNotFound :: !Name -> EnvironmentError
EnvironmentTypeError :: !TypeRep -> !TypeRep -> EnvironmentError

-- | Create an empty environment.
emptyEnvironment :: Environment

-- | Insert a symbolic / concrete pairing in to the environment.
insertConcrete :: Symbolic a -> Concrete a -> Environment -> Environment

-- | Cast a <a>Dynamic</a> in to a concrete value.
reifyDynamic :: forall a. Typeable a => Dynamic -> Either EnvironmentError (Concrete a)

-- | Turns an environment in to a function for looking up a concrete value
--   from a symbolic one.
reifyEnvironment :: Environment -> forall a. Symbolic a -> Either EnvironmentError (Concrete a)

-- | Convert a symbolic structure to a concrete one, using the provided
--   environment.
reify :: TraversableB t => Environment -> t Symbolic -> Either EnvironmentError (t Concrete)

-- | The specification for the expected behaviour of an <a>Action</a>.
--   These are used to generate sequences of actions to test.
--   
--   This is the main type you will use when writing state machine tests.
--   <tt>gen</tt> is usually an instance of <a>MonadGen</a>, and <tt>m</tt>
--   is usually an instance of <a>MonadTest</a>. These constraints appear
--   when you pass your <a>Command</a> list to <a>sequential</a> or
--   <a>parallel</a>.
data Command gen m (state :: (Type -> Type) -> Type)
Command :: (state Symbolic -> Maybe (gen (input Symbolic))) -> (input Concrete -> m output) -> [Callback input output state] -> Command gen m (state :: (Type -> Type) -> Type)

-- | A generator which provides random arguments for a command. If the
--   command cannot be executed in the current state, it should return
--   <a>Nothing</a>.
[commandGen] :: Command gen m (state :: (Type -> Type) -> Type) -> state Symbolic -> Maybe (gen (input Symbolic))

-- | Executes a command using the arguments generated by <a>commandGen</a>.
[commandExecute] :: Command gen m (state :: (Type -> Type) -> Type) -> input Concrete -> m output

-- | A set of callbacks which provide optional command configuration such
--   as pre-condtions, post-conditions and state updates.
[commandCallbacks] :: Command gen m (state :: (Type -> Type) -> Type) -> [Callback input output state]

-- | Optional command configuration.
data Callback input output state

-- | A pre-condition for a command that must be verified before the command
--   can be executed. This is mainly used during shrinking to ensure that
--   it is still OK to run a command despite the fact that some previously
--   executed commands may have been removed from the sequence.
Require :: (state Symbolic -> input Symbolic -> Bool) -> Callback input output state

-- | Updates the model state, given the input and output of the command.
--   Note that this function is polymorphic in the type of values. This is
--   because it must work over <a>Symbolic</a> values when we are
--   generating actions, and <a>Concrete</a> values when we are executing
--   them.
Update :: (forall v. Ord1 v => state v -> input v -> Var output v -> state v) -> Callback input output state

-- | A post-condition for a command that must be verified for the command
--   to be considered a success.
--   
--   This callback receives the state prior to execution as the first
--   argument, and the state after execution as the second argument.
Ensure :: (state Concrete -> state Concrete -> input Concrete -> output -> Test ()) -> Callback input output state

-- | Checks that input for a command can be executed in the given state.
commandGenOK :: Command gen m state -> state Symbolic -> Bool

-- | An instantiation of a <a>Command</a> which can be executed, and its
--   effect evaluated.
data Action m (state :: (Type -> Type) -> Type)
Action :: input Symbolic -> Symbolic output -> (input Concrete -> m output) -> (state Symbolic -> input Symbolic -> Bool) -> (forall v. Ord1 v => state v -> input v -> Var output v -> state v) -> (state Concrete -> state Concrete -> input Concrete -> output -> Test ()) -> Action m (state :: (Type -> Type) -> Type)
[actionInput] :: Action m (state :: (Type -> Type) -> Type) -> input Symbolic
[actionOutput] :: Action m (state :: (Type -> Type) -> Type) -> Symbolic output
[actionExecute] :: Action m (state :: (Type -> Type) -> Type) -> input Concrete -> m output
[actionRequire] :: Action m (state :: (Type -> Type) -> Type) -> state Symbolic -> input Symbolic -> Bool
[actionUpdate] :: Action m (state :: (Type -> Type) -> Type) -> forall v. Ord1 v => state v -> input v -> Var output v -> state v
[actionEnsure] :: Action m (state :: (Type -> Type) -> Type) -> state Concrete -> state Concrete -> input Concrete -> output -> Test ()

-- | A sequence of actions to execute.
newtype Sequential m state
Sequential :: [Action m state] -> Sequential m state

-- | The sequence of actions.
[sequentialActions] :: Sequential m state -> [Action m state]

-- | A sequential prefix of actions to execute, with two branches to
--   execute in parallel.
data Parallel m state
Parallel :: [Action m state] -> [Action m state] -> [Action m state] -> Parallel m state

-- | The sequential prefix.
[parallelPrefix] :: Parallel m state -> [Action m state]

-- | The first branch.
[parallelBranch1] :: Parallel m state -> [Action m state]

-- | The second branch.
[parallelBranch2] :: Parallel m state -> [Action m state]

-- | Collects all the symbolic values in a data structure and produces a
--   set of all the variables they refer to.
takeVariables :: forall t. TraversableB t => t Symbolic -> Map Name TypeRep

-- | Checks that the symbolic values in the data structure refer only to
--   the variables in the provided set, and that they are of the correct
--   type.
variablesOK :: TraversableB t => t Symbolic -> Map Name TypeRep -> Bool

-- | Drops invalid actions from the sequence.
dropInvalid :: [Action m state] -> State (Context state) [Action m state]

-- | Generates a single action from a set of possible commands.
action :: (MonadGen gen, MonadTest m) => [Command gen m state] -> GenT (StateT (Context state) (GenBase gen)) (Action m state)

-- | Generates a sequence of actions from an initial model state and set of
--   commands.
sequential :: (MonadGen gen, MonadTest m) => Range Int -> (forall v. state v) -> [Command gen m state] -> gen (Sequential m state)

-- | Given the initial model state and set of commands, generates prefix
--   actions to be run sequentially, followed by two branches to be run in
--   parallel.
parallel :: (MonadGen gen, MonadTest m) => Range Int -> Range Int -> (forall v. state v) -> [Command gen m state] -> gen (Parallel m state)

-- | Executes a list of actions sequentially, verifying that all
--   post-conditions are met and no exceptions are thrown.
--   
--   To generate a sequence of actions to execute, see the
--   <a>sequential</a> combinator in the <a>Hedgehog.Gen</a> module.
executeSequential :: (MonadTest m, MonadCatch m, HasCallStack) => (forall v. state v) -> Sequential m state -> m ()

-- | Executes the prefix actions sequentially, then executes the two
--   branches in parallel, verifying that no exceptions are thrown and that
--   there is at least one sequential interleaving where all the
--   post-conditions are met.
--   
--   To generate parallel actions to execute, see the <a>parallel</a>
--   combinator in the <a>Hedgehog.Gen</a> module.
executeParallel :: (MonadTest m, MonadCatch m, MonadBaseControl IO m, HasCallStack) => (forall v. state v) -> Parallel m state -> m ()
instance GHC.Num.Num Hedgehog.Internal.State.Name
instance GHC.Classes.Ord Hedgehog.Internal.State.Name
instance GHC.Classes.Eq Hedgehog.Internal.State.Name
instance Data.Traversable.Traversable Hedgehog.Internal.State.Concrete
instance Data.Foldable.Foldable Hedgehog.Internal.State.Concrete
instance GHC.Base.Functor Hedgehog.Internal.State.Concrete
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.State.Concrete a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.State.Concrete a)
instance GHC.Show.Show Hedgehog.Internal.State.Environment
instance GHC.Show.Show Hedgehog.Internal.State.EnvironmentError
instance GHC.Classes.Ord Hedgehog.Internal.State.EnvironmentError
instance GHC.Classes.Eq Hedgehog.Internal.State.EnvironmentError
instance GHC.Classes.Eq (Hedgehog.Internal.State.Symbolic a)
instance GHC.Classes.Ord (Hedgehog.Internal.State.Symbolic a)
instance GHC.Show.Show (Hedgehog.Internal.State.Parallel m state)
instance GHC.Show.Show (Hedgehog.Internal.State.Sequential m state)
instance GHC.Show.Show (Hedgehog.Internal.State.Action m state)
instance (GHC.Classes.Eq a, Data.Functor.Classes.Eq1 v) => GHC.Classes.Eq (Hedgehog.Internal.State.Var a v)
instance (GHC.Classes.Ord a, Data.Functor.Classes.Ord1 v) => GHC.Classes.Ord (Hedgehog.Internal.State.Var a v)
instance (GHC.Show.Show a, Data.Functor.Classes.Show1 v) => GHC.Show.Show (Hedgehog.Internal.State.Var a v)
instance Barbies.Internal.FunctorB.FunctorB (Hedgehog.Internal.State.Var a)
instance Barbies.Internal.TraversableB.TraversableB (Hedgehog.Internal.State.Var a)
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.State.Concrete a)
instance Data.Functor.Classes.Show1 Hedgehog.Internal.State.Concrete
instance Data.Functor.Classes.Eq1 Hedgehog.Internal.State.Concrete
instance Data.Functor.Classes.Ord1 Hedgehog.Internal.State.Concrete
instance GHC.Show.Show (Hedgehog.Internal.State.Symbolic a)
instance Data.Functor.Classes.Show1 Hedgehog.Internal.State.Symbolic
instance Data.Functor.Classes.Eq1 Hedgehog.Internal.State.Symbolic
instance Data.Functor.Classes.Ord1 Hedgehog.Internal.State.Symbolic
instance GHC.Show.Show Hedgehog.Internal.State.Name

module Hedgehog.Internal.Discovery
newtype PropertySource
PropertySource :: Pos String -> PropertySource
[propertySource] :: PropertySource -> Pos String
readProperties :: MonadIO m => String -> FilePath -> m (Map PropertyName PropertySource)
findProperties :: String -> FilePath -> String -> Map PropertyName PropertySource
readDeclaration :: MonadIO m => FilePath -> LineNo -> m (Maybe (String, Pos String))
data Pos a
Pos :: !Position -> a -> Pos a
[posPostion] :: Pos a -> !Position
[posValue] :: Pos a -> a
data Position
Position :: !FilePath -> !LineNo -> !ColumnNo -> Position
[_posPath] :: Position -> !FilePath
[posLine] :: Position -> !LineNo
[posColumn] :: Position -> !ColumnNo
instance GHC.Show.Show Hedgehog.Internal.Discovery.Class
instance GHC.Classes.Ord Hedgehog.Internal.Discovery.Class
instance GHC.Classes.Eq Hedgehog.Internal.Discovery.Class
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Discovery.Classified a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.Discovery.Classified a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Discovery.Classified a)
instance GHC.Show.Show Hedgehog.Internal.Discovery.Position
instance GHC.Classes.Ord Hedgehog.Internal.Discovery.Position
instance GHC.Classes.Eq Hedgehog.Internal.Discovery.Position
instance GHC.Base.Functor Hedgehog.Internal.Discovery.Pos
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Discovery.Pos a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.Discovery.Pos a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Discovery.Pos a)
instance GHC.Show.Show Hedgehog.Internal.Discovery.PropertySource
instance GHC.Classes.Ord Hedgehog.Internal.Discovery.PropertySource
instance GHC.Classes.Eq Hedgehog.Internal.Discovery.PropertySource
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Hedgehog.Internal.Discovery.Pos a)

module Hedgehog.Internal.TH
type TExpQ a = CodeQ a

-- | Discover all the properties in a module.
--   
--   Functions starting with <tt>prop_</tt> are assumed to be properties.
discover :: TExpQ Group
discoverPrefix :: String -> TExpQ Group

module Hedgehog.Internal.Config

-- | Whether to render output using ANSI colors or not.
data UseColor

-- | Disable ANSI colors in report output.
DisableColor :: UseColor

-- | Enable ANSI colors in report output.
EnableColor :: UseColor
resolveColor :: MonadIO m => Maybe UseColor -> m UseColor

-- | A splittable random number generator.
data Seed
Seed :: !Word64 -> !Word64 -> Seed
[seedValue] :: Seed -> !Word64

-- | must be an odd number
[seedGamma] :: Seed -> !Word64
resolveSeed :: MonadIO m => Maybe Seed -> m Seed

-- | How verbose should the report output be.
data Verbosity

-- | Only display the summary of the test run.
Quiet :: Verbosity

-- | Display each property as it is running, as well as the summary.
Normal :: Verbosity
resolveVerbosity :: MonadIO m => Maybe Verbosity -> m Verbosity

-- | The number of workers to use when running properties in parallel.
newtype WorkerCount
WorkerCount :: Int -> WorkerCount
resolveWorkers :: MonadIO m => Maybe WorkerCount -> m WorkerCount

-- | Where to start running a property's tests.
data Skip

-- | Don't skip anything.
SkipNothing :: Skip

-- | Skip to a specific test number. If it fails, shrink as normal. If it
--   passes, move on to the next test. Coverage checks are disabled.
--   
--   We also need to count discards, since failing "after 7 tests" points
--   at a different generated value than failing "after 7 tests and 5
--   discards".
SkipToTest :: TestCount -> DiscardCount -> Skip

-- | Skip to a specific test number and shrink state. If it fails, stop
--   without shrinking further. If it passes, the property will pass
--   without running any more tests.
--   
--   Due to implementation details, all intermediate shrink states - those
--   on the direct path from the original test input to the target state -
--   will be tested too, and their results discarded.
SkipToShrink :: TestCount -> DiscardCount -> ShrinkPath -> Skip
resolveSkip :: MonadIO m => Maybe Skip -> m Skip
detectMark :: MonadIO m => m Bool
detectColor :: MonadIO m => m UseColor
detectSeed :: MonadIO m => m Seed
detectVerbosity :: MonadIO m => m Verbosity
detectWorkers :: MonadIO m => m WorkerCount
detectSkip :: MonadIO m => m Skip
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Config.UseColor
instance GHC.Show.Show Hedgehog.Internal.Config.UseColor
instance GHC.Classes.Ord Hedgehog.Internal.Config.UseColor
instance GHC.Classes.Eq Hedgehog.Internal.Config.UseColor
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Config.Verbosity
instance GHC.Show.Show Hedgehog.Internal.Config.Verbosity
instance GHC.Classes.Ord Hedgehog.Internal.Config.Verbosity
instance GHC.Classes.Eq Hedgehog.Internal.Config.Verbosity
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Config.WorkerCount
instance GHC.Real.Integral Hedgehog.Internal.Config.WorkerCount
instance GHC.Real.Real Hedgehog.Internal.Config.WorkerCount
instance GHC.Enum.Enum Hedgehog.Internal.Config.WorkerCount
instance GHC.Num.Num Hedgehog.Internal.Config.WorkerCount
instance GHC.Show.Show Hedgehog.Internal.Config.WorkerCount
instance GHC.Classes.Ord Hedgehog.Internal.Config.WorkerCount
instance GHC.Classes.Eq Hedgehog.Internal.Config.WorkerCount

module Hedgehog.Internal.Report

-- | A summary of all the properties executed.
data Summary
Summary :: !PropertyCount -> !PropertyCount -> !PropertyCount -> !PropertyCount -> !PropertyCount -> Summary
[summaryWaiting] :: Summary -> !PropertyCount
[summaryRunning] :: Summary -> !PropertyCount
[summaryFailed] :: Summary -> !PropertyCount
[summaryGaveUp] :: Summary -> !PropertyCount
[summaryOK] :: Summary -> !PropertyCount

-- | A report on a running or completed property test.
data Report a
Report :: !TestCount -> !DiscardCount -> !Coverage CoverCount -> !Seed -> !a -> Report a
[reportTests] :: Report a -> !TestCount
[reportDiscards] :: Report a -> !DiscardCount
[reportCoverage] :: Report a -> !Coverage CoverCount
[reportSeed] :: Report a -> !Seed
[reportStatus] :: Report a -> !a

-- | The status of a running property test.
data Progress
Running :: Progress
Shrinking :: !FailureReport -> Progress

-- | The status of a completed property test.
--   
--   In the case of a failure it provides the seed used for the test, the
--   number of shrinks, and the execution log.
data Result
Failed :: !FailureReport -> Result
GaveUp :: Result
OK :: Result
data FailureReport
FailureReport :: !ShrinkCount -> !ShrinkPath -> !Maybe (Coverage CoverCount) -> ![FailedAnnotation] -> !Maybe Span -> !String -> !Maybe Diff -> ![String] -> FailureReport
[failureShrinks] :: FailureReport -> !ShrinkCount
[failureShrinkPath] :: FailureReport -> !ShrinkPath
[failureCoverage] :: FailureReport -> !Maybe (Coverage CoverCount)
[failureAnnotations] :: FailureReport -> ![FailedAnnotation]
[failureLocation] :: FailureReport -> !Maybe Span
[failureMessage] :: FailureReport -> !String
[failureDiff] :: FailureReport -> !Maybe Diff
[failureFootnotes] :: FailureReport -> ![String]
data FailedAnnotation
FailedAnnotation :: !Maybe Span -> !String -> FailedAnnotation
[failedSpan] :: FailedAnnotation -> !Maybe Span
[failedValue] :: FailedAnnotation -> !String
data Style
StyleDefault :: Style
StyleAnnotation :: Style
StyleFailure :: Style
data Markup
WaitingIcon :: Markup
WaitingHeader :: Markup
RunningIcon :: Markup
RunningHeader :: Markup
ShrinkingIcon :: Markup
ShrinkingHeader :: Markup
FailedIcon :: Markup
FailedText :: Markup
GaveUpIcon :: Markup
GaveUpText :: Markup
SuccessIcon :: Markup
SuccessText :: Markup
CoverageIcon :: Markup
CoverageText :: Markup
CoverageFill :: Markup
DeclarationLocation :: Markup
StyledLineNo :: !Style -> Markup
StyledBorder :: !Style -> Markup
StyledSource :: !Style -> Markup
AnnotationGutter :: Markup
AnnotationValue :: Markup
FailureArrows :: Markup
FailureGutter :: Markup
FailureMessage :: Markup
DiffPrefix :: Markup
DiffInfix :: Markup
DiffSuffix :: Markup
DiffSame :: Markup
DiffRemoved :: Markup
DiffAdded :: Markup
ReproduceHeader :: Markup
ReproduceGutter :: Markup
ReproduceSource :: Markup
data Config
Config :: Context -> Bool -> Bool -> Bool -> PrintPrefixIcons -> Config
[configContext] :: Config -> Context
[configPrintFailedAtLocation] :: Config -> Bool
[configPrintShrinkPath] :: Config -> Bool
[configPrintReproduceMessage] :: Config -> Bool
[configPrintPrefixIcons] :: Config -> PrintPrefixIcons
defaultConfig :: Config
data Context
FullContext :: Context
Context :: Lines -> Context
data Lines

-- | Whether to add icons to the start of important output lines or not.
data PrintPrefixIcons

-- | Do not add icons to the start of important output lines.
DisablePrefixIcons :: PrintPrefixIcons

-- | Add icons to the start of important output lines.
EnablePrefixIcons :: PrintPrefixIcons
renderProgress :: MonadIO m => UseColor -> Maybe PropertyName -> Report Progress -> m String
renderResult :: MonadIO m => UseColor -> Maybe PropertyName -> Report Result -> m String
renderResultWith :: MonadIO m => Config -> UseColor -> Maybe PropertyName -> Report Result -> m String
renderSummary :: MonadIO m => UseColor -> Summary -> m String
renderDoc :: MonadIO m => UseColor -> Doc Markup -> m String
ppProgress :: MonadIO m => Maybe PropertyName -> Report Progress -> m (Doc Markup)
ppResult :: MonadIO m => Maybe PropertyName -> Report Result -> m (Doc Markup)
ppResultWith :: MonadIO m => Config -> Maybe PropertyName -> Report Result -> m (Doc Markup)
ppSummary :: MonadIO m => Summary -> m (Doc Markup)

-- | Construct a summary from a single result.
fromResult :: Result -> Summary
mkFailure :: ShrinkCount -> ShrinkPath -> Maybe (Coverage CoverCount) -> Maybe Span -> String -> Maybe Diff -> [Log] -> FailureReport
instance GHC.Show.Show Hedgehog.Internal.Report.FailedAnnotation
instance GHC.Classes.Eq Hedgehog.Internal.Report.FailedAnnotation
instance GHC.Show.Show Hedgehog.Internal.Report.FailureReport
instance GHC.Classes.Eq Hedgehog.Internal.Report.FailureReport
instance GHC.Show.Show Hedgehog.Internal.Report.Progress
instance GHC.Classes.Eq Hedgehog.Internal.Report.Progress
instance GHC.Show.Show Hedgehog.Internal.Report.Result
instance GHC.Classes.Eq Hedgehog.Internal.Report.Result
instance Data.Traversable.Traversable Hedgehog.Internal.Report.Report
instance Data.Foldable.Foldable Hedgehog.Internal.Report.Report
instance GHC.Base.Functor Hedgehog.Internal.Report.Report
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Report.Report a)
instance GHC.Show.Show Hedgehog.Internal.Report.Summary
instance GHC.Base.Functor Hedgehog.Internal.Report.Line
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Report.Line a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.Report.Line a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Report.Line a)
instance GHC.Base.Functor Hedgehog.Internal.Report.Declaration
instance GHC.Show.Show a => GHC.Show.Show (Hedgehog.Internal.Report.Declaration a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hedgehog.Internal.Report.Declaration a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hedgehog.Internal.Report.Declaration a)
instance GHC.Show.Show Hedgehog.Internal.Report.Style
instance GHC.Classes.Ord Hedgehog.Internal.Report.Style
instance GHC.Classes.Eq Hedgehog.Internal.Report.Style
instance GHC.Show.Show Hedgehog.Internal.Report.Markup
instance GHC.Classes.Ord Hedgehog.Internal.Report.Markup
instance GHC.Classes.Eq Hedgehog.Internal.Report.Markup
instance GHC.Num.Num Hedgehog.Internal.Report.Lines
instance GHC.Classes.Eq Hedgehog.Internal.Report.Lines
instance GHC.Show.Show Hedgehog.Internal.Report.Context
instance GHC.Classes.Eq Hedgehog.Internal.Report.Context
instance GHC.Show.Show Hedgehog.Internal.Report.PrintPrefixIcons
instance GHC.Classes.Eq Hedgehog.Internal.Report.PrintPrefixIcons
instance GHC.Show.Show Hedgehog.Internal.Report.Config
instance GHC.Classes.Eq Hedgehog.Internal.Report.Config
instance GHC.Base.Semigroup Hedgehog.Internal.Report.ColumnWidth
instance GHC.Base.Monoid Hedgehog.Internal.Report.ColumnWidth
instance GHC.Show.Show Hedgehog.Internal.Report.Lines
instance GHC.Base.Semigroup Hedgehog.Internal.Report.Style
instance GHC.Base.Monoid Hedgehog.Internal.Report.Summary
instance GHC.Base.Semigroup Hedgehog.Internal.Report.Summary

module Hedgehog.Internal.Queue
newtype TaskIndex
TaskIndex :: Int -> TaskIndex
newtype TasksRemaining
TasksRemaining :: Int -> TasksRemaining
runTasks :: WorkerCount -> [a] -> (TasksRemaining -> TaskIndex -> a -> IO b) -> (b -> IO ()) -> (b -> IO ()) -> (b -> IO c) -> IO [c]
finalizeTask :: MonadIO m => MVar (TaskIndex, Map TaskIndex (IO ())) -> TaskIndex -> IO () -> m ()
runActiveFinalizers :: MonadIO m => MVar (TaskIndex, Map TaskIndex (IO ())) -> m ()
dequeueMVar :: MVar [(TaskIndex, a)] -> (TasksRemaining -> TaskIndex -> a -> IO b) -> IO (Maybe (TaskIndex, b))

-- | Update the number of capabilities but never set it lower than it
--   already is.
updateNumCapabilities :: WorkerCount -> IO ()
instance GHC.Num.Num Hedgehog.Internal.Queue.TaskIndex
instance GHC.Enum.Enum Hedgehog.Internal.Queue.TaskIndex
instance GHC.Classes.Ord Hedgehog.Internal.Queue.TaskIndex
instance GHC.Classes.Eq Hedgehog.Internal.Queue.TaskIndex

module Hedgehog.Internal.Runner

-- | Check a property.
check :: MonadIO m => Property -> m Bool

-- | Check a property using a specific size and seed.
recheck :: MonadIO m => Size -> Seed -> Property -> m ()
recheckAt :: MonadIO m => Seed -> Skip -> Property -> m ()

-- | Configuration for a property test run.
data RunnerConfig
RunnerConfig :: !Maybe WorkerCount -> !Maybe UseColor -> !Maybe Seed -> !Maybe Verbosity -> RunnerConfig

-- | The number of property tests to run concurrently. <a>Nothing</a> means
--   use one worker per processor.
[runnerWorkers] :: RunnerConfig -> !Maybe WorkerCount

-- | Whether to use colored output or not. <a>Nothing</a> means detect from
--   the environment.
[runnerColor] :: RunnerConfig -> !Maybe UseColor

-- | The seed to use. <a>Nothing</a> means detect from the environment.
[runnerSeed] :: RunnerConfig -> !Maybe Seed

-- | How verbose to be in the runner output. <a>Nothing</a> means detect
--   from the environment.
[runnerVerbosity] :: RunnerConfig -> !Maybe Verbosity

-- | Check a group of properties in parallel.
--   
--   <i>Warning: although this check function runs tests faster than</i>
--   <i><a>checkSequential</a>, it should be noted that it may cause
--   problems with</i> <i>properties that are not self-contained. For
--   example, if you have a group</i> <i>of tests which all use the same
--   database table, you may find that they</i> <i>interfere with each
--   other when being run in parallel.</i>
--   
--   Using Template Haskell for property discovery:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkParallel $$(discover)
--   </pre>
--   
--   With manually specified properties:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkParallel $ Group "Test.Example" [
--         ("prop_reverse", prop_reverse)
--       ]
--   </pre>
checkParallel :: MonadIO m => Group -> m Bool

-- | Check a group of properties sequentially.
--   
--   Using Template Haskell for property discovery:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkSequential $$(discover)
--   </pre>
--   
--   With manually specified properties:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkSequential $ Group "Test.Example" [
--         ("prop_reverse", prop_reverse)
--       ]
--   </pre>
checkSequential :: MonadIO m => Group -> m Bool

-- | Check a group of properties using the specified runner config.
checkGroup :: MonadIO m => RunnerConfig -> Group -> m Bool
checkReport :: forall m. MonadIO m => MonadCatch m => PropertyConfig -> Size -> Seed -> PropertyT m () -> (Report Progress -> m ()) -> m (Report Result)
checkRegion :: MonadIO m => Region -> UseColor -> Maybe PropertyName -> Size -> Seed -> Property -> m (Report Result)
checkNamed :: MonadIO m => Region -> UseColor -> Maybe PropertyName -> Maybe Seed -> Property -> m (Report Result)
instance Language.Haskell.TH.Syntax.Lift Hedgehog.Internal.Runner.RunnerConfig
instance GHC.Show.Show Hedgehog.Internal.Runner.RunnerConfig
instance GHC.Classes.Ord Hedgehog.Internal.Runner.RunnerConfig
instance GHC.Classes.Eq Hedgehog.Internal.Runner.RunnerConfig

module Hedgehog.Gen

-- | Apply a shrinking function to a generator.
--   
--   This will give the generator additional shrinking options, while
--   keeping the existing shrinks intact.
shrink :: MonadGen m => (a -> [a]) -> m a -> m a

-- | Throw away a generator's shrink tree.
prune :: MonadGen m => m a -> m a

-- | Make a generator smaller by scaling its size parameter.
small :: MonadGen m => m a -> m a

-- | Adjust the size parameter by transforming it with the given function.
scale :: MonadGen m => (Size -> Size) -> m a -> m a

-- | Override the size parameter. Returns a generator which uses the given
--   size instead of the runtime-size parameter.
resize :: MonadGen m => Size -> m a -> m a

-- | Construct a generator that depends on the size parameter.
sized :: MonadGen m => (Size -> m a) -> m a

-- | Generates a random integral number in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   When the generator tries to shrink, it will shrink towards the
--   <a>origin</a> of the specified <a>Range</a>.
--   
--   For example, the following generator will produce a number between
--   <tt>1970</tt> and <tt>2100</tt>, but will shrink towards
--   <tt>2000</tt>:
--   
--   <pre>
--   integral (Range.<a>constantFrom</a> 2000 1970 2100) :: <a>Gen</a> <a>Int</a>
--   </pre>
--   
--   Some sample outputs from this generator might look like:
--   
--   <pre>
--   === Outcome ===
--   1973
--   === Shrinks ===
--   2000
--   1987
--   1980
--   1976
--   1974
--   </pre>
--   
--   <pre>
--   === Outcome ===
--   2061
--   === Shrinks ===
--   2000
--   2031
--   2046
--   2054
--   2058
--   2060
--   </pre>
integral :: forall m a. (MonadGen m, Integral a) => Range a -> m a

-- | Generates a random integral number in the [inclusive,inclusive] range.
--   
--   <i>This generator does not shrink.</i>
integral_ :: (MonadGen m, Integral a) => Range a -> m a

-- | Generates a random machine integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int :: MonadGen m => Range Int -> m Int

-- | Generates a random 8-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int8 :: MonadGen m => Range Int8 -> m Int8

-- | Generates a random 16-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int16 :: MonadGen m => Range Int16 -> m Int16

-- | Generates a random 32-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int32 :: MonadGen m => Range Int32 -> m Int32

-- | Generates a random 64-bit integer in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
int64 :: MonadGen m => Range Int64 -> m Int64

-- | Generates a random machine word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word :: MonadGen m => Range Word -> m Word

-- | Generates a random byte in the given <tt>[inclusive,inclusive]</tt>
--   range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word8 :: MonadGen m => Range Word8 -> m Word8

-- | Generates a random 16-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word16 :: MonadGen m => Range Word16 -> m Word16

-- | Generates a random 32-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word32 :: MonadGen m => Range Word32 -> m Word32

-- | Generates a random 64-bit word in the given
--   <tt>[inclusive,inclusive]</tt> range.
--   
--   <i>This is a specialization of <a>integral</a>, offered for
--   convenience.</i>
word64 :: MonadGen m => Range Word64 -> m Word64

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   <i>This generator works the same as <a>integral</a>, but for floating
--   point numbers.</i>
realFloat :: (MonadGen m, RealFloat a) => Range a -> m a

-- | Generates a random fractional number in the [inclusive,exclusive)
--   range.
--   
--   <i>This generator does not shrink.</i>
realFrac_ :: (MonadGen m, RealFrac a) => Range a -> m a

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   <i>This is a specialization of <a>realFloat</a>, offered for
--   convenience.</i>
float :: MonadGen m => Range Float -> m Float

-- | Generates a random floating-point number in the
--   <tt>[inclusive,exclusive)</tt> range.
--   
--   <i>This is a specialization of <a>realFloat</a>, offered for
--   convenience.</i>
double :: MonadGen m => Range Double -> m Double

-- | Generates an element from an enumeration.
--   
--   This generator shrinks towards the first argument.
--   
--   For example:
--   
--   <pre>
--   enum 'a' 'z' :: <a>Gen</a> <a>Char</a>
--   </pre>
enum :: (MonadGen m, Enum a) => a -> a -> m a

-- | Generates a random value from a bounded enumeration.
--   
--   This generator shrinks towards <a>minBound</a>.
--   
--   For example:
--   
--   <pre>
--   enumBounded :: <a>Gen</a> <a>Bool</a>
--   </pre>
--   
--   <i>This is implemented in terms of the <a>Enum</a> class, and thus may
--   be</i> <i>partial for integral types larger than <a>Int</a>, e.g.
--   <a>Word64</a>.</i>
enumBounded :: (MonadGen m, Enum a, Bounded a) => m a

-- | Generates a random boolean.
--   
--   This generator shrinks to <a>False</a>.
--   
--   <i>This is a specialization of <a>enumBounded</a>, offered for
--   convenience.</i>
bool :: MonadGen m => m Bool

-- | Generates a random boolean.
--   
--   <i>This generator does not shrink.</i>
bool_ :: MonadGen m => m Bool

-- | Generates an ASCII binit: <tt>'0'..'1'</tt>
binit :: MonadGen m => m Char

-- | Generates an ASCII octit: <tt>'0'..'7'</tt>
octit :: MonadGen m => m Char

-- | Generates an ASCII digit: <tt>'0'..'9'</tt>
digit :: MonadGen m => m Char

-- | Generates an ASCII hexit: <tt>'0'..'9', 'a'..'f', 'A'..'F'</tt>
hexit :: MonadGen m => m Char

-- | Generates an ASCII lowercase letter: <tt>'a'..'z'</tt>
lower :: MonadGen m => m Char

-- | Generates an ASCII uppercase letter: <tt>'A'..'Z'</tt>
upper :: MonadGen m => m Char

-- | Generates an ASCII letter: <tt>'a'..'z', 'A'..'Z'</tt>
alpha :: MonadGen m => m Char

-- | Generates an ASCII letter or digit: <tt>'a'..'z', 'A'..'Z',
--   '0'..'9'</tt>
alphaNum :: MonadGen m => m Char

-- | Generates an ASCII character: <tt>'0'..'127'</tt>
ascii :: MonadGen m => m Char

-- | Generates a Latin-1 character: <tt>'0'..'255'</tt>
latin1 :: MonadGen m => m Char

-- | Generates a Unicode character, excluding noncharacters and invalid
--   standalone surrogates: <tt>'0'..'1114111' (excluding '55296'..'57343',
--   '65534', '65535')</tt>
unicode :: MonadGen m => m Char

-- | Generates a Unicode character, including noncharacters and invalid
--   standalone surrogates: <tt>'0'..'1114111'</tt>
unicodeAll :: MonadGen m => m Char

-- | Generates a string using <a>Range</a> to determine the length.
--   
--   <i>This is a specialization of <a>list</a>, offered for
--   convenience.</i>
string :: MonadGen m => Range Int -> m Char -> m String

-- | Generates a string using <a>Range</a> to determine the length.
text :: MonadGen m => Range Int -> m Char -> m Text

-- | Generates a UTF-8 encoded string, using <a>Range</a> to determine the
--   length.
utf8 :: MonadGen m => Range Int -> m Char -> m ByteString

-- | Generates a random <a>ByteString</a>, using <a>Range</a> to determine
--   the length.
bytes :: MonadGen m => Range Int -> m ByteString

-- | Trivial generator that always produces the same element.
--   
--   <i>This is another name for <a>pure</a> / <a>return</a>.</i>
constant :: MonadGen m => a -> m a

-- | Randomly selects one of the elements in the list.
--   
--   This generator shrinks towards the first element in the list.
--   
--   <i>The input list must be non-empty.</i>
element :: (Foldable f, MonadGen m) => f a -> m a

-- | Randomly selects one of the generators in the list.
--   
--   This generator shrinks towards the first generator in the list.
--   
--   <i>The input list must be non-empty.</i>
choice :: MonadGen m => [m a] -> m a

-- | Uses a weighted distribution to randomly select one of the generators
--   in the list.
--   
--   This generator shrinks towards the first generator in the list.
--   
--   <i>The input list must be non-empty.</i>
frequency :: MonadGen m => [(Int, m a)] -> m a

-- | Modifies combinators which choose from a list of generators, like
--   <a>choice</a> or <a>frequency</a>, so that they can be used in
--   recursive scenarios.
--   
--   This combinator modifies its target to select one of the generators in
--   either the non-recursive or the recursive list. When a selection is
--   made from the recursive list, the <a>Size</a> is halved. When the
--   <a>Size</a> gets to one or less, selections are no longer made from
--   the recursive list, this ensures termination.
--   
--   A good example of where this might be useful is abstract syntax trees:
--   
--   <pre>
--   data Expr =
--       Var String
--     | Lam String Expr
--     | App Expr Expr
--   
--   -- Assuming we have a name generator
--   genName :: <a>MonadGen</a> m =&gt; m String
--   
--   -- We can write a generator for expressions
--   genExpr :: <a>MonadGen</a> m =&gt; m Expr
--   genExpr =
--     Gen.<a>recursive</a> Gen.<a>choice</a> [
--         -- non-recursive generators
--         Var <a>&lt;$&gt;</a> genName
--       ] [
--         -- recursive generators
--         Gen.<a>subtermM</a> genExpr (x -&gt; Lam <a>&lt;$&gt;</a> genName <a>&lt;*&gt;</a> pure x)
--       , Gen.<a>subterm2</a> genExpr genExpr App
--       ]
--   </pre>
--   
--   If we wrote the above example using only <a>choice</a>, it is likely
--   that it would fail to terminate. This is because for every call to
--   <tt>genExpr</tt>, there is a 2 in 3 chance that we will recurse again.
recursive :: MonadGen m => ([m a] -> m a) -> [m a] -> [m a] -> m a

-- | Discards the whole generator.
discard :: MonadGen m => m a

-- | Generates a value that satisfies a predicate.
--   
--   Shrinks of the generated value will also satisfy the predicate. From
--   the original generator's shrink tree, any values that fail the
--   predicate will be removed, but any subsequent shrinks that satisfy it
--   will be retained. Compared to <a>filter</a>, shrinking may be slower
--   but will be optimal.
--   
--   It's possible that the predicate will never pass, or will only pass at
--   a larger size than we're currently running at. To avoid looping
--   forever, we limit the number of retries, and grow the size with each
--   retry. If we retry too many times then the whole generator is
--   discarded.
filter :: (MonadGen m, GenBase m ~ Identity) => (a -> Bool) -> m a -> m a

-- | Generates a value that satisfies a predicate.
--   
--   Shrinks of the generated value will also satisfy the predicate. From
--   the original generator's shrink tree, any values that fail the
--   predicate will be removed, along with their subsequent shrinks.
--   Compared to <a>filter</a>, shrinking may be faster but may also be
--   less optimal.
--   
--   The type is also more general, because the shrink behavior from
--   <a>filter</a> would force the entire shrink tree to be evaluated when
--   applied to an impure tree.
--   
--   This is essentially:
--   
--   <pre>
--   filterT p gen = <tt>mfilter</tt> p gen <a>&lt;|&gt;</a> filterT p gen
--   </pre>
--   
--   But that could loop forever, if the predicate will never pass or will
--   only pass at a larger size than we're currently running at. We differ
--   from the above in keeping some state to avoid that. We limit the
--   number of retries, and grow the size with each retry. If we retry too
--   many times then the whole generator is discarded.
filterT :: MonadGen m => (a -> Bool) -> m a -> m a

-- | Generates a value which is the result of the given function returning
--   a <a>Just</a>.
--   
--   The original generator's shrink tree will be retained, with values
--   returning <a>Nothing</a> removed. Subsequent shrinks of those values
--   will be retained. Compared to <a>mapMaybeT</a>, shrinking may be
--   slower but will be optimal.
--   
--   It's possible that the function will never return <a>Just</a>, or will
--   only do so a larger size than we're currently running at. To avoid
--   looping forever, we limit the number of retries, and grow the size
--   with each retry. If we retry too many times then the whole generator
--   is discarded.
mapMaybe :: (MonadGen m, GenBase m ~ Identity) => (a -> Maybe b) -> m a -> m b

-- | Generates a value which is the result of the given function returning
--   a <a>Just</a>.
--   
--   The original generator's shrink tree will be retained, with values
--   returning <a>Nothing</a> removed. Subsequent shrinks of those values
--   will be retained. Compared to <a>mapMaybeT</a>, shrinking may be
--   slower but will be optimal.
--   
--   The type is also more general, because the shrink behavior from
--   <a>mapMaybe</a> would force the entire shrink tree to be evaluated
--   when applied to an impure tree.
--   
--   It's possible that the function will never return <a>Just</a>, or will
--   only do so a larger size than we're currently running at. To avoid
--   looping forever, we limit the number of retries, and grow the size
--   with each retry. If we retry too many times then the whole generator
--   is discarded.
mapMaybeT :: MonadGen m => (a -> Maybe b) -> m a -> m b

-- | Runs a <a>Maybe</a> generator until it produces a <a>Just</a>.
--   
--   <i>This is implemented using <a>filter</a> and has the same
--   caveats.</i>
just :: (MonadGen m, GenBase m ~ Identity) => m (Maybe a) -> m a

-- | Runs a <a>Maybe</a> generator until it produces a <a>Just</a>.
--   
--   <i>This is implemented using <a>filter</a> and has the same
--   caveats.</i>
justT :: MonadGen m => m (Maybe a) -> m a

-- | Generates a <a>Nothing</a> some of the time.
maybe :: MonadGen m => m a -> m (Maybe a)

-- | Generates either an <tt>a</tt> or a <tt>b</tt>.
--   
--   As the size grows, this generator generates <tt>Right</tt>s more often
--   than <tt>Left</tt>s.
either :: MonadGen m => m a -> m b -> m (Either a b)

-- | Generates either an <tt>a</tt> or a <tt>b</tt>, without bias.
--   
--   This generator generates as many <tt>Right</tt>s as it does
--   <tt>Left</tt>s.
either_ :: MonadGen m => m a -> m b -> m (Either a b)

-- | Generates a list using a <a>Range</a> to determine the length.
list :: MonadGen m => Range Int -> m a -> m [a]

-- | Generates a seq using a <a>Range</a> to determine the length.
seq :: MonadGen m => Range Int -> m a -> m (Seq a)

-- | Generates a non-empty list using a <a>Range</a> to determine the
--   length.
nonEmpty :: MonadGen m => Range Int -> m a -> m (NonEmpty a)

-- | Generates a set using a <a>Range</a> to determine the length.
--   
--   <i>This may fail to generate anything if the element generator</i>
--   <i>cannot produce a large enough number of unique items to satify</i>
--   <i>the required set size.</i>
set :: (MonadGen m, Ord a) => Range Int -> m a -> m (Set a)

-- | Generates a map using a <a>Range</a> to determine the length.
--   
--   <i>This may fail to generate anything if the keys produced by the</i>
--   <i>generator do not account for a large enough number of unique</i>
--   <i>items to satify the required map size.</i>
map :: (MonadGen m, Ord k) => Range Int -> m (k, v) -> m (Map k v)

-- | Freeze the size and seed used by a generator, so we can inspect the
--   value which it will produce.
--   
--   This is used for implementing <a>list</a> and <a>subtermMVec</a>. It
--   allows us to shrink the list itself before trying to shrink the values
--   inside the list.
freeze :: MonadGen m => m a -> m (a, m a)

-- | Constructs a generator from a sub-term generator.
--   
--   <i>Shrinks to the sub-term if possible.</i>
subterm :: MonadGen m => m a -> (a -> a) -> m a

-- | Constructs a generator from a sub-term generator.
--   
--   <i>Shrinks to the sub-term if possible.</i>
subtermM :: MonadGen m => m a -> (a -> m a) -> m a

-- | Constructs a generator from two sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subterm2 :: MonadGen m => m a -> m a -> (a -> a -> a) -> m a

-- | Constructs a generator from two sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subtermM2 :: MonadGen m => m a -> m a -> (a -> a -> m a) -> m a

-- | Constructs a generator from three sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subterm3 :: MonadGen m => m a -> m a -> m a -> (a -> a -> a -> a) -> m a

-- | Constructs a generator from three sub-term generators.
--   
--   <i>Shrinks to one of the sub-terms if possible.</i>
subtermM3 :: MonadGen m => m a -> m a -> m a -> (a -> a -> a -> m a) -> m a

-- | Generates a random subsequence of a list.
--   
--   For example:
--   
--   <pre>
--   Gen.print (Gen.subsequence [1..5])
--   </pre>
--   
--   <pre>
--   === Outcome ===
--   [1,2,4]
--   === Shrinks ===
--   []
--   [2,4]
--   [1,4]
--   [1,2]
--   </pre>
subsequence :: MonadGen m => [a] -> m [a]

-- | Generates a random subset of a set.
--   
--   <i>This shrinks towards the empty set.</i>
subset :: MonadGen m => Set a -> m (Set a)

-- | Generates a random permutation of a list.
--   
--   <i>This shrinks towards the order of the list being identical to the
--   input</i> <i>list.</i>
shuffle :: MonadGen m => [a] -> m [a]

-- | Generates a sequence of actions from an initial model state and set of
--   commands.
sequential :: (MonadGen gen, MonadTest m) => Range Int -> (forall v. state v) -> [Command gen m state] -> gen (Sequential m state)

-- | Given the initial model state and set of commands, generates prefix
--   actions to be run sequentially, followed by two branches to be run in
--   parallel.
parallel :: (MonadGen gen, MonadTest m) => Range Int -> Range Int -> (forall v. state v) -> [Command gen m state] -> gen (Parallel m state)

-- | Generate a sample from a generator.
--   
--   This function is useful for examining a <a>Gen</a> in GHCi or other
--   contexts. It is not appropriate for use in a test suite directly. You
--   will only get a single sample from this function, and it will not give
--   you a property test. The seed is random, so the test is not
--   deterministic.
--   
--   If you only want a single test to run, then use <tt><tt>withTests</tt>
--   1</tt>:
--   
--   <pre>
--   prop_OnlyRunOnce :: Property
--   prop_OnlyRunOnce =
--     <tt>withTests</tt> 1 $ <tt>property</tt> $ do
--       i &lt;- Gen.int
--       i /== 0
--   </pre>
sample :: MonadIO m => Gen a -> m a

-- | Run a generator with a random seed and print the outcome, and the
--   first level of shrinks.
--   
--   <pre>
--   Gen.print (Gen.<a>enum</a> 'a' 'f')
--   </pre>
--   
--   <pre>
--   === Outcome ===
--   'd'
--   === Shrinks ===
--   'a'
--   'b'
--   'c'
--   </pre>
print :: (MonadIO m, Show a) => Gen a -> m ()

-- | Run a generator with a random seed and print the resulting shrink
--   tree.
--   
--   <pre>
--   Gen.printTree (Gen.<a>enum</a> 'a' 'f')
--   </pre>
--   
--   <pre>
--   'd'
--    ├╼'a'
--    ├╼'b'
--    │  └╼'a'
--    └╼'c'
--       ├╼'a'
--       └╼'b'
--          └╼'a'
--   </pre>
--   
--   <i>This may not terminate when the tree is very large.</i>
printTree :: (MonadIO m, Show a) => Gen a -> m ()

-- | Print the value produced by a generator, and the first level of
--   shrinks, for the given size and seed.
--   
--   Use <a>print</a> to generate a value from a random seed.
printWith :: (MonadIO m, Show a) => Size -> Seed -> Gen a -> m ()

-- | Print the shrink tree produced by a generator, for the given size and
--   seed.
--   
--   Use <a>printTree</a> to generate a value from a random seed.
printTreeWith :: (MonadIO m, Show a) => Size -> Seed -> Gen a -> m ()


-- | This module includes almost everything you need to get started writing
--   property tests with Hedgehog.
--   
--   It is designed to be used alongside <a>Hedgehog.Gen</a> and
--   <a>Hedgehog.Range</a>, which should be imported qualified. You also
--   need to enable Template Haskell so the Hedgehog test runner can find
--   your properties.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   
--   import           Hedgehog
--   import qualified Hedgehog.Gen as Gen
--   import qualified Hedgehog.Range as Range
--   </pre>
--   
--   Once you have your imports set up, you can write a simple property:
--   
--   <pre>
--   prop_reverse :: Property
--   prop_reverse =
--     property $ do
--       xs &lt;- forAll $ Gen.list (Range.linear 0 100) Gen.alpha
--       reverse (reverse xs) === xs
--   </pre>
--   
--   And add the Template Haskell splice which will discover your
--   properties:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkParallel $$(discover)
--   </pre>
--   
--   If you prefer to avoid macros, you can specify the group of properties
--   to run manually instead:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   tests :: IO Bool
--   tests =
--     checkParallel $ Group "Test.Example" [
--         ("prop_reverse", prop_reverse)
--       ]
--   </pre>
--   
--   You can then load the module in GHCi, and run it:
--   
--   <pre>
--   λ tests
--   ━━━ Test.Example ━━━
--     ✓ prop_reverse passed 100 tests.
--   </pre>
module Hedgehog

-- | A property test, along with some configurable limits like how many
--   times to run the test.
data Property

-- | The property monad transformer allows both the generation of test
--   inputs and the assertion of expectations.
data PropertyT m a

-- | A named collection of property tests.
data Group
Group :: !GroupName -> ![(PropertyName, Property)] -> Group
[groupName] :: Group -> !GroupName
[groupProperties] :: Group -> ![(PropertyName, Property)]

-- | The name of a property.
--   
--   Should be constructed using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   "apples" :: PropertyName
--   </pre>
data PropertyName

-- | The name of a group of properties.
--   
--   Should be constructed using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   "fruit" :: GroupName
--   </pre>
data GroupName

-- | Creates a property with the default configuration.
property :: HasCallStack => PropertyT IO () -> Property

-- | Lift a test in to a property.
--   
--   Because both <a>TestT</a> and <a>PropertyT</a> have <a>MonadTest</a>
--   instances, this function is not often required. It can however be
--   useful for writing functions directly in <a>TestT</a> and thus gaining
--   a <a>MonadTransControl</a> instance at the expense of not being able
--   to generate additional inputs using <a>forAll</a>.
--   
--   An example where this is useful is parallel state machine testing, as
--   <a>executeParallel</a> requires <a>MonadBaseControl</a> <a>IO</a> in
--   order to be able to spawn threads in <a>MonadTest</a>.
test :: Monad m => TestT m a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
forAll :: (Monad m, Show a, HasCallStack) => Gen a -> PropertyT m a

-- | Generates a random input for the test by running the provided
--   generator.
--   
--   <i>This is a the same as <a>forAll</a> but allows the user to provide
--   a custom</i> <i>rendering function. This is useful for values which
--   don't have a</i> <i><a>Show</a> instance.</i>
forAllWith :: (Monad m, HasCallStack) => (a -> String) -> Gen a -> PropertyT m a

-- | Discards the current test entirely.
discard :: Monad m => PropertyT m a

-- | Check a property.
check :: MonadIO m => Property -> m Bool

-- | Check a property using a specific size and seed.
recheck :: MonadIO m => Size -> Seed -> Property -> m ()
recheckAt :: MonadIO m => Seed -> Skip -> Property -> m ()

-- | Discover all the properties in a module.
--   
--   Functions starting with <tt>prop_</tt> are assumed to be properties.
discover :: TExpQ Group
discoverPrefix :: String -> TExpQ Group

-- | Check a group of properties in parallel.
--   
--   <i>Warning: although this check function runs tests faster than</i>
--   <i><a>checkSequential</a>, it should be noted that it may cause
--   problems with</i> <i>properties that are not self-contained. For
--   example, if you have a group</i> <i>of tests which all use the same
--   database table, you may find that they</i> <i>interfere with each
--   other when being run in parallel.</i>
--   
--   Using Template Haskell for property discovery:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkParallel $$(discover)
--   </pre>
--   
--   With manually specified properties:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkParallel $ Group "Test.Example" [
--         ("prop_reverse", prop_reverse)
--       ]
--   </pre>
checkParallel :: MonadIO m => Group -> m Bool

-- | Check a group of properties sequentially.
--   
--   Using Template Haskell for property discovery:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkSequential $$(discover)
--   </pre>
--   
--   With manually specified properties:
--   
--   <pre>
--   tests :: IO Bool
--   tests =
--     checkSequential $ Group "Test.Example" [
--         ("prop_reverse", prop_reverse)
--       ]
--   </pre>
checkSequential :: MonadIO m => Group -> m Bool

-- | The acceptable occurrence of false positives
--   
--   Example, <tt>Confidence 10^9</tt> would mean that you'd accept a false
--   positive for 1 in 10^9 tests.
data Confidence
verifiedTermination :: Property -> Property

-- | Make sure that the result is statistically significant in accordance
--   to the passed <a>Confidence</a>
withConfidence :: Confidence -> Property -> Property

-- | Set the number of times a property should be executed before it is
--   considered successful.
--   
--   If you have a test that does not involve any generators and thus does
--   not need to run repeatedly, you can use <tt>withTests 1</tt> to define
--   a property that will only be checked once.
withTests :: TestLimit -> Property -> Property

-- | The number of successful tests that need to be run before a property
--   test is considered successful.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   200 :: TestLimit
--   </pre>
data TestLimit

-- | Set the number of times a property is allowed to discard before the
--   test runner gives up.
withDiscards :: DiscardLimit -> Property -> Property

-- | The number of discards to allow before giving up.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   10000 :: DiscardLimit
--   </pre>
data DiscardLimit

-- | Set the number of times a property is allowed to shrink before the
--   test runner gives up and prints the counterexample.
withShrinks :: ShrinkLimit -> Property -> Property

-- | The number of shrinks to try before giving up on shrinking.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   1000 :: ShrinkLimit
--   </pre>
data ShrinkLimit

-- | Set the number of times a property will be executed for each shrink
--   before the test runner gives up and tries a different shrink. See
--   <a>ShrinkRetries</a> for more information.
withRetries :: ShrinkRetries -> Property -> Property

-- | The number of times to re-run a test during shrinking. This is useful
--   if you are testing something which fails non-deterministically and you
--   want to increase the change of getting a good shrink.
--   
--   If you are doing parallel state machine testing, you should probably
--   set shrink retries to something like <tt>10</tt>. This will mean that
--   during shrinking, a parallel test case requires 10 successful runs
--   before it is passes and we try a different shrink.
--   
--   Can be constructed using numeric literals:
--   
--   <pre>
--   0 :: ShrinkRetries
--   </pre>
data ShrinkRetries

-- | Set the target that a property will skip to before it starts to run.
withSkip :: Skip -> Property -> Property

-- | Where to start running a property's tests.
data Skip

-- | Generator for random values of <tt>a</tt>.
type Gen = GenT Identity

-- | Monad transformer which can generate random values of <tt>a</tt>.
data GenT m a

-- | Class of monads which can generate input data for tests.
class (Monad m, Monad (GenBase m)) => MonadGen m where {
    type GenBase m :: (Type -> Type);
}

-- | Extract a <a>GenT</a> from a <a>MonadGen</a>.
toGenT :: MonadGen m => m a -> GenT (GenBase m) a

-- | Lift a <a>GenT</a> in to a <a>MonadGen</a>.
fromGenT :: MonadGen m => GenT (GenBase m) a -> m a

-- | A range describes the bounds of a number to generate, which may or may
--   not be dependent on a <a>Size</a>.
--   
--   The constructor takes an origin between the lower and upper bound, and
--   a function from <a>Size</a> to bounds. As the size goes towards
--   <tt>0</tt>, the values go towards the origin.
data Range a

-- | Tests are parameterized by the size of the randomly-generated data.
--   The meaning of a <a>Size</a> value depends on the particular generator
--   used, but it must always be a number between 0 and 99 inclusive.
newtype Size
Size :: Int -> Size
[unSize] :: Size -> Int

-- | A splittable random number generator.
data Seed
Seed :: !Word64 -> !Word64 -> Seed
[seedValue] :: Seed -> !Word64

-- | must be an odd number
[seedGamma] :: Seed -> !Word64

-- | A test monad allows the assertion of expectations.
type Test = TestT Identity

-- | A test monad transformer allows the assertion of expectations.
data TestT m a
class Monad m => MonadTest m
liftTest :: MonadTest m => Test a -> m a

-- | Annotates the source code with a message that might be useful for
--   debugging a test failure.
annotate :: (MonadTest m, HasCallStack) => String -> m ()

-- | Annotates the source code with a value that might be useful for
--   debugging a test failure.
annotateShow :: (MonadTest m, Show a, HasCallStack) => a -> m ()

-- | Logs a message to be displayed as additional information in the footer
--   of the failure report.
footnote :: MonadTest m => String -> m ()

-- | Logs a value to be displayed as additional information in the footer
--   of the failure report.
footnoteShow :: (MonadTest m, Show a) => a -> m ()

-- | Another name for <tt>pure ()</tt>.
success :: MonadTest m => m ()

-- | Causes a test to fail.
failure :: (MonadTest m, HasCallStack) => m a

-- | Fails the test if the condition provided is <a>False</a>.
assert :: (MonadTest m, HasCallStack) => Bool -> m ()

-- | Fails the test and shows a git-like diff if the comparison operation
--   evaluates to <a>False</a> when applied to its arguments.
--   
--   The comparison function is the second argument, which may be
--   counter-intuitive to Haskell programmers. However, it allows operators
--   to be written infix for easy reading:
--   
--   <pre>
--   diff y (&lt;) 87
--   diff x (&lt;=) <tt>r</tt>
--   </pre>
--   
--   This function behaves like the unix <tt>diff</tt> tool, which gives a
--   0 exit code if the compared files are identical, or a 1 exit code code
--   otherwise. Like unix <tt>diff</tt>, if the arguments fail the
--   comparison, a /diff is shown.
diff :: (MonadTest m, Show a, Show b, HasCallStack) => a -> (a -> b -> Bool) -> b -> m ()

-- | Fails the test if the two arguments provided are not equal.
(===) :: (MonadTest m, Eq a, Show a, HasCallStack) => a -> a -> m ()
infix 4 ===

-- | Fails the test if the two arguments provided are equal.
(/==) :: (MonadTest m, Eq a, Show a, HasCallStack) => a -> a -> m ()
infix 4 /==

-- | Test that a pair of encode / decode functions are compatible.
--   
--   Given a printer from some type <tt>a -&gt; b</tt>, and a parser with a
--   potential failure case <tt>b -&gt; f a</tt>. Ensure that a valid
--   <tt>a</tt> round trips through the "print" and "parse" to yield the
--   same <tt>a</tt>.
--   
--   For example, types <i>should</i> have tripping <a>Read</a> and
--   <a>Show</a> instances:
--   
--   <pre>
--   trippingShowRead :: (Show a, Read a, Eq a, MonadTest m) =&gt; a -&gt; m ()
--   trippingShowRead a = tripping a show readEither
--   </pre>
tripping :: (MonadTest m, Applicative f, Show b, Show (f a), Eq (f a), HasCallStack) => a -> (a -> b) -> (b -> f a) -> m ()

-- | Fails the test if the value throws an exception when evaluated to weak
--   head normal form (WHNF).
eval :: (MonadTest m, HasCallStack) => a -> m a

-- | Fails the test if the value throws an exception when evaluated to
--   normal form (NF).
evalNF :: (MonadTest m, NFData a, HasCallStack) => a -> m a

-- | Fails the test if the action throws an exception.
--   
--   <i>The benefit of using this over simply letting the exception bubble
--   up is</i> <i>that the location of the closest <a>evalM</a> will be
--   shown in the output.</i>
evalM :: (MonadTest m, MonadCatch m, HasCallStack) => m a -> m a

-- | Fails the test if the <a>IO</a> action throws an exception.
--   
--   <i>The benefit of using this over <a>liftIO</a> is that the location
--   of the</i> <i>exception will be shown in the output.</i>
evalIO :: (MonadTest m, MonadIO m, HasCallStack) => IO a -> m a

-- | Fails the test if the <a>Either</a> is <a>Left</a>, otherwise returns
--   the value in the <a>Right</a>.
evalEither :: (MonadTest m, Show x, HasCallStack) => Either x a -> m a

-- | Fails the test if the action throws an exception, or if the
--   <a>Either</a> is <a>Left</a>, otherwise returns the value in the
--   <a>Right</a>.
evalEitherM :: (MonadTest m, Show x, MonadCatch m, HasCallStack) => m (Either x a) -> m a

-- | Fails the test if the <a>ExceptT</a> is <a>Left</a>, otherwise returns
--   the value in the <a>Right</a>.
evalExceptT :: (MonadTest m, Show x, HasCallStack) => ExceptT x m a -> m a

-- | Fails the test if the <a>Maybe</a> is <a>Nothing</a>, otherwise
--   returns the value in the <a>Just</a>.
evalMaybe :: (MonadTest m, HasCallStack) => Maybe a -> m a

-- | Fails the test if the action throws an exception, or if the
--   <a>Maybe</a> is <a>Nothing</a>, otherwise returns the value in the
--   <a>Just</a>.
evalMaybeM :: (MonadTest m, MonadCatch m, HasCallStack) => m (Maybe a) -> m a

-- | The name of a classifier.
--   
--   Should be constructed using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   "apples" :: LabelName
--   </pre>
data LabelName

-- | Records the proportion of tests which satisfy a given condition.
--   
--   <pre>
--   prop_with_classifier :: Property
--   prop_with_classifier =
--     property $ do
--       xs &lt;- forAll $ Gen.list (Range.linear 0 100) Gen.alpha
--       for_ xs $ \x -&gt; do
--         classify "newborns" $ x == 0
--         classify "children" $ x &gt; 0 &amp;&amp; x &lt; 13
--         classify "teens" $ x &gt; 12 &amp;&amp; x &lt; 20
--   </pre>
classify :: (MonadTest m, HasCallStack) => LabelName -> Bool -> m ()

-- | Require a certain percentage of the tests to be covered by the
--   classifier.
--   
--   <pre>
--   prop_with_coverage :: Property
--   prop_with_coverage =
--     property $ do
--       match &lt;- forAll Gen.bool
--       cover 30 "True" $ match
--       cover 30 "False" $ not match
--   </pre>
--   
--   The example above requires a minimum of 30% coverage for both
--   classifiers. If these requirements are not met, it will fail the test.
cover :: (MonadTest m, HasCallStack) => CoverPercentage -> LabelName -> Bool -> m ()

-- | Add a label for each test run. It produces a table showing the
--   percentage of test runs that produced each label.
label :: (MonadTest m, HasCallStack) => LabelName -> m ()

-- | Like <a>label</a>, but uses <a>Show</a> to render its argument for
--   display.
collect :: (MonadTest m, Show a, HasCallStack) => a -> m ()

-- | The specification for the expected behaviour of an <a>Action</a>.
--   These are used to generate sequences of actions to test.
--   
--   This is the main type you will use when writing state machine tests.
--   <tt>gen</tt> is usually an instance of <a>MonadGen</a>, and <tt>m</tt>
--   is usually an instance of <a>MonadTest</a>. These constraints appear
--   when you pass your <a>Command</a> list to <a>sequential</a> or
--   <a>parallel</a>.
data Command gen m (state :: (Type -> Type) -> Type)
Command :: (state Symbolic -> Maybe (gen (input Symbolic))) -> (input Concrete -> m output) -> [Callback input output state] -> Command gen m (state :: (Type -> Type) -> Type)

-- | A generator which provides random arguments for a command. If the
--   command cannot be executed in the current state, it should return
--   <a>Nothing</a>.
[commandGen] :: Command gen m (state :: (Type -> Type) -> Type) -> state Symbolic -> Maybe (gen (input Symbolic))

-- | Executes a command using the arguments generated by <a>commandGen</a>.
[commandExecute] :: Command gen m (state :: (Type -> Type) -> Type) -> input Concrete -> m output

-- | A set of callbacks which provide optional command configuration such
--   as pre-condtions, post-conditions and state updates.
[commandCallbacks] :: Command gen m (state :: (Type -> Type) -> Type) -> [Callback input output state]

-- | Optional command configuration.
data Callback input output state

-- | A pre-condition for a command that must be verified before the command
--   can be executed. This is mainly used during shrinking to ensure that
--   it is still OK to run a command despite the fact that some previously
--   executed commands may have been removed from the sequence.
Require :: (state Symbolic -> input Symbolic -> Bool) -> Callback input output state

-- | Updates the model state, given the input and output of the command.
--   Note that this function is polymorphic in the type of values. This is
--   because it must work over <a>Symbolic</a> values when we are
--   generating actions, and <a>Concrete</a> values when we are executing
--   them.
Update :: (forall v. Ord1 v => state v -> input v -> Var output v -> state v) -> Callback input output state

-- | A post-condition for a command that must be verified for the command
--   to be considered a success.
--   
--   This callback receives the state prior to execution as the first
--   argument, and the state after execution as the second argument.
Ensure :: (state Concrete -> state Concrete -> input Concrete -> output -> Test ()) -> Callback input output state

-- | An instantiation of a <a>Command</a> which can be executed, and its
--   effect evaluated.
data Action m (state :: (Type -> Type) -> Type)

-- | A sequence of actions to execute.
newtype Sequential m state
Sequential :: [Action m state] -> Sequential m state

-- | The sequence of actions.
[sequentialActions] :: Sequential m state -> [Action m state]

-- | A sequential prefix of actions to execute, with two branches to
--   execute in parallel.
data Parallel m state
Parallel :: [Action m state] -> [Action m state] -> [Action m state] -> Parallel m state

-- | The sequential prefix.
[parallelPrefix] :: Parallel m state -> [Action m state]

-- | The first branch.
[parallelBranch1] :: Parallel m state -> [Action m state]

-- | The second branch.
[parallelBranch2] :: Parallel m state -> [Action m state]

-- | Executes a list of actions sequentially, verifying that all
--   post-conditions are met and no exceptions are thrown.
--   
--   To generate a sequence of actions to execute, see the
--   <a>sequential</a> combinator in the <a>Hedgehog.Gen</a> module.
executeSequential :: (MonadTest m, MonadCatch m, HasCallStack) => (forall v. state v) -> Sequential m state -> m ()

-- | Executes the prefix actions sequentially, then executes the two
--   branches in parallel, verifying that no exceptions are thrown and that
--   there is at least one sequential interleaving where all the
--   post-conditions are met.
--   
--   To generate parallel actions to execute, see the <a>parallel</a>
--   combinator in the <a>Hedgehog.Gen</a> module.
executeParallel :: (MonadTest m, MonadCatch m, MonadBaseControl IO m, HasCallStack) => (forall v. state v) -> Parallel m state -> m ()

-- | Variables are the potential or actual result of executing an action.
--   They are parameterised by either <a>Symbolic</a> or <a>Concrete</a>
--   depending on the phase of the test.
--   
--   <a>Symbolic</a> variables are the potential results of actions. These
--   are used when generating the sequence of actions to execute. They
--   allow actions which occur later in the sequence to make use of the
--   result of an action which came earlier in the sequence.
--   
--   <a>Concrete</a> variables are the actual results of actions. These are
--   used during test execution. They provide access to the actual runtime
--   value of a variable.
--   
--   The state update <a>Callback</a> for a command needs to be polymorphic
--   in the type of variable because it is used in both the generation and
--   the execution phase.
--   
--   The order of arguments makes <a>Var</a> <a>FunctorB</a> and
--   <a>TraversableB</a>, which is how <a>Symbolic</a> values are turned
--   into <a>Concrete</a> ones.
newtype Var a v
Var :: v a -> Var a v

-- | Take the value from a concrete variable.
concrete :: Var a Concrete -> a

-- | Take the value from an opaque concrete variable.
opaque :: Var (Opaque a) Concrete -> a

-- | Symbolic values: Because hedgehog generates actions in a separate
--   phase before execution, you will sometimes need to refer to the result
--   of a previous action in a generator without knowing the value of the
--   result (e.g., to get the ID of a previously-created user).
--   
--   Symbolic variables provide a token to stand in for the actual
--   variables at generation time (and in <a>Require</a>/<a>Update</a>
--   callbacks). At execution time, real values are available, so your
--   execute actions work on <a>Concrete</a> variables.
--   
--   See also: <a>Command</a>, <a>Var</a>
data Symbolic a

-- | Concrete values: At test-execution time, <a>Symbolic</a> values from
--   generation are replaced with <a>Concrete</a> values from performing
--   actions. This type gives us something of the same kind as
--   <a>Symbolic</a> to pass as a type argument to <a>Var</a>.
newtype Concrete a
[Concrete] :: a -> Concrete a

-- | Opaque values.
--   
--   Useful if you want to put something without a <a>Show</a> instance
--   inside something which you'd like to be able to display.
--   
--   For example:
--   
--   <pre>
--   data State v =
--     State {
--         stateRefs :: [Var (Opaque (IORef Int)) v]
--       } deriving (Eq, Show)
--   </pre>
newtype Opaque a
Opaque :: a -> Opaque a
[unOpaque] :: Opaque a -> a

-- | Distribute one monad transformer over another.
distributeT :: (MonadTransDistributive g, Transformer f g m) => g (f m) a -> f (g m) a
class () => FunctorB (b :: k -> Type -> Type)
bmap :: FunctorB b => (forall (a :: k). () => f a -> g a) -> b f -> b g
class FunctorB b => TraversableB (b :: k -> Type -> Type)
btraverse :: (TraversableB b, Applicative e) => (forall (a :: k). () => f a -> e (g a)) -> b f -> e (b g)
newtype () => Rec p a (x :: k)
Rec :: K1 R a x -> Rec p a (x :: k)
[unRec] :: Rec p a (x :: k) -> K1 R a x

-- | Lifting of the <a>Eq</a> class to unary type constructors.
--   
--   Any instance should be subject to the following law that canonicity is
--   preserved:
--   
--   <tt>liftEq (==)</tt> = <tt>(==)</tt>
--   
--   This class therefore represents the generalization of <a>Eq</a> by
--   decomposing its main method into a canonical lifting on a canonical
--   inner method, so that the lifting can be reused for other arguments
--   than the canonical one.
class forall a. Eq a => Eq f a => Eq1 (f :: Type -> Type)

-- | Lift the standard <tt>(<a>==</a>)</tt> function through the type
--   constructor.
eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool

-- | Lifting of the <a>Ord</a> class to unary type constructors.
--   
--   Any instance should be subject to the following law that canonicity is
--   preserved:
--   
--   <tt>liftCompare compare</tt> = <a>compare</a>
--   
--   This class therefore represents the generalization of <a>Ord</a> by
--   decomposing its main method into a canonical lifting on a canonical
--   inner method, so that the lifting can be reused for other arguments
--   than the canonical one.
class (Eq1 f, forall a. Ord a => Ord f a) => Ord1 (f :: Type -> Type)

-- | Lift the standard <a>compare</a> function through the type
--   constructor.
compare1 :: (Ord1 f, Ord a) => f a -> f a -> Ordering

-- | Lifting of the <a>Show</a> class to unary type constructors.
--   
--   Any instance should be subject to the following laws that canonicity
--   is preserved:
--   
--   <tt>liftShowsPrec showsPrec showList</tt> = <a>showsPrec</a>
--   
--   <tt>liftShowList showsPrec showList</tt> = <a>showList</a>
--   
--   This class therefore represents the generalization of <a>Show</a> by
--   decomposing it's methods into a canonical lifting on a canonical inner
--   method, so that the lifting can be reused for other arguments than the
--   canonical one.
class forall a. Show a => Show f a => Show1 (f :: Type -> Type)

-- | Lift the standard <a>showsPrec</a> and <a>showList</a> functions
--   through the type constructor.
showsPrec1 :: (Show1 f, Show a) => Int -> f a -> ShowS

-- | Higher-order traversable functors.
--   
--   <i>Deprecated in favor of <a>TraversableB</a> which can be derived
--   using <a>GHC.Generics</a></i>

-- | <i>Deprecated: Replace with Hedgehog.TraversableB (defined in
--   Data.Functor.Barbie) which can be derived automatically using
--   GHC.Generics</i>
class HTraversable t
htraverse :: (HTraversable t, Applicative f) => (forall a. g a -> f (h a)) -> t g -> f (t h)
