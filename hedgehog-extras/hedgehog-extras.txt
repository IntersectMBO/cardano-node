-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Supplemental library for hedgehog
--   
--   Supplemental library for hedgehog.
@package hedgehog-extras
@version 0.8.0.0

module Hedgehog.Extras.Aeson
goldenTestJsonValue :: forall a. () => Eq a => FromJSON a => Show a => ToJSON a => HasCallStack => a -> FilePath -> Property
goldenTestJsonValuePretty :: forall a. () => Eq a => FromJSON a => HasCallStack => Show a => ToJSON a => a -> FilePath -> Property

module Hedgehog.Extras.Internal.Cli

-- | Format argument for a shell CLI command.
--   
--   This includes automatically embedding string in double quotes if
--   necessary, including any necessary escaping.
--   
--   Note, this function does not cover all the edge cases for shell
--   processing, so avoid use in production code.
argQuote :: String -> String

module Hedgehog.Extras.Internal.Orphans
instance Control.Monad.Base.MonadBase GHC.Types.IO (Control.Monad.Trans.Resource.Internal.ResourceT GHC.Types.IO)
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO (Control.Monad.Trans.Resource.Internal.ResourceT GHC.Types.IO)

module Hedgehog.Extras.Internal.Plan
newtype Plan
Plan :: [Component] -> Plan
[installPlan] :: Plan -> [Component]
data Component
Component :: Maybe Text -> Maybe Text -> Component
[componentName] :: Component -> Maybe Text
[binFile] :: Component -> Maybe Text
instance GHC.Show.Show Hedgehog.Extras.Internal.Plan.Component
instance GHC.Classes.Eq Hedgehog.Extras.Internal.Plan.Component
instance GHC.Generics.Generic Hedgehog.Extras.Internal.Plan.Component
instance GHC.Show.Show Hedgehog.Extras.Internal.Plan.Plan
instance GHC.Classes.Eq Hedgehog.Extras.Internal.Plan.Plan
instance GHC.Generics.Generic Hedgehog.Extras.Internal.Plan.Plan
instance Data.Aeson.Types.FromJSON.FromJSON Hedgehog.Extras.Internal.Plan.Plan
instance Data.Aeson.Types.FromJSON.FromJSON Hedgehog.Extras.Internal.Plan.Component

module Hedgehog.Extras.Internal.Test.Integration
type Integration a = PropertyT (ReaderT IntegrationState (ResourceT IO)) a
newtype IntegrationState
IntegrationState :: TVar [Integration ()] -> IntegrationState
[integrationStateFinals] :: IntegrationState -> TVar [Integration ()]
newIntegrationStateIO :: IO IntegrationState
newIntegrationStateM :: MonadIO m => m IntegrationState
runIntegrationReaderT :: MonadIO m => ReaderT IntegrationState m a -> m a
instance GHC.Generics.Generic Hedgehog.Extras.Internal.Test.Integration.IntegrationState

module Hedgehog.Extras.Stock.Aeson

-- | Rewrite a JSON object to another JSON object using the function
--   <tt>f</tt>.
--   
--   All other JSON values are preserved.
rewriteObject :: (KeyMap Value -> KeyMap Value) -> Value -> Value

-- | Rewrite each element of a JSON array using the function <tt>f</tt>.
--   
--   All other JSON values are preserved.
rewriteArrayElements :: (Value -> Value) -> Value -> Value

module Hedgehog.Extras.Stock.CallStack

-- | Get the module name of the caller.
callerModuleName :: HasCallStack => String

module Hedgehog.Extras.Stock.IO.File

-- | Determine if the given string is found in the given file.
fileContains :: String -> FilePath -> IO Bool

module Hedgehog.Extras.Stock.IO.Network.NamedPipe
doesNamedPipeExist :: FilePath -> IO Bool

module Hedgehog.Extras.Stock.IO.Network.Port

-- | Return a random available port on a specified host address
randomPort :: () => MonadIO m => MonadFail m => HostAddress -> m PortNumber
reserveRandomPort :: () => MonadFail m => MonadResource m => HostAddress -> m (ReleaseKey, PortNumber)

-- | Check if a port is in use on a specified host address
portInUse :: () => MonadIO m => HostAddress -> PortNumber -> m Bool

module Hedgehog.Extras.Stock.IO.Network.Socket
doesSocketExist :: FilePath -> IO Bool

-- | Check if a TCP port is open
isPortOpen :: Int -> IO Bool

-- | Check if it is possible to connect to a socket address
canConnect :: SockAddr -> IO ()

-- | Open a socket at the specified port for listening
listenOn :: Int -> IO Socket

-- | Allocate the specified number of random ports
allocateRandomPorts :: Int -> IO [Int]

module Hedgehog.Extras.Stock.IO.Process
maybeWaitForProcess :: ProcessHandle -> IO (Maybe ExitCode)
waitSecondsForProcess :: Int -> ProcessHandle -> IO (Either TimedOut (Maybe ExitCode))
data TimedOut
TimedOut :: TimedOut
instance GHC.Show.Show Hedgehog.Extras.Stock.IO.Process.TimedOut
instance GHC.Classes.Eq Hedgehog.Extras.Stock.IO.Process.TimedOut
instance GHC.Generics.Generic Hedgehog.Extras.Stock.IO.Process.TimedOut

module Hedgehog.Extras.Stock.Monad

-- | Force the evaluation of the return value in a monadic computation.
forceM :: (Monad m, NFData a) => m a -> m a

module Hedgehog.Extras.Stock.OS

-- | Determine if the operating system is Windows.
isWin32 :: Bool

module Hedgehog.Extras.Stock.IO.Network.Sprocket

-- | Socket emulation. On Posix it represents a socket. On Windows it
--   represents a named pipe.
data Sprocket
Sprocket :: String -> String -> Sprocket
[sprocketBase] :: Sprocket -> String
[sprocketName] :: Sprocket -> String

-- | Test if the sprocket exists
doesSprocketExist :: Sprocket -> IO Bool

-- | Use this when needing to pass a sprocket into a command line argument.
sprocketArgumentName :: Sprocket -> FilePath

-- | Use this to query the OS about the sprocket
sprocketSystemName :: Sprocket -> FilePath
maxSprocketArgumentNameLength :: Int
instance GHC.Show.Show Hedgehog.Extras.Stock.IO.Network.Sprocket.Sprocket
instance GHC.Classes.Eq Hedgehog.Extras.Stock.IO.Network.Sprocket.Sprocket
instance GHC.Generics.Generic Hedgehog.Extras.Stock.IO.Network.Sprocket.Sprocket

module Hedgehog.Extras.Stock.Time

-- | Show <a>UTCTime</a> in seconds since epoch
showUTCTimeSeconds :: UTCTime -> String

-- | Format the given time as an ISO 8601 date-time string
formatIso8601 :: UTCTime -> String


-- | This modules provides concurrency abstractions for hedgehog tests.
--   Using "lifted-base" one can execute expensive test actions
--   concurrently.
--   
--   For example, the actions invoked inside <a>mapConcurrently_</a> are
--   invoked in the same <a>MonadTest</a> as the outer monad of
--   <a>mapConcurrently_</a>.
--   
--   <pre>
--   import qualified Hedgehog.Extras.Test.Concurrent as H
--   
--   setUpEnvironment = H.mapConcurrently_ id
--     [ H.threadDelay 100 &gt;&gt; pure 1
--     , H.threadDelay 200 &gt;&gt; pure 2
--     , H.threadDelay 300 &gt;&gt; pure 3
--     ]
--   </pre>
--   
--   <b>Warning: Do not use this module for running concurrent checks!</b>
--   The <tt>MonadBaseControl</tt> instance does not aggregate effects for
--   <a>PropertyT</a>. Consider the following code:
--   
--   <pre>
--   LA.mapConcurrently_ id
--     [ do
--       H.note_ "FAIL1"
--       success
--     , do
--       IO.threadDelay 1_000_000
--       H.note_ "FAIL2"
--       failure
--     , do
--       H.note_ "FAIL3"
--       failure
--     ]
--   </pre>
--   
--   Executing this code will give you the following output in the test
--   report:
--   
--   <pre>
--   66 ┃   LA.mapConcurrently_ id
--   67 ┃     [ do
--   68 ┃       H.note_ "FAIL1"
--      ┃       │ FAIL1
--   69 ┃       success
--   70 ┃     , do
--   71 ┃       IO.threadDelay 1_000_000
--   72 ┃       H.note_ "FAIL2"
--      ┃       │ FAIL2
--   73 ┃       failure
--      ┃       ^^^^^^^
--   74 ┃     , do
--   75 ┃       H.note_ "FAIL3"
--   76 ┃       failure
--   77 ┃     ]
--   </pre>
--   
--   Please note that only <tt>FAIL1</tt> and <tt>FAIL2</tt> annotations
--   were reported - <tt>FAIL3</tt> annotation and the failure below was
--   swallowed without any information.
--   
--   <b>Don't use concurrency abstractions from this module, when you need
--   to aggregate and report failures!</b>
module Hedgehog.Extras.Test.Concurrent

-- | Delay the thread by <tt>n</tt> microseconds.
threadDelay :: (HasCallStack, MonadTest m, MonadIO m) => Int -> m ()

-- | Runs an action in background, and registers its cancellation to
--   <a>MonadResource</a>.
asyncRegister_ :: HasCallStack => MonadTest m => MonadResource m => MonadCatch m => IO a -> m ()

module Hedgehog.Extras.Test.Prim

-- | Takes a <a>CallStack</a> so the error can be rendered at the
--   appropriate call site.
failWithCustom :: MonadTest m => CallStack -> Maybe Diff -> String -> m a

-- | Takes a <a>CallStack</a> so the error can be rendered at the
--   appropriate call site.
failMessage :: MonadTest m => CallStack -> String -> m a

module Hedgehog.Extras.Test.MonadAssertion
class Monad m => MonadAssertion m
throwAssertion :: MonadAssertion m => Failure -> m a
catchAssertion :: MonadAssertion m => m a -> (Failure -> m a) -> m a

-- | Run the given action and succeed if the action fails, but fail if it
--   succeeds.
assertFailure :: () => HasCallStack => Show a => MonadAssertion m => MonadTest m => m a -> m Failure

-- | Run the given action and succeed if the action fails, but fail if it
--   succeeds.
assertFailure_ :: () => HasCallStack => Show a => MonadAssertion m => MonadTest m => m a -> m ()

-- | Attempt to run a function that may assert, returning either a failure
--   or the result of the assertion.
tryAssertion :: () => MonadAssertion m => m a -> m (Either Failure a)
instance GHC.Base.Monad m => Hedgehog.Extras.Test.MonadAssertion.MonadAssertion (Hedgehog.Internal.Property.PropertyT m)
instance GHC.Base.Monad m => Hedgehog.Extras.Test.MonadAssertion.MonadAssertion (Hedgehog.Internal.Property.TestT m)
instance Hedgehog.Extras.Test.MonadAssertion.MonadAssertion m => Hedgehog.Extras.Test.MonadAssertion.MonadAssertion (Control.Monad.Trans.Resource.Internal.ResourceT m)

module Hedgehog.Extras.Test.Base

-- | Run a property with only one test. This is intended for allowing
--   hedgehog to run unit tests.
propertyOnce :: HasCallStack => Integration () -> Property

-- | Create a workspace directory which will exist for at least the
--   duration of the supplied block.
--   
--   The directory will have the supplied prefix but contain a generated
--   random suffix to prevent interference between tests
--   
--   The directory will be deleted if the block succeeds, but left behind
--   if the block fails.
workspace :: MonadTest m => HasCallStack => MonadResource m => FilePath -> (FilePath -> m ()) -> m ()

-- | Create a workspace directory which will exist for at least the
--   duration of the supplied block.
--   
--   The directory will have the prefix as "$prefixPath/$moduleName" but
--   contain a generated random suffix to prevent interference between
--   tests
--   
--   The directory will be deleted if the block succeeds, but left behind
--   if the block fails.
--   
--   The <tt>prefix</tt> argument should not contain directory delimeters.
moduleWorkspace :: (MonadTest m, MonadResource m, HasCallStack) => String -> (FilePath -> m ()) -> m ()

-- | Annotate with the given string.
note :: (MonadTest m, HasCallStack) => String -> m String

-- | Annotate the given string returning unit.
note_ :: (MonadTest m, HasCallStack) => String -> m ()

-- | Annotate the given string in a monadic context.
noteM :: (MonadTest m, MonadCatch m, HasCallStack) => m String -> m String

-- | Annotate the given string in a monadic context returning unit.
noteM_ :: (MonadTest m, MonadCatch m, HasCallStack) => m String -> m ()

-- | Annotate the given string in IO.
noteIO :: (MonadTest m, MonadIO m, HasCallStack) => IO String -> m String

-- | Annotate the given string in IO returning unit.
noteIO_ :: (MonadTest m, MonadIO m, HasCallStack) => IO String -> m ()

-- | Annotate the given value.
noteShow :: (MonadTest m, HasCallStack, Show a) => a -> m a

-- | Annotate the given value, pretty printing it with indentation. Note
--   that large data structures will take a significant amount of vertical
--   screen space.
noteShowPretty :: (MonadTest m, HasCallStack, Show a) => a -> m a

-- | Annotate the given value in IO.
noteShowIO :: (MonadTest m, MonadIO m, HasCallStack, Show a) => IO a -> m a

-- | Annotate the given value in IO, pretty printing it with indentation.
--   Note that large data structures will take a significant amount of
--   vertical screen space.
noteShowPrettyIO :: (MonadTest m, MonadIO m, HasCallStack, Show a) => IO a -> m a

-- | Annotate the given value in IO returning unit.
noteShowIO_ :: (MonadTest m, MonadIO m, HasCallStack, Show a) => IO a -> m ()

-- | Annotate the given value in IO returning unit, pretty printing it with
--   indentation. Note that large data structures will take a significant
--   amount of vertical screen space.
noteShowPrettyIO_ :: (MonadTest m, MonadIO m, HasCallStack, Show a) => IO a -> m ()

-- | Annotate the given value in a monadic context.
noteShowM :: (MonadTest m, MonadCatch m, HasCallStack, Show a) => m a -> m a

-- | Annotate the given value in a monadic context, pretty printing it with
--   indentation. Note that large data structures will take a significant
--   amount of vertical screen space.
noteShowPrettyM :: (MonadTest m, MonadCatch m, HasCallStack, Show a) => m a -> m a

-- | Annotate the given value in a monadic context returning unit.
noteShowM_ :: (MonadTest m, MonadCatch m, HasCallStack, Show a) => m a -> m ()

-- | Annotate the given value in a monadic context returning unit, pretty
--   printing it with indentation. Note that large data structures will
--   take a significant amount of vertical screen space.
noteShowPrettyM_ :: (MonadTest m, MonadCatch m, HasCallStack, Show a) => m a -> m ()

-- | Annotate the given value returning unit.
noteShow_ :: (MonadTest m, HasCallStack, Show a) => a -> m ()

-- | Annotate the given value returning unit, pretty printing it with
--   indentation. Note that large data structures will take a significant
--   amount of vertical screen space.
noteShowPretty_ :: (MonadTest m, HasCallStack, Show a) => a -> m ()

-- | Annotate the each value in the given traversable.
noteEach :: (MonadTest m, HasCallStack, Show a, Traversable f) => f a -> m (f a)

-- | Annotate the each value in the given traversable, pretty printing it
--   with indentation. Note that large data structures will take a
--   significant amount of vertical screen space.
noteEachPretty :: (MonadTest m, HasCallStack, Show a, Traversable f) => f a -> m (f a)

-- | Annotate the each value in the given traversable in IO.
noteEachIO :: (MonadTest m, MonadIO m, HasCallStack, Show a, Traversable f) => IO (f a) -> m (f a)

-- | Annotate the each value in the given traversable in IO, pretty
--   printing it with indentation. Note that large data structures will
--   take a significant amount of vertical screen space.
noteEachPrettyIO :: (MonadTest m, MonadIO m, HasCallStack, Show a, Traversable f) => IO (f a) -> m (f a)

-- | Annotate the each value in the given traversable in IO returning unit.
noteEachIO_ :: (MonadTest m, MonadIO m, HasCallStack, Show a, Traversable f) => IO (f a) -> m ()

-- | Annotate the each value in the given traversable in IO returning unit,
--   pretty printing it with indentation. Note that large data structures
--   will take a significant amount of vertical screen space.
noteEachPrettyIO_ :: (MonadTest m, MonadIO m, HasCallStack, Show a, Traversable f) => IO (f a) -> m ()

-- | Annotate the each value in the given traversable in a monadic context.
noteEachM :: (MonadTest m, HasCallStack, Show a, Traversable f) => m (f a) -> m (f a)

-- | Annotate the each value in the given traversable in a monadic context,
--   pretty printing it with indentation. Note that large data structures
--   will take a significant amount of vertical screen space.
noteEachPrettyM :: (MonadTest m, HasCallStack, Show a, Traversable f) => m (f a) -> m (f a)

-- | Annotate the each value in the given traversable in a monadic context
--   returning unit.
noteEachM_ :: (MonadTest m, HasCallStack, Show a, Traversable f) => m (f a) -> m ()

-- | Annotate the each value in the given traversable in a monadic context
--   returning unit, pretty printing it with indentation. Note that large
--   data structures will take a significant amount of vertical screen
--   space.
noteEachPrettyM_ :: (MonadTest m, HasCallStack, Show a, Traversable f) => m (f a) -> m ()

-- | Annotate the each value in the given traversable returning unit.
noteEach_ :: (MonadTest m, HasCallStack, Show a, Traversable f) => f a -> m ()

-- | Annotate the each value in the given traversable returning unit,
--   pretty printing it with indentation. Note that large data structures
--   will take a significant amount of vertical screen space.
noteEachPretty_ :: (MonadTest m, HasCallStack, Show a, Traversable f) => f a -> m ()

-- | Return the test file path after annotating it relative to the project
--   root directory
noteTempFile :: (MonadTest m, HasCallStack) => FilePath -> FilePath -> m FilePath
headM :: (MonadTest m, HasCallStack) => [a] -> m a
indexM :: (MonadTest m, HasCallStack) => Int -> [a] -> m a

-- | Index into a list. On failure, a friendly message is included in the
--   test report.
fromJustM :: (MonadTest m, HasCallStack) => Maybe a -> m a

-- | Fail when the result is Nothing.
nothingFail :: (MonadTest m, HasCallStack) => Maybe a -> m a

-- | Fail when the computed result is Nothing.
nothingFailM :: (MonadTest m, HasCallStack) => m (Maybe a) -> m a

-- | Fail when the result is Left.
leftFail :: (MonadTest m, Show e, HasCallStack) => Either e a -> m a

-- | Fail when the computed result is Left.
leftFailM :: (MonadTest m, Show e, HasCallStack) => m (Either e a) -> m a
onLeft :: Monad m => (e -> m a) -> m (Either e a) -> m a
onNothing :: Monad m => m a -> m (Maybe a) -> m a

-- | Fail when the result is Error.
jsonErrorFail :: (MonadTest m, HasCallStack) => Result a -> m a

-- | Fail when the computed result is Error.
jsonErrorFailM :: (MonadTest m, HasCallStack) => m (Result a) -> m a

-- | Takes a <a>CallStack</a> so the error can be rendered at the
--   appropriate call site.
failWithCustom :: MonadTest m => CallStack -> Maybe Diff -> String -> m a

-- | Takes a <a>CallStack</a> so the error can be rendered at the
--   appropriate call site.
failMessage :: MonadTest m => CallStack -> String -> m a

-- | Invert the behavior of a property: success becomes failure and vice
--   versa.
expectFailure :: (MonadTest m, MonadIO m, HasCallStack) => TestT IO a -> m ()

-- | Invert the behavior of a property: success becomes failure and vice
--   versa. This function behaves like <a>expectFailure</a> but it allows
--   to check the failure is as expected. The function takes a
--   <tt>Failure</tt> and should itself be a test that fails if the failure
--   is not as expected.
expectFailureWith :: (MonadTest m, MonadIO m, HasCallStack) => (Failure -> m ()) -> TestT IO b -> m ()

-- | Attempt to run a function that may assert, returning either a failure
--   or the result of the assertion.
tryAssertion :: () => MonadAssertion m => m a -> m (Either Failure a)

-- | Run the given action and succeed if the action fails, but fail if it
--   succeeds.
assertFailure :: () => HasCallStack => Show a => MonadAssertion m => MonadTest m => m a -> m Failure

-- | Run the given action and succeed if the action fails, but fail if it
--   succeeds.
assertFailure_ :: () => HasCallStack => Show a => MonadAssertion m => MonadTest m => m a -> m ()

-- | Run the operation <tt>f</tt> once a second until it returns
--   <a>True</a> or the deadline expires.
--   
--   Expiration of the deadline results in an assertion failure
assertByDeadlineM :: (MonadTest m, MonadIO m, HasCallStack) => UTCTime -> m Bool -> m ()

-- | Run the operation <tt>f</tt> once a second until it returns
--   <a>True</a> or the deadline expires.
--   
--   Expiration of the deadline results in an assertion failure
assertByDeadlineIO :: (MonadTest m, MonadIO m, HasCallStack) => UTCTime -> IO Bool -> m ()

-- | Run the operation <tt>f</tt> once a second until it returns
--   <a>True</a> or the deadline expires.
--   
--   The action <tt>g</tt> is run after expiration of the deadline, but
--   before failure allowing for additional annotations to be presented.
--   
--   Expiration of the deadline results in an assertion failure
assertByDeadlineMFinally :: (MonadTest m, MonadIO m, HasCallStack) => UTCTime -> m Bool -> m () -> m ()

-- | Run the operation <tt>f</tt> once a second until it returns
--   <a>True</a> or the deadline expires.
--   
--   The action <tt>g</tt> is run after expiration of the deadline, but
--   before failure allowing for additional annotations to be presented.
--   
--   Expiration of the deadline results in an assertion failure
assertByDeadlineIOFinally :: (MonadTest m, MonadIO m, HasCallStack) => UTCTime -> IO Bool -> m () -> m ()

-- | Run the test function against the value. Report the value on the
--   failure.
assertWith :: (MonadTest m, Show p, HasCallStack) => p -> (p -> Bool) -> m ()

-- | Run the test function against the value. Report the value on the
--   failure.
assertWithM :: (MonadTest m, Show p, HasCallStack) => p -> (p -> m Bool) -> m ()

-- | Run the monadic action <tt>f</tt> and assert the return value is
--   <a>True</a>.
assertM :: (MonadTest m, HasCallStack) => m Bool -> m ()

-- | Run the IO action <tt>f</tt> and assert the return value is
--   <a>True</a>.
assertIO :: (MonadTest m, MonadIO m, HasCallStack) => IO Bool -> m ()

-- | Tests if <tt>|c - v| &lt;= r</tt>
assertWithinTolerance :: (Show a, Ord a, Num a, HasCallStack, MonadTest m) => a -> a -> a -> m ()

-- | Run the operation <tt>f</tt> once per <tt>period</tt> until it returns
--   <a>True</a> or the deadline expires.
--   
--   Expiration of the deadline results in an assertion failure
byDeadlineM :: forall m a. (MonadAssertion m, MonadTest m, MonadIO m, HasCallStack) => NominalDiffTime -> UTCTime -> String -> m a -> m a

-- | Run the operation <tt>f</tt> once per <tt>period</tt> until it returns
--   <a>True</a> or the deadline expires.
--   
--   Expiration of the deadline results in an assertion failure
byDeadlineIO :: (MonadAssertion m, MonadTest m, MonadIO m, HasCallStack) => NominalDiffTime -> UTCTime -> String -> IO a -> m a

-- | Run the operation <tt>f</tt> once per <tt>period</tt> until it returns
--   <a>True</a> or the duration expires.
--   
--   Expiration of the duration results in an assertion failure
byDurationM :: (MonadAssertion m, MonadTest m, MonadIO m, HasCallStack) => NominalDiffTime -> NominalDiffTime -> String -> m a -> m a

-- | Run the operation <tt>f</tt> once per <tt>period</tt> until it returns
--   <a>True</a> or the duration expires.
--   
--   Expiration of the duration results in an assertion failure
byDurationIO :: (MonadAssertion m, MonadTest m, MonadIO m, HasCallStack) => NominalDiffTime -> NominalDiffTime -> String -> IO a -> m a
onFailure :: Integration () -> Integration ()
type Integration a = PropertyT (ReaderT IntegrationState (ResourceT IO)) a

-- | Release the given release key.
release :: (MonadTest m, MonadIO m) => ReleaseKey -> m ()
runFinallies :: Integration a -> Integration a
retry :: forall a. Int -> (Int -> Integration a) -> Integration a
retry' :: forall a. Int -> Integration a -> Integration a
class MonadBase b m => MonadBaseControl (b :: Type -> Type) (m :: Type -> Type) | m -> b
bracket :: MonadBaseControl IO m => m a -> (a -> m b) -> (a -> m c) -> m c
bracket_ :: MonadBaseControl IO m => m a -> m b -> m c -> m c

module Hedgehog.Extras.Test.Network

-- | Test if a file exists
doesFileExists :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m Bool

-- | Test if a port is open
isPortOpen :: (MonadTest m, MonadIO m, HasCallStack) => Int -> m Bool

-- | Test if a socket file exists
doesSocketExist :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m Bool

-- | Assert that a port is open
assertPortOpen :: (MonadTest m, MonadIO m, HasCallStack) => Int -> m ()

-- | Assert that a socket file exists is open
assertSocketExists :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ()

-- | Test if the sprocket exists
doesSprocketExist :: (MonadTest m, MonadIO m, HasCallStack) => Sprocket -> m Bool

-- | Download from a URl to a file
downloadToFile :: (MonadTest m, MonadIO m, HasCallStack) => String -> FilePath -> m ()

-- | Download a github commit to a temporary directory, extract it and
--   return the path to the extracted directory.
--   
--   If the file is already downloaded, it will not be downloaded again. If
--   the file is already extracted, it will not be extracted again.
downloadAndExtractGithubCommitToTemp :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> String -> String -> m FilePath

module Hedgehog.Extras.Test.File

-- | Create the <tt>directory</tt> directory if it is missing.
createDirectoryIfMissing :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m FilePath

-- | Create the <tt>directory</tt> directory if it is missing.
createDirectoryIfMissing_ :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ()

-- | Create the <tt>subdirectory</tt> subdirectory if it is missing. The
--   subdirectory is returned.
createSubdirectoryIfMissing :: () => HasCallStack => MonadTest m => MonadIO m => FilePath -> FilePath -> m FilePath

-- | Create the <tt>subdirectory</tt> subdirectory if it is missing. The
--   subdirectory is returned.
createSubdirectoryIfMissing_ :: () => HasCallStack => MonadTest m => MonadIO m => FilePath -> FilePath -> m ()

-- | Copy the contents of the <tt>src</tt> file to the <tt>dst</tt> file.
copyFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> FilePath -> m ()

-- | Rename the <tt>src</tt> file to <tt>dst</tt>.
renameFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> FilePath -> m ()

-- | Create a symbolic link from <tt>dst</tt> to <tt>src</tt>.
createFileLink :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> FilePath -> m ()

-- | List <tt>p</tt> directory.
listDirectory :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m [FilePath]

-- | Append <tt>contents</tt> to the <tt>filePath</tt> file.
appendFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> String -> m ()

-- | Write <tt>contents</tt> to the <tt>filePath</tt> file.
writeFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> String -> m ()

-- | Open a handle to the <tt>filePath</tt> file.
openFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> IOMode -> m Handle

-- | Read the contents of the <tt>filePath</tt> file.
readFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m String

-- | Write <tt>contents</tt> to the <tt>filePath</tt> file.
lbsWriteFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> ByteString -> m ()

-- | Read the contents of the <tt>filePath</tt> file.
lbsReadFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ByteString

-- | Write <tt>contents</tt> to the <tt>filePath</tt> file.
textWriteFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> Text -> m ()

-- | Read the contents of the <tt>filePath</tt> file.
textReadFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m Text

-- | Rewrite the <tt>filePath</tt> JSON file using the function <tt>f</tt>.
copyRewriteJsonFile :: forall a m. (MonadTest m, MonadIO m, FromJSON a, ToJSON a, HasCallStack) => FilePath -> FilePath -> (a -> a) -> m ()

-- | Read the <tt>filePath</tt> file as JSON. Use <tt>readJsonFile
--   @<a>Value</a></tt> to decode into <a>Value</a>.
readJsonFile :: forall a m. (MonadTest m, MonadIO m, FromJSON a, HasCallStack) => FilePath -> m (Either String a)

-- | Read the <tt>filePath</tt> file as JSON. Same as <a>readJsonFile</a>
--   but fails on error. Use <tt>readJsonFileOk @<a>Value</a></tt> to
--   decode into <a>Value</a>.
readJsonFileOk :: forall a m. (MonadTest m, MonadIO m, FromJSON a, HasCallStack) => FilePath -> m a

-- | Rewrite the <tt>filePath</tt> JSON file using the function <tt>f</tt>.
rewriteJsonFile :: forall a m. (MonadTest m, MonadIO m, FromJSON a, ToJSON a, HasCallStack) => FilePath -> (a -> a) -> m ()
rewriteLbsJson :: forall a m. (MonadTest m, FromJSON a, ToJSON a, HasCallStack) => (a -> a) -> ByteString -> m ByteString

-- | Rewrite the <tt>filePath</tt> YAML file using the function <tt>f</tt>.
copyRewriteYamlFile :: forall a m. (MonadTest m, MonadIO m, FromJSON a, ToJSON a, HasCallStack) => FilePath -> FilePath -> (a -> a) -> m ()

-- | Read the <tt>filePath</tt> file as YAML.
readYamlFile :: forall a m. (MonadTest m, MonadIO m, FromJSON a, HasCallStack) => FilePath -> m (Either ParseException a)

-- | Read the <tt>filePath</tt> file as YAML. Same as <a>readYamlFile</a>
--   but fails on error.
readYamlFileOk :: forall a m. (MonadTest m, MonadIO m, FromJSON a, HasCallStack) => FilePath -> m a

-- | Rewrite the <tt>filePath</tt> YAML file using the function <tt>f</tt>.
rewriteYamlFile :: forall a m. (MonadTest m, MonadIO m, FromJSON a, ToJSON a, HasCallStack) => FilePath -> (a -> a) -> m ()
rewriteLbsYaml :: forall a m. (MonadTest m, FromJSON a, ToJSON a, HasCallStack) => (a -> a) -> ByteString -> m ByteString

-- | Annotate the contents of the <tt>filePath</tt> file.
cat :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ()

-- | Assert the <tt>filePath</tt> can be parsed as JSON.
assertIsJsonFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ()

-- | Assert the <tt>filePath</tt> can be parsed as YAML.
assertIsYamlFile :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ()

-- | Asserts that the given file exists.
assertFileExists :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ()

-- | Asserts that all of the given files exist.
assertFilesExist :: (MonadTest m, MonadIO m, HasCallStack) => [FilePath] -> m ()

-- | Asserts that the given file is missing.
assertFileMissing :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ()

-- | Asserts that all of the given files are missing.
assertFilesMissing :: (MonadTest m, MonadIO m, HasCallStack) => [FilePath] -> m ()

-- | Assert the file contains the given number of occurrences of the given
--   string
assertFileOccurences :: (MonadTest m, MonadIO m, HasCallStack) => Int -> String -> FilePath -> m ()

-- | Assert the file contains the given number of occurrences of the given
--   string
assertFileLines :: (MonadTest m, MonadIO m, HasCallStack) => (Int -> Bool) -> FilePath -> m ()

-- | Assert the file contains the given number of occurrences of the given
--   string
assertEndsWithSingleNewline :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ()

-- | Write <tt>contents</tt> to the <tt>filePath</tt> file.
appendFileTimeDelta :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> UTCTime -> m ()

-- | Asserts that the given directory is missing.
assertDirectoryMissing :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ()

-- | Asserts that the given directory exists.
assertDirectoryExists :: (MonadTest m, MonadIO m, HasCallStack) => FilePath -> m ()

module Hedgehog.Extras.Test.Golden

-- | Diff contents against the golden file. If CREATE_GOLDEN_FILES
--   environment is set to "1", then should the golden file not exist it
--   would be created. If RECREATE_GOLDEN_FILES is set to "1", then should
--   the golden file exist it would be recreated. If GOLDEN_FILE_LOG_FILE
--   is set to a filename, then the golden file path will be logged to the
--   specified file.
--   
--   Set the environment variable when you intend to generate or
--   re-generate the golden file for example when running the test for the
--   first time or if the golden file genuinely needs to change.
--   
--   To re-generate a golden file you must also delete the golden file
--   because golden files are never overwritten.
--   
--   TODO: Improve the help output by saying the difference of each input.
diffVsGoldenFile :: HasCallStack => MonadIO m => MonadBaseControl IO m => MonadTest m => String -> FilePath -> m ()

-- | Diff file against the golden file. If CREATE_GOLDEN_FILES environment
--   is set to "1", then should the gold file not exist it would be
--   created. If GOLDEN_FILE_LOG_FILE is set to a filename, then the golden
--   file path will be logged to the specified file.
--   
--   Set the environment variable when you intend to generate or
--   re-generate the golden file for example when running the test for the
--   first time or if the golden file genuinely needs to change.
--   
--   To re-generate a golden file you must also delete the golden file
--   because golden files are never overwritten.
diffFileVsGoldenFile :: HasCallStack => MonadBaseControl IO m => MonadIO m => MonadTest m => FilePath -> FilePath -> m ()

-- | Diff contents against the golden file, excluding the trace. If
--   CREATE_GOLDEN_FILES environment is set to "1", then should the golden
--   file not exist it would be created. If RECREATE_GOLDEN_FILES is set to
--   "1", then should the golden file exist it would be recreated. If
--   GOLDEN_FILE_LOG_FILE is set to a filename, then the golden file path
--   will be logged to the specified file.
--   
--   Set the environment variable when you intend to generate or
--   re-generate the golden file for example when running the test for the
--   first time or if the golden file genuinely needs to change.
--   
--   To re-generate a golden file you must also delete the golden file
--   because golden files are never overwritten.
diffVsGoldenFileExcludeTrace :: MonadBaseControl IO m => MonadIO m => MonadTest m => HasCallStack => String -> FilePath -> m ()

module Hedgehog.Extras.Stock.String

-- | Strip whitespace from the beginning and end of the string.
strip :: String -> String

-- | Get the last line in the string
lastLine :: String -> String

-- | Get the first line in the string
firstLine :: String -> String

-- | Trim leading and trailing whitespace and read the string into a value.
--   Report the read value in the test annotations.
readNoteM :: (Read a, Show a, MonadTest m, MonadCatch m, HasCallStack) => String -> m a

module Hedgehog.Extras.Stock

module Hedgehog.Extras.Test.Process

-- | Create a process returning handles to stdin, stdout, and stderr as
--   well as the process handle.
createProcess :: (MonadTest m, MonadResource m, HasCallStack) => CreateProcess -> m (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle, ReleaseKey)

-- | Execute a process, returning the stdout. Fail if the call returns with
--   a non-zero exit code. For a version that doesn't fail upon receiving a
--   non-zero exit code, see <a>execAny</a>.
exec :: (MonadTest m, MonadIO m, HasCallStack) => ExecConfig -> String -> [String] -> m String

-- | Execute a process, returning the error code, the stdout, and the
--   stderr.
execAny :: (MonadTest m, MonadIO m, HasCallStack) => ExecConfig -> String -> [String] -> m (ExitCode, String, String)

-- | Execute a process, returning <tt>()</tt>.
exec_ :: (MonadTest m, MonadIO m, HasCallStack) => ExecConfig -> String -> [String] -> m ()

-- | Create a process returning its stdout.
--   
--   Being a <tt>flex</tt> function means that the environment determines
--   how the process is launched.
--   
--   When running in a nix environment, the <tt>envBin</tt> argument
--   describes the environment variable that defines the binary to use to
--   launch the process.
--   
--   When running outside a nix environment, the <tt>pkgBin</tt> describes
--   the name of the binary to launch via cabal exec.
execFlex :: (MonadTest m, MonadCatch m, MonadIO m, HasCallStack) => String -> String -> [String] -> m String
execFlex' :: (MonadTest m, MonadCatch m, MonadIO m, HasCallStack) => ExecConfig -> String -> String -> [String] -> m String

-- | Run a process, returning its exit code, its stdout, and its stderr.
--   Contrary to <tt>execFlex'</tt>, this function doesn't fail if the call
--   fails. So, if you want to test something negative, this is the
--   function to use.
execFlexAny' :: (MonadTest m, MonadCatch m, MonadIO m, HasCallStack) => ExecConfig -> String -> String -> [String] -> m (ExitCode, String, String)

-- | Create a <a>CreateProcess</a> describing how to start a process given
--   the Cabal package name corresponding to the executable, an environment
--   variable pointing to the executable, and an argument list.
--   
--   The actual executable used will the one specified by the environment
--   variable, but if the environment variable is not defined, it will be
--   found instead by consulting the "plan.json" generated by cabal. It is
--   assumed that the project has already been configured and the
--   executable has been built.
procFlex :: (MonadTest m, MonadCatch m, MonadIO m, HasCallStack) => String -> String -> [String] -> m CreateProcess

-- | Compute the path to the binary given a package name or an environment
--   variable override.
binFlex :: (HasCallStack, MonadTest m, MonadIO m) => String -> String -> m FilePath

-- | Compute the project base. This will be based on either the
--   <a>CARDANO_NODE_SRC</a> environment variable or the first parent
--   directory that contains the `cabal.project`. Both should point to the
--   root directory of the Github project checkout.
getProjectBase :: (MonadTest m, MonadIO m) => m String

-- | Wait for process to exit.
waitForProcess :: (MonadTest m, MonadIO m, HasCallStack) => ProcessHandle -> m ExitCode

-- | Wait for process to exit or return <a>Nothing</a> if interrupted by an
--   asynchronous exception.
maybeWaitForProcess :: (MonadTest m, MonadIO m, HasCallStack) => ProcessHandle -> m (Maybe ExitCode)

-- | Get the process ID.
getPid :: (MonadTest m, MonadIO m, HasCallStack) => ProcessHandle -> m (Maybe Pid)

-- | Get the process ID.
getPidOk :: (MonadTest m, MonadIO m, HasCallStack) => ProcessHandle -> m Pid

-- | Wait a maximum of <tt>seconds</tt> secons for process to exit.
waitSecondsForProcess :: (MonadTest m, MonadIO m, HasCallStack) => Int -> ProcessHandle -> m (Either TimedOut ExitCode)

-- | Configuration for starting a new process. This is a subset of
--   <a>CreateProcess</a>.
data ExecConfig
ExecConfig :: Last [(String, String)] -> Last FilePath -> ExecConfig
[execConfigEnv] :: ExecConfig -> Last [(String, String)]
[execConfigCwd] :: ExecConfig -> Last FilePath
defaultExecConfig :: ExecConfig
instance GHC.Show.Show Hedgehog.Extras.Test.Process.ExecConfig
instance GHC.Generics.Generic Hedgehog.Extras.Test.Process.ExecConfig
instance GHC.Classes.Eq Hedgehog.Extras.Test.Process.ExecConfig


-- | This module provides a test watchdog - an utility monitoring test
--   cases and killing them if they don't finish in time. <a>Watchdog</a>
--   thread runs in the background, and after specified timeout, it throws
--   <a>WatchdogException</a> to the target thread. A user is able to
--   <a>kickWatchdog</a>, which delays the killing and
--   <a>poisonWatchdog</a> which stops the watchdog.
--   
--   To wrap a test case in a watchdog just use
--   
--   <pre>
--   runWithWatchdog watchdogConfig $ \watchdog -&gt; do
--     -- body of your test case
--   </pre>
module Hedgehog.Extras.Test.TestWatchdog

-- | Execute a test case with a watchdog.
runWithWatchdog_ :: HasCallStack => MonadBaseControl IO m => WatchdogConfig -> (HasCallStack => m a) -> m a

-- | Execute a test case with a watchdog.
runWithWatchdog :: HasCallStack => MonadBaseControl IO m => WatchdogConfig -> (HasCallStack => Watchdog -> m a) -> m a

-- | Execute a test case with watchdog with default config.
runWithDefaultWatchdog_ :: HasCallStack => MonadBaseControl IO m => (HasCallStack => m a) -> m a

-- | Execute a test case with watchdog with default config.
runWithDefaultWatchdog :: HasCallStack => MonadBaseControl IO m => (HasCallStack => Watchdog -> m a) -> m a

-- | Enqueue a kick for the watchdog. It will extend the timeout by another
--   one defined in the watchdog configuration.
kickWatchdog :: MonadIO m => Watchdog -> m ()

-- | Enqueue a poison pill for the watchdog. It will stop the watchdog
--   after all timeouts.
poisonWatchdog :: MonadIO m => Watchdog -> m ()

-- | A watchdog instance. See the module header for more detailed
--   description.
data Watchdog

-- | Configuration for the watchdog.
newtype WatchdogConfig
WatchdogConfig :: Int -> WatchdogConfig

-- | Timeout in seconds after which watchdog will kill the test case
[watchdogTimeout] :: WatchdogConfig -> Int

-- | An exception thrown to the test case thread.
newtype WatchdogException
WatchdogException :: NominalDiffTime -> WatchdogException
[timeElapsed] :: WatchdogException -> NominalDiffTime

-- | Create manually a new watchdog, providing the target thread ID. After
--   all watchdog timeouts expire, the target thread will get
--   <a>WatchdogException</a> thrown to it asynchronously (using
--   <a>throwTo</a>).
makeWatchdog :: MonadBase IO m => WatchdogConfig -> ThreadId -> m Watchdog

-- | Run watchdog in a loop in the current thread. Usually this function
--   should be used with <a>withAsync</a> to run it in the background.
runWatchdog :: MonadBase IO m => Watchdog -> m ()
instance GHC.Show.Show Hedgehog.Extras.Test.TestWatchdog.WatchdogException
instance GHC.Exception.Type.Exception Hedgehog.Extras.Test.TestWatchdog.WatchdogException
instance GHC.Show.Show Hedgehog.Extras.Test.TestWatchdog.Watchdog


-- | This modules provides a tripwire abstraction. You can use tripwire as
--   a detection mechanism if the code path was executed. Trip a tripwire
--   with <a>trip</a> in the place where you'd like to detect if it was
--   reached. The tripwire can then be checked in the other place in the
--   code using for example <a>isTripped</a> or <a>assertNotTripped</a>.
module Hedgehog.Extras.Test.Tripwire

-- | Represents a tripwire which can be tripped only once. It can be used
--   to detect if a particular code path was reached.
data Tripwire

-- | Creates a new tripwire
makeTripwire :: MonadIO m => m Tripwire

-- | Creates a new tripwire with a label, which is visible when
--   <a>show</a>ed: <tt>Tripwire mylabel</tt>
makeTripwireWithLabel :: MonadIO m => String -> m Tripwire

-- | Triggers the tripwire and registers the place of the first trigger.
--   Idempotent. Prints the information in the test log about tripping the
--   tripwire.
trip :: HasCallStack => MonadIO m => MonadTest m => Tripwire -> m ()

-- | Triggers the tripwire and registers the place of the first trigger.
--   Idempotent. A silent variant of <a>trip</a> which does not require
--   <a>MonadTest</a>, but also does not log the information about
--   tripping.
trip_ :: HasCallStack => MonadIO m => Tripwire -> m ()

-- | Check if the tripwire was tripped.
isTripped :: MonadIO m => Tripwire -> m Bool

-- | Return the call stack, where the tripwire was tripped - if it was
--   tripped.
getTripSite :: MonadIO m => Tripwire -> m (Maybe CallStack)

-- | Restore tripwire to initial non triggered state
resetTripwire :: MonadIO m => Tripwire -> m ()

-- | Fails the test if the tripwire was triggered. Prints the call stack
--   where the tripwire was triggered.
assertNotTripped :: HasCallStack => MonadTest m => MonadIO m => Tripwire -> m ()

-- | Fails the test if the tripwire was not triggered yet.
assertTripped :: HasCallStack => MonadTest m => MonadIO m => Tripwire -> m ()
instance GHC.Show.Show Hedgehog.Extras.Test.Tripwire.Tripwire

module Hedgehog.Extras.Test.Unit
newtype UnitIO a
UnitIO :: TestT (ResourceT IO) a -> UnitIO a
[runTestIO] :: UnitIO a -> TestT (ResourceT IO) a
testUnitIO :: TestName -> UnitIO () -> TestTree
instance Control.Monad.Catch.MonadThrow Hedgehog.Extras.Test.Unit.UnitIO
instance Hedgehog.Internal.Property.MonadTest Hedgehog.Extras.Test.Unit.UnitIO
instance Control.Monad.Trans.Resource.Internal.MonadResource Hedgehog.Extras.Test.Unit.UnitIO
instance Control.Monad.IO.Class.MonadIO Hedgehog.Extras.Test.Unit.UnitIO
instance Control.Monad.Fail.MonadFail Hedgehog.Extras.Test.Unit.UnitIO
instance Control.Monad.Catch.MonadCatch Hedgehog.Extras.Test.Unit.UnitIO
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Hedgehog.Extras.Test.Unit.UnitIO
instance Control.Monad.Base.MonadBase GHC.Types.IO Hedgehog.Extras.Test.Unit.UnitIO
instance Hedgehog.Extras.Test.MonadAssertion.MonadAssertion Hedgehog.Extras.Test.Unit.UnitIO
instance GHC.Base.Monad Hedgehog.Extras.Test.Unit.UnitIO
instance GHC.Base.Functor Hedgehog.Extras.Test.Unit.UnitIO
instance GHC.Base.Applicative Hedgehog.Extras.Test.Unit.UnitIO
instance Test.Tasty.Discover.Tasty (Hedgehog.Extras.Test.Unit.UnitIO ())

module Hedgehog.Extras.Test

module Hedgehog.Extras
