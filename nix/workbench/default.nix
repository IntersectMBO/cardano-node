# The workbench entrypoint,
{ pkgs, lib
  # This provided project attrset will be used all over the workbench instead
  # of the flake's `pkgs` or `cardanoNodePackages`. This allows to easily
  # parametrize the whole build at any point, be it only for the workbench in
  # "nix/pkgs.nix" or when entering a workbench shell in
  # "nix/workbench/shell.nix".
  # Also, by using a haskell.nix project instead of `cardanoNodePackages` or
  # `pkgs` to fetch it's project related dependencies we are sure they are not
  # tagged with the git commit because if we use the `set-git-rev` versions of
  # `cardano-node` and/or `tx-generator` then on every distinct commit ID all
  # the scripts generated by the workbench (start.sh files) will be re-generated
  # instead of obtained from the cache in the nix store.
, haskellProject
}:

with lib;

let

  # Workbench derivation to create derivations from `wb` commands.
  ##############################################################################

  # "Minimal" workbench, manually add the dependencies expected in $PATH.
  # Which tools to add differs if full workbench needed or `wb` commands subset.
  workbench =
    pkgs.stdenv.mkDerivation {
      pname = "workbench";

      version = "0.1";

      # Only what will be installed to avoid rebuilds on all workbench changes.
      src = lib.cleanSourceWith {
        src = ./.;
        filter = fullPath: type:
          let relativePath = lib.removePrefix "${toString ./.}/" fullPath;
              directories = {
                analyse  = [".sh" ".json"];
                backend  = [".sh"];
                ede      = [".ede"];
                evaluate = [".sh"];
                genesis  = [""]; # All. Key files, jq files, plutus scripts, etc
                profile  = [".sh" ".json"];
                topology = [".sh"];
              };
          in  lib.any id [
            # Include the "wb" file (has no ".sh", workbench's entrypoint).
            (relativePath == "wb")
            # Include all top level "*.sh" files.
            (
                (dirOf fullPath == toString ./.)
              &&
                (lib.hasSuffix ".sh" relativePath)
            )
            # Traverse the above specified directories.
            (   type == "directory"
              &&
                (lib.any
                  (p: lib.hasPrefix p relativePath)
                  (builtins.attrNames directories)
                )
            )
            # Include only the extensions defined above.
            (lib.any id
              (lib.attrValues (mapAttrs
                (dirName: suffixes:
                     (lib.hasPrefix (dirName + "/") relativePath)
                  &&
                     (lib.any
                        (s: lib.hasSuffix s relativePath)
                        suffixes
                     )
                )
                directories
              ))
            )
          ]
        ;
      };

      # Install everything "src" provided.
      installPhase = ''
        runHook preInstall
        mkdir -p     "$out"/bin
        cp    -a ./* "$out"/bin/
        runHook postInstall
      '';

      # Only the "wb" script gets patched.
      dontPatchShebangs = true;
      postFixup = ''
        patchShebangs "$out"/bin/wb
      '';
    }
  ;

  # Extras.
  ##############################################################################

  profile-names = __fromJSON (__readFile profile-names-json);

  profile-names-json = pkgs.runCommand "profile-names.json" {}
    ''
    ${haskellProject.exes.cardano-profile}/bin/cardano-profile "names" > $out
    ''
  ;

# Output
################################################################################

in pkgs.lib.fix (self: {

  inherit workbench;
  inherit haskellProject;
  inherit profile-names-json profile-names;

  # Return a profile attr with a `materialise-profile` function.
  # profileName -> profile
  profile = profileName:
    (import ./profile/profile.nix
      { inherit pkgs lib;
        workbenchNix = self;
        inherit profileName;
      }
    )
  ;

  # Return a backend attr with a `materialise-profile` function.
  # backendName -> stateDir -> basePort -> useCabalRun -> profiling -> backend
  backend =
    let backendRegistry = {
        nomadcloud      = params:
          import ./backend/nomad/cloud.nix  params;
        nomadexec       = params:
          import ./backend/nomad/exec.nix   params;
        supervisor      = params:
          import ./backend/supervisor.nix   params;
        };
  in { backendName
     , stateDir
     , basePort
     , useCabalRun
     , profiling
     }:
      (backendRegistry."${backendName}")
        { inherit pkgs lib;
          inherit haskellProject;
          inherit stateDir basePort;
          # The `useCabalRun` and `profiling` flags are set in the backend to
          # allow the backend to override its values. The runner must use the
          # value of these two flags from the backend to prevent having a runner
          # that uses a different value than the ones the backend supports.
          inherit useCabalRun profiling;
        }
  ;

  # A conveniently-parametrizable workbench preset.
  # See https://input-output-hk.github.io/haskell.nix/user-guide/development/
  # The general idea is:
  # 1. profileName -> profiling -> profile
  # 2. backendName -> stateDir -> basePort -> useCabalRun -> backend
  # 3. profile -> backend -> batchName -> runner
  runner =
    { profileName
    , backendName
    , stateDir
    , basePort
    , useCabalRun
    , profiling
    , batchName
    , workbenchStartArgs
    , cardano-node-rev
    }:
    let
        # Only a name needed to create a profile attrset.
        profile = self.profile profileName;
        backend = self.backend
                    { inherit backendName stateDir basePort;
                      # The `useCabalRun` and `profiling` flags final decisions
                      # belong to the backend. We allow the backend to override
                      # its values.
                      # The runner must use the values returned from the backend
                      # to prevent having a runner that uses a different value
                      # than the ones supported by the chosen backend.
                      inherit useCabalRun profiling;
                    }
        ;
    in import ./backend/runner.nix
      {
          inherit pkgs lib;
          inherit haskellProject;
          inherit workbench;
          inherit profile backend;
          inherit batchName workbenchStartArgs;
          inherit cardano-node-rev;
      }
  ;
})
