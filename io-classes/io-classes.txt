-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type classes for concurrency with STM, ST and timing
--   
--   IO Monad class hierarchy compatible with <a>io-sim</a>, <a>base</a>,
--   <a>async</a>, <a>stm</a>, <a>exceptions</a> &amp; <a>time</a>
--   packages.
@package io-classes
@version 1.5.0.0

module Control.Monad.Class.MonadEventlog
class Monad m => MonadEventlog m

-- | Emits a message to the eventlog, if eventlog profiling is available
--   and enabled at runtime.
traceEventIO :: MonadEventlog m => String -> m ()

-- | Emits a marker to the eventlog, if eventlog profiling is available and
--   enabled at runtime.
--   
--   The <a>String</a> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
traceMarkerIO :: MonadEventlog m => String -> m ()
instance Control.Monad.Class.MonadEventlog.MonadEventlog GHC.Types.IO
instance Control.Monad.Class.MonadEventlog.MonadEventlog m => Control.Monad.Class.MonadEventlog.MonadEventlog (Control.Monad.Trans.Reader.ReaderT r m)


-- | A generalisation of <a>Control.Concurrent</a> API to both <a>IO</a>
--   and <a>IOSim</a>.
module Control.Monad.Class.MonadFork
class (Monad m, Eq (ThreadId m), Ord (ThreadId m), Show (ThreadId m)) => MonadThread m where {
    type ThreadId m :: Type;
}
myThreadId :: MonadThread m => m (ThreadId m)
labelThread :: MonadThread m => ThreadId m -> String -> m ()

-- | Apply the label to the current thread
labelThisThread :: MonadThread m => String -> m ()
class MonadThread m => MonadFork m
forkIO :: MonadFork m => m () -> m (ThreadId m)
forkOn :: MonadFork m => Int -> m () -> m (ThreadId m)
forkIOWithUnmask :: MonadFork m => ((forall a. m a -> m a) -> m ()) -> m (ThreadId m)
forkFinally :: MonadFork m => m a -> (Either SomeException a -> m ()) -> m (ThreadId m)
throwTo :: (MonadFork m, Exception e) => ThreadId m -> e -> m ()
killThread :: MonadFork m => ThreadId m -> m ()
yield :: MonadFork m => m ()
instance Control.Monad.Class.MonadFork.MonadFork GHC.Types.IO
instance Control.Monad.Class.MonadFork.MonadFork m => Control.Monad.Class.MonadFork.MonadFork (Control.Monad.Trans.Reader.ReaderT e m)
instance Control.Monad.Class.MonadFork.MonadThread GHC.Types.IO
instance Control.Monad.Class.MonadFork.MonadThread m => Control.Monad.Class.MonadFork.MonadThread (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Monad.Class.MonadST

-- | This class is for abstracting over <a>stToIO</a> which allows running
--   <a>ST</a> actions in <a>IO</a>. In this case it is to allow running
--   <a>ST</a> actions within another monad <tt>m</tt>.
--   
--   The normal type of <a>stToIO</a> is:
--   
--   <pre>
--   stToIO :: ST RealWorld a -&gt; IO a
--   </pre>
--   
--   We have two approaches to abstracting over this, a new and an older
--   (deprecated) method. The new method borrows the <tt>primitive</tt>
--   package's <a>PrimMonad</a> and <a>PrimState</a> type family. This
--   gives us:
--   
--   <pre>
--   stToIO :: ST (PrimState m) a -&gt; m a
--   </pre>
--   
--   Which for <a>IO</a> is exactly the same as above. For <a>ST</a> it is
--   identity, while for <tt>IOSim</tt> it is
--   
--   <pre>
--   stToIO :: ST s a -&gt; IOSim s a
--   </pre>
--   
--   The older (deprecated) method is tricky because we need to not care
--   about both the <tt>IO</tt>, and also the <tt>RealWorld</tt>, and it
--   does so avoiding mentioning any <tt>s</tt> type (which is what the
--   <a>PrimState</a> type family gives access to). The solution is to
--   write an action that is given the <tt>liftST</tt> as an argument and
--   where that action itself is polymorphic in the <tt>s</tt> parameter.
--   This allows us to instantiate it with <tt>RealWorld</tt> in the
--   <tt>IO</tt> case, and the local <tt>s</tt> in a case where we are
--   embedding into another <tt>ST</tt> action.
class PrimMonad m => MonadST m

stToIO :: MonadST m => ST (PrimState m) a -> m a

-- | Deprecated. Use <a>stToIO</a> instead.

-- | <i>Deprecated: Use the simpler <a>stToIO</a> instead.</i>
withLiftST :: MonadST m => (forall s. (forall a. ST s a -> m a) -> b) -> b
instance Control.Monad.Class.MonadST.MonadST GHC.Types.IO
instance Control.Monad.Class.MonadST.MonadST (GHC.ST.ST s)
instance (Control.Monad.Class.MonadST.MonadST m, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Class.MonadST.MonadST (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Monad.Class.MonadSay
class Monad m => MonadSay m
say :: MonadSay m => String -> m ()
instance Control.Monad.Class.MonadSay.MonadSay GHC.Types.IO
instance Control.Monad.Class.MonadSay.MonadSay m => Control.Monad.Class.MonadSay.MonadSay (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Monad.Class.MonadTest

-- | A helper monad for <i>IOSimPOR</i>.
class Monad m => MonadTest m

-- | Mark a thread for schedule exploration. All threads that are forked by
--   it are also included in the exploration.
exploreRaces :: MonadTest m => m ()
instance Control.Monad.Class.MonadTest.MonadTest GHC.Types.IO
instance Control.Monad.Class.MonadTest.MonadTest m => Control.Monad.Class.MonadTest.MonadTest (Control.Monad.Trans.Reader.ReaderT e m)


-- | A generalisation of <a>Control.Exception</a> API to both <a>IO</a> and
--   <a>IOSim</a>.
module Control.Monad.Class.MonadThrow

-- | Throwing exceptions, and resource handling in the presence of
--   exceptions.
--   
--   Does not include the ability to respond to exceptions.
class Monad m => MonadThrow m
throwIO :: (MonadThrow m, Exception e) => e -> m a
bracket :: MonadThrow m => m a -> (a -> m b) -> (a -> m c) -> m c
bracket_ :: MonadThrow m => m a -> m b -> m c -> m c
finally :: MonadThrow m => m a -> m b -> m a
bracket :: (MonadThrow m, MonadCatch m) => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Catching exceptions.
--   
--   Covers standard utilities to respond to exceptions.
class MonadThrow m => MonadCatch m
catch :: (MonadCatch m, Exception e) => m a -> (e -> m a) -> m a
catchJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a
try :: (MonadCatch m, Exception e) => m a -> m (Either e a)
tryJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)
handle :: (MonadCatch m, Exception e) => (e -> m a) -> m a -> m a
handleJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a
onException :: MonadCatch m => m a -> m b -> m a
bracketOnError :: MonadCatch m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | General form of bracket
--   
--   See
--   <a>http://hackage.haskell.org/package/exceptions-0.10.0/docs/Control-Monad-Catch.html#v:generalBracket</a>
--   for discussion and motivation.
generalBracket :: MonadCatch m => m a -> (a -> ExitCase b -> m c) -> (a -> m b) -> m (b, c)

-- | General form of bracket
--   
--   See
--   <a>http://hackage.haskell.org/package/exceptions-0.10.0/docs/Control-Monad-Catch.html#v:generalBracket</a>
--   for discussion and motivation.
generalBracket :: (MonadCatch m, MonadMask m) => m a -> (a -> ExitCase b -> m c) -> (a -> m b) -> m (b, c)

-- | Support for safely working in the presence of asynchronous exceptions.
--   
--   This is typically not needed directly as the utilities in
--   <a>MonadThrow</a> and <a>MonadCatch</a> cover most use cases.
class MonadCatch m => MonadMask m
mask :: MonadMask m => ((forall a. m a -> m a) -> m b) -> m b
uninterruptibleMask :: MonadMask m => ((forall a. m a -> m a) -> m b) -> m b
mask_ :: MonadMask m => m a -> m a
uninterruptibleMask_ :: MonadMask m => m a -> m a
class MonadMask m => MonadMaskingState m
getMaskingState :: MonadMaskingState m => m MaskingState
interruptible :: MonadMaskingState m => m a -> m a
allowInterrupt :: MonadMaskingState m => m ()

-- | Monads which can <a>evaluate</a>.
class MonadThrow m => MonadEvaluate m
evaluate :: MonadEvaluate m => a -> m a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data () => MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data () => SomeException

-- | Used in <a>generalBracket</a>
--   
--   See <tt>exceptions</tt> package for discussion and motivation.
data ExitCase a
ExitCaseSuccess :: a -> ExitCase a
ExitCaseException :: SomeException -> ExitCase a
ExitCaseAbort :: ExitCase a

-- | The default handler type for <a>catches</a>, whcih is a generalisation
--   of <a>Handler</a>.
data Handler m a
Handler :: (e -> m a) -> Handler m a

-- | Like <a>catches</a> but for <a>MonadCatch</a> rather than only
--   <a>IO</a>.
catches :: forall m a. MonadCatch m => m a -> [Handler m a] -> m a
instance GHC.Base.Functor Control.Monad.Class.MonadThrow.ExitCase
instance GHC.Show.Show a => GHC.Show.Show (Control.Monad.Class.MonadThrow.ExitCase a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Class.MonadThrow.Handler m)
instance Control.Monad.Class.MonadThrow.MonadEvaluate GHC.Types.IO
instance Control.Monad.Class.MonadThrow.MonadEvaluate m => Control.Monad.Class.MonadThrow.MonadEvaluate (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadThrow.MonadMaskingState GHC.Types.IO
instance Control.Monad.Class.MonadThrow.MonadThrow GHC.Types.IO
instance Control.Monad.Class.MonadThrow.MonadCatch GHC.Types.IO
instance Control.Monad.Class.MonadThrow.MonadMask GHC.Types.IO
instance Control.Monad.Class.MonadThrow.MonadThrow GHC.Conc.Sync.STM
instance Control.Monad.Class.MonadThrow.MonadCatch GHC.Conc.Sync.STM
instance Control.Monad.Class.MonadThrow.MonadThrow m => Control.Monad.Class.MonadThrow.MonadThrow (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadThrow.MonadCatch m => Control.Monad.Class.MonadThrow.MonadCatch (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadThrow.MonadMask m => Control.Monad.Class.MonadThrow.MonadMask (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Monad.Class.MonadSTM.Internal

-- | The STM primitives parametrised by a monad <tt>m</tt>.
class (Monad m, Monad (STM m)) => MonadSTM m where {
    
    -- | The STM monad.
    type STM m = (stm :: Type -> Type) | stm -> m;
    
    -- | A type of a <a>TVar</a>.
    --   
    --   See <a>TVar</a>.
    type TVar m :: Type -> Type;
    type TMVar m :: Type -> Type;
    type TQueue m :: Type -> Type;
    type TBQueue m :: Type -> Type;
    type TArray m :: Type -> Type -> Type;
    type TSem m :: Type;
    type TChan m :: Type -> Type;
}

-- | Atomically run an STM computation.
--   
--   See <a>atomically</a>.
atomically :: (MonadSTM m, HasCallStack) => STM m a -> m a
newTVar :: MonadSTM m => a -> STM m (TVar m a)
readTVar :: MonadSTM m => TVar m a -> STM m a
writeTVar :: MonadSTM m => TVar m a -> a -> STM m ()

-- | See <a>retry</a>.
retry :: MonadSTM m => STM m a

-- | See <a>orElse</a>.
orElse :: MonadSTM m => STM m a -> STM m a -> STM m a
modifyTVar :: MonadSTM m => TVar m a -> (a -> a) -> STM m ()
modifyTVar' :: MonadSTM m => TVar m a -> (a -> a) -> STM m ()

-- | @since io-classes-0.2.0.0
stateTVar :: MonadSTM m => TVar m s -> (s -> (a, s)) -> STM m a
swapTVar :: MonadSTM m => TVar m a -> a -> STM m a

-- | See <a>check</a>.
check :: MonadSTM m => Bool -> STM m ()
newTMVar :: MonadSTM m => a -> STM m (TMVar m a)
newEmptyTMVar :: MonadSTM m => STM m (TMVar m a)
takeTMVar :: MonadSTM m => TMVar m a -> STM m a
tryTakeTMVar :: MonadSTM m => TMVar m a -> STM m (Maybe a)
putTMVar :: MonadSTM m => TMVar m a -> a -> STM m ()
tryPutTMVar :: MonadSTM m => TMVar m a -> a -> STM m Bool
readTMVar :: MonadSTM m => TMVar m a -> STM m a
tryReadTMVar :: MonadSTM m => TMVar m a -> STM m (Maybe a)
swapTMVar :: MonadSTM m => TMVar m a -> a -> STM m a
writeTMVar :: MonadSTM m => TMVar m a -> a -> STM m ()
isEmptyTMVar :: MonadSTM m => TMVar m a -> STM m Bool
newTQueue :: MonadSTM m => STM m (TQueue m a)
readTQueue :: MonadSTM m => TQueue m a -> STM m a
tryReadTQueue :: MonadSTM m => TQueue m a -> STM m (Maybe a)
peekTQueue :: MonadSTM m => TQueue m a -> STM m a
tryPeekTQueue :: MonadSTM m => TQueue m a -> STM m (Maybe a)
flushTQueue :: MonadSTM m => TQueue m a -> STM m [a]
writeTQueue :: MonadSTM m => TQueue m a -> a -> STM m ()
isEmptyTQueue :: MonadSTM m => TQueue m a -> STM m Bool
unGetTQueue :: MonadSTM m => TQueue m a -> a -> STM m ()
newTBQueue :: MonadSTM m => Natural -> STM m (TBQueue m a)
readTBQueue :: MonadSTM m => TBQueue m a -> STM m a
tryReadTBQueue :: MonadSTM m => TBQueue m a -> STM m (Maybe a)
peekTBQueue :: MonadSTM m => TBQueue m a -> STM m a
tryPeekTBQueue :: MonadSTM m => TBQueue m a -> STM m (Maybe a)
flushTBQueue :: MonadSTM m => TBQueue m a -> STM m [a]
writeTBQueue :: MonadSTM m => TBQueue m a -> a -> STM m ()

lengthTBQueue :: MonadSTM m => TBQueue m a -> STM m Natural
isEmptyTBQueue :: MonadSTM m => TBQueue m a -> STM m Bool
isFullTBQueue :: MonadSTM m => TBQueue m a -> STM m Bool
unGetTBQueue :: MonadSTM m => TBQueue m a -> a -> STM m ()
newTSem :: MonadSTM m => Integer -> STM m (TSem m)
waitTSem :: MonadSTM m => TSem m -> STM m ()
signalTSem :: MonadSTM m => TSem m -> STM m ()
signalTSemN :: MonadSTM m => Natural -> TSem m -> STM m ()
newTChan :: MonadSTM m => STM m (TChan m a)
newBroadcastTChan :: MonadSTM m => STM m (TChan m a)
dupTChan :: MonadSTM m => TChan m a -> STM m (TChan m a)
cloneTChan :: MonadSTM m => TChan m a -> STM m (TChan m a)
readTChan :: MonadSTM m => TChan m a -> STM m a
tryReadTChan :: MonadSTM m => TChan m a -> STM m (Maybe a)
peekTChan :: MonadSTM m => TChan m a -> STM m a
tryPeekTChan :: MonadSTM m => TChan m a -> STM m (Maybe a)
writeTChan :: MonadSTM m => TChan m a -> a -> STM m ()
unGetTChan :: MonadSTM m => TChan m a -> a -> STM m ()
isEmptyTChan :: MonadSTM m => TChan m a -> STM m Bool
newTVarIO :: MonadSTM m => a -> m (TVar m a)
readTVarIO :: MonadSTM m => TVar m a -> m a
newTMVarIO :: MonadSTM m => a -> m (TMVar m a)
newEmptyTMVarIO :: MonadSTM m => m (TMVar m a)
newTQueueIO :: MonadSTM m => m (TQueue m a)
newTBQueueIO :: MonadSTM m => Natural -> m (TBQueue m a)
newTChanIO :: MonadSTM m => m (TChan m a)
newBroadcastTChanIO :: MonadSTM m => m (TChan m a)

-- | Labelled <a>TVar</a>s &amp; friends.
--   
--   The <a>IO</a> instances is no-op, the <tt>IOSim</tt> instance enhances
--   simulation trace. This is very useful when analysing low lever
--   concurrency issues (e.g. deadlocks, livelocks etc).
class MonadSTM m => MonadLabelledSTM m

-- | Name a <a>TVar</a>.
labelTVar :: MonadLabelledSTM m => TVar m a -> String -> STM m ()
labelTMVar :: MonadLabelledSTM m => TMVar m a -> String -> STM m ()
labelTQueue :: MonadLabelledSTM m => TQueue m a -> String -> STM m ()
labelTBQueue :: MonadLabelledSTM m => TBQueue m a -> String -> STM m ()
labelTArray :: (MonadLabelledSTM m, Ix i, Show i) => TArray m i e -> String -> STM m ()
labelTSem :: MonadLabelledSTM m => TSem m -> String -> STM m ()
labelTChan :: MonadLabelledSTM m => TChan m a -> String -> STM m ()
labelTVarIO :: MonadLabelledSTM m => TVar m a -> String -> m ()
labelTMVarIO :: MonadLabelledSTM m => TMVar m a -> String -> m ()
labelTQueueIO :: MonadLabelledSTM m => TQueue m a -> String -> m ()
labelTBQueueIO :: MonadLabelledSTM m => TBQueue m a -> String -> m ()
labelTArrayIO :: (MonadLabelledSTM m, Ix i, Show i) => TArray m i e -> String -> m ()
labelTSemIO :: MonadLabelledSTM m => TSem m -> String -> m ()
labelTChanIO :: MonadLabelledSTM m => TChan m a -> String -> m ()
labelTMVar :: (MonadLabelledSTM m, TMVar m ~ TMVarDefault m) => TMVar m a -> String -> STM m ()
labelTQueue :: (MonadLabelledSTM m, TQueue m ~ TQueueDefault m) => TQueue m a -> String -> STM m ()
labelTBQueue :: (MonadLabelledSTM m, TBQueue m ~ TBQueueDefault m) => TBQueue m a -> String -> STM m ()
labelTSem :: (MonadLabelledSTM m, TSem m ~ TSemDefault m) => TSem m -> String -> STM m ()
labelTChan :: (MonadLabelledSTM m, TChan m ~ TChanDefault m) => TChan m a -> String -> STM m ()
labelTArray :: (MonadLabelledSTM m, TArray m ~ TArrayDefault m, Ix i, Show i) => TArray m i e -> String -> STM m ()
labelTVarIO :: MonadLabelledSTM m => TVar m a -> String -> m ()
labelTMVarIO :: MonadLabelledSTM m => TMVar m a -> String -> m ()
labelTQueueIO :: MonadLabelledSTM m => TQueue m a -> String -> m ()
labelTBQueueIO :: MonadLabelledSTM m => TBQueue m a -> String -> m ()
labelTArrayIO :: (MonadLabelledSTM m, Ix i, Show i) => TArray m i e -> String -> m ()
labelTSemIO :: MonadLabelledSTM m => TSem m -> String -> m ()
labelTChanIO :: MonadLabelledSTM m => TChan m a -> String -> m ()

-- | This type class is indented for <a>'io-sim'</a>, where one might want
--   to access a <a>TVar</a> in the underlying <tt>ST</tt> monad.
class (MonadSTM m, Monad (InspectMonad m)) => MonadInspectSTM m where {
    type InspectMonad m :: Type -> Type;
}

-- | Return the value of a <a>TVar</a> as an <a>InspectMonad</a>
--   computation.
--   
--   <a>inspectTVar</a> is useful if the value of a <a>TVar</a> observed by
--   <a>traceTVar</a> contains other <a>TVar</a>s.
inspectTVar :: MonadInspectSTM m => proxy m -> TVar m a -> InspectMonad m a

-- | Return the value of a <a>MonadSTM</a> as an <a>InspectMonad</a>
--   computation.
inspectTMVar :: MonadInspectSTM m => proxy m -> TMVar m a -> InspectMonad m (Maybe a)

-- | A GADT which instructs how to trace the value. The <a>traceDynamic</a>
--   will use dynamic tracing, e.g. "Control.Monad.IOSim.traceM"; while
--   <a>traceString</a> will be traced with <tt>EventSay</tt>. The
--   <tt>IOSim</tt>s dynamic tracing allows to recover the value from the
--   simulation trace (see "Control.Monad.IOSim.selectTraceEventsDynamic").
data TraceValue
[TraceValue] :: forall tr. Typeable tr => Maybe tr -> Maybe String -> TraceValue

-- | Use only a dynamic tracer.
pattern TraceDynamic :: () => forall tr. Typeable tr => tr -> TraceValue

-- | Use only string tracing.
pattern TraceString :: String -> TraceValue

-- | Do not trace the value.
pattern DontTrace :: TraceValue

-- | <a>MonadTraceSTM</a> allows to trace values of stm variables when stm
--   transaction is committed. This allows to verify invariants when a
--   variable is committed.
class MonadInspectSTM m => MonadTraceSTM m

-- | Construct a trace output out of previous &amp; new value of a
--   <a>TVar</a>. The callback is called whenever an stm transaction which
--   modifies the <a>TVar</a> is committed.
--   
--   This is supported by <tt>IOSim</tt> (and <tt>IOSimPOR</tt>); <a>IO</a>
--   has a trivial instance.
--   
--   The simplest example is:
--   
--   <pre>
--   traceTVar (Proxy @m) tvar (\_ -&gt; TraceString . show)
--   </pre>
--   
--   Note that the interpretation of <a>TraceValue</a> depends on the monad
--   <tt>m</tt> itself (see <a>TraceValue</a>).
traceTVar :: MonadTraceSTM m => proxy m -> TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> STM m ()
traceTMVar :: MonadTraceSTM m => proxy m -> TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
traceTQueue :: MonadTraceSTM m => proxy m -> TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTBQueue :: MonadTraceSTM m => proxy m -> TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTSem :: MonadTraceSTM m => proxy m -> TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> STM m ()
traceTMVar :: (MonadTraceSTM m, TMVar m a ~ TMVarDefault m a) => proxy m -> TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
traceTSem :: (MonadTraceSTM m, TSem m ~ TSemDefault m) => proxy m -> TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> STM m ()
traceTVarIO :: MonadTraceSTM m => TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> m ()
traceTMVarIO :: MonadTraceSTM m => TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> m ()
traceTQueueIO :: MonadTraceSTM m => TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTBQueueIO :: MonadTraceSTM m => TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTSemIO :: MonadTraceSTM m => TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> m ()
traceTVarIO :: MonadTraceSTM m => TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> m ()
traceTMVarIO :: MonadTraceSTM m => TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> m ()
traceTQueueIO :: MonadTraceSTM m => TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTBQueueIO :: MonadTraceSTM m => TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTSemIO :: MonadTraceSTM m => TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> m ()

-- | <a>throwIO</a> specialised to <tt>stm</tt> monad.
throwSTM :: (MonadSTM m, MonadThrow (STM m), Exception e) => e -> STM m a

-- | <a>catch</a> specialized for an <tt>stm</tt> monad.
catchSTM :: (MonadSTM m, MonadCatch (STM m), Exception e) => STM m a -> (e -> STM m a) -> STM m a
newtype TMVarDefault m a
TMVar :: TVar m (Maybe a) -> TMVarDefault m a
newTMVarDefault :: MonadSTM m => a -> STM m (TMVarDefault m a)
newEmptyTMVarDefault :: MonadSTM m => STM m (TMVarDefault m a)
takeTMVarDefault :: MonadSTM m => TMVarDefault m a -> STM m a
tryTakeTMVarDefault :: MonadSTM m => TMVarDefault m a -> STM m (Maybe a)
putTMVarDefault :: MonadSTM m => TMVarDefault m a -> a -> STM m ()
tryPutTMVarDefault :: MonadSTM m => TMVarDefault m a -> a -> STM m Bool
readTMVarDefault :: MonadSTM m => TMVarDefault m a -> STM m a
tryReadTMVarDefault :: MonadSTM m => TMVarDefault m a -> STM m (Maybe a)
swapTMVarDefault :: MonadSTM m => TMVarDefault m a -> a -> STM m a
writeTMVarDefault :: MonadSTM m => TMVarDefault m a -> a -> STM m ()
isEmptyTMVarDefault :: MonadSTM m => TMVarDefault m a -> STM m Bool
labelTMVarDefault :: MonadLabelledSTM m => TMVarDefault m a -> String -> STM m ()
traceTMVarDefault :: MonadTraceSTM m => proxy m -> TMVarDefault m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
data TQueueDefault m a
TQueue :: !TVar m [a] -> !TVar m [a] -> TQueueDefault m a
newTQueueDefault :: MonadSTM m => STM m (TQueueDefault m a)
writeTQueueDefault :: MonadSTM m => TQueueDefault m a -> a -> STM m ()
readTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m a
tryReadTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m (Maybe a)
isEmptyTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m Bool
peekTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m a
tryPeekTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m (Maybe a)
flushTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m [a]
unGetTQueueDefault :: MonadSTM m => TQueueDefault m a -> a -> STM m ()
labelTQueueDefault :: MonadLabelledSTM m => TQueueDefault m a -> String -> STM m ()
data TBQueueDefault m a
TBQueue :: !TVar m Natural -> !TVar m [a] -> !TVar m Natural -> !TVar m [a] -> !Natural -> TBQueueDefault m a
newTBQueueDefault :: MonadSTM m => Natural -> STM m (TBQueueDefault m a)
writeTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> a -> STM m ()
readTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m a
tryReadTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m (Maybe a)
peekTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m a
tryPeekTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m (Maybe a)
isEmptyTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m Bool
isFullTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m Bool
lengthTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m Natural
flushTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m [a]
unGetTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> a -> STM m ()
labelTBQueueDefault :: MonadLabelledSTM m => TBQueueDefault m a -> String -> STM m ()

-- | Default implementation of <a>MonadSTM</a>.
data TArrayDefault m i e
TArray :: Array i (TVar m e) -> TArrayDefault m i e
newtype TSemDefault m
TSem :: TVar m Integer -> TSemDefault m
newTSemDefault :: MonadSTM m => Integer -> STM m (TSemDefault m)
waitTSemDefault :: MonadSTM m => TSemDefault m -> STM m ()
signalTSemDefault :: MonadSTM m => TSemDefault m -> STM m ()
signalTSemNDefault :: MonadSTM m => Natural -> TSemDefault m -> STM m ()
labelTSemDefault :: MonadLabelledSTM m => TSemDefault m -> String -> STM m ()
data TChanDefault m a
TChan :: TVar m (TVarList m a) -> TVar m (TVarList m a) -> TChanDefault m a
newTChanDefault :: MonadSTM m => STM m (TChanDefault m a)
newBroadcastTChanDefault :: MonadSTM m => STM m (TChanDefault m a)
writeTChanDefault :: MonadSTM m => TChanDefault m a -> a -> STM m ()
readTChanDefault :: MonadSTM m => TChanDefault m a -> STM m a
tryReadTChanDefault :: MonadSTM m => TChanDefault m a -> STM m (Maybe a)
peekTChanDefault :: MonadSTM m => TChanDefault m a -> STM m a
tryPeekTChanDefault :: MonadSTM m => TChanDefault m a -> STM m (Maybe a)
dupTChanDefault :: MonadSTM m => TChanDefault m a -> STM m (TChanDefault m a)
unGetTChanDefault :: MonadSTM m => TChanDefault m a -> a -> STM m ()
isEmptyTChanDefault :: MonadSTM m => TChanDefault m a -> STM m Bool
cloneTChanDefault :: MonadSTM m => TChanDefault m a -> STM m (TChanDefault m a)
labelTChanDefault :: MonadLabelledSTM m => TChanDefault m a -> String -> STM m ()
instance GHC.Show.Show Control.Monad.Class.MonadSTM.Internal.BlockedIndefinitely
instance (GHC.Classes.Eq (Control.Monad.Class.MonadSTM.Internal.TVar m e), GHC.Ix.Ix i) => GHC.Classes.Eq (Control.Monad.Class.MonadSTM.Internal.TArrayDefault m i e)
instance Control.Monad.Class.MonadSTM.Internal.MonadLabelledSTM GHC.Types.IO
instance Control.Monad.Class.MonadSTM.Internal.MonadTraceSTM GHC.Types.IO
instance (GHC.Base.Monad stm, Control.Monad.Class.MonadSTM.Internal.MonadSTM m, stm GHC.Types.~ Control.Monad.Class.MonadSTM.Internal.STM m) => Data.Array.Base.MArray (Control.Monad.Class.MonadSTM.Internal.TArrayDefault m) e stm
instance GHC.Exception.Type.Exception Control.Monad.Class.MonadSTM.Internal.BlockedIndefinitely
instance Control.Monad.Class.MonadSTM.Internal.MonadInspectSTM GHC.Types.IO
instance Control.Monad.Class.MonadSTM.Internal.MonadSTM GHC.Types.IO
instance Control.Monad.Class.MonadSTM.Internal.MonadSTM m => Control.Monad.Class.MonadSTM.Internal.MonadSTM (Control.Monad.Trans.Reader.ReaderT r m)


-- | This module corresponds to <a>Control.Monad.STM</a> in "stm" package
module Control.Monad.Class.MonadSTM

-- | The STM primitives parametrised by a monad <tt>m</tt>.
class (Monad m, Monad (STM m)) => MonadSTM m where {
    
    -- | The STM monad.
    type STM m = (stm :: Type -> Type) | stm -> m;
}

-- | Atomically run an STM computation.
--   
--   See <a>atomically</a>.
atomically :: (MonadSTM m, HasCallStack) => STM m a -> m a

-- | See <a>retry</a>.
retry :: MonadSTM m => STM m a

-- | See <a>orElse</a>.
orElse :: MonadSTM m => STM m a -> STM m a -> STM m a

-- | See <a>check</a>.
check :: MonadSTM m => Bool -> STM m ()

-- | <a>throwIO</a> specialised to <tt>stm</tt> monad.
throwSTM :: (MonadSTM m, MonadThrow (STM m), Exception e) => e -> STM m a

-- | Labelled <a>TVar</a>s &amp; friends.
--   
--   The <a>IO</a> instances is no-op, the <tt>IOSim</tt> instance enhances
--   simulation trace. This is very useful when analysing low lever
--   concurrency issues (e.g. deadlocks, livelocks etc).
class MonadSTM m => MonadLabelledSTM m

-- | <a>MonadTraceSTM</a> allows to trace values of stm variables when stm
--   transaction is committed. This allows to verify invariants when a
--   variable is committed.
class MonadInspectSTM m => MonadTraceSTM m

-- | Construct a trace output out of previous &amp; new value of a
--   <a>TVar</a>. The callback is called whenever an stm transaction which
--   modifies the <a>TVar</a> is committed.
--   
--   This is supported by <tt>IOSim</tt> (and <tt>IOSimPOR</tt>); <a>IO</a>
--   has a trivial instance.
--   
--   The simplest example is:
--   
--   <pre>
--   traceTVar (Proxy @m) tvar (\_ -&gt; TraceString . show)
--   </pre>
--   
--   Note that the interpretation of <a>TraceValue</a> depends on the monad
--   <tt>m</tt> itself (see <a>TraceValue</a>).
traceTVar :: MonadTraceSTM m => proxy m -> TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> STM m ()
traceTMVar :: MonadTraceSTM m => proxy m -> TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
traceTQueue :: MonadTraceSTM m => proxy m -> TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTBQueue :: MonadTraceSTM m => proxy m -> TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTSem :: MonadTraceSTM m => proxy m -> TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> STM m ()
traceTMVar :: (MonadTraceSTM m, TMVar m a ~ TMVarDefault m a) => proxy m -> TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
traceTSem :: (MonadTraceSTM m, TSem m ~ TSemDefault m) => proxy m -> TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> STM m ()
traceTVarIO :: MonadTraceSTM m => TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> m ()
traceTMVarIO :: MonadTraceSTM m => TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> m ()
traceTQueueIO :: MonadTraceSTM m => TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTBQueueIO :: MonadTraceSTM m => TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTSemIO :: MonadTraceSTM m => TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> m ()
traceTVarIO :: MonadTraceSTM m => TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> m ()
traceTMVarIO :: MonadTraceSTM m => TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> m ()
traceTQueueIO :: MonadTraceSTM m => TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTBQueueIO :: MonadTraceSTM m => TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTSemIO :: MonadTraceSTM m => TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> m ()

-- | A GADT which instructs how to trace the value. The <a>traceDynamic</a>
--   will use dynamic tracing, e.g. "Control.Monad.IOSim.traceM"; while
--   <a>traceString</a> will be traced with <tt>EventSay</tt>. The
--   <tt>IOSim</tt>s dynamic tracing allows to recover the value from the
--   simulation trace (see "Control.Monad.IOSim.selectTraceEventsDynamic").
data TraceValue
[TraceValue] :: forall tr. Typeable tr => Maybe tr -> Maybe String -> TraceValue

-- | Use only a dynamic tracer.
pattern TraceDynamic :: () => forall tr. Typeable tr => tr -> TraceValue

-- | Use only string tracing.
pattern TraceString :: String -> TraceValue

-- | Do not trace the value.
pattern DontTrace :: TraceValue

-- | This type class is indented for <a>'io-sim'</a>, where one might want
--   to access a <a>TVar</a> in the underlying <tt>ST</tt> monad.
class (MonadSTM m, Monad (InspectMonad m)) => MonadInspectSTM m where {
    type InspectMonad m :: Type -> Type;
}

-- | Return the value of a <a>TVar</a> as an <a>InspectMonad</a>
--   computation.
--   
--   <a>inspectTVar</a> is useful if the value of a <a>TVar</a> observed by
--   <a>traceTVar</a> contains other <a>TVar</a>s.
inspectTVar :: MonadInspectSTM m => proxy m -> TVar m a -> InspectMonad m a

-- | Return the value of a <a>MonadSTM</a> as an <a>InspectMonad</a>
--   computation.
inspectTMVar :: MonadInspectSTM m => proxy m -> TMVar m a -> InspectMonad m (Maybe a)


-- | This module corresponds to <a>TVar</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.TVar

-- | A type of a <a>TVar</a>.
--   
--   See <a>TVar</a>.
type TVar m :: Type -> Type
newTVar :: MonadSTM m => a -> STM m (TVar m a)
newTVarIO :: MonadSTM m => a -> m (TVar m a)
readTVar :: MonadSTM m => TVar m a -> STM m a
readTVarIO :: MonadSTM m => TVar m a -> m a
writeTVar :: MonadSTM m => TVar m a -> a -> STM m ()
modifyTVar :: MonadSTM m => TVar m a -> (a -> a) -> STM m ()
modifyTVar' :: MonadSTM m => TVar m a -> (a -> a) -> STM m ()

-- | @since io-classes-0.2.0.0
stateTVar :: MonadSTM m => TVar m s -> (s -> (a, s)) -> STM m a
swapTVar :: MonadSTM m => TVar m a -> a -> STM m a

-- | See <a>check</a>.
check :: MonadSTM m => Bool -> STM m ()

-- | Name a <a>TVar</a>.
labelTVar :: MonadLabelledSTM m => TVar m a -> String -> STM m ()
labelTVarIO :: MonadLabelledSTM m => TVar m a -> String -> m ()

-- | Construct a trace output out of previous &amp; new value of a
--   <a>TVar</a>. The callback is called whenever an stm transaction which
--   modifies the <a>TVar</a> is committed.
--   
--   This is supported by <tt>IOSim</tt> (and <tt>IOSimPOR</tt>); <a>IO</a>
--   has a trivial instance.
--   
--   The simplest example is:
--   
--   <pre>
--   traceTVar (Proxy @m) tvar (\_ -&gt; TraceString . show)
--   </pre>
--   
--   Note that the interpretation of <a>TraceValue</a> depends on the monad
--   <tt>m</tt> itself (see <a>TraceValue</a>).
traceTVar :: MonadTraceSTM m => proxy m -> TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> STM m ()
traceTVarIO :: MonadTraceSTM m => TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> m ()


-- | This module corresponds to <a>TSem</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.TSem
type TSem m :: Type
newTSem :: MonadSTM m => Integer -> STM m (TSem m)
waitTSem :: MonadSTM m => TSem m -> STM m ()
signalTSem :: MonadSTM m => TSem m -> STM m ()
signalTSemN :: MonadSTM m => Natural -> TSem m -> STM m ()
labelTSem :: MonadLabelledSTM m => TSem m -> String -> STM m ()
labelTSemIO :: MonadLabelledSTM m => TSem m -> String -> m ()
traceTSem :: MonadTraceSTM m => proxy m -> TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> STM m ()
traceTSemIO :: MonadTraceSTM m => TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> m ()


-- | This module corresponds to <a>TQueue</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.TQueue
type TQueue m :: Type -> Type
newTQueue :: MonadSTM m => STM m (TQueue m a)
newTQueueIO :: MonadSTM m => m (TQueue m a)
readTQueue :: MonadSTM m => TQueue m a -> STM m a
tryReadTQueue :: MonadSTM m => TQueue m a -> STM m (Maybe a)
peekTQueue :: MonadSTM m => TQueue m a -> STM m a
tryPeekTQueue :: MonadSTM m => TQueue m a -> STM m (Maybe a)
flushTQueue :: MonadSTM m => TQueue m a -> STM m [a]
writeTQueue :: MonadSTM m => TQueue m a -> a -> STM m ()
unGetTQueue :: MonadSTM m => TQueue m a -> a -> STM m ()
isEmptyTQueue :: MonadSTM m => TQueue m a -> STM m Bool
labelTQueue :: MonadLabelledSTM m => TQueue m a -> String -> STM m ()
labelTQueueIO :: MonadLabelledSTM m => TQueue m a -> String -> m ()
traceTQueue :: MonadTraceSTM m => proxy m -> TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTQueueIO :: MonadTraceSTM m => TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()


-- | This module corresponds to <a>TMVar</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.TMVar
type TMVar m :: Type -> Type
newTMVar :: MonadSTM m => a -> STM m (TMVar m a)
newEmptyTMVar :: MonadSTM m => STM m (TMVar m a)
newTMVarIO :: MonadSTM m => a -> m (TMVar m a)
newEmptyTMVarIO :: MonadSTM m => m (TMVar m a)
takeTMVar :: MonadSTM m => TMVar m a -> STM m a
tryTakeTMVar :: MonadSTM m => TMVar m a -> STM m (Maybe a)
putTMVar :: MonadSTM m => TMVar m a -> a -> STM m ()
tryPutTMVar :: MonadSTM m => TMVar m a -> a -> STM m Bool
readTMVar :: MonadSTM m => TMVar m a -> STM m a
tryReadTMVar :: MonadSTM m => TMVar m a -> STM m (Maybe a)
swapTMVar :: MonadSTM m => TMVar m a -> a -> STM m a
writeTMVar :: MonadSTM m => TMVar m a -> a -> STM m ()
isEmptyTMVar :: MonadSTM m => TMVar m a -> STM m Bool
labelTMVar :: MonadLabelledSTM m => TMVar m a -> String -> STM m ()
labelTMVarIO :: MonadLabelledSTM m => TMVar m a -> String -> m ()
traceTMVar :: MonadTraceSTM m => proxy m -> TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
traceTMVarIO :: MonadTraceSTM m => TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> m ()


-- | This module corresponds to <a>TChan</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.TChan
type TChan m :: Type -> Type
newTChan :: MonadSTM m => STM m (TChan m a)
newBroadcastTChan :: MonadSTM m => STM m (TChan m a)
newTChanIO :: MonadSTM m => m (TChan m a)
newBroadcastTChanIO :: MonadSTM m => m (TChan m a)
dupTChan :: MonadSTM m => TChan m a -> STM m (TChan m a)
cloneTChan :: MonadSTM m => TChan m a -> STM m (TChan m a)
readTChan :: MonadSTM m => TChan m a -> STM m a
tryReadTChan :: MonadSTM m => TChan m a -> STM m (Maybe a)
peekTChan :: MonadSTM m => TChan m a -> STM m a
tryPeekTChan :: MonadSTM m => TChan m a -> STM m (Maybe a)
writeTChan :: MonadSTM m => TChan m a -> a -> STM m ()
unGetTChan :: MonadSTM m => TChan m a -> a -> STM m ()
isEmptyTChan :: MonadSTM m => TChan m a -> STM m Bool


-- | This module corresponds to <a>TVar</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.TBQueue
type TBQueue m :: Type -> Type
newTBQueue :: MonadSTM m => Natural -> STM m (TBQueue m a)
newTBQueueIO :: MonadSTM m => Natural -> m (TBQueue m a)
readTBQueue :: MonadSTM m => TBQueue m a -> STM m a
tryReadTBQueue :: MonadSTM m => TBQueue m a -> STM m (Maybe a)
peekTBQueue :: MonadSTM m => TBQueue m a -> STM m a
tryPeekTBQueue :: MonadSTM m => TBQueue m a -> STM m (Maybe a)
flushTBQueue :: MonadSTM m => TBQueue m a -> STM m [a]
writeTBQueue :: MonadSTM m => TBQueue m a -> a -> STM m ()

lengthTBQueue :: MonadSTM m => TBQueue m a -> STM m Natural
isEmptyTBQueue :: MonadSTM m => TBQueue m a -> STM m Bool
isFullTBQueue :: MonadSTM m => TBQueue m a -> STM m Bool
unGetTBQueue :: MonadSTM m => TBQueue m a -> a -> STM m ()
labelTBQueue :: MonadLabelledSTM m => TBQueue m a -> String -> STM m ()
labelTBQueueIO :: MonadLabelledSTM m => TBQueue m a -> String -> m ()
traceTBQueue :: MonadTraceSTM m => proxy m -> TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTBQueueIO :: MonadTraceSTM m => TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()


-- | This module corresponds to <a>TArray</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.TArray
type TArray m :: Type -> Type -> Type


-- | This module corresponds to <a>Control.Concurrent.STM</a> in "stm"
--   package
module Control.Concurrent.Class.MonadSTM

module Control.Concurrent.Class.MonadMVar
class Monad m => MonadMVar m where {
    type MVar m :: Type -> Type;
}

-- | See <a>newEmptyMVar</a>.
newEmptyMVar :: MonadMVar m => m (MVar m a)

-- | See <a>takeMVar</a>.
takeMVar :: MonadMVar m => MVar m a -> m a

-- | See <a>putMVar</a>.
putMVar :: MonadMVar m => MVar m a -> a -> m ()

-- | See <a>tryTakeMVar</a>.
tryTakeMVar :: MonadMVar m => MVar m a -> m (Maybe a)

-- | See <a>tryPutMVar</a>.
tryPutMVar :: MonadMVar m => MVar m a -> a -> m Bool

-- | See <a>isEmptyMVar</a>.
isEmptyMVar :: MonadMVar m => MVar m a -> m Bool

-- | See <a>newMVar</a>.
newMVar :: MonadMVar m => a -> m (MVar m a)

-- | See <a>readMVar</a>.
readMVar :: MonadMVar m => MVar m a -> m a

-- | See <a>tryReadMVar</a>.
tryReadMVar :: MonadMVar m => MVar m a -> m (Maybe a)

-- | See <a>swapMVar</a>.
swapMVar :: MonadMVar m => MVar m a -> a -> m a

-- | See <a>withMVar</a>.
withMVar :: MonadMVar m => MVar m a -> (a -> m b) -> m b

-- | See <a>withMVarMasked</a>.
withMVarMasked :: MonadMVar m => MVar m a -> (a -> m b) -> m b

-- | See <a>modifyMVar_</a>.
modifyMVar_ :: MonadMVar m => MVar m a -> (a -> m a) -> m ()

-- | See <a>modifyMVar</a>.
modifyMVar :: MonadMVar m => MVar m a -> (a -> m (a, b)) -> m b

-- | See <a>modifyMVarMasked_</a>.
modifyMVarMasked_ :: MonadMVar m => MVar m a -> (a -> m a) -> m ()

-- | See <a>modifyMVarMasked</a>.
modifyMVarMasked :: MonadMVar m => MVar m a -> (a -> m (a, b)) -> m b

-- | See <a>newMVar</a>.
newMVar :: MonadMVar m => a -> m (MVar m a)

-- | See <a>swapMVar</a>.
swapMVar :: (MonadMVar m, MonadMask m) => MVar m a -> a -> m a

-- | See <a>withMVar</a>.
withMVar :: (MonadMVar m, MonadMask m) => MVar m a -> (a -> m b) -> m b

-- | See <a>withMVarMasked</a>.
withMVarMasked :: (MonadMVar m, MonadMask m) => MVar m a -> (a -> m b) -> m b

-- | See <a>modifyMVar_</a>.
modifyMVar_ :: (MonadMVar m, MonadMask m) => MVar m a -> (a -> m a) -> m ()

-- | See <a>modifyMVar</a>.
modifyMVar :: (MonadMVar m, MonadMask m, MonadEvaluate m) => MVar m a -> (a -> m (a, b)) -> m b

-- | See <a>modifyMVarMasked_</a>.
modifyMVarMasked_ :: (MonadMVar m, MonadMask m) => MVar m a -> (a -> m a) -> m ()

-- | See <a>modifyMVarMasked</a>.
modifyMVarMasked :: (MonadMVar m, MonadMask m, MonadEvaluate m) => MVar m a -> (a -> m (a, b)) -> m b

-- | This type class is intended for <a>'io-sim'</a>, where one might want
--   to access an <a>MVar</a> in the underlying <tt>ST</tt> monad.
class (MonadMVar m, Monad (InspectMVarMonad m)) => MonadInspectMVar m where {
    type InspectMVarMonad m :: Type -> Type;
}

-- | Return the value of an <a>MVar</a> as an <a>InspectMVarMonad</a>
--   computation. Can be <a>Nothing</a> if the <a>MVar</a> is empty.
inspectMVar :: MonadInspectMVar m => proxy m -> MVar m a -> InspectMVarMonad m (Maybe a)
instance Control.Concurrent.Class.MonadMVar.MonadInspectMVar GHC.Types.IO
instance (Control.Monad.Class.MonadThrow.MonadMask m, Control.Concurrent.Class.MonadMVar.MonadMVar m) => Control.Concurrent.Class.MonadMVar.MonadMVar (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Concurrent.Class.MonadMVar.MonadMVar GHC.Types.IO


-- | <a>time</a> and <a>base</a> time API compatible with both <a>IO</a>
--   and <a>IOSim</a>.
module Control.Monad.Class.MonadTime
class Monad m => MonadTime m

-- | Wall clock time.
getCurrentTime :: MonadTime m => m UTCTime
class Monad m => MonadMonotonicTimeNSec m

-- | Time in a monotonic clock, with high precision. The epoch for this
--   clock is arbitrary and does not correspond to any wall clock or
--   calendar.
--   
--   The time is measured in nano seconds as does
--   <a>getMonotonicTimeNSec</a> from "base".
getMonotonicTimeNSec :: MonadMonotonicTimeNSec m => m Word64

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data () => UTCTime

-- | diffUTCTime a b = a - b
diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime

-- | addUTCTime a b = a + b
addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime

-- | This is a length of time, as measured by UTC. It has a precision of
--   10^-12 s.
--   
--   Conversion functions such as <a>fromInteger</a> and <a>realToFrac</a>
--   will treat it as seconds. For example, <tt>(0.010 ::
--   NominalDiffTime)</tt> corresponds to 10 milliseconds.
--   
--   It has a precision of one picosecond (= 10^-12 s). Enumeration
--   functions will treat it as picoseconds.
--   
--   It ignores leap-seconds, so it's not necessarily a fixed amount of
--   clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime =
--   01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.
data () => NominalDiffTime
instance Control.Monad.Class.MonadTime.MonadTime GHC.Types.IO
instance Control.Monad.Class.MonadTime.MonadTime m => Control.Monad.Class.MonadTime.MonadTime (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadTime.MonadMonotonicTimeNSec GHC.Types.IO
instance Control.Monad.Class.MonadTime.MonadMonotonicTimeNSec m => Control.Monad.Class.MonadTime.MonadMonotonicTimeNSec (Control.Monad.Trans.Reader.ReaderT r m)


-- | Provides classes to handle delays and timeouts which generalised
--   <a>base</a> API to both <a>IO</a> and <a>IOSim</a>.
module Control.Monad.Class.MonadTimer

-- | A typeclass to delay current thread.
class Monad m => MonadDelay m

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   See <a>threadDelay</a>.
threadDelay :: MonadDelay m => Int -> m ()

-- | A typeclass providing utilities for <i>timeouts</i>.
class (MonadDelay m, MonadSTM m) => MonadTimer m

-- | See <a>registerDelay</a>.
registerDelay :: MonadTimer m => Int -> m (TVar m Bool)

-- | See <a>timeout</a>.
timeout :: MonadTimer m => Int -> m a -> m (Maybe a)
instance Control.Monad.Class.MonadTimer.MonadTimer GHC.Types.IO
instance Control.Monad.Class.MonadTimer.MonadTimer m => Control.Monad.Class.MonadTimer.MonadTimer (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadTimer.MonadDelay GHC.Types.IO
instance Control.Monad.Class.MonadTimer.MonadDelay m => Control.Monad.Class.MonadTimer.MonadDelay (Control.Monad.Trans.Reader.ReaderT r m)


-- | <a>async</a> API compatible with both <a>IO</a> and <a>IOSim</a>.
module Control.Monad.Class.MonadAsync
class (MonadSTM m, MonadThread m) => MonadAsync m where {
    
    -- | An asynchronous action
    --   
    --   See <a>Async</a>.
    type Async m = (async :: Type -> Type) | async -> m;
}

-- | See <a>async</a>.
async :: MonadAsync m => m a -> m (Async m a)

-- | See <a>asyncBound</a>.
asyncBound :: MonadAsync m => m a -> m (Async m a)

-- | See <a>asyncOn</a>.
asyncOn :: MonadAsync m => Int -> m a -> m (Async m a)

-- | See <a>asyncThreadId</a>.
asyncThreadId :: MonadAsync m => Async m a -> ThreadId m

-- | See <a>withAsync</a>.
withAsync :: MonadAsync m => m a -> (Async m a -> m b) -> m b

-- | See <a>withAsyncBound</a>.
withAsyncBound :: MonadAsync m => m a -> (Async m a -> m b) -> m b

-- | See <a>withAsyncOn</a>.
withAsyncOn :: MonadAsync m => Int -> m a -> (Async m a -> m b) -> m b

-- | See <a>waitSTM</a>.
waitSTM :: MonadAsync m => Async m a -> STM m a

-- | See <a>pollSTM</a>.
pollSTM :: MonadAsync m => Async m a -> STM m (Maybe (Either SomeException a))

-- | See <a>waitCatchSTM</a>.
waitCatchSTM :: MonadAsync m => Async m a -> STM m (Either SomeException a)

-- | See <a>waitSTM</a>.
waitSTM :: (MonadAsync m, MonadThrow (STM m)) => Async m a -> STM m a

-- | See <a>waitAnySTM</a>.
waitAnySTM :: MonadAsync m => [Async m a] -> STM m (Async m a, a)

-- | See <a>waitAnyCatchSTM</a>.
waitAnyCatchSTM :: MonadAsync m => [Async m a] -> STM m (Async m a, Either SomeException a)

-- | See <a>waitEitherSTM</a>.
waitEitherSTM :: MonadAsync m => Async m a -> Async m b -> STM m (Either a b)

-- | See <a>waitEitherSTM_</a>.
waitEitherSTM_ :: MonadAsync m => Async m a -> Async m b -> STM m ()

-- | See <a>waitEitherCatchSTM</a>.
waitEitherCatchSTM :: MonadAsync m => Async m a -> Async m b -> STM m (Either (Either SomeException a) (Either SomeException b))

-- | See <a>waitBothSTM</a>.
waitBothSTM :: MonadAsync m => Async m a -> Async m b -> STM m (a, b)

-- | See <a>wait</a>.
wait :: MonadAsync m => Async m a -> m a

-- | See <a>poll</a>.
poll :: MonadAsync m => Async m a -> m (Maybe (Either SomeException a))

-- | See <a>waitCatch</a>.
waitCatch :: MonadAsync m => Async m a -> m (Either SomeException a)

-- | See <a>cancel</a>.
cancel :: MonadAsync m => Async m a -> m ()

-- | See <a>cancelWith</a>.
cancelWith :: (MonadAsync m, Exception e) => Async m a -> e -> m ()

-- | See <a>uninterruptibleCancel</a>.
uninterruptibleCancel :: MonadAsync m => Async m a -> m ()

-- | See <a>waitAny</a>.
waitAny :: MonadAsync m => [Async m a] -> m (Async m a, a)

-- | See <a>waitAnyCatch</a>.
waitAnyCatch :: MonadAsync m => [Async m a] -> m (Async m a, Either SomeException a)

-- | See <a>waitAnyCancel</a>.
waitAnyCancel :: MonadAsync m => [Async m a] -> m (Async m a, a)

-- | See <a>waitAnyCatchCancel</a>.
waitAnyCatchCancel :: MonadAsync m => [Async m a] -> m (Async m a, Either SomeException a)

-- | See <a>waitEither</a>.
waitEither :: MonadAsync m => Async m a -> Async m b -> m (Either a b)

-- | See <a>waitAnySTM</a>.
waitAnySTM :: (MonadAsync m, MonadThrow (STM m)) => [Async m a] -> STM m (Async m a, a)

-- | See <a>waitEitherSTM</a>.
waitEitherSTM :: (MonadAsync m, MonadThrow (STM m)) => Async m a -> Async m b -> STM m (Either a b)

-- | See <a>waitEitherSTM_</a>.
waitEitherSTM_ :: (MonadAsync m, MonadThrow (STM m)) => Async m a -> Async m b -> STM m ()

-- | See <a>waitBothSTM</a>.
waitBothSTM :: (MonadAsync m, MonadThrow (STM m)) => Async m a -> Async m b -> STM m (a, b)

-- | Note, IO-based implementations should override the default
--   implementation. See the <tt>async</tt> package implementation and
--   comments.
--   <a>http://hackage.haskell.org/package/async-2.2.1/docs/src/Control.Concurrent.Async.html#waitEitherCatch</a>
--   
--   See <a>waitEitherCatch</a>.
waitEitherCatch :: MonadAsync m => Async m a -> Async m b -> m (Either (Either SomeException a) (Either SomeException b))

-- | See <a>waitEitherCancel</a>.
waitEitherCancel :: MonadAsync m => Async m a -> Async m b -> m (Either a b)

-- | See <a>waitEitherCatchCancel</a>.
waitEitherCatchCancel :: MonadAsync m => Async m a -> Async m b -> m (Either (Either SomeException a) (Either SomeException b))

-- | See <a>waitEither_</a>.
waitEither_ :: MonadAsync m => Async m a -> Async m b -> m ()

-- | See <a>waitBoth</a>.
waitBoth :: MonadAsync m => Async m a -> Async m b -> m (a, b)

-- | See <a>race</a>.
race :: MonadAsync m => m a -> m b -> m (Either a b)

-- | See <a>race_</a>.
race_ :: MonadAsync m => m a -> m b -> m ()

-- | See <a>concurrently</a>.
concurrently :: MonadAsync m => m a -> m b -> m (a, b)

-- | See <a>concurrently_</a>.
concurrently_ :: MonadAsync m => m a -> m b -> m ()

-- | See <a>concurrently_</a>.
asyncWithUnmask :: MonadAsync m => ((forall b. m b -> m b) -> m a) -> m (Async m a)

-- | See <a>asyncOnWithUnmask</a>.
asyncOnWithUnmask :: MonadAsync m => Int -> ((forall b. m b -> m b) -> m a) -> m (Async m a)

-- | See <a>withAsyncWithUnmask</a>.
withAsyncWithUnmask :: MonadAsync m => ((forall c. m c -> m c) -> m a) -> (Async m a -> m b) -> m b

-- | See <a>withAsyncOnWithUnmask</a>.
withAsyncOnWithUnmask :: MonadAsync m => Int -> ((forall c. m c -> m c) -> m a) -> (Async m a -> m b) -> m b

-- | See <a>compareAsyncs</a>.
compareAsyncs :: MonadAsync m => Async m a -> Async m b -> Ordering

-- | See <a>withAsync</a>.
withAsync :: (MonadAsync m, MonadMask m) => m a -> (Async m a -> m b) -> m b

-- | See <a>withAsyncBound</a>.
withAsyncBound :: (MonadAsync m, MonadMask m) => m a -> (Async m a -> m b) -> m b

-- | See <a>withAsyncOn</a>.
withAsyncOn :: (MonadAsync m, MonadMask m) => Int -> m a -> (Async m a -> m b) -> m b

-- | See <a>withAsyncWithUnmask</a>.
withAsyncWithUnmask :: (MonadAsync m, MonadMask m) => ((forall c. m c -> m c) -> m a) -> (Async m a -> m b) -> m b

-- | See <a>withAsyncOnWithUnmask</a>.
withAsyncOnWithUnmask :: (MonadAsync m, MonadMask m) => Int -> ((forall c. m c -> m c) -> m a) -> (Async m a -> m b) -> m b

-- | See <a>uninterruptibleCancel</a>.
uninterruptibleCancel :: (MonadAsync m, MonadMask m) => Async m a -> m ()

-- | See <a>waitAnyCancel</a>.
waitAnyCancel :: (MonadAsync m, MonadThrow m) => [Async m a] -> m (Async m a, a)

-- | See <a>waitAnyCatchCancel</a>.
waitAnyCatchCancel :: (MonadAsync m, MonadThrow m) => [Async m a] -> m (Async m a, Either SomeException a)

-- | See <a>waitEitherCancel</a>.
waitEitherCancel :: (MonadAsync m, MonadThrow m) => Async m a -> Async m b -> m (Either a b)

-- | See <a>waitEitherCatchCancel</a>.
waitEitherCatchCancel :: (MonadAsync m, MonadThrow m) => Async m a -> Async m b -> m (Either (Either SomeException a) (Either SomeException b))

-- | See <a>compareAsyncs</a>.
compareAsyncs :: (MonadAsync m, Ord (ThreadId m)) => Async m a -> Async m b -> Ordering
data () => AsyncCancelled
AsyncCancelled :: AsyncCancelled

-- | Exception from child thread re-raised in parent thread
--   
--   We record the thread ID of the child thread as a <a>String</a>. This
--   avoids an <tt>m</tt> parameter in the type, which is important:
--   <a>ExceptionInLinkedThread</a> must be an instance of
--   <a>Exception</a>, requiring it to be <tt>Typeable</tt>; if <tt>m</tt>
--   appeared in the type, we would require <tt>m</tt> to be
--   <tt>Typeable</tt>, which does not work with with the simulator, as it
--   would require a <tt>Typeable</tt> constraint on the <tt>s</tt>
--   parameter of <tt>IOSim</tt>.
data ExceptionInLinkedThread
ExceptionInLinkedThread :: String -> SomeException -> ExceptionInLinkedThread

-- | Like <a>link</a>.
link :: (MonadAsync m, MonadFork m, MonadMask m) => Async m a -> m ()

-- | Like <a>linkOnly</a>.
linkOnly :: forall m a. (MonadAsync m, MonadFork m, MonadMask m) => (SomeException -> Bool) -> Async m a -> m ()

-- | Like <a>link2</a>.
link2 :: (MonadAsync m, MonadFork m, MonadMask m) => Async m a -> Async m b -> m ()

-- | Like <a>link2Only</a>.
link2Only :: (MonadAsync m, MonadFork m, MonadMask m) => (SomeException -> Bool) -> Async m a -> Async m b -> m ()

-- | See <a>mapConcurrently</a>.
mapConcurrently :: (Traversable t, MonadAsync m) => (a -> m b) -> t a -> m (t b)

-- | See <a>forConcurrently</a>.
forConcurrently :: (Traversable t, MonadAsync m) => t a -> (a -> m b) -> m (t b)

-- | See <a>mapConcurrently_</a>.
mapConcurrently_ :: (Foldable f, MonadAsync m) => (a -> m b) -> f a -> m ()

-- | See <a>forConcurrently_</a>.
forConcurrently_ :: (Foldable f, MonadAsync m) => f a -> (a -> m b) -> m ()

-- | See <a>replicateConcurrently</a>.
replicateConcurrently :: MonadAsync m => Int -> m a -> m [a]

-- | See <a>replicateConcurrently_</a>.
replicateConcurrently_ :: MonadAsync m => Int -> m a -> m ()

-- | Similar to <a>Concurrently</a> but which works for any
--   <a>MonadAsync</a> instance.
newtype Concurrently m a
Concurrently :: m a -> Concurrently m a
[runConcurrently] :: Concurrently m a -> m a
instance (Control.Monad.Class.MonadAsync.MonadAsync m, Control.Monad.Class.MonadThrow.MonadCatch (Control.Monad.Class.MonadSTM.Internal.STM m), Control.Monad.Class.MonadFork.MonadFork m, Control.Monad.Class.MonadThrow.MonadMask m) => Control.Monad.Class.MonadAsync.MonadAsync (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Show.Show Control.Monad.Class.MonadAsync.ExceptionInLinkedThread
instance GHC.Exception.Type.Exception Control.Monad.Class.MonadAsync.ExceptionInLinkedThread
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Class.MonadAsync.Concurrently m)
instance Control.Monad.Class.MonadAsync.MonadAsync m => GHC.Base.Applicative (Control.Monad.Class.MonadAsync.Concurrently m)
instance (Control.Monad.Class.MonadAsync.MonadAsync m, Control.Monad.Class.MonadTimer.MonadTimer m) => GHC.Base.Alternative (Control.Monad.Class.MonadAsync.Concurrently m)
instance (GHC.Base.Semigroup a, Control.Monad.Class.MonadAsync.MonadAsync m) => GHC.Base.Semigroup (Control.Monad.Class.MonadAsync.Concurrently m a)
instance (GHC.Base.Monoid a, Control.Monad.Class.MonadAsync.MonadAsync m) => GHC.Base.Monoid (Control.Monad.Class.MonadAsync.Concurrently m a)
instance Control.Monad.Class.MonadAsync.MonadAsync GHC.Types.IO
