-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Strict STM interface polymorphic over stm implementation.
--   
--   Strict STM interface provided on top of <a>io-classes</a> and thus
--   compatible with <a>stm</a> &amp; <a>io-sim</a>.
@package strict-stm
@version 1.5.0.0


-- | This module corresponds to <a>TArray</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.Strict.TArray
data StrictTArray m i e
type LazyTArray m = TArray m
toLazyTArray :: StrictTArray m i e -> LazyTArray m i e
fromLazyTArray :: LazyTArray m i e -> StrictTArray m i e
instance (Data.Array.Base.MArray (Control.Monad.Class.MonadSTM.Internal.TArray m) e stm, GHC.Base.Monad stm) => Data.Array.Base.MArray (Control.Concurrent.Class.MonadSTM.Strict.TArray.StrictTArray m) e stm


-- | This module corresponds to <a>TBQueue</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.Strict.TBQueue
data StrictTBQueue m a
type LazyTBQueue m = TBQueue m
toLazyTBQueue :: StrictTBQueue m a -> LazyTBQueue m a
fromLazyTBQueue :: LazyTBQueue m a -> StrictTBQueue m a
castStrictTBQueue :: LazyTBQueue m ~ LazyTBQueue n => StrictTBQueue m a -> StrictTBQueue n a
newTBQueue :: MonadSTM m => Natural -> STM m (StrictTBQueue m a)
newTBQueueIO :: MonadSTM m => Natural -> m (StrictTBQueue m a)
readTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m a
tryReadTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m (Maybe a)
peekTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m a
tryPeekTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m (Maybe a)
flushTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m [a]
writeTBQueue :: MonadSTM m => StrictTBQueue m a -> a -> STM m ()
lengthTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m Natural
isEmptyTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m Bool
isFullTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m Bool
unGetTBQueue :: MonadSTM m => StrictTBQueue m a -> a -> STM m ()
labelTBQueue :: MonadLabelledSTM m => StrictTBQueue m a -> String -> STM m ()
labelTBQueueIO :: MonadLabelledSTM m => StrictTBQueue m a -> String -> m ()
traceTBQueue :: MonadTraceSTM m => proxy m -> StrictTBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTBQueueIO :: MonadTraceSTM m => StrictTBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()


-- | This module corresponds to <a>TChan</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.Strict.TChan
data StrictTChan m a
type LazyTChan m = TChan m
toLazyTChan :: StrictTChan m a -> LazyTChan m a
fromLazyTChan :: LazyTChan m a -> StrictTChan m a
castStrictTChan :: LazyTChan m ~ LazyTChan n => StrictTChan m a -> StrictTChan n a
newTChan :: MonadSTM m => STM m (StrictTChan m a)
newBroadcastTChan :: MonadSTM m => STM m (StrictTChan m a)
writeTChan :: MonadSTM m => StrictTChan m a -> a -> STM m ()
readTChan :: MonadSTM m => StrictTChan m a -> STM m a
tryReadTChan :: MonadSTM m => StrictTChan m a -> STM m (Maybe a)
peekTChan :: MonadSTM m => StrictTChan m a -> STM m a
tryPeekTChan :: MonadSTM m => StrictTChan m a -> STM m (Maybe a)
dupTChan :: MonadSTM m => StrictTChan m a -> STM m (StrictTChan m a)
unGetTChan :: MonadSTM m => StrictTChan m a -> a -> STM m ()
isEmptyTChan :: MonadSTM m => StrictTChan m a -> STM m Bool
cloneTChan :: MonadSTM m => StrictTChan m a -> STM m (StrictTChan m a)


-- | This module corresponds to <a>TMVar</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.Strict.TMVar

-- | <tt>TMVar</tt> that keeps its value in WHNF at all times
data StrictTMVar m a
type LazyTMVar m = TMVar m
toLazyTMVar :: StrictTMVar m a -> LazyTMVar m a
fromLazyTMVar :: LazyTMVar m a -> StrictTMVar m a
castStrictTMVar :: LazyTMVar m ~ LazyTMVar n => StrictTMVar m a -> StrictTMVar n a
newTMVar :: MonadSTM m => a -> STM m (StrictTMVar m a)
newEmptyTMVar :: MonadSTM m => STM m (StrictTMVar m a)
newTMVarIO :: MonadSTM m => a -> m (StrictTMVar m a)
newEmptyTMVarIO :: MonadSTM m => m (StrictTMVar m a)
takeTMVar :: MonadSTM m => StrictTMVar m a -> STM m a
tryTakeTMVar :: MonadSTM m => StrictTMVar m a -> STM m (Maybe a)
putTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m ()
tryPutTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m Bool
readTMVar :: MonadSTM m => StrictTMVar m a -> STM m a
tryReadTMVar :: MonadSTM m => StrictTMVar m a -> STM m (Maybe a)
swapTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m a
writeTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m ()
isEmptyTMVar :: MonadSTM m => StrictTMVar m a -> STM m Bool
labelTMVar :: MonadLabelledSTM m => StrictTMVar m a -> String -> STM m ()
labelTMVarIO :: MonadLabelledSTM m => StrictTMVar m a -> String -> m ()
traceTMVar :: MonadTraceSTM m => proxy m -> StrictTMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
traceTMVarIO :: MonadTraceSTM m => StrictTMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> m ()


-- | This module corresponds to <a>TQueue</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.Strict.TQueue
data StrictTQueue m a
type LazyTQueue m = TQueue m
toLazyTQueue :: StrictTQueue m a -> LazyTQueue m a
fromLazyTQueue :: LazyTQueue m a -> StrictTQueue m a
castStrictTQueue :: LazyTQueue m ~ LazyTQueue n => StrictTQueue m a -> StrictTQueue n a
newTQueue :: MonadSTM m => STM m (StrictTQueue m a)
newTQueueIO :: MonadSTM m => m (StrictTQueue m a)
readTQueue :: MonadSTM m => StrictTQueue m a -> STM m a
tryReadTQueue :: MonadSTM m => StrictTQueue m a -> STM m (Maybe a)
peekTQueue :: MonadSTM m => StrictTQueue m a -> STM m a
tryPeekTQueue :: MonadSTM m => StrictTQueue m a -> STM m (Maybe a)
flushTQueue :: MonadSTM m => StrictTQueue m a -> STM m [a]
writeTQueue :: MonadSTM m => StrictTQueue m a -> a -> STM m ()
unGetTQueue :: MonadSTM m => StrictTQueue m a -> a -> STM m ()
isEmptyTQueue :: MonadSTM m => StrictTQueue m a -> STM m Bool
labelTQueue :: MonadLabelledSTM m => StrictTQueue m a -> String -> STM m ()
labelTQueueIO :: MonadLabelledSTM m => StrictTQueue m a -> String -> m ()
traceTQueue :: MonadTraceSTM m => proxy m -> StrictTQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTQueueIO :: MonadTraceSTM m => StrictTQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()


-- | This module corresponds to <a>TVar</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.Strict.TVar
data StrictTVar m a
type LazyTVar m = TVar m

-- | Get the underlying <tt>TVar</tt>
--   
--   Since we obviously cannot guarantee that updates to this
--   <a>LazyTVar</a> will be strict, this should be used with caution.
toLazyTVar :: StrictTVar m a -> LazyTVar m a
fromLazyTVar :: LazyTVar m a -> StrictTVar m a

-- | Cast the monad if both use the same representation of <tt>TVar</tt>s.
--   
--   This function is useful for monad transformers stacks if the
--   <tt>TVar</tt> is used in different monad stacks.
castStrictTVar :: LazyTVar m ~ LazyTVar n => StrictTVar m a -> StrictTVar n a
newTVar :: MonadSTM m => a -> STM m (StrictTVar m a)
newTVarIO :: MonadSTM m => a -> m (StrictTVar m a)
readTVar :: MonadSTM m => StrictTVar m a -> STM m a
readTVarIO :: MonadSTM m => StrictTVar m a -> m a
writeTVar :: MonadSTM m => StrictTVar m a -> a -> STM m ()
modifyTVar :: MonadSTM m => StrictTVar m a -> (a -> a) -> STM m ()
stateTVar :: MonadSTM m => StrictTVar m s -> (s -> (a, s)) -> STM m a
swapTVar :: MonadSTM m => StrictTVar m a -> a -> STM m a
check :: MonadSTM m => Bool -> STM m ()
labelTVar :: MonadLabelledSTM m => StrictTVar m a -> String -> STM m ()
labelTVarIO :: MonadLabelledSTM m => StrictTVar m a -> String -> m ()
traceTVar :: MonadTraceSTM m => proxy m -> StrictTVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> STM m ()
traceTVarIO :: MonadTraceSTM m => StrictTVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> m ()


-- | This module corresponds to <a>STM</a> in "stm" package
module Control.Concurrent.Class.MonadSTM.Strict
class (Monad m, Monad STM m) => MonadSTM (m :: Type -> Type) where {
    type family STM (m :: Type -> Type) = (stm :: Type -> Type) | stm -> m;
}
atomically :: (MonadSTM m, HasCallStack) => STM m a -> m a
retry :: MonadSTM m => STM m a
orElse :: MonadSTM m => STM m a -> STM m a -> STM m a
check :: MonadSTM m => Bool -> STM m ()
type family STM (m :: Type -> Type) = (stm :: Type -> Type) | stm -> m
data StrictTArray m i e
type LazyTArray m = TArray m
data StrictTBQueue m a
type LazyTBQueue m = TBQueue m
data StrictTChan m a
type LazyTChan m = TChan m

-- | <tt>TMVar</tt> that keeps its value in WHNF at all times
data StrictTMVar m a
type LazyTMVar m = TMVar m
data StrictTQueue m a
type LazyTQueue m = TQueue m
data StrictTVar m a
type LazyTVar m = TVar m
class (MonadSTM m, Monad InspectMonad m) => MonadInspectSTM (m :: Type -> Type) where {
    type family InspectMonad (m :: Type -> Type) :: Type -> Type;
}
inspectTVar :: MonadInspectSTM m => proxy m -> TVar m a -> InspectMonad m a
inspectTMVar :: MonadInspectSTM m => proxy m -> TMVar m a -> InspectMonad m (Maybe a)
class MonadSTM m => MonadLabelledSTM (m :: Type -> Type)
class MonadInspectSTM m => MonadTraceSTM (m :: Type -> Type)
traceTSem :: MonadTraceSTM m => proxy m -> TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> STM m ()
traceTSemIO :: MonadTraceSTM m => TSem m -> (Maybe Integer -> Integer -> InspectMonad m TraceValue) -> m ()
type family InspectMonad (m :: Type -> Type) :: Type -> Type
data () => TraceValue
[TraceValue] :: forall tr. Typeable tr => Maybe tr -> Maybe String -> TraceValue
pattern DontTrace :: TraceValue
pattern TraceDynamic :: () => Typeable tr => tr -> TraceValue
pattern TraceString :: String -> TraceValue
newTQueueIO :: MonadSTM m => m (StrictTQueue m a)
newTBQueueIO :: MonadSTM m => Natural -> m (StrictTBQueue m a)
newTMVarIO :: MonadSTM m => a -> m (StrictTMVar m a)
throwSTM :: forall (m :: Type -> Type) e a. (MonadSTM m, MonadThrow (STM m), Exception e) => e -> STM m a
newTVar :: MonadSTM m => a -> STM m (StrictTVar m a)
newTVarIO :: MonadSTM m => a -> m (StrictTVar m a)
readTVarIO :: MonadSTM m => StrictTVar m a -> m a
readTVar :: MonadSTM m => StrictTVar m a -> STM m a
writeTVar :: MonadSTM m => StrictTVar m a -> a -> STM m ()
newTBQueue :: MonadSTM m => Natural -> STM m (StrictTBQueue m a)
writeTBQueue :: MonadSTM m => StrictTBQueue m a -> a -> STM m ()
readTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m a
tryReadTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m (Maybe a)
flushTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m [a]
peekTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m a
tryPeekTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m (Maybe a)
unGetTBQueue :: MonadSTM m => StrictTBQueue m a -> a -> STM m ()
lengthTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m Natural
isEmptyTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m Bool
isFullTBQueue :: MonadSTM m => StrictTBQueue m a -> STM m Bool
newTChan :: MonadSTM m => STM m (StrictTChan m a)
newBroadcastTChan :: MonadSTM m => STM m (StrictTChan m a)
writeTChan :: MonadSTM m => StrictTChan m a -> a -> STM m ()
readTChan :: MonadSTM m => StrictTChan m a -> STM m a
tryReadTChan :: MonadSTM m => StrictTChan m a -> STM m (Maybe a)
peekTChan :: MonadSTM m => StrictTChan m a -> STM m a
tryPeekTChan :: MonadSTM m => StrictTChan m a -> STM m (Maybe a)
dupTChan :: MonadSTM m => StrictTChan m a -> STM m (StrictTChan m a)
unGetTChan :: MonadSTM m => StrictTChan m a -> a -> STM m ()
isEmptyTChan :: MonadSTM m => StrictTChan m a -> STM m Bool
cloneTChan :: MonadSTM m => StrictTChan m a -> STM m (StrictTChan m a)
newTMVar :: MonadSTM m => a -> STM m (StrictTMVar m a)
newEmptyTMVar :: MonadSTM m => STM m (StrictTMVar m a)
newEmptyTMVarIO :: MonadSTM m => m (StrictTMVar m a)
takeTMVar :: MonadSTM m => StrictTMVar m a -> STM m a
tryTakeTMVar :: MonadSTM m => StrictTMVar m a -> STM m (Maybe a)
putTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m ()
tryPutTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m Bool
readTMVar :: MonadSTM m => StrictTMVar m a -> STM m a
tryReadTMVar :: MonadSTM m => StrictTMVar m a -> STM m (Maybe a)
swapTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m a
writeTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m ()
isEmptyTMVar :: MonadSTM m => StrictTMVar m a -> STM m Bool
newTQueue :: MonadSTM m => STM m (StrictTQueue m a)
writeTQueue :: MonadSTM m => StrictTQueue m a -> a -> STM m ()
readTQueue :: MonadSTM m => StrictTQueue m a -> STM m a
tryReadTQueue :: MonadSTM m => StrictTQueue m a -> STM m (Maybe a)
flushTQueue :: MonadSTM m => StrictTQueue m a -> STM m [a]
peekTQueue :: MonadSTM m => StrictTQueue m a -> STM m a
tryPeekTQueue :: MonadSTM m => StrictTQueue m a -> STM m (Maybe a)
unGetTQueue :: MonadSTM m => StrictTQueue m a -> a -> STM m ()
isEmptyTQueue :: MonadSTM m => StrictTQueue m a -> STM m Bool
modifyTVar :: MonadSTM m => StrictTVar m a -> (a -> a) -> STM m ()
stateTVar :: MonadSTM m => StrictTVar m s -> (s -> (a, s)) -> STM m a
swapTVar :: MonadSTM m => StrictTVar m a -> a -> STM m a
traceTBQueue :: MonadTraceSTM m => proxy m -> StrictTBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTBQueueIO :: MonadTraceSTM m => StrictTBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTMVar :: MonadTraceSTM m => proxy m -> StrictTMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
traceTMVarIO :: MonadTraceSTM m => StrictTMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> m ()
traceTQueue :: MonadTraceSTM m => proxy m -> StrictTQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTQueueIO :: MonadTraceSTM m => StrictTQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTVar :: MonadTraceSTM m => proxy m -> StrictTVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> STM m ()
traceTVarIO :: MonadTraceSTM m => StrictTVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> m ()
fromLazyTArray :: LazyTArray m i e -> StrictTArray m i e
fromLazyTBQueue :: LazyTBQueue m a -> StrictTBQueue m a
castStrictTBQueue :: LazyTBQueue m ~ LazyTBQueue n => StrictTBQueue m a -> StrictTBQueue n a
labelTBQueue :: MonadLabelledSTM m => StrictTBQueue m a -> String -> STM m ()
labelTBQueueIO :: MonadLabelledSTM m => StrictTBQueue m a -> String -> m ()
fromLazyTChan :: LazyTChan m a -> StrictTChan m a
castStrictTChan :: LazyTChan m ~ LazyTChan n => StrictTChan m a -> StrictTChan n a
fromLazyTMVar :: LazyTMVar m a -> StrictTMVar m a
castStrictTMVar :: LazyTMVar m ~ LazyTMVar n => StrictTMVar m a -> StrictTMVar n a
labelTMVar :: MonadLabelledSTM m => StrictTMVar m a -> String -> STM m ()
labelTMVarIO :: MonadLabelledSTM m => StrictTMVar m a -> String -> m ()
fromLazyTQueue :: LazyTQueue m a -> StrictTQueue m a
castStrictTQueue :: LazyTQueue m ~ LazyTQueue n => StrictTQueue m a -> StrictTQueue n a
labelTQueue :: MonadLabelledSTM m => StrictTQueue m a -> String -> STM m ()
labelTQueueIO :: MonadLabelledSTM m => StrictTQueue m a -> String -> m ()

-- | Get the underlying <tt>TVar</tt>
--   
--   Since we obviously cannot guarantee that updates to this
--   <a>LazyTVar</a> will be strict, this should be used with caution.
toLazyTVar :: StrictTVar m a -> LazyTVar m a
fromLazyTVar :: LazyTVar m a -> StrictTVar m a

-- | Cast the monad if both use the same representation of <tt>TVar</tt>s.
--   
--   This function is useful for monad transformers stacks if the
--   <tt>TVar</tt> is used in different monad stacks.
castStrictTVar :: LazyTVar m ~ LazyTVar n => StrictTVar m a -> StrictTVar n a
labelTVar :: MonadLabelledSTM m => StrictTVar m a -> String -> STM m ()
labelTVarIO :: MonadLabelledSTM m => StrictTVar m a -> String -> m ()
