-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Prometheus Haskell Client
--   
--   <ul>
--   <li><i>Prometheus Haskell Client</i></li>
--   </ul>
--   
--   A simple and modern, type safe, performance focused, idiomatic Haskell
--   client for <a>Prometheus</a> monitoring. Specifically there is no use
--   of unsafe IO or manual ByteString construction from lists of bytes.
--   Batteries-included web server.
--   
--   A key design element of this library is that the RegistryT monad
--   transformer is only required for registering new time series. Once the
--   time series is registered, new data samples may just be added in the
--   IO monad.
--   
--   Note: Version 0.* supports Prometheus v1.0 and version 2.* supports
--   Prometheus v2.0.
--   
--   <ul>
--   <li><i>Usage Example</i></li>
--   </ul>
--   
--   <pre>
--   module Example where
--   
--   import           Control.Monad.IO.Class                         (liftIO)
--   import           System.Metrics.Prometheus.Http.Scrape          (serveMetricsT)
--   import           System.Metrics.Prometheus.Concurrent.RegistryT
--   import           System.Metrics.Prometheus.Metric.Counter       (inc)
--   import           System.Metrics.Prometheus.MetricId
--   
--   main :: IO ()
--   main = runRegistryT $ do
--       -- Labels can be defined as lists or added to an empty label set
--       connectSuccessGauge &lt;- registerGauge "example_connections" (fromList [("login", "success")])
--       connectFailureGauge &lt;- registerGauge "example_connections" (addLabel "login" "failure" mempty)
--       connectCounter &lt;- registerCounter "example_connection_total" mempty
--       latencyHistogram &lt;- registerHistogram "example_round_trip_latency_ms" mempty [10, 20..100]
--   
--       liftIO $ inc connectCounter -- increment a counter
--   
--       -- [...] pass metric handles to the rest of the app
--   
--       serveMetricsT 8080 ["metrics"] -- http://localhost:8080/metric server
--   </pre>
--   
--   <ul>
--   <li><i>Advanced Usage</i></li>
--   </ul>
--   
--   A <a>Registry</a> and <a>StateT</a>-based <a>RegistryT</a> are
--   available for unit testing or generating lists of `[IO a]` actions
--   that can be <a>sequenced</a> and returned from pure code to be
--   applied.
@package prometheus
@version 2.3.0

module System.Metrics.Prometheus.Metric.Counter
data Counter
newtype CounterSample
CounterSample :: Int -> CounterSample
[unCounterSample] :: CounterSample -> Int
new :: IO Counter
add :: Int -> Counter -> IO ()
inc :: Counter -> IO ()
sample :: Counter -> IO CounterSample
addAndSample :: Int -> Counter -> IO CounterSample

-- | Write <tt>i</tt> to the counter, if <tt>i</tt> is more than the
--   current value. This is useful for when the count is maintained by a
--   separate system (e.g. GHC's GC counter).
--   
--   WARNING: For multiple writers, the most recent one wins, which may not
--   preserve the increasing property. If you have stronger requirements
--   than this, please check with the maintainers. See
--   <a>https://github.com/bitnomial/prometheus/pull/44</a> for discussion.
set :: Int -> Counter -> IO ()
instance GHC.Show.Show System.Metrics.Prometheus.Metric.Counter.CounterSample

module System.Metrics.Prometheus.Metric.Gauge
data Gauge
newtype GaugeSample
GaugeSample :: Double -> GaugeSample
[unGaugeSample] :: GaugeSample -> Double
new :: IO Gauge
add :: Double -> Gauge -> IO ()
sub :: Double -> Gauge -> IO ()
inc :: Gauge -> IO ()
dec :: Gauge -> IO ()
set :: Double -> Gauge -> IO ()
sample :: Gauge -> IO GaugeSample
modifyAndSample :: (Double -> Double) -> Gauge -> IO GaugeSample
instance GHC.Show.Show System.Metrics.Prometheus.Metric.Gauge.GaugeSample

module System.Metrics.Prometheus.Metric.Histogram
data Histogram
data HistogramSample
HistogramSample :: !Buckets -> !Double -> !Int -> HistogramSample
[histBuckets] :: HistogramSample -> !Buckets
[histSum] :: HistogramSample -> !Double
[histCount] :: HistogramSample -> !Int
type Buckets = Map UpperBound Double
type UpperBound = Double
new :: [UpperBound] -> IO Histogram
observe :: Double -> Histogram -> IO ()
sample :: Histogram -> IO HistogramSample
observeAndSample :: Double -> Histogram -> IO HistogramSample
instance GHC.Show.Show System.Metrics.Prometheus.Metric.Histogram.HistogramSample

module System.Metrics.Prometheus.Metric.Summary
data SummarySample
SummarySample :: !Map Double Int -> !Int -> !Int -> SummarySample
[sumQuantiles] :: SummarySample -> !Map Double Int
[sumSum] :: SummarySample -> !Int
[sumCount] :: SummarySample -> !Int
instance GHC.Show.Show System.Metrics.Prometheus.Metric.Summary.SummarySample

module System.Metrics.Prometheus.Metric
data Metric
CounterMetric :: Counter -> Metric
GaugeMetric :: Gauge -> Metric

-- | Summary S.Summary
HistogramMetric :: Histogram -> Metric
data MetricSample
CounterMetricSample :: CounterSample -> MetricSample
GaugeMetricSample :: GaugeSample -> MetricSample
HistogramMetricSample :: HistogramSample -> MetricSample
SummaryMetricSample :: SummarySample -> MetricSample
metricSample :: (CounterSample -> a) -> (GaugeSample -> a) -> (HistogramSample -> a) -> (SummarySample -> a) -> MetricSample -> a

module System.Metrics.Prometheus.MetricId

-- | Construct with <a>makeName</a> to ensure that names use only valid
--   characters
newtype Name
Name :: Text -> Name
[unName] :: Name -> Text
newtype Labels
Labels :: Map Text Text -> Labels
[unLabels] :: Labels -> Map Text Text
data MetricId
MetricId :: Name -> Labels -> MetricId
[name] :: MetricId -> Name
[labels] :: MetricId -> Labels
addLabel :: Text -> Text -> Labels -> Labels
fromList :: [(Text, Text)] -> Labels
toList :: Labels -> [(Text, Text)]
null :: Labels -> Bool

-- | Make the input match the regex <tt>[a-zA-Z_][a-zA-Z0-9_]</tt> which
--   defines valid metric and label names, according to
--   <a>https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels</a>
--   Replace invalid characters with <tt>_</tt> and add a leading
--   <tt>_</tt> if the first character is only valid as a later character.
makeValid :: Text -> Text

-- | Construct a <a>Name</a>, replacing disallowed characters.
makeName :: Text -> Name
instance GHC.Base.Semigroup System.Metrics.Prometheus.MetricId.Name
instance GHC.Base.Monoid System.Metrics.Prometheus.MetricId.Name
instance GHC.Classes.Ord System.Metrics.Prometheus.MetricId.Name
instance GHC.Classes.Eq System.Metrics.Prometheus.MetricId.Name
instance GHC.Show.Show System.Metrics.Prometheus.MetricId.Name
instance GHC.Base.Semigroup System.Metrics.Prometheus.MetricId.Labels
instance GHC.Base.Monoid System.Metrics.Prometheus.MetricId.Labels
instance GHC.Classes.Ord System.Metrics.Prometheus.MetricId.Labels
instance GHC.Classes.Eq System.Metrics.Prometheus.MetricId.Labels
instance GHC.Show.Show System.Metrics.Prometheus.MetricId.Labels
instance GHC.Show.Show System.Metrics.Prometheus.MetricId.MetricId
instance GHC.Classes.Ord System.Metrics.Prometheus.MetricId.MetricId
instance GHC.Classes.Eq System.Metrics.Prometheus.MetricId.MetricId
instance Data.String.IsString System.Metrics.Prometheus.MetricId.Name

module System.Metrics.Prometheus.Encode.Text.MetricId
encodeHeader :: MetricId -> MetricSample -> Builder
encodeMetricId :: MetricId -> Builder
encodeLabels :: Labels -> Builder
encodeName :: Name -> Builder
textValue :: RealFloat f => f -> Text
encodeDouble :: RealFloat f => f -> Builder
encodeInt :: Int -> Builder
escape :: Text -> Text
newline :: Builder
space :: Builder

module System.Metrics.Prometheus.Encode.Text.Histogram
encodeHistogram :: MetricId -> HistogramSample -> Builder

module System.Metrics.Prometheus.Registry
data Registry
newtype RegistrySample
RegistrySample :: Map MetricId MetricSample -> RegistrySample
[unRegistrySample] :: RegistrySample -> Map MetricId MetricSample
new :: Registry
registerCounter :: Name -> Labels -> Registry -> IO (Counter, Registry)
registerGauge :: Name -> Labels -> Registry -> IO (Gauge, Registry)
registerHistogram :: Name -> Labels -> [UpperBound] -> Registry -> IO (Histogram, Registry)
listMetricIds :: Registry -> [MetricId]
removeMetric :: MetricId -> Registry -> Registry
sample :: Registry -> IO RegistrySample
instance GHC.Show.Show System.Metrics.Prometheus.Registry.KeyError
instance GHC.Exception.Type.Exception System.Metrics.Prometheus.Registry.KeyError

module System.Metrics.Prometheus.Encode.Text
encodeMetrics :: RegistrySample -> Builder

module System.Metrics.Prometheus.Http.Push
pushMetrics :: URI -> Text -> Labels -> Int -> IO RegistrySample -> IO ()

-- | Parses a uri such that <tt> parseURI "<a>https://example.com"</a> ===
--   Just (URI "https:" "//example.com" </tt>
parseURI :: String -> Maybe URI

module System.Metrics.Prometheus.Concurrent.Registry
data Registry
new :: IO Registry
registerCounter :: Name -> Labels -> Registry -> IO Counter
registerGauge :: Name -> Labels -> Registry -> IO Gauge
registerHistogram :: Name -> Labels -> [UpperBound] -> Registry -> IO Histogram
listMetricIds :: Registry -> IO [MetricId]
removeMetric :: MetricId -> Registry -> IO ()
sample :: Registry -> IO RegistrySample

module System.Metrics.Prometheus.Concurrent.RegistryT
newtype RegistryT m a
RegistryT :: ReaderT Registry m a -> RegistryT m a
[unRegistryT] :: RegistryT m a -> ReaderT Registry m a
runRegistryT :: MonadIO m => RegistryT m a -> m a
registerCounter :: MonadIO m => Name -> Labels -> RegistryT m Counter
registerGauge :: MonadIO m => Name -> Labels -> RegistryT m Gauge
registerHistogram :: MonadIO m => Name -> Labels -> [UpperBound] -> RegistryT m Histogram
removeMetric :: MonadIO m => MetricId -> RegistryT m ()
listMetricIds :: MonadIO m => RegistryT m [MetricId]
sample :: Monad m => RegistryT m (IO RegistrySample)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (System.Metrics.Prometheus.Concurrent.RegistryT.RegistryT m)
instance GHC.Base.Functor m => GHC.Base.Functor (System.Metrics.Prometheus.Concurrent.RegistryT.RegistryT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (System.Metrics.Prometheus.Concurrent.RegistryT.RegistryT m)
instance Control.Monad.Trans.Class.MonadTrans System.Metrics.Prometheus.Concurrent.RegistryT.RegistryT
instance GHC.Base.Monad m => GHC.Base.Monad (System.Metrics.Prometheus.Concurrent.RegistryT.RegistryT m)

module System.Metrics.Prometheus.Http.Scrape

-- | The HTTP web route on which to serve data
--   
--   For example:
--   
--   <ul>
--   <li><tt><a>http://localhost:9090/metrics</a></tt> should use a path of
--   <tt>["metrics"]</tt>.</li>
--   <li><tt><a>http://localhost/</a></tt> should use a path of
--   <tt>[]</tt>.</li>
--   </ul>
type Path = [Text]
serveMetrics :: MonadIO m => Port -> Path -> IO RegistrySample -> m ()
serveMetricsT :: MonadIO m => Port -> Path -> RegistryT m ()
prometheusApp :: Path -> IO RegistrySample -> Application

module System.Metrics.Prometheus.RegistryT
newtype RegistryT m a
RegistryT :: StateT Registry m a -> RegistryT m a
[unRegistryT] :: RegistryT m a -> StateT Registry m a
evalRegistryT :: Monad m => RegistryT m a -> m a
execRegistryT :: Monad m => RegistryT m a -> m Registry
runRegistryT :: Monad m => RegistryT m a -> m (a, Registry)
withRegistry :: MonadIO m => (Registry -> m (a, Registry)) -> RegistryT m a
registerCounter :: MonadIO m => Name -> Labels -> RegistryT m Counter
registerGauge :: MonadIO m => Name -> Labels -> RegistryT m Gauge
registerHistogram :: MonadIO m => Name -> Labels -> [UpperBound] -> RegistryT m Histogram
removeMetric :: MonadIO m => MetricId -> RegistryT m ()
listMetricIds :: MonadIO m => RegistryT m [MetricId]
sample :: Monad m => RegistryT m (IO RegistrySample)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (System.Metrics.Prometheus.RegistryT.RegistryT m)
instance GHC.Base.Functor m => GHC.Base.Functor (System.Metrics.Prometheus.RegistryT.RegistryT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (System.Metrics.Prometheus.RegistryT.RegistryT m)
instance Control.Monad.Trans.Class.MonadTrans System.Metrics.Prometheus.RegistryT.RegistryT
instance GHC.Base.Monad m => GHC.Base.Monad (System.Metrics.Prometheus.RegistryT.RegistryT m)
