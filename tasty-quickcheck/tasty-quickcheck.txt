-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | QuickCheck support for the Tasty test framework.
--   
--   QuickCheck support for the Tasty test framework.
@package tasty-quickcheck
@version 0.11.1


-- | This module allows to use QuickCheck properties in tasty.
module Test.Tasty.QuickCheck

-- | Create a <a>TestTree</a> for a QuickCheck <a>Testable</a> property
testProperty :: Testable a => TestName -> a -> TestTree

-- | Create a test from a list of QuickCheck properties. To be used with
--   <a>allProperties</a>. E.g.
--   
--   <pre>
--   tests :: TestTree
--   tests = testProperties "Foo" $allProperties
--   </pre>
testProperties :: TestName -> [(String, Property)] -> TestTree

-- | Number of test cases for QuickCheck to generate
newtype QuickCheckTests
QuickCheckTests :: Int -> QuickCheckTests

-- | Replay seed
data QuickCheckReplay

-- | No seed
QuickCheckReplayNone :: QuickCheckReplay

-- | Legacy integer seed
QuickCheckReplayLegacy :: Int -> QuickCheckReplay

-- | <tt>(qcgen, intSize)</tt> holds both the seed and the size to run
--   QuickCheck tests
QuickCheckReplay :: (QCGen, Int) -> QuickCheckReplay

-- | If a test case fails unexpectedly, show the replay token
newtype QuickCheckShowReplay
QuickCheckShowReplay :: Bool -> QuickCheckShowReplay

-- | Size of the biggest test cases
newtype QuickCheckMaxSize
QuickCheckMaxSize :: Int -> QuickCheckMaxSize

-- | Maximum number of of discarded tests per successful test before giving
--   up.
newtype QuickCheckMaxRatio
QuickCheckMaxRatio :: Int -> QuickCheckMaxRatio

-- | Show the test cases that QuickCheck generates
newtype QuickCheckVerbose
QuickCheckVerbose :: Bool -> QuickCheckVerbose

-- | Number of shrinks allowed before QuickCheck will fail a test.
newtype QuickCheckMaxShrinks
QuickCheckMaxShrinks :: Int -> QuickCheckMaxShrinks

-- | Timeout for individual tests within a property.
newtype QuickCheckTimeout
QuickCheckTimeout :: Timeout -> QuickCheckTimeout
data () => Fun a b
Fun :: (a :-> b, b, Shrunk) -> (a -> b) -> Fun a b
newtype () => Fixed a
Fixed :: a -> Fixed a
[getFixed] :: Fixed a -> a
data () => Property
class () => Arbitrary a
arbitrary :: Arbitrary a => Gen a
shrink :: Arbitrary a => a -> [a]
class () => Arbitrary1 (f :: Type -> Type)
liftArbitrary :: Arbitrary1 f => Gen a -> Gen (f a)
liftShrink :: Arbitrary1 f => (a -> [a]) -> f a -> [f a]
class () => Arbitrary2 (f :: Type -> Type -> Type)
liftArbitrary2 :: Arbitrary2 f => Gen a -> Gen b -> Gen (f a b)
liftShrink2 :: Arbitrary2 f => (a -> [a]) -> (b -> [b]) -> f a b -> [f a b]
class () => CoArbitrary a
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b
class () => Function a
function :: Function a => (a -> b) -> a :-> b
data () => Gen a
newtype () => ASCIIString
ASCIIString :: String -> ASCIIString
[getASCIIString] :: ASCIIString -> String
newtype () => Blind a
Blind :: a -> Blind a
[getBlind] :: Blind a -> a
data () => InfiniteList a
InfiniteList :: [a] -> InfiniteListInternalData a -> InfiniteList a
[getInfiniteList] :: InfiniteList a -> [a]
[infiniteListInternalData] :: InfiniteList a -> InfiniteListInternalData a
newtype () => Large a
Large :: a -> Large a
[getLarge] :: Large a -> a
newtype () => Negative a
Negative :: a -> Negative a
[getNegative] :: Negative a -> a
newtype () => NonEmptyList a
NonEmpty :: [a] -> NonEmptyList a
[getNonEmpty] :: NonEmptyList a -> [a]
newtype () => NonNegative a
NonNegative :: a -> NonNegative a
[getNonNegative] :: NonNegative a -> a
newtype () => NonPositive a
NonPositive :: a -> NonPositive a
[getNonPositive] :: NonPositive a -> a
newtype () => NonZero a
NonZero :: a -> NonZero a
[getNonZero] :: NonZero a -> a
newtype () => OrderedList a
Ordered :: [a] -> OrderedList a
[getOrdered] :: OrderedList a -> [a]
newtype () => Positive a
Positive :: a -> Positive a
[getPositive] :: Positive a -> a
newtype () => PrintableString
PrintableString :: String -> PrintableString
[getPrintableString] :: PrintableString -> String
newtype () => Shrink2 a
Shrink2 :: a -> Shrink2 a
[getShrink2] :: Shrink2 a -> a
class () => ShrinkState s a
shrinkInit :: ShrinkState s a => a -> s
shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
data () => Shrinking s a
Shrinking :: s -> a -> Shrinking s a
newtype () => Small a
Small :: a -> Small a
[getSmall] :: Small a -> a
data () => Smart a
Smart :: Int -> a -> Smart a
newtype () => SortedList a
Sorted :: [a] -> SortedList a
[getSorted] :: SortedList a -> [a]
newtype () => UnicodeString
UnicodeString :: String -> UnicodeString
[getUnicodeString] :: UnicodeString -> String
data () => Discard
Discard :: Discard
class () => Testable prop
property :: Testable prop => prop -> Property
propertyForAllShrinkShow :: Testable prop => Gen a -> (a -> [a]) -> (a -> [String]) -> (a -> prop) -> Property
data () => Witness
Wit :: a -> Witness
data () => Confidence
Confidence :: Integer -> Double -> Confidence
[certainty] :: Confidence -> Integer
[tolerance] :: Confidence -> Double
pattern Success :: () => Int -> Int -> !Map [String] Int -> !Map String Int -> !Map String (Map String Int) -> String -> Result
pattern Failure :: () => Int -> Int -> Int -> Int -> Int -> QCGen -> Int -> String -> Maybe AnException -> String -> [String] -> [String] -> Set String -> [Witness] -> Result
pattern GaveUp :: () => Int -> Int -> !Map [String] Int -> !Map String Int -> !Map String (Map String Int) -> String -> Result
pattern NoExpectedFailure :: () => Int -> Int -> !Map [String] Int -> !Map String Int -> !Map String (Map String Int) -> String -> Result
classes :: Result -> Map String Int
failingClasses :: Result -> Set String
failingLabels :: Result -> [String]
failingTestCase :: Result -> [String]
labels :: Result -> Map [String] Int
numDiscarded :: Result -> Int
numShrinkFinal :: Result -> Int
numShrinkTries :: Result -> Int
numShrinks :: Result -> Int
numTests :: Result -> Int
output :: Result -> String
reason :: Result -> String
tables :: Result -> Map String (Map String Int)
theException :: Result -> Maybe AnException
usedSeed :: Result -> QCGen
usedSize :: Result -> Int
witnesses :: Result -> [Witness]
pattern Fn :: (a -> b) -> Fun a b
pattern Fn2 :: (a -> b -> c) -> Fun (a, b) c
pattern Fn3 :: (a -> b -> c -> d) -> Fun (a, b, c) d
(==>) :: Testable prop => Bool -> prop -> Property
(.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
choose :: Random a => (a, a) -> Gen a
getSize :: Gen Int
label :: Testable prop => String -> prop -> Property
(><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
monomorphic :: Name -> ExpQ
polyQuickCheck :: Name -> ExpQ
polyVerboseCheck :: Name -> ExpQ
applyArbitrary2 :: (Arbitrary a, Arbitrary b) => (a -> b -> r) -> Gen r
applyArbitrary3 :: (Arbitrary a, Arbitrary b, Arbitrary c) => (a -> b -> c -> r) -> Gen r
applyArbitrary4 :: (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) => (a -> b -> c -> d -> r) -> Gen r
arbitrary1 :: (Arbitrary1 f, Arbitrary a) => Gen (f a)
arbitrary2 :: (Arbitrary2 f, Arbitrary a, Arbitrary b) => Gen (f a b)
arbitraryASCIIChar :: Gen Char
arbitraryBoundedEnum :: (Bounded a, Enum a) => Gen a
arbitraryBoundedIntegral :: (Bounded a, Integral a) => Gen a
arbitraryBoundedRandom :: (Bounded a, Random a) => Gen a
arbitraryPrintableChar :: Gen Char
arbitrarySizedBoundedIntegral :: (Bounded a, Integral a) => Gen a
arbitrarySizedFractional :: Fractional a => Gen a
arbitrarySizedIntegral :: Integral a => Gen a
arbitrarySizedNatural :: Integral a => Gen a
arbitraryUnicodeChar :: Gen Char
coarbitraryEnum :: Enum a => a -> Gen b -> Gen b
coarbitraryIntegral :: Integral a => a -> Gen b -> Gen b
coarbitraryReal :: Real a => a -> Gen b -> Gen b
coarbitraryShow :: Show a => a -> Gen b -> Gen b
genericCoarbitrary :: (Generic a, GCoArbitrary (Rep a)) => a -> Gen b -> Gen b
genericShrink :: (Generic a, RecursivelyShrink (Rep a), GSubterms (Rep a) a) => a -> [a]
infiniteList :: Arbitrary a => Gen [a]
orderedList :: (Ord a, Arbitrary a) => Gen [a]
recursivelyShrink :: (Generic a, RecursivelyShrink (Rep a)) => a -> [a]
shrink1 :: (Arbitrary1 f, Arbitrary a) => f a -> [f a]
shrink2 :: (Arbitrary2 f, Arbitrary a, Arbitrary b) => f a b -> [f a b]
shrinkBoundedEnum :: (Bounded a, Enum a, Eq a) => a -> [a]
shrinkDecimal :: RealFrac a => a -> [a]
shrinkIntegral :: Integral a => a -> [a]
shrinkList :: (a -> [a]) -> [a] -> [[a]]
shrinkMap :: Arbitrary a => (a -> b) -> (b -> a) -> b -> [b]
shrinkMapBy :: (a -> b) -> (b -> a) -> (a -> [a]) -> b -> [b]
shrinkNothing :: a -> [a]
shrinkRealFrac :: RealFrac a => a -> [a]
subterms :: (Generic a, GSubterms (Rep a) a) => a -> [a]
vector :: Arbitrary a => Int -> Gen [a]
discard :: a
labelledExamples :: Testable prop => prop -> IO ()
labelledExamplesResult :: Testable prop => prop -> IO Result
labelledExamplesWith :: Testable prop => Args -> prop -> IO ()
labelledExamplesWithResult :: Testable prop => Args -> prop -> IO Result
applyFun :: Fun a b -> a -> b
applyFun2 :: Fun (a, b) c -> a -> b -> c
applyFun3 :: Fun (a, b, c) d -> a -> b -> c -> d
functionBoundedEnum :: (Eq a, Bounded a, Enum a) => (a -> b) -> a :-> b
functionIntegral :: Integral a => (a -> b) -> a :-> b
functionMap :: Function b => (a -> b) -> (b -> a) -> (a -> c) -> a :-> c
functionRealFrac :: RealFrac a => (a -> b) -> a :-> b
functionShow :: (Show a, Read a) => (a -> c) -> a :-> c
functionVoid :: (forall b. () => void -> b) -> void :-> c
chooseAny :: Random a => Gen a
chooseBoundedIntegral :: (Bounded a, Integral a) => (a, a) -> Gen a
chooseEnum :: Enum a => (a, a) -> Gen a
chooseInt :: (Int, Int) -> Gen Int
chooseInteger :: (Integer, Integer) -> Gen Integer
elements :: HasCallStack => [a] -> Gen a
frequency :: HasCallStack => [(Int, Gen a)] -> Gen a
generate :: Gen a -> IO a
growingElements :: HasCallStack => [a] -> Gen a
infiniteListOf :: Gen a -> Gen [a]
listOf :: Gen a -> Gen [a]
listOf1 :: Gen a -> Gen [a]
oneof :: HasCallStack => [Gen a] -> Gen a
resize :: HasCallStack => Int -> Gen a -> Gen a
sample :: Show a => Gen a -> IO ()
sample' :: Gen a -> IO [a]
scale :: (Int -> Int) -> Gen a -> Gen a
shuffle :: [a] -> Gen [a]
sized :: (Int -> Gen a) -> Gen a
sublistOf :: [a] -> Gen [a]
suchThat :: Gen a -> (a -> Bool) -> Gen a
suchThatMap :: Gen a -> (a -> Maybe b) -> Gen b
suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)
variant :: Integral n => n -> Gen a -> Gen a
vectorOf :: Int -> Gen a -> Gen [a]
(.&&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
(.||.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
(=/=) :: (Eq a, Show a) => a -> a -> Property
(===) :: (Eq a, Show a) => a -> a -> Property
again :: Testable prop => prop -> Property
castWitness :: Typeable a => Witness -> Maybe a
checkCoverage :: Testable prop => prop -> Property
checkCoverageWith :: Testable prop => Confidence -> prop -> Property
classify :: Testable prop => Bool -> String -> prop -> Property
coerceWitness :: Typeable a => Witness -> a
collect :: (Show a, Testable prop) => a -> prop -> Property
conjoin :: Testable prop => [prop] -> Property
counterexample :: Testable prop => String -> prop -> Property
cover :: Testable prop => Double -> Bool -> String -> prop -> Property
coverTable :: Testable prop => String -> [(String, Double)] -> prop -> Property
discardAfter :: Testable prop => Int -> prop -> Property
disjoin :: Testable prop => [prop] -> Property
expectFailure :: Testable prop => prop -> Property
forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
forAllBlind :: Testable prop => Gen a -> (a -> prop) -> Property
forAllShow :: Testable prop => Gen a -> (a -> String) -> (a -> prop) -> Property
forAllShrink :: (Show a, Testable prop) => Gen a -> (a -> [a]) -> (a -> prop) -> Property
forAllShrinkBlind :: Testable prop => Gen a -> (a -> [a]) -> (a -> prop) -> Property
forAllShrinkShow :: Testable prop => Gen a -> (a -> [a]) -> (a -> String) -> (a -> prop) -> Property
idempotentIOProperty :: Testable prop => IO prop -> Property
ioProperty :: Testable prop => IO prop -> Property
mapSize :: Testable prop => (Int -> Int) -> prop -> Property
noShrinking :: Testable prop => prop -> Property
once :: Testable prop => prop -> Property
printTestCase :: Testable prop => String -> prop -> Property
shrinking :: Testable prop => (a -> [a]) -> a -> (a -> prop) -> Property
stdConfidence :: Confidence
tabulate :: Testable prop => String -> [String] -> prop -> Property
total :: NFData a => a -> Property
verboseShrinking :: Testable prop => prop -> Property
whenFail :: Testable prop => IO () -> prop -> Property
whenFail' :: Testable prop => IO () -> prop -> Property
withDiscardRatio :: Testable prop => Int -> prop -> Property
withMaxShrinks :: Testable prop => Int -> prop -> Property
withMaxSize :: Testable prop => Int -> prop -> Property
withMaxSuccess :: Testable prop => Int -> prop -> Property
within :: Testable prop => Int -> prop -> Property
witness :: (Typeable a, Show a, Testable prop) => a -> prop -> Property
isSuccess :: Result -> Bool
recheck :: Testable prop => Result -> prop -> IO ()
newtype QC
QC :: Property -> QC

-- | Convert tasty options into QuickCheck options.
--   
--   This is a low-level function that was originally added for tasty-hspec
--   but may be used by others.
--   
--   The returned Int is kept only for backward compatibility purposes. It
--   has no use in <tt>tasty-quickcheck</tt>.
optionSetToArgs :: OptionSet -> IO (Int, Args)
instance GHC.Real.Integral Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Enum.Enum Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Real.Real Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Classes.Eq Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Classes.Ord Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Num.Num Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Real.Integral Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Enum.Enum Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Real.Real Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Classes.Eq Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Classes.Ord Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Num.Num Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Real.Integral Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Enum.Enum Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Real.Real Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Classes.Eq Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Classes.Ord Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Num.Num Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Real.Integral Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Enum.Enum Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Real.Real Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Classes.Eq Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Classes.Ord Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Num.Num Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Classes.Ord Test.Tasty.QuickCheck.QuickCheckTimeout
instance GHC.Classes.Eq Test.Tasty.QuickCheck.QuickCheckTimeout
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckTimeout
instance Test.Tasty.Core.IsTest Test.Tasty.QuickCheck.QC
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckVerbose
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckMaxSize
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckShowReplay
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckReplay
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckTests
