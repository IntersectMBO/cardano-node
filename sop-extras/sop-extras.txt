-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | This package provides some more constructs that are not present on the
--   <tt>sop-core</tt> package but built upon the same foundations.
@package sop-extras
@version 0.4.1.0

module Data.SOP.Functors
newtype Flip f x y
Flip :: f y x -> Flip f x y
[unFlip] :: Flip f x y -> f y x
data Product2 f g x y
Pair2 :: f x y -> g x y -> Product2 f g x y
snd2 :: Product2 f g x y -> g x y
instance (GHC.Show.Show (f x y), GHC.Show.Show (g x y)) => GHC.Show.Show (Data.SOP.Functors.Product2 f g x y)
instance GHC.Generics.Generic (Data.SOP.Functors.Product2 f g x y)
instance (GHC.Classes.Eq (f x y), GHC.Classes.Eq (g x y)) => GHC.Classes.Eq (Data.SOP.Functors.Product2 f g x y)
instance forall y1 x1 (f :: x1 -> y1 -> *) (x2 :: y1) (y2 :: x1). GHC.Show.Show (f y2 x2) => GHC.Show.Show (Data.SOP.Functors.Flip f x2 y2)
instance forall y1 x1 (f :: x1 -> y1 -> *) (x2 :: y1) (y2 :: x1). NoThunks.Class.NoThunks (f y2 x2) => NoThunks.Class.NoThunks (Data.SOP.Functors.Flip f x2 y2)
instance forall y1 x1 (f :: x1 -> y1 -> *) (x2 :: y1) (y2 :: x1). GHC.Generics.Generic (Data.SOP.Functors.Flip f x2 y2)
instance forall y1 x1 (f :: x1 -> y1 -> *) (x2 :: y1) (y2 :: x1). GHC.Classes.Eq (f y2 x2) => GHC.Classes.Eq (Data.SOP.Functors.Flip f x2 y2)

module Data.SOP.Index
newtype Index xs x
Index :: NS ((:~:) x) xs -> Index xs x
[getIndex] :: Index xs x -> NS ((:~:) x) xs
pattern IS :: () => xs ~ (x' ': xs') => Index xs' x -> Index xs x
pattern IZ :: () => xs ~ (x ': xs1) => Index xs x
dictIndexAll :: forall c xs x. All c xs => Proxy c -> Index xs x -> Dict c x
indices :: forall xs. SListI xs => NP (Index xs) xs
injectNS :: forall f x xs. All Top xs => Index xs x -> f x -> NS f xs
injectNS' :: forall f a b x xs. All Top xs => (Coercible a (f x), Coercible b (NS f xs)) => Proxy f -> Index xs x -> a -> b
projectNP :: All Top xs => Index xs x -> NP f xs -> f x
hcimap :: (HAp h, All c xs, Prod h ~ NP) => proxy c -> (forall a. c a => Index xs a -> f1 a -> f2 a) -> h f1 xs -> h f2 xs
hcizipWith :: (HAp h, All c xs, Prod h ~ NP) => proxy c -> (forall a. c a => Index xs a -> f1 a -> f2 a -> f3 a) -> NP f1 xs -> h f2 xs -> h f3 xs
hcizipWith3 :: (HAp h, All c xs, Prod h ~ NP) => proxy c -> (forall a. c a => Index xs a -> f1 a -> f2 a -> f3 a -> f4 a) -> NP f1 xs -> NP f2 xs -> h f3 xs -> h f4 xs
hcizipWith4 :: (HAp h, All c xs, Prod h ~ NP) => proxy c -> (forall a. c a => Index xs a -> f1 a -> f2 a -> f3 a -> f4 a -> f5 a) -> NP f1 xs -> NP f2 xs -> NP f3 xs -> h f4 xs -> h f5 xs
himap :: (HAp h, SListI xs, Prod h ~ NP) => (forall a. Index xs a -> f1 a -> f2 a) -> h f1 xs -> h f2 xs
hizipWith :: (HAp h, SListI xs, Prod h ~ NP) => (forall a. Index xs a -> f1 a -> f2 a -> f3 a) -> NP f1 xs -> h f2 xs -> h f3 xs
hizipWith3 :: (HAp h, SListI xs, Prod h ~ NP) => (forall a. Index xs a -> f1 a -> f2 a -> f3 a -> f4 a) -> NP f1 xs -> NP f2 xs -> h f3 xs -> h f4 xs
hizipWith4 :: (HAp h, SListI xs, Prod h ~ NP) => (forall a. Index xs a -> f1 a -> f2 a -> f3 a -> f4 a -> f5 a) -> NP f1 xs -> NP f2 xs -> NP f3 xs -> h f4 xs -> h f5 xs

-- | We only allow up to 23 (so counting from 0, 24 elements in
--   <tt>xs</tt>), because CBOR stores a <a>Word8</a> in the range 0-23 as
--   a single byte equal to the value of the <a>Word8</a>.
npWithIndices :: SListI xs => NP (K Word8) xs

-- | We only allow up to 23, see <a>npWithIndices</a>.
nsFromIndex :: SListI xs => Word8 -> Maybe (NS (K ()) xs)
nsToIndex :: SListI xs => NS f xs -> Word8
toWord8 :: Index xs x -> Word8

module Data.SOP.Lenses

-- | Simple lens to access an element of an n-ary product.
data Lens f xs a
Lens :: (NP f xs -> f a) -> (f a -> NP f xs -> NP f xs) -> Lens f xs a
[getter] :: Lens f xs a -> NP f xs -> f a
[setter] :: Lens f xs a -> f a -> NP f xs -> NP f xs

-- | Generate all lenses to access the element of an n-ary product.
lenses_NP :: SListI xs => NP (Lens f xs) xs


-- | Type-level non-empty lists
module Data.SOP.NonEmpty

-- | Non-empty variation on <tt>AtMost</tt>
data NonEmpty xs a
[NonEmptyOne] :: !a -> NonEmpty (x ': xs) a
[NonEmptyCons] :: !a -> !NonEmpty xs a -> NonEmpty (x ': xs) a
class IsNonEmpty xs
isNonEmpty :: IsNonEmpty xs => proxy xs -> ProofNonEmpty xs
data ProofNonEmpty xs
[ProofNonEmpty] :: Proxy x -> Proxy xs -> ProofNonEmpty (x ': xs)
checkIsNonEmpty :: forall xs. SListI xs => Proxy xs -> Maybe (ProofNonEmpty xs)

-- | Build a <a>NonEmpty</a> from a list. Returns <a>Nothing</a> when the
--   list is empty or when it's longer than <tt>xs</tt>.
nonEmptyFromList :: forall xs a. SListI xs => [a] -> Maybe (NonEmpty xs a)

-- | Analogue of <a>head</a>
nonEmptyHead :: NonEmpty xs a -> a

-- | Analogue of <a>init</a>
nonEmptyInit :: NonEmpty xs a -> (Maybe (NonEmpty xs a), a)

-- | Analogue of <a>last</a>
nonEmptyLast :: NonEmpty xs a -> a

-- | Apply the specified function to exactly one element
nonEmptyMapOne :: forall m xs a. Alternative m => (a -> m a) -> NonEmpty xs a -> m (NonEmpty xs a)

-- | Variation on <a>nonEmptyMapOne</a> where we try to apply the function
--   to <i>pairs</i> of elements
nonEmptyMapTwo :: forall m xs a. Alternative m => (a -> m a) -> (a -> a -> m (a, a)) -> NonEmpty xs a -> m (NonEmpty xs a)

-- | A strict prefixes
--   
--   <pre>
--      nonEmptyStrictPrefixes (fromJust (nonEmptyFromList [1..4]))
--   == [ NonEmptyOne  1
--      , NonEmptyCons 1 $ NonEmptyOne  2
--      , NonEmptyCons 1 $ NonEmptyCons 2 $ NonEmptyOne 3
--      ]
--   </pre>
nonEmptyStrictPrefixes :: NonEmpty xs a -> [NonEmpty xs a]

-- | Convert a <a>NonEmpty</a> to a list.
nonEmptyToList :: forall xs a. NonEmpty xs a -> [a]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.SOP.NonEmpty.NonEmpty xs a)
instance GHC.Show.Show a => GHC.Show.Show (Data.SOP.NonEmpty.NonEmpty xs a)
instance GHC.Base.Functor (Data.SOP.NonEmpty.NonEmpty xs)
instance Data.Foldable.Foldable (Data.SOP.NonEmpty.NonEmpty xs)
instance Data.Traversable.Traversable (Data.SOP.NonEmpty.NonEmpty xs)
instance (Data.SOP.NonEmpty.IsNonEmpty xs, Data.SOP.Constraint.SListI xs) => GHC.Base.Applicative (Data.SOP.NonEmpty.NonEmpty xs)
instance forall a (x :: a) (xs :: [a]). Data.SOP.NonEmpty.IsNonEmpty (x : xs)


-- | Intended for qualified import
--   
--   <pre>
--   import           Data.SOP.InPairs (InPairs(..))
--   import qualified Data.SOP.InPairs as InPairs
--   </pre>
module Data.SOP.InPairs

-- | We have an <tt>f x y</tt> for each pair <tt>(x, y)</tt> of successive
--   list elements
data InPairs f xs
[PNil] :: InPairs f '[x]
[PCons] :: f x y -> InPairs f (y ': zs) -> InPairs f (x ': (y ': zs))
mk1 :: InPairs f '[x]
mk2 :: f x y -> InPairs f '[x, y]
mk3 :: f x y -> f y z -> InPairs f '[x, y, z]
hcmap :: forall proxy c f g xs. All c xs => proxy c -> (forall x y. (c x, c y) => f x y -> g x y) -> InPairs f xs -> InPairs g xs
hcpure :: forall proxy c xs f. (All c xs, IsNonEmpty xs) => proxy c -> (forall x y. (c x, c y) => f x y) -> InPairs f xs
hczipWith :: forall proxy c f f' f'' xs. All c xs => proxy c -> (forall x y. (c x, c y) => f x y -> f' x y -> f'' x y) -> InPairs f xs -> InPairs f' xs -> InPairs f'' xs
hmap :: SListI xs => (forall x y. f x y -> g x y) -> InPairs f xs -> InPairs g xs
hpure :: (SListI xs, IsNonEmpty xs) => (forall x y. f x y) -> InPairs f xs
newtype Requiring h f x y
Require :: (h x -> f x y) -> Requiring h f x y
[provide] :: Requiring h f x y -> h x -> f x y
newtype RequiringBoth h f x y
RequireBoth :: (h x -> h y -> f x y) -> RequiringBoth h f x y
[provideBoth] :: RequiringBoth h f x y -> h x -> h y -> f x y
ignoring :: f x y -> Requiring h f x y
ignoringBoth :: f x y -> RequiringBoth h f x y
requiring :: SListI xs => NP h xs -> InPairs (Requiring h f) xs -> InPairs f xs
requiringBoth :: NP h xs -> InPairs (RequiringBoth h f) xs -> InPairs f xs
newtype Fn2 f x y
Fn2 :: (f x -> f y) -> Fn2 f x y
[apFn2] :: Fn2 f x y -> f x -> f y
composeFromTo :: Index xs x -> Index xs y -> InPairs (Fn2 f) xs -> f x -> Maybe (f y)


-- | Type-level counting
--   
--   Intended for unqualified import.
module Data.SOP.Counting

-- | At most one value for each type level index
data AtMost xs a
[AtMostNil] :: AtMost xs a
[AtMostCons] :: !a -> !AtMost xs a -> AtMost (x ': xs) a
newtype Exactly xs a
Exactly :: NP (K a) xs -> Exactly xs a
[getExactly] :: Exactly xs a -> NP (K a) xs
pattern ExactlyNil :: () => xs ~ '[] => Exactly xs a
pattern ExactlyCons :: () => xs' ~ (x ': xs) => a -> Exactly xs a -> Exactly xs' a

-- | Analogue of <a>head</a>
exactlyHead :: Exactly (x ': xs) a -> a

-- | Singleton
exactlyOne :: a -> Exactly '[x] a

-- | Analogue of <a>replicate</a>
--   
--   In CPS style because the <tt>xs</tt> type parameter is not statically
--   known.
exactlyReplicate :: forall a r. Word -> a -> (forall xs. Exactly xs a -> r) -> r

-- | Analogue of <a>tail</a>
exactlyTail :: Exactly (x ': xs) a -> Exactly xs a

-- | From a pair
exactlyTwo :: a -> a -> Exactly '[x, y] a
exactlyWeaken :: Exactly xs a -> AtMost xs a
exactlyWeakenNonEmpty :: Exactly (x ': xs) a -> NonEmpty (x ': xs) a

-- | Analogue of <a>zip</a>
exactlyZip :: Exactly xs a -> Exactly xs b -> Exactly xs (a, b)

-- | Analogue of <a>zip</a> where the length of second argument is unknown
exactlyZipFoldable :: Foldable t => Exactly xs a -> t b -> AtMost xs (a, b)
atMostFromNonEmpty :: NonEmpty xs a -> AtMost xs a

-- | Analogue of <a>head</a>
atMostHead :: AtMost xs a -> Maybe a

-- | Analogue of <a>init</a>
--   
--   For simplicity we don't shrink the type-level index.
atMostInit :: AtMost xs a -> Maybe (AtMost xs a, a)

-- | Analogue of <a>last</a>
atMostLast :: AtMost xs a -> Maybe a
atMostNonEmpty :: AtMost (x ': xs) a -> Maybe (NonEmpty (x ': xs) a)

-- | Singleton
atMostOne :: a -> AtMost (x ': xs) a
atMostZipFoldable :: Foldable t => AtMost xs a -> t b -> AtMost xs (a, b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.SOP.Counting.AtMost xs a)
instance GHC.Show.Show a => GHC.Show.Show (Data.SOP.Counting.AtMost xs a)
instance GHC.Base.Functor (Data.SOP.Counting.AtMost xs)
instance Data.Foldable.Foldable (Data.SOP.Counting.AtMost xs)
instance Data.Traversable.Traversable (Data.SOP.Counting.AtMost xs)
instance GHC.Base.Functor (Data.SOP.Counting.Exactly xs)
instance Data.Foldable.Foldable (Data.SOP.Counting.Exactly xs)
instance Data.Traversable.Traversable (Data.SOP.Counting.Exactly xs)
instance GHC.Show.Show a => GHC.Show.Show (Data.SOP.Counting.Exactly xs a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.SOP.Counting.Exactly xs a)


-- | NP with optional values
--   
--   Intended for qualified import
--   
--   <pre>
--   import           Data.SOP.OptNP (OptNP (..), ViewOptNP (..))
--   import qualified Data.SOP.OptNP as OptNP
--   </pre>
module Data.SOP.OptNP
type NonEmptyOptNP = OptNP 'False

-- | Like an <a>NP</a>, but with optional values
data OptNP empty f xs
[OptNil] :: OptNP 'True f '[]
[OptCons] :: !f x -> !OptNP empty f xs -> OptNP 'False f (x ': xs)
[OptSkip] :: !OptNP empty f xs -> OptNP empty f (x ': xs)
at :: SListI xs => f x -> Index xs x -> NonEmptyOptNP f xs
empty :: forall f xs. SListI xs => OptNP 'True f xs
fromNP :: (forall empty. OptNP empty f xs -> r) -> NP f xs -> r
fromNonEmptyNP :: forall f xs. IsNonEmpty xs => NP f xs -> NonEmptyOptNP f xs

-- | If <a>OptNP</a> is not empty, it must contain at least one value
fromSingleton :: NonEmptyOptNP f '[x] -> f x
singleton :: f x -> NonEmptyOptNP f '[x]
toNP :: OptNP empty f xs -> NP (Maybe :.: f) xs
data ViewOptNP f xs
[OptNP_ExactlyOne] :: f x -> ViewOptNP f '[x]
[OptNP_AtLeastTwo] :: ViewOptNP f (x ': (y ': zs))
view :: forall f xs. NonEmptyOptNP f xs -> ViewOptNP f xs

-- | Precondition: there is no overlap between the two given lists: if
--   there is a <a>Just</a> at a given position in one, it must be
--   <a>Nothing</a> at the same position in the other.
combine :: forall (f :: Type -> Type) xs. (SListI xs, HasCallStack) => Maybe (NonEmptyOptNP f xs) -> Maybe (NonEmptyOptNP f xs) -> Maybe (NonEmptyOptNP f xs)
combineWith :: SListI xs => (forall a. These1 f g a -> h a) -> Maybe (NonEmptyOptNP f xs) -> Maybe (NonEmptyOptNP g xs) -> Maybe (NonEmptyOptNP h xs)
zipWith :: forall f g h xs. (forall a. These1 f g a -> h a) -> NonEmptyOptNP f xs -> NonEmptyOptNP g xs -> NonEmptyOptNP h xs
instance forall k (f :: k -> *) (xs :: [k]) (empty :: GHC.Types.Bool). Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Show.Show f) xs => GHC.Show.Show (Data.SOP.OptNP.OptNP empty f xs)
instance forall k (f :: k -> *) (xs :: [k]) (empty :: GHC.Types.Bool). Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq f) xs => GHC.Classes.Eq (Data.SOP.OptNP.OptNP empty f xs)
instance Data.SOP.Classes.HAp (Data.SOP.OptNP.OptNP empty)
instance Data.SOP.Classes.HTraverse_ (Data.SOP.OptNP.OptNP empty)
instance Data.SOP.Classes.HSequence (Data.SOP.OptNP.OptNP empty)
instance Data.SOP.Classes.HTrans (Data.SOP.OptNP.OptNP empty) (Data.SOP.OptNP.OptNP empty)


-- | Intended for qualified import
--   
--   <pre>
--   import           Data.SOP.Tails (Tails(..))
--   import qualified Data.SOP.Tails as Tails
--   </pre>
module Data.SOP.Tails

-- | For every tail <tt>(x ': xs)</tt> of the list, an <tt>f x y</tt> for
--   every <tt>y</tt> in <tt>xs</tt>
data Tails f xs
[TNil] :: Tails f '[]
[TCons] :: NP (f x) xs -> Tails f xs -> Tails f (x ': xs)
mk1 :: Tails f '[x]
mk2 :: f x y -> Tails f '[x, y]
mk3 :: f x y -> f x z -> f y z -> Tails f '[x, y, z]
extendWithTails :: SListI xs => Index xs x -> Index xs y -> Tails (Fn2 f) xs -> f x -> Maybe (f y)
hcmap :: forall proxy c f g xs. All c xs => proxy c -> (forall x y. (c x, c y) => f x y -> g x y) -> Tails f xs -> Tails g xs
hcpure :: forall proxy f c xs. All c xs => proxy c -> (forall x y. (c x, c y) => f x y) -> Tails f xs
hmap :: SListI xs => (forall x y. f x y -> g x y) -> Tails f xs -> Tails g xs
hpure :: SListI xs => (forall x y. f x y) -> Tails f xs
inPairsToTails :: forall f xs. All Top xs => InPairs (Fn2 f) xs -> Tails (Fn2 f) xs


-- | See <a>Telescope</a>
--   
--   Intended for qualified import
--   
--   <pre>
--   import           Data.SOP.Telescope (Telescope(..))
--   import qualified Data.SOP.Telescope as Telescope
--   </pre>
module Data.SOP.Telescope

-- | Telescope
--   
--   A telescope is an extension of an <a>NS</a>, where every time we "go
--   right" in the sum we have an additional value.
--   
--   The <a>Telescope</a> API mostly follows <tt>sop-core</tt> conventions,
--   supporting functor (<a>hmap</a>, <a>hcmap</a>), applicative
--   (<a>hap</a>, <a>hpure</a>), foldable (<a>hcollapse</a>) and
--   traversable (<a>hsequence'</a>). However, since <a>Telescope</a> is a
--   bi-functor, it cannot reuse the <tt>sop-core</tt> classes. The naming
--   scheme of the functions is adopted from <tt>sop-core</tt> though; for
--   example:
--   
--   <pre>
--   bi h (c) zipWith
--   |  |  |    |
--   |  |  |    \ zipWith: the name from base
--   |  |  |
--   |  |  \ constrained: version of the function with a constraint parameter
--   |  |
--   |  \ higher order: 'Telescope' (like 'NS'/'NP') is a /higher order/ functor
--   |
--   \ bifunctor: 'Telescope' (unlike 'NS'/'NP') is a higher order /bifunctor/
--   </pre>
--   
--   In addition to the standard SOP operators, the new operators that make
--   a <a>Telescope</a> a telescope are <a>extend</a>, <a>retract</a> and
--   <a>align</a>; see their documentation for details.
data Telescope g f xs
[TZ] :: !f x -> Telescope g f (x ': xs)
[TS] :: !g x -> !Telescope g f xs -> Telescope g f (x ': xs)

-- | Specialization of <a>hsequence'</a> with weaker constraints
--   (<a>Functor</a> rather than <a>Applicative</a>)
sequence :: forall m g f xs. Functor m => Telescope g (m :.: f) xs -> m (Telescope g f xs)
fromTZ :: Telescope g f '[x] -> f x
fromTip :: NS f xs -> Telescope (K ()) f xs
tip :: Telescope g f xs -> NS f xs
toAtMost :: Telescope (K a) (K (Maybe a)) xs -> AtMost xs a

-- | Bifunctor analogue of <a>hap</a>
bihap :: NP (g -.-> g') xs -> NP (f -.-> f') xs -> Telescope g f xs -> Telescope g' f' xs

-- | Bifunctor equivalent of <a>hczipWith</a>
bihczipWith :: All c xs => proxy c -> (forall x. c x => h x -> g x -> g' x) -> (forall x. c x => h x -> f x -> f' x) -> NP h xs -> Telescope g f xs -> Telescope g' f' xs

-- | Bifunctor analogue of <a>hmap</a>
bihmap :: SListI xs => (forall x. g x -> g' x) -> (forall x. f x -> f' x) -> Telescope g f xs -> Telescope g' f' xs

-- | Bifunctor equivalent of <a>hzipWith</a>
bihzipWith :: SListI xs => (forall x. h x -> g x -> g' x) -> (forall x. h x -> f x -> f' x) -> NP h xs -> Telescope g f xs -> Telescope g' f' xs
newtype Extend m g f x y
Extend :: (f x -> m (g x, f y)) -> Extend m g f x y
[extendWith] :: Extend m g f x y -> f x -> m (g x, f y)
newtype Retract m g f x y
Retract :: (g x -> f y -> m (f x)) -> Retract m g f x y
[retractWith] :: Retract m g f x y -> g x -> f y -> m (f x)

-- | Align a telescope with another, then apply a function to the tips
--   
--   Aligning is a combination of extension and retraction, extending or
--   retracting the telescope as required to match up with the other
--   telescope.
align :: forall m g' g f' f f'' xs. Monad m => InPairs (Requiring g' (Extend m g f)) xs -> Tails (Requiring f' (Retract m g f)) xs -> NP (f' -.-> (f -.-> f'')) xs -> Telescope g' f' xs -> Telescope g f xs -> m (Telescope g f'' xs)

-- | Extend the telescope
--   
--   We will not attempt to extend the telescope past its final segment.
extend :: forall m h g f xs. Monad m => InPairs (Requiring h (Extend m g f)) xs -> NP (f -.-> (Maybe :.: h)) xs -> Telescope g f xs -> m (Telescope g f xs)

-- | Retract a telescope
retract :: forall m h g f xs. Monad m => Tails (Requiring h (Retract m g f)) xs -> NP (g -.-> (Maybe :.: h)) xs -> Telescope g f xs -> m (Telescope g f xs)

-- | Version of <a>align</a> that never retracts, only extends
--   
--   PRE: The telescope we are aligning with cannot be behind us.
alignExtend :: (Monad m, HasCallStack) => InPairs (Requiring g' (Extend m g f)) xs -> NP (f' -.-> (f -.-> f'')) xs -> Telescope g' f' xs -> Telescope g f xs -> m (Telescope g f'' xs)

-- | Version of <a>alignExtend</a> that extends with an NS instead
alignExtendNS :: (Monad m, HasCallStack) => InPairs (Extend m g f) xs -> NP (f' -.-> (f -.-> f'')) xs -> NS f' xs -> Telescope g f xs -> m (Telescope g f'' xs)

-- | Version of <a>extend</a> where the evidence is a simple <a>Bool</a>
extendIf :: Monad m => InPairs (Extend m g f) xs -> NP (f -.-> K Bool) xs -> Telescope g f xs -> m (Telescope g f xs)

-- | Version of <a>retract</a> where the evidence is a simple <a>Bool</a>
retractIf :: Monad m => Tails (Retract m g f) xs -> NP (g -.-> K Bool) xs -> Telescope g f xs -> m (Telescope g f xs)
newtype ScanNext h g x y
ScanNext :: (h x -> g x -> h y) -> ScanNext h g x y
[getNext] :: ScanNext h g x y -> h x -> g x -> h y

-- | <a>Telescope</a> with both functors set to the same <tt>f</tt>
newtype SimpleTelescope f xs
SimpleTelescope :: Telescope f f xs -> SimpleTelescope f xs
[getSimpleTelescope] :: SimpleTelescope f xs -> Telescope f f xs

-- | Telescope analogue of <a>scanl</a> on lists
--   
--   This function is modelled on
--   
--   <pre>
--   scanl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]
--   </pre>
--   
--   but there are a few differences:
--   
--   <ul>
--   <li>Since every seed has a different type, we must be given a function
--   for each transition.</li>
--   <li>Unlike <a>scanl</a>, we preserve the length of the telescope
--   (<a>scanl</a> prepends the initial seed)</li>
--   <li>Instead of generating a telescope containing only the seeds, we
--   instead pair the seeds with the elements.</li>
--   </ul>
scanl :: InPairs (ScanNext h g) (x ': xs) -> h x -> Telescope g f (x ': xs) -> Telescope (Product h g) (Product h f) (x ': xs)
instance forall k (g :: k -> *) (xs :: [k]) (f :: k -> *). (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq g) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq f) xs) => GHC.Classes.Eq (Data.SOP.Telescope.Telescope g f xs)
instance forall k (g :: k -> *) (xs :: [k]) (f :: k -> *). (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq g) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Ord g) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq f) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Ord f) xs) => GHC.Classes.Ord (Data.SOP.Telescope.Telescope g f xs)
instance forall k (g :: k -> *) (xs :: [k]) (f :: k -> *). (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Show.Show g) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Show.Show f) xs) => GHC.Show.Show (Data.SOP.Telescope.Telescope g f xs)
instance Data.SOP.Classes.HAp Data.SOP.Telescope.SimpleTelescope
instance Data.SOP.Classes.HTraverse_ Data.SOP.Telescope.SimpleTelescope
instance Data.SOP.Classes.HSequence Data.SOP.Telescope.SimpleTelescope
instance Data.SOP.Classes.HCollapse Data.SOP.Telescope.SimpleTelescope
instance forall k (g :: k -> *). Data.SOP.Classes.HAp (Data.SOP.Telescope.Telescope g)
instance forall k (g :: k -> *). Data.SOP.Classes.HTraverse_ (Data.SOP.Telescope.Telescope g)
instance forall k (g :: k -> *). Data.SOP.Classes.HSequence (Data.SOP.Telescope.Telescope g)
instance forall k2 (g :: k2 -> *). (forall (x :: k2) (y :: k2). Data.SOP.Constraint.LiftedCoercible g g x y) => Data.SOP.Classes.HTrans (Data.SOP.Telescope.Telescope g) (Data.SOP.Telescope.Telescope g)
instance forall k (g :: k -> *) (xs :: [k]) (f :: k -> *). (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose NoThunks.Class.NoThunks g) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose NoThunks.Class.NoThunks f) xs) => NoThunks.Class.NoThunks (Data.SOP.Telescope.Telescope g f xs)


-- | Intended for qualified import
--   
--   <pre>
--   import           Data.SOP.Match (Mismatch(..))
--   import qualified Data.SOP.Match as Match
--   </pre>
module Data.SOP.Match

-- | We have a mismatch in the index between two NS
data Mismatch f g xs

-- | The left is at the current <tt>x</tt> and the right is somewhere in
--   the later <tt>xs</tt>
[ML] :: f x -> NS g xs -> Mismatch f g (x ': xs)

-- | The right is at the current <tt>x</tt> and the left is somewhere in
--   the later <tt>xs</tt>
[MR] :: NS f xs -> g x -> Mismatch f g (x ': xs)

-- | There is a mismatch later on in the <tt>xs</tt>
[MS] :: Mismatch f g xs -> Mismatch f g (x ': xs)
flipMatch :: Mismatch f g xs -> Mismatch g f xs
matchNS :: NS f xs -> NS g xs -> Either (Mismatch f g xs) (NS (Product f g) xs)
matchTelescope :: NS h xs -> Telescope g f xs -> Either (Mismatch h f xs) (Telescope g (Product h f) xs)
telescopesMismatch :: Telescope a b xs -> Telescope g f xs -> Maybe (Mismatch b f xs)
mismatchNotEmpty :: Mismatch f g xs -> (forall x xs'. xs ~ (x ': xs') => Mismatch f g (x ': xs') -> a) -> a
mismatchNotFirst :: Mismatch f g (x ': xs) -> Either (NS f xs) (NS g xs)

-- | We cannot give a mismatch if we have only one type variable
mismatchOne :: Mismatch f g '[x] -> Void

-- | Project two <a>NS</a> from a <a>Mismatch</a>
--   
--   We should have the property that
--   
--   <pre>
--   uncurry matchNS (mismatchToNS m) == Left m
--   </pre>
mismatchToNS :: Mismatch f g xs -> (NS f xs, NS g xs)

-- | If we only have two eras, only two possibilities for a mismatch
mismatchTwo :: Mismatch f g '[x, y] -> Either (f x, g y) (f y, g x)
mkMismatchTwo :: Either (f x, g y) (f y, g x) -> Mismatch f g '[x, y]

-- | Variant of <a>matchNS</a> for when we know the two <a>NS</a>s must
--   match. Otherwise an error, mentioning the given <a>String</a>, is
--   thrown.
mustMatchNS :: forall f g xs. HasCallStack => String -> NS f xs -> NS g xs -> NS (Product f g) xs
bihap :: NP (f -.-> f') xs -> NP (g -.-> g') xs -> Mismatch f g xs -> Mismatch f' g' xs

-- | Bifunctor analogue of <a>hcmap</a>
bihcmap :: All c xs => proxy c -> (forall x. c x => f x -> f' x) -> (forall x. c x => g x -> g' x) -> Mismatch f g xs -> Mismatch f' g' xs
bihmap :: SListI xs => (forall x. f x -> f' x) -> (forall x. g x -> g' x) -> Mismatch f g xs -> Mismatch f' g' xs
instance forall k (f :: k -> *) (xs :: [k]) (g :: k -> *). (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq f) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq g) xs) => GHC.Classes.Eq (Data.SOP.Match.Mismatch f g xs)
instance forall k (f :: k -> *) (xs :: [k]) (g :: k -> *). (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq f) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Ord f) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq g) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Ord g) xs) => GHC.Classes.Ord (Data.SOP.Match.Mismatch f g xs)
instance forall k (f :: k -> *) (xs :: [k]) (g :: k -> *). (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Show.Show f) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Show.Show g) xs) => GHC.Show.Show (Data.SOP.Match.Mismatch f g xs)
instance forall k (f :: k -> *). Data.SOP.Classes.HAp (Data.SOP.Match.Mismatch f)
instance forall k2 (p :: k2 -> *). (forall (x :: k2) (y :: k2). Data.SOP.Constraint.LiftedCoercible p p x y) => Data.SOP.Classes.HTrans (Data.SOP.Match.Mismatch p) (Data.SOP.Match.Mismatch p)
instance forall k (f :: k -> *) (xs :: [k]) (g :: k -> *). (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose NoThunks.Class.NoThunks f) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose NoThunks.Class.NoThunks g) xs) => NoThunks.Class.NoThunks (Data.SOP.Match.Mismatch f g xs)
