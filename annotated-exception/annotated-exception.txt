-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on Github at
--   <a>https://github.com/parsonsmatt/annotated-exception#readme</a>
@package annotated-exception
@version 0.3.0.4


-- | An <a>Annotation</a> is attached to an <a>AnnotatedException</a>.
--   They're essentially a dynamically typed value with a convenient
--   <a>IsString</a> instance.
--   
--   When integrating into your own application, you will likely want to do
--   more than just have the <a>String</a> you get from <a>show</a>ing the
--   <a>Annotation</a>. You can do this by creating a special wrapper type
--   that carries a class constraint. This allows you to also pluck out the
--   <a>Annotation</a>s from your library or executable independently and
--   treat them differently from unknonwn annotations.
--   
--   As an example, here's one that requires a <a>ToJSON</a> constraint on
--   the underlying value. This means that you can convert any annotated
--   value to JSON, and then use that JSON in bug reports or logging.
--   
--   <pre>
--   data JsonAnnotation where
--     JsonAnnotation :: (ToJSON a, Typeable a) =&gt; a -&gt; JsonAnnotation
--   
--   instance Show JsonANnotation where
--     show (JsonAnnotation a) = concat
--        [ "(JsonAnnotation ("
--        , show (toJSON a)
--        , "))"
--        ]
--   
--   jsonCheckpoint :: (Typeable a, ToJSON a, <a>HasCallStack</a>, MonadCatch m) =&gt; a -&gt; m a -&gt; m a
--   jsonCheckpoint val = <a>withFrozenCallStack</a> checkpoint (JsonAnnotation val)
--   </pre>
--   
--   When handling the <tt>[<a>Annotation</a>]</tt> carried on the
--   <a>AnnotatedException</a>, you can use <a>tryAnnotations</a> to pick
--   out the JSON annotations.
--   
--   <pre>
--   jsonAnnotations :: [Annotation] -&gt; ([JsonAnnotation], [Annotation])
--   jsonAnnotations = tryAnnotations
--   </pre>
--   
--   and handle them however you please.
module Data.Annotation

-- | An <a>Annotation</a> is a wrapper around a value that includes a
--   <a>Typeable</a> constraint so we can later unpack it. It is
--   essentially a <a>Dynamic</a>, but we also include <a>Show</a> so that
--   you can always fall back to simply <a>show</a>ing the
--   <a>Annotation</a> if it is otherwise unrecognized.
data Annotation
[Annotation] :: AnnC a => a -> Annotation

-- | A wrapper type for putting a <a>CallStack</a> into an
--   <a>Annotation</a>. We need this because <a>CallStack</a> does not have
--   an <a>Eq</a> instance.
--   
--   Deprecated in 0.2.0.0 since you can just put a <a>CallStack</a>
--   directly in an <a>Annotation</a> now that we have no need for an
--   <a>Eq</a> constraint on it.

-- | <i>Deprecated: You can just use <a>CallStack</a> directly now.</i>
newtype CallStackAnnotation

-- | <i>Deprecated: You can just use <a>CallStack</a> directly now.</i>
CallStackAnnotation :: [(String, SrcLoc)] -> CallStackAnnotation
[unCallStackAnnotation] :: CallStackAnnotation -> [(String, SrcLoc)]

-- | The constraints that the value inside an <a>Annotation</a> must have.
--   
--   We want <a>Typeable</a> so we can do <a>cast</a> and potentially get
--   more useful information out of it.
type AnnC a = (Typeable a, Show a)

-- | Wrap a value in an <a>Annotation</a>.
toAnnotation :: AnnC a => a -> Annotation

-- | Attempt to <a>cast</a> the underlying value out of an
--   <a>Annotation</a>.
castAnnotation :: forall a. Typeable a => Annotation -> Maybe a

-- | Attempt to <a>cast</a> the underlying value out of an
--   <a>Annotation</a>. Returns the original <a>Annotation</a> if the cast
--   isn't right.
tryAnnotation :: forall a. Typeable a => Annotation -> Either a Annotation

-- | Attempt to <a>cast</a> list of <a>Annotation</a> into the given type.
--   Any <a>Annotation</a> that is not in that form is left untouched.
tryAnnotations :: forall a. Typeable a => [Annotation] -> ([a], [Annotation])

-- | Returns the <a>Set</a> of types that are in the given annotations.
annotationTypes :: [Annotation] -> Set TypeRep

-- | Map a function over the given <a>Annotation</a>. If the types don't
--   match up, then the whole thing returns <a>Nothing</a>.
mapAnnotation :: (AnnC a, AnnC b) => (a -> b) -> Annotation -> Maybe Annotation

-- | Map a function over the <a>Annotation</a>, leaving it unchanged if the
--   types don't match.
mapMaybeAnnotation :: (AnnC a, AnnC b) => (a -> b) -> Annotation -> Annotation

-- | Grab an <a>Annotation</a> corresponding to the <a>CallStack</a> that
--   is currently in scope.
callStackAnnotation :: HasCallStack => Annotation

-- | Stuff a <a>CallStack</a> into an <a>Annotation</a> via the
--   <a>CallStackAnnotation</a> newtype wrapper.
callStackToAnnotation :: CallStack -> Annotation

-- | Convert the legacy <a>CallStackAnnotation</a> into a <a>CallStack</a>.
--   
--   Deprecated in 0.2.0.0 since you can use <a>CallStack</a> directly.

-- | <i>Deprecated: You can use <a>CallStack</a> directly in annotations as
--   of 0.2.0.0.</i>
callStackFromAnnotation :: CallStackAnnotation -> CallStack

-- | Extract the <a>CallStack</a>s from the <tt>[<a>Annotation</a>]</tt>.
--   Any <a>Annotation</a> not corresponding to a <a>CallStack</a> will be
--   in the second element of the tuple.

-- | <i>Deprecated: You can just use <a>tryAnnotations</a> directly as of
--   0.2.0.0.</i>
callStackInAnnotations :: [Annotation] -> ([CallStack], [Annotation])
instance GHC.Show.Show Data.Annotation.CallStackAnnotation
instance GHC.Classes.Eq Data.Annotation.CallStackAnnotation
instance GHC.Show.Show Data.Annotation.Annotation
instance Data.String.IsString Data.Annotation.Annotation


-- | This module defines an exception wrapper <a>AnnotatedException</a>
--   that carries a list of <a>Annotation</a>s, along with some helper
--   methods for throwing and catching that can make the annotations
--   transparent.
--   
--   While this library can be used directly, it is recommended that you
--   define your own types and functions specific to your domain. As an
--   example, <a>checkpoint</a> is useful *only* for providing exception
--   annotation information. However, you probably want to use
--   <a>checkpoint</a> in concert with other context adding features, like
--   logging.
--   
--   Likewise, the <a>Annotation</a> type defined in <a>Data.Annotation</a>
--   is essentially a wrapper for a dynamically typed value. So you
--   probably want to define your own <a>checkpoint</a> that uses a custom
--   type that you want to enforce throughout your application.
module Control.Exception.Annotated

-- | The <a>AnnotatedException</a> type wraps an <tt>exception</tt> with a
--   <tt>[<a>Annotation</a>]</tt>. This can provide a sort of a manual
--   stack trace with programmer provided data.
data AnnotatedException exception
AnnotatedException :: [Annotation] -> exception -> AnnotatedException exception
[annotations] :: AnnotatedException exception -> [Annotation]
[exception] :: AnnotatedException exception -> exception

-- | Annotate the underlying exception with a <a>CallStack</a>.
exceptionWithCallStack :: (Exception e, HasCallStack) => e -> AnnotatedException e

-- | Throws an <a>Exception</a> and annotates it with the current
--   <a>CallStack</a>.
--   
--   An alias for <a>throwWithCallStack</a>.
throw :: (HasCallStack, MonadThrow m, Exception e) => e -> m a

-- | Attaches the <a>CallStack</a> to the <a>AnnotatedException</a> that is
--   thrown.
throwWithCallStack :: (HasCallStack, MonadThrow m, Exception e) => e -> m a

-- | Add a single <a>Annotation</a> to any exceptions thrown in the
--   following action. The <a>CallStack</a> present on any
--   <a>AnnotatedException</a> will also be updated to include this
--   location.
--   
--   Example:
--   
--   <pre>
--   main = do
--       checkpoint "Foo" $ do
--           print =&lt;&lt; readFile "I don't exist.markdown"
--   </pre>
--   
--   The exception thrown due to a missing file will now have an
--   <a>Annotation</a> <tt><a>Foo</a></tt>.
checkpoint :: (HasCallStack, MonadCatch m) => Annotation -> m a -> m a

-- | Add the list of <a>Annotation</a> to any exception thrown in the
--   following action.
checkpointMany :: (MonadCatch m, HasCallStack) => [Annotation] -> m a -> m a

-- | Adds only the current <a>CallStack</a> to the checkpoint. This
--   function searches any thrown exception for a pre-existing
--   <a>CallStack</a> and will merge the given pre-existing
--   <a>CallStack</a> with the one on this function, in an attempt to
--   preserve the actual call history.
checkpointCallStack :: (MonadCatch m, HasCallStack) => m a -> m a

-- | Add the current <a>CallStack</a> to the checkpoint, along with the
--   given annotations. This function merges <a>CallStack</a>s together,
--   attempting to preserve the call site ordering as GHC does it.
--   
--   As of 0.2.0.0, an alias for <a>checkpointMany</a>.

-- | <i>Deprecated: As of 0.2.0.0 this is exactly equivalent to
--   <a>checkpointMany</a>.</i>
checkpointCallStackWith :: (MonadCatch m, HasCallStack) => [Annotation] -> m a -> m a

-- | Catch an exception. This works just like <a>catch</a>, but it also
--   will attempt to catch <tt><a>AnnotatedException</a> e</tt>. The
--   annotations will be preserved in the handler, so rethrowing exceptions
--   will retain the context.
--   
--   Let's consider a few examples, that share this import and exception
--   type.
--   
--   <pre>
--   import qualified Control.Exception.Safe as Safe
--   import Control.Exception.Annotated
--   
--   data TestException deriving (Show, Exception)
--   </pre>
--   
--   We can throw an exception and catch it as usual.
--   
--   <pre>
--   throw TestException `catch` \TestException -&gt;
--       putStrLn "ok!"
--   </pre>
--   
--   We can throw an exception and catch it with annotations.
--   
--   <pre>
--   throw TestException `catch` \(AnnotatedException anns TestException) -&gt;
--       putStrLn "ok!"
--   </pre>
--   
--   We can throw an exception and catch it as a
--   <tt><a>AnnotatedException</a> <a>SomeException</a></tt>.
--   
--   <pre>
--   throw TestException `catch` \(AnnotatedException anns (e :: SomeException) -&gt;
--       putStrLn "ok!"
--   </pre>
catch :: (HasCallStack, Exception e, MonadCatch m) => m a -> (e -> m a) -> m a

-- | Like <a>catches</a>, but this function enhance the provided
--   <a>Handler</a>s to "see through" any <a>AnnotatedException</a>s.
catches :: (MonadCatch m, HasCallStack) => m a -> [Handler m a] -> m a

-- | Like <a>catch</a>, but always returns a <a>AnnotatedException</a>.
tryAnnotated :: (Exception e, MonadCatch m) => m a -> m (Either (AnnotatedException e) a)

-- | Like <a>try</a>, but can also handle an <a>AnnotatedException</a> or
--   the underlying value. Useful when you want to <a>try</a> to catch a
--   type of exception, but you may not care about the <a>Annotation</a>s
--   that it may or may not have.
--   
--   Example:
--   
--   <pre>
--   Left exn &lt;- try $ throw (AnnotatedException [] TestException)
--   exn == TestException
--   </pre>
--   
--   <pre>
--   Left exn &lt;- try $ throw TestException
--   exn == AnnotatedException [] TestException
--   </pre>
try :: (Exception e, MonadCatch m) => m a -> m (Either e a)

-- | Call <a>fromException</a> on the underlying <a>Exception</a>,
--   attaching the annotations to the result.
check :: Exception e => AnnotatedException SomeException -> Maybe (AnnotatedException e)

-- | Call <a>toException</a> on the underlying <a>Exception</a>.
hide :: Exception e => AnnotatedException e -> AnnotatedException SomeException

-- | Retrieves the <a>CallStack</a> from an <a>AnnotatedException</a> if
--   one is present.
--   
--   The library maintains an internal check that a single <a>CallStack</a>
--   is present in the list, so this only returns the first one found. If
--   you have added a <a>CallStack</a> directly to the
--   <tt>[<a>Annotation</a>]</tt>, then this will likely break.
annotatedExceptionCallStack :: AnnotatedException exception -> Maybe CallStack

-- | Adds a <a>CallStack</a> to the given <a>AnnotatedException</a>. This
--   function will search through the existing annotations, and it will not
--   add a second <a>CallStack</a> to the list. Instead, it will append the
--   contents of the given <a>CallStack</a> to the existing one.
--   
--   This mirrors the behavior of the way <a>HasCallStack</a> actually
--   works.
addCallStackToException :: CallStack -> AnnotatedException exception -> AnnotatedException exception

-- | An <a>Annotation</a> is a wrapper around a value that includes a
--   <a>Typeable</a> constraint so we can later unpack it. It is
--   essentially a <a>Dynamic</a>, but we also include <a>Show</a> so that
--   you can always fall back to simply <a>show</a>ing the
--   <a>Annotation</a> if it is otherwise unrecognized.
data Annotation
[Annotation] :: AnnC a => a -> Annotation

-- | A wrapper type for putting a <a>CallStack</a> into an
--   <a>Annotation</a>. We need this because <a>CallStack</a> does not have
--   an <a>Eq</a> instance.
--   
--   Deprecated in 0.2.0.0 since you can just put a <a>CallStack</a>
--   directly in an <a>Annotation</a> now that we have no need for an
--   <a>Eq</a> constraint on it.

-- | <i>Deprecated: You can just use <a>CallStack</a> directly now.</i>
newtype CallStackAnnotation

-- | <i>Deprecated: You can just use <a>CallStack</a> directly now.</i>
CallStackAnnotation :: [(String, SrcLoc)] -> CallStackAnnotation
[unCallStackAnnotation] :: CallStackAnnotation -> [(String, SrcLoc)]

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data () => SomeException
SomeException :: e -> SomeException

-- | Generalized version of <a>Handler</a>
data () => Handler (m :: Type -> Type) a
Handler :: (e -> m a) -> Handler (m :: Type -> Type) a
instance Data.Traversable.Traversable Control.Exception.Annotated.AnnotatedException
instance Data.Foldable.Foldable Control.Exception.Annotated.AnnotatedException
instance GHC.Base.Functor Control.Exception.Annotated.AnnotatedException
instance GHC.Exception.Type.Exception exception => GHC.Show.Show (Control.Exception.Annotated.AnnotatedException exception)
instance GHC.Base.Applicative Control.Exception.Annotated.AnnotatedException
instance GHC.Exception.Type.Exception exception => GHC.Exception.Type.Exception (Control.Exception.Annotated.AnnotatedException exception)


-- | This module presents the same interface as
--   <a>Control.Exception.Annotated</a>, but uses <a>MonadUnliftIO</a>
--   instead of <a>MonadCatch</a> or <a>MonadThrow</a>.
module Control.Exception.Annotated.UnliftIO

-- | The <a>AnnotatedException</a> type wraps an <tt>exception</tt> with a
--   <tt>[<a>Annotation</a>]</tt>. This can provide a sort of a manual
--   stack trace with programmer provided data.
data AnnotatedException exception
AnnotatedException :: [Annotation] -> exception -> AnnotatedException exception
[annotations] :: AnnotatedException exception -> [Annotation]
[exception] :: AnnotatedException exception -> exception

-- | Annotate the underlying exception with a <a>CallStack</a>.
exceptionWithCallStack :: (Exception e, HasCallStack) => e -> AnnotatedException e

-- | Like <a>throwWithCallStack</a>, but uses <a>MonadIO</a> instead of
--   <a>MonadThrow</a>.
throwWithCallStack :: forall e m a. (MonadIO m, Exception e, HasCallStack) => e -> m a

-- | Like <a>checkpoint</a>, but uses <a>MonadUnliftIO</a> instead of
--   <a>MonadCatch</a>.
checkpoint :: forall m a. (MonadUnliftIO m, HasCallStack) => Annotation -> m a -> m a

-- | Like <a>checkpointMany</a>, but uses <a>MonadUnliftIO</a> instead of
--   <a>MonadCatch</a>.
checkpointMany :: forall m a. (MonadUnliftIO m, HasCallStack) => [Annotation] -> m a -> m a

-- | Like <a>checkpointCallStack</a>, but uses <a>MonadUnliftIO</a> instead
--   of <a>MonadCatch</a>.
checkpointCallStack :: forall m a. (MonadUnliftIO m, HasCallStack) => m a -> m a

-- | Like <a>checkpointCallStackWith</a>, but uses <a>MonadUnliftIO</a>
--   instead of <a>MonadCatch</a>.
--   
--   Deprecated in 0.2.0.0 as it is now an alias for <a>checkpointMany</a>.

-- | <i>Deprecated: As of annotated-exception-0.2.0.0, this is an alias for
--   checkpointMany</i>
checkpointCallStackWith :: forall m a. (MonadUnliftIO m, HasCallStack) => [Annotation] -> m a -> m a

-- | Like <a>catch</a>, but uses <a>MonadUnliftIO</a> instead of
--   <a>MonadCatch</a>.
catch :: forall e m a. (MonadUnliftIO m, Exception e, HasCallStack) => m a -> (e -> m a) -> m a

-- | Like <a>catches</a>, bt uses <a>MonadUnliftIO</a> instead of
--   <a>MonadCatch</a>.
catches :: forall m a. (MonadUnliftIO m, HasCallStack) => m a -> [Handler m a] -> m a

-- | Like <a>tryAnnotated</a> but uses <a>MonadUnliftIO</a> instead of
--   <a>MonadCatch</a>.
tryAnnotated :: forall e m a. (MonadUnliftIO m, Exception e) => m a -> m (Either (AnnotatedException e) a)

-- | Like <a>try</a> but uses <a>MonadUnliftIO</a> instead of
--   <a>MonadCatch</a>.
try :: forall e m a. (MonadUnliftIO m, Exception e) => m a -> m (Either e a)

-- | Call <a>fromException</a> on the underlying <a>Exception</a>,
--   attaching the annotations to the result.
check :: Exception e => AnnotatedException SomeException -> Maybe (AnnotatedException e)

-- | Call <a>toException</a> on the underlying <a>Exception</a>.
hide :: Exception e => AnnotatedException e -> AnnotatedException SomeException

-- | Retrieves the <a>CallStack</a> from an <a>AnnotatedException</a> if
--   one is present.
--   
--   The library maintains an internal check that a single <a>CallStack</a>
--   is present in the list, so this only returns the first one found. If
--   you have added a <a>CallStack</a> directly to the
--   <tt>[<a>Annotation</a>]</tt>, then this will likely break.
annotatedExceptionCallStack :: AnnotatedException exception -> Maybe CallStack

-- | Adds a <a>CallStack</a> to the given <a>AnnotatedException</a>. This
--   function will search through the existing annotations, and it will not
--   add a second <a>CallStack</a> to the list. Instead, it will append the
--   contents of the given <a>CallStack</a> to the existing one.
--   
--   This mirrors the behavior of the way <a>HasCallStack</a> actually
--   works.
addCallStackToException :: CallStack -> AnnotatedException exception -> AnnotatedException exception

-- | An <a>Annotation</a> is a wrapper around a value that includes a
--   <a>Typeable</a> constraint so we can later unpack it. It is
--   essentially a <a>Dynamic</a>, but we also include <a>Show</a> so that
--   you can always fall back to simply <a>show</a>ing the
--   <a>Annotation</a> if it is otherwise unrecognized.
data Annotation
[Annotation] :: AnnC a => a -> Annotation

-- | A wrapper type for putting a <a>CallStack</a> into an
--   <a>Annotation</a>. We need this because <a>CallStack</a> does not have
--   an <a>Eq</a> instance.
--   
--   Deprecated in 0.2.0.0 since you can just put a <a>CallStack</a>
--   directly in an <a>Annotation</a> now that we have no need for an
--   <a>Eq</a> constraint on it.

-- | <i>Deprecated: You can just use <a>CallStack</a> directly now.</i>
newtype CallStackAnnotation

-- | <i>Deprecated: You can just use <a>CallStack</a> directly now.</i>
CallStackAnnotation :: [(String, SrcLoc)] -> CallStackAnnotation
[unCallStackAnnotation] :: CallStackAnnotation -> [(String, SrcLoc)]

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data () => SomeException
SomeException :: e -> SomeException

-- | Like <a>throw</a>, but uses <a>MonadIO</a> instead of
--   <a>MonadThrow</a>.
throw :: forall e m a. (MonadIO m, Exception e, HasCallStack) => e -> m a

-- | Generalized version of <a>Handler</a>
data () => Handler (m :: Type -> Type) a
Handler :: (e -> m a) -> Handler (m :: Type -> Type) a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
class MonadIO m => MonadUnliftIO (m :: Type -> Type)
withRunInIO :: MonadUnliftIO m => ((forall a. () => m a -> IO a) -> IO b) -> m b
