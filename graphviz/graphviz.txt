-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings to Graphviz for graph visualisation.
--   
--   This library provides bindings for the Dot language used by the
--   Graphviz (<a>http://graphviz.org/</a>) suite of programs for
--   visualising graphs, as well as functions to call those programs.
--   
--   Main features of the graphviz library include:
--   
--   <ul>
--   <li>Almost complete coverage of all Graphviz attributes and
--   syntax.</li>
--   <li>Support for specifying clusters.</li>
--   <li>The ability to use a custom node type.</li>
--   <li>Functions for running a Graphviz layout tool with all specified
--   output types.</li>
--   <li>The ability to not only generate but also parse Dot code with two
--   options: strict and liberal (in terms of ordering of statements).</li>
--   <li>Functions to convert FGL graphs and other graph-like data
--   structures to Dot code - including support to group them into clusters
--   - with a high degree of customisation by specifying which attributes
--   to use and limited support for the inverse operation.</li>
--   <li>Round-trip support for passing an FGL graph through Graphviz to
--   augment node and edge labels with positional information, etc.</li>
--   </ul>
@package graphviz
@version 2999.20.2.1


module Data.GraphViz.Exception

-- | Exceptions that arise from using this library fall into four
--   categories:
--   
--   <ul>
--   <li>Unable to parse provided Dot code.</li>
--   <li>Dot code is not valid UTF-8.</li>
--   <li>An error when trying to run an external program (e.g.
--   <tt>dot</tt>).</li>
--   <li>Treating a non-custom Attribute as a custom one.</li>
--   </ul>
data GraphvizException
NotDotCode :: String -> GraphvizException
NotUTF8Dot :: String -> GraphvizException
GVProgramExc :: String -> GraphvizException
NotCustomAttr :: String -> GraphvizException

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall (r :: RuntimeRep) (a :: TYPE r) e. Exception e => e -> a

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` ()  ===&gt; throw e
--   throwIO e `seq` ()  ===&gt; ()
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other operations, whereas
--   <a>throw</a> does not. We say that <a>throwIO</a> throws *precise*
--   exceptions and <a>throw</a>, <a>error</a>, etc. all throw *imprecise*
--   exceptions. For example
--   
--   <pre>
--   throw e + error "boom" ===&gt; error "boom"
--   throw e + error "boom" ===&gt; throw e
--   </pre>
--   
--   are both valid reductions and the compiler may pick any (loop, even),
--   whereas
--   
--   <pre>
--   throwIO e &gt;&gt; error "boom" ===&gt; throwIO e
--   </pre>
--   
--   will always throw <tt>e</tt> when executed.
--   
--   See also the <a>GHC wiki page on precise exceptions</a> for a more
--   technical introduction to how GHC optimises around precise vs.
--   imprecise exceptions.
throwIO :: Exception e => e -> IO a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: Exception e => (e -> IO a) -> IO a -> IO a

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
--   
--   Bracket wraps the release action with <a>mask</a>, which is sufficient
--   to ensure that the release action executes to completion when it does
--   not invoke any interruptible actions, even in the presence of
--   asynchronous exceptions. For example, <tt>hClose</tt> is
--   uninterruptible when it is not racing other uses of the handle.
--   Similarly, closing a socket (from "network" package) is also
--   uninterruptible under similar conditions. An example of an
--   interruptible action is <a>killThread</a>. Completion of interruptible
--   release actions can be ensured by wrapping them in in
--   <a>uninterruptibleMask_</a>, but this risks making the program
--   non-responsive to <tt>Control-C</tt>, or timeouts. Another option is
--   to run the release action asynchronously in its own thread:
--   
--   <pre>
--   void $ uninterruptibleMask_ $ forkIO $ do { ... }
--   </pre>
--   
--   The resource will be released as soon as possible, but the thread that
--   invoked bracket will not block in an uninterruptible state.
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
instance GHC.Classes.Ord Data.GraphViz.Exception.GraphvizException
instance GHC.Classes.Eq Data.GraphViz.Exception.GraphvizException
instance GHC.Show.Show Data.GraphViz.Exception.GraphvizException
instance GHC.Exception.Type.Exception Data.GraphViz.Exception.GraphvizException


-- | This module defines simple helper functions for use with
--   <a>Text.ParserCombinators.Poly.Lazy</a>.
--   
--   Note that the <a>ParseDot</a> instances for <a>Bool</a>, etc. match
--   those specified for use with Graphviz (e.g. non-zero integers are
--   equivalent to <a>True</a>).
--   
--   You should not be using this module; rather, it is here for
--   informative/documentative reasons. If you want to parse a
--   <tt><a>DotRepr</a></tt>, you should use <tt><a>parseDotGraph</a></tt>
--   rather than its <a>ParseDot</a> instance.
module Data.GraphViz.Parsing

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | The <a>Const</a> functor.
newtype () => Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
newtype () => ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]
newtype () => WrappedArrow (a :: Type -> Type -> Type) b c
WrapArrow :: a b c -> WrappedArrow (a :: Type -> Type -> Type) b c
[unwrapArrow] :: WrappedArrow (a :: Type -> Type -> Type) b c -> a b c
newtype () => WrappedMonad (m :: Type -> Type) a
WrapMonad :: m a -> WrappedMonad (m :: Type -> Type) a
[unwrapMonad] :: WrappedMonad (m :: Type -> Type) a -> m a
newtype () => Parser s a
P :: (s -> Text -> Result (Text, s) a) -> Parser s a
data () => Result z a
Success :: z -> a -> Result z a
Failure :: z -> String -> Result z a
Committed :: Result z a -> Result z a
class () => Commitment (p :: Type -> Type)
commit :: Commitment p => p a -> p a
adjustErr :: Commitment p => p a -> (String -> String) -> p a
oneOf' :: Commitment p => [(String, p a)] -> p a
class (Functor p, Monad p, MonadFail p, Applicative p, Alternative p, Commitment p) => PolyParse (p :: Type -> Type)

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>
bracket :: PolyParse p => p bra -> p ket -> p a -> p a

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Lift a function to actions. Equivalent to Functor's <a>fmap</a> but
--   implemented using only <a>Applicative</a>'s methods: <tt><a>liftA</a>
--   f a = <a>pure</a> f <a>&lt;*&gt;</a> a</tt>
--   
--   As such this function may be used to implement a <a>Functor</a>
--   instance from an <a>Applicative</a> one.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the Applicative instance for Lists:
--   
--   <pre>
--   &gt;&gt;&gt; liftA (+1) [1, 2]
--   [2,3]
--   </pre>
--   
--   Or the Applicative instance for <a>Maybe</a>
--   
--   <pre>
--   &gt;&gt;&gt; liftA (+1) (Just 3)
--   Just 4
--   </pre>
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
satisfy :: (Char -> Bool) -> Parser s Char
eof :: Parser s ()

-- | One or none.
--   
--   It is useful for modelling any computation that is allowed to fail.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the <a>Alternative</a> instance of <a>Control.Monad.Except</a>,
--   the following functions:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.Except
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; canFail = throwError "it failed" :: Except String Int
--   
--   &gt;&gt;&gt; final = return 42                :: Except String Int
--   </pre>
--   
--   Can be combined by allowing the first function to fail:
--   
--   <pre>
--   &gt;&gt;&gt; runExcept $ canFail *&gt; final
--   Left "it failed"
--   
--   &gt;&gt;&gt; runExcept $ optional canFail *&gt; final
--   Right 42
--   </pre>
optional :: Alternative f => f a -> f (Maybe a)
many1 :: PolyParse p => p a -> p [a]
sepBy :: PolyParse p => p a -> p sep -> p [a]
sepBy1 :: PolyParse p => p a -> p sep -> p [a]
apply :: PolyParse p => p (a -> b) -> p a -> p b

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>asum</a> is just like <a>msum</a>, but generalised to
--   <a>Alternative</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a
exactly :: PolyParse p => Int -> p a -> p [a]
stQuery :: (s -> a) -> Parser s a
stUpdate :: (s -> s) -> Parser s ()
adjustErrBad :: PolyParse p => p a -> (String -> String) -> p a
bracketSep :: PolyParse p => p bra -> p sep -> p ket -> p a -> p [a]
discard :: PolyParse p => p a -> p b -> p a
failBad :: PolyParse p => String -> p a
manyFinally :: PolyParse p => p a -> p z -> p [a]
manyFinally' :: (PolyParse p, Show a) => p a -> p z -> p [a]
oneOf :: PolyParse p => [p a] -> p a
upto :: PolyParse p => Int -> p a -> p [a]
many1Satisfy :: (Char -> Bool) -> Parser s Text
manySatisfy :: (Char -> Bool) -> Parser s Text
next :: Parser s Char
onFail :: Parser s a -> Parser s a -> Parser s a
reparse :: Text -> Parser s ()
stGet :: Parser s s

-- | A <tt>ReadS</tt>-like type alias.
type Parse a = Parser GraphvizState a
class ParseDot a
parseUnqt :: ParseDot a => Parse a
parse :: ParseDot a => Parse a
parseUnqtList :: ParseDot a => Parse [a]
parseList :: ParseDot a => Parse [a]

-- | Parse the required value, returning also the rest of the input
--   <a>Text</a> that hasn't been parsed (for debugging purposes).
parseIt :: ParseDot a => Text -> (a, Text)

-- | Parse the required value with the assumption that it will parse all of
--   the input <a>Text</a>.
parseIt' :: ParseDot a => Text -> a
runParser :: Parse a -> Text -> (Either String a, Text)

-- | A variant of <a>runParser</a> where it is assumed that the provided
--   parsing function consumes all of the <a>Text</a> input (with the
--   exception of whitespace at the end).
runParser' :: Parse a -> Text -> a
runParserWith :: (GraphvizState -> GraphvizState) -> Parse a -> Text -> (Either String a, Text)
parseLiberally :: GraphvizState -> GraphvizState

-- | If unable to parse <i>Dot</i> code properly, <a>throw</a> a
--   <a>GraphvizException</a>.
checkValidParse :: Either String a -> a

-- | If unable to parse <i>Dot</i> code properly, <a>throw</a> a
--   <a>GraphvizException</a>, with the error containing the remaining
--   unparsed code..
checkValidParseWithRest :: (Either String a, Text) -> a

-- | The opposite of <a>bracket</a>.
ignoreSep :: (a -> b -> c) -> Parse a -> Parse sep -> Parse b -> Parse c

-- | Use this when you do not want numbers to be treated as <a>Bool</a>
--   values.
onlyBool :: Parse Bool

-- | Parse a <a>Text</a> that doesn't need to be quoted.
quotelessString :: Parse Text
stringBlock :: Parse Text
numString :: Bool -> Parse Text

-- | Determine if this String represents a number. Boolean parameter
--   determines if exponents are considered part of numbers for this.
isNumString :: Bool -> Text -> Bool
isIntString :: Text -> Bool

-- | Used when quotes are explicitly required;
quotedString :: Parse Text

-- | Parse a <a>Text</a> where the provided <a>Char</a>s (as well as
--   <tt>"</tt> and <tt>\</tt>) are escaped and the second list of
--   <a>Char</a>s are those that are not permitted. Note: does not parse
--   surrounding quotes. The <a>Bool</a> value indicates whether empty
--   <a>Text</a>s are allowed or not.
parseEscaped :: Bool -> [Char] -> [Char] -> Parse Text
parseAndSpace :: Parse a -> Parse a
string :: String -> Parse ()
strings :: [String] -> Parse ()

-- | Assumes that any letter is ASCII for case-insensitive comparisons.
character :: Char -> Parse Char

-- | Parse a floating point number that actually contains decimals. Bool
--   flag indicates whether values that need to be quoted are parsed.
parseStrictFloat :: Bool -> Parse Double
parseSignedFloat :: Bool -> Parse Double
noneOf :: [Char] -> Parse Char

-- | Parses at least one whitespace character.
whitespace1 :: Parse ()

-- | Parses zero or more whitespace characters.
whitespace :: Parse ()

-- | Parse and discard optional surrounding whitespace.
wrapWhitespace :: Parse a -> Parse a
optionalQuotedString :: String -> Parse ()
optionalQuoted :: Parse a -> Parse a
quotedParse :: Parse a -> Parse a
orQuote :: Parse Char -> Parse Char
quoteChar :: Char

-- | Parses a newline.
newline :: Parse ()

-- | Consume all whitespace and newlines until a line with non-whitespace
--   is reached. The whitespace on that line is not consumed.
newline' :: Parse ()
parseComma :: Parse ()
parseEq :: Parse ()

-- | Try to parse a list of the specified type; returns an empty list if
--   parsing fails.
tryParseList :: ParseDot a => Parse [a]

-- | Return an empty list if parsing a list fails.
tryParseList' :: Parse [a] -> Parse [a]

-- | Parses and returns all characters up till the end of the line, but
--   does not touch the newline characters.
consumeLine :: Parse Text
commaSep :: (ParseDot a, ParseDot b) => Parse (a, b)
commaSepUnqt :: (ParseDot a, ParseDot b) => Parse (a, b)
commaSep' :: Parse a -> Parse b -> Parse (a, b)
stringRep :: a -> String -> Parse a
stringReps :: a -> [String] -> Parse a
stringParse :: [(String, Parse a)] -> Parse a
stringValue :: [(String, a)] -> Parse a
parseAngled :: Parse a -> Parse a
parseBraced :: Parse a -> Parse a
parseColorScheme :: Bool -> Parse ColorScheme
instance Data.GraphViz.Parsing.ParseDot GHC.Types.Int
instance Data.GraphViz.Parsing.ParseDot GHC.Num.Integer.Integer
instance Data.GraphViz.Parsing.ParseDot GHC.Word.Word8
instance Data.GraphViz.Parsing.ParseDot GHC.Word.Word16
instance Data.GraphViz.Parsing.ParseDot GHC.Types.Double
instance Data.GraphViz.Parsing.ParseDot GHC.Types.Bool
instance Data.GraphViz.Parsing.ParseDot GHC.Types.Char
instance Data.GraphViz.Parsing.ParseDot Data.Version.Version
instance Data.GraphViz.Parsing.ParseDot Data.Text.Internal.Lazy.Text
instance Data.GraphViz.Parsing.ParseDot Data.Text.Internal.Text
instance Data.GraphViz.Parsing.ParseDot a => Data.GraphViz.Parsing.ParseDot [a]
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.ColorScheme.ColorScheme
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.ColorScheme.BrewerScheme
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.ColorScheme.BrewerName


-- | "Real life" Dot code contains various items that are not directly
--   parseable by this library. This module defines the <a>preProcess</a>
--   function to remove these components, which include:
--   
--   <ul>
--   <li>Comments (both <tt>/* ... */</tt> style and <tt>// ... </tt>
--   style);</li>
--   <li>Pre-processor lines (lines starting with a <tt>#</tt>);</li>
--   <li>Split lines (by inserting a <tt>\</tt> the rest of that "line" is
--   continued on the next line).</li>
--   <li>Strings concatenated together using <tt>"..." + "..."</tt>; these
--   are concatenated into one big string.</li>
--   </ul>
module Data.GraphViz.PreProcessing

-- | Remove unparseable features of Dot, such as comments and multi-line
--   strings (which are converted to single-line strings).
preProcess :: Text -> Text


-- | This module defines simple helper functions for use with
--   <a>Text.PrettyPrint</a>. It also re-exports all the pretty-printing
--   combinators from that module.
--   
--   Note that the <a>PrintDot</a> instances for <a>Bool</a>, etc. match
--   those specified for use with Graphviz.
--   
--   You should only be using this module if you are writing custom node
--   types for use with <a>Data.GraphViz.Types</a>. For actual printing of
--   code, use <tt><a>printDotGraph</a></tt> (which produces a <a>Text</a>
--   value).
--   
--   The Dot language specification specifies that any identifier is in one
--   of four forms:
--   
--   <ul>
--   <li>Any string of alphabetic ([a-zA-Z\200-\377]) characters,
--   underscores ('_') or digits ([0-9]), not beginning with a digit;</li>
--   <li>a number [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? );</li>
--   <li>any double-quoted string ("...") possibly containing escaped
--   quotes (\");</li>
--   <li>an HTML string (&lt;...&gt;).</li>
--   </ul>
--   
--   (Note that the first restriction is referring to a byte-by-byte
--   comparison using octal values; when using UTF-8 this corresponds to
--   all characters <tt>c</tt> where <tt>ord c &gt;= 128</tt>.)
--   
--   Due to these restrictions, you should only use <a>text</a> when you
--   are sure that the <a>Text</a> in question is static and quotes are
--   definitely needed/unneeded; it is better to use the <a>Text</a>
--   instance for <a>PrintDot</a>. For more information, see the
--   specification page: <a>http://graphviz.org/doc/info/lang.html</a>
module Data.GraphViz.Printing
data () => Doc
text :: Applicative m => Text -> m Doc
group :: Functor m => m Doc -> m Doc
empty :: Applicative m => m Doc
fill :: Functor m => Int -> m Doc -> m Doc
char :: Applicative m => Char -> m Doc
parens :: Functor m => m Doc -> m Doc
list :: Functor m => m [Doc] -> m Doc
(<+>) :: Applicative m => m Doc -> m Doc -> m Doc
(</>) :: Applicative m => m Doc -> m Doc -> m Doc
semi :: Applicative m => m Doc
comma :: Applicative m => m Doc
colon :: Applicative m => m Doc
space :: Applicative m => m Doc
equals :: Applicative m => m Doc
lparen :: Applicative m => m Doc
rparen :: Applicative m => m Doc
lbrace :: Applicative m => m Doc
rbrace :: Applicative m => m Doc
int :: Applicative m => Int -> m Doc
integer :: Applicative m => Integer -> m Doc
float :: Applicative m => Float -> m Doc
double :: Applicative m => Double -> m Doc
rational :: Applicative m => Rational -> m Doc
brackets :: Functor m => m Doc -> m Doc
braces :: Functor m => m Doc -> m Doc
hcat :: Functor m => m [Doc] -> m Doc
hsep :: Functor m => m [Doc] -> m Doc
vcat :: Functor m => m [Doc] -> m Doc
nest :: Functor m => Int -> m Doc -> m Doc
hang :: Functor m => Int -> m Doc -> m Doc
punctuate :: Applicative m => m Doc -> m [Doc] -> m [Doc]
sep :: Functor m => m [Doc] -> m Doc
cat :: Functor m => m [Doc] -> m Doc
indent :: Functor m => Int -> m Doc -> m Doc
(<++>) :: Applicative m => m Doc -> m Doc -> m Doc
renderOneLine :: Doc -> SimpleDoc
beside :: Applicative m => m Doc -> m Doc -> m Doc
dquotes :: Functor m => m Doc -> m Doc
dot :: Applicative m => m Doc
langle :: Applicative m => m Doc
rangle :: Applicative m => m Doc
(<$$>) :: Applicative m => m Doc -> m Doc -> m Doc
(<//>) :: Applicative m => m Doc -> m Doc -> m Doc
align :: Functor m => m Doc -> m Doc
angles :: Functor m => m Doc -> m Doc
backslash :: Applicative m => m Doc
column :: Functor m => m (Int -> Doc) -> m Doc
displayB :: SimpleDoc -> Builder
displayTStrict :: SimpleDoc -> Text
dquote :: Applicative m => m Doc
enclose :: Applicative m => m Doc -> m Doc -> m Doc -> m Doc
encloseSep :: Applicative m => m Doc -> m Doc -> m Doc -> m [Doc] -> m Doc
fillBreak :: Functor m => Int -> m Doc -> m Doc
fillCat :: Functor m => m [Doc] -> m Doc
fillSep :: Functor m => m [Doc] -> m Doc
lbracket :: Applicative m => m Doc
line :: Applicative m => m Doc
linebreak :: Applicative m => m Doc
nesting :: Functor m => m (Int -> Doc) -> m Doc
rbracket :: Applicative m => m Doc
semiBraces :: Functor m => m [Doc] -> m Doc
softbreak :: Applicative m => m Doc
softline :: Applicative m => m Doc
spacebreak :: Applicative m => m Doc
squote :: Applicative m => m Doc
squotes :: Functor m => m Doc -> m Doc
stringStrict :: Monad m => Text -> m Doc
textStrict :: Monad m => Text -> m Doc
tupled :: Functor m => m [Doc] -> m Doc
vsep :: Functor m => m [Doc] -> m Doc
prettyM :: (Pretty a, Applicative m) => a -> m Doc
type DotCode = DotCodeM Doc

-- | A type alias to indicate what is being produced.
data DotCodeM a
runDotCode :: DotCode -> Doc

-- | Correctly render Graphviz output.
renderDot :: DotCode -> Text

-- | A class used to correctly print parts of the Graphviz Dot language.
--   Minimal implementation is <a>unqtDot</a>.
class PrintDot a

-- | The unquoted representation, for use when composing values to produce
--   a larger printing value.
unqtDot :: PrintDot a => a -> DotCode

-- | The actual quoted representation; this should be quoted if it contains
--   characters not permitted a plain ID String, a number or it is not an
--   HTML string. Defaults to <a>unqtDot</a>.
toDot :: PrintDot a => a -> DotCode

-- | The correct way of representing a list of this value when printed; not
--   all Dot values require this to be implemented. Defaults to
--   Haskell-like list representation.
unqtListToDot :: PrintDot a => [a] -> DotCode

-- | The quoted form of <a>unqtListToDot</a>; defaults to wrapping double
--   quotes around the result of <a>unqtListToDot</a> (since the default
--   implementation has characters that must be quoted).
listToDot :: PrintDot a => [a] -> DotCode

-- | For use with <tt>OverloadedStrings</tt> to avoid ambiguous type
--   variable errors.
unqtText :: Text -> DotCode

-- | For use with <tt>OverloadedStrings</tt> to avoid ambiguous type
--   variable errors.
dotText :: Text -> DotCode

-- | Convert to DotCode; note that this has no indentation, as we can only
--   have one of indentation and (possibly) infinite line lengths.
printIt :: PrintDot a => a -> Text
addQuotes :: Text -> DotCode -> DotCode

-- | Escape the specified chars as well as <tt>"</tt>.
unqtEscaped :: [Char] -> Text -> DotCode

-- | Escape the specified chars as well as <tt>"</tt> and then wrap the
--   result in quotes.
printEscaped :: [Char] -> Text -> DotCode
wrap :: DotCode -> DotCode -> DotCode -> DotCode
commaDel :: (PrintDot a, PrintDot b) => a -> b -> DotCode
printField :: PrintDot a => Text -> a -> DotCode
angled :: DotCode -> DotCode
fslash :: DotCode
printColorScheme :: Bool -> ColorScheme -> DotCode
instance Control.Monad.State.Class.MonadState Data.GraphViz.Internal.State.GraphvizState Data.GraphViz.Printing.DotCodeM
instance GHC.Base.Monad Data.GraphViz.Printing.DotCodeM
instance GHC.Base.Applicative Data.GraphViz.Printing.DotCodeM
instance GHC.Base.Functor Data.GraphViz.Printing.DotCodeM
instance Data.GraphViz.Printing.PrintDot GHC.Types.Int
instance Data.GraphViz.Printing.PrintDot GHC.Num.Integer.Integer
instance Data.GraphViz.Printing.PrintDot GHC.Word.Word8
instance Data.GraphViz.Printing.PrintDot GHC.Word.Word16
instance Data.GraphViz.Printing.PrintDot GHC.Word.Word32
instance Data.GraphViz.Printing.PrintDot GHC.Word.Word64
instance Data.GraphViz.Printing.PrintDot GHC.Types.Double
instance Data.GraphViz.Printing.PrintDot GHC.Types.Bool
instance Data.GraphViz.Printing.PrintDot GHC.Types.Char
instance Data.GraphViz.Printing.PrintDot Data.Version.Version
instance Data.GraphViz.Printing.PrintDot Data.Text.Internal.Lazy.Text
instance Data.GraphViz.Printing.PrintDot Data.Text.Internal.Text
instance Data.GraphViz.Printing.PrintDot a => Data.GraphViz.Printing.PrintDot [a]
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.ColorScheme.ColorScheme
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.ColorScheme.BrewerScheme
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.ColorScheme.BrewerName
instance GHC.Show.Show Data.GraphViz.Printing.DotCode
instance Data.String.IsString Data.GraphViz.Printing.DotCode
instance GHC.Base.Semigroup Data.GraphViz.Printing.DotCode
instance GHC.Base.Monoid Data.GraphViz.Printing.DotCode
instance Data.GraphViz.Internal.State.GraphvizStateM Data.GraphViz.Printing.DotCodeM


-- | Graphviz's definition of X11 colors differs from the "normal" list
--   installed on many systems at
--   <tt><i>usr</i>share<i>X11</i>rgb.txt</tt>. For example,
--   <tt>Crimson</tt> is not a usual X11 color.
--   
--   Furthermore, all <tt>Gray*</tt> colors are duplicated with
--   <tt>Grey*</tt> names. To simplify this, these duplicates have been
--   removed but <i>all</i> <a>X11Color</a>s with "<tt>Gray</tt>" (whether
--   they have the duplicate spelling or not) in their name are also
--   parseable as if they were spelt with "<tt>grey</tt>".
--   
--   The complete list of X11 colors can be found at
--   <a>http://www.graphviz.org/doc/info/colors.html#x11</a>.
module Data.GraphViz.Attributes.Colors.X11

-- | The X11 colors that Graphviz uses. Note that these are slightly
--   different from the "normal" X11 colors used (e.g. the inclusion of
--   <tt>Crimson</tt>). Graphviz's list of colors also duplicated almost
--   all <tt>Gray</tt> colors with <tt>Grey</tt> ones; parsing of an
--   <a>X11Color</a> which is specified using "grey" will succeed, even for
--   those that don't have the duplicate spelling (e.g.
--   <tt>DarkSlateGray1</tt>).
data X11Color
AliceBlue :: X11Color
AntiqueWhite :: X11Color
AntiqueWhite1 :: X11Color
AntiqueWhite2 :: X11Color
AntiqueWhite3 :: X11Color
AntiqueWhite4 :: X11Color
Aquamarine :: X11Color
Aquamarine1 :: X11Color
Aquamarine2 :: X11Color
Aquamarine3 :: X11Color
Aquamarine4 :: X11Color
Azure :: X11Color
Azure1 :: X11Color
Azure2 :: X11Color
Azure3 :: X11Color
Azure4 :: X11Color
Beige :: X11Color
Bisque :: X11Color
Bisque1 :: X11Color
Bisque2 :: X11Color
Bisque3 :: X11Color
Bisque4 :: X11Color
Black :: X11Color
BlanchedAlmond :: X11Color
Blue :: X11Color
Blue1 :: X11Color
Blue2 :: X11Color
Blue3 :: X11Color
Blue4 :: X11Color
BlueViolet :: X11Color
Brown :: X11Color
Brown1 :: X11Color
Brown2 :: X11Color
Brown3 :: X11Color
Brown4 :: X11Color
Burlywood :: X11Color
Burlywood1 :: X11Color
Burlywood2 :: X11Color
Burlywood3 :: X11Color
Burlywood4 :: X11Color
CadetBlue :: X11Color
CadetBlue1 :: X11Color
CadetBlue2 :: X11Color
CadetBlue3 :: X11Color
CadetBlue4 :: X11Color
Chartreuse :: X11Color
Chartreuse1 :: X11Color
Chartreuse2 :: X11Color
Chartreuse3 :: X11Color
Chartreuse4 :: X11Color
Chocolate :: X11Color
Chocolate1 :: X11Color
Chocolate2 :: X11Color
Chocolate3 :: X11Color
Chocolate4 :: X11Color
Coral :: X11Color
Coral1 :: X11Color
Coral2 :: X11Color
Coral3 :: X11Color
Coral4 :: X11Color
CornFlowerBlue :: X11Color
CornSilk :: X11Color
CornSilk1 :: X11Color
CornSilk2 :: X11Color
CornSilk3 :: X11Color
CornSilk4 :: X11Color
Crimson :: X11Color
Cyan :: X11Color
Cyan1 :: X11Color
Cyan2 :: X11Color
Cyan3 :: X11Color
Cyan4 :: X11Color
DarkGoldenrod :: X11Color
DarkGoldenrod1 :: X11Color
DarkGoldenrod2 :: X11Color
DarkGoldenrod3 :: X11Color
DarkGoldenrod4 :: X11Color
DarkGreen :: X11Color
Darkkhaki :: X11Color
DarkOliveGreen :: X11Color
DarkOliveGreen1 :: X11Color
DarkOliveGreen2 :: X11Color
DarkOliveGreen3 :: X11Color
DarkOliveGreen4 :: X11Color
DarkOrange :: X11Color
DarkOrange1 :: X11Color
DarkOrange2 :: X11Color
DarkOrange3 :: X11Color
DarkOrange4 :: X11Color
DarkOrchid :: X11Color
DarkOrchid1 :: X11Color
DarkOrchid2 :: X11Color
DarkOrchid3 :: X11Color
DarkOrchid4 :: X11Color
DarkSalmon :: X11Color
DarkSeaGreen :: X11Color
DarkSeaGreen1 :: X11Color
DarkSeaGreen2 :: X11Color
DarkSeaGreen3 :: X11Color
DarkSeaGreen4 :: X11Color
DarkSlateBlue :: X11Color
DarkSlateGray :: X11Color
DarkSlateGray1 :: X11Color
DarkSlateGray2 :: X11Color
DarkSlateGray3 :: X11Color
DarkSlateGray4 :: X11Color
DarkTurquoise :: X11Color
DarkViolet :: X11Color
DeepPink :: X11Color
DeepPink1 :: X11Color
DeepPink2 :: X11Color
DeepPink3 :: X11Color
DeepPink4 :: X11Color
DeepSkyBlue :: X11Color
DeepSkyBlue1 :: X11Color
DeepSkyBlue2 :: X11Color
DeepSkyBlue3 :: X11Color
DeepSkyBlue4 :: X11Color
DimGray :: X11Color
DodgerBlue :: X11Color
DodgerBlue1 :: X11Color
DodgerBlue2 :: X11Color
DodgerBlue3 :: X11Color
DodgerBlue4 :: X11Color
Firebrick :: X11Color
Firebrick1 :: X11Color
Firebrick2 :: X11Color
Firebrick3 :: X11Color
Firebrick4 :: X11Color
FloralWhite :: X11Color
ForestGreen :: X11Color
Gainsboro :: X11Color
GhostWhite :: X11Color
Gold :: X11Color
Gold1 :: X11Color
Gold2 :: X11Color
Gold3 :: X11Color
Gold4 :: X11Color
Goldenrod :: X11Color
Goldenrod1 :: X11Color
Goldenrod2 :: X11Color
Goldenrod3 :: X11Color
Goldenrod4 :: X11Color
Gray :: X11Color
Gray0 :: X11Color
Gray1 :: X11Color
Gray2 :: X11Color
Gray3 :: X11Color
Gray4 :: X11Color
Gray5 :: X11Color
Gray6 :: X11Color
Gray7 :: X11Color
Gray8 :: X11Color
Gray9 :: X11Color
Gray10 :: X11Color
Gray11 :: X11Color
Gray12 :: X11Color
Gray13 :: X11Color
Gray14 :: X11Color
Gray15 :: X11Color
Gray16 :: X11Color
Gray17 :: X11Color
Gray18 :: X11Color
Gray19 :: X11Color
Gray20 :: X11Color
Gray21 :: X11Color
Gray22 :: X11Color
Gray23 :: X11Color
Gray24 :: X11Color
Gray25 :: X11Color
Gray26 :: X11Color
Gray27 :: X11Color
Gray28 :: X11Color
Gray29 :: X11Color
Gray30 :: X11Color
Gray31 :: X11Color
Gray32 :: X11Color
Gray33 :: X11Color
Gray34 :: X11Color
Gray35 :: X11Color
Gray36 :: X11Color
Gray37 :: X11Color
Gray38 :: X11Color
Gray39 :: X11Color
Gray40 :: X11Color
Gray41 :: X11Color
Gray42 :: X11Color
Gray43 :: X11Color
Gray44 :: X11Color
Gray45 :: X11Color
Gray46 :: X11Color
Gray47 :: X11Color
Gray48 :: X11Color
Gray49 :: X11Color
Gray50 :: X11Color
Gray51 :: X11Color
Gray52 :: X11Color
Gray53 :: X11Color
Gray54 :: X11Color
Gray55 :: X11Color
Gray56 :: X11Color
Gray57 :: X11Color
Gray58 :: X11Color
Gray59 :: X11Color
Gray60 :: X11Color
Gray61 :: X11Color
Gray62 :: X11Color
Gray63 :: X11Color
Gray64 :: X11Color
Gray65 :: X11Color
Gray66 :: X11Color
Gray67 :: X11Color
Gray68 :: X11Color
Gray69 :: X11Color
Gray70 :: X11Color
Gray71 :: X11Color
Gray72 :: X11Color
Gray73 :: X11Color
Gray74 :: X11Color
Gray75 :: X11Color
Gray76 :: X11Color
Gray77 :: X11Color
Gray78 :: X11Color
Gray79 :: X11Color
Gray80 :: X11Color
Gray81 :: X11Color
Gray82 :: X11Color
Gray83 :: X11Color
Gray84 :: X11Color
Gray85 :: X11Color
Gray86 :: X11Color
Gray87 :: X11Color
Gray88 :: X11Color
Gray89 :: X11Color
Gray90 :: X11Color
Gray91 :: X11Color
Gray92 :: X11Color
Gray93 :: X11Color
Gray94 :: X11Color
Gray95 :: X11Color
Gray96 :: X11Color
Gray97 :: X11Color
Gray98 :: X11Color
Gray99 :: X11Color
Gray100 :: X11Color
Green :: X11Color
Green1 :: X11Color
Green2 :: X11Color
Green3 :: X11Color
Green4 :: X11Color
GreenYellow :: X11Color
HoneyDew :: X11Color
HoneyDew1 :: X11Color
HoneyDew2 :: X11Color
HoneyDew3 :: X11Color
HoneyDew4 :: X11Color
HotPink :: X11Color
HotPink1 :: X11Color
HotPink2 :: X11Color
HotPink3 :: X11Color
HotPink4 :: X11Color
IndianRed :: X11Color
IndianRed1 :: X11Color
IndianRed2 :: X11Color
IndianRed3 :: X11Color
IndianRed4 :: X11Color
Indigo :: X11Color
Ivory :: X11Color
Ivory1 :: X11Color
Ivory2 :: X11Color
Ivory3 :: X11Color
Ivory4 :: X11Color
Khaki :: X11Color
Khaki1 :: X11Color
Khaki2 :: X11Color
Khaki3 :: X11Color
Khaki4 :: X11Color
Lavender :: X11Color
LavenderBlush :: X11Color
LavenderBlush1 :: X11Color
LavenderBlush2 :: X11Color
LavenderBlush3 :: X11Color
LavenderBlush4 :: X11Color
LawnGreen :: X11Color
LemonChiffon :: X11Color
LemonChiffon1 :: X11Color
LemonChiffon2 :: X11Color
LemonChiffon3 :: X11Color
LemonChiffon4 :: X11Color
LightBlue :: X11Color
LightBlue1 :: X11Color
LightBlue2 :: X11Color
LightBlue3 :: X11Color
LightBlue4 :: X11Color
LightCoral :: X11Color
LightCyan :: X11Color
LightCyan1 :: X11Color
LightCyan2 :: X11Color
LightCyan3 :: X11Color
LightCyan4 :: X11Color
LightGoldenrod :: X11Color
LightGoldenrod1 :: X11Color
LightGoldenrod2 :: X11Color
LightGoldenrod3 :: X11Color
LightGoldenrod4 :: X11Color
LightGoldenrodYellow :: X11Color
LightGray :: X11Color
LightPink :: X11Color
LightPink1 :: X11Color
LightPink2 :: X11Color
LightPink3 :: X11Color
LightPink4 :: X11Color
LightSalmon :: X11Color
LightSalmon1 :: X11Color
LightSalmon2 :: X11Color
LightSalmon3 :: X11Color
LightSalmon4 :: X11Color
LightSeaGreen :: X11Color
LightSkyBlue :: X11Color
LightSkyBlue1 :: X11Color
LightSkyBlue2 :: X11Color
LightSkyBlue3 :: X11Color
LightSkyBlue4 :: X11Color
LightSlateBlue :: X11Color
LightSlateGray :: X11Color
LightSteelBlue :: X11Color
LightSteelBlue1 :: X11Color
LightSteelBlue2 :: X11Color
LightSteelBlue3 :: X11Color
LightSteelBlue4 :: X11Color
LightYellow :: X11Color
LightYellow1 :: X11Color
LightYellow2 :: X11Color
LightYellow3 :: X11Color
LightYellow4 :: X11Color
LimeGreen :: X11Color
Linen :: X11Color
Magenta :: X11Color
Magenta1 :: X11Color
Magenta2 :: X11Color
Magenta3 :: X11Color
Magenta4 :: X11Color
Maroon :: X11Color
Maroon1 :: X11Color
Maroon2 :: X11Color
Maroon3 :: X11Color
Maroon4 :: X11Color
MediumAquamarine :: X11Color
MediumBlue :: X11Color
MediumOrchid :: X11Color
MediumOrchid1 :: X11Color
MediumOrchid2 :: X11Color
MediumOrchid3 :: X11Color
MediumOrchid4 :: X11Color
MediumPurple :: X11Color
MediumPurple1 :: X11Color
MediumPurple2 :: X11Color
MediumPurple3 :: X11Color
MediumPurple4 :: X11Color
MediumSeaGreen :: X11Color
MediumSlateBlue :: X11Color
MediumSpringGreen :: X11Color
MediumTurquoise :: X11Color
MediumVioletRed :: X11Color
MidnightBlue :: X11Color
MintCream :: X11Color
MistyRose :: X11Color
MistyRose1 :: X11Color
MistyRose2 :: X11Color
MistyRose3 :: X11Color
MistyRose4 :: X11Color
Moccasin :: X11Color
NavajoWhite :: X11Color
NavajoWhite1 :: X11Color
NavajoWhite2 :: X11Color
NavajoWhite3 :: X11Color
NavajoWhite4 :: X11Color
Navy :: X11Color
NavyBlue :: X11Color
OldLace :: X11Color
OliveDrab :: X11Color
OliveDrab1 :: X11Color
OliveDrab2 :: X11Color
OliveDrab3 :: X11Color
OliveDrab4 :: X11Color
Orange :: X11Color
Orange1 :: X11Color
Orange2 :: X11Color
Orange3 :: X11Color
Orange4 :: X11Color
OrangeRed :: X11Color
OrangeRed1 :: X11Color
OrangeRed2 :: X11Color
OrangeRed3 :: X11Color
OrangeRed4 :: X11Color
Orchid :: X11Color
Orchid1 :: X11Color
Orchid2 :: X11Color
Orchid3 :: X11Color
Orchid4 :: X11Color
PaleGoldenrod :: X11Color
PaleGreen :: X11Color
PaleGreen1 :: X11Color
PaleGreen2 :: X11Color
PaleGreen3 :: X11Color
PaleGreen4 :: X11Color
PaleTurquoise :: X11Color
PaleTurquoise1 :: X11Color
PaleTurquoise2 :: X11Color
PaleTurquoise3 :: X11Color
PaleTurquoise4 :: X11Color
PaleVioletRed :: X11Color
PaleVioletRed1 :: X11Color
PaleVioletRed2 :: X11Color
PaleVioletRed3 :: X11Color
PaleVioletRed4 :: X11Color
PapayaWhip :: X11Color
PeachPuff :: X11Color
PeachPuff1 :: X11Color
PeachPuff2 :: X11Color
PeachPuff3 :: X11Color
PeachPuff4 :: X11Color
Peru :: X11Color
Pink :: X11Color
Pink1 :: X11Color
Pink2 :: X11Color
Pink3 :: X11Color
Pink4 :: X11Color
Plum :: X11Color
Plum1 :: X11Color
Plum2 :: X11Color
Plum3 :: X11Color
Plum4 :: X11Color
PowderBlue :: X11Color
Purple :: X11Color
Purple1 :: X11Color
Purple2 :: X11Color
Purple3 :: X11Color
Purple4 :: X11Color
Red :: X11Color
Red1 :: X11Color
Red2 :: X11Color
Red3 :: X11Color
Red4 :: X11Color
RosyBrown :: X11Color
RosyBrown1 :: X11Color
RosyBrown2 :: X11Color
RosyBrown3 :: X11Color
RosyBrown4 :: X11Color
RoyalBlue :: X11Color
RoyalBlue1 :: X11Color
RoyalBlue2 :: X11Color
RoyalBlue3 :: X11Color
RoyalBlue4 :: X11Color
SaddleBrown :: X11Color
Salmon :: X11Color
Salmon1 :: X11Color
Salmon2 :: X11Color
Salmon3 :: X11Color
Salmon4 :: X11Color
SandyBrown :: X11Color
SeaGreen :: X11Color
SeaGreen1 :: X11Color
SeaGreen2 :: X11Color
SeaGreen3 :: X11Color
SeaGreen4 :: X11Color
SeaShell :: X11Color
SeaShell1 :: X11Color
SeaShell2 :: X11Color
SeaShell3 :: X11Color
SeaShell4 :: X11Color
Sienna :: X11Color
Sienna1 :: X11Color
Sienna2 :: X11Color
Sienna3 :: X11Color
Sienna4 :: X11Color
SkyBlue :: X11Color
SkyBlue1 :: X11Color
SkyBlue2 :: X11Color
SkyBlue3 :: X11Color
SkyBlue4 :: X11Color
SlateBlue :: X11Color
SlateBlue1 :: X11Color
SlateBlue2 :: X11Color
SlateBlue3 :: X11Color
SlateBlue4 :: X11Color
SlateGray :: X11Color
SlateGray1 :: X11Color
SlateGray2 :: X11Color
SlateGray3 :: X11Color
SlateGray4 :: X11Color
Snow :: X11Color
Snow1 :: X11Color
Snow2 :: X11Color
Snow3 :: X11Color
Snow4 :: X11Color
SpringGreen :: X11Color
SpringGreen1 :: X11Color
SpringGreen2 :: X11Color
SpringGreen3 :: X11Color
SpringGreen4 :: X11Color
SteelBlue :: X11Color
SteelBlue1 :: X11Color
SteelBlue2 :: X11Color
SteelBlue3 :: X11Color
SteelBlue4 :: X11Color
Tan :: X11Color
Tan1 :: X11Color
Tan2 :: X11Color
Tan3 :: X11Color
Tan4 :: X11Color
Thistle :: X11Color
Thistle1 :: X11Color
Thistle2 :: X11Color
Thistle3 :: X11Color
Thistle4 :: X11Color
Tomato :: X11Color
Tomato1 :: X11Color
Tomato2 :: X11Color
Tomato3 :: X11Color
Tomato4 :: X11Color

-- | Equivalent to setting <tt>Style [SItem Invisible []]</tt>.
Transparent :: X11Color
Turquoise :: X11Color
Turquoise1 :: X11Color
Turquoise2 :: X11Color
Turquoise3 :: X11Color
Turquoise4 :: X11Color
Violet :: X11Color
VioletRed :: X11Color
VioletRed1 :: X11Color
VioletRed2 :: X11Color
VioletRed3 :: X11Color
VioletRed4 :: X11Color
Wheat :: X11Color
Wheat1 :: X11Color
Wheat2 :: X11Color
Wheat3 :: X11Color
Wheat4 :: X11Color
White :: X11Color
WhiteSmoke :: X11Color
Yellow :: X11Color
Yellow1 :: X11Color
Yellow2 :: X11Color
Yellow3 :: X11Color
Yellow4 :: X11Color
YellowGreen :: X11Color

-- | Convert an <a>X11Color</a> to its equivalent <tt>Colour</tt> value.
--   Note that it uses <a>AlphaColour</a> because of <a>Transparent</a>;
--   all other <a>X11Color</a> values are completely opaque.
x11Colour :: X11Color -> AlphaColour Double
instance GHC.Read.Read Data.GraphViz.Attributes.Colors.X11.X11Color
instance GHC.Show.Show Data.GraphViz.Attributes.Colors.X11.X11Color
instance GHC.Enum.Enum Data.GraphViz.Attributes.Colors.X11.X11Color
instance GHC.Enum.Bounded Data.GraphViz.Attributes.Colors.X11.X11Color
instance GHC.Classes.Ord Data.GraphViz.Attributes.Colors.X11.X11Color
instance GHC.Classes.Eq Data.GraphViz.Attributes.Colors.X11.X11Color
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.Colors.X11.X11Color
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.Colors.X11.X11Color


-- | Graphviz comes with an SVG color scheme:
--   <a>http://www.graphviz.org/doc/info/colors.html#svg</a>
--   
--   However, in general use you probably want to use
--   <a>Data.GraphViz.Attributes.Colors.X11</a> instead, unless you are
--   only generating SVG images.
module Data.GraphViz.Attributes.Colors.SVG

-- | The SVG colors that Graphviz uses. Graphviz's list of colors also
--   duplicated all <tt>*Gray*</tt> colors with <tt>*Grey*</tt> ones;
--   parsing of an <a>SVGColor</a> which is specified using "grey" will
--   succeed.
data SVGColor
AliceBlue :: SVGColor
AntiqueWhite :: SVGColor
Aqua :: SVGColor
Aquamarine :: SVGColor
Azure :: SVGColor
Beige :: SVGColor
Bisque :: SVGColor
Black :: SVGColor
BlanchedAlmond :: SVGColor
Blue :: SVGColor
BlueViolet :: SVGColor
Brown :: SVGColor
Burlywood :: SVGColor
CadetBlue :: SVGColor
Chartreuse :: SVGColor
Chocolate :: SVGColor
Coral :: SVGColor
CornflowerBlue :: SVGColor
Cornsilk :: SVGColor
Crimson :: SVGColor
Cyan :: SVGColor
DarkBlue :: SVGColor
DarkCyan :: SVGColor
DarkGoldenrod :: SVGColor
DarkGray :: SVGColor
DarkGreen :: SVGColor
DarkKhaki :: SVGColor
DarkMagenta :: SVGColor
DarkOliveGreen :: SVGColor
DarkOrange :: SVGColor
DarkOrchid :: SVGColor
DarkRed :: SVGColor
DarkSalmon :: SVGColor
DarkSeaGreen :: SVGColor
DarkSlateBlue :: SVGColor
DarkSlateGray :: SVGColor
DarkTurquoise :: SVGColor
DarkViolet :: SVGColor
DeepPink :: SVGColor
DeepSkyBlue :: SVGColor
DimGray :: SVGColor
DodgerBlue :: SVGColor
Firebrick :: SVGColor
FloralWhite :: SVGColor
ForestGreen :: SVGColor
Fuchsia :: SVGColor
Gainsboro :: SVGColor
GhostWhite :: SVGColor
Gold :: SVGColor
Goldenrod :: SVGColor
Gray :: SVGColor
Green :: SVGColor
GreenYellow :: SVGColor
Honeydew :: SVGColor
HotPink :: SVGColor
IndianRed :: SVGColor
Indigo :: SVGColor
Ivory :: SVGColor
Khaki :: SVGColor
Lavender :: SVGColor
LavenderBlush :: SVGColor
LawnGreen :: SVGColor
LemonChiffon :: SVGColor
LightBlue :: SVGColor
LightCoral :: SVGColor
LightCyan :: SVGColor
LightGoldenrodYellow :: SVGColor
LightGray :: SVGColor
LightGreen :: SVGColor
LightPink :: SVGColor
LightSalmon :: SVGColor
LightSeaGreen :: SVGColor
LightSkyBlue :: SVGColor
LightSlateGray :: SVGColor
LightSteelBlue :: SVGColor
LightYellow :: SVGColor
Lime :: SVGColor
LimeGreen :: SVGColor
Linen :: SVGColor
Magenta :: SVGColor
Maroon :: SVGColor
MediumAquamarine :: SVGColor
MediumBlue :: SVGColor
MediumOrchid :: SVGColor
MediumPurple :: SVGColor
MediumSeaGreen :: SVGColor
MediumSlateBlue :: SVGColor
MediumSpringGreen :: SVGColor
MediumTurquoise :: SVGColor
MediumVioletRed :: SVGColor
MidnightBlue :: SVGColor
MintCream :: SVGColor
MistyRose :: SVGColor
Moccasin :: SVGColor
NavajoWhite :: SVGColor
Navy :: SVGColor
OldLace :: SVGColor
Olive :: SVGColor
OliveDrab :: SVGColor
Orange :: SVGColor
OrangeRed :: SVGColor
Orchid :: SVGColor
PaleGoldenrod :: SVGColor
PaleGreen :: SVGColor
PaleTurquoise :: SVGColor
PaleVioletRed :: SVGColor
PapayaWhip :: SVGColor
PeachPuff :: SVGColor
Peru :: SVGColor
Pink :: SVGColor
Plum :: SVGColor
PowderBlue :: SVGColor
Purple :: SVGColor
Red :: SVGColor
RosyBrown :: SVGColor
RoyalBlue :: SVGColor
SaddleBrown :: SVGColor
Salmon :: SVGColor
SandyBrown :: SVGColor
SeaGreen :: SVGColor
SeaShell :: SVGColor
Sienna :: SVGColor
Silver :: SVGColor
SkyBlue :: SVGColor
SlateBlue :: SVGColor
SlateGray :: SVGColor
Snow :: SVGColor
SpringGreen :: SVGColor
SteelBlue :: SVGColor
Tan :: SVGColor
Teal :: SVGColor
Thistle :: SVGColor
Tomato :: SVGColor
Turquoise :: SVGColor
Violet :: SVGColor
Wheat :: SVGColor
White :: SVGColor
WhiteSmoke :: SVGColor
Yellow :: SVGColor
YellowGreen :: SVGColor

-- | Convert an <a>SVGColor</a> to its equivalent <a>Colour</a> value.
svgColour :: SVGColor -> Colour Double
instance GHC.Read.Read Data.GraphViz.Attributes.Colors.SVG.SVGColor
instance GHC.Show.Show Data.GraphViz.Attributes.Colors.SVG.SVGColor
instance GHC.Enum.Enum Data.GraphViz.Attributes.Colors.SVG.SVGColor
instance GHC.Enum.Bounded Data.GraphViz.Attributes.Colors.SVG.SVGColor
instance GHC.Classes.Ord Data.GraphViz.Attributes.Colors.SVG.SVGColor
instance GHC.Classes.Eq Data.GraphViz.Attributes.Colors.SVG.SVGColor
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.Colors.SVG.SVGColor
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.Colors.SVG.SVGColor


-- | You almost definitely do <i>not</i> want to use this module. It is
--   only defined for completeness when parsing existing Dot code.
--   
--   Graphviz contains a list of colors known as the /Brewer color
--   schemes/.
--   
--   These colors are available under an Apache-style license:
--   <a>http://www.graphviz.org/doc/info/colors.html#brewer_license</a>. As
--   such, they are not recommended for general use, and have only been
--   included in this package for completeness.
--   
--   The complete list of Brewer colors can be found at
--   <a>http://www.graphviz.org/doc/info/colors.html#brewer</a>.
module Data.GraphViz.Attributes.Colors.Brewer

-- | Specify which colour palette and how many colours it has. Note the
--   allowed values for the different <a>BrewerName</a>s.
data BrewerScheme
BScheme :: BrewerName -> Word8 -> BrewerScheme

-- | All of these have a minimum level value of <tt>3</tt>, with a maximum
--   of <tt>9</tt> unless otherwise specified.
data BrewerName

-- | Maximum of <tt>8</tt>.
Accent :: BrewerName
Blues :: BrewerName

-- | Maximum of <tt>11</tt>.
Brbg :: BrewerName
Bugn :: BrewerName
Bupu :: BrewerName

-- | Maximum of <tt>8</tt>.
Dark2 :: BrewerName
Gnbu :: BrewerName
Greens :: BrewerName
Greys :: BrewerName
Oranges :: BrewerName
Orrd :: BrewerName

-- | Maximum of <tt>12</tt>.
Paired :: BrewerName
Pastel1 :: BrewerName

-- | Maximum of <tt>8</tt>.
Pastel2 :: BrewerName

-- | Maximum of <tt>11</tt>.
Piyg :: BrewerName

-- | Maximum of <tt>11</tt>.
Prgn :: BrewerName
Pubu :: BrewerName
Pubugn :: BrewerName

-- | Maximum of <tt>11</tt>; note that the last two are listed after the
--   <tt><a>Purd</a></tt> values in the documentation.
Puor :: BrewerName
Purd :: BrewerName
Purples :: BrewerName

-- | Maximum of <tt>11</tt>; note that the last two are listed first.
Rdbu :: BrewerName

-- | Maximum of <tt>11</tt>; note that the last two are listed after the
--   <tt><a>Rdpu</a></tt> values in the documentation.
Rdgy :: BrewerName
Rdpu :: BrewerName

-- | Maximum of <tt>11</tt>.
Rdylbu :: BrewerName

-- | Maximum of <tt>11</tt>.
Rdylgn :: BrewerName
Reds :: BrewerName
Set1 :: BrewerName

-- | Maximum of <tt>8</tt>.
Set2 :: BrewerName

-- | Maximum of <tt>12</tt>.
Set3 :: BrewerName

-- | Maximum of <tt>11</tt>.
Spectral :: BrewerName
Ylgn :: BrewerName
Ylgnbu :: BrewerName
Ylorbr :: BrewerName
Ylorrd :: BrewerName

-- | This value should be between <tt>1</tt> and the level of the
--   <a>BrewerScheme</a> being used.
data BrewerColor
BC :: BrewerScheme -> Word8 -> BrewerColor
instance GHC.Read.Read Data.GraphViz.Attributes.Colors.Brewer.BrewerColor
instance GHC.Show.Show Data.GraphViz.Attributes.Colors.Brewer.BrewerColor
instance GHC.Classes.Ord Data.GraphViz.Attributes.Colors.Brewer.BrewerColor
instance GHC.Classes.Eq Data.GraphViz.Attributes.Colors.Brewer.BrewerColor


-- | This module defines the various colors, etc. for Graphviz. For
--   information on colors in general, see:
--   <a>http://graphviz.org/doc/info/attrs.html#k:color</a> For named
--   colors, see: <a>http://graphviz.org/doc/info/colors.html</a>
--   
--   Note that the ColorBrewer Color Schemes (shortened to just "Brewer"
--   for the rest of this module) are covered by the following license
--   (also available in the LICENSE file of this library):
--   <a>http://graphviz.org/doc/info/colors.html#brewer_license</a>
module Data.GraphViz.Attributes.Colors

-- | This represents the color schemes that Graphviz accepts.
data ColorScheme
X11 :: ColorScheme
SVG :: ColorScheme
Brewer :: BrewerScheme -> ColorScheme

-- | Defining a color for use with Graphviz. Note that named colors have
--   been split up into <a>Color</a>s and those based upon the Brewer color
--   schemes.
data Color
RGB :: Word8 -> Word8 -> Word8 -> Color
[red] :: Color -> Word8
[green] :: Color -> Word8
[blue] :: Color -> Word8
RGBA :: Word8 -> Word8 -> Word8 -> Word8 -> Color
[red] :: Color -> Word8
[green] :: Color -> Word8
[blue] :: Color -> Word8
[alpha] :: Color -> Word8

-- | The <a>hue</a>, <a>saturation</a> and <a>value</a> values must all be
--   <tt>0 &lt;= x &lt;=1</tt>.
HSV :: Double -> Double -> Double -> Color
[hue] :: Color -> Double
[saturation] :: Color -> Double
[value] :: Color -> Double
X11Color :: X11Color -> Color
SVGColor :: SVGColor -> Color
BrewerColor :: BrewerColor -> Color

-- | The sum of the optional weightings <i>must</i> sum to at most
--   <tt>1</tt>.
type ColorList = [WeightedColor]

-- | A <a>Color</a> tagged with an optional weighting.
data WeightedColor
WC :: Color -> Maybe Double -> WeightedColor
[wColor] :: WeightedColor -> Color

-- | Must be in range <tt>0 &lt;= W &lt;= 1</tt>.
[weighting] :: WeightedColor -> Maybe Double

-- | For colors without weightings.
toWC :: Color -> WeightedColor

-- | For a list of colors without weightings.
toColorList :: [Color] -> ColorList

-- | More easily convert named colors to an overall <a>Color</a> value.
class NamedColor nc
toColor :: NamedColor nc => nc -> Color
toWColor :: NamedColor nc => nc -> WeightedColor

-- | Attempt to convert a <a>Color</a> into a <a>Colour</a> value with an
--   alpha channel. The use of <a>Maybe</a> is because the RGB values of
--   the <a>Color</a>s haven't been stored here (primarily for licensing
--   reasons).
toColour :: Color -> Maybe (AlphaColour Double)

-- | Convert a <a>Colour</a> value to an <a>RGB</a> <a>Color</a>.
fromColour :: Colour Double -> Color

-- | Convert an <a>AlphaColour</a> to an <a>RGBA</a> <a>Color</a>. The
--   exception to this is for any <a>AlphaColour</a> which has
--   <tt>alphaChannel ac == 0</tt>; these are converted to <tt>X11Color
--   <a>Transparent</a></tt> (note that the <a>Show</a> instance for such
--   an <a>AlphaColour</a> is <tt>"transparent"</tt>).
fromAColour :: AlphaColour Double -> Color
instance GHC.Read.Read Data.GraphViz.Attributes.Colors.Color
instance GHC.Show.Show Data.GraphViz.Attributes.Colors.Color
instance GHC.Classes.Ord Data.GraphViz.Attributes.Colors.Color
instance GHC.Classes.Eq Data.GraphViz.Attributes.Colors.Color
instance GHC.Read.Read Data.GraphViz.Attributes.Colors.WeightedColor
instance GHC.Show.Show Data.GraphViz.Attributes.Colors.WeightedColor
instance GHC.Classes.Ord Data.GraphViz.Attributes.Colors.WeightedColor
instance GHC.Classes.Eq Data.GraphViz.Attributes.Colors.WeightedColor
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.Colors.Color
instance Data.GraphViz.Attributes.Colors.NamedColor Data.GraphViz.Attributes.Colors.Brewer.BrewerColor
instance Data.GraphViz.Attributes.Colors.NamedColor Data.GraphViz.Attributes.Colors.X11.X11Color
instance Data.GraphViz.Attributes.Colors.NamedColor Data.GraphViz.Attributes.Colors.SVG.SVGColor
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.Colors.WeightedColor
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.Colors.WeightedColor
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.Colors.Color


-- | This module is written to be imported qualified. It defines the syntax
--   for HTML-like values for use in Graphviz. Please note that these
--   values are <i>not</i> really HTML, but the term "HTML" is used
--   throughout as it is less cumbersome than "HTML-like". To be able to
--   use this, the version of Graphviz must be at least 1.10. For more
--   information, please see:
--   <a>http://graphviz.org/doc/info/shapes.html#html</a>
--   
--   The actual definition of the syntax specifies that these types must be
--   valid XML syntax. As such, this assumed when printing and parsing,
--   though the correct escape/descaping for <tt>"</tt>, <tt>&amp;</tt>,
--   <tt>&lt;</tt> and <tt>&gt;</tt> are automatically done when printing
--   and parsing.
--   
--   Differences from how Graphviz treats HTML-like values:
--   
--   <ul>
--   <li>Graphviz only specifies the above-listed characters must be
--   escaped; however, internally it also escapes <tt>-</tt>, <tt>'</tt>
--   and multiple sequences of spaces. This library attempts to match this
--   behaviour. Please let me know if this behaviour (especially about
--   escaping multiple spaces) is unwanted.</li>
--   <li>When parsing escaped HTML characters, numeric escapes are
--   converted to the corresponding character as are the various characters
--   listed above; all other escaped characters (apart from those listed
--   above) are silently ignored and removed from the input (since
--   technically these must be valid <i>XML</i>, which doesn't recognise as
--   many named escape characters as does HTML).</li>
--   <li>All whitespace read in is kept (even if Graphviz would ignore
--   multiple whitespace characters); when printing them, however, they are
--   replaced with non-breaking spaces. As such, if multiple literal
--   whitespace characters are used in a sequence, then the result of
--   parsing and then printing some Dot code will <i>not</i> be the same as
--   the initial Dot code. Furthermore, all whitespace characters are
--   printed as spaces.</li>
--   <li>It is assumed that all parsed <tt>&amp;</tt> values are the
--   beginning of an XML escape sequence (which <i>must</i> finish with a
--   <tt>;</tt> character).</li>
--   <li>There should be no pre-escaped characters in values; when
--   printing, the <tt>&amp;</tt> will get escaped without considering if
--   that is an escaped character.</li>
--   </ul>
module Data.GraphViz.Attributes.HTML

-- | The overall type for HTML-like labels. Fundamentally, HTML-like values
--   in Graphviz are either textual (i.e. a single element with formatting)
--   or a table. Note that <a>Label</a> values can be nested via
--   <a>LabelCell</a>.
data Label
Text :: Text -> Label
Table :: Table -> Label

-- | Represents a textual component of an HTML-like label. It is assumed
--   that a <a>Label</a> list is non-empty. It is preferable to "group"
--   <a>Str</a> values together rather than have individual ones. Note that
--   when printing, the individual values are concatenated together without
--   spaces, and when parsing anything that isn't a tag is assumed to be a
--   <a>Str</a>: that is, something like "<tt>&lt;BR/&gt; &lt;BR/&gt;</tt>"
--   is parsed as:
--   
--   <pre>
--   [Newline [], Str " ", Newline []]
--   </pre>
type Text = [TextItem]

-- | Textual items in HTML-like labels.
data TextItem
Str :: Text -> TextItem

-- | Only accepts an optional <a>Attribute</a> <a>Attribute</a>; defined
--   this way for ease of printing/parsing.
Newline :: Attributes -> TextItem
Font :: Attributes -> Text -> TextItem

-- | Only available in Graphviz &gt;= 2.28.0.
Format :: Format -> Text -> TextItem
data Format
Italics :: Format
Bold :: Format
Underline :: Format

-- | Requires Graphviz &gt;= 2.38.0.
Overline :: Format
Subscript :: Format
Superscript :: Format

-- | A table in HTML-like labels. Tables are optionally wrapped in overall
--   <tt>FONT</tt> tags.
data Table
HTable :: Maybe Attributes -> Attributes -> [Row] -> Table

-- | Optional <tt>FONT</tt> attributes. <tt><a>Just</a> []</tt> denotes
--   empty <tt>FONT</tt> tags; <tt><a>Nothing</a></tt> denotes no such
--   tags.
[tableFontAttrs] :: Table -> Maybe Attributes
[tableAttrs] :: Table -> Attributes

-- | This list is assumed to be non-empty.
[tableRows] :: Table -> [Row]

-- | A row in a <a>Label</a>. The list of <a>Cell</a> values is assumed to
--   be non-empty.
data Row
Cells :: [Cell] -> Row

-- | Should be between <a>Cells</a> values, requires Graphviz &gt;= 2.29.0
HorizontalRule :: Row

-- | Cells either recursively contain another <a>Label</a> or else a path
--   to an image file.
data Cell
LabelCell :: Attributes -> Label -> Cell
ImgCell :: Attributes -> Img -> Cell

-- | Should be between <a>LabelCell</a> or <a>ImgCell</a> values, requires
--   Graphviz &gt;= 2.29.0
VerticalRule :: Cell

-- | The path to an image; accepted <a>Attributes</a> are <a>Attribute</a>
--   and <a>Src</a>.
newtype Img
Img :: Attributes -> Img

-- | The various HTML-like label-specific attributes being used.
type Attributes = [Attribute]

-- | Note that not all <a>Attribute</a> values are valid everywhere: see
--   the comments for each one on where it is valid.
data Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>, <a>Newline</a>.
Align :: Align -> Attribute

-- | Valid for: <a>Cell</a>.
BAlign :: Align -> Attribute

-- | Valid for: <a>Label</a> (including <a>tableFontAttrs</a>),
--   <a>Cell</a>, <a>Font</a>.
BGColor :: Color -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>. Default is <tt>1</tt>;
--   <tt>0</tt> represents no border.
Border :: Word8 -> Attribute

-- | Valid for: <a>Label</a>. Default is <tt>1</tt>; <tt>0</tt> represents
--   no border.
CellBorder :: Word8 -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>. Default is <tt>2</tt>.
CellPadding :: Word8 -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>. Default is <tt>2</tt>; maximum
--   is <tt>127</tt>.
CellSpacing :: Word8 -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>.
Color :: Color -> Attribute

-- | Valid for: <a>Cell</a>. Default is <tt>1</tt>.
ColSpan :: Word16 -> Attribute

-- | Valid for: <a>Label</a>. Requires Graphviz &gt;= 2.40.1
Columns :: CellFormat -> Attribute

-- | Valid for: <a>tableFontAttrs</a>, <a>Font</a>.
Face :: Text -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>. Default is
--   <tt><a>False</a></tt>.
FixedSize :: Bool -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>. Default is <tt>0</tt>. Requires
--   Graphviz &gt;= 2.40.1
GradientAngle :: Int -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>.
Height :: Word16 -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>.
HRef :: Text -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>. Requires Graphviz &gt;= 2.29.0
ID :: Text -> Attribute

-- | Valid for: <a>tableFontAttrs</a>, <a>Font</a>.
PointSize :: Double -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>.
Port :: PortName -> Attribute

-- | Valid for: <a>Label</a>. Requires Graphviz &gt;= 2.40.1
Rows :: CellFormat -> Attribute

-- | Valid for: <a>Cell</a>.
RowSpan :: Word16 -> Attribute

-- | Valid for: <a>Img</a>.
Scale :: Scale -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>. Default is <tt>[<a>LeftSide</a>,
--   <a>TopSide</a>, <a>RightSide</a>, <a>BottomSide</a>]</tt>. Requires
--   Graphviz &gt;= 2.40.1
Sides :: [Side] -> Attribute

-- | Valid for: <a>Img</a>.
Src :: FilePath -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>. Requires Graphviz &gt;= 2.40.1
Style :: Style -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>.
Target :: Text -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>. Has an alias of
--   <tt>TOOLTIP</tt>.
Title :: Text -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>.
VAlign :: VAlign -> Attribute

-- | Valid for: <a>Label</a>, <a>Cell</a>.
Width :: Word16 -> Attribute

-- | Specifies horizontal placement. When an object is allocated more space
--   than required, this value determines where the extra space is placed
--   left and right of the object.
data Align
HLeft :: Align

-- | Default value.
HCenter :: Align
HRight :: Align

-- | <a>LabelCell</a> values only; aligns lines of text using the full cell
--   width. The alignment of a line is determined by its (possibly
--   implicit) associated <a>Newline</a> element.
HText :: Align

-- | Specifies vertical placement. When an object is allocated more space
--   than required, this value determines where the extra space is placed
--   above and below the object.
data VAlign
HTop :: VAlign

-- | Default value.
HMiddle :: VAlign
HBottom :: VAlign
data CellFormat
RuleBetween :: CellFormat

-- | Specifies how an image will use any extra space available in its cell.
--   If undefined, the image inherits the value of the <tt>ImageScale</tt>
--   attribute.
data Scale

-- | Default value.
NaturalSize :: Scale
ScaleUniformly :: Scale
ExpandWidth :: Scale
ExpandHeight :: Scale
ExpandBoth :: Scale

-- | Which sides of a border in a cell or table should be drawn, if a
--   border is drawn.
data Side
LeftSide :: Side
RightSide :: Side
TopSide :: Side
BottomSide :: Side
data Style

-- | Valid for <a>Label</a>
Rounded :: Style

-- | Valid for <a>Label</a>, <a>Cell</a>.
Radial :: Style
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Format
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Format
instance GHC.Enum.Enum Data.GraphViz.Attributes.HTML.Format
instance GHC.Enum.Bounded Data.GraphViz.Attributes.HTML.Format
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Format
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Format
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Align
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Align
instance GHC.Enum.Enum Data.GraphViz.Attributes.HTML.Align
instance GHC.Enum.Bounded Data.GraphViz.Attributes.HTML.Align
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Align
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Align
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.VAlign
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.VAlign
instance GHC.Enum.Enum Data.GraphViz.Attributes.HTML.VAlign
instance GHC.Enum.Bounded Data.GraphViz.Attributes.HTML.VAlign
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.VAlign
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.VAlign
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.CellFormat
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.CellFormat
instance GHC.Enum.Enum Data.GraphViz.Attributes.HTML.CellFormat
instance GHC.Enum.Bounded Data.GraphViz.Attributes.HTML.CellFormat
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.CellFormat
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.CellFormat
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Scale
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Scale
instance GHC.Enum.Enum Data.GraphViz.Attributes.HTML.Scale
instance GHC.Enum.Bounded Data.GraphViz.Attributes.HTML.Scale
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Scale
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Scale
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Side
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Side
instance GHC.Enum.Enum Data.GraphViz.Attributes.HTML.Side
instance GHC.Enum.Bounded Data.GraphViz.Attributes.HTML.Side
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Side
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Side
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Style
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Style
instance GHC.Enum.Enum Data.GraphViz.Attributes.HTML.Style
instance GHC.Enum.Bounded Data.GraphViz.Attributes.HTML.Style
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Style
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Style
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Attribute
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Attribute
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Attribute
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Attribute
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Img
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Img
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Img
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Img
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.TextItem
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.TextItem
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.TextItem
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.TextItem
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Cell
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Cell
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Cell
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Cell
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Row
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Row
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Row
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Row
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Table
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Table
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Table
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Table
instance GHC.Read.Read Data.GraphViz.Attributes.HTML.Label
instance GHC.Show.Show Data.GraphViz.Attributes.HTML.Label
instance GHC.Classes.Ord Data.GraphViz.Attributes.HTML.Label
instance GHC.Classes.Eq Data.GraphViz.Attributes.HTML.Label
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Label
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Label
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Table
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Table
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Row
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Row
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Cell
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Cell
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.TextItem
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.TextItem
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Img
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Img
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Attribute
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Attribute
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Style
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Style
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Side
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Side
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Scale
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Scale
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.CellFormat
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.CellFormat
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.VAlign
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.VAlign
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Align
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Align
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.HTML.Format
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.HTML.Format


-- | If you are just using graphviz to create basic Dot graphs, then you
--   probably want to use <a>Data.GraphViz.Attributes</a> rather than this
--   module.
--   
--   This module defines the various attributes that different parts of a
--   Graphviz graph can have. These attributes are based on the
--   documentation found at: <a>http://graphviz.org/doc/info/attrs.html</a>
--   
--   For more information on usage, etc. please see that document.
--   
--   A summary of known current constraints/limitations/differences:
--   
--   <ul>
--   <li>Note that for an edge, in <i>Dot</i> parlance if the edge goes
--   from <i>A</i> to <i>B</i>, then <i>A</i> is the tail node and <i>B</i>
--   is the head node (since <i>A</i> is at the tail end of the
--   arrow).</li>
--   <li><tt>ColorList</tt>, <tt>DoubleList</tt> and <tt>PointfList</tt>
--   are defined as actual lists (<tt><a>LayerList</a></tt> needs a newtype
--   for other reasons). All of these are assumed to be non-empty
--   lists.</li>
--   <li>For the various <tt>*Color</tt> attributes that take in a list of
--   <a>Attribute</a> values, usually only one color is used. The
--   <tt>Color</tt> attribute for edges allows multiple values; for other
--   attributes, two values are supported for gradient fills in Graphviz
--   &gt;= 2.29.0.</li>
--   <li>Style is implemented as a list of <a>StyleItem</a> values; note
--   that empty lists are not allowed.</li>
--   <li>A lot of values have a possible value of <tt>none</tt>. These now
--   have custom constructors. In fact, most constructors have been
--   expanded upon to give an idea of what they represent rather than using
--   generic terms.</li>
--   <li><a>Rect</a> uses two <a>Point</a> values to denote the lower-left
--   and top-right corners.</li>
--   <li>The two <a>LabelLoc</a> attributes have been combined.</li>
--   <li><tt>SplineType</tt> has been replaced with
--   <tt>[<a>Spline</a>]</tt>.</li>
--   <li>Only polygon-based <a>Attribute</a>s are available.</li>
--   <li>Not every <a>Attribute</a> is fully documented/described. However,
--   all those which have specific allowed values should be covered.</li>
--   <li>Deprecated <a>Attribute</a> algorithms are not defined.
--   Furthermore, the ability to specify an integer prefix for use with the
--   fdp layout is <i>not</i> supported.</li>
--   <li>The global <tt>Orientation</tt> attribute is not defined, as it is
--   difficult to distinguish from the node-based <a>Orientation</a>
--   <a>Attribute</a>; also, its behaviour is duplicated by
--   <a>Rotate</a>.</li>
--   <li>The <tt>charset</tt> attribute is not available, as graphviz only
--   supports UTF-8 encoding (as it is not currently feasible nor needed to
--   also support Latin1 encoding).</li>
--   <li>In Graphviz, when a node or edge has a list of attributes, the
--   colorscheme which is used to identify a color can be set <i>after</i>
--   that color (e.g. <tt>[colorscheme=x11,color=grey,colorscheme=svg]</tt>
--   uses the svg colorscheme's definition of grey, which is different from
--   the x11 one. Instead, graphviz parses them in order.</li>
--   </ul>
module Data.GraphViz.Attributes.Complete

-- | Attributes are used to customise the layout and design of Dot graphs.
--   Care must be taken to ensure that the attribute you use is valid, as
--   not all attributes can be used everywhere.
data Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>0.99</tt>; <i>Minimum</i>:
--   <tt>0.0</tt>; <i>Notes</i>: <a>Neato</a> only
Damping :: Double -> Attribute

-- | <i>Valid for</i>: GC; <i>Default</i>: <tt>0.3</tt>; <i>Minimum</i>:
--   <tt>0</tt>; <i>Notes</i>: <a>Sfdp</a>, <a>Fdp</a> only
K :: Double -> Attribute

-- | <i>Valid for</i>: ENGC; <i>Default</i>: none; <i>Notes</i>: svg,
--   postscript, map only
URL :: EscString -> Attribute

-- | <i>Valid for</i>: NC; <i>Default</i>: <tt>1.0</tt>; <i>Minimum</i>:
--   <tt>&gt;0</tt>; <i>Notes</i>: <a>Patchwork</a> only, requires Graphviz
--   &gt;= 2.30.0
Area :: Double -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>normal</a></tt>
ArrowHead :: ArrowType -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>1.0</tt>; <i>Minimum</i>:
--   <tt>0.0</tt>
ArrowSize :: Double -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>normal</a></tt>
ArrowTail :: ArrowType -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: none; <i>Notes</i>: xdot only
Background :: Text -> Attribute

-- | <i>Valid for</i>: G; <i>Notes</i>: write only
BoundingBox :: Rect -> Attribute

-- | <i>Valid for</i>: GC; <i>Default</i>: <tt>[]</tt>
BgColor :: ColorList -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>
Center :: Bool -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>Local</a></tt>;
--   <i>Notes</i>: <a>Dot</a> only
ClusterRank :: ClusterMode -> Attribute

-- | <i>Valid for</i>: ENC; <i>Default</i>: <tt>[<a>WC</a> (<a>Color</a>
--   <a>Black</a>) Nothing]</tt>
Color :: ColorList -> Attribute

-- | <i>Valid for</i>: ENCG; <i>Default</i>: <tt><a>X11</a></tt>
ColorScheme :: ColorScheme -> Attribute

-- | <i>Valid for</i>: ENG; <i>Default</i>: <tt>""</tt>
Comment :: Text -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>; <i>Notes</i>: <a>Dot</a> only
Compound :: Bool -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>
Concentrate :: Bool -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>True</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>; <i>Notes</i>: <a>Dot</a> only
Constraint :: Bool -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>
Decorate :: Bool -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>1+(avg.
--   len)*sqrt(abs(V))</tt> (unable to statically define); <i>Minimum</i>:
--   The value of <a>Epsilon</a>.; <i>Notes</i>: <a>Neato</a> only, only if
--   <tt><a>Attribute</a> <a>DontPack</a></tt>
DefaultDist :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>2</tt>; <i>Minimum</i>:
--   <tt>2</tt>; <i>Notes</i>: maximum of <tt>10</tt>; <a>Sfdp</a>,
--   <a>Fdp</a>, <a>Neato</a> only
Dim :: Int -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>2</tt>; <i>Minimum</i>:
--   <tt>2</tt>; <i>Notes</i>: maximum of <tt>10</tt>; <a>Sfdp</a>,
--   <a>Fdp</a>, <a>Neato</a> only
Dimen :: Int -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>Forward</a></tt>
--   (directed), <tt><a>NoDir</a></tt> (undirected)
Dir :: DirType -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>NoConstraints</a></tt>;
--   <i>Parsing Default</i>: <a>EdgeConstraints</a>; <i>Notes</i>:
--   <a>Neato</a> only
DirEdgeConstraints :: DEConstraints -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt>0.0</tt>; <i>Minimum</i>:
--   <tt>-100.0</tt>
Distortion :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>96.0</tt>, <tt>0.0</tt>;
--   <i>Notes</i>: svg, bitmap output only; "resolution" is a synonym
DPI :: Double -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg,
--   map only
EdgeURL :: EscString -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: none; <i>Notes</i>: svg, map only
EdgeTarget :: EscString -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg,
--   cmap only
EdgeTooltip :: EscString -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>.0001 * # nodes</tt>
--   (<tt>mode == <a>KK</a></tt>), <tt>.0001</tt> (<tt>mode ==
--   <a>Major</a></tt>); <i>Notes</i>: <a>Neato</a> only
Epsilon :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>DVal</a> 3</tt>;
--   <i>Notes</i>: not <a>Dot</a>
ESep :: DPoint -> Attribute

-- | <i>Valid for</i>: NEC; <i>Default</i>: <tt>[<a>WC</a> (<a>Color</a>
--   <tt>LightGray</tt>) Nothing]</tt> (nodes), <tt>[<a>WC</a>
--   (<a>Color</a> <a>Black</a>) Nothing]</tt> (clusters)
FillColor :: ColorList -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt><a>GrowAsNeeded</a></tt>;
--   <i>Parsing Default</i>: <a>SetNodeSize</a>
FixedSize :: NodeSize -> Attribute

-- | <i>Valid for</i>: ENGC; <i>Default</i>: <tt><a>Color</a>
--   <a>Black</a></tt>
FontColor :: Color -> Attribute

-- | <i>Valid for</i>: ENGC; <i>Default</i>: <tt>"Times-Roman"</tt>
FontName :: Text -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>SvgNames</a></tt>;
--   <i>Notes</i>: svg only
FontNames :: SVGFontNames -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: system dependent
FontPath :: Paths -> Attribute

-- | <i>Valid for</i>: ENGC; <i>Default</i>: <tt>14.0</tt>; <i>Minimum</i>:
--   <tt>1.0</tt>
FontSize :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>True</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>; <i>Notes</i>: only for <a>XLabel</a>
--   attributes, requires Graphviz &gt;= 2.29.0
ForceLabels :: Bool -> Attribute

-- | <i>Valid for</i>: NCG; <i>Default</i>: 0; <i>Notes</i>: requires
--   Graphviz &gt;= 2.29.0
GradientAngle :: Int -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt>""</tt>; <i>Notes</i>:
--   <a>Dot</a> only
Group :: Text -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg,
--   map only
HeadURL :: EscString -> Attribute

-- | <i>Valid for</i>: E; <i>Notes</i>: write only, requires Graphviz &gt;=
--   2.30.0
Head_LP :: Point -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>True</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>
HeadClip :: Bool -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>StrLabel</a> ""</tt>
HeadLabel :: Label -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>PortPos</a>
--   <a>CenterPoint</a></tt>
HeadPort :: PortPos -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: none; <i>Notes</i>: svg, map only
HeadTarget :: EscString -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg,
--   cmap only
HeadTooltip :: EscString -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt>0.5</tt>; <i>Minimum</i>:
--   <tt>0.02</tt>
Height :: Double -> Attribute

-- | <i>Valid for</i>: GNE; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg,
--   postscript, map only
ID :: EscString -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt>""</tt>
Image :: Text -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>Paths</a> []</tt>;
--   <i>Notes</i>: Printing and parsing is OS-specific, requires Graphviz
--   &gt;= 2.29.0
ImagePath :: Paths -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt><a>NoScale</a></tt>;
--   <i>Parsing Default</i>: <a>UniformScale</a>
ImageScale :: ScaleType -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: none; <i>Notes</i>: <a>Fdp</a>,
--   <a>Neato</a> only, a value of <tt>0</tt> is equivalent to being
--   <tt>72</tt>, requires Graphviz &gt;= 2.36.0
InputScale :: Double -> Attribute

-- | <i>Valid for</i>: ENGC; <i>Default</i>: <tt><a>StrLabel</a> "\N"</tt>
--   (nodes), <tt><a>StrLabel</a> ""</tt> (otherwise)
Label :: Label -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg,
--   map only
LabelURL :: EscString -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>NotEdgeLabel</a></tt>;
--   <i>Notes</i>: <a>Sfdp</a> only, requires Graphviz &gt;= 2.28.0
LabelScheme :: LabelScheme -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>-25.0</tt>; <i>Minimum</i>:
--   <tt>-180.0</tt>
LabelAngle :: Double -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>1.0</tt>; <i>Minimum</i>:
--   <tt>0.0</tt>
LabelDistance :: Double -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>
LabelFloat :: Bool -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>Color</a>
--   <a>Black</a></tt>
LabelFontColor :: Color -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>"Times-Roman"</tt>
LabelFontName :: Text -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>14.0</tt>; <i>Minimum</i>:
--   <tt>1.0</tt>
LabelFontSize :: Double -> Attribute

-- | <i>Valid for</i>: GC; <i>Default</i>: <tt><a>JCenter</a></tt>
LabelJust :: Justification -> Attribute

-- | <i>Valid for</i>: GCN; <i>Default</i>: <tt><a>VTop</a></tt>
--   (clusters), <tt><a>VBottom</a></tt> (root graphs),
--   <tt><a>VCenter</a></tt> (nodes)
LabelLoc :: VerticalPlacement -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: none; <i>Notes</i>: svg, map only
LabelTarget :: EscString -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg,
--   cmap only
LabelTooltip :: EscString -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>
Landscape :: Bool -> Attribute

-- | <i>Valid for</i>: ENC; <i>Default</i>: <tt>[]</tt>
Layer :: LayerRange -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>LLSep</a> ","</tt>;
--   <i>Notes</i>: requires Graphviz &gt;= 2.30.0
LayerListSep :: LayerListSep -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>LL</a> []</tt>
Layers :: LayerList -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>[]</tt>
LayerSelect :: LayerRange -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>LSep</a> " :t"</tt>
LayerSep :: LayerSep -> Attribute

-- | <i>Valid for</i>: G
Layout :: GraphvizCommand -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>1.0</tt> (<a>Neato</a>),
--   <tt>0.3</tt> (<a>Fdp</a>); <i>Notes</i>: <a>Fdp</a>, <a>Neato</a> only
Len :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>maxBound</a></tt>;
--   <i>Minimum</i>: <tt>0</tt>; <i>Notes</i>: <a>Sfdp</a> only
Levels :: Int -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>0.0</tt>; <i>Notes</i>:
--   <a>Neato</a> only
LevelsGap :: Double -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>:
--   <a>Dot</a> only
LHead :: Text -> Attribute

-- | <i>Valid for</i>: GC; <i>Notes</i>: write only, requires Graphviz
--   &gt;= 2.28.0
LHeight :: Double -> Attribute

-- | <i>Valid for</i>: EGC; <i>Notes</i>: write only
LPos :: Point -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>:
--   <a>Dot</a> only
LTail :: Text -> Attribute

-- | <i>Valid for</i>: GC; <i>Notes</i>: write only, requires Graphviz
--   &gt;= 2.28.0
LWidth :: Double -> Attribute

-- | <i>Valid for</i>: NGC; <i>Default</i>: device dependent
Margin :: DPoint -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>100 * # nodes</tt> (<tt>mode
--   == <a>KK</a></tt>), <tt>200</tt> (<tt>mode == <a>Major</a></tt>),
--   <tt>600</tt> (<a>Fdp</a>); <i>Notes</i>: <a>Fdp</a>, <a>Neato</a> only
MaxIter :: Int -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>1.0</tt>; <i>Notes</i>:
--   <a>Dot</a> only
MCLimit :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>1.0</tt>; <i>Minimum</i>:
--   <tt>0.0</tt>; <i>Notes</i>: <a>Circo</a> only
MinDist :: Double -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>1</tt>; <i>Minimum</i>:
--   <tt>0</tt>; <i>Notes</i>: <a>Dot</a> only
MinLen :: Int -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>Major</a></tt> (actually
--   <tt><a>Spring</a></tt> for <a>Sfdp</a>, but this isn't used as a
--   default in this library); <i>Notes</i>: <a>Neato</a>, <a>Sfdp</a> only
Mode :: ModeType -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>ShortPath</a></tt>;
--   <i>Notes</i>: <a>Neato</a> only
Model :: Model -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>; <i>Notes</i>: <a>Neato</a> only; requires
--   the Mosek software
Mosek :: Bool -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>0.25</tt>; <i>Minimum</i>:
--   <tt>0.02</tt>
NodeSep :: Double -> Attribute

-- | <i>Valid for</i>: GCNE; <i>Default</i>: <tt><a>False</a></tt>;
--   <i>Parsing Default</i>: <a>True</a>
NoJustify :: Bool -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>NotNormalized</a></tt>;
--   <i>Parsing Default</i>: <a>IsNormalized</a>; <i>Notes</i>: not
--   <a>Dot</a>
Normalize :: Normalized -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>; <i>Notes</i>: <a>Neato</a> only, requires
--   Graphviz &gt;= 2.38.0
NoTranslate :: Bool -> Attribute

-- | <i>Valid for</i>: G; <i>Notes</i>: <a>Dot</a> only
Nslimit :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Notes</i>: <a>Dot</a> only
Nslimit1 :: Double -> Attribute

-- | <i>Valid for</i>: GN; <i>Default</i>: none; <i>Notes</i>: <a>Dot</a>
--   only
Ordering :: Order -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt>0.0</tt>; <i>Minimum</i>:
--   <tt>360.0</tt>
Orientation :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>BreadthFirst</a></tt>
OutputOrder :: OutputMode -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>KeepOverlaps</a></tt>;
--   <i>Parsing Default</i>: <a>KeepOverlaps</a>; <i>Notes</i>: not
--   <a>Dot</a>
Overlap :: Overlap -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>-4</tt>; <i>Minimum</i>:
--   <tt>-1.0e10</tt>; <i>Notes</i>: <a>PrismOverlap</a> only
OverlapScaling :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>True</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>; <i>Notes</i>: <a>PrismOverlap</a> only,
--   requires Graphviz &gt;= 2.36.0
OverlapShrink :: Bool -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>DontPack</a></tt>;
--   <i>Parsing Default</i>: <a>DoPack</a>
Pack :: Pack -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>PackNode</a></tt>
PackMode :: PackMode -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>DVal</a> 0.0555</tt> (4
--   points)
Pad :: DPoint -> Attribute

-- | <i>Valid for</i>: G
Page :: Point -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>Bl</a></tt>
PageDir :: PageDir -> Attribute

-- | <i>Valid for</i>: C; <i>Default</i>: <tt><a>Color</a>
--   <a>Black</a></tt>
PenColor :: Color -> Attribute

-- | <i>Valid for</i>: CNE; <i>Default</i>: <tt>1.0</tt>; <i>Minimum</i>:
--   <tt>0.0</tt>
PenWidth :: Double -> Attribute

-- | <i>Valid for</i>: NC; <i>Default</i>: shape default (nodes),
--   <tt>1</tt> (clusters); <i>Minimum</i>: 0
Peripheries :: Int -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>; <i>Notes</i>: <a>Fdp</a>, <a>Neato</a> only
Pin :: Bool -> Attribute

-- | <i>Valid for</i>: EN
Pos :: Pos -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>NormalQT</a></tt>;
--   <i>Parsing Default</i>: <a>NormalQT</a>; <i>Notes</i>: <a>Sfdp</a>
--   only
QuadTree :: QuadType -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>0.0</tt>; <i>Minimum</i>:
--   <tt>0.0</tt>
Quantum :: Double -> Attribute

-- | <i>Valid for</i>: S; <i>Notes</i>: <a>Dot</a> only
Rank :: RankType -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>FromTop</a></tt>;
--   <i>Notes</i>: <a>Dot</a> only
RankDir :: RankDir -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>[0.5]</tt> (<a>Dot</a>),
--   <tt>[1.0]</tt> (<tt>Twopi</tt>); <i>Minimum</i>: <tt>[0.02]</tt>;
--   <i>Notes</i>: <tt>Twopi</tt>, <a>Dot</a> only
RankSep :: [Double] -> Attribute

-- | <i>Valid for</i>: G
Ratio :: Ratios -> Attribute

-- | <i>Valid for</i>: N; <i>Notes</i>: write only
Rects :: [Rect] -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>
Regular :: Bool -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>False</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>; <i>Notes</i>: <a>Dot</a> only
ReMinCross :: Bool -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>1.0</tt>; <i>Minimum</i>:
--   <tt>0.0</tt>; <i>Notes</i>: <a>Sfdp</a> only
RepulsiveForce :: Double -> Attribute

-- | <i>Valid for</i>: GN; <i>Default</i>: <tt><a>NodeName</a> ""</tt>
--   (graphs), <tt><a>NotCentral</a></tt> (nodes); <i>Parsing Default</i>:
--   <a>IsCentral</a>; <i>Notes</i>: <a>Circo</a>, <tt>Twopi</tt> only
Root :: Root -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>0</tt>
Rotate :: Int -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>0</tt>; <i>Notes</i>:
--   <a>Sfdp</a> only, requires Graphviz &gt;= 2.28.0
Rotation :: Double -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>:
--   <a>Dot</a> only
SameHead :: Text -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>:
--   <a>Dot</a> only
SameTail :: Text -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt>8</tt> (output), <tt>20</tt>
--   (overlap and image maps)
SamplePoints :: Int -> Attribute

-- | <i>Valid for</i>: G; <i>Notes</i>: Not <a>Dot</a>, requires Graphviz
--   &gt;= 2.28.0 (&gt;= 2.38.0 for anything except <a>TwoPi</a>)
Scale :: DPoint -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>30</tt>; <i>Notes</i>:
--   <a>Dot</a> only
SearchSize :: Int -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>DVal</a> 4</tt>;
--   <i>Notes</i>: not <a>Dot</a>
Sep :: DPoint -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt><a>Ellipse</a></tt>
Shape :: Shape -> Attribute

-- | <i>Valid for</i>: ENG; <i>Default</i>: <tt>0</tt>; <i>Minimum</i>:
--   <tt>0</tt>; <i>Notes</i>: <a>Dot</a> only; used for debugging by
--   printing PostScript guide boxes
ShowBoxes :: Int -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt>4</tt>; <i>Minimum</i>:
--   <tt>0</tt>
Sides :: Int -> Attribute

-- | <i>Valid for</i>: G
Size :: GraphSize -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt>0.0</tt>; <i>Minimum</i>:
--   <tt>-100.0</tt>
Skew :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>NoSmooth</a></tt>;
--   <i>Notes</i>: <a>Sfdp</a> only
Smoothing :: SmoothType -> Attribute

-- | <i>Valid for</i>: GCN; <i>Default</i>: <tt>0</tt>; <i>Minimum</i>:
--   <tt>0</tt>
SortV :: Word16 -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>SplineEdges</a></tt>
--   (<a>Dot</a>), <tt><a>LineEdges</a></tt> (other); <i>Parsing
--   Default</i>: <a>SplineEdges</a>
Splines :: EdgeType -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt><a>StartStyleSeed</a>
--   <a>RandomStyle</a> seed</tt> for some unknown fixed seed.;
--   <i>Notes</i>: <a>Fdp</a>, <a>Neato</a> only
Start :: StartType -> Attribute

-- | <i>Valid for</i>: ENCG
Style :: [StyleItem] -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg
--   only
StyleSheet :: Text -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg,
--   map only
TailURL :: EscString -> Attribute

-- | <i>Valid for</i>: E; <i>Notes</i>: write only, requires Graphviz &gt;=
--   2.30.0
Tail_LP :: Point -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>True</a></tt>; <i>Parsing
--   Default</i>: <a>True</a>
TailClip :: Bool -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>StrLabel</a> ""</tt>
TailLabel :: Label -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>PortPos</a>
--   <a>CenterPoint</a></tt>
TailPort :: PortPos -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: none; <i>Notes</i>: svg, map only
TailTarget :: EscString -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg,
--   cmap only
TailTooltip :: EscString -> Attribute

-- | <i>Valid for</i>: ENGC; <i>Default</i>: none; <i>Notes</i>: svg, map
--   only
Target :: EscString -> Attribute

-- | <i>Valid for</i>: NEC; <i>Default</i>: <tt>""</tt>; <i>Notes</i>: svg,
--   cmap only
Tooltip :: EscString -> Attribute

-- | <i>Valid for</i>: G; <i>Parsing Default</i>: <a>True</a>;
--   <i>Notes</i>: bitmap output only
TrueColor :: Bool -> Attribute

-- | <i>Valid for</i>: N; <i>Notes</i>: write only
Vertices :: [Point] -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: none
ViewPort :: ViewPort -> Attribute

-- | <i>Valid for</i>: G; <i>Default</i>: <tt>0.05</tt>; <i>Minimum</i>:
--   <tt>0.0</tt>; <i>Notes</i>: not <a>Dot</a>
VoroMargin :: Double -> Attribute

-- | <i>Valid for</i>: E; <i>Default</i>: <tt><a>Number</a> 1</tt>;
--   <i>Minimum</i>: <tt><a>Number</a> 0</tt> (<a>Dot</a>),
--   <tt><a>Number</a> 1</tt> (<a>Neato</a>,<a>Fdp</a>,<a>Sfdp</a>);
--   <i>Notes</i>: as of Graphviz 2.30: weights for dot need to be
--   <a>Number</a>s
Weight :: Number -> Attribute

-- | <i>Valid for</i>: N; <i>Default</i>: <tt>0.75</tt>; <i>Minimum</i>:
--   <tt>0.01</tt>
Width :: Double -> Attribute

-- | <i>Valid for</i>: G; <i>Notes</i>: xdot only, requires Graphviz &gt;=
--   2.34.0, equivalent to specifying version of xdot to be used
XDotVersion :: Version -> Attribute

-- | <i>Valid for</i>: EN; <i>Default</i>: <tt><a>StrLabel</a> ""</tt>;
--   <i>Notes</i>: requires Graphviz &gt;= 2.29.0
XLabel :: Label -> Attribute

-- | <i>Valid for</i>: EN; <i>Notes</i>: write only, requires Graphviz
--   &gt;= 2.29.0
XLP :: Point -> Attribute

-- | <i>Valid for</i>: Assumed valid for all; the fields are
--   <a>Attribute</a> name and value respectively.
UnknownAttribute :: AttributeName -> Text -> Attribute
type Attributes = [Attribute]

-- | Determine if two <a>Attributes</a> are the same type of
--   <a>Attribute</a>.
sameAttribute :: Attribute -> Attribute -> Bool

-- | Return the default value for a specific <a>Attribute</a> if possible;
--   graph<i>cluster values are preferred over node</i>edge values.
defaultAttributeValue :: Attribute -> Maybe Attribute

-- | Remove attributes that we don't want to consider:
--   
--   <ul>
--   <li>Those that are defaults</li>
--   <li>colorscheme (as the colors embed it anyway)</li>
--   </ul>
rmUnwantedAttributes :: Attributes -> Attributes

-- | Determine if this <a>Attribute</a> is valid for use with Graphs.
usedByGraphs :: Attribute -> Bool

-- | Determine if this <a>Attribute</a> is valid for use with SubGraphs.
usedBySubGraphs :: Attribute -> Bool

-- | Determine if this <a>Attribute</a> is valid for use with Clusters.
usedByClusters :: Attribute -> Bool

-- | Determine if this <a>Attribute</a> is valid for use with Nodes.
usedByNodes :: Attribute -> Bool

-- | Determine if this <a>Attribute</a> is valid for use with Edges.
usedByEdges :: Attribute -> Bool

-- | Determine if the provided <a>Text</a> value is a valid name for an
--   <a>UnknownAttribute</a>.
validUnknown :: AttributeName -> Bool

-- | The name for an UnknownAttribute; must satisfy <a>validUnknown</a>.
type AttributeName = Text

-- | If performing any custom pre-/post-processing on Dot code, you may
--   wish to utilise some custom <a>Attributes</a>. These are wrappers
--   around the <a>UnknownAttribute</a> constructor (and thus
--   <a>CustomAttribute</a> is just an alias for <a>Attribute</a>).
--   
--   You should ensure that <a>validUnknown</a> is <a>True</a> for any
--   potential custom attribute name.
type CustomAttribute = Attribute

-- | Create a custom attribute.
customAttribute :: AttributeName -> Text -> CustomAttribute

-- | Determines whether or not this is a custom attribute.
isCustom :: Attribute -> Bool
isSpecifiedCustom :: AttributeName -> Attribute -> Bool

-- | The value of a custom attribute. Will throw a <a>GraphvizException</a>
--   if the provided <a>Attribute</a> isn't a custom one.
customValue :: CustomAttribute -> Text

-- | The name of a custom attribute. Will throw a <a>GraphvizException</a>
--   if the provided <a>Attribute</a> isn't a custom one.
customName :: CustomAttribute -> AttributeName

-- | Returns all custom attributes and the list of non-custom Attributes.
findCustoms :: Attributes -> ([CustomAttribute], Attributes)

-- | Find the (first instance of the) specified custom attribute and
--   returns it along with all other Attributes.
findSpecifiedCustom :: AttributeName -> Attributes -> Maybe (CustomAttribute, Attributes)

-- | Delete all custom attributes (actually, this will delete all
--   <a>UnknownAttribute</a> values; as such it can also be used to remove
--   legacy attributes).
deleteCustomAttributes :: Attributes -> Attributes

-- | Removes all instances of the specified custom attribute.
deleteSpecifiedCustom :: AttributeName -> Attributes -> Attributes

-- | A numeric type with an explicit separation between integers and
--   floating-point values.
data Number
Int :: Int -> Number
Dbl :: Double -> Number

-- | Some <tt>Attribute</tt>s (mainly label-like ones) take a <a>String</a>
--   argument that allows for extra escape codes. This library doesn't do
--   any extra checks or special parsing for these escape codes, but usage
--   of <a>EscString</a> rather than <a>Text</a> indicates that the
--   Graphviz tools will recognise these extra escape codes for these
--   <tt>Attribute</tt>s.
--   
--   The extra escape codes include (note that these are all Strings):
--   
--   <ul>
--   <li><i><tt>\N</tt></i> Replace with the name of the node (for Node
--   <tt>Attribute</tt>s).</li>
--   <li><i><tt>\G</tt></i> Replace with the name of the graph (for Node
--   <tt>Attribute</tt>s) or the name of the graph or cluster, whichever is
--   applicable (for Graph, Cluster and Edge <tt>Attribute</tt>s).</li>
--   <li><i><tt>\E</tt></i> Replace with the name of the edge, formed by
--   the two adjoining nodes and the edge type (for Edge
--   <tt>Attribute</tt>s).</li>
--   <li><i><tt>\T</tt></i> Replace with the name of the tail node (for
--   Edge <tt>Attribute</tt>s).</li>
--   <li><i><tt>\H</tt></i> Replace with the name of the head node (for
--   Edge <tt>Attribute</tt>s).</li>
--   <li><i><tt>\L</tt></i> Replace with the object's label (for all
--   <tt>Attribute</tt>s).</li>
--   </ul>
--   
--   Also, if the <tt>Attribute</tt> in question is <a>Label</a>,
--   <tt>HeadLabel</tt> or <tt>TailLabel</tt>, then <tt>\n</tt>,
--   <tt>\l</tt> and <tt>\r</tt> split the label into lines centered,
--   left-justified and right-justified respectively.
type EscString = Text
data Label
StrLabel :: EscString -> Label

-- | If <a>PlainText</a> is used, the <a>Label</a> value is the entire
--   "shape"; if anything else except <a>PointShape</a> is used then the
--   <a>Label</a> is embedded within the shape.
HtmlLabel :: Label -> Label

-- | For nodes only; requires either <a>Record</a> or <a>MRecord</a> as the
--   shape.
RecordLabel :: RecordFields -> Label
data VerticalPlacement
VTop :: VerticalPlacement

-- | Only valid for Nodes.
VCenter :: VerticalPlacement
VBottom :: VerticalPlacement

-- | How to treat a node whose name is of the form "<tt>|edgelabel|*</tt>"
--   as a special node representing an edge label.
data LabelScheme

-- | No effect
NotEdgeLabel :: LabelScheme

-- | Make node close to center of neighbor
CloseToCenter :: LabelScheme

-- | Make node close to old center of neighbor
CloseToOldCenter :: LabelScheme

-- | Use a two-step process.
RemoveAndStraighten :: LabelScheme

-- | The mapping used for <tt>FontName</tt> values in SVG output.
--   
--   More information can be found at
--   <a>http://www.graphviz.org/doc/fontfaq.txt</a>.
data SVGFontNames

-- | Use the legal generic SVG font names.
SvgNames :: SVGFontNames

-- | Use PostScript font names.
PostScriptNames :: SVGFontNames

-- | Use fontconfig font conventions.
FontConfigNames :: SVGFontNames

-- | A RecordFields value should never be empty.
type RecordFields = [RecordField]

-- | Specifies the sub-values of a record-based label. By default, the
--   cells are laid out horizontally; use <a>FlipFields</a> to change the
--   orientation of the fields (can be applied recursively). To change the
--   default orientation, use <a>RankDir</a>.
data RecordField
LabelledTarget :: PortName -> EscString -> RecordField

-- | Will result in no label for that cell.
PortName :: PortName -> RecordField
FieldLabel :: EscString -> RecordField
FlipFields :: RecordFields -> RecordField

-- | Should only have 2D points (i.e. created with <a>createPoint</a>).
data Rect
Rect :: Point -> Point -> Rect
data Justification
JLeft :: Justification
JRight :: Justification
JCenter :: Justification

-- | Geometries of shapes are affected by the attributes <tt>Regular</tt>,
--   <tt>Peripheries</tt> and <tt>Orientation</tt>.
data Shape

-- | Has synonyms of <i>rect</i> and <i>rectangle</i>.
BoxShape :: Shape

-- | Also affected by <tt>Sides</tt>, <tt>Skew</tt> and
--   <tt>Distortion</tt>.
Polygon :: Shape

-- | Has synonym of <i>oval</i>.
Ellipse :: Shape
Circle :: Shape

-- | Only affected by <tt>Peripheries</tt>, <tt>Width</tt> and
--   <tt>Height</tt>.
PointShape :: Shape
Egg :: Shape
Triangle :: Shape

-- | Has synonym of <i>none</i>. Recommended for <a>HtmlLabel</a>s.
PlainText :: Shape
DiamondShape :: Shape
Trapezium :: Shape
Parallelogram :: Shape
House :: Shape
Pentagon :: Shape
Hexagon :: Shape
Septagon :: Shape
Octagon :: Shape
DoubleCircle :: Shape
DoubleOctagon :: Shape
TripleOctagon :: Shape
InvTriangle :: Shape
InvTrapezium :: Shape
InvHouse :: Shape
MDiamond :: Shape
MSquare :: Shape
MCircle :: Shape
Square :: Shape

-- | Requires Graphviz &gt;= 2.32.0.
Star :: Shape

-- | Requires Graphviz &gt;= 2.36.0.
Underline :: Shape
Note :: Shape
Tab :: Shape
Folder :: Shape
Box3D :: Shape
Component :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Promoter :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
CDS :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Terminator :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
UTR :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
PrimerSite :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
RestrictionSite :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
FivePovOverhang :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
ThreePovOverhang :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
NoOverhang :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Assembly :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Signature :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Insulator :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Ribosite :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
RNAStab :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
ProteaseSite :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
ProteinStab :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
RPromoter :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
RArrow :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
LArrow :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
LPromoter :: Shape

-- | Must specify the record shape with a <a>Label</a>.
Record :: Shape

-- | Must specify the record shape with a <a>Label</a>.
MRecord :: Shape

-- | A list of search paths.
newtype Paths
Paths :: [FilePath] -> Paths
[paths] :: Paths -> [FilePath]
data ScaleType
UniformScale :: ScaleType
NoScale :: ScaleType
FillWidth :: ScaleType
FillHeight :: ScaleType
FillBoth :: ScaleType

-- | Determine how the <tt>Width</tt> and <tt>Height</tt> attributes
--   specify the size of nodes.
data NodeSize

-- | Nodes will be the smallest width and height needed to contain the
--   label and any possible image. <tt>Width</tt> and <tt>Height</tt> are
--   the minimum allowed sizes.
GrowAsNeeded :: NodeSize

-- | <tt>Width</tt> and <tt>Height</tt> dictate the size of the node with a
--   warning if the label cannot fit in this.
SetNodeSize :: NodeSize

-- | <tt>Width</tt> and <tt>Height</tt> dictate the size of the shape only
--   and the label can expand out of the shape (with a warning). Requires
--   Graphviz &gt;= 2.38.0.
SetShapeSize :: NodeSize

-- | Specify where to place arrow heads on an edge.
data DirType

-- | Draw a directed edge with an arrow to the node it's pointing go.
Forward :: DirType

-- | Draw a reverse directed edge with an arrow to the node it's coming
--   from.
Back :: DirType

-- | Draw arrows on both ends of the edge.
Both :: DirType

-- | Draw an undirected edge.
NoDir :: DirType

-- | Controls how (and if) edges are represented.
--   
--   For <tt>Dot</tt>, the default is <a>SplineEdges</a>; for all other
--   layouts the default is <a>LineEdges</a>.
data EdgeType

-- | Except for <tt>Dot</tt>, requires non-overlapping nodes (see
--   <a>Overlap</a>).
SplineEdges :: EdgeType
LineEdges :: EdgeType
NoEdges :: EdgeType
PolyLine :: EdgeType

-- | Does not handle ports or edge labels in <tt>Dot</tt>.
Ortho :: EdgeType

-- | Requires Graphviz &gt;= 2.30.0.
Curved :: EdgeType

-- | <tt>Fdp</tt> only
CompoundEdge :: EdgeType

-- | Specifies a name for ports (used also in record-based and HTML-like
--   labels). Note that it is not valid for a <a>PortName</a> value to
--   contain a colon (<tt>:</tt>) character; it is assumed that it doesn't.
newtype PortName
PN :: Text -> PortName
[portName] :: PortName -> Text
data PortPos
LabelledPort :: PortName -> Maybe CompassPoint -> PortPos
CompassPoint :: CompassPoint -> PortPos
data CompassPoint
North :: CompassPoint
NorthEast :: CompassPoint
East :: CompassPoint
SouthEast :: CompassPoint
South :: CompassPoint
SouthWest :: CompassPoint
West :: CompassPoint
NorthWest :: CompassPoint
CenterPoint :: CompassPoint
NoCP :: CompassPoint

-- | <i>Dot</i> has a basic grammar of arrow shapes which allows usage of
--   up to 1,544,761 different shapes from 9 different basic
--   <a>ArrowShape</a>s. Note that whilst an explicit list is used in the
--   definition of <a>ArrowType</a>, there must be at least one tuple and a
--   maximum of 4 (since that is what is required by Dot). For more
--   information, see: <a>http://graphviz.org/doc/info/arrows.html</a>
--   
--   The 19 basic arrows shown on the overall attributes page have been
--   defined below as a convenience. Parsing of the 5 backward-compatible
--   special cases is also supported.
newtype ArrowType
AType :: [(ArrowModifier, ArrowShape)] -> ArrowType
data ArrowShape
Box :: ArrowShape
Crow :: ArrowShape
Diamond :: ArrowShape
DotArrow :: ArrowShape
Inv :: ArrowShape
NoArrow :: ArrowShape
Normal :: ArrowShape
Tee :: ArrowShape
Vee :: ArrowShape

-- | What modifications to apply to an <a>ArrowShape</a>.
data ArrowModifier
ArrMod :: ArrowFill -> ArrowSide -> ArrowModifier
[arrowFill] :: ArrowModifier -> ArrowFill
[arrowSide] :: ArrowModifier -> ArrowSide
data ArrowFill
OpenArrow :: ArrowFill
FilledArrow :: ArrowFill

-- | Represents which side (when looking towards the node the arrow is
--   pointing to) is drawn.
data ArrowSide
LeftSide :: ArrowSide
RightSide :: ArrowSide
BothSides :: ArrowSide

-- | Apply no modifications to an <a>ArrowShape</a>.
noMods :: ArrowModifier

-- | <a>OpenArrow</a> and <a>BothSides</a>
openMod :: ArrowModifier
data Point
Point :: Double -> Double -> Maybe Double -> Bool -> Point
[xCoord] :: Point -> Double
[yCoord] :: Point -> Double

-- | Can only be <a>Just</a> for <tt><tt>Dim</tt> 3</tt> or greater.
[zCoord] :: Point -> Maybe Double

-- | Input to Graphviz only: specify that the node position should not
--   change.
[forcePos] :: Point -> Bool

-- | Create a point with only <tt>x</tt> and <tt>y</tt> values.
createPoint :: Double -> Double -> Point
data Pos
PointPos :: Point -> Pos
SplinePos :: [Spline] -> Pos

-- | The number of points in the list must be equivalent to 1 mod 3; note
--   that this is not checked.
data Spline
Spline :: Maybe Point -> Maybe Point -> [Point] -> Spline
[endPoint] :: Spline -> Maybe Point
[startPoint] :: Spline -> Maybe Point
[splinePoints] :: Spline -> [Point]

-- | Either a <a>Double</a> or a (2D) <a>Point</a> (i.e. created with
--   <a>createPoint</a>).
--   
--   Whilst it is possible to create a <a>Point</a> value with either a
--   third co-ordinate or a forced position, these are ignored for
--   printing/parsing.
--   
--   An optional prefix of <tt>'+'</tt> is allowed when parsing.
data DPoint
DVal :: Double -> DPoint
PVal :: Point -> DPoint

-- | If set, normalizes coordinates such that the first point is at the
--   origin and the first edge is at the angle if specified.
data Normalized

-- | Equivalent to <tt><a>NormalizedAngle</a> 0</tt>.
IsNormalized :: Normalized
NotNormalized :: Normalized

-- | Angle of first edge when normalized. Requires Graphviz &gt;= 2.32.0.
NormalizedAngle :: Double -> Normalized

-- | The available Graphviz commands. The following directions are based
--   upon those in the Graphviz man page (available online at
--   <a>http://graphviz.org/pdf/dot.1.pdf</a>, or if installed on your
--   system <tt>man graphviz</tt>). Note that any command can be used on
--   both directed and undirected graphs.
--   
--   When used with the <tt>Layout</tt> attribute, it overrides any actual
--   command called on the dot graph.
data GraphvizCommand

-- | For hierachical graphs (ideal for directed graphs).
Dot :: GraphvizCommand

-- | For symmetric layouts of graphs (ideal for undirected graphs).
Neato :: GraphvizCommand

-- | For radial layout of graphs.
TwoPi :: GraphvizCommand

-- | For circular layout of graphs.
Circo :: GraphvizCommand

-- | Spring-model approach for undirected graphs.
Fdp :: GraphvizCommand

-- | As with Fdp, but ideal for large graphs.
Sfdp :: GraphvizCommand

-- | Filter for drawing clustered graphs, requires Graphviz &gt;= 2.28.0.
Osage :: GraphvizCommand

-- | Draw clustered graphs as treemaps, requires Graphviz &gt;= 2.28.0.
Patchwork :: GraphvizCommand

-- | Maximum width and height of drawing in inches.
data GraphSize
GSize :: Double -> Maybe Double -> Bool -> GraphSize
[width] :: GraphSize -> Double

-- | If <tt>Nothing</tt>, then the height is the same as the width.
[height] :: GraphSize -> Maybe Double

-- | If drawing is smaller than specified size, this value determines
--   whether it is scaled up.
[desiredSize] :: GraphSize -> Bool

-- | If <a>Local</a>, then sub-graphs that are clusters are given special
--   treatment. <a>Global</a> and <a>NoCluster</a> currently appear to be
--   identical and turn off the special cluster processing.
data ClusterMode
Local :: ClusterMode
Global :: ClusterMode
NoCluster :: ClusterMode
data Model
ShortPath :: Model
SubSet :: Model
Circuit :: Model
MDS :: Model

-- | How to deal with node overlaps.
--   
--   Defaults to <a>KeepOverlaps</a> <i>except</i> for <tt>Fdp</tt> and
--   <tt>Sfdp</tt>.
--   
--   The ability to specify the number of tries for <tt>Fdp'</tt>s initial
--   force-directed technique is <i>not</i> supported (by default,
--   <tt>Fdp</tt> uses <tt>9</tt> passes of its in-built technique, and
--   then <tt><a>PrismOverlap</a> Nothing</tt>).
--   
--   For <tt>Sfdp</tt>, the default is <tt><a>PrismOverlap</a> (Just
--   0)</tt>.
data Overlap
KeepOverlaps :: Overlap

-- | Remove overlaps by uniformly scaling in x and y.
ScaleOverlaps :: Overlap

-- | Remove overlaps by separately scaling x and y.
ScaleXYOverlaps :: Overlap

-- | Requires the Prism library to be available (if not, this is equivalent
--   to <a>VoronoiOverlap</a>). <tt><a>Nothing</a></tt> is equivalent to
--   <tt><a>Just</a> 1000</tt>. Influenced by <tt>OverlapScaling</tt>.
PrismOverlap :: Maybe Word16 -> Overlap

-- | Requires Graphviz &gt;= 2.30.0.
VoronoiOverlap :: Overlap

-- | Scale layout down as much as possible without introducing overlaps,
--   assuming none to begin with.
CompressOverlap :: Overlap

-- | Uses quadratic optimization to minimize node displacement.
VpscOverlap :: Overlap

-- | Only when <tt>mode == <a>IpSep</a></tt>
IpsepOverlap :: Overlap

-- | Specify the root node either as a Node attribute or a Graph attribute.
data Root

-- | For Nodes only
IsCentral :: Root

-- | For Nodes only
NotCentral :: Root

-- | For Graphs only
NodeName :: Text -> Root
data Order

-- | Draw outgoing edges in order specified.
OutEdges :: Order

-- | Draw incoming edges in order specified.
InEdges :: Order
data OutputMode
BreadthFirst :: OutputMode
NodesFirst :: OutputMode
EdgesFirst :: OutputMode
data Pack
DoPack :: Pack
DontPack :: Pack

-- | If non-negative, then packs; otherwise doesn't.
PackMargin :: Int -> Pack
data PackMode
PackNode :: PackMode
PackClust :: PackMode
PackGraph :: PackMode

-- | Sort by cols, sort by user, number of rows/cols
PackArray :: Bool -> Bool -> Maybe Int -> PackMode

-- | Upper-case first character is major order; lower-case second character
--   is minor order.
data PageDir
Bl :: PageDir
Br :: PageDir
Tl :: PageDir
Tr :: PageDir
Rb :: PageDir
Rt :: PageDir
Lb :: PageDir
Lt :: PageDir
data QuadType
NormalQT :: QuadType
FastQT :: QuadType
NoQT :: QuadType
data RankType
SameRank :: RankType
MinRank :: RankType
SourceRank :: RankType
MaxRank :: RankType
SinkRank :: RankType
data RankDir
FromTop :: RankDir
FromLeft :: RankDir
FromBottom :: RankDir
FromRight :: RankDir
data StartType
StartStyle :: STStyle -> StartType
StartSeed :: Int -> StartType
StartStyleSeed :: STStyle -> Int -> StartType
data ViewPort
VP :: Double -> Double -> Double -> Maybe FocusType -> ViewPort
[wVal] :: ViewPort -> Double
[hVal] :: ViewPort -> Double
[zVal] :: ViewPort -> Double
[focus] :: ViewPort -> Maybe FocusType

-- | For use with <a>ViewPort</a>.
data FocusType
XY :: Point -> FocusType
NodeFocus :: Text -> FocusType
data Ratios
AspectRatio :: Double -> Ratios
FillRatio :: Ratios
CompressRatio :: Ratios
ExpandRatio :: Ratios
AutoRatio :: Ratios

-- | For <tt>Neato</tt> unless indicated otherwise.
data ModeType
Major :: ModeType
KK :: ModeType
Hier :: ModeType
IpSep :: ModeType

-- | For <tt>Sfdp</tt>, requires Graphviz &gt;= 2.32.0.
SpringMode :: ModeType

-- | For <tt>Sfdp</tt>, requires Graphviz &gt;= 2.32.0.
MaxEnt :: ModeType

-- | Only when <tt>mode == <a>IpSep</a></tt>.
data DEConstraints
EdgeConstraints :: DEConstraints
NoConstraints :: DEConstraints
HierConstraints :: DEConstraints
newtype LayerSep
LSep :: Text -> LayerSep
newtype LayerListSep
LLSep :: Text -> LayerListSep
type LayerRange = [LayerRangeElem]
data LayerRangeElem
LRID :: LayerID -> LayerRangeElem
LRS :: LayerID -> LayerID -> LayerRangeElem

-- | You should not have any layer separator characters for the
--   <a>LRName</a> option, as they won't be parseable.
data LayerID
AllLayers :: LayerID
LRInt :: Int -> LayerID

-- | Should not be a number or <tt>"all"</tt>.
LRName :: Text -> LayerID

-- | A list of layer names. The names should all be unique <a>LRName</a>
--   values, and when printed will use an arbitrary character from
--   <tt>defLayerSep</tt>. The values in the list are implicitly numbered
--   <tt>1, 2, ...</tt>.
newtype LayerList
LL :: [LayerID] -> LayerList
data SmoothType
NoSmooth :: SmoothType
AvgDist :: SmoothType
GraphDist :: SmoothType
PowerDist :: SmoothType
RNG :: SmoothType
Spring :: SmoothType
TriangleSmooth :: SmoothType
data STStyle
RegularStyle :: STStyle
SelfStyle :: STStyle
RandomStyle :: STStyle

-- | An individual style item. Except for <a>DD</a>, the
--   <tt>[<a>String</a>]</tt> should be empty.
data StyleItem
SItem :: StyleName -> [Text] -> StyleItem
data StyleName

-- | Nodes and Edges
Dashed :: StyleName

-- | Nodes and Edges
Dotted :: StyleName

-- | Nodes and Edges
Solid :: StyleName

-- | Nodes and Edges
Bold :: StyleName

-- | Nodes and Edges
Invisible :: StyleName

-- | Nodes and Clusters
Filled :: StyleName

-- | Rectangularly-shaped Nodes and Clusters; requires Graphviz &gt;=
--   2.30.0
Striped :: StyleName

-- | Elliptically-shaped Nodes only; requires Graphviz &gt;= 2.30.0
Wedged :: StyleName

-- | Nodes only
Diagonals :: StyleName

-- | Nodes and Clusters
Rounded :: StyleName

-- | Edges only; requires Graphviz &gt;= 2.29.0
Tapered :: StyleName

-- | Nodes, Clusters and Graphs, for use with <tt>GradientAngle</tt>;
--   requires Graphviz &gt;= 2.29.0
Radial :: StyleName

-- | Device Dependent
DD :: Text -> StyleName
instance GHC.Read.Read Data.GraphViz.Attributes.Complete.Attribute
instance GHC.Show.Show Data.GraphViz.Attributes.Complete.Attribute
instance GHC.Classes.Ord Data.GraphViz.Attributes.Complete.Attribute
instance GHC.Classes.Eq Data.GraphViz.Attributes.Complete.Attribute
instance Data.GraphViz.Printing.PrintDot Data.GraphViz.Attributes.Complete.Attribute
instance Data.GraphViz.Parsing.ParseDot Data.GraphViz.Attributes.Complete.Attribute


-- | There are almost 150 possible attributes available for Dot graphs, and
--   it can be difficult to know which ones to use. This module provides
--   helper functions for the most commonly used ones.
--   
--   The complete list of all possible attributes can be found in
--   <a>Data.GraphViz.Attributes.Complete</a>; it is possible to use both
--   of these modules if you require specific extra attributes that are not
--   provided here.
module Data.GraphViz.Attributes

-- | Attributes are used to customise the layout and design of Dot graphs.
--   Care must be taken to ensure that the attribute you use is valid, as
--   not all attributes can be used everywhere.
data Attribute
type Attributes = [Attribute]

-- | Equivalent to <tt><a>Attribute</a> . <a>toLabelValue</a></tt>; the
--   most common label <a>Attribute</a>.
toLabel :: Labellable a => a -> Attribute

-- | An alias for <a>toLabel</a> for use with the
--   <tt>OverloadedStrings</tt> extension.
textLabel :: Text -> Attribute

-- | Create a label <i>outside</i> of a node/edge. Currently only in the
--   Graphviz development branch (2.29.*).
xLabel :: Labellable a => a -> Attribute

-- | An alias for <a>xLabel</a> for use with the <tt>OverloadedStrings</tt>
--   extension.
xTextLabel :: Text -> Attribute

-- | Force the positioning of <a>xLabel</a>s, even when it will cause
--   overlaps.
forceLabels :: Attribute

-- | An alias for <a>toLabelValue</a> for use with the
--   <tt>OverloadedStrings</tt> extension.
textLabelValue :: Text -> Label

-- | A convenience class to make it easier to create labels. It is highly
--   recommended that you make any other types that you wish to create
--   labels from an instance of this class, preferably via the
--   <tt>String</tt> or <tt>Text</tt> instances.
class Labellable a

-- | This function only creates a <a>Attribute</a> value to enable you to
--   use it for <a>Attributes</a> such as <a>HeadLabel</a>, etc.
toLabelValue :: Labellable a => a -> Label

-- | The X11 colors that Graphviz uses. Note that these are slightly
--   different from the "normal" X11 colors used (e.g. the inclusion of
--   <tt>Crimson</tt>). Graphviz's list of colors also duplicated almost
--   all <tt>Gray</tt> colors with <tt>Grey</tt> ones; parsing of an
--   <a>X11Color</a> which is specified using "grey" will succeed, even for
--   those that don't have the duplicate spelling (e.g.
--   <tt>DarkSlateGray1</tt>).
data X11Color
AliceBlue :: X11Color
AntiqueWhite :: X11Color
AntiqueWhite1 :: X11Color
AntiqueWhite2 :: X11Color
AntiqueWhite3 :: X11Color
AntiqueWhite4 :: X11Color
Aquamarine :: X11Color
Aquamarine1 :: X11Color
Aquamarine2 :: X11Color
Aquamarine3 :: X11Color
Aquamarine4 :: X11Color
Azure :: X11Color
Azure1 :: X11Color
Azure2 :: X11Color
Azure3 :: X11Color
Azure4 :: X11Color
Beige :: X11Color
Bisque :: X11Color
Bisque1 :: X11Color
Bisque2 :: X11Color
Bisque3 :: X11Color
Bisque4 :: X11Color
Black :: X11Color
BlanchedAlmond :: X11Color
Blue :: X11Color
Blue1 :: X11Color
Blue2 :: X11Color
Blue3 :: X11Color
Blue4 :: X11Color
BlueViolet :: X11Color
Brown :: X11Color
Brown1 :: X11Color
Brown2 :: X11Color
Brown3 :: X11Color
Brown4 :: X11Color
Burlywood :: X11Color
Burlywood1 :: X11Color
Burlywood2 :: X11Color
Burlywood3 :: X11Color
Burlywood4 :: X11Color
CadetBlue :: X11Color
CadetBlue1 :: X11Color
CadetBlue2 :: X11Color
CadetBlue3 :: X11Color
CadetBlue4 :: X11Color
Chartreuse :: X11Color
Chartreuse1 :: X11Color
Chartreuse2 :: X11Color
Chartreuse3 :: X11Color
Chartreuse4 :: X11Color
Chocolate :: X11Color
Chocolate1 :: X11Color
Chocolate2 :: X11Color
Chocolate3 :: X11Color
Chocolate4 :: X11Color
Coral :: X11Color
Coral1 :: X11Color
Coral2 :: X11Color
Coral3 :: X11Color
Coral4 :: X11Color
CornFlowerBlue :: X11Color
CornSilk :: X11Color
CornSilk1 :: X11Color
CornSilk2 :: X11Color
CornSilk3 :: X11Color
CornSilk4 :: X11Color
Crimson :: X11Color
Cyan :: X11Color
Cyan1 :: X11Color
Cyan2 :: X11Color
Cyan3 :: X11Color
Cyan4 :: X11Color
DarkGoldenrod :: X11Color
DarkGoldenrod1 :: X11Color
DarkGoldenrod2 :: X11Color
DarkGoldenrod3 :: X11Color
DarkGoldenrod4 :: X11Color
DarkGreen :: X11Color
Darkkhaki :: X11Color
DarkOliveGreen :: X11Color
DarkOliveGreen1 :: X11Color
DarkOliveGreen2 :: X11Color
DarkOliveGreen3 :: X11Color
DarkOliveGreen4 :: X11Color
DarkOrange :: X11Color
DarkOrange1 :: X11Color
DarkOrange2 :: X11Color
DarkOrange3 :: X11Color
DarkOrange4 :: X11Color
DarkOrchid :: X11Color
DarkOrchid1 :: X11Color
DarkOrchid2 :: X11Color
DarkOrchid3 :: X11Color
DarkOrchid4 :: X11Color
DarkSalmon :: X11Color
DarkSeaGreen :: X11Color
DarkSeaGreen1 :: X11Color
DarkSeaGreen2 :: X11Color
DarkSeaGreen3 :: X11Color
DarkSeaGreen4 :: X11Color
DarkSlateBlue :: X11Color
DarkSlateGray :: X11Color
DarkSlateGray1 :: X11Color
DarkSlateGray2 :: X11Color
DarkSlateGray3 :: X11Color
DarkSlateGray4 :: X11Color
DarkTurquoise :: X11Color
DarkViolet :: X11Color
DeepPink :: X11Color
DeepPink1 :: X11Color
DeepPink2 :: X11Color
DeepPink3 :: X11Color
DeepPink4 :: X11Color
DeepSkyBlue :: X11Color
DeepSkyBlue1 :: X11Color
DeepSkyBlue2 :: X11Color
DeepSkyBlue3 :: X11Color
DeepSkyBlue4 :: X11Color
DimGray :: X11Color
DodgerBlue :: X11Color
DodgerBlue1 :: X11Color
DodgerBlue2 :: X11Color
DodgerBlue3 :: X11Color
DodgerBlue4 :: X11Color
Firebrick :: X11Color
Firebrick1 :: X11Color
Firebrick2 :: X11Color
Firebrick3 :: X11Color
Firebrick4 :: X11Color
FloralWhite :: X11Color
ForestGreen :: X11Color
Gainsboro :: X11Color
GhostWhite :: X11Color
Gold :: X11Color
Gold1 :: X11Color
Gold2 :: X11Color
Gold3 :: X11Color
Gold4 :: X11Color
Goldenrod :: X11Color
Goldenrod1 :: X11Color
Goldenrod2 :: X11Color
Goldenrod3 :: X11Color
Goldenrod4 :: X11Color
Gray :: X11Color
Gray0 :: X11Color
Gray1 :: X11Color
Gray2 :: X11Color
Gray3 :: X11Color
Gray4 :: X11Color
Gray5 :: X11Color
Gray6 :: X11Color
Gray7 :: X11Color
Gray8 :: X11Color
Gray9 :: X11Color
Gray10 :: X11Color
Gray11 :: X11Color
Gray12 :: X11Color
Gray13 :: X11Color
Gray14 :: X11Color
Gray15 :: X11Color
Gray16 :: X11Color
Gray17 :: X11Color
Gray18 :: X11Color
Gray19 :: X11Color
Gray20 :: X11Color
Gray21 :: X11Color
Gray22 :: X11Color
Gray23 :: X11Color
Gray24 :: X11Color
Gray25 :: X11Color
Gray26 :: X11Color
Gray27 :: X11Color
Gray28 :: X11Color
Gray29 :: X11Color
Gray30 :: X11Color
Gray31 :: X11Color
Gray32 :: X11Color
Gray33 :: X11Color
Gray34 :: X11Color
Gray35 :: X11Color
Gray36 :: X11Color
Gray37 :: X11Color
Gray38 :: X11Color
Gray39 :: X11Color
Gray40 :: X11Color
Gray41 :: X11Color
Gray42 :: X11Color
Gray43 :: X11Color
Gray44 :: X11Color
Gray45 :: X11Color
Gray46 :: X11Color
Gray47 :: X11Color
Gray48 :: X11Color
Gray49 :: X11Color
Gray50 :: X11Color
Gray51 :: X11Color
Gray52 :: X11Color
Gray53 :: X11Color
Gray54 :: X11Color
Gray55 :: X11Color
Gray56 :: X11Color
Gray57 :: X11Color
Gray58 :: X11Color
Gray59 :: X11Color
Gray60 :: X11Color
Gray61 :: X11Color
Gray62 :: X11Color
Gray63 :: X11Color
Gray64 :: X11Color
Gray65 :: X11Color
Gray66 :: X11Color
Gray67 :: X11Color
Gray68 :: X11Color
Gray69 :: X11Color
Gray70 :: X11Color
Gray71 :: X11Color
Gray72 :: X11Color
Gray73 :: X11Color
Gray74 :: X11Color
Gray75 :: X11Color
Gray76 :: X11Color
Gray77 :: X11Color
Gray78 :: X11Color
Gray79 :: X11Color
Gray80 :: X11Color
Gray81 :: X11Color
Gray82 :: X11Color
Gray83 :: X11Color
Gray84 :: X11Color
Gray85 :: X11Color
Gray86 :: X11Color
Gray87 :: X11Color
Gray88 :: X11Color
Gray89 :: X11Color
Gray90 :: X11Color
Gray91 :: X11Color
Gray92 :: X11Color
Gray93 :: X11Color
Gray94 :: X11Color
Gray95 :: X11Color
Gray96 :: X11Color
Gray97 :: X11Color
Gray98 :: X11Color
Gray99 :: X11Color
Gray100 :: X11Color
Green :: X11Color
Green1 :: X11Color
Green2 :: X11Color
Green3 :: X11Color
Green4 :: X11Color
GreenYellow :: X11Color
HoneyDew :: X11Color
HoneyDew1 :: X11Color
HoneyDew2 :: X11Color
HoneyDew3 :: X11Color
HoneyDew4 :: X11Color
HotPink :: X11Color
HotPink1 :: X11Color
HotPink2 :: X11Color
HotPink3 :: X11Color
HotPink4 :: X11Color
IndianRed :: X11Color
IndianRed1 :: X11Color
IndianRed2 :: X11Color
IndianRed3 :: X11Color
IndianRed4 :: X11Color
Indigo :: X11Color
Ivory :: X11Color
Ivory1 :: X11Color
Ivory2 :: X11Color
Ivory3 :: X11Color
Ivory4 :: X11Color
Khaki :: X11Color
Khaki1 :: X11Color
Khaki2 :: X11Color
Khaki3 :: X11Color
Khaki4 :: X11Color
Lavender :: X11Color
LavenderBlush :: X11Color
LavenderBlush1 :: X11Color
LavenderBlush2 :: X11Color
LavenderBlush3 :: X11Color
LavenderBlush4 :: X11Color
LawnGreen :: X11Color
LemonChiffon :: X11Color
LemonChiffon1 :: X11Color
LemonChiffon2 :: X11Color
LemonChiffon3 :: X11Color
LemonChiffon4 :: X11Color
LightBlue :: X11Color
LightBlue1 :: X11Color
LightBlue2 :: X11Color
LightBlue3 :: X11Color
LightBlue4 :: X11Color
LightCoral :: X11Color
LightCyan :: X11Color
LightCyan1 :: X11Color
LightCyan2 :: X11Color
LightCyan3 :: X11Color
LightCyan4 :: X11Color
LightGoldenrod :: X11Color
LightGoldenrod1 :: X11Color
LightGoldenrod2 :: X11Color
LightGoldenrod3 :: X11Color
LightGoldenrod4 :: X11Color
LightGoldenrodYellow :: X11Color
LightGray :: X11Color
LightPink :: X11Color
LightPink1 :: X11Color
LightPink2 :: X11Color
LightPink3 :: X11Color
LightPink4 :: X11Color
LightSalmon :: X11Color
LightSalmon1 :: X11Color
LightSalmon2 :: X11Color
LightSalmon3 :: X11Color
LightSalmon4 :: X11Color
LightSeaGreen :: X11Color
LightSkyBlue :: X11Color
LightSkyBlue1 :: X11Color
LightSkyBlue2 :: X11Color
LightSkyBlue3 :: X11Color
LightSkyBlue4 :: X11Color
LightSlateBlue :: X11Color
LightSlateGray :: X11Color
LightSteelBlue :: X11Color
LightSteelBlue1 :: X11Color
LightSteelBlue2 :: X11Color
LightSteelBlue3 :: X11Color
LightSteelBlue4 :: X11Color
LightYellow :: X11Color
LightYellow1 :: X11Color
LightYellow2 :: X11Color
LightYellow3 :: X11Color
LightYellow4 :: X11Color
LimeGreen :: X11Color
Linen :: X11Color
Magenta :: X11Color
Magenta1 :: X11Color
Magenta2 :: X11Color
Magenta3 :: X11Color
Magenta4 :: X11Color
Maroon :: X11Color
Maroon1 :: X11Color
Maroon2 :: X11Color
Maroon3 :: X11Color
Maroon4 :: X11Color
MediumAquamarine :: X11Color
MediumBlue :: X11Color
MediumOrchid :: X11Color
MediumOrchid1 :: X11Color
MediumOrchid2 :: X11Color
MediumOrchid3 :: X11Color
MediumOrchid4 :: X11Color
MediumPurple :: X11Color
MediumPurple1 :: X11Color
MediumPurple2 :: X11Color
MediumPurple3 :: X11Color
MediumPurple4 :: X11Color
MediumSeaGreen :: X11Color
MediumSlateBlue :: X11Color
MediumSpringGreen :: X11Color
MediumTurquoise :: X11Color
MediumVioletRed :: X11Color
MidnightBlue :: X11Color
MintCream :: X11Color
MistyRose :: X11Color
MistyRose1 :: X11Color
MistyRose2 :: X11Color
MistyRose3 :: X11Color
MistyRose4 :: X11Color
Moccasin :: X11Color
NavajoWhite :: X11Color
NavajoWhite1 :: X11Color
NavajoWhite2 :: X11Color
NavajoWhite3 :: X11Color
NavajoWhite4 :: X11Color
Navy :: X11Color
NavyBlue :: X11Color
OldLace :: X11Color
OliveDrab :: X11Color
OliveDrab1 :: X11Color
OliveDrab2 :: X11Color
OliveDrab3 :: X11Color
OliveDrab4 :: X11Color
Orange :: X11Color
Orange1 :: X11Color
Orange2 :: X11Color
Orange3 :: X11Color
Orange4 :: X11Color
OrangeRed :: X11Color
OrangeRed1 :: X11Color
OrangeRed2 :: X11Color
OrangeRed3 :: X11Color
OrangeRed4 :: X11Color
Orchid :: X11Color
Orchid1 :: X11Color
Orchid2 :: X11Color
Orchid3 :: X11Color
Orchid4 :: X11Color
PaleGoldenrod :: X11Color
PaleGreen :: X11Color
PaleGreen1 :: X11Color
PaleGreen2 :: X11Color
PaleGreen3 :: X11Color
PaleGreen4 :: X11Color
PaleTurquoise :: X11Color
PaleTurquoise1 :: X11Color
PaleTurquoise2 :: X11Color
PaleTurquoise3 :: X11Color
PaleTurquoise4 :: X11Color
PaleVioletRed :: X11Color
PaleVioletRed1 :: X11Color
PaleVioletRed2 :: X11Color
PaleVioletRed3 :: X11Color
PaleVioletRed4 :: X11Color
PapayaWhip :: X11Color
PeachPuff :: X11Color
PeachPuff1 :: X11Color
PeachPuff2 :: X11Color
PeachPuff3 :: X11Color
PeachPuff4 :: X11Color
Peru :: X11Color
Pink :: X11Color
Pink1 :: X11Color
Pink2 :: X11Color
Pink3 :: X11Color
Pink4 :: X11Color
Plum :: X11Color
Plum1 :: X11Color
Plum2 :: X11Color
Plum3 :: X11Color
Plum4 :: X11Color
PowderBlue :: X11Color
Purple :: X11Color
Purple1 :: X11Color
Purple2 :: X11Color
Purple3 :: X11Color
Purple4 :: X11Color
Red :: X11Color
Red1 :: X11Color
Red2 :: X11Color
Red3 :: X11Color
Red4 :: X11Color
RosyBrown :: X11Color
RosyBrown1 :: X11Color
RosyBrown2 :: X11Color
RosyBrown3 :: X11Color
RosyBrown4 :: X11Color
RoyalBlue :: X11Color
RoyalBlue1 :: X11Color
RoyalBlue2 :: X11Color
RoyalBlue3 :: X11Color
RoyalBlue4 :: X11Color
SaddleBrown :: X11Color
Salmon :: X11Color
Salmon1 :: X11Color
Salmon2 :: X11Color
Salmon3 :: X11Color
Salmon4 :: X11Color
SandyBrown :: X11Color
SeaGreen :: X11Color
SeaGreen1 :: X11Color
SeaGreen2 :: X11Color
SeaGreen3 :: X11Color
SeaGreen4 :: X11Color
SeaShell :: X11Color
SeaShell1 :: X11Color
SeaShell2 :: X11Color
SeaShell3 :: X11Color
SeaShell4 :: X11Color
Sienna :: X11Color
Sienna1 :: X11Color
Sienna2 :: X11Color
Sienna3 :: X11Color
Sienna4 :: X11Color
SkyBlue :: X11Color
SkyBlue1 :: X11Color
SkyBlue2 :: X11Color
SkyBlue3 :: X11Color
SkyBlue4 :: X11Color
SlateBlue :: X11Color
SlateBlue1 :: X11Color
SlateBlue2 :: X11Color
SlateBlue3 :: X11Color
SlateBlue4 :: X11Color
SlateGray :: X11Color
SlateGray1 :: X11Color
SlateGray2 :: X11Color
SlateGray3 :: X11Color
SlateGray4 :: X11Color
Snow :: X11Color
Snow1 :: X11Color
Snow2 :: X11Color
Snow3 :: X11Color
Snow4 :: X11Color
SpringGreen :: X11Color
SpringGreen1 :: X11Color
SpringGreen2 :: X11Color
SpringGreen3 :: X11Color
SpringGreen4 :: X11Color
SteelBlue :: X11Color
SteelBlue1 :: X11Color
SteelBlue2 :: X11Color
SteelBlue3 :: X11Color
SteelBlue4 :: X11Color
Tan :: X11Color
Tan1 :: X11Color
Tan2 :: X11Color
Tan3 :: X11Color
Tan4 :: X11Color
Thistle :: X11Color
Thistle1 :: X11Color
Thistle2 :: X11Color
Thistle3 :: X11Color
Thistle4 :: X11Color
Tomato :: X11Color
Tomato1 :: X11Color
Tomato2 :: X11Color
Tomato3 :: X11Color
Tomato4 :: X11Color

-- | Equivalent to setting <tt>Style [SItem Invisible []]</tt>.
Transparent :: X11Color
Turquoise :: X11Color
Turquoise1 :: X11Color
Turquoise2 :: X11Color
Turquoise3 :: X11Color
Turquoise4 :: X11Color
Violet :: X11Color
VioletRed :: X11Color
VioletRed1 :: X11Color
VioletRed2 :: X11Color
VioletRed3 :: X11Color
VioletRed4 :: X11Color
Wheat :: X11Color
Wheat1 :: X11Color
Wheat2 :: X11Color
Wheat3 :: X11Color
Wheat4 :: X11Color
White :: X11Color
WhiteSmoke :: X11Color
Yellow :: X11Color
Yellow1 :: X11Color
Yellow2 :: X11Color
Yellow3 :: X11Color
Yellow4 :: X11Color
YellowGreen :: X11Color

-- | Specify the background color of a graph or cluster. For clusters, if
--   <tt><a>style</a> <a>filled</a></tt> is used, then <a>fillColor</a>
--   will override it.
bgColor :: NamedColor nc => nc -> Attribute

-- | As with <a>bgColor</a>, but add a second color to create a gradient
--   effect. Requires Graphviz &gt;= 2.29.0.
bgColors :: NamedColor nc => nc -> nc -> Attribute

-- | Specify the fill color of a node, cluster or arrowhead. Requires
--   <tt><a>style</a> <a>filled</a></tt> for nodes and clusters. For nodes
--   and edges, if this isn't set then the <a>color</a> value is used
--   instead; for clusters, <a>bgColor</a> is used.
fillColor :: NamedColor nc => nc -> Attribute

-- | As with <a>fillColor</a>, but add a second color to create a gradient
--   effect. Requires Graphviz &gt;= 2.29.0.
fillColors :: NamedColor nc => nc -> nc -> Attribute

-- | Specify the color of text.
fontColor :: NamedColor nc => nc -> Attribute

-- | Specify the color of the bounding box of a cluster.
penColor :: NamedColor nc => nc -> Attribute

-- | The <tt>color</tt> attribute serves several purposes. As such care
--   must be taken when using it, and it is preferable to use those
--   alternatives that are available when they exist.
--   
--   <ul>
--   <li>The color of edges;</li>
--   <li>The bounding color of nodes;</li>
--   <li>The bounding color of clusters (i.e. equivalent to
--   <a>penColor</a>);</li>
--   <li>If the <a>filled</a> <a>Style</a> is set, then it defines the
--   background color of nodes and clusters unless <a>fillColor</a> or
--   <a>bgColor</a> respectively is set.</li>
--   </ul>
color :: NamedColor nc => nc -> Attribute

-- | Specify the width of lines. Valid for clusters, nodes and edges.
penWidth :: Double -> Attribute

-- | Specify the angle at which gradient fills are drawn; for use with
--   <a>bgColors</a> and <a>fillColors</a>. Requires Graphviz &gt;= 2.29.0.
gradientAngle :: Int -> Attribute
style :: Style -> Attribute
styles :: [Style] -> Attribute

-- | A particular style type to be used.
type Style = StyleItem

-- | Also available for edges.
dashed :: Style

-- | Also available for edges.
dotted :: Style

-- | Also available for edges.
solid :: Style

-- | Also available for edges.
bold :: Style

-- | Also available for edges.
invis :: Style

-- | Also available for clusters.
filled :: Style

-- | Only available for nodes.
diagonals :: Style

-- | Only available for rectangularly-shaped nodes and clusters. Requires
--   Graphviz &gt;= 2.30.0.
striped :: Style

-- | Only available for elliptically-shaped nodes. Requires Graphviz &gt;=
--   2.30.0.
wedged :: Style

-- | Also available for clusters.
rounded :: Style

-- | Only available for edges; creates a tapered edge between the two
--   nodes. Requires Graphviz &gt;= 2.29.0.
tapered :: Style

-- | Available for nodes, clusters and edges. When using
--   <a>gradientAngle</a>, indicates that a radial gradient should be used.
--   Requires Graphviz &gt;= 2.29.0.
radial :: Style

-- | The shape of a node.
shape :: Shape -> Attribute

-- | Geometries of shapes are affected by the attributes <tt>Regular</tt>,
--   <tt>Peripheries</tt> and <tt>Orientation</tt>.
data Shape

-- | Has synonyms of <i>rect</i> and <i>rectangle</i>.
BoxShape :: Shape

-- | Also affected by <tt>Sides</tt>, <tt>Skew</tt> and
--   <tt>Distortion</tt>.
Polygon :: Shape

-- | Has synonym of <i>oval</i>.
Ellipse :: Shape
Circle :: Shape

-- | Only affected by <tt>Peripheries</tt>, <tt>Width</tt> and
--   <tt>Height</tt>.
PointShape :: Shape
Egg :: Shape
Triangle :: Shape

-- | Has synonym of <i>none</i>. Recommended for <a>HtmlLabel</a>s.
PlainText :: Shape
DiamondShape :: Shape
Trapezium :: Shape
Parallelogram :: Shape
House :: Shape
Pentagon :: Shape
Hexagon :: Shape
Septagon :: Shape
Octagon :: Shape
DoubleCircle :: Shape
DoubleOctagon :: Shape
TripleOctagon :: Shape
InvTriangle :: Shape
InvTrapezium :: Shape
InvHouse :: Shape
MDiamond :: Shape
MSquare :: Shape
MCircle :: Shape
Square :: Shape

-- | Requires Graphviz &gt;= 2.32.0.
Star :: Shape

-- | Requires Graphviz &gt;= 2.36.0.
Underline :: Shape
Note :: Shape
Tab :: Shape
Folder :: Shape
Box3D :: Shape
Component :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Promoter :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
CDS :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Terminator :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
UTR :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
PrimerSite :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
RestrictionSite :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
FivePovOverhang :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
ThreePovOverhang :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
NoOverhang :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Assembly :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Signature :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Insulator :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
Ribosite :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
RNAStab :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
ProteaseSite :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
ProteinStab :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
RPromoter :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
RArrow :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
LArrow :: Shape

-- | Requires Graphviz &gt;= 2.30.0.
LPromoter :: Shape

-- | Must specify the record shape with a <a>Label</a>.
Record :: Shape

-- | Must specify the record shape with a <a>Label</a>.
MRecord :: Shape

-- | How to draw the arrow at the node the edge is pointing to. For an
--   undirected graph, requires either <tt><a>edgeEnds</a>
--   <a>Forward</a></tt> or <tt><a>edgeEnds</a> <a>Both</a></tt>.
arrowTo :: Arrow -> Attribute

-- | How to draw the arrow at the node the edge is coming from. Requires
--   either <tt><a>edgeEnds</a> <a>Back</a></tt> or <tt><a>edgeEnds</a>
--   <a>Both</a></tt>.
arrowFrom :: Arrow -> Attribute

-- | Specify where to place arrows on an edge.
edgeEnds :: DirType -> Attribute

-- | Specify where to place arrow heads on an edge.
data DirType

-- | Draw a directed edge with an arrow to the node it's pointing go.
Forward :: DirType

-- | Draw a reverse directed edge with an arrow to the node it's coming
--   from.
Back :: DirType

-- | Draw arrows on both ends of the edge.
Both :: DirType

-- | Draw an undirected edge.
NoDir :: DirType

-- | A particular way of drawing the end of an edge.
type Arrow = ArrowType
box :: Arrow
crow :: Arrow
diamond :: Arrow
dotArrow :: Arrow
inv :: Arrow
noArrow :: Arrow
normal :: ArrowType
tee :: Arrow
vee :: Arrow
oDot :: Arrow
invDot :: Arrow
invODot :: Arrow
oBox :: Arrow
oDiamond :: Arrow

-- | Specify an ordering of edges of a node: either the outgoing or the
--   incoming edges of a node must appear left-to-right in the same order
--   in which they are defined in the input.
--   
--   When specified as both a global graph or sub-graph level attribute,
--   then it takes precedence over an attribute specified for an individual
--   node.
ordering :: Order -> Attribute
data Order

-- | Draw outgoing edges in order specified.
OutEdges :: Order

-- | Draw incoming edges in order specified.
InEdges :: Order

-- | When using <tt>dot</tt>, this allows you to control relative placement
--   of sub-graphs and clusters.
rank :: RankType -> Attribute
data RankType
SameRank :: RankType
MinRank :: RankType
SourceRank :: RankType
MaxRank :: RankType
SinkRank :: RankType
instance Data.GraphViz.Attributes.Labellable Data.Text.Internal.Lazy.Text
instance Data.GraphViz.Attributes.Labellable Data.Text.Internal.Text
instance Data.GraphViz.Attributes.Labellable GHC.Types.Char
instance Data.GraphViz.Attributes.Labellable GHC.Base.String
instance Data.GraphViz.Attributes.Labellable GHC.Types.Int
instance Data.GraphViz.Attributes.Labellable GHC.Types.Double
instance Data.GraphViz.Attributes.Labellable GHC.Types.Bool
instance Data.GraphViz.Attributes.Labellable Data.GraphViz.Attributes.HTML.Label
instance Data.GraphViz.Attributes.Labellable Data.GraphViz.Attributes.HTML.Text
instance Data.GraphViz.Attributes.Labellable Data.GraphViz.Attributes.HTML.Table
instance Data.GraphViz.Attributes.Labellable Data.GraphViz.Attributes.Values.RecordFields
instance Data.GraphViz.Attributes.Labellable Data.GraphViz.Attributes.Values.RecordField
instance Data.GraphViz.Attributes.Labellable Data.GraphViz.Attributes.Internal.PortName
instance Data.GraphViz.Attributes.Labellable (Data.GraphViz.Attributes.Internal.PortName, Data.GraphViz.Attributes.Values.EscString)


-- | A canonical Dot graph requires that within each graph/sub-graph, the
--   statements are in the following order:
--   
--   <ul>
--   <li>global attributes</li>
--   <li>sub-graphs/clusters</li>
--   <li>nodes</li>
--   <li>edges</li>
--   </ul>
--   
--   This Dot graph representation is ideally suited for converting other
--   data structures to Dot form (especially with the help of
--   <tt>graphElemsToDot</tt> from <a>Data.GraphViz</a>).
--   
--   If you require arbitrary ordering of statements, then use
--   <a>Data.GraphViz.Types.Generalised</a>.
--   
--   The sample graph could be implemented (this is actually the result of
--   calling <tt>canonicalise</tt> from <a>Data.GraphViz.Algorithms</a> on
--   the generalised one) as:
--   
--   <pre>
--   DotGraph { strictGraph = False
--            , directedGraph = True
--            , graphID = Just (Str "G")
--            , graphStatements = DotStmts { attrStmts = []
--                                         , subGraphs = [ DotSG { isCluster = True
--                                                               , subGraphID = Just (Num (Int 0))
--                                                               , subGraphStmts = DotStmts { attrStmts = [ GraphAttrs [ style filled
--                                                                                                                     , color LightGray
--                                                                                                                     , textLabel "process #1"]
--                                                                                                        , NodeAttrs [style filled, color White]]
--                                                                                          , subGraphs = []
--                                                                                          , nodeStmts = [ DotNode "a0" []
--                                                                                                        , DotNode "a1" []
--                                                                                                        , DotNode "a2" []
--                                                                                                        , DotNode "a3" []]
--                                                                                          , edgeStmts = [ DotEdge "a0" "a1" []
--                                                                                                        , DotEdge "a1" "a2" []
--                                                                                                        , DotEdge "a2" "a3" []
--                                                                                                        , DotEdge "a3" "a0" []]}}
--                                                       , DotSG { isCluster = True
--                                                               , subGraphID = Just (Num (Int 1))
--                                                               , subGraphStmts = DotStmts { attrStmts = [ GraphAttrs [textLabel "process #2", color Blue]
--                                                                                                        , NodeAttrs [style filled]]
--                                                                                          , subGraphs = []
--                                                                                          , nodeStmts = [ DotNode "b0" []
--                                                                                                        , DotNode "b1" []
--                                                                                                        , DotNode "b2" []
--                                                                                                        , DotNode "b3" []]
--                                                                                          , edgeStmts = [ DotEdge "b0" "b1" []
--                                                                                                        , DotEdge "b1" "b2" []
--                                                                                                        , DotEdge "b2" "b3" []]}}]
--                                         , nodeStmts = [ DotNode "end" [shape MSquare]
--                                                       , DotNode "start" [shape MDiamond]]
--                                         , edgeStmts = [ DotEdge "start" "a0" []
--                                                       , DotEdge "start" "b0" []
--                                                       , DotEdge "a1" "b3" []
--                                                       , DotEdge "b2" "a3" []
--                                                       , DotEdge "a3" "end" []
--                                                       , DotEdge "b3" "end" []]}}
--   </pre>
--   
--   Note that whilst the above graph represents the same Dot graph as
--   specified in <a>Data.GraphViz.Types.Generalised</a>, etc., it
--   <i>may</i> be drawn slightly differently by the various Graphviz
--   tools.
module Data.GraphViz.Types.Canonical

-- | A Dot graph in canonical form.
data DotGraph n
DotGraph :: Bool -> Bool -> Maybe GraphID -> DotStatements n -> DotGraph n

-- | If <a>True</a>, no multiple edges are drawn.
[strictGraph] :: DotGraph n -> Bool
[directedGraph] :: DotGraph n -> Bool
[graphID] :: DotGraph n -> Maybe GraphID
[graphStatements] :: DotGraph n -> DotStatements n
data DotStatements n
DotStmts :: [GlobalAttributes] -> [DotSubGraph n] -> [DotNode n] -> [DotEdge n] -> DotStatements n
[attrStmts] :: DotStatements n -> [GlobalAttributes]
[subGraphs] :: DotStatements n -> [DotSubGraph n]
[nodeStmts] :: DotStatements n -> [DotNode n]
[edgeStmts] :: DotStatements n -> [DotEdge n]
data DotSubGraph n
DotSG :: Bool -> Maybe GraphID -> DotStatements n -> DotSubGraph n
[isCluster] :: DotSubGraph n -> Bool
[subGraphID] :: DotSubGraph n -> Maybe GraphID
[subGraphStmts] :: DotSubGraph n -> DotStatements n

-- | A polymorphic type that covers all possible ID values allowed by Dot
--   syntax. Note that whilst the <a>ParseDot</a> and <a>PrintDot</a>
--   instances for <a>String</a> will properly take care of the special
--   cases for numbers, they are treated differently here.
data GraphID
Str :: Text -> GraphID
Num :: Number -> GraphID

-- | Represents a list of top-level list of <a>Attribute</a>s for the
--   entire graph/sub-graph. Note that <a>GraphAttrs</a> also applies to
--   <tt>DotSubGraph</tt>s.
--   
--   Note that Dot allows a single <a>Attribute</a> to be listed on a line;
--   if this is the case then when parsing, the type of <a>Attribute</a> it
--   is determined and that type of <tt>GlobalAttribute</tt> is created.
data GlobalAttributes
GraphAttrs :: Attributes -> GlobalAttributes
[attrs] :: GlobalAttributes -> Attributes
NodeAttrs :: Attributes -> GlobalAttributes
[attrs] :: GlobalAttributes -> Attributes
EdgeAttrs :: Attributes -> GlobalAttributes
[attrs] :: GlobalAttributes -> Attributes

-- | A node in <tt>DotGraph</tt>.
data DotNode n
DotNode :: n -> Attributes -> DotNode n
[nodeID] :: DotNode n -> n
[nodeAttributes] :: DotNode n -> Attributes

-- | An edge in <tt>DotGraph</tt>.
data DotEdge n
DotEdge :: n -> n -> Attributes -> DotEdge n
[fromNode] :: DotEdge n -> n
[toNode] :: DotEdge n -> n
[edgeAttributes] :: DotEdge n -> Attributes
instance GHC.Read.Read n => GHC.Read.Read (Data.GraphViz.Types.Canonical.DotStatements n)
instance GHC.Show.Show n => GHC.Show.Show (Data.GraphViz.Types.Canonical.DotStatements n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.GraphViz.Types.Canonical.DotStatements n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.GraphViz.Types.Canonical.DotStatements n)
instance GHC.Read.Read n => GHC.Read.Read (Data.GraphViz.Types.Canonical.DotSubGraph n)
instance GHC.Show.Show n => GHC.Show.Show (Data.GraphViz.Types.Canonical.DotSubGraph n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.GraphViz.Types.Canonical.DotSubGraph n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.GraphViz.Types.Canonical.DotSubGraph n)
instance GHC.Read.Read n => GHC.Read.Read (Data.GraphViz.Types.Canonical.DotGraph n)
instance GHC.Show.Show n => GHC.Show.Show (Data.GraphViz.Types.Canonical.DotGraph n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.GraphViz.Types.Canonical.DotGraph n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.GraphViz.Types.Canonical.DotGraph n)
instance Data.GraphViz.Printing.PrintDot n => Data.GraphViz.Printing.PrintDot (Data.GraphViz.Types.Canonical.DotGraph n)
instance Data.GraphViz.Parsing.ParseDot n => Data.GraphViz.Parsing.ParseDot (Data.GraphViz.Types.Canonical.DotGraph n)
instance GHC.Base.Functor Data.GraphViz.Types.Canonical.DotGraph
instance Data.GraphViz.Printing.PrintDot n => Data.GraphViz.Printing.PrintDot (Data.GraphViz.Types.Canonical.DotStatements n)
instance Data.GraphViz.Parsing.ParseDot n => Data.GraphViz.Parsing.ParseDot (Data.GraphViz.Types.Canonical.DotStatements n)
instance GHC.Base.Functor Data.GraphViz.Types.Canonical.DotStatements
instance Data.GraphViz.Printing.PrintDot n => Data.GraphViz.Printing.PrintDot (Data.GraphViz.Types.Canonical.DotSubGraph n)
instance Data.GraphViz.Parsing.ParseDot n => Data.GraphViz.Parsing.ParseDot (Data.GraphViz.Types.Canonical.DotSubGraph n)
instance GHC.Base.Functor Data.GraphViz.Types.Canonical.DotSubGraph


-- | Four different representations of Dot graphs are available, all of
--   which are based loosely upon the specifications at:
--   <a>http://graphviz.org/doc/info/lang.html</a>. The <a>DotRepr</a>
--   class provides a common interface for them (the <a>PrintDotRepr</a>,
--   <a>ParseDotRepr</a> and <a>PPDotRepr</a> classes are used until class
--   aliases are implemented).
--   
--   Every representation takes in a type parameter: this indicates the
--   node type (e.g. <tt>DotGraph Int</tt> is a Dot graph with integer
--   nodes). Sum types are allowed, though care must be taken when
--   specifying their <a>ParseDot</a> instances if there is the possibility
--   of overlapping definitions. The <a>GraphID</a> type is an existing sum
--   type that allows textual and numeric values.
--   
--   If you require using more than one Dot representation, you will most
--   likely need to import at least one of them qualified, as they
--   typically all use the same names.
--   
--   As a comparison, all four representations provide how you would define
--   the following Dot graph (or at least one isomorphic to it) (the
--   original of which can be found at
--   <a>http://graphviz.org/content/cluster</a>). Note that in all the
--   examples, they are not necessarily done the best way (variables rather
--   than repeated constants, etc.); they are just there to provide a
--   comparison on the structure of each representation.
--   
--   <pre>
--   digraph G {
--   
--     subgraph cluster_0 {
--       style=filled;
--       color=lightgrey;
--       node [style=filled,color=white];
--       a0 -&gt; a1 -&gt; a2 -&gt; a3;
--       label = "process #1";
--     }
--   
--     subgraph cluster_1 {
--       node [style=filled];
--       b0 -&gt; b1 -&gt; b2 -&gt; b3;
--       label = "process #2";
--       color=blue
--     }
--     start -&gt; a0;
--     start -&gt; b0;
--     a1 -&gt; b3;
--     b2 -&gt; a3;
--     a3 -&gt; a0;
--     a3 -&gt; end;
--     b3 -&gt; end;
--   
--     start [shape=Mdiamond];
--     end [shape=Msquare];
--   }
--   </pre>
--   
--   Each representation is suited for different things:
--   
--   <ul>
--   <li><i><a>Data.GraphViz.Types.Canonical</a></i> is ideal for
--   converting other graph-like data structures into Dot graphs (the
--   <a>Data.GraphViz</a> module provides some functions for this). It is a
--   structured representation of Dot code.</li>
--   <li><i><a>Data.GraphViz.Types.Generalised</a></i> matches the actual
--   structure of Dot code. As such, it is suited for parsing in existing
--   Dot code.</li>
--   <li><i><a>Data.GraphViz.Types.Graph</a></i> provides graph operations
--   for manipulating Dot graphs; this is suited when you want to edit
--   existing Dot code. It uses generalised Dot graphs for parsing and
--   canonical Dot graphs for printing.</li>
--   <li><i><a>Data.GraphViz.Types.Monadic</a></i> is a much easier
--   representation to use when defining relatively static Dot graphs in
--   Haskell code, and looks vaguely like actual Dot code if you squint a
--   bit.</li>
--   </ul>
--   
--   Please also read the limitations section at the end for advice on how
--   to properly use these Dot representations.
module Data.GraphViz.Types

-- | This class is used to provide a common interface to different ways of
--   representing a graph in <i>Dot</i> form.
--   
--   You will most probably <i>not</i> need to create your own instances of
--   this class.
--   
--   The type variable represents the current node type of the Dot graph,
--   and the <a>Ord</a> restriction is there because in practice most
--   implementations of some of these methods require it.
class (Ord n) => DotRepr dg n

-- | Convert from a graph in canonical form. This is especially useful when
--   using the functions from <a>Data.GraphViz.Algorithms</a>.
--   
--   See <tt>FromGeneralisedDot</tt> in
--   <a>Data.GraphViz.Types.Generalised</a> for a semi-inverse of this
--   function.
fromCanonical :: DotRepr dg n => DotGraph n -> dg n

-- | Return the ID of the graph.
getID :: DotRepr dg n => dg n -> Maybe GraphID

-- | Set the ID of the graph.
setID :: DotRepr dg n => GraphID -> dg n -> dg n

-- | Is this graph directed?
graphIsDirected :: DotRepr dg n => dg n -> Bool

-- | Set whether a graph is directed or not.
setIsDirected :: DotRepr dg n => Bool -> dg n -> dg n

-- | Is this graph strict? Strict graphs disallow multiple edges.
graphIsStrict :: DotRepr dg n => dg n -> Bool

-- | A strict graph disallows multiple edges.
setStrictness :: DotRepr dg n => Bool -> dg n -> dg n

-- | Change the node values. This function is assumed to be
--   <i>injective</i>, otherwise the resulting graph will not be identical
--   to the original (modulo labels).
mapDotGraph :: (DotRepr dg n, DotRepr dg n') => (n -> n') -> dg n -> dg n'

-- | Return information on all the clusters contained within this
--   <a>DotRepr</a>, as well as the top-level <a>GraphAttrs</a> for the
--   overall graph.
graphStructureInformation :: DotRepr dg n => dg n -> (GlobalAttributes, ClusterLookup)

-- | Return information on the <a>DotNode</a>s contained within this
--   <a>DotRepr</a>. The <a>Bool</a> parameter indicates if applicable
--   <a>NodeAttrs</a> should be included.
nodeInformation :: DotRepr dg n => Bool -> dg n -> NodeLookup n

-- | Return information on the <a>DotEdge</a>s contained within this
--   <a>DotRepr</a>. The <a>Bool</a> parameter indicates if applicable
--   <a>EdgeAttrs</a> should be included.
edgeInformation :: DotRepr dg n => Bool -> dg n -> [DotEdge n]

-- | Give any anonymous sub-graphs or clusters a unique identifier (i.e.
--   there will be no <a>Nothing</a> key in the <a>ClusterLookup</a> from
--   <a>graphStructureInformation</a>).
unAnonymise :: DotRepr dg n => dg n -> dg n

-- | A class used to correctly print parts of the Graphviz Dot language.
--   Minimal implementation is <a>unqtDot</a>.
class PrintDot a

-- | The unquoted representation, for use when composing values to produce
--   a larger printing value.
unqtDot :: PrintDot a => a -> DotCode

-- | The actual quoted representation; this should be quoted if it contains
--   characters not permitted a plain ID String, a number or it is not an
--   HTML string. Defaults to <a>unqtDot</a>.
toDot :: PrintDot a => a -> DotCode

-- | The correct way of representing a list of this value when printed; not
--   all Dot values require this to be implemented. Defaults to
--   Haskell-like list representation.
unqtListToDot :: PrintDot a => [a] -> DotCode

-- | The quoted form of <a>unqtListToDot</a>; defaults to wrapping double
--   quotes around the result of <a>unqtListToDot</a> (since the default
--   implementation has characters that must be quoted).
listToDot :: PrintDot a => [a] -> DotCode
class ParseDot a
parseUnqt :: ParseDot a => Parse a
parse :: ParseDot a => Parse a
parseUnqtList :: ParseDot a => Parse [a]
parseList :: ParseDot a => Parse [a]

-- | This class exists just to make type signatures nicer; all instances of
--   <a>DotRepr</a> should also be an instance of <a>PrintDotRepr</a>.
class (DotRepr dg n, PrintDot (dg n)) => PrintDotRepr dg n

-- | This class exists just to make type signatures nicer; all instances of
--   <a>DotRepr</a> should also be an instance of <a>ParseDotRepr</a>.
class (DotRepr dg n, ParseDot (dg n)) => ParseDotRepr dg n

-- | This class exists just to make type signatures nicer; all instances of
--   <a>DotRepr</a> should also be an instance of <a>PPDotRepr</a>.
class (PrintDotRepr dg n, ParseDotRepr dg n) => PPDotRepr dg n

-- | A polymorphic type that covers all possible ID values allowed by Dot
--   syntax. Note that whilst the <a>ParseDot</a> and <a>PrintDot</a>
--   instances for <a>String</a> will properly take care of the special
--   cases for numbers, they are treated differently here.
data GraphID
Str :: Text -> GraphID
Num :: Number -> GraphID

-- | A numeric type with an explicit separation between integers and
--   floating-point values.
data Number
Int :: Int -> Number
Dbl :: Double -> Number

-- | A convenience class to make it easier to convert data types to
--   <a>GraphID</a> values, e.g. for cluster identifiers.
--   
--   In most cases, conversion would be via the <a>Text</a> or
--   <a>String</a> instances (e.g. using <a>show</a>).
class ToGraphID a
toGraphID :: ToGraphID a => a -> GraphID

-- | An alias for <a>toGraphID</a> for use with the
--   <tt>OverloadedStrings</tt> extension.
textGraphID :: Text -> GraphID

-- | Represents a list of top-level list of <a>Attribute</a>s for the
--   entire graph/sub-graph. Note that <a>GraphAttrs</a> also applies to
--   <tt>DotSubGraph</tt>s.
--   
--   Note that Dot allows a single <a>Attribute</a> to be listed on a line;
--   if this is the case then when parsing, the type of <a>Attribute</a> it
--   is determined and that type of <tt>GlobalAttribute</tt> is created.
data GlobalAttributes
GraphAttrs :: Attributes -> GlobalAttributes
[attrs] :: GlobalAttributes -> Attributes
NodeAttrs :: Attributes -> GlobalAttributes
[attrs] :: GlobalAttributes -> Attributes
EdgeAttrs :: Attributes -> GlobalAttributes
[attrs] :: GlobalAttributes -> Attributes

-- | A node in <tt>DotGraph</tt>.
data DotNode n
DotNode :: n -> Attributes -> DotNode n
[nodeID] :: DotNode n -> n
[nodeAttributes] :: DotNode n -> Attributes

-- | An edge in <tt>DotGraph</tt>.
data DotEdge n
DotEdge :: n -> n -> Attributes -> DotEdge n
[fromNode] :: DotEdge n -> n
[toNode] :: DotEdge n -> n
[edgeAttributes] :: DotEdge n -> Attributes

-- | The available information for each cluster; the <tt>[<a>Path</a>]</tt>
--   denotes all locations where that particular cluster is located (more
--   than one location can indicate possible problems).
type ClusterLookup = Map (Maybe GraphID) ([Path], GlobalAttributes)

-- | The available information on each <a>DotNode</a> (both explicit and
--   implicit).
type NodeLookup n = Map n (Path, Attributes)

-- | The path of clusters that must be traversed to reach this spot.
type Path = Seq (Maybe GraphID)

-- | A variant of <a>graphStructureInformation</a> with default attributes
--   removed and only attributes usable by graph/cluster kept (where
--   applicable).
graphStructureInformationClean :: DotRepr dg n => dg n -> (GlobalAttributes, ClusterLookup)

-- | A variant of <a>nodeInformation</a> with default attributes removed
--   and only attributes used by nodes kept.
nodeInformationClean :: DotRepr dg n => Bool -> dg n -> NodeLookup n

-- | A variant of <a>edgeInformation</a> with default attributes removed
--   and only attributes used by edges kept.
edgeInformationClean :: DotRepr dg n => Bool -> dg n -> [DotEdge n]

-- | Returns all resultant <a>DotNode</a>s in the <a>DotRepr</a> (not
--   including <tt>NodeAttr</tt>s).
graphNodes :: DotRepr dg n => dg n -> [DotNode n]

-- | Returns all resultant <a>DotEdge</a>s in the <a>DotRepr</a> (not
--   including <tt>EdgeAttr</tt>s).
graphEdges :: DotRepr dg n => dg n -> [DotEdge n]

-- | The actual <i>Dot</i> code for an instance of <a>DotRepr</a>. Note
--   that it is expected that <tt><a>parseDotGraph</a> .
--   <a>printDotGraph</a> == <a>id</a></tt> (this might not be true the
--   other way around due to un-parseable components).
printDotGraph :: PrintDotRepr dg n => dg n -> Text

-- | Parse a limited subset of the Dot language to form an instance of
--   <a>DotRepr</a>. Each instance may have its own limitations on what may
--   or may not be parseable Dot code.
--   
--   Also removes any comments, etc. before parsing.
parseDotGraph :: ParseDotRepr dg n => Text -> dg n

-- | As with <a>parseDotGraph</a>, but if an <tt>Attribute</tt> cannot be
--   parsed strictly according to the known rules, let it fall back to
--   being parsed as an <tt>UnknownAttribute</tt>. This is especially
--   useful for when using a version of Graphviz that is either newer
--   (especially for the XDot attributes) or older (when some attributes
--   have changed) but you'd still prefer it to parse rather than throwing
--   an error.
parseDotGraphLiberally :: ParseDotRepr dg n => Text -> dg n
instance Data.GraphViz.Types.ToGraphID Data.Text.Internal.Lazy.Text
instance Data.GraphViz.Types.ToGraphID GHC.Base.String
instance Data.GraphViz.Types.ToGraphID GHC.Types.Char
instance Data.GraphViz.Types.ToGraphID GHC.Types.Int
instance Data.GraphViz.Types.ToGraphID GHC.Num.Integer.Integer
instance Data.GraphViz.Types.ToGraphID GHC.Types.Double
instance (GHC.Classes.Ord n, Data.GraphViz.Printing.PrintDot n, Data.GraphViz.Parsing.ParseDot n) => Data.GraphViz.Types.PPDotRepr Data.GraphViz.Types.Canonical.DotGraph n
instance (GHC.Classes.Ord n, Data.GraphViz.Parsing.ParseDot n) => Data.GraphViz.Types.ParseDotRepr Data.GraphViz.Types.Canonical.DotGraph n
instance (GHC.Classes.Ord n, Data.GraphViz.Printing.PrintDot n) => Data.GraphViz.Types.PrintDotRepr Data.GraphViz.Types.Canonical.DotGraph n
instance GHC.Classes.Ord n => Data.GraphViz.Types.DotRepr Data.GraphViz.Types.Canonical.DotGraph n


-- | Various utility functions to help with custom I/O of Dot code.
module Data.GraphViz.Commands.IO

-- | Explicitly convert a (lazy) <a>ByteString</a> to a <a>Text</a> value
--   using UTF-8 encoding, throwing a <a>GraphvizException</a> if there is
--   a decoding error.
toUTF8 :: ByteString -> Text

-- | Write the specified <tt>DotRepr</tt> to file.
writeDotFile :: PrintDotRepr dg n => FilePath -> dg n -> IO ()

-- | Read in and parse a <tt>DotRepr</tt> value from a file.
readDotFile :: ParseDotRepr dg n => FilePath -> IO (dg n)

-- | Output the <tt>DotRepr</tt> to the specified <a>Handle</a>.
hPutDot :: PrintDotRepr dg n => Handle -> dg n -> IO ()

-- | Output the <tt>DotRepr</tt> to the spcified <a>Handle</a> in a more
--   compact, machine-oriented form.
hPutCompactDot :: PrintDotRepr dg n => Handle -> dg n -> IO ()

-- | Read in and parse a <tt>DotRepr</tt> value from the specified
--   <a>Handle</a>.
hGetDot :: ParseDotRepr dg n => Handle -> IO (dg n)

-- | Strictly read in a <a>Text</a> value using an appropriate encoding.
hGetStrict :: Handle -> IO Text

-- | Print the specified <tt>DotRepr</tt> to <a>stdout</a>.
putDot :: PrintDotRepr dg n => dg n -> IO ()

-- | Read in and parse a <tt>DotRepr</tt> value from <a>stdin</a>.
readDot :: ParseDotRepr dg n => IO (dg n)

-- | Run an external command on the specified <tt>DotRepr</tt>. Remember to
--   use <tt>hSetBinaryMode</tt> on the <a>Handle</a> for the output
--   function if necessary.
--   
--   If the command was unsuccessful, then a <a>GraphvizException</a> is
--   thrown.
--   
--   For performance reasons, a temporary file is used to store the
--   generated Dot code. As such, this is only suitable for local commands.
runCommand :: PrintDotRepr dg n => String -> [String] -> (Handle -> IO a) -> dg n -> IO a


-- | This module defines functions to call the various Graphviz commands.
--   
--   Whilst various output formats are supported (see <a>GraphvizOutput</a>
--   for a complete list), it is not yet possible to choose a desired
--   renderer and formatter. Being able to determine which renderers and
--   formatters are applicable for a specific <a>GraphvizOutput</a> is not
--   easy (there is no listing of available renderers or formatters on the
--   Graphviz website), and for the most part the default ones do the job
--   well.
--   
--   Please note that for <a>GraphvizOutput</a> and <a>GraphvizCanvas</a>,
--   you will see that they are instances of a <tt>GraphvizResult</tt>
--   class; this is an internal class that should not be visible outside
--   this module, but Haddock is being too helpful for its own good.
module Data.GraphViz.Commands

-- | The available Graphviz commands. The following directions are based
--   upon those in the Graphviz man page (available online at
--   <a>http://graphviz.org/pdf/dot.1.pdf</a>, or if installed on your
--   system <tt>man graphviz</tt>). Note that any command can be used on
--   both directed and undirected graphs.
--   
--   When used with the <tt>Layout</tt> attribute, it overrides any actual
--   command called on the dot graph.
data GraphvizCommand

-- | For hierachical graphs (ideal for directed graphs).
Dot :: GraphvizCommand

-- | For symmetric layouts of graphs (ideal for undirected graphs).
Neato :: GraphvizCommand

-- | For radial layout of graphs.
TwoPi :: GraphvizCommand

-- | For circular layout of graphs.
Circo :: GraphvizCommand

-- | Spring-model approach for undirected graphs.
Fdp :: GraphvizCommand

-- | As with Fdp, but ideal for large graphs.
Sfdp :: GraphvizCommand

-- | Filter for drawing clustered graphs, requires Graphviz &gt;= 2.28.0.
Osage :: GraphvizCommand

-- | Draw clustered graphs as treemaps, requires Graphviz &gt;= 2.28.0.
Patchwork :: GraphvizCommand

-- | The default command for directed graphs.
dirCommand :: GraphvizCommand

-- | The default command for undirected graphs.
undirCommand :: GraphvizCommand

-- | The appropriate (default) Graphviz command for the given graph.
commandFor :: DotRepr dg n => dg n -> GraphvizCommand

-- | The possible Graphviz output formats (that is, those that actually
--   produce a file).
data GraphvizOutput

-- | Windows Bitmap Format.
Bmp :: GraphvizOutput

-- | Pretty-printed Dot output with no layout performed.
Canon :: GraphvizOutput

-- | Reproduces the input along with layout information.
DotOutput :: GraphvizOutput

-- | As with <a>DotOutput</a>, but provides even more information on how
--   the graph is drawn. The optional <a>Version</a> is the same as
--   specifying the <tt>XDotVersion</tt> attribute.
XDot :: Maybe Version -> GraphvizOutput

-- | Encapsulated PostScript.
Eps :: GraphvizOutput

-- | FIG graphics language.
Fig :: GraphvizOutput

-- | Internal GD library format.
Gd :: GraphvizOutput

-- | Compressed version of <a>Gd</a>.
Gd2 :: GraphvizOutput

-- | Graphics Interchange Format.
Gif :: GraphvizOutput

-- | Icon image file format.
Ico :: GraphvizOutput

-- | Server-side imagemap.
Imap :: GraphvizOutput

-- | Client-side imagemap.
Cmapx :: GraphvizOutput

-- | As for <a>Imap</a>, except only rectangles are used as active areas.
ImapNP :: GraphvizOutput

-- | As for <a>Cmapx</a>, except only rectangles are used as active areas.
CmapxNP :: GraphvizOutput

-- | The JPEG image format.
Jpeg :: GraphvizOutput

-- | Portable Document Format.
Pdf :: GraphvizOutput

-- | Simple text format.
Plain :: GraphvizOutput

-- | As for <a>Plain</a>, but provides port names on head and tail nodes
--   when applicable.
PlainExt :: GraphvizOutput

-- | Portable Network Graphics format.
Png :: GraphvizOutput

-- | PostScript.
Ps :: GraphvizOutput

-- | PostScript for PDF.
Ps2 :: GraphvizOutput

-- | Scalable Vector Graphics format.
Svg :: GraphvizOutput

-- | Compressed SVG format.
SvgZ :: GraphvizOutput

-- | Tagged Image File Format.
Tiff :: GraphvizOutput

-- | Vector Markup Language; <a>Svg</a> is usually preferred.
Vml :: GraphvizOutput

-- | Compressed VML format; <a>SvgZ</a> is usually preferred.
VmlZ :: GraphvizOutput

-- | Virtual Reality Modeling Language format; requires nodes to have a
--   third dimension set via the <tt>Pos</tt> attribute (and with a
--   <tt>Dim</tt> value of at least <tt>3</tt>).
Vrml :: GraphvizOutput

-- | Wireless BitMap format; monochrome format usually used for mobile
--   computing devices.
WBmp :: GraphvizOutput

-- | Google's WebP format; requires Graphviz &gt;= 2.29.0.
WebP :: GraphvizOutput

-- | Unlike <a>GraphvizOutput</a>, these items do not produce an output
--   file; instead, they directly draw a canvas (i.e. a window) with the
--   resulting image.
data GraphvizCanvas
Gtk :: GraphvizCanvas
Xlib :: GraphvizCanvas

-- | Run the recommended Graphviz command on this graph, saving the result
--   to the file provided (note: file extensions are <i>not</i> checked).
runGraphviz :: PrintDotRepr dg n => dg n -> GraphvizOutput -> FilePath -> IO FilePath

-- | Run the chosen Graphviz command on this graph, saving the result to
--   the file provided (note: file extensions are <i>not</i> checked).
runGraphvizCommand :: PrintDotRepr dg n => GraphvizCommand -> dg n -> GraphvizOutput -> FilePath -> IO FilePath

-- | Append the default extension for the provided <a>GraphvizOutput</a> to
--   the provided <a>FilePath</a> for the output file.
addExtension :: (GraphvizOutput -> FilePath -> a) -> GraphvizOutput -> FilePath -> a

-- | Run the chosen Graphviz command on this graph and render it using the
--   given canvas type.
runGraphvizCanvas :: PrintDotRepr dg n => GraphvizCommand -> dg n -> GraphvizCanvas -> IO ()

-- | Run the recommended Graphviz command on this graph and render it using
--   the given canvas type.
runGraphvizCanvas' :: PrintDotRepr dg n => dg n -> GraphvizCanvas -> IO ()

-- | Run the chosen Graphviz command on this graph, but send the result to
--   the given handle rather than to a file.
--   
--   Note that the <tt><a>Handle</a> -&gt; <a>IO</a> a</tt> function
--   <i>must</i> fully consume the input from the <a>Handle</a>; e.g. use
--   strict <tt>ByteStrings</tt> rather than lazy ones.
--   
--   If the command was unsuccessful, then a <a>GraphvizException</a> is
--   thrown.
graphvizWithHandle :: PrintDotRepr dg n => GraphvizCommand -> dg n -> GraphvizOutput -> (Handle -> IO a) -> IO a

-- | Is the Graphviz suite of tools installed? This is determined by
--   whether <tt>dot</tt> is available in the <tt>PATH</tt>.
isGraphvizInstalled :: IO Bool

-- | If Graphviz does not seem to be available, print the provided error
--   message and then exit fatally.
quitWithoutGraphviz :: String -> IO ()
instance GHC.Read.Read Data.GraphViz.Commands.GraphvizOutput
instance GHC.Show.Show Data.GraphViz.Commands.GraphvizOutput
instance GHC.Classes.Ord Data.GraphViz.Commands.GraphvizOutput
instance GHC.Classes.Eq Data.GraphViz.Commands.GraphvizOutput
instance GHC.Show.Show Data.GraphViz.Commands.GraphvizCanvas
instance GHC.Read.Read Data.GraphViz.Commands.GraphvizCanvas
instance GHC.Enum.Enum Data.GraphViz.Commands.GraphvizCanvas
instance GHC.Enum.Bounded Data.GraphViz.Commands.GraphvizCanvas
instance GHC.Classes.Ord Data.GraphViz.Commands.GraphvizCanvas
instance GHC.Classes.Eq Data.GraphViz.Commands.GraphvizCanvas
instance Data.GraphViz.Commands.GraphvizResult Data.GraphViz.Commands.GraphvizCanvas
instance Data.GraphViz.Commands.GraphvizResult Data.GraphViz.Commands.GraphvizOutput


-- | Defines various algorithms for use on <a>DotRepr</a> graphs. These are
--   typically re-implementations of behaviour found in existing Graphviz
--   tools but without the I/O requirement.
--   
--   Note that one way that these algorithms differ from those found in
--   Graphviz is that the order of clusters is <i>not</i> maintained, which
--   may affect layout in some cases.
module Data.GraphViz.Algorithms
data CanonicaliseOptions
COpts :: Bool -> Bool -> CanonicaliseOptions

-- | Place edges in the clusters where their nodes are rather than in the
--   top-level graph.
[edgesInClusters] :: CanonicaliseOptions -> Bool

-- | Put common <a>Attributes</a> as top-level <a>GlobalAttributes</a>.
[groupAttributes] :: CanonicaliseOptions -> Bool
defaultCanonOptions :: CanonicaliseOptions

-- | Options that are more like how <tt>dot -Tcanon</tt> works.
dotLikeOptions :: CanonicaliseOptions

-- | Canonicalise with some sensible defaults.
canonicalise :: DotRepr dg n => dg n -> DotGraph n

-- | As with <a>canonicalise</a>, but allow custom
--   <a>CanonicaliseOptions</a>.
canonicaliseOptions :: DotRepr dg n => CanonicaliseOptions -> dg n -> DotGraph n
transitiveReduction :: DotRepr dg n => dg n -> DotGraph n
transitiveReductionOptions :: DotRepr dg n => CanonicaliseOptions -> dg n -> DotGraph n
instance GHC.Read.Read Data.GraphViz.Algorithms.CanonicaliseOptions
instance GHC.Show.Show Data.GraphViz.Algorithms.CanonicaliseOptions
instance GHC.Classes.Ord Data.GraphViz.Algorithms.CanonicaliseOptions
instance GHC.Classes.Eq Data.GraphViz.Algorithms.CanonicaliseOptions
instance GHC.Read.Read n => GHC.Read.Read (Data.GraphViz.Algorithms.TaggedValues n)
instance GHC.Show.Show n => GHC.Show.Show (Data.GraphViz.Algorithms.TaggedValues n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.GraphViz.Algorithms.TaggedValues n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.GraphViz.Algorithms.TaggedValues n)


-- | The generalised Dot representation most closely matches the
--   implementation of actual Dot code, as it places no restrictions on
--   ordering of elements, etc. As such it should be able to parse any
--   existing Dot code (taking into account the parsing
--   limitations/assumptions).
--   
--   The sample graph could be implemented (this is actually a prettied
--   version of parsing in the Dot code) as:
--   
--   <pre>
--   DotGraph { strictGraph = False
--            , directedGraph = True
--            , graphID = Just (Str "G")
--            , graphStatements = Seq.fromList [ SG $ DotSG { isCluster = True
--                                                          , subGraphID = Just (Int 0)
--                                                          , subGraphStmts = Seq.fromList [ GA $ GraphAttrs [style filled]
--                                                                                         , GA $ GraphAttrs [color LightGray]
--                                                                                         , GA $ NodeAttrs [style filled, color White]
--                                                                                         , DE $ DotEdge "a0" "a1" []
--                                                                                         , DE $ DotEdge "a1" "a2" []
--                                                                                         , DE $ DotEdge "a2" "a3" []
--                                                                                         , GA $ GraphAttrs [textLabel "process #1"]]}
--                                             , SG $ DotSG { isCluster = True
--                                                          , subGraphID = Just (Int 1)
--                                                          , subGraphStmts = fromList [ GA $ NodeAttrs [style filled]
--                                                                                     , DE $ DotEdge "b0" "b1" []
--                                                                                     , DE $ DotEdge "b1" "b2" []
--                                                                                     , DE $ DotEdge "b2" "b3" []
--                                                                                     , GA $ GraphAttrs [textLabel "process #2"]
--                                                                                     , GA $ GraphAttrs [color Blue]]}
--                                             , DE $ DotEdge "start" "a0" []
--                                             , DE $ DotEdge "start" "b0" []
--                                             , DE $ DotEdge "a1" "b3" []
--                                             , DE $ DotEdge "b2" "a3" []
--                                             , DE $ DotEdge "a3" "a0" []
--                                             , DE $ DotEdge "a3" "end" []
--                                             , DE $ DotEdge "b3" "end" []
--                                             , DN $ DotNode "start" [shape MDiamond]
--                                             , DN $ DotNode "end" [shape MSquare]]}
--   </pre>
module Data.GraphViz.Types.Generalised

-- | The internal representation of a generalised graph in Dot form.
data DotGraph n
DotGraph :: Bool -> Bool -> Maybe GraphID -> DotStatements n -> DotGraph n

-- | If <a>True</a>, no multiple edges are drawn.
[strictGraph] :: DotGraph n -> Bool
[directedGraph] :: DotGraph n -> Bool
[graphID] :: DotGraph n -> Maybe GraphID
[graphStatements] :: DotGraph n -> DotStatements n

-- | This class is useful for being able to parse in a dot graph as a
--   generalised one, and then convert it to your preferred representation.
--   
--   This can be seen as a semi-inverse of <a>fromCanonical</a>.
class (DotRepr dg n) => FromGeneralisedDot dg n
fromGeneralised :: FromGeneralisedDot dg n => DotGraph n -> dg n
type DotStatements n = Seq (DotStatement n)
data DotStatement n
GA :: GlobalAttributes -> DotStatement n
SG :: DotSubGraph n -> DotStatement n
DN :: DotNode n -> DotStatement n
DE :: DotEdge n -> DotStatement n
data DotSubGraph n
DotSG :: Bool -> Maybe GraphID -> DotStatements n -> DotSubGraph n
[isCluster] :: DotSubGraph n -> Bool
[subGraphID] :: DotSubGraph n -> Maybe GraphID
[subGraphStmts] :: DotSubGraph n -> DotStatements n

-- | A polymorphic type that covers all possible ID values allowed by Dot
--   syntax. Note that whilst the <a>ParseDot</a> and <a>PrintDot</a>
--   instances for <a>String</a> will properly take care of the special
--   cases for numbers, they are treated differently here.
data GraphID
Str :: Text -> GraphID
Num :: Number -> GraphID

-- | Represents a list of top-level list of <a>Attribute</a>s for the
--   entire graph/sub-graph. Note that <a>GraphAttrs</a> also applies to
--   <tt>DotSubGraph</tt>s.
--   
--   Note that Dot allows a single <a>Attribute</a> to be listed on a line;
--   if this is the case then when parsing, the type of <a>Attribute</a> it
--   is determined and that type of <tt>GlobalAttribute</tt> is created.
data GlobalAttributes
GraphAttrs :: Attributes -> GlobalAttributes
[attrs] :: GlobalAttributes -> Attributes
NodeAttrs :: Attributes -> GlobalAttributes
[attrs] :: GlobalAttributes -> Attributes
EdgeAttrs :: Attributes -> GlobalAttributes
[attrs] :: GlobalAttributes -> Attributes

-- | A node in <tt>DotGraph</tt>.
data DotNode n
DotNode :: n -> Attributes -> DotNode n
[nodeID] :: DotNode n -> n
[nodeAttributes] :: DotNode n -> Attributes

-- | An edge in <tt>DotGraph</tt>.
data DotEdge n
DotEdge :: n -> n -> Attributes -> DotEdge n
[fromNode] :: DotEdge n -> n
[toNode] :: DotEdge n -> n
[edgeAttributes] :: DotEdge n -> Attributes
instance GHC.Read.Read n => GHC.Read.Read (Data.GraphViz.Types.Generalised.DotStatement n)
instance GHC.Show.Show n => GHC.Show.Show (Data.GraphViz.Types.Generalised.DotStatement n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.GraphViz.Types.Generalised.DotStatement n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.GraphViz.Types.Generalised.DotStatement n)
instance GHC.Read.Read n => GHC.Read.Read (Data.GraphViz.Types.Generalised.DotSubGraph n)
instance GHC.Show.Show n => GHC.Show.Show (Data.GraphViz.Types.Generalised.DotSubGraph n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.GraphViz.Types.Generalised.DotSubGraph n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.GraphViz.Types.Generalised.DotSubGraph n)
instance GHC.Read.Read n => GHC.Read.Read (Data.GraphViz.Types.Generalised.DotGraph n)
instance GHC.Show.Show n => GHC.Show.Show (Data.GraphViz.Types.Generalised.DotGraph n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.GraphViz.Types.Generalised.DotGraph n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.GraphViz.Types.Generalised.DotGraph n)
instance GHC.Classes.Ord n => Data.GraphViz.Types.Generalised.FromGeneralisedDot Data.GraphViz.Types.Canonical.DotGraph n
instance GHC.Classes.Ord n => Data.GraphViz.Types.Generalised.FromGeneralisedDot Data.GraphViz.Types.Generalised.DotGraph n
instance GHC.Classes.Ord n => Data.GraphViz.Types.DotRepr Data.GraphViz.Types.Generalised.DotGraph n
instance (GHC.Classes.Ord n, Data.GraphViz.Printing.PrintDot n) => Data.GraphViz.Types.PrintDotRepr Data.GraphViz.Types.Generalised.DotGraph n
instance (GHC.Classes.Ord n, Data.GraphViz.Parsing.ParseDot n) => Data.GraphViz.Types.ParseDotRepr Data.GraphViz.Types.Generalised.DotGraph n
instance (GHC.Classes.Ord n, Data.GraphViz.Printing.PrintDot n, Data.GraphViz.Parsing.ParseDot n) => Data.GraphViz.Types.PPDotRepr Data.GraphViz.Types.Generalised.DotGraph n
instance Data.GraphViz.Printing.PrintDot n => Data.GraphViz.Printing.PrintDot (Data.GraphViz.Types.Generalised.DotGraph n)
instance Data.GraphViz.Parsing.ParseDot n => Data.GraphViz.Parsing.ParseDot (Data.GraphViz.Types.Generalised.DotGraph n)
instance GHC.Base.Functor Data.GraphViz.Types.Generalised.DotGraph
instance Data.GraphViz.Printing.PrintDot n => Data.GraphViz.Printing.PrintDot (Data.GraphViz.Types.Generalised.DotStatement n)
instance Data.GraphViz.Parsing.ParseDot n => Data.GraphViz.Parsing.ParseDot (Data.GraphViz.Types.Generalised.DotStatement n)
instance GHC.Base.Functor Data.GraphViz.Types.Generalised.DotStatement
instance Data.GraphViz.Printing.PrintDot n => Data.GraphViz.Printing.PrintDot (Data.GraphViz.Types.Generalised.DotSubGraph n)
instance Data.GraphViz.Parsing.ParseDot n => Data.GraphViz.Parsing.ParseDot (Data.GraphViz.Types.Generalised.DotSubGraph n)
instance GHC.Base.Functor Data.GraphViz.Types.Generalised.DotSubGraph


-- | This module is based upon the <i>dotgen</i> library by Andy Gill:
--   <a>http://hackage.haskell.org/package/dotgen</a>
--   
--   It provides a monadic interface for constructing generalised Dot
--   graphs. Note that this does <i>not</i> have an instance for
--   <tt>DotRepr</tt> (e.g. what would be the point of the
--   <tt>fromCanonical</tt> function, as you can't do anything with the
--   result): it is purely for construction purposes. Use the generalised
--   Dot graph instance for printing, etc.
--   
--   Note that the generalised Dot graph types are <i>not</i> re-exported,
--   in case it causes a clash with other modules you may choose to import.
--   
--   The example graph in <a>Data.GraphViz.Types</a> can be written as:
--   
--   <pre>
--   digraph (Str "G") $ do
--   
--      cluster (Int 0) $ do
--          graphAttrs [style filled, color LightGray]
--          nodeAttrs [style filled, color White]
--          "a0" --&gt; "a1"
--          "a1" --&gt; "a2"
--          "a2" --&gt; "a3"
--          graphAttrs [textLabel "process #1"]
--   
--      cluster (Int 1) $ do
--          nodeAttrs [style filled]
--          "b0" --&gt; "b1"
--          "b1" --&gt; "b2"
--          "b2" --&gt; "b3"
--          graphAttrs [textLabel "process #2", color Blue]
--   
--      "start" --&gt; "a0"
--      "start" --&gt; "b0"
--      "a1" --&gt; "b3"
--      "b2" --&gt; "a3"
--      "a3" --&gt; "end"
--      "b3" --&gt; "end"
--   
--      node "start" [shape MDiamond]
--      node "end" [shape MSquare]
--   </pre>
module Data.GraphViz.Types.Monadic

-- | The monadic representation of a Dot graph.
type Dot n = DotM n ()

-- | The actual monad; as with <a>Dot</a> but allows you to return a value
--   within the do-block. The actual implementation is based upon the
--   Writer monad.
data DotM n a

-- | A polymorphic type that covers all possible ID values allowed by Dot
--   syntax. Note that whilst the <a>ParseDot</a> and <a>PrintDot</a>
--   instances for <a>String</a> will properly take care of the special
--   cases for numbers, they are treated differently here.
data GraphID
Str :: Text -> GraphID
Num :: Number -> GraphID

-- | Create a directed dot graph with the specified graph ID.
digraph :: GraphID -> DotM n a -> DotGraph n

-- | Create a directed dot graph with no graph ID.
digraph' :: DotM n a -> DotGraph n

-- | Create a undirected dot graph with the specified graph ID.
graph :: GraphID -> DotM n a -> DotGraph n

-- | Create a undirected dot graph with no graph ID.
graph' :: DotM n a -> DotGraph n

-- | Add graph/sub-graph/cluster attributes.
graphAttrs :: Attributes -> Dot n

-- | Add global node attributes.
nodeAttrs :: Attributes -> Dot n

-- | Add global edge attributes
edgeAttrs :: Attributes -> Dot n

-- | Add a named subgraph to the graph.
subgraph :: GraphID -> DotM n a -> Dot n

-- | Add an anonymous subgraph to the graph.
--   
--   It is highly recommended you use <a>subgraph</a> instead.
anonSubgraph :: DotM n a -> Dot n

-- | Add a named cluster to the graph.
cluster :: GraphID -> DotM n a -> Dot n

-- | Add a node to the graph.
node :: n -> Attributes -> Dot n

-- | Add a node with no attributes to the graph.
node' :: n -> Dot n

-- | Add an edge to the graph.
edge :: n -> n -> Attributes -> Dot n

-- | Add an edge with no attributes.
(-->) :: n -> n -> Dot n
infixr 9 -->

-- | An alias for <a>--&gt;</a> to make edges look more undirected.
(<->) :: n -> n -> Dot n
infixr 9 <->
instance GHC.Base.Functor (Data.GraphViz.Types.Monadic.DotM n)
instance GHC.Base.Applicative (Data.GraphViz.Types.Monadic.DotM n)
instance GHC.Base.Monad (Data.GraphViz.Types.Monadic.DotM n)
instance Control.Monad.Fix.MonadFix (Data.GraphViz.Types.Monadic.DotM n)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.GraphViz.Types.Monadic.DotM n a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.GraphViz.Types.Monadic.DotM n a)


-- | It is sometimes useful to be able to manipulate a Dot graph <i>as</i>
--   an actual graph. This representation lets you do so, using an
--   inductive approach based upon that from FGL (note that <a>DotGraph</a>
--   is <i>not</i> an instance of the FGL classes due to having the wrong
--   kind). Note, however, that the API is not as complete as proper graph
--   implementations.
--   
--   For purposes of manipulation, all edges are found in the root graph
--   and not in a cluster; as such, having <a>EdgeAttrs</a> in a cluster's
--   <a>GlobalAttributes</a> is redundant.
--   
--   Printing is achieved via <a>Data.GraphViz.Types.Canonical</a> (using
--   <a>toCanonical</a>) and parsing via
--   <a>Data.GraphViz.Types.Generalised</a> (so <i>any</i> piece of Dot
--   code can be parsed in).
--   
--   This representation doesn't allow non-cluster sub-graphs. Also, all
--   clusters <i>must</i> have a unique identifier. For those functions
--   (with the exception of <a>DotRepr</a> methods) that take or return a
--   "<tt>Maybe GraphID</tt>", a value of "<tt>Nothing</tt>" refers to the
--   root graph; "<tt>Just clust</tt>" refers to the cluster with the
--   identifier "<tt>clust</tt>".
--   
--   You would not typically explicitly create these values, instead
--   converting existing Dot graphs (via <a>fromDotRepr</a>). However, one
--   way of constructing the sample graph would be:
--   
--   <pre>
--   setID (Str "G")
--   . setStrictness False
--   . setIsDirected True
--   . setClusterAttributes (Int 0) [GraphAttrs [style filled, color LightGray, textLabel "process #1"], NodeAttrs [style filled, color White]]
--   . setClusterAttributes (Int 1) [GraphAttrs [textLabel "process #2", color Blue], NodeAttrs [style filled]]
--   $ composeList [ Cntxt "a0"    (Just $ Int 0)   []               [("a3",[]),("start",[])] [("a1",[])]
--                 , Cntxt "a1"    (Just $ Int 0)   []               []                       [("a2",[]),("b3",[])]
--                 , Cntxt "a2"    (Just $ Int 0)   []               []                       [("a3",[])]
--                 , Cntxt "a3"    (Just $ Int 0)   []               [("b2",[])]              [("end",[])]
--                 , Cntxt "b0"    (Just $ Int 1)   []               [("start",[])]           [("b1",[])]
--                 , Cntxt "b1"    (Just $ Int 1)   []               []                       [("b2",[])]
--                 , Cntxt "b2"    (Just $ Int 1)   []               []                       [("b3",[])]
--                 , Cntxt "b3"    (Just $ Int 1)   []               []                       [("end",[])]
--                 , Cntxt "end"   Nothing          [shape MSquare]  []                       []
--                 , Cntxt "start" Nothing          [shape MDiamond] []                       []]
--   </pre>
module Data.GraphViz.Types.Graph

-- | A Dot graph that allows graph operations on it.
data DotGraph n

-- | A polymorphic type that covers all possible ID values allowed by Dot
--   syntax. Note that whilst the <a>ParseDot</a> and <a>PrintDot</a>
--   instances for <a>String</a> will properly take care of the special
--   cases for numbers, they are treated differently here.
data GraphID
Str :: Text -> GraphID
Num :: Number -> GraphID

-- | The decomposition of a node from a dot graph. Any loops should be
--   found in <a>successors</a> rather than <a>predecessors</a>. Note also
--   that these are created/consumed as if for <i>directed</i> graphs.
data Context n
Cntxt :: !n -> !Maybe GraphID -> !Attributes -> ![(n, Attributes)] -> ![(n, Attributes)] -> Context n
[node] :: Context n -> !n

-- | The cluster this node can be found in; <tt>Nothing</tt> indicates the
--   node can be found in the root graph.
[inCluster] :: Context n -> !Maybe GraphID
[attributes] :: Context n -> !Attributes
[predecessors] :: Context n -> ![(n, Attributes)]
[successors] :: Context n -> ![(n, Attributes)]

-- | Convert this DotGraph into canonical form. All edges are found in the
--   outer graph rather than in clusters.
toCanonical :: DotGraph n -> DotGraph n

-- | Convert a canonical Dot graph to a graph-based one. This assumes that
--   the canonical graph is the same format as returned by
--   <a>toCanonical</a>. The "unsafeness" is that:
--   
--   <ul>
--   <li>All clusters must have a unique identifier (<a>unAnonymise</a> can
--   be used to make sure all clusters <i>have</i> an identifier, but it
--   doesn't ensure uniqueness).</li>
--   <li>All nodes are assumed to be explicitly listed precisely once.</li>
--   <li>Only edges found in the root graph are considered.</li>
--   </ul>
--   
--   If this isn't the case, use <a>fromCanonical</a> instead.
--   
--   The <tt>graphToDot</tt> function from <a>Data.GraphViz</a> produces
--   output suitable for this function (assuming all clusters are provided
--   with a unique identifier); <tt>graphElemsToDot</tt> is suitable if all
--   nodes are specified in the input list (rather than just the edges).
unsafeFromCanonical :: Ord n => DotGraph n -> DotGraph n

-- | Convert any existing DotRepr instance to a <a>DotGraph</a>.
fromDotRepr :: DotRepr dg n => dg n -> DotGraph n

-- | Does this graph have any nodes?
isEmpty :: DotGraph n -> Bool

-- | Does this graph have any clusters?
hasClusters :: DotGraph n -> Bool

-- | Determine if this graph has nodes or clusters.
isEmptyGraph :: DotGraph n -> Bool
graphAttributes :: DotGraph n -> [GlobalAttributes]

-- | Which cluster (or the root graph) is this cluster in?
parentOf :: DotGraph n -> GraphID -> Maybe GraphID
clusterAttributes :: DotGraph n -> GraphID -> [GlobalAttributes]

-- | Return the ID for the cluster the node is in.
foundInCluster :: Ord n => DotGraph n -> n -> Maybe GraphID

-- | Return the attributes for the node.
attributesOf :: Ord n => DotGraph n -> n -> Attributes

-- | Predecessor edges for the specified node. For undirected graphs
--   equivalent to <a>adjacentTo</a>.
predecessorsOf :: Ord n => DotGraph n -> n -> [DotEdge n]

-- | Successor edges for the specified node. For undirected graphs
--   equivalent to <a>adjacentTo</a>.
successorsOf :: Ord n => DotGraph n -> n -> [DotEdge n]

-- | All edges involving this node.
adjacentTo :: Ord n => DotGraph n -> n -> [DotEdge n]
adjacent :: Context n -> [DotEdge n]

-- | Create a graph with no clusters.
mkGraph :: Ord n => [DotNode n] -> [DotEdge n] -> DotGraph n
emptyGraph :: DotGraph n

-- | Merge the <a>Context</a> into the graph. Assumes that the specified
--   node is not in the graph but that all endpoints in the
--   <a>successors</a> and <a>predecessors</a> (with the exception of
--   loops) are. If the cluster is not present in the graph, then it will
--   be added with no attributes with a parent of the root graph.
--   
--   Note that <tt>&amp;</tt> and <tt><a>decompose</a></tt> are <i>not</i>
--   quite inverses, as this function will add in the cluster if it does
--   not yet exist in the graph, but <a>decompose</a> will not delete it.
(&) :: Ord n => Context n -> DotGraph n -> DotGraph n
infixr 5 &

-- | Recursively merge the list of contexts.
--   
--   <pre>
--   composeList = foldr (&amp;) emptyGraph
--   </pre>
composeList :: Ord n => [Context n] -> DotGraph n

-- | Add a node to the current graph. Merges attributes and edges if the
--   node already exists in the graph.
--   
--   If the specified cluster does not yet exist in the graph, then it will
--   be added (as a sub-graph of the overall graph and no attributes).
addNode :: Ord n => n -> Maybe GraphID -> Attributes -> DotGraph n -> DotGraph n

-- | A node in <tt>DotGraph</tt>.
data DotNode n
DotNode :: n -> Attributes -> DotNode n
[nodeID] :: DotNode n -> n
[nodeAttributes] :: DotNode n -> Attributes

-- | A variant of <a>addNode</a> that takes in a DotNode (not in a
--   cluster).
addDotNode :: Ord n => DotNode n -> DotGraph n -> DotGraph n

-- | Add the specified edge to the graph; assumes both node values are
--   already present in the graph. If the graph is undirected then the
--   order of nodes doesn't matter.
addEdge :: Ord n => n -> n -> Attributes -> DotGraph n -> DotGraph n

-- | An edge in <tt>DotGraph</tt>.
data DotEdge n
DotEdge :: n -> n -> Attributes -> DotEdge n
[fromNode] :: DotEdge n -> n
[toNode] :: DotEdge n -> n
[edgeAttributes] :: DotEdge n -> Attributes

-- | A variant of <a>addEdge</a> that takes a <a>DotEdge</a> value.
addDotEdge :: Ord n => DotEdge n -> DotGraph n -> DotGraph n

-- | Add a new cluster to the graph; throws an error if the cluster already
--   exists. Assumes that it doesn't match the identifier of the overall
--   graph. If the parent cluster doesn't already exist in the graph then
--   it will be added.
addCluster :: GraphID -> Maybe GraphID -> [GlobalAttributes] -> DotGraph n -> DotGraph n

-- | Specify the parent of the cluster; adds both in if not already
--   present.
setClusterParent :: GraphID -> Maybe GraphID -> DotGraph n -> DotGraph n

-- | Specify the attributes of the cluster; adds it if not already present.
setClusterAttributes :: GraphID -> [GlobalAttributes] -> DotGraph n -> DotGraph n

-- | A partial inverse of <tt><a>&amp;</a></tt>, in that if a node exists
--   in a graph then it will be decomposed, but will not remove the cluster
--   that it was in even if it was the only node in that cluster.
decompose :: Ord n => n -> DotGraph n -> Maybe (Context n, DotGraph n)

-- | As with <a>decompose</a>, but do not specify <i>which</i> node to
--   decompose.
decomposeAny :: Ord n => DotGraph n -> Maybe (Context n, DotGraph n)

-- | Recursively decompose the Dot graph into a list of contexts such that
--   if <tt>(c:cs) = decomposeList dg</tt>, then <tt>dg = c &amp;
--   <a>composeList</a> cs</tt>.
--   
--   Note that all global attributes are lost, so this is <i>not</i>
--   suitable for representing a Dot graph on its own.
decomposeList :: Ord n => DotGraph n -> [Context n]

-- | Delete the specified node from the graph; returns the original graph
--   if that node isn't present.
deleteNode :: Ord n => n -> DotGraph n -> DotGraph n

-- | Delete all edges between the two nodes; returns the original graph if
--   there are no edges.
deleteAllEdges :: Ord n => n -> n -> DotGraph n -> DotGraph n

-- | Deletes the specified edge from the DotGraph (note: for unordered
--   graphs both orientations are considered).
deleteEdge :: Ord n => n -> n -> Attributes -> DotGraph n -> DotGraph n

-- | As with <a>deleteEdge</a> but takes a <a>DotEdge</a> rather than
--   individual values.
deleteDotEdge :: Ord n => DotEdge n -> DotGraph n -> DotGraph n

-- | Delete the specified cluster, and makes any clusters or nodes within
--   it be in its root cluster (or the overall graph if required).
deleteCluster :: GraphID -> DotGraph n -> DotGraph n

-- | Remove clusters with no sub-clusters and no nodes within them.
removeEmptyClusters :: DotGraph n -> DotGraph n
instance GHC.Read.Read Data.GraphViz.Types.Graph.GlobAttrs
instance GHC.Show.Show Data.GraphViz.Types.Graph.GlobAttrs
instance GHC.Classes.Ord Data.GraphViz.Types.Graph.GlobAttrs
instance GHC.Classes.Eq Data.GraphViz.Types.Graph.GlobAttrs
instance GHC.Read.Read Data.GraphViz.Types.Graph.ClusterInfo
instance GHC.Show.Show Data.GraphViz.Types.Graph.ClusterInfo
instance GHC.Classes.Ord Data.GraphViz.Types.Graph.ClusterInfo
instance GHC.Classes.Eq Data.GraphViz.Types.Graph.ClusterInfo
instance (GHC.Classes.Ord n, GHC.Read.Read n) => GHC.Read.Read (Data.GraphViz.Types.Graph.NodeInfo n)
instance GHC.Show.Show n => GHC.Show.Show (Data.GraphViz.Types.Graph.NodeInfo n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.GraphViz.Types.Graph.NodeInfo n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.GraphViz.Types.Graph.NodeInfo n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.GraphViz.Types.Graph.DotGraph n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.GraphViz.Types.Graph.DotGraph n)
instance GHC.Read.Read n => GHC.Read.Read (Data.GraphViz.Types.Graph.Context n)
instance GHC.Show.Show n => GHC.Show.Show (Data.GraphViz.Types.Graph.Context n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.GraphViz.Types.Graph.Context n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.GraphViz.Types.Graph.Context n)
instance GHC.Show.Show n => GHC.Show.Show (Data.GraphViz.Types.Graph.DotGraph n)
instance (GHC.Classes.Ord n, GHC.Read.Read n) => GHC.Read.Read (Data.GraphViz.Types.Graph.DotGraph n)
instance GHC.Classes.Ord n => Data.GraphViz.Types.DotRepr Data.GraphViz.Types.Graph.DotGraph n
instance GHC.Classes.Ord n => Data.GraphViz.Types.Generalised.FromGeneralisedDot Data.GraphViz.Types.Graph.DotGraph n
instance (GHC.Classes.Ord n, Data.GraphViz.Printing.PrintDot n) => Data.GraphViz.Types.PrintDotRepr Data.GraphViz.Types.Graph.DotGraph n
instance (GHC.Classes.Ord n, Data.GraphViz.Parsing.ParseDot n) => Data.GraphViz.Types.ParseDotRepr Data.GraphViz.Types.Graph.DotGraph n
instance (GHC.Classes.Ord n, Data.GraphViz.Printing.PrintDot n, Data.GraphViz.Parsing.ParseDot n) => Data.GraphViz.Types.PPDotRepr Data.GraphViz.Types.Graph.DotGraph n
instance Data.GraphViz.Printing.PrintDot n => Data.GraphViz.Printing.PrintDot (Data.GraphViz.Types.Graph.DotGraph n)
instance (GHC.Classes.Ord n, Data.GraphViz.Parsing.ParseDot n) => Data.GraphViz.Parsing.ParseDot (Data.GraphViz.Types.Graph.DotGraph n)


-- | This is the top-level module for the graphviz library. It provides
--   functions to convert <a>Graph</a>s into the <i>Dot</i> language used
--   by the <i>Graphviz</i> suite of programs (as well as a limited ability
--   to perform the reverse operation).
--   
--   If you wish to construct a Haskell representation of a Dot graph
--   yourself rather than using the conversion functions here, please see
--   the <a>Data.GraphViz.Types</a> module as a starting point for how to
--   do so.
--   
--   Information about Graphviz and the Dot language can be found at:
--   <a>http://graphviz.org/</a>
module Data.GraphViz

-- | Defines the parameters used to convert a <a>Graph</a> into a
--   <a>DotRepr</a>.
--   
--   A value of type <tt><a>GraphvizParams</a> n nl el cl l</tt> indicates
--   that the <a>Graph</a> has a node type of <tt>n</tt>, node labels of
--   type <tt>nl</tt>, edge labels of type <tt>el</tt>, corresponding
--   clusters of type <tt>cl</tt> and after clustering the nodes have a
--   label of type <tt>l</tt> (which may or may not be the same as
--   <tt>nl</tt>).
--   
--   The tuples in the function types represent labelled nodes (for
--   <tt>(n,nl)</tt> and <tt>(n,l)</tt>) and labelled edges
--   (<tt>(n,n,el)</tt>; the value <tt>(f,t,ftl)</tt> is an edge from
--   <tt>f</tt> to <tt>l</tt> with a label of <tt>ftl</tt>). These
--   correspond to <a>LNode</a> and <a>LEdge</a> in FGL graphs.
--   
--   The clustering in <a>clusterBy</a> can be to arbitrary depth.
--   
--   Note that the term "cluster" is slightly conflated here: in terms of
--   <tt>GraphvizParams</tt> values, a cluster is a grouping of nodes; the
--   <a>isDotCluster</a> function lets you specify whether it is a cluster
--   in the Dot sense or just a sub-graph.
data GraphvizParams n nl el cl l
Params :: Bool -> [GlobalAttributes] -> ((n, nl) -> NodeCluster cl (n, l)) -> (cl -> Bool) -> (cl -> GraphID) -> (cl -> [GlobalAttributes]) -> ((n, l) -> Attributes) -> ((n, n, el) -> Attributes) -> GraphvizParams n nl el cl l

-- | <tt>True</tt> if the graph is directed; <tt>False</tt> otherwise.
[isDirected] :: GraphvizParams n nl el cl l -> Bool

-- | The top-level global <a>Attributes</a> for the entire graph.
[globalAttributes] :: GraphvizParams n nl el cl l -> [GlobalAttributes]

-- | A function to specify which cluster a particular node is in.
[clusterBy] :: GraphvizParams n nl el cl l -> (n, nl) -> NodeCluster cl (n, l)

-- | Is this "cluster" actually a cluster, or just a sub-graph?
[isDotCluster] :: GraphvizParams n nl el cl l -> cl -> Bool

-- | The name/identifier for a cluster.
[clusterID] :: GraphvizParams n nl el cl l -> cl -> GraphID

-- | Specify which global attributes are applied in the given cluster.
[fmtCluster] :: GraphvizParams n nl el cl l -> cl -> [GlobalAttributes]

-- | The specific <tt>Attributes</tt> for a node.
[fmtNode] :: GraphvizParams n nl el cl l -> (n, l) -> Attributes

-- | The specific <tt>Attributes</tt> for an edge.
[fmtEdge] :: GraphvizParams n nl el cl l -> (n, n, el) -> Attributes

-- | Especially useful for quick explorations in ghci, this is a "do what I
--   mean" set of parameters that prints the specified labels of a
--   non-clustered graph.
quickParams :: (Labellable nl, Labellable el) => GraphvizParams n nl el () nl

-- | A default <a>GraphvizParams</a> value which assumes the graph is
--   directed, contains no clusters and has no <a>Attribute</a>s set.
--   
--   If you wish to have the labels of the nodes to have a different type
--   after applying <a>clusterBy</a> from before clustering, then you will
--   have to specify your own <a>GraphvizParams</a> value from scratch (or
--   use <a>blankParams</a>).
--   
--   If you use a custom <a>clusterBy</a> function (which if you actually
--   want clusters you should) then you should also override the
--   (nonsensical) default <a>clusterID</a>.
defaultParams :: GraphvizParams n nl el cl nl

-- | A variant of <a>defaultParams</a> that enforces that the clustering
--   type is <tt><tt>()</tt></tt> (i.e.: no clustering); this avoids
--   problems when using <a>defaultParams</a> internally within a function
--   without any constraint on what the clustering type is.
nonClusteredParams :: GraphvizParams n nl el () nl

-- | A <a>GraphvizParams</a> value where every field is set to
--   <tt><a>undefined</a></tt>. This is useful when you have a function
--   that will set some of the values for you (e.g. <a>setDirectedness</a>)
--   but you don't want to bother thinking of default values to set in the
--   meantime. This is especially useful when you are programmatically
--   setting the clustering function (and as such do not know what the
--   types might be).
blankParams :: GraphvizParams n nl el cl l

-- | Determine if the provided <a>Graph</a> is directed or not and set the
--   value of <a>isDirected</a> appropriately.
setDirectedness :: (Ord el, Graph gr) => (GraphvizParams Node nl el cl l -> gr nl el -> a) -> GraphvizParams Node nl el cl l -> gr nl el -> a

-- | Define into which cluster a particular node belongs. Clusters can be
--   nested to arbitrary depth.
data NodeCluster c a

-- | Indicates the actual Node in the Graph.
N :: a -> NodeCluster c a

-- | Indicates that the <a>NodeCluster</a> is in the Cluster <i>c</i>.
C :: c -> NodeCluster c a -> NodeCluster c a

-- | An alias for <a>NodeCluster</a> when dealing with FGL graphs.
type LNodeCluster cl l = NodeCluster cl (Node, l)

-- | Convert a graph to <i>Dot</i> format, using the specified parameters
--   to cluster the graph, etc.
graphToDot :: (Ord cl, Graph gr) => GraphvizParams Node nl el cl l -> gr nl el -> DotGraph Node

-- | As with <a>graphToDot</a>, but this allows you to easily convert other
--   graph-like formats to a Dot graph as long as you can get a list of
--   nodes and edges from it.
graphElemsToDot :: (Ord cl, Ord n) => GraphvizParams n nl el cl l -> [(n, nl)] -> [(n, n, el)] -> DotGraph n

-- | A pseudo-inverse to <a>graphToDot</a>; "pseudo" in the sense that the
--   original node and edge labels aren't able to be reconstructed.
dotToGraph :: (DotRepr dg Node, Graph gr) => dg Node -> gr Attributes Attributes

-- | Augment the current node label type with the <a>Attributes</a> applied
--   to that node.
type AttributeNode nl = (Attributes, nl)

-- | Augment the current edge label type with the <a>Attributes</a> applied
--   to that edge.
type AttributeEdge el = (Attributes, el)

-- | Run the appropriate Graphviz command on the graph to get positional
--   information and then combine that information back into the original
--   graph.
graphToGraph :: (Ord cl, Graph gr) => GraphvizParams Node nl el cl l -> gr nl el -> IO (gr (AttributeNode nl) (AttributeEdge el))

-- | This is a "quick-and-dirty" graph augmentation function that sets no
--   <a>Attributes</a> and thus should be referentially transparent and is
--   wrapped in <a>unsafePerformIO</a>.
--   
--   Note that the provided <a>GraphvizParams</a> is only used for
--   <a>isDirected</a>, <a>clusterBy</a> and <a>clusterID</a>.
dotizeGraph :: (Ord cl, Graph gr) => GraphvizParams Node nl el cl l -> gr nl el -> gr (AttributeNode nl) (AttributeEdge el)

-- | Used to augment an edge label with a unique identifier.
data EdgeID el

-- | Add unique edge identifiers to each label. This is useful for when
--   multiple edges between two nodes need to be distinguished.
addEdgeIDs :: Graph gr => gr nl el -> gr nl (EdgeID el)

-- | Add a custom attribute to the list of attributes containing the value
--   of the unique edge identifier.
setEdgeIDAttribute :: (LEdge el -> Attributes) -> LEdge (EdgeID el) -> Attributes

-- | Pass the <a>DotRepr</a> through the relevant command and then augment
--   the <a>Graph</a> that it came from.
dotAttributes :: (Graph gr, PPDotRepr dg Node, FromGeneralisedDot dg Node) => Bool -> gr nl (EdgeID el) -> dg Node -> IO (gr (AttributeNode nl) (AttributeEdge el))

-- | Use the <a>Attributes</a> in the provided <a>DotGraph</a> to augment
--   the node and edge labels in the provided <a>Graph</a>. The unique
--   identifiers on the edges are also stripped off.
--   
--   Please note that the behaviour for this function is undefined if the
--   <a>DotGraph</a> does not come from the original <a>Graph</a> (either
--   by using a conversion function or by passing the result of a
--   conversion function through a <a>GraphvizCommand</a> via the
--   <a>DotOutput</a> or similar).
augmentGraph :: (Graph gr, DotRepr dg Node) => gr nl (EdgeID el) -> dg Node -> gr (AttributeNode nl) (AttributeEdge el)

-- | Quickly visualise a graph using the <a>Xlib</a> <a>GraphvizCanvas</a>.
--   If your label types are not (and cannot) be instances of
--   <a>Labellable</a>, you may wish to use <a>gmap</a>, <a>nmap</a> or
--   <a>emap</a> to set them to a value such as <tt>""</tt>.
preview :: (Ord el, Graph gr, Labellable nl, Labellable el) => gr nl el -> IO ()

-- | A Dot graph in canonical form.
data DotGraph n
DotGraph :: Bool -> Bool -> Maybe GraphID -> DotStatements n -> DotGraph n

-- | If <a>True</a>, no multiple edges are drawn.
[strictGraph] :: DotGraph n -> Bool
[directedGraph] :: DotGraph n -> Bool
[graphID] :: DotGraph n -> Maybe GraphID
[graphStatements] :: DotGraph n -> DotStatements n
data DotStatements n
DotStmts :: [GlobalAttributes] -> [DotSubGraph n] -> [DotNode n] -> [DotEdge n] -> DotStatements n
[attrStmts] :: DotStatements n -> [GlobalAttributes]
[subGraphs] :: DotStatements n -> [DotSubGraph n]
[nodeStmts] :: DotStatements n -> [DotNode n]
[edgeStmts] :: DotStatements n -> [DotEdge n]
data DotSubGraph n
DotSG :: Bool -> Maybe GraphID -> DotStatements n -> DotSubGraph n
[isCluster] :: DotSubGraph n -> Bool
[subGraphID] :: DotSubGraph n -> Maybe GraphID
[subGraphStmts] :: DotSubGraph n -> DotStatements n
instance GHC.Show.Show el => GHC.Show.Show (Data.GraphViz.EdgeID el)
instance GHC.Classes.Ord el => GHC.Classes.Ord (Data.GraphViz.EdgeID el)
instance GHC.Classes.Eq el => GHC.Classes.Eq (Data.GraphViz.EdgeID el)
