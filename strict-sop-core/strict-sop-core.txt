-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Strict replacement for NS and NP from <tt>sop-core</tt>.
@package strict-sop-core
@version 0.1.3.0


-- | Strict variant of NP
--   
--   See <a><tt>sop-core</tt>'s NP</a>.
module Data.SOP.Strict.NP
data NP f xs
[Nil] :: NP f '[]
[:*] :: !f x -> !NP f xs -> NP f (x ': xs)
infixr 5 :*
hd :: NP f (x ': xs) -> f x

-- | Version of <tt>map_NP</tt> that does not require a singleton
map_NP' :: forall f g xs. (forall a. f a -> g a) -> NP f xs -> NP g xs

-- | Conjure up an <a>SListI</a> constraint from an <a>NP</a>
npToSListI :: NP a xs -> (SListI xs => r) -> r
singletonNP :: f x -> NP f '[x]
tl :: NP f (x ': xs) -> NP f xs
instance forall k (f :: k -> *) (xs :: [k]). Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq f) xs => GHC.Classes.Eq (Data.SOP.Strict.NP.NP f xs)
instance forall k (f :: k -> *) (xs :: [k]). (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq f) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Ord f) xs) => GHC.Classes.Ord (Data.SOP.Strict.NP.NP f xs)
instance Data.SOP.Classes.HPure Data.SOP.Strict.NP.NP
instance Data.SOP.Classes.HAp Data.SOP.Strict.NP.NP
instance Data.SOP.Classes.HCollapse Data.SOP.Strict.NP.NP
instance Data.SOP.Classes.HSequence Data.SOP.Strict.NP.NP
instance Data.SOP.Classes.HTraverse_ Data.SOP.Strict.NP.NP
instance Data.SOP.Classes.HTrans Data.SOP.Strict.NP.NP Data.SOP.Strict.NP.NP
instance forall k (f :: k -> *) (xs :: [k]). Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Show.Show f) xs => GHC.Show.Show (Data.SOP.Strict.NP.NP f xs)
instance forall k (f :: k -> *) (xs :: [k]). Data.SOP.Constraint.All (Data.SOP.Constraint.Compose NoThunks.Class.NoThunks f) xs => NoThunks.Class.NoThunks (Data.SOP.Strict.NP.NP f xs)


-- | Strict variant of NS
--   
--   See <a><tt>sop-core</tt>'s NS</a>.
module Data.SOP.Strict.NS
data NS f xs
[Z] :: !f x -> NS f (x ': xs)
[S] :: !NS f xs -> NS f (x ': xs)
index_NS :: forall f xs. NS f xs -> Int
partition_NS :: forall xs f. SListI xs => [NS f xs] -> NP ([] :.: f) xs

-- | Version of <tt>sequence_NS</tt> that requires only <a>Functor</a>
--   
--   The version in the library requires <a>Applicative</a>, which is
--   unnecessary.
sequence_NS' :: forall xs f g. Functor f => NS (f :.: g) xs -> f (NS g xs)
unZ :: NS f '[x] -> f x
type Injection (f :: k -> Type) (xs :: [k]) = f -.-> K (NS f xs)
injections :: forall xs f. SListI xs => NP (Injection f xs) xs
instance forall k (f :: k -> *) (xs :: [k]). Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Show.Show f) xs => GHC.Show.Show (Data.SOP.Strict.NS.NS f xs)
instance forall k (f :: k -> *) (xs :: [k]). Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq f) xs => GHC.Classes.Eq (Data.SOP.Strict.NS.NS f xs)
instance forall k (f :: k -> *) (xs :: [k]). (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq f) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Ord f) xs) => GHC.Classes.Ord (Data.SOP.Strict.NS.NS f xs)
instance Data.SOP.Classes.HExpand Data.SOP.Strict.NS.NS
instance Data.SOP.Classes.HAp Data.SOP.Strict.NS.NS
instance Data.SOP.Classes.HCollapse Data.SOP.Strict.NS.NS
instance Data.SOP.Classes.HSequence Data.SOP.Strict.NS.NS
instance Data.SOP.Classes.HTrans Data.SOP.Strict.NS.NS Data.SOP.Strict.NS.NS
instance forall k (f :: k -> *) (xs :: [k]). Data.SOP.Constraint.All (Data.SOP.Constraint.Compose NoThunks.Class.NoThunks f) xs => NoThunks.Class.NoThunks (Data.SOP.Strict.NS.NS f xs)


-- | Strict variant of SOP
module Data.SOP.Strict
fn_5 :: (f0 a -> f1 a -> f2 a -> f3 a -> f4 a -> f5 a) -> (f0 -.-> (f1 -.-> (f2 -.-> (f3 -.-> (f4 -.-> f5))))) a
