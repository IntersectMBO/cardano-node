-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for strongly typed protocols
--   
--   A framework for strongly typed protocols
@package typed-protocols-stateful
@version 0.3.0.0


-- | Stateful codec. This module is intended to be imported qualified.
module Network.TypedProtocol.Stateful.Codec

-- | A stateful codec.
data Codec ps failure (f :: ps -> Type) m bytes
Codec :: (forall (st :: ps) (st' :: ps). StateTokenI st => ActiveState st => f st -> Message ps st st' -> bytes) -> (forall (st :: ps). ActiveState st => StateToken st -> f st -> m (DecodeStep bytes failure m (SomeMessage st))) -> Codec ps failure (f :: ps -> Type) m bytes
[encode] :: Codec ps failure (f :: ps -> Type) m bytes -> forall (st :: ps) (st' :: ps). StateTokenI st => ActiveState st => f st -> Message ps st st' -> bytes
[decode] :: Codec ps failure (f :: ps -> Type) m bytes -> forall (st :: ps). ActiveState st => StateToken st -> f st -> m (DecodeStep bytes failure m (SomeMessage st))
hoistCodec :: Functor n => (forall x. m x -> n x) -> Codec ps failure f m bytes -> Codec ps failure f n bytes
isoCodec :: Functor m => (bytes -> bytes') -> (bytes' -> bytes) -> Codec ps failure f m bytes -> Codec ps failure f m bytes'
mapFailureCodec :: Functor m => (failure -> failure') -> Codec ps failure f m bytes -> Codec ps failure' f m bytes
liftCodec :: Codec ps failure m bytes -> Codec ps failure f m bytes
data () => DecodeStep bytes failure (m :: Type -> Type) a
DecodePartial :: (Maybe bytes -> m (DecodeStep bytes failure m a)) -> DecodeStep bytes failure (m :: Type -> Type) a
DecodeDone :: a -> Maybe bytes -> DecodeStep bytes failure (m :: Type -> Type) a
DecodeFail :: failure -> DecodeStep bytes failure (m :: Type -> Type) a
runDecoder :: Monad m => [bytes] -> DecodeStep bytes failure m a -> m (Either failure a)
runDecoderPure :: Monad m => (forall b. () => m b -> b) -> m (DecodeStep bytes failure m a) -> [bytes] -> Either failure a
data () => SomeMessage (st :: ps)
[SomeMessage] :: forall ps (st :: ps) (st' :: ps). (StateTokenI st, StateTokenI st', ActiveState st) => Message ps st st' -> SomeMessage st
type family StateToken :: ps -> Type
class () => StateTokenI (st :: ps)
stateToken :: StateTokenI st => StateToken st
type ActiveState (st :: ps) = IsActiveState st StateAgency st
data () => PeerRole
AsClient :: PeerRole
AsServer :: PeerRole
data () => CodecFailure
CodecFailureOutOfInput :: CodecFailure
CodecFailure :: String -> CodecFailure

-- | Any message for a protocol, with a <a>StateTokenI</a> constraint which
--   gives access to protocol state.
--   
--   Used where we don't know statically what the state type is, but need
--   the agency and message to match each other.
data AnyMessage ps (f :: ps -> Type)
[AnyMessage] :: forall ps f (st :: ps) (st' :: ps). (StateTokenI st, ActiveState st) => f st -> Message ps (st :: ps) (st' :: ps) -> AnyMessage ps f

-- | A convenient pattern synonym which unwrap <a>AnyMessage</a> giving
--   both the singleton for the state and the message.
pattern AnyMessageAndAgency :: forall ps f. () => forall (st :: ps) (st' :: ps). (StateTokenI st, ActiveState st) => StateToken st -> f st -> Message ps st st' -> AnyMessage ps f

-- | <a>showAnyMessage</a> is can be used to provide <a>Show</a> instance
--   for <a>AnyMessage</a> if showing <a>Message</a> is independent of the
--   state or one accepts showing only partial information included in
--   message constructors or accepts message constructors to carry
--   <a>Show</a> instances for its arguments. Note that the proper solution
--   is to define a custom `Show (AnyMessage ps f)` instance for a protocol
--   <tt>ps</tt>, which give access to the state functor <tt>f</tt> in
--   scope of <a>show</a>.
showAnyMessage :: forall ps f. (forall st st'. Show (Message ps st st'), forall st. Show (f st)) => AnyMessage ps f -> String

-- | The <a>Codec</a> round-trip property: decode after encode gives the
--   same message. Every codec must satisfy this property.
prop_codecM :: forall ps failure f m bytes. (Monad m, Eq (AnyMessage ps f)) => Codec ps failure f m bytes -> AnyMessage ps f -> m Bool

-- | The <a>Codec</a> round-trip property in a pure monad.
prop_codec :: forall ps failure f m bytes. (Monad m, Eq (AnyMessage ps f)) => (forall a. m a -> a) -> Codec ps failure f m bytes -> AnyMessage ps f -> Bool

-- | A variant on the codec round-trip property: given the encoding of a
--   message, check that decode always gives the same result irrespective
--   of how the chunks of input are fed to the incremental decoder.
--   
--   This property guards against boundary errors in incremental decoders.
--   It is not necessary to check this for every message type, just for
--   each generic codec construction. For example given some binary
--   serialisation library one would write a generic adaptor to the codec
--   interface. This adaptor has to deal with the incremental decoding and
--   this is what needs to be checked.
prop_codec_splitsM :: forall ps failure f m bytes. (Monad m, Eq (AnyMessage ps f)) => (bytes -> [[bytes]]) -> Codec ps failure f m bytes -> AnyMessage ps f -> m Bool

-- | Like <tt><a>prop_codec_splitsM</a></tt> but run in a pure monad
--   <tt>m</tt>, e.g. <tt>Identity</tt>.
prop_codec_splits :: forall ps failure f m bytes. (Monad m, Eq (AnyMessage ps f)) => (bytes -> [[bytes]]) -> (forall a. m a -> a) -> Codec ps failure f m bytes -> AnyMessage ps f -> Bool

-- | Compatibility between two codecs of the same protocol. Encode a
--   message with one codec and decode it with the other one, then compare
--   if the result is the same as initial message.
prop_codecs_compatM :: forall ps failure f m bytes. (Monad m, Eq (AnyMessage ps f), forall a. Monoid a => Monoid (m a)) => Codec ps failure f m bytes -> Codec ps failure f m bytes -> AnyMessage ps f -> m Bool

-- | Like <tt><a>prop_codecs_compatM</a></tt> but run in a pure monad
--   <tt>m</tt>, e.g. <tt>Identity</tt>.
prop_codecs_compat :: forall ps failure f m bytes. (Monad m, Eq (AnyMessage ps f), forall a. Monoid a => Monoid (m a)) => (forall a. m a -> a) -> Codec ps failure f m bytes -> Codec ps failure f m bytes -> AnyMessage ps f -> Bool


-- | Protocol stateful EDSL.
--   
--   <b>Note</b>: <a>Client</a> and <a>Server</a> patterns are easier to
--   use.
module Network.TypedProtocol.Stateful.Peer

-- | A description of a peer that engages in a protocol.
--   
--   The protocol describes what messages peers <i>may</i> send or
--   <i>must</i> accept. A particular peer implementation decides what to
--   actually do within the constraints of the protocol.
--   
--   Peers engage in a protocol in either the client or server role. Of
--   course the client role can only interact with the serve role for the
--   same protocol and vice versa.
--   
--   <a>Peer</a> has several type arguments:
--   
--   <ul>
--   <li>the protocol itself;</li>
--   <li>the client/server role;</li>
--   <li>.the current protocol state;</li>
--   <li>the local state type;</li>
--   <li>the monad in which the peer operates; and</li>
--   <li>the type of any final result once the peer terminates.</li>
--   </ul>
--   
--   For example:
--   
--   <pre>
--   reqRespClientExample :: Peer (ReqResp FileAPI) AsClient StIdle State m ()
--   reqRespServerExample :: Peer (ReqResp FileAPI) AsServer StIdle State m Int
--   </pre>
--   
--   The actions that a peer can take are:
--   
--   <ul>
--   <li>perform a local monadic effect,</li>
--   <li>terminate with a result (but only in a terminal protocol
--   state),</li>
--   <li>send a message (but only in a protocol state in which we have
--   agency),</li>
--   <li>wait to receive a message (but only in a protocol state in which
--   the other peer has agency).</li>
--   </ul>
--   
--   The <a>Yield</a>, <a>Await</a> and <a>Done</a> constructors require to
--   provide an evidence that the appropriate peer has agency. This
--   information is supplied using one of the constructors of
--   <a>ReflRelativeAgency</a>.
--   
--   While this evidence must be provided, the types guarantee that it is
--   not possible to supply incorrect evidence. The <a>Client</a> or
--   <a>Server</a> pattern synonyms provide this evidence automatically.
--   
--   TODO: We are not exposing pipelined version, since it is not possible
--   to write a driver &amp; proofs in a type safe which take into account
--   the state when the peer type only tracks depth of pipelining rather
--   than pipelined transitions.
data Peer ps pr st f m a

-- | Perform a local monadic effect and then continue.
--   
--   Example:
--   
--   <pre>
--   Effect $ do
--     ...          -- actions in the monad
--     return $ ... -- another Peer value
--   </pre>
[Effect] :: forall ps pr st f m a. m (Peer ps pr st f m a) -> Peer ps pr st f m a

-- | Send a message to the other peer and then continue. The constructor
--   requires evidence that we have agency for this protocol state and thus
--   are allowed to send messages. It takes local state associated to the
--   source and target protocol state of the message that is sent. This
--   state is only maintained locally, never shared remotely. It also takes
--   the message and the continuation. It also requires evidence that we
--   have agency for this protocol state and thus are allowed to send
--   messages.
--   
--   Example:
--   
--   <pre>
--   Yield ReflClientAgency (StateBusy (ReadFile /etc/os-release))
--                          StateIdle
--                        $ MsgResp "..."
--   </pre>
[Yield] :: forall ps pr (st :: ps) (st' :: ps) f m a. (StateTokenI st, StateTokenI st', ActiveState st) => WeHaveAgencyProof pr st -> f st -> f st' -> Message ps st st' -> Peer ps pr st' f m a -> Peer ps pr st f m a

-- | Waits to receive a message from the other peer and then continues.
--   This takes the continuation that is supplied with the received
--   message. It also requires evidence that the other peer has agency for
--   this protocol state and thus we are expected to wait to receive
--   messages.
--   
--   Note that the continuation that gets supplied with the message must be
--   prepared to deal with <i>any</i> message that is allowed in
--   <i>this</i> protocol state. This is why the continuation <i>must</i>
--   be polymorphic in the target state of the message (the third type
--   argument of <a>Message</a>).
--   
--   Example:
--   
--   <pre>
--   Await ReflClientAgency $ \f msg -&gt;
--   case (f, msg) of
--     (StateBusy (ReadFile path), MsgResp resp) -&gt;
--       ( _continuation
--       , StateIdle
--       )
--   </pre>
[Await] :: forall ps pr (st :: ps) f m a. (StateTokenI st, ActiveState st) => TheyHaveAgencyProof pr st -> (forall (st' :: ps). f st -> Message ps st st' -> (Peer ps pr st' f m a, f st')) -> Peer ps pr st f m a

-- | Terminate with a result. A state token must be provided from the
--   <a>NobodyHasAgency</a> states, to show that this is a state in which
--   we can terminate.
--   
--   Example:
--   
--   <pre>
--   Yield ReflClientAgency
--          MsgDone
--         (Done ReflNobodyAgency TokDone result)
--   </pre>
[Done] :: forall ps pr (st :: ps) f m a. (StateTokenI st, StateAgency st ~ NobodyAgency) => NobodyHasAgencyProof pr st -> a -> Peer ps pr st f m a
instance forall (m :: * -> *) ps (pr :: Network.TypedProtocol.Core.PeerRole) (st :: ps) (f :: ps -> *). GHC.Base.Functor m => GHC.Base.Functor (Network.TypedProtocol.Stateful.Peer.Peer ps pr st f m)


-- | Actions for running <a>Peer</a>s with a <a>Driver</a>. This module
--   should be imported qualified.
module Network.TypedProtocol.Stateful.Driver
data Driver ps (pr :: PeerRole) bytes failure dstate f m
Driver :: (forall (st :: ps) (st' :: ps). StateTokenI st => StateTokenI st' => ActiveState st => ReflRelativeAgency (StateAgency st) WeHaveAgency (Relative pr (StateAgency st)) -> f st -> Message ps st st' -> m ()) -> (forall (st :: ps). StateTokenI st => ActiveState st => ReflRelativeAgency (StateAgency st) TheyHaveAgency (Relative pr (StateAgency st)) -> f st -> dstate -> m (SomeMessage st, dstate)) -> dstate -> Driver ps (pr :: PeerRole) bytes failure dstate f m

-- | Send a message.
[sendMessage] :: Driver ps (pr :: PeerRole) bytes failure dstate f m -> forall (st :: ps) (st' :: ps). StateTokenI st => StateTokenI st' => ActiveState st => ReflRelativeAgency (StateAgency st) WeHaveAgency (Relative pr (StateAgency st)) -> f st -> Message ps st st' -> m ()

-- | Receive a message, a blocking action which reads from the network and
--   runs the incremental decoder until a full message is decoded.
[recvMessage] :: Driver ps (pr :: PeerRole) bytes failure dstate f m -> forall (st :: ps). StateTokenI st => ActiveState st => ReflRelativeAgency (StateAgency st) TheyHaveAgency (Relative pr (StateAgency st)) -> f st -> dstate -> m (SomeMessage st, dstate)

-- | Initial decoder state.
[initialDState] :: Driver ps (pr :: PeerRole) bytes failure dstate f m -> dstate

-- | Run a peer with the given driver.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
--   
--   NOTE: this function threads local state (i.e. <tt>f</tt>) through
--   evolution of a protocol (i.e. <a>Peer</a>).
runPeerWithDriver :: forall ps (st :: ps) pr bytes failure dstate (f :: ps -> Type) m a. MonadSTM m => Driver ps pr bytes failure dstate f m -> f st -> Peer ps pr st f m a -> m (a, dstate)
data () => SomeMessage (st :: ps)
[SomeMessage] :: forall ps (st :: ps) (st' :: ps). (StateTokenI st, StateTokenI st', ActiveState st) => Message ps st st' -> SomeMessage st
data () => DecodeStep bytes failure (m :: Type -> Type) a
DecodePartial :: (Maybe bytes -> m (DecodeStep bytes failure m a)) -> DecodeStep bytes failure (m :: Type -> Type) a
DecodeDone :: a -> Maybe bytes -> DecodeStep bytes failure (m :: Type -> Type) a
DecodeFail :: failure -> DecodeStep bytes failure (m :: Type -> Type) a


-- | Bidirectional patterns for <tt><a>Peer</a> ps <a>AsClient</a></tt>.
--   The advantage of these patterns is that they automatically provide the
--   <tt>RelativeAgencyEq</tt> singleton.
module Network.TypedProtocol.Stateful.Peer.Client
type Client ps st f m a = Peer ps AsClient st f m a

-- | Client role pattern for <a>Effect</a>.
pattern Effect :: forall ps st f m a. m (Client ps st f m a) -> Client ps st f m a

-- | Client role pattern for <a>Yield</a>
pattern Yield :: forall ps st f m a. () => forall st'. (StateTokenI st, StateTokenI st', StateAgency st ~ ClientAgency) => f st -> f st' -> Message ps st st' -> Client ps st' f m a -> Client ps st f m a

-- | Client role pattern for <a>Await</a>
pattern Await :: forall ps st f m a. () => (StateTokenI st, StateAgency st ~ ServerAgency) => (forall st'. f st -> Message ps st st' -> (Client ps st' f m a, f st')) -> Client ps st f m a

-- | Client role pattern for <a>Done</a>
pattern Done :: forall ps st f m a. () => (StateTokenI st, StateAgency st ~ NobodyAgency) => a -> Client ps st f m a


-- | Bidirectional patterns for <tt><a>Peer</a> ps <a>AsServer</a></tt>.
--   The advantage of these patterns is that they automatically provide the
--   <tt>RelativeAgencyEq</tt> singleton.
module Network.TypedProtocol.Stateful.Peer.Server
type Server ps st f m a = Peer ps AsServer st f m a

-- | Server role pattern for <a>Effect</a>.
pattern Effect :: forall ps st f m a. m (Server ps st f m a) -> Server ps st f m a

-- | Server role pattern for <a>Yield</a>
pattern Yield :: forall ps st f m a. () => forall st'. (StateTokenI st, StateTokenI st', StateAgency st ~ ServerAgency) => f st -> f st' -> Message ps st st' -> Server ps st' f m a -> Server ps st f m a

-- | Server role pattern for <a>Await</a>
pattern Await :: forall ps st f m a. () => (StateTokenI st, StateAgency st ~ ClientAgency) => (forall st'. f st -> Message ps st st' -> (Server ps st' f m a, f st')) -> Server ps st f m a

-- | Server role pattern for <a>Done</a>
pattern Done :: forall ps st f m a. () => (StateTokenI st, StateAgency st ~ NobodyAgency) => a -> Server ps st f m a


-- | Proofs about the typed protocol framework.
--   
--   It also provides helpful testing utilities.
module Network.TypedProtocol.Stateful.Proofs
connect :: forall ps (pr :: PeerRole) (st :: ps) (f :: ps -> Type) m a b. (MonadSTM m, SingI pr) => f st -> Peer ps pr st f m a -> Peer ps (FlipAgency pr) st f m b -> m (a, b, TerminalStates ps)
data () => TerminalStates ps
[TerminalStates] :: forall ps (st :: ps). StateAgency st ~ 'NobodyAgency => StateToken st -> StateToken st -> TerminalStates ps

-- | Remove state for non-pipelined peers.
--   
--   TODO: There's a difficulty to write <a>removeState</a> for pipelined
--   peers which is type safe. The <a>Peer</a> doesn't track all pipelined
--   transitions, just the depth of pipelining, so we cannot push `f st` to
--   a queue which type is linked to <a>Peer</a>. For a similar reason
--   there's no way to write <tt>forgetPipelined</tt> function.
--   
--   However, this is possible if <a>Peer</a> tracks all transitions.
removeState :: Functor m => f st -> Peer ps pr st f m a -> Peer ps pr NonPipelined st m a
