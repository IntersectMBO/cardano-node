-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Concise Binary Object Representation (CBOR)
--   
--   This package provides an efficient implementation of the Concise
--   Binary Object Representation (CBOR), as specified by <a>RFC 7049</a>.
--   
--   If you are looking for a library for serialisation of Haskell values,
--   have a look at the <a>serialise</a> package, which is built upon this
--   library.
--   
--   An implementation of the standard bijection between CBOR and JSON is
--   provided by the <a>cborg-json</a> package. Also see <a>cbor-tool</a>
--   for a convenient command-line utility for working with CBOR data.
--   
--   This package was formerly known as <tt>binary-serialise-cbor</tt>.
@package cborg
@version 0.2.10.0


-- | A ByteArray with more instances than <a>ByteArray</a>. Some day when
--   these instances are reliably available from <tt>primitive</tt> we can
--   likely replace this with <a>ByteArray</a>.
module Codec.CBOR.ByteArray.Sliced
data SlicedByteArray
SBA :: !ByteArray -> !Int -> !Int -> SlicedByteArray
[unSBA] :: SlicedByteArray -> !ByteArray
[offset] :: SlicedByteArray -> !Int
[length] :: SlicedByteArray -> !Int
sizeofSlicedByteArray :: SlicedByteArray -> Int
fromShortByteString :: ShortByteString -> SlicedByteArray
fromByteString :: ByteString -> SlicedByteArray
fromByteArray :: ByteArray -> SlicedByteArray

-- | Note that this may require a copy.
toByteString :: SlicedByteArray -> ByteString
toBuilder :: SlicedByteArray -> Builder
instance Data.String.IsString Codec.CBOR.ByteArray.Sliced.SlicedByteArray
instance GHC.IsList.IsList Codec.CBOR.ByteArray.Sliced.SlicedByteArray
instance GHC.Show.Show Codec.CBOR.ByteArray.Sliced.SlicedByteArray
instance GHC.Classes.Eq Codec.CBOR.ByteArray.Sliced.SlicedByteArray
instance GHC.Classes.Ord Codec.CBOR.ByteArray.Sliced.SlicedByteArray


-- | A ByteArray with more instances than <a>ByteArray</a>. Some day when
--   these instances are reliably available from <tt>primitive</tt> we can
--   likely replace this with <a>ByteArray</a>.
module Codec.CBOR.ByteArray
newtype ByteArray
BA :: ByteArray -> ByteArray
[unBA] :: ByteArray -> ByteArray
sizeofByteArray :: ByteArray -> Int
fromShortByteString :: ShortByteString -> ByteArray
toShortByteString :: ByteArray -> ShortByteString
fromByteString :: ByteString -> ByteArray
toBuilder :: ByteArray -> Builder
toSliced :: ByteArray -> SlicedByteArray
instance GHC.Show.Show Codec.CBOR.ByteArray.ByteArray
instance GHC.Classes.Eq Codec.CBOR.ByteArray.ByteArray
instance GHC.Classes.Ord Codec.CBOR.ByteArray.ByteArray
instance Data.String.IsString Codec.CBOR.ByteArray.ByteArray
instance GHC.IsList.IsList Codec.CBOR.ByteArray.ByteArray


-- | High level API for decoding values that were encoded with the
--   <a>Codec.CBOR.Encoding</a> module, using a <a>Monad</a> based
--   interface.
module Codec.CBOR.Decoding

-- | A continuation-based decoder, used for decoding values that were
--   previously encoded using the <a>Codec.CBOR.Encoding</a> module. As
--   <a>Decoder</a> has a <a>Monad</a> instance, you can easily write
--   <a>Decoder</a>s monadically for building your deserialisation logic.
data Decoder s a

-- | An action, representing a step for a decoder to taken and a
--   continuation to invoke with the expected value.
data DecodeAction s a
ConsumeWord :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord8 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord16 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord32 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeNegWord :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt8 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt16 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt32 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeListLen :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLen :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeTag :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInteger :: (Integer -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloat :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeDouble :: (Double# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytes :: (ByteString -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeByteArray :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeString :: (Text -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeUtf8ByteArray :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBool :: (Bool -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeSimple :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytesIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeStringIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeListLenIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeMapLenIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeNull :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeListLenOrIndef :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLenOrIndef :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBreakOr :: (Bool -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekTokenType :: (TokenType -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekAvailable :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekByteOffset :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWordCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord8Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord16Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord32Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeNegWordCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeIntCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt8Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt16Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt32Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeListLenCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLenCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeTagCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeIntegerCanonical :: (Integer -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloat16Canonical :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloatCanonical :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeDoubleCanonical :: (Double# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytesCanonical :: (ByteString -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeByteArrayCanonical :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeStringCanonical :: (Text -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeUtf8ByteArrayCanonical :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeSimpleCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
Fail :: String -> DecodeAction s a
Done :: a -> DecodeAction s a

-- | Lift an <tt>ST</tt> action into a <tt>Decoder</tt>. Useful for, e.g.,
--   leveraging in-place mutation to efficiently build a deserialised
--   value.
liftST :: ST s a -> Decoder s a

-- | Given a <a>Decoder</a>, give us the <a>DecodeAction</a>
getDecodeAction :: Decoder s a -> ST s (DecodeAction s a)

-- | Decode a <a>Word</a>.
decodeWord :: Decoder s Word

-- | Decode a <a>Word8</a>.
decodeWord8 :: Decoder s Word8

-- | Decode a <a>Word16</a>.
decodeWord16 :: Decoder s Word16

-- | Decode a <a>Word32</a>.
decodeWord32 :: Decoder s Word32

-- | Decode a <a>Word64</a>.
decodeWord64 :: Decoder s Word64

-- | Decode a negative <a>Word</a>.
decodeNegWord :: Decoder s Word

-- | Decode a negative <a>Word64</a>.
decodeNegWord64 :: Decoder s Word64

-- | Decode an <a>Int</a>.
decodeInt :: Decoder s Int

-- | Decode an <a>Int8</a>.
decodeInt8 :: Decoder s Int8

-- | Decode an <a>Int16</a>.
decodeInt16 :: Decoder s Int16

-- | Decode an <a>Int32</a>.
decodeInt32 :: Decoder s Int32

-- | Decode an <a>Int64</a>.
decodeInt64 :: Decoder s Int64

-- | Decode an <a>Integer</a>.
decodeInteger :: Decoder s Integer

-- | Decode a <a>Float</a>.
decodeFloat :: Decoder s Float

-- | Decode a <a>Double</a>.
decodeDouble :: Decoder s Double

-- | Decode a string of bytes as a <a>ByteString</a>.
decodeBytes :: Decoder s ByteString

-- | Decode a token marking the beginning of an indefinite length set of
--   bytes.
decodeBytesIndef :: Decoder s ()

-- | Decode a string of bytes as a <a>ByteArray</a>.
--   
--   Also note that this will eagerly copy the content out of the input to
--   ensure that the input does not leak in the event that the
--   <a>ByteArray</a> is live but not forced.
decodeByteArray :: Decoder s ByteArray

-- | Decode a textual string as a piece of <a>Text</a>.
decodeString :: Decoder s Text

-- | Decode a token marking the beginning of an indefinite length string.
decodeStringIndef :: Decoder s ()

-- | Decode a textual string as UTF-8 encoded <a>ByteArray</a>. Note that
--   the result is not validated to be well-formed UTF-8.
--   
--   Also note that this will eagerly copy the content out of the input to
--   ensure that the input does not leak in the event that the
--   <a>ByteArray</a> is live but not forced.
decodeUtf8ByteArray :: Decoder s ByteArray

-- | Decode the length of a list.
decodeListLen :: Decoder s Int

-- | Decode a token marking the beginning of a list of indefinite length.
decodeListLenIndef :: Decoder s ()

-- | Decode the length of a map.
decodeMapLen :: Decoder s Int

-- | Decode a token marking the beginning of a map of indefinite length.
decodeMapLenIndef :: Decoder s ()

-- | Decode an arbitrary tag and return it as a <a>Word</a>.
decodeTag :: Decoder s Word

-- | Decode an arbitrary 64-bit tag and return it as a <a>Word64</a>.
decodeTag64 :: Decoder s Word64

-- | Decode a bool.
decodeBool :: Decoder s Bool

-- | Decode a nullary value, and return a unit value.
decodeNull :: Decoder s ()

-- | Decode a <tt>simple</tt> CBOR value and give back a <a>Word8</a>. You
--   probably don't ever need to use this.
decodeSimple :: Decoder s Word8

-- | Attempt to decode a word with <a>decodeWord</a>, and ensure the word
--   is exactly as expected, or fail.
decodeWordOf :: Word -> Decoder s ()

-- | Attempt to decode a list length using <a>decodeListLen</a>, and ensure
--   it is exactly the specified length, or fail.
decodeListLenOf :: Int -> Decoder s ()

-- | Attempt to decode a token for the length of a finite, known list, or
--   an indefinite list. If <a>Nothing</a> is returned, then an indefinite
--   length list occurs afterwords. If <tt><a>Just</a> x</tt> is returned,
--   then a list of length <tt>x</tt> is encoded.
decodeListLenOrIndef :: Decoder s (Maybe Int)

-- | Attempt to decode a token for the length of a finite, known map, or an
--   indefinite map. If <a>Nothing</a> is returned, then an indefinite
--   length map occurs afterwords. If <tt><a>Just</a> x</tt> is returned,
--   then a map of length <tt>x</tt> is encoded.
decodeMapLenOrIndef :: Decoder s (Maybe Int)

-- | Attempt to decode a <tt>Break</tt> token, and if that was successful,
--   return <a>True</a>. If the token was of any other type, return
--   <a>False</a>.
decodeBreakOr :: Decoder s Bool

-- | Peek at the current token we're about to decode, and return a
--   <a>TokenType</a> specifying what it is.
peekTokenType :: Decoder s TokenType

-- | The type of a token, which a decoder can ask for at an arbitrary time.
data TokenType
TypeUInt :: TokenType
TypeUInt64 :: TokenType
TypeNInt :: TokenType
TypeNInt64 :: TokenType
TypeInteger :: TokenType
TypeFloat16 :: TokenType
TypeFloat32 :: TokenType
TypeFloat64 :: TokenType
TypeBytes :: TokenType
TypeBytesIndef :: TokenType
TypeString :: TokenType
TypeStringIndef :: TokenType
TypeListLen :: TokenType
TypeListLen64 :: TokenType
TypeListLenIndef :: TokenType
TypeMapLen :: TokenType
TypeMapLen64 :: TokenType
TypeMapLenIndef :: TokenType
TypeTag :: TokenType
TypeTag64 :: TokenType
TypeBool :: TokenType
TypeNull :: TokenType
TypeSimple :: TokenType
TypeBreak :: TokenType
TypeInvalid :: TokenType

-- | Peek and return the length of the current buffer that we're running
--   our decoder on.
peekAvailable :: Decoder s Int

-- | A 0-based offset within the overall byte sequence that makes up the
--   input to the <a>Decoder</a>.
--   
--   This is an <a>Int64</a> since <a>Decoder</a> is incremental and can
--   decode more data than fits in memory at once. This is also compatible
--   with the result type of <a>length</a>.
type ByteOffset = Int64

-- | Get the current <a>ByteOffset</a> in the input byte sequence of the
--   <a>Decoder</a>.
--   
--   The <a>Decoder</a> does not provide any facility to get at the input
--   data directly (since that is tricky with an incremental decoder). The
--   next best is this primitive which can be used to keep track of the
--   offset within the input bytes that makes up the encoded form of a
--   term.
--   
--   By keeping track of the byte offsets before and after decoding a
--   subterm (a pattern captured by <a>decodeWithByteSpan</a>) and if the
--   overall input data is retained then this is enables later retrieving
--   the span of bytes for the subterm.
peekByteOffset :: Decoder s ByteOffset

-- | This captures the pattern of getting the byte offsets before and after
--   decoding a subterm.
--   
--   <pre>
--   !before &lt;- peekByteOffset
--   x &lt;- decode
--   !after  &lt;- peekByteOffset
--   </pre>
decodeWithByteSpan :: Decoder s a -> Decoder s (a, ByteOffset, ByteOffset)

-- | Decode canonical representation of a <a>Word</a>.
decodeWordCanonical :: Decoder s Word

-- | Decode canonical representation of a <a>Word8</a>.
decodeWord8Canonical :: Decoder s Word8

-- | Decode canonical representation of a <a>Word16</a>.
decodeWord16Canonical :: Decoder s Word16

-- | Decode canonical representation of a <a>Word32</a>.
decodeWord32Canonical :: Decoder s Word32

-- | Decode canonical representation of a <a>Word64</a>.
decodeWord64Canonical :: Decoder s Word64

-- | Decode canonical representation of a negative <a>Word</a>.
decodeNegWordCanonical :: Decoder s Word

-- | Decode canonical representation of a negative <a>Word64</a>.
decodeNegWord64Canonical :: Decoder s Word64

-- | Decode canonical representation of an <a>Int</a>.
decodeIntCanonical :: Decoder s Int

-- | Decode canonical representation of an <a>Int8</a>.
decodeInt8Canonical :: Decoder s Int8

-- | Decode canonical representation of an <a>Int16</a>.
decodeInt16Canonical :: Decoder s Int16

-- | Decode canonical representation of an <a>Int32</a>.
decodeInt32Canonical :: Decoder s Int32

-- | Decode canonical representation of an <a>Int64</a>.
decodeInt64Canonical :: Decoder s Int64

-- | Decode canonical representation of a string of bytes as a
--   <a>ByteString</a>.
decodeBytesCanonical :: Decoder s ByteString

-- | Decode canonical representation of a string of bytes as a
--   <a>ByteArray</a>.
--   
--   Also note that this will eagerly copy the content out of the input to
--   ensure that the input does not leak in the event that the
--   <a>ByteArray</a> is live but not forced.
decodeByteArrayCanonical :: Decoder s ByteArray

-- | Decode canonical representation of a textual string as a piece of
--   <a>Text</a>.
decodeStringCanonical :: Decoder s Text

-- | Decode canonical representation of a textual string as UTF-8 encoded
--   <a>ByteArray</a>. Note that the result is not validated to be
--   well-formed UTF-8.
--   
--   Also note that this will eagerly copy the content out of the input to
--   ensure that the input does not leak in the event that the
--   <a>ByteArray</a> is live but not forced.
decodeUtf8ByteArrayCanonical :: Decoder s ByteArray

-- | Decode canonical representation of the length of a list.
decodeListLenCanonical :: Decoder s Int

-- | Decode canonical representation of the length of a map.
decodeMapLenCanonical :: Decoder s Int

-- | Decode canonical representation of an arbitrary tag and return it as a
--   <a>Word</a>.
decodeTagCanonical :: Decoder s Word

-- | Decode canonical representation of an arbitrary 64-bit tag and return
--   it as a <a>Word64</a>.
decodeTag64Canonical :: Decoder s Word64

-- | Decode canonical representation of an <a>Integer</a>.
decodeIntegerCanonical :: Decoder s Integer

-- | Decode canonical representation of a half-precision <a>Float</a>.
decodeFloat16Canonical :: Decoder s Float

-- | Decode canonical representation of a <a>Float</a>.
decodeFloatCanonical :: Decoder s Float

-- | Decode canonical representation of a <a>Double</a>.
decodeDoubleCanonical :: Decoder s Double

-- | Decode canonical representation of a <tt>simple</tt> CBOR value and
--   give back a <a>Word8</a>. You probably don't ever need to use this.
decodeSimpleCanonical :: Decoder s Word8

-- | Attempt to decode canonical representation of a word with
--   <a>decodeWordCanonical</a>, and ensure the word is exactly as
--   expected, or fail.
decodeWordCanonicalOf :: Word -> Decoder s ()

-- | Attempt to decode canonical representation of a list length using
--   <a>decodeListLenCanonical</a>, and ensure it is exactly the specified
--   length, or fail.
decodeListLenCanonicalOf :: Int -> Decoder s ()

-- | Decode an indefinite sequence length.
decodeSequenceLenIndef :: (r -> a -> r) -> r -> (r -> r') -> Decoder s a -> Decoder s r'

-- | Decode a sequence length.
decodeSequenceLenN :: (r -> a -> r) -> r -> (r -> r') -> Int -> Decoder s a -> Decoder s r'
instance GHC.Show.Show Codec.CBOR.Decoding.TokenType
instance GHC.Enum.Bounded Codec.CBOR.Decoding.TokenType
instance GHC.Enum.Enum Codec.CBOR.Decoding.TokenType
instance GHC.Classes.Ord Codec.CBOR.Decoding.TokenType
instance GHC.Classes.Eq Codec.CBOR.Decoding.TokenType
instance GHC.Base.Functor (Codec.CBOR.Decoding.Decoder s)
instance GHC.Base.Applicative (Codec.CBOR.Decoding.Decoder s)
instance GHC.Base.Monad (Codec.CBOR.Decoding.Decoder s)
instance Control.Monad.Fail.MonadFail (Codec.CBOR.Decoding.Decoder s)


-- | High level API for encoding values, for later serialization into CBOR
--   binary format, using a <a>Monoid</a> based interface.
module Codec.CBOR.Encoding

-- | An intermediate form used during serialisation, specified as a
--   <a>Monoid</a>. It supports efficient concatenation, and is equivalent
--   to a specialised <a>Endo</a> <a>Tokens</a> type.
--   
--   It is used for the stage in serialisation where we flatten out the
--   Haskell data structure but it is independent of any specific external
--   binary or text format.
--   
--   Traditionally, to build any arbitrary <a>Encoding</a> value, you
--   specify larger structures from smaller ones and append the small ones
--   together using <a>mconcat</a>.
newtype Encoding
Encoding :: (Tokens -> Tokens) -> Encoding

-- | A flattened representation of a term, which is independent of any
--   underlying binary representation, but which we later serialise into
--   CBOR format.
data Tokens
TkWord :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkWord64 :: {-# UNPACK #-} !Word64 -> Tokens -> Tokens
TkInt :: {-# UNPACK #-} !Int -> Tokens -> Tokens
TkInt64 :: {-# UNPACK #-} !Int64 -> Tokens -> Tokens
TkBytes :: {-# UNPACK #-} !ByteString -> Tokens -> Tokens
TkBytesBegin :: Tokens -> Tokens
TkByteArray :: {-# UNPACK #-} !SlicedByteArray -> Tokens -> Tokens
TkString :: {-# UNPACK #-} !Text -> Tokens -> Tokens
TkUtf8ByteArray :: {-# UNPACK #-} !SlicedByteArray -> Tokens -> Tokens
TkStringBegin :: Tokens -> Tokens
TkListLen :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkListBegin :: Tokens -> Tokens
TkMapLen :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkMapBegin :: Tokens -> Tokens
TkTag :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkTag64 :: {-# UNPACK #-} !Word64 -> Tokens -> Tokens
TkInteger :: !Integer -> Tokens -> Tokens
TkNull :: Tokens -> Tokens
TkUndef :: Tokens -> Tokens
TkBool :: !Bool -> Tokens -> Tokens
TkSimple :: {-# UNPACK #-} !Word8 -> Tokens -> Tokens
TkFloat16 :: {-# UNPACK #-} !Float -> Tokens -> Tokens
TkFloat32 :: {-# UNPACK #-} !Float -> Tokens -> Tokens
TkFloat64 :: {-# UNPACK #-} !Double -> Tokens -> Tokens
TkBreak :: Tokens -> Tokens
TkEncoded :: {-# UNPACK #-} !ByteString -> Tokens -> Tokens
TkEnd :: Tokens

-- | Encode a <a>Word</a> in a flattened format.
encodeWord :: Word -> Encoding

-- | Encode a <a>Word8</a> in a flattened format.
encodeWord8 :: Word8 -> Encoding

-- | Encode a <a>Word16</a> in a flattened format.
encodeWord16 :: Word16 -> Encoding

-- | Encode a <a>Word32</a> in a flattened format.
encodeWord32 :: Word32 -> Encoding

-- | Encode a <a>Word64</a> in a flattened format.
encodeWord64 :: Word64 -> Encoding

-- | Encode an <a>Int</a> in a flattened format.
encodeInt :: Int -> Encoding

-- | Encode an <a>Int8</a> in a flattened format.
encodeInt8 :: Int8 -> Encoding

-- | Encode an <a>Int16</a> in a flattened format.
encodeInt16 :: Int16 -> Encoding

-- | Encode an <a>Int32</a> in a flattened format.
encodeInt32 :: Int32 -> Encoding

-- | Encode an @<a>Int64</a> in a flattened format.
encodeInt64 :: Int64 -> Encoding

-- | Encode an arbitrarily large @<a>Integer</a> in a flattened format.
encodeInteger :: Integer -> Encoding

-- | Encode an arbitrary strict <a>ByteString</a> in a flattened format.
encodeBytes :: ByteString -> Encoding

-- | Encode a token specifying the beginning of a string of bytes of
--   indefinite length. In reality, this specifies a stream of many
--   occurrences of <a>encodeBytes</a>, each specifying a single chunk of
--   the overall string. After all the bytes desired have been encoded, you
--   should follow it with a break token (see <a>encodeBreak</a>).
encodeBytesIndef :: Encoding

-- | Encode a bytestring in a flattened format.
encodeByteArray :: SlicedByteArray -> Encoding

-- | Encode a <a>Text</a> in a flattened format.
encodeString :: Text -> Encoding

-- | Encode the beginning of an indefinite string.
encodeStringIndef :: Encoding

-- | Encode a UTF-8 string in a flattened format. Note that the contents is
--   not validated to be well-formed UTF-8.
encodeUtf8ByteArray :: SlicedByteArray -> Encoding

-- | Encode the length of a list, used to indicate that the following
--   tokens represent the list values.
encodeListLen :: Word -> Encoding

-- | Encode a token specifying that this is the beginning of an indefinite
--   list of unknown size. Tokens representing the list are expected
--   afterwords, followed by a break token (see <a>encodeBreak</a>) when
--   the list has ended.
encodeListLenIndef :: Encoding

-- | Encode the length of a Map, used to indicate that the following tokens
--   represent the map values.
encodeMapLen :: Word -> Encoding

-- | Encode a token specifying that this is the beginning of an indefinite
--   map of unknown size. Tokens representing the map are expected
--   afterwords, followed by a break token (see <a>encodeBreak</a>) when
--   the map has ended.
encodeMapLenIndef :: Encoding

-- | Encode a 'break', used to specify the end of indefinite length objects
--   like maps or lists.
encodeBreak :: Encoding

-- | Encode an arbitrary <a>Word</a> tag.
encodeTag :: Word -> Encoding

-- | Encode an arbitrary 64-bit <a>Word64</a> tag.
encodeTag64 :: Word64 -> Encoding

-- | Encode a <a>Bool</a>.
encodeBool :: Bool -> Encoding

-- | Encode an <tt>Undef</tt> value.
encodeUndef :: Encoding

-- | Encode a <tt>Null</tt> value.
encodeNull :: Encoding

-- | Encode a 'simple' CBOR token that can be represented with an 8-bit
--   word. You probably don't ever need this.
encodeSimple :: Word8 -> Encoding

-- | Encode a small 16-bit <a>Float</a> in a flattened format.
encodeFloat16 :: Float -> Encoding

-- | Encode a full precision <a>Float</a> in a flattened format.
encodeFloat :: Float -> Encoding

-- | Encode a <a>Double</a> in a flattened format.
encodeDouble :: Double -> Encoding

-- | Include pre-encoded valid CBOR data into the <a>Encoding</a>.
--   
--   The data is included into the output as-is without any additional
--   wrapper.
--   
--   This should be used with care. The data <i>must</i> be a valid CBOR
--   encoding, but this is <i>not</i> checked.
--   
--   This is useful when you have CBOR data that you know is already valid,
--   e.g. previously validated and stored on disk, and you wish to include
--   it without having to decode and re-encode it.
encodePreEncoded :: ByteString -> Encoding
instance GHC.Classes.Eq Codec.CBOR.Encoding.Tokens
instance GHC.Show.Show Codec.CBOR.Encoding.Tokens
instance GHC.Show.Show Codec.CBOR.Encoding.Encoding
instance GHC.Base.Semigroup Codec.CBOR.Encoding.Encoding
instance GHC.Base.Monoid Codec.CBOR.Encoding.Encoding


-- | An internal module for doing magical, low-level, and unholy things in
--   the name of efficiency.
module Codec.CBOR.Magic

-- | Grab a 8-bit <a>Word</a> given a <a>Ptr</a> to some address.
grabWord8 :: Ptr () -> Word8

-- | Grab a 16-bit <a>Word</a> given a <a>Ptr</a> to some address.
grabWord16 :: Ptr () -> Word16

-- | Grab a 32-bit <a>Word</a> given a <a>Ptr</a> to some address.
grabWord32 :: Ptr () -> Word32

-- | Grab a 64-bit <a>Word64</a> given a <a>Ptr</a> to some address.
grabWord64 :: Ptr () -> Word64

-- | Take the tail of a <a>ByteString</a> (i.e. drop the first byte) and
--   read the resulting byte(s) as an 8-bit word value. The input
--   <a>ByteString</a> MUST be at least 2 bytes long: one byte to drop from
--   the front, and one to read as a <a>Word</a> value. This is not
--   checked, and failure to ensure this will result in undefined behavior.
eatTailWord8 :: ByteString -> Word8

-- | Take the tail of a <a>ByteString</a> (i.e. drop the first byte) and
--   read the resulting byte(s) as a 16-bit word value. The input
--   <a>ByteString</a> MUST be at least 3 bytes long: one byte to drop from
--   the front, and two to read as a 16-bit <a>Word</a> value. This is not
--   checked, and failure to ensure this will result in undefined behavior.
eatTailWord16 :: ByteString -> Word16

-- | Take the tail of a <a>ByteString</a> (i.e. drop the first byte) and
--   read the resulting byte(s) as a 32-bit word value. The input
--   <a>ByteString</a> MUST be at least 5 bytes long: one byte to drop from
--   the front, and four to read as a 32-bit <a>Word</a> value. This is not
--   checked, and failure to ensure this will result in undefined behavior.
eatTailWord32 :: ByteString -> Word32

-- | Take the tail of a <a>ByteString</a> (i.e. drop the first byte) and
--   read the resulting byte(s) as a 64-bit word value. The input
--   <a>ByteString</a> MUST be at least 9 bytes long: one byte to drop from
--   the front, and eight to read as a 64-bit <a>Word64</a> value. This is
--   not checked, and failure to ensure this will result in undefined
--   behavior.
eatTailWord64 :: ByteString -> Word64

-- | Convert a <a>Word16</a> to a half-sized <a>Float</a>.
wordToFloat16 :: Word16 -> Float

-- | Convert a half-sized <a>Float</a> to a <a>Word</a>.
floatToWord16 :: Float -> Word16

-- | Cast a <a>Word32</a> to a <a>Float</a>.
wordToFloat32 :: Word32 -> Float

-- | Cast a <a>Word64</a> to a <a>Float</a>.
wordToFloat64 :: Word64 -> Double
word8ToWord :: Word8 -> Word
word16ToWord :: Word16 -> Word
word32ToWord :: Word32 -> Word
word64ToWord :: Word64 -> Word
word8ToInt :: Word8 -> Int
word16ToInt :: Word16 -> Int
word32ToInt :: Word32 -> Int
word64ToInt :: Word64 -> Maybe Int
intToWord :: Int -> Word
intToInt64 :: Int -> Int64
intToWord64 :: Int -> Word64
int64ToWord64 :: Int64 -> Word64

-- | Create a negative <a>Integer</a> out of a raw <a>ByteString</a>.
nintegerFromBytes :: ByteString -> Integer

-- | Create an <a>Integer</a> out of a raw <a>ByteString</a>.
uintegerFromBytes :: ByteString -> Integer

-- | An efficient, mutable counter. Designed to be used inside <a>ST</a> or
--   other primitive monads, hence it carries an abstract rank-2 <tt>s</tt>
--   type parameter.
data Counter s

-- | Create a new counter with a starting <a>Int</a> value.
newCounter :: Int -> ST s (Counter s)

-- | Read the current value of a <a>Counter</a>.
readCounter :: Counter s -> ST s Int

-- | Write a new value into the <a>Counter</a>.
writeCounter :: Counter s -> Int -> ST s ()

-- | Increment a <a>Counter</a> by one.
incCounter :: Counter s -> ST s ()

-- | Decrement a <a>Counter</a> by one.
decCounter :: Counter s -> ST s ()

-- | Copy a <a>ByteString</a> and create a primitive <a>ByteArray</a> from
--   it.
copyByteStringToByteArray :: ByteString -> ByteArray

-- | Copy a <a>ByteArray</a> at a certain offset and length into a
--   <a>ByteString</a>.
copyByteArrayToByteString :: ByteArray -> Int -> Int -> ByteString


-- | Tools for reading values in a CBOR-encoded format back into ordinary
--   values.
module Codec.CBOR.Read

-- | Given a <a>Decoder</a> and some <a>ByteString</a> representing an
--   encoded CBOR value, return <a>Either</a> the decoded CBOR value or an
--   error. In addition to the decoded value return any remaining input
--   content.
deserialiseFromBytes :: (forall s. Decoder s a) -> ByteString -> Either DeserialiseFailure (ByteString, a)

-- | Given a <a>Decoder</a> and some <a>ByteString</a> representing an
--   encoded CBOR value, return <a>Either</a> the decoded CBOR value or an
--   error. In addition to the decoded value return any remaining input
--   content and the number of bytes consumed.
deserialiseFromBytesWithSize :: (forall s. Decoder s a) -> ByteString -> Either DeserialiseFailure (ByteString, ByteOffset, a)

-- | Run a <a>Decoder</a> incrementally, returning a continuation
--   representing the result of the incremental decode.
deserialiseIncremental :: Decoder s a -> ST s (IDecode s a)

-- | An exception type that may be returned (by pure functions) or thrown
--   (by IO actions) that fail to deserialise a given input.
data DeserialiseFailure
DeserialiseFailure :: ByteOffset -> String -> DeserialiseFailure

-- | An Incremental decoder, used to represent the result of attempting to
--   run a decoder over a given input, and return a value of type
--   <tt>a</tt>.
data IDecode s a

-- | The decoder has consumed the available input and needs more to
--   continue. Provide <a>Just</a> if more input is available and
--   <a>Nothing</a> otherwise, and you will get a new <a>IDecode</a>.
Partial :: (Maybe ByteString -> ST s (IDecode s a)) -> IDecode s a

-- | The decoder has successfully finished. Except for the output value you
--   also get any unused input as well as the number of bytes consumed.
Done :: !ByteString -> {-# UNPACK #-} !ByteOffset -> a -> IDecode s a

-- | The decoder ran into an error. The decoder either used <a>fail</a> or
--   was not provided enough input. Contains any unconsumed input, the
--   number of bytes consumed, and a <a>DeserialiseFailure</a> exception
--   describing the reason why the failure occurred.
Fail :: !ByteString -> {-# UNPACK #-} !ByteOffset -> DeserialiseFailure -> IDecode s a

-- | A 0-based offset within the overall byte sequence that makes up the
--   input to the <a>Decoder</a>.
--   
--   This is an <a>Int64</a> since <a>Decoder</a> is incremental and can
--   decode more data than fits in memory at once. This is also compatible
--   with the result type of <a>length</a>.
type ByteOffset = Int64
instance GHC.Show.Show Codec.CBOR.Read.DeserialiseFailure
instance GHC.Classes.Eq Codec.CBOR.Read.DeserialiseFailure
instance GHC.Show.Show a => GHC.Show.Show (Codec.CBOR.Read.DecodedToken a)
instance GHC.Show.Show a => GHC.Show.Show (Codec.CBOR.Read.LongToken a)
instance GHC.Base.Functor (Codec.CBOR.Read.IncrementalDecoder s)
instance GHC.Base.Applicative (Codec.CBOR.Read.IncrementalDecoder s)
instance GHC.Base.Monad (Codec.CBOR.Read.IncrementalDecoder s)
instance Control.DeepSeq.NFData Codec.CBOR.Read.DeserialiseFailure
instance GHC.Exception.Type.Exception Codec.CBOR.Read.DeserialiseFailure


-- | A simpler form than CBOR for writing out <a>Encoding</a> values that
--   allows easier verification and testing. While this library primarily
--   focuses on taking <a>Encoding</a> values (independent of any
--   underlying format) and serializing them into CBOR format, this module
--   offers an alternative format called <a>FlatTerm</a> for serializing
--   <a>Encoding</a> values.
--   
--   The <a>FlatTerm</a> form is very simple and internally mirrors the
--   original <a>Encoding</a> type very carefully. The intention here is
--   that once you have <a>Encoding</a> and <a>Decoding</a> values for your
--   types, you can round-trip values through <a>FlatTerm</a> to catch bugs
--   more easily and with a smaller amount of code to look through.
--   
--   For that reason, this module is primarily useful for client libraries,
--   and even then, only for their test suites to offer a simpler form for
--   doing encoding tests and catching problems in an encoder and decoder.
module Codec.CBOR.FlatTerm

-- | A "flat" representation of an <a>Encoding</a> value, useful for
--   round-tripping and writing tests.
type FlatTerm = [TermToken]

-- | A concrete encoding of <a>Encoding</a> values, one which mirrors the
--   original <a>Encoding</a> type closely.
data TermToken
TkInt :: {-# UNPACK #-} !Int -> TermToken
TkInteger :: !Integer -> TermToken
TkBytes :: {-# UNPACK #-} !ByteString -> TermToken
TkBytesBegin :: TermToken
TkString :: {-# UNPACK #-} !Text -> TermToken
TkStringBegin :: TermToken
TkListLen :: {-# UNPACK #-} !Word -> TermToken
TkListBegin :: TermToken
TkMapLen :: {-# UNPACK #-} !Word -> TermToken
TkMapBegin :: TermToken
TkBreak :: TermToken
TkTag :: {-# UNPACK #-} !Word64 -> TermToken
TkBool :: !Bool -> TermToken
TkNull :: TermToken
TkSimple :: {-# UNPACK #-} !Word8 -> TermToken
TkFloat16 :: {-# UNPACK #-} !Float -> TermToken
TkFloat32 :: {-# UNPACK #-} !Float -> TermToken
TkFloat64 :: {-# UNPACK #-} !Double -> TermToken

-- | Convert an arbitrary <a>Encoding</a> into a <a>FlatTerm</a>.
toFlatTerm :: Encoding -> FlatTerm

-- | Given a <a>Decoder</a>, decode a <a>FlatTerm</a> back into an ordinary
--   value, or return an error.
fromFlatTerm :: (forall s. Decoder s a) -> FlatTerm -> Either String a

-- | Ensure a <a>FlatTerm</a> is internally consistent and was created in a
--   valid manner.
validFlatTerm :: FlatTerm -> Bool
decodeTermToken :: Decoder s TermToken
instance GHC.Show.Show Codec.CBOR.FlatTerm.TermToken
instance GHC.Classes.Ord Codec.CBOR.FlatTerm.TermToken
instance GHC.Classes.Eq Codec.CBOR.FlatTerm.TermToken
instance GHC.Show.Show Codec.CBOR.FlatTerm.Loc


-- | This module provides an interface for decoding and encoding arbitrary
--   CBOR values (ones that, for example, may not have been generated by
--   this library).
--   
--   Using <a>decodeTerm</a>, you can decode an arbitrary CBOR value given
--   to you into a <a>Term</a>, which represents a CBOR value as an AST.
--   
--   Similarly, if you wanted to encode some value into a CBOR value
--   directly, you can wrap it in a <a>Term</a> constructor and use
--   <a>encodeTerm</a>. This would be useful, as an example, if you needed
--   to serialise some value into a CBOR term that is not compatible with
--   that types <tt>Serialise</tt> instance.
--   
--   Because this interface gives you the ability to decode or encode any
--   arbitrary CBOR term, it can also be seen as an alternative interface
--   to the <a>Encoding</a> and <a>Decoding</a> modules.
module Codec.CBOR.Term

-- | A general CBOR term, which can be used to serialise or deserialise
--   arbitrary CBOR terms for interoperability or debugging. This type is
--   essentially a direct reflection of the CBOR abstract syntax tree as a
--   Haskell data type.
--   
--   The <a>Term</a> type also comes with a <tt>Serialise</tt> instance, so
--   you can easily use <tt><tt>decode</tt> :: <a>Decoder</a>
--   <a>Term</a></tt> to directly decode any arbitrary CBOR value into
--   Haskell with ease, and likewise with <tt>encode</tt>.
data Term
TInt :: {-# UNPACK #-} !Int -> Term
TInteger :: !Integer -> Term
TBytes :: !ByteString -> Term
TBytesI :: !ByteString -> Term
TString :: !Text -> Term
TStringI :: !Text -> Term
TList :: ![Term] -> Term
TListI :: ![Term] -> Term
TMap :: ![(Term, Term)] -> Term
TMapI :: ![(Term, Term)] -> Term
TTagged :: {-# UNPACK #-} !Word64 -> !Term -> Term
TBool :: !Bool -> Term
TNull :: Term
TSimple :: {-# UNPACK #-} !Word8 -> Term
THalf :: {-# UNPACK #-} !Float -> Term
TFloat :: {-# UNPACK #-} !Float -> Term
TDouble :: {-# UNPACK #-} !Double -> Term

-- | Encode an arbitrary <a>Term</a> into an <a>Encoding</a> for later
--   serialization.
encodeTerm :: Term -> Encoding

-- | Decode some arbitrary CBOR value into a <a>Term</a>.
decodeTerm :: Decoder s Term
instance GHC.Read.Read Codec.CBOR.Term.Term
instance GHC.Show.Show Codec.CBOR.Term.Term
instance GHC.Classes.Ord Codec.CBOR.Term.Term
instance GHC.Classes.Eq Codec.CBOR.Term.Term


-- | A library for working with CBOR.
module Codec.CBOR


-- | Functions for writing out CBOR <a>Encoding</a> values in a variety of
--   forms.
module Codec.CBOR.Write

-- | Turn an <a>Encoding</a> into a <a>ByteString</a> <a>Builder</a> in
--   CBOR binary format.
toBuilder :: Encoding -> Builder

-- | Turn an <a>Encoding</a> into a lazy <a>ByteString</a> in CBOR binary
--   format.
toLazyByteString :: Encoding -> ByteString

-- | Turn an <a>Encoding</a> into a strict <a>ByteString</a> in CBOR binary
--   format.
toStrictByteString :: Encoding -> ByteString


-- | Pretty printing tools for debugging and analysis.
module Codec.CBOR.Pretty

-- | Pretty prints an <a>Encoding</a> in an annotated, hexadecimal format
--   that maps CBOR values to their types. The output format is similar to
--   the format used on <a>http://cbor.me/</a>.
--   
--   For example, with the term:
--   
--   <pre>
--   <a>putStrLn</a> . <a>prettyHexEnc</a> . <a>encode</a> $
--     ( True
--     , [1,2,3::Int]
--     , (<a>fromList</a> [("Hello",True),("World",False)], "This is a long string which wraps")
--     )
--   </pre>
--   
--   You get:
--   
--   <pre>
--   83      # list(3)
--      f5   # bool(true)
--      9f   # list(*)
--         01        # int(1)
--         02        # int(2)
--         03        # int(3)
--      ff   # break
--      82   # list(2)
--         a2        # map(2)
--            65 48 65 6c 6c 6f      # text("Hello")
--            f5     # bool(true)
--            65 57 6f 72 6c 64      # text("World")
--            f4     # bool(false)
--         78 21 54 68 69 73 20 69 73 20 61 20 6c 6f 6e 67
--         20 73 74 72 69 6e 67 20 77 68 69 63 68 20 77 72
--         61 70 73          # text("This is a long string which wraps")
--   </pre>
prettyHexEnc :: Encoding -> String
instance GHC.Base.Functor Codec.CBOR.Pretty.PP
instance GHC.Base.Applicative Codec.CBOR.Pretty.PP
instance GHC.Base.Monad Codec.CBOR.Pretty.PP
instance Control.Monad.Fail.MonadFail Codec.CBOR.Pretty.PP
