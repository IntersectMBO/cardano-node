-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A pure simulator for monadic concurrency with STM.
--   
--   A pure simulator monad with support of concurency (base &amp; async
--   style), stm, synchronous and asynchronous exceptions, timeouts &amp;
--   delays, dynamic traces, partial order reduction and more.
@package io-sim
@version 1.5.1.0

module Data.List.Trace

-- | A <tt>cons</tt> list with polymorphic <tt>nil</tt>.
--   
--   <ul>
--   <li><tt><a>Trace</a> Void a</tt> is an infinite stream</li>
--   <li><tt><a>Trace</a> () a</tt> is isomorphic to <tt>[a]</tt></li>
--   </ul>
--   
--   Usually used with <tt>a</tt> being a non empty sum type.
data Trace a b
Cons :: b -> Trace a b -> Trace a b
Nil :: a -> Trace a b

-- | Pretty print a <a>Trace</a>.
ppTrace :: (a -> String) -> (b -> String) -> Trace a b -> String
toList :: Trace a b -> [b]
fromList :: a -> [b] -> Trace a b
head :: Trace a b -> b
tail :: Trace a b -> Trace a b
filter :: (b -> Bool) -> Trace a b -> Trace a b
length :: Trace a b -> Int

-- | Take the first n elements of a Trace, converting each to ().
take :: Int -> Trace a b -> Trace (Maybe a) b

-- | Take elements from the Trace while the predicate holds, converting
--   each to ().
takeWhile :: (b -> Bool) -> Trace a b -> Trace (Maybe a) b

-- | Drop the first n elements of a Trace.
drop :: Int -> Trace a b -> Trace a b

-- | Drop elements from the Trace while the predicate holds.
dropWhile :: (b -> Bool) -> Trace a b -> Trace a b
instance GHC.Base.Functor (Data.List.Trace.Trace a)
instance (GHC.Classes.Ord b, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.List.Trace.Trace a b)
instance (GHC.Classes.Eq b, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.List.Trace.Trace a b)
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Data.List.Trace.Trace a b)
instance Data.Bifunctor.Bifunctor Data.List.Trace.Trace
instance Data.Bifoldable.Bifoldable Data.List.Trace.Trace
instance Data.Bitraversable.Bitraversable Data.List.Trace.Trace
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.List.Trace.Trace a b)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.List.Trace.Trace a b)
instance GHC.Base.Monoid a => GHC.Base.Applicative (Data.List.Trace.Trace a)
instance GHC.Base.Monoid a => GHC.Base.Monad (Data.List.Trace.Trace a)
instance GHC.Base.Monoid a => Control.Monad.Fail.MonadFail (Data.List.Trace.Trace a)
instance GHC.Base.Monoid a => GHC.Base.Alternative (Data.List.Trace.Trace a)
instance GHC.Base.Monoid a => GHC.Base.MonadPlus (Data.List.Trace.Trace a)
instance GHC.Base.Monoid a => Control.Monad.Fix.MonadFix (Data.List.Trace.Trace a)
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.List.Trace.Trace a)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.List.Trace.Trace a)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.List.Trace.Trace a)

module Control.Monad.IOSim
data IOSim s a

-- | <a>IOSim</a>'s <a>STM</a> monad, as <a>IOSim</a> it is parametrised by
--   <tt>s</tt>, e.g. <tt>STMSim s a</tt> is monadic expression of type
--   <tt>a</tt>.
type STMSim = STM

-- | <a>IOSim</a> is a pure monad.
runSim :: forall a. (forall s. IOSim s a) -> Either Failure a

-- | For quick experiments and tests it is often appropriate and convenient
--   to simply throw failures as exceptions.
runSimOrThrow :: forall a. (forall s. IOSim s a) -> a

-- | Like <a>runSim</a> but fail when the main thread terminates if there
--   are other threads still running or blocked. If one is trying to follow
--   a strict thread clean-up policy then this helps testing for that.
runSimStrictShutdown :: forall a. (forall s. IOSim s a) -> Either Failure a

-- | Simulation terminated a failure.
data Failure

-- | The main thread terminated with an exception.
FailureException :: SomeException -> Failure

-- | The threads all deadlocked.
FailureDeadlock :: ![Labelled IOSimThreadId] -> Failure

-- | The main thread terminated normally but other threads were still
--   alive, and strict shutdown checking was requested. See
--   <a>runSimStrictShutdown</a>.
FailureSloppyShutdown :: [Labelled IOSimThreadId] -> Failure

-- | An exception was thrown while evaluation the trace. This could be an
--   internal assertion failure of `io-sim` or an unhandled exception in
--   the simulation.
FailureEvaluation :: SomeException -> Failure

-- | An internal failure of the simulator.
--   
--   Please open an issue at
--   <a>https://github.com/input-output-hk/io-sim/issues</a>.
FailureInternal :: String -> Failure

-- | See <a>runSimTraceST</a> below.
runSimTrace :: forall a. (forall s. IOSim s a) -> SimTrace a

-- | The most general method of running <a>IOSim</a> is in the lazy
--   <a>ST</a> monad. One can recover failures or the result from
--   <a>SimTrace</a> with <a>traceResult</a>, or access
--   <a>SimEventType</a>s generated by the computation with
--   <a>traceEvents</a>. A slightly more convenient way is exposed by
--   <a>runSimTrace</a>.
runSimTraceST :: forall s a. IOSim s a -> ST s (SimTrace a)

-- | Like
--   <a>https://hackage.haskell.org/package/QuickCheck-2.14.3/docs/Test-QuickCheck-Monadic.html#v:monadicST</a>.
--   
--   Note: it calls <a>traceResult</a> in non-strict mode, e.g. leaked
--   threads do not cause failures.
monadicIOSim_ :: Testable a => (forall s. PropertyM (IOSim s) a) -> Property

-- | A more general version of <a>monadicIOSim_</a>, which:
--   
--   <ul>
--   <li>allows to run in monad stacks build on top of <a>IOSim</a>;</li>
--   <li>gives more control how to attach debugging information to failed
--   tests.</li>
--   </ul>
--   
--   Note, to use this combinator your monad needs to be defined as:
--   
--   <pre>
--   newtype M s a = M s { runM :: ReaderT State (IOSim s) a }
--   </pre>
--   
--   It's important that `M s` is a monad. For such a monad one you'll need
--   provide a natural transformation: <tt> -- the state could also be
--   created as an <a>IOSim</a> computation. nat :: forall s a. State -&gt;
--   M s a -&gt; <a>IOSim</a> s a nat state m = runStateT (runM m) state
--   </tt>
monadicIOSim :: (Testable a, forall s. Monad (m s)) => (SimTrace Property -> Property) -> (forall s a. m s a -> IOSim s a) -> (forall s. PropertyM (m s) a) -> Property

-- | Like &lt;runSTGen
--   <a>https://hackage.haskell.org/package/QuickCheck-2.14.3/docs/Test-QuickCheck-Monadic.html#v:runSTGen&gt;</a>.
runIOSimGen :: (SimTrace a -> Property) -> (forall s. Gen (IOSim s a)) -> Gen Property

-- | Execute a simulation, discover &amp; revert races. Note that this will
--   execute the simulation multiple times with different schedules, and
--   thus it's much more costly than a simple <a>runSimTrace</a> (also the
--   simulation environments has much more state to track and hence it is
--   slower).
--   
--   On property failure it will show the failing schedule
--   (<a>ScheduleControl</a>) which can be passed to <a>controlSimTrace</a>
--   to reproduce the failure without discovering the schedule.
exploreSimTrace :: forall a test. Testable test => (ExplorationOptions -> ExplorationOptions) -> (forall s. IOSim s a) -> (Maybe (SimTrace a) -> SimTrace a -> test) -> Property

-- | Run a simulation using a given schedule. This is useful to reproduce
--   failing cases without exploring the races.
controlSimTrace :: forall a. Maybe Int -> ScheduleControl -> (forall s. IOSim s a) -> SimTrace a

-- | A schedule modification inserted at given execution step.
data ScheduleMod
ScheduleMod :: StepId -> ScheduleControl -> [StepId] -> ScheduleMod

-- | Step at which the <a>ScheduleMod</a> is activated.
[scheduleModTarget] :: ScheduleMod -> StepId

-- | <a>ScheduleControl</a> at the activation step. It is needed by
--   <tt>extendScheduleControl</tt> when combining the discovered schedule
--   with the initial one.
[scheduleModControl] :: ScheduleMod -> ScheduleControl

-- | Series of steps which are executed at the target step. This *includes*
--   the target step, not necessarily as the last step.
[scheduleModInsertion] :: ScheduleMod -> [StepId]

-- | Modified execution schedule.
data ScheduleControl

-- | default scheduling mode
ControlDefault :: ScheduleControl

-- | if the current control is <a>ControlAwait</a>, the normal scheduling
--   will proceed, until the thread found in the first <a>ScheduleMod</a>
--   reaches the given step. At this point the thread is put to sleep,
--   until after all the steps are followed.
ControlAwait :: [ScheduleMod] -> ScheduleControl

-- | follow the steps then continue with schedule modifications. This
--   control is set by <tt>followControl</tt> when <tt>controlTargets</tt>
--   returns true.
ControlFollow :: [StepId] -> [ScheduleMod] -> ScheduleControl
type ExplorationSpec = ExplorationOptions -> ExplorationOptions

-- | Race exploration options.
data ExplorationOptions
ExplorationOptions :: Int -> Int -> Maybe Int -> Maybe ScheduleControl -> Int -> ExplorationOptions

-- | This is an upper bound on the number of schedules with race reversals
--   that will be explored; a bound of zero means that the default schedule
--   will be explored, but no others. Setting the bound to zero makes
--   IOSimPOR behave rather like IOSim, in that only one schedule is
--   explored, but (a) IOSimPOR is considerably slower, because it still
--   collects information on potential races, and (b) the IOSimPOR schedule
--   is different (based on priorities, in contrast to IOSim's
--   round-robin), and plays better with shrinking.
--   
--   The default value is `100`.
[explorationScheduleBound] :: ExplorationOptions -> Int

-- | The branching factor. This is the number of alternative schedules that
--   IOSimPOR tries to run, per race reversal. With the default parameters,
--   IOSimPOR will try to reverse the first 33 (100 div 3) races discovered
--   using the default schedule, then (if 33 or more races are discovered),
--   for each such reversed race, will run the reversal and try to reverse
--   two more races in the resulting schedule. A high branching factor will
--   explore more combinations of reversing fewer races, within the overall
--   schedule bound. A branching factor of one will explore only schedules
--   resulting from a single race reversal (unless there are fewer races
--   available to be reversed than the schedule bound).
--   
--   The default value is `3`.
[explorationBranching] :: ExplorationOptions -> Int

-- | Limit on the computation time allowed per scheduling step, for
--   catching infinite loops etc.
--   
--   The default value is <a>Nothing</a>.
[explorationStepTimelimit] :: ExplorationOptions -> Maybe Int

-- | A schedule to replay.
--   
--   The default value is <a>Nothing</a>.
[explorationReplay] :: ExplorationOptions -> Maybe ScheduleControl

-- | Log detailed trace to stderr containing information on discovered
--   races. The trace does not contain the result of the simulation, unless
--   one will do that explicitly inside the simulation.
--   
--   level 0: don't show any output, level 1: show simulation trace with
--   discovered schedules level 2: show simulation trace with discovered
--   schedules and races
--   
--   NOTE: discovered schedules &amp; races are not exposed to the user in
--   the callback of <tt>exploreSimTrace</tt> or in the output of
--   <tt>controlSimTrace</tt>.
[explorationDebugLevel] :: ExplorationOptions -> Int
stdExplorationOptions :: ExplorationOptions
withScheduleBound :: Int -> ExplorationSpec
withBranching :: Int -> ExplorationSpec
withStepTimelimit :: Int -> ExplorationSpec
withReplay :: ScheduleControl -> ExplorationSpec

-- | Lift an <a>ST</a> computation to <a>IOSim</a>.
--   
--   Note: you can use <a>MonadST</a> to lift <a>ST</a> computations, this
--   is a more convenient function just for <a>IOSim</a>.
liftST :: ST s a -> IOSim s a

-- | Set the current wall clock time for the thread's clock domain.
setCurrentTime :: UTCTime -> IOSim s ()

-- | Put the thread into a new wall clock domain, not shared with the
--   parent thread. Changing the wall clock time in the new clock domain
--   will not affect the other clock of other threads. All threads forked
--   by this thread from this point onwards will share the new clock
--   domain.
unshareClock :: IOSim s ()

-- | A type alias for <a>IOSim</a> simulation trace. It comes with useful
--   pattern synonyms.
type SimTrace a = Trace (SimResult a) SimEvent

-- | A <tt>cons</tt> list with polymorphic <tt>nil</tt>.
--   
--   <ul>
--   <li><tt><a>Trace</a> Void a</tt> is an infinite stream</li>
--   <li><tt><a>Trace</a> () a</tt> is isomorphic to <tt>[a]</tt></li>
--   </ul>
--   
--   Usually used with <tt>a</tt> being a non empty sum type.
data Trace a b
Cons :: b -> Trace a b -> Trace a b
Nil :: a -> Trace a b
pattern SimTrace :: Time -> IOSimThreadId -> Maybe ThreadLabel -> SimEventType -> SimTrace a -> SimTrace a
pattern SimPORTrace :: Time -> IOSimThreadId -> Int -> Maybe ThreadLabel -> SimEventType -> SimTrace a -> SimTrace a
pattern TraceDeadlock :: Time -> [Labelled IOSimThreadId] -> SimTrace a
pattern TraceLoop :: SimTrace a
pattern TraceMainReturn :: Time -> Labelled IOSimThreadId -> a -> [Labelled IOSimThreadId] -> SimTrace a
pattern TraceMainException :: Time -> Labelled IOSimThreadId -> SomeException -> [Labelled IOSimThreadId] -> SimTrace a
pattern TraceRacesFound :: [ScheduleControl] -> SimTrace a -> SimTrace a
pattern TraceInternalError :: String -> SimTrace a

-- | A result type of a simulation.
data SimResult a

-- | Return value of the main thread.
MainReturn :: !Time -> !Labelled IOSimThreadId -> a -> ![Labelled IOSimThreadId] -> SimResult a

-- | Exception thrown by the main thread.
MainException :: !Time -> !Labelled IOSimThreadId -> SomeException -> ![Labelled IOSimThreadId] -> SimResult a

-- | Deadlock discovered in the simulation. Deadlocks are discovered if
--   simply the simulation cannot do any progress in a given time slot and
--   there's no event which would advance the time.
Deadlock :: !Time -> ![Labelled IOSimThreadId] -> SimResult a

-- | Only returned by <i>IOSimPOR</i> when a step execution took longer
--   than <a>explorationStepTimelimit</a> was exceeded.
Loop :: SimResult a

-- | An <a>IOSim</a> bug, please report to
--   <a>https://github.com/input-output-hk/io-sim</a>
InternalError :: String -> SimResult a

-- | <tt>Trace</tt> is a recursive data type, it is the trace of a
--   <a>IOSim</a> computation. The trace will contain information about
--   thread scheduling, blocking on <a>TVar</a>s, and other internal state
--   changes of <a>IOSim</a>. More importantly it also supports traces
--   generated by the computation with <a>say</a> (which corresponds to
--   using <a>putStrLn</a> in <a>IO</a>), <tt>traceEventM</tt>, or
--   dynamically typed traces with <a>traceM</a> (which generalise the
--   <tt>base</tt> library <a>traceM</a>)
--   
--   It also contains information on discovered races.
--   
--   See also: <a>traceEvents</a>, <a>traceResult</a>,
--   <a>selectTraceEvents</a>, <a>selectTraceEventsDynamic</a> and
--   <a>printTraceEventsSay</a>.
data SimEvent

-- | Used when using <a>IOSim</a>.
SimEvent :: !Time -> !IOSimThreadId -> !Maybe ThreadLabel -> !SimEventType -> SimEvent
[seTime] :: SimEvent -> !Time
[seThreadId] :: SimEvent -> !IOSimThreadId
[seThreadLabel] :: SimEvent -> !Maybe ThreadLabel
[seType] :: SimEvent -> !SimEventType

-- | Only used for <i>IOSimPOR</i>
SimPOREvent :: !Time -> !IOSimThreadId -> !Int -> !Maybe ThreadLabel -> !SimEventType -> SimEvent
[seTime] :: SimEvent -> !Time
[seThreadId] :: SimEvent -> !IOSimThreadId
[seStep] :: SimEvent -> !Int
[seThreadLabel] :: SimEvent -> !Maybe ThreadLabel
[seType] :: SimEvent -> !SimEventType

-- | Only used for <i>IOSimPOR</i>
SimRacesFound :: [ScheduleControl] -> SimEvent

-- | Events recorded by the simulation.
data SimEventType

-- | hold value of <a>say</a>
EventSay :: String -> SimEventType

-- | hold a dynamic value of <a>traceM</a>
EventLog :: Dynamic -> SimEventType

-- | masking state changed
EventMask :: MaskingState -> SimEventType

-- | throw exception
EventThrow :: SomeException -> SimEventType

-- | throw asynchronous exception (<a>throwTo</a>)
EventThrowTo :: SomeException -> IOSimThreadId -> SimEventType

-- | the thread which executed <a>throwTo</a> is blocked
EventThrowToBlocked :: SimEventType

-- | the thread which executed <a>throwTo</a> is woken up
EventThrowToWakeup :: SimEventType

-- | a target thread of <a>throwTo</a> unmasked its exceptions, this is
--   paired with <a>EventThrowToWakeup</a> for threads which were blocked
--   on <a>throwTo</a>
EventThrowToUnmasked :: Labelled IOSimThreadId -> SimEventType

-- | forked a thread
EventThreadForked :: IOSimThreadId -> SimEventType

-- | thread terminated normally
EventThreadFinished :: SimEventType

-- | thread terminated by an unhandled exception
EventThreadUnhandled :: SomeException -> SimEventType

-- | committed STM transaction
EventTxCommitted :: [Labelled TVarId] -> [Labelled TVarId] -> Maybe Effect -> SimEventType
EventTxAborted :: Maybe Effect -> SimEventType

-- | STM transaction blocked (due to <a>retry</a>)
EventTxBlocked :: [Labelled TVarId] -> Maybe Effect -> SimEventType

-- | changed vars causing retry
EventTxWakeup :: [Labelled TVarId] -> SimEventType

-- | unblocked threads by a committed STM transaction
EventUnblocked :: [IOSimThreadId] -> SimEventType

-- | thread delayed
EventThreadDelay :: TimeoutId -> Time -> SimEventType

-- | thread woken up after a delay
EventThreadDelayFired :: TimeoutId -> SimEventType

-- | new timeout created (via <a>timeout</a>)
EventTimeoutCreated :: TimeoutId -> IOSimThreadId -> Time -> SimEventType

-- | timeout fired
EventTimeoutFired :: TimeoutId -> SimEventType

-- | registered delay (via <a>registerDelay</a>)
EventRegisterDelayCreated :: TimeoutId -> TVarId -> Time -> SimEventType

-- | registered delay fired
EventRegisterDelayFired :: TimeoutId -> SimEventType

-- | a new <a>Timeout</a> created (via <a>newTimeout</a>)
EventTimerCreated :: TimeoutId -> TVarId -> Time -> SimEventType

-- | a <a>Timeout</a> was cancelled (via <a>cancelTimeout</a>)
EventTimerCancelled :: TimeoutId -> SimEventType

-- | a <a>Timeout</a> fired
EventTimerFired :: TimeoutId -> SimEventType

-- | event traced when <tt>threadStatus</tt> is executed
EventThreadStatus :: IOSimThreadId -> IOSimThreadId -> SimEventType

-- | <i>IOSimPOR</i> event: new execution started exploring the given
--   schedule.
EventSimStart :: ScheduleControl -> SimEventType

-- | <i>IOSimPOR</i> event: the labelling thread was runnable, but its
--   execution was delayed, until <a>EventThreadWake</a>.
--   
--   Event inserted to mark a difference between a failed trace and a
--   similar passing trace.
EventThreadSleep :: SimEventType

-- | <i>IOSimPOR</i> event: marks when the thread was rescheduled by
--   <i>IOSimPOR</i>
EventThreadWake :: SimEventType

-- | <i>IOSim</i> and <i>IOSimPOR</i> event: a thread was descheduled
EventDeschedule :: Deschedule -> SimEventType

-- | <i>IOSimPOR</i> event: following given schedule
EventFollowControl :: ScheduleControl -> SimEventType

-- | <i>IOSimPOR</i> event: thread delayed to follow the given schedule
EventAwaitControl :: StepId -> ScheduleControl -> SimEventType

-- | <i>IOSimPOR</i> event: perform action of the given step
EventPerformAction :: StepId -> SimEventType

-- | <i>IOSimPOR</i> event: reschedule a thread following the given
--   <a>ScheduleControl</a>
EventReschedule :: ScheduleControl -> SimEventType

-- | <i>IOSimPOR</i> event: executed effect; Useful for debugging IOSimPOR
--   or showing compact information about thread execution.
EventEffect :: VectorClock -> Effect -> SimEventType

-- | <i>IOSimPOR</i> event: races. Races are updated while we execute a
--   simulation. Useful for debugging IOSimPOR.
EventRaces :: Races -> SimEventType
type ThreadLabel = String

-- | A thread id.
--   
--   <i>IOSimPOR</i>: <a>RacyThreadId</a> indicates that this thread is
--   taken into account when discovering races. A thread is marked as racy
--   iff <a>exploreRaces</a> was executed in it or it's a thread forked by
--   a racy thread.
data IOSimThreadId

-- | A racy thread (<tt>IOSimPOR</tt> only), shown in the trace with curly
--   braces, e.g. `Thread {2,3}`.
RacyThreadId :: [Int] -> IOSimThreadId

-- | A non racy thread. They have higher priority than racy threads in
--   <tt>IOSimPOR</tt> scheduler.
ThreadId :: [Int] -> IOSimThreadId

-- | A labelled value.
--   
--   For example <a>labelThread</a> or <a>labelTVar</a> will insert a label
--   to <a>IOSimThreadId</a> (or <a>TVarId</a>).
data Labelled a
Labelled :: !a -> !Maybe String -> Labelled a
[l_labelled] :: Labelled a -> !a
[l_label] :: Labelled a -> !Maybe String

-- | <a>IOSim</a> has the ability to store any <a>Typeable</a> value in its
--   trace which can then be recovered with
--   <tt>selectTraceEventsDynamic</tt> or
--   <tt>selectTraceEventsDynamic'</tt>.
traceM :: Typeable a => a -> IOSim s ()

-- | Trace a value, in the same was as <a>traceM</a> does, but from the
--   <a>STM</a> monad. This is primarily useful for debugging.
traceSTM :: Typeable a => a -> STMSim s ()

-- | Pretty print simulation trace.
--   
--   Note: this is not a streaming function, it will evaluate the whole
--   trace before printing it. If you need to print a very large trace, you
--   might want to use
--   
--   <pre>
--   <a>ppTrace</a> show (<a>ppSimEvent</a> 0 0 0)
--   </pre>
ppTrace :: Show a => SimTrace a -> String

-- | Like <a>ppTrace</a> but does not show the result value.
ppTrace_ :: SimTrace a -> String

-- | Pretty print a timestamped event.
ppEvents :: [(Time, IOSimThreadId, Maybe ThreadLabel, SimEventType)] -> String

-- | Pretty print a <a>SimEvent</a>.
ppSimEvent :: Int -> Int -> Int -> SimEvent -> String

-- | Trace each event using <a>trace</a>; this is useful when a trace ends
--   with a pure error, e.g. an assertion.
ppDebug :: SimTrace a -> x -> x

-- | Turn <a>SimTrace</a> into a list of timestamped events.
traceEvents :: SimTrace a -> [(Time, IOSimThreadId, Maybe ThreadLabel, SimEventType)]

-- | Fold through the trace and return either <a>Failure</a> or a
--   simulation result, i.e. the return value of the main thread.
traceResult :: Bool -> SimTrace a -> Either Failure a

-- | Select events according to the predicate function. It throws an error
--   if the simulation ends with <a>Failure</a>.
selectTraceEvents :: (Time -> SimEventType -> Maybe b) -> SimTrace a -> [b]

-- | Like <a>selectTraceEvents</a>, but it returns even if the simulation
--   trace ends with <a>Failure</a>. It also works with any return type,
--   not only <a>SimResult</a> like <a>selectTraceEvents</a> does.
selectTraceEvents' :: (Time -> SimEventType -> Maybe b) -> Trace a SimEvent -> [b]

-- | Select all the traced values matching the expected type. It relies on
--   the sim's dynamic trace facility.
--   
--   For convenience, it throws exceptions for abnormal sim termination.
selectTraceEventsDynamic :: forall a b. Typeable b => SimTrace a -> [b]

-- | Like <a>selectTraceEventsDynamic</a> but it also captures time of the
--   trace event.
selectTraceEventsDynamicWithTime :: forall a b. Typeable b => SimTrace a -> [(Time, b)]

-- | Like <a>selectTraceEventsDynamic</a> but it returns even if the
--   simulation trace ends with <a>Failure</a>. It also works with any
--   return type, not only <a>SimResult</a> like
--   <a>selectTraceEventsDynamic</a> does.
selectTraceEventsDynamic' :: forall a b. Typeable b => Trace a SimEvent -> [b]

-- | Like <a>selectTraceEventsDynamicWithTime'</a> but it also captures
--   time of the trace event. It also works with any return type, not only
--   <a>SimResult</a> like <a>selectTraceEventsDynamicWithTime</a> does.
selectTraceEventsDynamicWithTime' :: forall a b. Typeable b => Trace a SimEvent -> [(Time, b)]

-- | Get a trace of <a>EventSay</a>.
--   
--   For convenience, it throws exceptions for abnormal sim termination.
selectTraceEventsSay :: SimTrace a -> [String]

-- | Like <a>selectTraceEventsSay</a> but it also captures time of the
--   trace event.
selectTraceEventsSayWithTime :: SimTrace a -> [(Time, String)]

-- | Like <a>selectTraceEventsSay</a> but it returns even if the simulation
--   trace ends with <a>Failure</a>. It also works with any return type,
--   not only <a>SimResult</a> like <a>selectTraceEventsSay</a> does.
selectTraceEventsSay' :: Trace a SimEvent -> [String]

-- | Like <a>selectTraceEventsSay'</a> but it also captures time of the
--   trace event.
selectTraceEventsSayWithTime' :: Trace a SimEvent -> [(Time, String)]
selectTraceRaces :: SimTrace a -> [ScheduleControl]

-- | The most general select function. It is a <i>total function</i>.
traceSelectTraceEvents :: (Time -> SimEventType -> Maybe b) -> Trace a SimEvent -> Trace a b

-- | Select dynamic events. It is a <i>total function</i>.
traceSelectTraceEventsDynamic :: forall a b. Typeable b => Trace a SimEvent -> Trace a b

-- | Select say events. It is a <i>total function</i>.
traceSelectTraceEventsSay :: forall a. Trace a SimEvent -> Trace a String

-- | Print all <a>EventSay</a> to the console.
--   
--   For convenience, it throws exceptions for abnormal sim termination.
printTraceEventsSay :: SimTrace a -> IO ()

-- | Wrapper for Eventlog events so they can be retrieved from the trace
--   with <tt>selectTraceEventsDynamic</tt>.
newtype EventlogEvent
EventlogEvent :: String -> EventlogEvent

-- | Wrapper for Eventlog markers so they can be retrieved from the trace
--   with <tt>selectTraceEventsDynamic</tt>.
newtype EventlogMarker
EventlogMarker :: String -> EventlogMarker
data Timeout s
newTimeout :: DiffTime -> IOSim s (Timeout s)
readTimeout :: Timeout s -> STM s TimeoutState
cancelTimeout :: Timeout s -> IOSim s ()
awaitTimeout :: Timeout s -> STM s Bool
instance GHC.Show.Show Control.Monad.IOSim.Failure
instance GHC.Exception.Type.Exception Control.Monad.IOSim.Failure
