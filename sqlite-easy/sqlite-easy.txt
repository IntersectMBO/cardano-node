-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A primitive yet easy to use sqlite library built using sqlite-direct,
--   resource-pool and migrant.
@package sqlite-easy
@version 1.1.1.0


-- | The implementation of sqlite-easy.
--   
--   This module is unstable and may change at any time.
module Database.Sqlite.Easy.Internal

-- | A SQLite3 connection string
newtype ConnectionString
ConnectionString :: Text -> ConnectionString
[unConnectionString] :: ConnectionString -> Text

-- | Create a pool of a sqlite3 db with a specific connection string. This
--   also sets a few default pragmas.
createSqlitePool :: ConnectionString -> IO (Pool Database)

-- | Create a pool of a sqlite3 db with a specific connection string. This
--   will also run the supplied SQL statements after establishing each
--   connection.
createSqlitePoolWith :: ConnectionString -> [SQL] -> IO (Pool Database)

-- | Open a connection to a database, run the supplied statements, and
--   return the connection.
openWith :: ConnectionString -> [SQL] -> IO Database

-- | Default pragmas to be set when opening a connection from a pool.
defaultPragmas :: [SQL]

-- | Open a database, run some stuff, close the database.
withDb :: ConnectionString -> SQLite a -> IO a

-- | Use an active database connection to run some stuff on a database.
withDatabase :: Database -> SQLite a -> IO a

-- | Use a resource pool to run some stuff on a database.
withPool :: Pool Database -> SQLite a -> IO a

-- | A SQL statement
newtype SQL
SQL :: Text -> SQL
[unSQL] :: SQL -> Text

-- | Run a SQL statement on a database and fetch the results.
run :: SQL -> SQLite [[SQLData]]

-- | Run a SQL statement with certain parameters on a database and fetch
--   the results.
runWith :: SQL -> [SQLData] -> SQLite [[SQLData]]

-- | Run a SQL statement binding it to all given parameter rows and fetch
--   all of the data. This can significantly improve speed for cases like
--   bulk INSERTs.
runWithMany :: SQL -> [[SQLData]] -> SQLite [[[SQLData]]]

-- | Run a statement and fetch all of the data.
fetchAll :: Statement -> IO [[SQLData]]

-- | The type of actions to run on a SQLite database. In essence, it is
--   almost the same as <tt>Database -&gt; IO a</tt>.
--   
--   <a>SQLite</a> actions can be created with the <a>run</a> and
--   <a>runWith</a> functions, and can be composed using the type class
--   instances.
--   
--   <a>SQLite</a> actions can be run with the <a>withDb</a>,
--   <a>withDatabase</a>, and <a>withPool</a> functions.
newtype SQLite a
SQLite :: (SQLiteStuff -> IO a) -> SQLite a
[unSQLite] :: SQLite a -> SQLiteStuff -> IO a
data SQLiteStuff
SQLiteStuff :: Database -> Maybe Int -> SQLiteStuff
[dbConn] :: SQLiteStuff -> Database
[transactionNumber] :: SQLiteStuff -> Maybe Int
getDB :: SQLite Database
runSQLite :: Database -> SQLite a -> IO a

-- | Run operations as a transaction. If the action throws an error, the
--   transaction is rolled back. For more information, visit:
--   <a>https://www.sqlite.org/lang_transaction.html</a>
transaction :: forall a. Typeable a => SQLite a -> SQLite a
asTransaction' :: Database -> IO a -> IO a

-- | Rollback the current (inner-most) transaction by supplying the return
--   value. To be used inside transactions.
rollback :: Typeable a => a -> SQLite a

-- | Rollback all transaction structure by supplying the return value. To
--   be used inside transactions.
rollbackAll :: Typeable a => a -> SQLite a
data RollbackCurrent a
RollbackCurrent :: a -> RollbackCurrent a
data RollbackAll a
RollbackAll :: a -> RollbackAll a
instance GHC.Show.Show Database.Sqlite.Easy.Internal.ConnectionString
instance Data.String.IsString Database.Sqlite.Easy.Internal.ConnectionString
instance GHC.Show.Show Database.Sqlite.Easy.Internal.SQL
instance Data.String.IsString Database.Sqlite.Easy.Internal.SQL
instance GHC.Base.Semigroup Database.Sqlite.Easy.Internal.SQL
instance Control.Monad.IO.Unlift.MonadUnliftIO Database.Sqlite.Easy.Internal.SQLite
instance Control.Monad.Fail.MonadFail Database.Sqlite.Easy.Internal.SQLite
instance Control.Monad.IO.Class.MonadIO Database.Sqlite.Easy.Internal.SQLite
instance GHC.Base.Monad Database.Sqlite.Easy.Internal.SQLite
instance GHC.Base.Applicative Database.Sqlite.Easy.Internal.SQLite
instance GHC.Base.Functor Database.Sqlite.Easy.Internal.SQLite
instance GHC.Show.Show (Database.Sqlite.Easy.Internal.RollbackAll a)
instance Data.Typeable.Internal.Typeable a => GHC.Exception.Type.Exception (Database.Sqlite.Easy.Internal.RollbackAll a)
instance GHC.Show.Show (Database.Sqlite.Easy.Internal.RollbackCurrent a)
instance Data.Typeable.Internal.Typeable a => GHC.Exception.Type.Exception (Database.Sqlite.Easy.Internal.RollbackCurrent a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Database.Sqlite.Easy.Internal.SQLite a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Database.Sqlite.Easy.Internal.SQLite a)


-- | Migrations support based on <tt>migrant-core</tt>.
module Database.Sqlite.Easy.Migrant

-- | Execute a migration against the database. A wrapper around migrant's
--   <a>migrate</a> for SQLite.
migrate :: [MigrationName] -> (MigrationName -> SQLite ()) -> (MigrationName -> SQLite ()) -> SQLite ()
instance Database.Migrant.Driver.Class.Driver Database.SQLite3.Direct.Database


-- | Easy to use interface for SQLite3 using the <tt>direct-sqlite</tt>
--   library.
--   
--   This can be useful for your toy, hobby projects.
module Database.Sqlite.Easy

-- | Open a database, run some stuff, close the database.
withDb :: ConnectionString -> SQLite a -> IO a

-- | Use an active database connection to run some stuff on a database.
withDatabase :: Database -> SQLite a -> IO a

-- | Open a connection to a database, run the supplied statements, and
--   return the connection.
openWith :: ConnectionString -> [SQL] -> IO Database

-- | A SQLite3 connection string
newtype ConnectionString
ConnectionString :: Text -> ConnectionString
[unConnectionString] :: ConnectionString -> Text
data () => Database
data () => Pool a

-- | Create a pool of a sqlite3 db with a specific connection string. This
--   also sets a few default pragmas.
createSqlitePool :: ConnectionString -> IO (Pool Database)

-- | Create a pool of a sqlite3 db with a specific connection string. This
--   will also run the supplied SQL statements after establishing each
--   connection.
createSqlitePoolWith :: ConnectionString -> [SQL] -> IO (Pool Database)

-- | Use a resource pool to run some stuff on a database.
withPool :: Pool Database -> SQLite a -> IO a
withResource :: Pool a -> (a -> IO r) -> IO r
destroyAllResources :: Pool a -> IO ()

-- | Run a SQL statement on a database and fetch the results.
run :: SQL -> SQLite [[SQLData]]

-- | Run a SQL statement with certain parameters on a database and fetch
--   the results.
runWith :: SQL -> [SQLData] -> SQLite [[SQLData]]

-- | Run a SQL statement binding it to all given parameter rows and fetch
--   all of the data. This can significantly improve speed for cases like
--   bulk INSERTs.
runWithMany :: SQL -> [[SQLData]] -> SQLite [[[SQLData]]]

-- | The type of actions to run on a SQLite database. In essence, it is
--   almost the same as <tt>Database -&gt; IO a</tt>.
--   
--   <a>SQLite</a> actions can be created with the <a>run</a> and
--   <a>runWith</a> functions, and can be composed using the type class
--   instances.
--   
--   <a>SQLite</a> actions can be run with the <a>withDb</a>,
--   <a>withDatabase</a>, and <a>withPool</a> functions.
data SQLite a

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
fromString :: IsString a => String -> a

-- | A SQL statement
data SQL
data () => SQLData
SQLInteger :: !Int64 -> SQLData
SQLFloat :: !Double -> SQLData
SQLText :: !Text -> SQLData
SQLBlob :: !ByteString -> SQLData
SQLNull :: SQLData
data () => SQLError
SQLError :: !Error -> Text -> Text -> SQLError
[sqlError] :: SQLError -> !Error
[sqlErrorDetails] :: SQLError -> Text
[sqlErrorContext] :: SQLError -> Text
data () => ColumnType
IntegerColumn :: ColumnType
FloatColumn :: ColumnType
TextColumn :: ColumnType
BlobColumn :: ColumnType
NullColumn :: ColumnType

-- | Run operations as a transaction. If the action throws an error, the
--   transaction is rolled back. For more information, visit:
--   <a>https://www.sqlite.org/lang_transaction.html</a>
transaction :: forall a. Typeable a => SQLite a -> SQLite a

-- | Rollback the current (inner-most) transaction by supplying the return
--   value. To be used inside transactions.
rollback :: Typeable a => a -> SQLite a

-- | Rollback all transaction structure by supplying the return value. To
--   be used inside transactions.
rollbackAll :: Typeable a => a -> SQLite a
data () => MigrationName
class () => Driver d
withTransaction :: Driver d => (d -> IO a) -> d -> IO a
initMigrations :: Driver d => d -> IO ()
markUp :: Driver d => MigrationName -> d -> IO ()
markDown :: Driver d => MigrationName -> d -> IO ()
getMigrations :: Driver d => d -> IO [MigrationName]
data () => MigrationDirection
data () => DummyDriver
DummyDriver :: DummyDriver

-- | Execute a migration against the database. A wrapper around migrant's
--   <a>migrate</a> for SQLite.
migrate :: [MigrationName] -> (MigrationName -> SQLite ()) -> (MigrationName -> SQLite ()) -> SQLite ()
plan :: Driver d => [MigrationName] -> d -> IO [(MigrationDirection, MigrationName)]

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | 64-bit signed integer type
data () => Int64

-- | A space efficient, packed, unboxed Unicode text type.
data () => Text

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data () => ByteString
