-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | timers using SI units (seconds)
--   
--   Timers using SI units (seconds) which are safe on 32-bit platforms and
--   compatible with <a>io-sim</a>.
@package si-timers
@version 1.5.0.0

module Control.Monad.Class.MonadTime.SI
class Monad m => MonadTime (m :: Type -> Type)
getCurrentTime :: MonadTime m => m UTCTime
class MonadMonotonicTimeNSec m => MonadMonotonicTime m
getMonotonicTime :: MonadMonotonicTime m => m Time
getMonotonicTime :: MonadMonotonicTime m => m Time

-- | A point in time in a monotonic clock.
--   
--   The epoch for this clock is arbitrary and does not correspond to any
--   wall clock or calendar, and is <i>not guaranteed</i> to be the same
--   epoch across program runs. It is represented as the <a>DiffTime</a>
--   from this arbitrary epoch.
newtype Time
Time :: DiffTime -> Time

-- | The time duration between two points in time (positive or negative).
diffTime :: Time -> Time -> DiffTime

-- | Add a duration to a point in time, giving another time.
addTime :: DiffTime -> Time -> Time
infixr 9 `addTime`

-- | This is a length of time, as measured by a clock. Conversion functions
--   such as <a>fromInteger</a> and <a>realToFrac</a> will treat it as
--   seconds. For example, <tt>(0.010 :: DiffTime)</tt> corresponds to 10
--   milliseconds.
--   
--   It has a precision of one picosecond (= 10^-12 s). Enumeration
--   functions will treat it as picoseconds.
data () => DiffTime

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data () => UTCTime

-- | diffUTCTime a b = a - b
diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime

-- | addUTCTime a b = a + b
addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime

-- | This is a length of time, as measured by UTC. It has a precision of
--   10^-12 s.
--   
--   Conversion functions such as <a>fromInteger</a> and <a>realToFrac</a>
--   will treat it as seconds. For example, <tt>(0.010 ::
--   NominalDiffTime)</tt> corresponds to 10 milliseconds.
--   
--   It has a precision of one picosecond (= 10^-12 s). Enumeration
--   functions will treat it as picoseconds.
--   
--   It ignores leap-seconds, so it's not necessarily a fixed amount of
--   clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime =
--   01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.
data () => NominalDiffTime
instance NoThunks.Class.NoThunks Control.Monad.Class.MonadTime.SI.Time
instance Control.DeepSeq.NFData Control.Monad.Class.MonadTime.SI.Time
instance GHC.Generics.Generic Control.Monad.Class.MonadTime.SI.Time
instance GHC.Show.Show Control.Monad.Class.MonadTime.SI.Time
instance GHC.Classes.Ord Control.Monad.Class.MonadTime.SI.Time
instance GHC.Classes.Eq Control.Monad.Class.MonadTime.SI.Time
instance Control.Monad.Class.MonadTime.SI.MonadMonotonicTime GHC.Types.IO
instance Control.Monad.Class.MonadTime.SI.MonadMonotonicTime m => Control.Monad.Class.MonadTime.SI.MonadMonotonicTime (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Monad.Class.MonadTimer.SI
class (MonadDelay m, MonadMonotonicTime m) => MonadDelay m
threadDelay :: MonadDelay m => DiffTime -> m ()
class (MonadTimer m, MonadMonotonicTime m) => MonadTimer m

-- | A register delay function which safe on 32-bit systems.
registerDelay :: MonadTimer m => DiffTime -> m (TVar m Bool)

-- | A cancellable register delay which is safe on 32-bit systems and
--   efficient for delays smaller than what <a>Int</a> can represent
--   (especially on systems which support native timer manager).
registerDelayCancellable :: MonadTimer m => DiffTime -> m (STM m TimeoutState, m ())

-- | A timeout function.
--   
--   TODO: <a>IO</a> instance is not safe on 32-bit systems.
timeout :: MonadTimer m => DiffTime -> m a -> m (Maybe a)

-- | Convert <a>DiffTime</a> in seconds to microseconds represented by an
--   <a>Int</a>.
--   
--   Note that on 32bit systems it can only represent `2^31-1` seconds,
--   which is only ~35 minutes.
--   
--   It doesn't prevent under- or overflows; when assertions are on it will
--   thrown an assertion exception.
diffTimeToMicrosecondsAsInt :: DiffTime -> Int

-- | Convert time in microseconds in <a>DiffTime</a> (measured in seconds).
microsecondsAsIntToDiffTime :: Int -> DiffTime

-- | This is a length of time, as measured by a clock. Conversion functions
--   such as <a>fromInteger</a> and <a>realToFrac</a> will treat it as
--   seconds. For example, <tt>(0.010 :: DiffTime)</tt> corresponds to 10
--   milliseconds.
--   
--   It has a precision of one picosecond (= 10^-12 s). Enumeration
--   functions will treat it as picoseconds.
data () => DiffTime
class MonadThread m => MonadFork (m :: Type -> Type)
class MonadMonotonicTimeNSec m => MonadMonotonicTime m
class Monad m => MonadTime (m :: Type -> Type)

-- | State of a timeout: pending, fired or cancelled.
data TimeoutState
TimeoutPending :: TimeoutState
TimeoutFired :: TimeoutState
TimeoutCancelled :: TimeoutState

-- | A default implementation of <a>registerDelay</a> which supports delays
--   longer then <a>Int</a>; this is especially important on 32-bit systems
--   where maximum delay expressed in microseconds is around 35 minutes.
defaultRegisterDelay :: forall m timeout. (MonadFork m, MonadMonotonicTime m, MonadSTM m) => NewTimeout m timeout -> AwaitTimeout m timeout -> DiffTime -> m (TVar m Bool)

-- | A cancellable register delay which is safe on 32-bit systems and
--   efficient for delays smaller than what <a>Int</a> can represent
--   (especially on systems which support native timer manager).
defaultRegisterDelayCancellable :: forall m timeout. (MonadFork m, MonadMonotonicTime m, MonadSTM m) => NewTimeout m timeout -> ReadTimeout m timeout -> CancelTimeout m timeout -> AwaitTimeout m timeout -> DiffTime -> m (STM m TimeoutState, m ())
instance Control.Monad.Class.MonadTimer.SI.MonadTimer GHC.Types.IO
instance Control.Monad.Class.MonadTimer.SI.MonadTimer m => Control.Monad.Class.MonadTimer.SI.MonadTimer (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadTimer.SI.MonadDelay GHC.Types.IO
instance Control.Monad.Class.MonadTimer.SI.MonadDelay m => Control.Monad.Class.MonadTimer.SI.MonadDelay (Control.Monad.Trans.Reader.ReaderT r m)
