-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HTTP client package with conduit interface and HTTPS support.
--   
--   Hackage documentation generation is not reliable. For up to date
--   documentation, please see:
--   <a>http://www.stackage.org/package/http-conduit</a>.
@package http-conduit
@version 2.3.9.1


-- | A new, experimental API to replace <a>Network.HTTP.Conduit</a>.
--   
--   For most users, <a>Network.HTTP.Simple</a> is probably a better
--   choice. For more information, see:
--   
--   <a>https://haskell-lang.org/library/http-client</a>
--   
--   For more information on using this module, please be sure to read the
--   documentation in the <a>Network.HTTP.Client</a> module.
module Network.HTTP.Client.Conduit

-- | Conduit powered version of <a>withResponse</a>. Differences are:
--   
--   <ul>
--   <li>Response body is represented as a <tt>Producer</tt>.</li>
--   <li>Generalized to any instance of <tt>MonadUnliftIO</tt>, not just
--   <tt>IO</tt>.</li>
--   <li>The <tt>Manager</tt> is contained by a <tt>MonadReader</tt>
--   context.</li>
--   </ul>
--   
--   Since 2.1.0
withResponse :: (MonadUnliftIO m, MonadIO n, MonadReader env m, HasHttpManager env) => Request -> (Response (ConduitM i ByteString n ()) -> m a) -> m a

-- | Conduit-powered version of <a>responseOpen</a>.
--   
--   See <a>withResponse</a> for the differences with <a>responseOpen</a>.
--   
--   Since 2.1.0
responseOpen :: (MonadIO m, MonadIO n, MonadReader env m, HasHttpManager env) => Request -> m (Response (ConduitM i ByteString n ()))

-- | Generalized version of <a>responseClose</a>.
--   
--   Since 2.1.0
responseClose :: MonadIO m => Response body -> m ()

-- | An <tt>Acquire</tt> for getting a <tt>Response</tt>.
--   
--   Since 2.1.0
acquireResponse :: (MonadIO n, MonadReader env m, HasHttpManager env) => Request -> m (Acquire (Response (ConduitM i ByteString n ())))

-- | Same as <a>httpSource</a>, but uses <a>Manager</a> from Reader
--   environment instead of the global one.
--   
--   Since 2.3.6
httpSource :: (MonadResource m, MonadIO n, MonadReader env m, HasHttpManager env) => Request -> (Response (ConduitM () ByteString n ()) -> ConduitM () r m ()) -> ConduitM () r m ()

-- | TLS-powered manager settings.
--   
--   Since 2.1.0
defaultManagerSettings :: ManagerSettings

-- | Get a new manager using <a>defaultManagerSettings</a>.
--   
--   Since 2.1.0
newManager :: MonadIO m => m Manager

-- | Get a new manager using the given settings.
--   
--   Since 2.1.0
newManagerSettings :: MonadIO m => ManagerSettings -> m Manager
data () => Proxy
Proxy :: ByteString -> Int -> Proxy
[proxyHost] :: Proxy -> ByteString
[proxyPort] :: Proxy -> Int
data () => RequestBody
RequestBodyLBS :: ByteString -> RequestBody
RequestBodyBS :: ByteString -> RequestBody
RequestBodyBuilder :: Int64 -> Builder -> RequestBody
RequestBodyStream :: Int64 -> GivesPopper () -> RequestBody
RequestBodyStreamChunked :: GivesPopper () -> RequestBody
RequestBodyIO :: IO RequestBody -> RequestBody
data () => Request
data () => Response body
data () => Manager
data () => ManagerSettings
data () => ResponseTimeout
data () => Cookie
Cookie :: ByteString -> ByteString -> UTCTime -> ByteString -> ByteString -> UTCTime -> UTCTime -> Bool -> Bool -> Bool -> Bool -> Cookie
[cookie_name] :: Cookie -> ByteString
[cookie_value] :: Cookie -> ByteString
[cookie_expiry_time] :: Cookie -> UTCTime
[cookie_domain] :: Cookie -> ByteString
[cookie_path] :: Cookie -> ByteString
[cookie_creation_time] :: Cookie -> UTCTime
[cookie_last_access_time] :: Cookie -> UTCTime
[cookie_persistent] :: Cookie -> Bool
[cookie_host_only] :: Cookie -> Bool
[cookie_secure_only] :: Cookie -> Bool
[cookie_http_only] :: Cookie -> Bool
data () => CookieJar
data () => HttpException
HttpExceptionRequest :: Request -> HttpExceptionContent -> HttpException
InvalidUrlException :: String -> String -> HttpException
data () => HttpExceptionContent
StatusCodeException :: Response () -> ByteString -> HttpExceptionContent
TooManyRedirects :: [Response ByteString] -> HttpExceptionContent
OverlongHeaders :: HttpExceptionContent
TooManyHeaderFields :: HttpExceptionContent
ResponseTimeout :: HttpExceptionContent
ConnectionTimeout :: HttpExceptionContent
ConnectionFailure :: SomeException -> HttpExceptionContent
InvalidStatusLine :: ByteString -> HttpExceptionContent
InvalidHeader :: ByteString -> HttpExceptionContent
InvalidRequestHeader :: ByteString -> HttpExceptionContent
InternalException :: SomeException -> HttpExceptionContent
ProxyConnectException :: ByteString -> Int -> Status -> HttpExceptionContent
NoResponseDataReceived :: HttpExceptionContent
TlsNotSupported :: HttpExceptionContent
WrongRequestBodyStreamSize :: Word64 -> Word64 -> HttpExceptionContent
ResponseBodyTooShort :: Word64 -> Word64 -> HttpExceptionContent
InvalidChunkHeaders :: HttpExceptionContent
IncompleteHeaders :: HttpExceptionContent
InvalidDestinationHost :: ByteString -> HttpExceptionContent
HttpZlibException :: ZlibException -> HttpExceptionContent
InvalidProxyEnvironmentVariable :: Text -> Text -> HttpExceptionContent
ConnectionClosed :: HttpExceptionContent
InvalidProxySettings :: Text -> HttpExceptionContent
class () => HasHttpManager a
getHttpManager :: HasHttpManager a => a -> Manager
type GivesPopper a = NeedsPopper a -> IO a
type NeedsPopper a = Popper -> IO a
type Popper = IO ByteString
data () => ProxyOverride
data () => StreamFileStatus
StreamFileStatus :: Int64 -> Int64 -> Int -> StreamFileStatus
[fileSize] :: StreamFileStatus -> Int64
[readSoFar] :: StreamFileStatus -> Int64
[thisChunkSize] :: StreamFileStatus -> Int
data () => HistoriedResponse body
setQueryString :: [(ByteString, Maybe ByteString)] -> Request -> Request
responseTimeoutMicro :: Int -> ResponseTimeout
responseTimeoutNone :: ResponseTimeout
responseTimeoutDefault :: ResponseTimeout
createCookieJar :: [Cookie] -> CookieJar
destroyCookieJar :: CookieJar -> [Cookie]
parseUrl :: MonadThrow m => String -> m Request
parseUrlThrow :: MonadThrow m => String -> m Request
parseRequest :: MonadThrow m => String -> m Request
parseRequest_ :: String -> Request
defaultRequest :: Request
applyBasicAuth :: ByteString -> ByteString -> Request -> Request
urlEncodedBody :: [(ByteString, ByteString)] -> Request -> Request
setRequestIgnoreStatus :: Request -> Request
setRequestCheckStatus :: Request -> Request
brReadSome :: BodyReader -> Int -> IO ByteString
makeConnection :: IO ByteString -> (ByteString -> IO ()) -> IO () -> IO Connection
socketConnection :: Socket -> Int -> IO Connection
strippedHostName :: String -> String
computeCookieString :: Request -> CookieJar -> UTCTime -> Bool -> (ByteString, CookieJar)
defaultPath :: Request -> ByteString
domainMatches :: ByteString -> ByteString -> Bool
evictExpiredCookies :: CookieJar -> UTCTime -> CookieJar
generateCookie :: SetCookie -> Request -> UTCTime -> Bool -> Maybe Cookie
insertCheckedCookie :: Cookie -> CookieJar -> Bool -> CookieJar
insertCookiesIntoRequest :: Request -> CookieJar -> UTCTime -> (Request, CookieJar)
isIpAddress :: ByteString -> Bool
isPotentiallyTrustworthyOrigin :: Bool -> ByteString -> Bool
pathMatches :: ByteString -> ByteString -> Bool
receiveSetCookie :: SetCookie -> Request -> UTCTime -> Bool -> CookieJar -> CookieJar
removeExistingCookieFromCookieJar :: Cookie -> CookieJar -> (Maybe Cookie, CookieJar)
updateCookieJar :: Response a -> Request -> UTCTime -> CookieJar -> (CookieJar, Response a)
withConnection :: Request -> Manager -> (Connection -> IO a) -> IO a
defaultProxy :: ProxyOverride
noProxy :: ProxyOverride
proxyEnvironment :: Maybe Proxy -> ProxyOverride
proxyEnvironmentNamed :: Text -> Maybe Proxy -> ProxyOverride
proxyFromRequest :: ProxyOverride
rawConnectionModifySocket :: (Socket -> IO ()) -> IO (Maybe HostAddress -> String -> Int -> IO Connection)
rawConnectionModifySocketSize :: (Socket -> IO ()) -> IO (Int -> Maybe HostAddress -> String -> Int -> IO Connection)
useProxy :: Proxy -> ProxyOverride
useProxySecureWithoutConnect :: Proxy -> ProxyOverride
withManager :: ManagerSettings -> (Manager -> IO a) -> IO a
applyBasicProxyAuth :: ByteString -> ByteString -> Request -> Request
applyBearerAuth :: ByteString -> Request -> Request
getUri :: Request -> URI
observedStreamFile :: (StreamFileStatus -> IO ()) -> FilePath -> IO RequestBody
requestFromURI :: MonadThrow m => URI -> m Request
requestFromURI_ :: URI -> Request
setQueryStringPartialEscape :: [(ByteString, [EscapeItem])] -> Request -> Request
streamFile :: FilePath -> IO RequestBody
throwErrorStatusCodes :: MonadIO m => Request -> Response BodyReader -> m ()
getOriginalRequest :: Response a -> Request
compareCookies :: Cookie -> Cookie -> Ordering
equalCookie :: Cookie -> Cookie -> Bool
equalCookieJar :: CookieJar -> CookieJar -> Bool
equivCookie :: Cookie -> Cookie -> Bool
equivCookieJar :: CookieJar -> CookieJar -> Bool
managerSetInsecureProxy :: ProxyOverride -> ManagerSettings -> ManagerSettings
managerSetMaxHeaderLength :: Int -> ManagerSettings -> ManagerSettings
managerSetMaxNumberHeaders :: Int -> ManagerSettings -> ManagerSettings
managerSetProxy :: ProxyOverride -> ManagerSettings -> ManagerSettings
managerSetSecureProxy :: ProxyOverride -> ManagerSettings -> ManagerSettings
responseOpenHistory :: Request -> Manager -> IO (HistoriedResponse BodyReader)
withResponseHistory :: Request -> Manager -> (HistoriedResponse BodyReader -> IO a) -> IO a

-- | Same as <a>httpLbs</a>, except it uses the <tt>Manager</tt> in the
--   reader environment.
--   
--   Since 2.1.1
httpLbs :: (MonadIO m, HasHttpManager env, MonadReader env m) => Request -> m (Response ByteString)

-- | Same as <a>httpNoBody</a>, except it uses the <tt>Manager</tt> in the
--   reader environment.
--   
--   This can be more convenient that using <a>withManager</a> as it avoids
--   the need to specify the base monad for the response body.
--   
--   Since 2.1.2
httpNoBody :: (MonadIO m, HasHttpManager env, MonadReader env m) => Request -> m (Response ())
requestBodySource :: Int64 -> ConduitM () ByteString IO () -> RequestBody
requestBodySourceChunked :: ConduitM () ByteString IO () -> RequestBody
bodyReaderSource :: MonadIO m => BodyReader -> ConduitM i ByteString m ()


-- | <h1>Simpler API</h1>
--   
--   The API below is rather low-level. The <a>Network.HTTP.Simple</a>
--   module provides a higher-level API with built-in support for things
--   like JSON request and response bodies. For most users, this will be an
--   easier place to start. You can read the tutorial at:
--   
--   <a>https://haskell-lang.org/library/http-client</a>
--   
--   <h1>Lower-level API</h1>
--   
--   This module contains everything you need to initiate HTTP connections.
--   If you want a simple interface based on URLs, you can use
--   <a>simpleHttp</a>. If you want raw power, <a>http</a> is the
--   underlying workhorse of this package. Some examples:
--   
--   <pre>
--   -- Just download an HTML document and print it.
--   import Network.HTTP.Conduit
--   import qualified Data.ByteString.Lazy as L
--   
--   main = simpleHttp "http://www.haskell.org/" &gt;&gt;= L.putStr
--   </pre>
--   
--   This example uses interleaved IO to write the response body to a file
--   in constant memory space.
--   
--   <pre>
--   import Data.Conduit.Binary (sinkFile) -- Exported from the package conduit-extra
--   import Network.HTTP.Conduit
--   import Conduit (runConduit, (.|))
--   import Control.Monad.Trans.Resource (runResourceT)
--   
--   main :: IO ()
--   main = do
--        request &lt;- parseRequest "http://google.com/"
--        manager &lt;- newManager tlsManagerSettings
--        runResourceT $ do
--            response &lt;- http request manager
--            runConduit $ responseBody response .| sinkFile "google.html"
--   </pre>
--   
--   The following headers are automatically set by this module, and should
--   not be added to <a>requestHeaders</a>:
--   
--   <ul>
--   <li>Cookie</li>
--   <li>Content-Length</li>
--   <li>Transfer-Encoding</li>
--   </ul>
--   
--   Note: In previous versions, the Host header would be set by this
--   module in all cases. Starting from 1.6.1, if a Host header is present
--   in <tt>requestHeaders</tt>, it will be used in place of the header
--   this module would have generated. This can be useful for calling a
--   server which utilizes virtual hosting.
--   
--   Use <a>cookieJar</a> If you want to supply cookies with your request:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Network.HTTP.Conduit
--   import Network
--   import Data.Time.Clock
--   import Data.Time.Calendar
--   import qualified Control.Exception as E
--   import Network.HTTP.Types.Status (statusCode)
--   
--   past :: UTCTime
--   past = UTCTime (ModifiedJulianDay 56200) (secondsToDiffTime 0)
--   
--   future :: UTCTime
--   future = UTCTime (ModifiedJulianDay 562000) (secondsToDiffTime 0)
--   
--   cookie :: Cookie
--   cookie = Cookie { cookie_name = "password_hash"
--                   , cookie_value = "abf472c35f8297fbcabf2911230001234fd2"
--                   , cookie_expiry_time = future
--                   , cookie_domain = "example.com"
--                   , cookie_path = "/"
--                   , cookie_creation_time = past
--                   , cookie_last_access_time = past
--                   , cookie_persistent = False
--                   , cookie_host_only = False
--                   , cookie_secure_only = False
--                   , cookie_http_only = False
--                   }
--   
--   main = do
--        request' &lt;- parseRequest "http://example.com/secret-page"
--        manager &lt;- newManager tlsManagerSettings
--        let request = request' { cookieJar = Just $ createCookieJar [cookie] }
--        fmap Just (httpLbs request manager) `E.catch`
--                (\ex -&gt; case ex of
--                    HttpExceptionRequest _ (StatusCodeException res _) -&gt;
--                        if statusCode (responseStatus res) == 403
--                          then (putStrLn "login failed" &gt;&gt; return Nothing)
--                          else return Nothing
--                    _ -&gt; E.throw ex)
--   </pre>
--   
--   Cookies are implemented according to RFC 6265.
--   
--   Note that by default, the functions in this package will throw
--   exceptions for non-2xx status codes. If you would like to avoid this,
--   you should use <tt>checkStatus</tt>, e.g.:
--   
--   <pre>
--   import Data.Conduit.Binary (sinkFile)
--   import Network.HTTP.Conduit
--   import qualified Data.Conduit as C
--   import Network
--   
--   main :: IO ()
--   main = do
--        request' &lt;- parseRequest "http://www.yesodweb.com/does-not-exist"
--        let request = request' { checkStatus = \_ _ _ -&gt; Nothing }
--        manager &lt;- newManager tlsManagerSettings
--        res &lt;- httpLbs request manager
--        print res
--   </pre>
--   
--   By default, when connecting to websites using HTTPS, functions in this
--   package will throw an exception if the TLS certificate doesn't
--   validate. To continue the HTTPS transaction even if the TLS cerficate
--   validation fails, you should use <tt>mkManagerSetttings</tt> as
--   follows:
--   
--   <pre>
--   import Network.Connection (TLSSettings (..))
--   import Network.HTTP.Conduit
--   
--   main :: IO ()
--   main = do
--       request &lt;- parseRequest "https://github.com/"
--       let settings = mkManagerSettings (TLSSettingsSimple True False False) Nothing
--       manager &lt;- newManager settings
--       res &lt;- httpLbs request manager
--       print res
--   </pre>
--   
--   For more information, please be sure to read the documentation in the
--   <a>Network.HTTP.Client</a> module.
module Network.HTTP.Conduit

-- | Download the specified URL, following any redirects, and return the
--   response body.
--   
--   This function will <tt>throwIO</tt> an <a>HttpException</a> for any
--   response with a non-2xx status code (besides 3xx redirects up to a
--   limit of 10 redirects). It uses <a>parseUrlThrow</a> to parse the
--   input. This function essentially wraps <a>httpLbs</a>.
--   
--   Note: Even though this function returns a lazy bytestring, it does
--   <i>not</i> utilize lazy I/O, and therefore the entire response body
--   will live in memory. If you want constant memory usage, you'll need to
--   use the <tt>conduit</tt> package and <a>http</a> directly.
--   
--   Note: This function creates a new <a>Manager</a>. It should be avoided
--   in production code.
simpleHttp :: MonadIO m => String -> m ByteString

-- | Download the specified <a>Request</a>, returning the results as a
--   <a>Response</a>.
--   
--   This is a simplified version of <a>http</a> for the common case where
--   you simply want the response data as a simple datatype. If you want
--   more power, such as interleaved actions on the response body during
--   download, you'll need to use <a>http</a> directly. This function is
--   defined as:
--   
--   <pre>
--   httpLbs = <a>lbsResponse</a> &lt;=&lt; <a>http</a>
--   </pre>
--   
--   Even though the <a>Response</a> contains a lazy bytestring, this
--   function does <i>not</i> utilize lazy I/O, and therefore the entire
--   response body will live in memory. If you want constant memory usage,
--   you'll need to use <tt>conduit</tt> packages's <a>Source</a> returned
--   by <a>http</a>.
--   
--   This function will <tt>throwIO</tt> an <a>HttpException</a> for any
--   response with a non-2xx status code (besides 3xx redirects up to a
--   limit of 10 redirects). This behavior can be modified by changing the
--   <tt>checkStatus</tt> field of your request.
--   
--   Note: Unlike previous versions, this function will perform redirects,
--   as specified by the <a>redirectCount</a> setting.
httpLbs :: MonadIO m => Request -> Manager -> m (Response ByteString)
http :: MonadResource m => Request -> Manager -> m (Response (ConduitM i ByteString m ()))
data () => Proxy
Proxy :: ByteString -> Int -> Proxy
[proxyHost] :: Proxy -> ByteString
[proxyPort] :: Proxy -> Int
data () => RequestBody
RequestBodyLBS :: ByteString -> RequestBody
RequestBodyBS :: ByteString -> RequestBody
RequestBodyBuilder :: Int64 -> Builder -> RequestBody
RequestBodyStream :: Int64 -> GivesPopper () -> RequestBody
RequestBodyStreamChunked :: GivesPopper () -> RequestBody
RequestBodyIO :: IO RequestBody -> RequestBody
data () => Request
method :: Request -> Method
secure :: Request -> Bool
host :: Request -> ByteString
port :: Request -> Int
path :: Request -> ByteString
queryString :: Request -> ByteString
requestHeaders :: Request -> RequestHeaders
requestBody :: Request -> RequestBody
proxy :: Request -> Maybe Proxy
hostAddress :: Request -> Maybe HostAddress
rawBody :: Request -> Bool
decompress :: Request -> ByteString -> Bool
redirectCount :: Request -> Int
shouldStripHeaderOnRedirect :: Request -> HeaderName -> Bool
checkResponse :: Request -> Request -> Response BodyReader -> IO ()
responseTimeout :: Request -> ResponseTimeout
cookieJar :: Request -> Maybe CookieJar
requestVersion :: Request -> HttpVersion
setQueryString :: [(ByteString, Maybe ByteString)] -> Request -> Request
requestBodySource :: Int64 -> ConduitM () ByteString (ResourceT IO) () -> RequestBody
requestBodySourceChunked :: ConduitM () ByteString (ResourceT IO) () -> RequestBody
requestBodySourceIO :: Int64 -> ConduitM () ByteString IO () -> RequestBody
requestBodySourceChunkedIO :: ConduitM () ByteString IO () -> RequestBody
data () => Response body
responseStatus :: Response body -> Status
responseVersion :: Response body -> HttpVersion
responseHeaders :: Response body -> ResponseHeaders
responseBody :: Response body -> body
responseCookieJar :: Response body -> CookieJar
responseEarlyHints :: Response body -> ResponseHeaders
data () => Manager
newManager :: ManagerSettings -> IO Manager
closeManager :: Manager -> IO ()
data () => ManagerSettings
tlsManagerSettings :: ManagerSettings
mkManagerSettings :: TLSSettings -> Maybe SockSettings -> ManagerSettings
managerConnCount :: ManagerSettings -> Int
managerResponseTimeout :: ManagerSettings -> ResponseTimeout
managerTlsConnection :: ManagerSettings -> IO (Maybe HostAddress -> String -> Int -> IO Connection)
data () => ResponseTimeout
responseTimeoutMicro :: Int -> ResponseTimeout
responseTimeoutNone :: ResponseTimeout
responseTimeoutDefault :: ResponseTimeout
data () => Cookie
Cookie :: ByteString -> ByteString -> UTCTime -> ByteString -> ByteString -> UTCTime -> UTCTime -> Bool -> Bool -> Bool -> Bool -> Cookie
[cookie_name] :: Cookie -> ByteString
[cookie_value] :: Cookie -> ByteString
[cookie_expiry_time] :: Cookie -> UTCTime
[cookie_domain] :: Cookie -> ByteString
[cookie_path] :: Cookie -> ByteString
[cookie_creation_time] :: Cookie -> UTCTime
[cookie_last_access_time] :: Cookie -> UTCTime
[cookie_persistent] :: Cookie -> Bool
[cookie_host_only] :: Cookie -> Bool
[cookie_secure_only] :: Cookie -> Bool
[cookie_http_only] :: Cookie -> Bool
data () => CookieJar
createCookieJar :: [Cookie] -> CookieJar
destroyCookieJar :: CookieJar -> [Cookie]
parseUrl :: MonadThrow m => String -> m Request
parseUrlThrow :: MonadThrow m => String -> m Request
parseRequest :: MonadThrow m => String -> m Request
parseRequest_ :: String -> Request
defaultRequest :: Request
applyBasicAuth :: ByteString -> ByteString -> Request -> Request
addProxy :: ByteString -> Int -> Request -> Request
lbsResponse :: Monad m => Response (ConduitM () ByteString m ()) -> m (Response ByteString)
getRedirectedRequest :: Request -> Request -> ResponseHeaders -> CookieJar -> Int -> Maybe Request
alwaysDecompress :: ByteString -> Bool
browserDecompress :: ByteString -> Bool
urlEncodedBody :: [(ByteString, ByteString)] -> Request -> Request
data () => HttpException
HttpExceptionRequest :: Request -> HttpExceptionContent -> HttpException
InvalidUrlException :: String -> String -> HttpException
data () => HttpExceptionContent
StatusCodeException :: Response () -> ByteString -> HttpExceptionContent
TooManyRedirects :: [Response ByteString] -> HttpExceptionContent
OverlongHeaders :: HttpExceptionContent
TooManyHeaderFields :: HttpExceptionContent
ResponseTimeout :: HttpExceptionContent
ConnectionTimeout :: HttpExceptionContent
ConnectionFailure :: SomeException -> HttpExceptionContent
InvalidStatusLine :: ByteString -> HttpExceptionContent
InvalidHeader :: ByteString -> HttpExceptionContent
InvalidRequestHeader :: ByteString -> HttpExceptionContent
InternalException :: SomeException -> HttpExceptionContent
ProxyConnectException :: ByteString -> Int -> Status -> HttpExceptionContent
NoResponseDataReceived :: HttpExceptionContent
TlsNotSupported :: HttpExceptionContent
WrongRequestBodyStreamSize :: Word64 -> Word64 -> HttpExceptionContent
ResponseBodyTooShort :: Word64 -> Word64 -> HttpExceptionContent
InvalidChunkHeaders :: HttpExceptionContent
IncompleteHeaders :: HttpExceptionContent
InvalidDestinationHost :: ByteString -> HttpExceptionContent
HttpZlibException :: ZlibException -> HttpExceptionContent
InvalidProxyEnvironmentVariable :: Text -> Text -> HttpExceptionContent
ConnectionClosed :: HttpExceptionContent
InvalidProxySettings :: Text -> HttpExceptionContent


-- | Simplified interface for common HTTP client interactions. Tutorial
--   available at <a>https://haskell-lang.org/library/http-client</a>
--   
--   Important note: <a>Request</a> is an instance of <a>IsString</a>, and
--   therefore recommended usage is to turn on <tt>OverloadedStrings</tt>,
--   e.g.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Network.HTTP.Simple
--   import qualified Data.ByteString.Char8 as B8
--   
--   main :: IO ()
--   main = httpBS "http://example.com" &gt;&gt;= B8.putStrLn . getResponseBody
--   </pre>
--   
--   The <a>IsString</a> instance uses <a>parseRequest</a> behind the
--   scenes and inherits its behavior.
module Network.HTTP.Simple

-- | Perform an HTTP request and return the body as a <tt>ByteString</tt>.
httpBS :: MonadIO m => Request -> m (Response ByteString)

-- | Perform an HTTP request and return the body as a lazy
--   <tt>ByteString</tt>. Note that the entire value will be read into
--   memory at once (no lazy I/O will be performed). The advantage of a
--   lazy <tt>ByteString</tt> here (versus using <a>httpBS</a>) is--if
--   needed--a better in-memory representation.
httpLBS :: MonadIO m => Request -> m (Response ByteString)

-- | Perform an HTTP request and ignore the response body.
httpNoBody :: MonadIO m => Request -> m (Response ())

-- | Perform an HTTP request and parse the body as JSON. In the event of an
--   JSON parse errors, a <a>JSONException</a> runtime exception will be
--   thrown.
--   
--   NOTE: Depends on the <tt>aeson</tt> cabal flag being enabled
httpJSON :: (MonadIO m, FromJSON a) => Request -> m (Response a)

-- | Perform an HTTP request and parse the body as JSON. In the event of an
--   JSON parse errors, a <tt>Left</tt> value will be returned.
--   
--   NOTE: Depends on the <tt>aeson</tt> cabal flag being enabled
httpJSONEither :: (MonadIO m, FromJSON a) => Request -> m (Response (Either JSONException a))

-- | Perform an HTTP request and consume the body with the given
--   <a>Sink</a>
httpSink :: MonadUnliftIO m => Request -> (Response () -> ConduitM ByteString Void m a) -> m a

-- | Perform an HTTP request, and get the response body as a Source.
--   
--   The second argument to this function tells us how to make the Source
--   from the Response itself. This allows you to perform actions with the
--   status or headers, for example, in addition to the raw bytes
--   themselves. If you just care about the response body, you can use
--   <a>getResponseBody</a> as the second argument here.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import           Control.Monad.IO.Class       (liftIO)
--   import           Control.Monad.Trans.Resource (runResourceT)
--   import           Data.Conduit                 (($$))
--   import qualified Data.Conduit.Binary          as CB
--   import qualified Data.Conduit.List            as CL
--   import           Network.HTTP.Simple
--   import           System.IO                    (stdout)
--   
--   main :: IO ()
--   main =
--       runResourceT
--           $ httpSource "<a>http://httpbin.org/robots.txt"</a> getSrc
--          $$ CB.sinkHandle stdout
--     where
--       getSrc res = do
--           liftIO $ print (getResponseStatus res, getResponseHeaders res)
--           getResponseBody res
--   </pre>
httpSource :: (MonadResource m, MonadIO n) => Request -> (Response (ConduitM i ByteString n ()) -> ConduitM i o m r) -> ConduitM i o m r

-- | Perform an action with the given request. This employes the bracket
--   pattern.
--   
--   This is similar to <a>httpSource</a>, but does not require
--   <a>MonadResource</a> and allows the result to not contain a
--   <a>ConduitM</a> value.
withResponse :: (MonadUnliftIO m, MonadIO n) => Request -> (Response (ConduitM i ByteString n ()) -> m a) -> m a
type Header = (HeaderName, ByteString)
type Query = [QueryItem]
type QueryItem = (ByteString, Maybe ByteString)
data () => Request
type RequestHeaders = [Header]
data () => Response body
type ResponseHeaders = [Header]

-- | An exception that can occur when parsing JSON
--   
--   NOTE: Depends on the <tt>aeson</tt> cabal flag being enabled
data JSONException
JSONParseException :: Request -> Response () -> ParseError -> JSONException
JSONConversionException :: Request -> Response Value -> String -> JSONException
data () => HttpException
HttpExceptionRequest :: Request -> HttpExceptionContent -> HttpException
InvalidUrlException :: String -> String -> HttpException
data () => Proxy
Proxy :: ByteString -> Int -> Proxy
[proxyHost] :: Proxy -> ByteString
[proxyPort] :: Proxy -> Int
defaultRequest :: Request
parseRequest :: MonadThrow m => String -> m Request
parseRequest_ :: String -> Request

-- | Same as <tt>parseRequest</tt>, except will throw an
--   <tt>HttpException</tt> in the event of a non-2XX response. This uses
--   <tt>throwErrorStatusCodes</tt> to implement <tt>checkResponse</tt>.
--   
--   Exactly the same as <tt>parseUrlThrow</tt>, but has a name that is
--   more consistent with the other parseRequest functions.
parseRequestThrow :: MonadThrow m => String -> m Request

-- | Same as <a>parseRequestThrow</a>, but parse errors cause an impure
--   exception. Mostly useful for static strings which are known to be
--   correctly formatted.
parseRequestThrow_ :: String -> Request

-- | Set the request method
setRequestMethod :: ByteString -> Request -> Request

-- | Set whether this is a secure<i>HTTPS (<tt>True</tt>) or
--   insecure</i>HTTP (<tt>False</tt>) request
setRequestSecure :: Bool -> Request -> Request

-- | Set the destination host of the request
setRequestHost :: ByteString -> Request -> Request

-- | Set the destination port of the request
setRequestPort :: Int -> Request -> Request

-- | Lens for the requested path info of the request
setRequestPath :: ByteString -> Request -> Request

-- | Add a request header name/value combination
addRequestHeader :: HeaderName -> ByteString -> Request -> Request

-- | Get all request header values for the given name
getRequestHeader :: HeaderName -> Request -> [ByteString]

-- | Set the given request header to the given list of values. Removes any
--   previously set header values with the same name.
setRequestHeader :: HeaderName -> [ByteString] -> Request -> Request

-- | Set the request headers, wiping out <b>all</b> previously set headers.
--   This means if you use <a>setRequestHeaders</a> to set some headers and
--   also use one of the other setters that modifies the
--   <tt>content-type</tt> header (such as <a>setRequestBodyJSON</a>), be
--   sure that <a>setRequestHeaders</a> is evaluated <b>first</b>.
setRequestHeaders :: RequestHeaders -> Request -> Request

-- | Set the query string parameters
setRequestQueryString :: Query -> Request -> Request

-- | Get the query string parameters
getRequestQueryString :: Request -> Query

-- | Add to the existing query string parameters.
addToRequestQueryString :: Query -> Request -> Request

-- | Set the request body to the given <a>RequestBody</a>. You may want to
--   consider using one of the convenience functions in the modules, e.g.
--   <tt>requestBodyJSON</tt>.
--   
--   <i>Note</i>: This will not modify the request method. For that, please
--   use <tt>requestMethod</tt>. You likely don't want the default of
--   <tt>GET</tt>.
setRequestBody :: RequestBody -> Request -> Request

-- | Set the request body as a JSON value
--   
--   <i>Note</i>: This will not modify the request method. For that, please
--   use <tt>requestMethod</tt>. You likely don't want the default of
--   <tt>GET</tt>.
--   
--   This also sets the <tt>Content-Type</tt> to <tt>application/json;
--   charset=utf-8</tt>
--   
--   NOTE: Depends on the <tt>aeson</tt> cabal flag being enabled
setRequestBodyJSON :: ToJSON a => a -> Request -> Request

-- | Set the request body as a lazy <tt>ByteString</tt>
--   
--   <i>Note</i>: This will not modify the request method. For that, please
--   use <tt>requestMethod</tt>. You likely don't want the default of
--   <tt>GET</tt>.
setRequestBodyLBS :: ByteString -> Request -> Request

-- | Set the request body as a <a>Source</a>
--   
--   <i>Note</i>: This will not modify the request method. For that, please
--   use <tt>requestMethod</tt>. You likely don't want the default of
--   <tt>GET</tt>.
setRequestBodySource :: Int64 -> ConduitM () ByteString IO () -> Request -> Request

-- | Set the request body as a file
--   
--   <i>Note</i>: This will not modify the request method. For that, please
--   use <tt>requestMethod</tt>. You likely don't want the default of
--   <tt>GET</tt>.
setRequestBodyFile :: FilePath -> Request -> Request

-- | Set the request body as URL encoded data
--   
--   <i>Note</i>: This will change the request method to <tt>POST</tt> and
--   set the <tt>content-type</tt> to
--   <tt>application/x-www-form-urlencoded</tt>
setRequestBodyURLEncoded :: [(ByteString, ByteString)] -> Request -> Request
setRequestIgnoreStatus :: Request -> Request
setRequestCheckStatus :: Request -> Request

-- | Set basic auth with the given username and password
setRequestBasicAuth :: ByteString -> ByteString -> Request -> Request

-- | Set bearer auth with the given token
setRequestBearerAuth :: ByteString -> Request -> Request

-- | Instead of using the default global <a>Manager</a>, use the supplied
--   <tt>Manager</tt>.
setRequestManager :: Manager -> Request -> Request

-- | Override the default proxy server settings
setRequestProxy :: Maybe Proxy -> Request -> Request

-- | Set the maximum time to wait for a response
setRequestResponseTimeout :: ResponseTimeout -> Request -> Request

-- | Get the status of the response
getResponseStatus :: Response a -> Status

-- | Get the integral status code of the response
getResponseStatusCode :: Response a -> Int

-- | Get all response header values with the given name
getResponseHeader :: HeaderName -> Response a -> [ByteString]

-- | Get all response headers
getResponseHeaders :: Response a -> [(HeaderName, ByteString)]

-- | Get the response body
getResponseBody :: Response a -> a

-- | Alternate spelling of <a>httpLBS</a>
httpLbs :: MonadIO m => Request -> m (Response ByteString)
instance GHC.Show.Show Network.HTTP.Simple.JSONException
instance GHC.Exception.Type.Exception Network.HTTP.Simple.JSONException
