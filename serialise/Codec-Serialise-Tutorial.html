<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Codec.Serialise.Tutorial</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">serialise-0.2.6.1: A binary serialisation library for Haskell values.</span><ul class="links" id="page-menu"><li><a href="src/Codec.Serialise.Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Duncan Coutts 2015-2017</td></tr><tr><th>License</th><td>BSD3-style (see LICENSE.txt)</td></tr><tr><th>Maintainer</th><td>duncan@community.haskell.org</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable (GHC extensions)</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Codec.Serialise.Tutorial</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Basic use example</a></li><li><a href="#g:2">The CBOR format</a><ul><li><a href="#g:3">Interoperability with other CBOR implementations</a></li></ul></li><li><a href="#g:4">The <code>Serialise</code> class</a><ul><li><a href="#g:5">How to write encoding terms</a></li><li><a href="#g:6">How to write decoding terms</a></li></ul></li><li><a href="#g:7">Migrations</a></li><li><a href="#g:8">Working with foreign encodings</a><ul><li><a href="#g:9">Working with arbitrary terms</a></li><li><a href="#g:10">Examining encodings</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p><code>serialise</code> library is built on <code>cborg</code>, they implement CBOR (Concise Binary Object Representation, specified by <a href="https://tools.ietf.org/html/rfc7049">IETF RFC 7049</a>) and serialisers/deserializers for it.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Basic use example</h1></a><div class="doc"><p><code>serialise</code> offers ability to derive instances via <code><a href="GHC.html#v:Generic" title="GHC">Generic</a></code> mechanism:</p><pre>import Codec.Serialise
import qualified Data.ByteString.Lazy as BSL

fileName :: FilePath
fileName = &quot;out.cbor&quot;

data Animal = HoppingAnimal { animalName :: String, hoppingHeight :: Int }
            | WalkingAnimal { animalName :: String, walkingSpeed  :: Int }
            deriving (Generic)

instance Serialise Animal

fredTheFrog :: Animal
fredTheFrog = HoppingAnimal &quot;Fred&quot; 4

-- | To output value into a file
write :: Serialise a =&gt; FilePath -&gt; a -&gt; IO ()
write file val = BSL.writeFile file (serialise val)

-- | Outputs @Fred@ value into file
writeIO :: IO ()
writeIO = write fileName fredTheFrog

-- | Reads the value from file
readIO :: IO Animal
readIO = deserialise &lt;$&gt; BSL.readFile fileName

printIO :: IO ()
printIO = do
    val &lt;- readIO
    print val</pre></div><a href="#g:2" id="g:2"><h1>The CBOR format</h1></a><div class="doc"><p>CBOR encoding is efficient in encoding/decoding complexity and space, and is generally machine-independent.</p><p>CBOR data model has:
  * integers
  * floating point numbers
  * binary strings
  * text
  * arrays
  * key/value maps
and resembles JSON.</p><p>CBOR allows items to be <em>tagged</em> with a number which identifies the type of data.
This can be used both to identify which data constructor of a type
is represented, as well as representing different versions of the same
constructor.</p></div><a href="#g:3" id="g:3"><h2>Interoperability with other CBOR implementations</h2></a><div class="doc"><p>Library provides means of stably storing Haskell values for later
reading by the library.</p><p>The library is <em>not</em> aimed to facilitate serialisation and
deserialisation across different CBOR implementations.
But that is possible to setup practically.</p><p>A few things on compatibility with other CBOR implementations:</p><ol><li value="1">The <code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> instances for some &quot;basic&quot; Haskell types (e.g. <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code>,
   <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/bytestring-0.11.5.3/Data-ByteString.html#v:ByteString" title="Data.ByteString">ByteString</a></code>, tuples) don't carry a tag, in contrast to common
   convention. This is an intentional design decision to minimize encoding size
   for types which are primitive enough that their representation can be
   considered stable.</li><li value="2">The library reserves the right to change encodings in
   non-backwards-compatible ways across super-major versions. For example the
   library may start producing a new representation for some type. The new
   version of the library will be able to decode the old and new representation,
   but different CBOR decoder would not be expecting the new representation
   and would have to be updated to match.</li><li value="3">While the library tries to use standard encodings in its instances wherever possible,
   these instances aren't guaranteed to implement all valid variants of the
   RFCs/standards mentioned in the specification. For instance, the <code>UTCTime</code> instance only
   implements a small subset of the encodings described by the Extended Date
   RFC.</li></ol></div><a href="#g:4" id="g:4"><h1>The <code>Serialise</code> class</h1></a><div class="doc"><p><code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> class provides convenient access to serialisers and
deserialisers.</p><p>Creating &amp; using a serialiser can be as simple as deriving <code>Generic</code> and
<code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code>,</p><pre>-- all GHCs
data MyType = ...
            deriving (Generic)
instance Serialise MyType

-- with DerivingStrategies (GHC 8.2 and newer)
data Animal = ...
            deriving stock (Generic)
            deriving anyclass (Serialise)</pre><p>Of course, equivalent implementations can be handwritten.
A custom <code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> instance may be desireable for a variety
of reasons:</p><ul><li>deviating from the type-guided encoding that the <code>Generic</code> instance provides</li><li>interfacing with other CBOR implementations</li><li>managing migration changes to the type and its encoding</li></ul><p><code><a href="Codec-Serialise-Class.html#v:encode" title="Codec.Serialise.Class">encode</a></code> and <code><a href="Codec-Serialise-Class.html#v:decode" title="Codec.Serialise.Class">decode</a></code> methods form a minimal <code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> instance definition:</p><pre>instance Serialise Animal where
    encode = encodeAnimal
    decode = decodeAnimal</pre></div><a href="#g:5" id="g:5"><h2>How to write encoding terms</h2></a><div class="doc"><p>For the purposes of encoding, abstract CBOR representations are embodied by the
<code><a href="Codec-CBOR-Encoding.html#v:Tokens" title="Codec.CBOR.Encoding">Tokens</a></code> type. Such a representation can be efficiently
built using the <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a></code> <code><a href="Codec-CBOR-Encoding.html#v:Encoding" title="Codec.CBOR.Encoding">Encoding</a></code>.</p><p>For instance, to implement an encoder for the <code>Animal</code> type above:</p><pre>encodeAnimal :: Animal -&gt; Encoding
encodeAnimal (HoppingAnimal name height) =
    encodeListLen 3 &lt;&gt; encodeWord 0 &lt;&gt; encode name &lt;&gt; encode height
encodeAnimal (WalkingAnimal name speed) =
    encodeListLen 3 &lt;&gt; encodeWord 1 &lt;&gt; encode name &lt;&gt; encode speed</pre><p>Each encoding begins with a <em>length</em>, declaring how many
values belonging to <code>Animal</code> constructor going to follow. Then a <em>tag</em> which
identifies constructor. Fields are encoded using their respective
<code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> instances.</p><p>It is recommended to not deviate from this encoding scheme - including both
the length and tag - to ensure to have the option to migrate types
later on.</p><p>Note: the recommended encoding represents Haskell constructor indexes
as CBOR words, not CBOR tags.</p></div><a href="#g:6" id="g:6"><h2>How to write decoding terms</h2></a><div class="doc"><p>Decoding CBOR representations to Haskell values is done in the <code><a href="Codec-Serialise-Decoding.html#t:Decoder" title="Codec.Serialise.Decoding">Decoder</a></code>
<code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code>. A <code><a href="Codec-Serialise-Class.html#v:decode" title="Codec.Serialise.Class">decode</a></code> for the <code>Animal</code> type would be:</p><pre>decodeAnimal :: Decoder s Animal
decodeAnimal = do
    len &lt;- decodeListLen
    tag &lt;- decodeWord
    case (len, tag) of
      (3, 0) -&gt; HoppingAnimal &lt;$&gt; decode &lt;*&gt; decode
      (3, 1) -&gt; WalkingAnimal &lt;$&gt; decode &lt;*&gt; decode
      _      -&gt; fail &quot;invalid Animal encoding&quot;</pre></div><a href="#g:7" id="g:7"><h1>Migrations</h1></a><div class="doc"><p>One eventuality that data serialisation schemes need to account for
- is the future changes in the data's structure.</p><p>There are two types of compatibility to strive for in serialisers:</p><ul><li>backward compatibility: newer versions of the serialiser can read
   older versions of an encoding</li><li>forward compatibility: older versions of the serialiser can read
   (or at least tolerate) newer versions of an encoding</li></ul><p>Below are a few examples of how to provide backward-compatible serialisation.</p><h3>Adding a constructor</h3><p>Example: adding a new constructor to <code>Animal</code> type, <code>SwimmingAnimal</code>,</p><pre>data Animal = HoppingAnimal { animalName :: String, hoppingHeight :: Int }
            | WalkingAnimal { animalName :: String, walkingSpeed :: Int }
            | SwimmingAnimal { numberOfFins :: Int }
            deriving (Generic)</pre><p>To account for this in handwritten serialiser - add a new tag
to encoder and decoder,</p><pre>encodeAnimal :: Animal -&gt; Encoding
-- HoppingAnimal, SwimmingAnimal cases are unchanged...
encodeAnimal (HoppingAnimal name height) =
    encodeListLen 3 &lt;&gt; encodeWord 0 &lt;&gt; encode name &lt;&gt; encode height
encodeAnimal (WalkingAnimal name speed) =
    encodeListLen 3 &lt;&gt; encodeWord 1 &lt;&gt; encode name &lt;&gt; encode speed
-- Here is out new case...
encodeAnimal (SwimmingAnimal numberOfFins) =
    encodeListLen 2 &lt;&gt; encodeWord 2 &lt;&gt; encode numberOfFins

decodeAnimal :: Decoder s Animal
decodeAnimal = do
    len &lt;- decodeListLen
    tag &lt;- decodeWord
    case (len, tag) of
      -- these cases are unchanged...
      (3, 0) -&gt; HoppingAnimal &lt;$&gt; decode &lt;*&gt; decode
      (3, 1) -&gt; WalkingAnimal &lt;$&gt; decode &lt;*&gt; decode
      -- this is new...
      (2, 2) -&gt; SwimmingAnimal &lt;$&gt; decode
      _      -&gt; fail &quot;invalid Animal encoding&quot;</pre><h3>Adding/removing/modifying fields</h3><p>Example: adding a new field to <code>WalkingAnimal</code> constructor,</p><pre>data Animal = HoppingAnimal { animalName :: String, hoppingHeight :: Int }
            | WalkingAnimal { animalName :: String, walkingSpeed  :: Int, numberOfFeet :: Int }
            | SwimmingAnimal { numberOfFins :: Int }
            deriving (Generic)</pre><p>To account for this - represent <code>WalkingAnimal</code> with a new encoding with
a new tag, while also providing default value for backward compatibility:</p><pre>encodeAnimal :: Animal -&gt; Encoding
-- HoppingAnimal, SwimmingAnimal cases are unchanged...
encodeAnimal (HoppingAnimal name height) =
    encodeListLen 3 &lt;&gt; encodeWord 0 &lt;&gt; encode name &lt;&gt; encode height
encodeAnimal (SwimmingAnimal numberOfFins) =
    encodeListLen 2 &lt;&gt; encodeWord 2 &lt;&gt; encode numberOfFins
-- This is new...
encodeAnimal (WalkingAnimal animalName walkingSpeed numberOfFeet) =
    encodeListLen 4 &lt;&gt; encodeWord 3 &lt;&gt; encode animalName &lt;&gt; encode walkingSpeed &lt;&gt; encode numberOfFeet

decodeAnimal :: Decoder s Animal
decodeAnimal = do
    len &lt;- decodeListLen
    tag &lt;- decodeWord
    case (len, tag) of
      -- these cases are unchanged...
      (3, 0) -&gt; HoppingAnimal &lt;$&gt; decode &lt;*&gt; decode
      (2, 2) -&gt; SwimmingAnimal &lt;$&gt; decode
      -- this is new...
      (3, 1) -&gt; WalkingAnimal &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; pure 4
                                                     -- ^ note the default for backwards compat
      (4, 3) -&gt; WalkingAnimal &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode
      _      -&gt; fail &quot;invalid Animal encoding&quot;</pre><p>The same approach can be used to handle field removal and type changes.</p></div><a href="#g:8" id="g:8"><h1>Working with foreign encodings</h1></a><div class="doc"><p>While <code>serialise</code> &amp; <code>cborg</code> are primarily designed to be a Haskell-only values serialisation
library, the fact that it implements the standard CBOR encoding means that it also can
find uses in interacting with foreign CBOR producers &amp;
consumers. In this section we will describe a few features of the library
which may be useful in such applications.</p></div><a href="#g:9" id="g:9"><h2>Working with arbitrary terms</h2></a><div class="doc"><p>When working with foreign encodings, it can sometimes be useful to capture a
serialised CBOR term verbatim (for instance, to later re-serialise it in
some later result). The <code>Term</code> type provides such
representation, losslessly capturing a CBOR AST. It can be serialised and
deserialised with its <code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> instance.</p></div><a href="#g:10" id="g:10"><h2>Examining encodings</h2></a><div class="doc"><p>In addition to serialisation and deserialisation, <code>cborg</code>
provides a variety of tools for representing arbitrary CBOR encodings in the
<a href="Codec-CBOR-FlatTerm.html">Codec.CBOR.FlatTerm</a> and <a href="Codec-CBOR-Pretty.html">Codec.CBOR.Pretty</a> modules.</p><p>The <code>FlatTerm</code> type represents a single CBOR <em>term</em>, as
would be found in the ultimate CBOR representation. For instance, we can easily
look at the structure of our <code>Animal</code> encoding above,</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toFlatTerm $ encode $ HoppingAnimal &quot;Fred&quot; 42
</code></strong>[TkListLen 3,TkInt 0,TkString &quot;Fred&quot;,TkInt 42]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromFlatTerm (decode @Animal) $ toFlatTerm $ encode (HoppingAnimal &quot;Fred&quot; 42)
</code></strong>Right (HoppingAnimal {animalName = &quot;Fred&quot;, hoppingHeight = 42})
</pre><p>This can be useful both for understanding external CBOR formats, as well as
understanding and testing handwritten encodings.</p><p>The package also includes a pretty-printer in <a href="Codec-CBOR-Pretty.html">Codec.CBOR.Pretty</a>, for
visualising the CBOR wire protocol alongside its semantic structure. For instance,</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStrLn $ Codec.CBOR.Pretty.prettyHexEnc $ encode $ HoppingAnimal &quot;Fred&quot; 42
</code></strong>83  # list(3)
   00  # word(0)
   64 46 72 65 64  # text(&quot;Fred&quot;)
   18 2a  # int(42)
</pre></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>