-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A binary serialisation library for Haskell values.
--   
--   This package (formerly <tt>binary-serialise-cbor</tt>) provides pure,
--   efficient serialization of Haskell values directly into
--   <tt>ByteString</tt>s for storage or transmission purposes. By
--   providing a set of type class instances, you can also serialise any
--   custom data type you have as well.
--   
--   The underlying binary format used is the 'Concise Binary Object
--   Representation', or CBOR, specified in RFC 7049. As a result,
--   serialised Haskell values have implicit structure outside of the
--   Haskell program itself, meaning they can be inspected or analyzed
--   without custom tools.
--   
--   An implementation of the standard bijection between CBOR and JSON is
--   provided by the <a>cborg-json</a> package. Also see <a>cbor-tool</a>
--   for a convenient command-line utility for working with CBOR data.
@package serialise
@version 0.2.6.1


-- | High level API for decoding values that were encoded with the
--   <a>Codec.Serialise.Encoding</a> module, using a <tt><a>Monad</a></tt>
--   based interface.
module Codec.Serialise.Decoding
data () => Decoder s a
data () => DecodeAction s a
ConsumeWord :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord8 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord16 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord32 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeNegWord :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt8 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt16 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt32 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeListLen :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLen :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeTag :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInteger :: (Integer -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloat :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeDouble :: (Double# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytes :: (ByteString -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeByteArray :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeString :: (Text -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeUtf8ByteArray :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBool :: (Bool -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeSimple :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytesIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeStringIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeListLenIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeMapLenIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeNull :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeListLenOrIndef :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLenOrIndef :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBreakOr :: (Bool -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekTokenType :: (TokenType -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekAvailable :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekByteOffset :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWordCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord8Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord16Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord32Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeNegWordCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeIntCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt8Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt16Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt32Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeListLenCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLenCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeTagCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeIntegerCanonical :: (Integer -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloat16Canonical :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloatCanonical :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeDoubleCanonical :: (Double# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytesCanonical :: (ByteString -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeByteArrayCanonical :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeStringCanonical :: (Text -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeUtf8ByteArrayCanonical :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeSimpleCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
Fail :: String -> DecodeAction s a
Done :: a -> DecodeAction s a
getDecodeAction :: Decoder s a -> ST s (DecodeAction s a)
decodeWord :: Decoder s Word
decodeWord8 :: Decoder s Word8
decodeWord16 :: Decoder s Word16
decodeWord32 :: Decoder s Word32
decodeWord64 :: Decoder s Word64
decodeNegWord :: Decoder s Word
decodeNegWord64 :: Decoder s Word64
decodeInt :: Decoder s Int
decodeInt8 :: Decoder s Int8
decodeInt16 :: Decoder s Int16
decodeInt32 :: Decoder s Int32
decodeInt64 :: Decoder s Int64
decodeInteger :: Decoder s Integer
decodeFloat :: Decoder s Float
decodeDouble :: Decoder s Double
decodeBytes :: Decoder s ByteString
decodeBytesIndef :: Decoder s ()
decodeByteArray :: Decoder s ByteArray
decodeString :: Decoder s Text
decodeStringIndef :: Decoder s ()
decodeUtf8ByteArray :: Decoder s ByteArray
decodeListLen :: Decoder s Int
decodeListLenIndef :: Decoder s ()
decodeMapLen :: Decoder s Int
decodeMapLenIndef :: Decoder s ()
decodeTag :: Decoder s Word
decodeTag64 :: Decoder s Word64
decodeBool :: Decoder s Bool
decodeNull :: Decoder s ()
decodeSimple :: Decoder s Word8
decodeWordOf :: Word -> Decoder s ()
decodeListLenOf :: Int -> Decoder s ()
decodeListLenOrIndef :: Decoder s (Maybe Int)
decodeMapLenOrIndef :: Decoder s (Maybe Int)
decodeBreakOr :: Decoder s Bool
peekTokenType :: Decoder s TokenType
peekAvailable :: Decoder s Int
data () => TokenType
TypeUInt :: TokenType
TypeUInt64 :: TokenType
TypeNInt :: TokenType
TypeNInt64 :: TokenType
TypeInteger :: TokenType
TypeFloat16 :: TokenType
TypeFloat32 :: TokenType
TypeFloat64 :: TokenType
TypeBytes :: TokenType
TypeBytesIndef :: TokenType
TypeString :: TokenType
TypeStringIndef :: TokenType
TypeListLen :: TokenType
TypeListLen64 :: TokenType
TypeListLenIndef :: TokenType
TypeMapLen :: TokenType
TypeMapLen64 :: TokenType
TypeMapLenIndef :: TokenType
TypeTag :: TokenType
TypeTag64 :: TokenType
TypeBool :: TokenType
TypeNull :: TokenType
TypeSimple :: TokenType
TypeBreak :: TokenType
TypeInvalid :: TokenType
decodeSequenceLenIndef :: (r -> a -> r) -> r -> (r -> r') -> Decoder s a -> Decoder s r'
decodeSequenceLenN :: (r -> a -> r) -> r -> (r -> r') -> Int -> Decoder s a -> Decoder s r'


-- | High level API for encoding values, for later serialization into CBOR
--   binary format, using a <tt><a>Monoid</a></tt> based interface.
module Codec.Serialise.Encoding
newtype () => Encoding
Encoding :: (Tokens -> Tokens) -> Encoding
data () => Tokens
TkWord :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkWord64 :: {-# UNPACK #-} !Word64 -> Tokens -> Tokens
TkInt :: {-# UNPACK #-} !Int -> Tokens -> Tokens
TkInt64 :: {-# UNPACK #-} !Int64 -> Tokens -> Tokens
TkBytes :: {-# UNPACK #-} !ByteString -> Tokens -> Tokens
TkBytesBegin :: Tokens -> Tokens
TkByteArray :: {-# UNPACK #-} !SlicedByteArray -> Tokens -> Tokens
TkString :: {-# UNPACK #-} !Text -> Tokens -> Tokens
TkUtf8ByteArray :: {-# UNPACK #-} !SlicedByteArray -> Tokens -> Tokens
TkStringBegin :: Tokens -> Tokens
TkListLen :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkListBegin :: Tokens -> Tokens
TkMapLen :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkMapBegin :: Tokens -> Tokens
TkTag :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkTag64 :: {-# UNPACK #-} !Word64 -> Tokens -> Tokens
TkInteger :: !Integer -> Tokens -> Tokens
TkNull :: Tokens -> Tokens
TkUndef :: Tokens -> Tokens
TkBool :: !Bool -> Tokens -> Tokens
TkSimple :: {-# UNPACK #-} !Word8 -> Tokens -> Tokens
TkFloat16 :: {-# UNPACK #-} !Float -> Tokens -> Tokens
TkFloat32 :: {-# UNPACK #-} !Float -> Tokens -> Tokens
TkFloat64 :: {-# UNPACK #-} !Double -> Tokens -> Tokens
TkBreak :: Tokens -> Tokens
TkEncoded :: {-# UNPACK #-} !ByteString -> Tokens -> Tokens
TkEnd :: Tokens
encodeWord :: Word -> Encoding
encodeWord8 :: Word8 -> Encoding
encodeWord16 :: Word16 -> Encoding
encodeWord32 :: Word32 -> Encoding
encodeWord64 :: Word64 -> Encoding
encodeInt :: Int -> Encoding
encodeInt8 :: Int8 -> Encoding
encodeInt16 :: Int16 -> Encoding
encodeInt32 :: Int32 -> Encoding
encodeInt64 :: Int64 -> Encoding
encodeInteger :: Integer -> Encoding
encodeBytes :: ByteString -> Encoding
encodeBytesIndef :: Encoding
encodeByteArray :: SlicedByteArray -> Encoding
encodeString :: Text -> Encoding
encodeStringIndef :: Encoding
encodeUtf8ByteArray :: SlicedByteArray -> Encoding
encodeListLen :: Word -> Encoding
encodeListLenIndef :: Encoding
encodeMapLen :: Word -> Encoding
encodeMapLenIndef :: Encoding
encodeBreak :: Encoding
encodeTag :: Word -> Encoding
encodeTag64 :: Word64 -> Encoding
encodeBool :: Bool -> Encoding
encodeUndef :: Encoding
encodeNull :: Encoding
encodeSimple :: Word8 -> Encoding
encodeFloat16 :: Float -> Encoding
encodeFloat :: Float -> Encoding
encodeDouble :: Double -> Encoding

module Codec.Serialise.Internal.GeneralisedUTF8

-- | Encode a string as (generalized) UTF-8. In addition to the encoding,
--   we return a flag indicating whether the encoded string contained any
--   surrogate characters, in which case the output is generalized UTF-8.
encodeGenUTF8 :: String -> (SlicedByteArray, UTF8Encoding)
data UTF8Encoding
ConformantUTF8 :: UTF8Encoding
GeneralisedUTF8 :: UTF8Encoding
decodeGenUTF8 :: ByteArray -> String

-- | Is a <a>Char</a> a UTF-16 surrogate?
isSurrogate :: Char -> Bool

-- | Is the given byte sequence valid under the given encoding?
isValid :: UTF8Encoding -> [Word8] -> Bool
instance GHC.Classes.Eq Codec.Serialise.Internal.GeneralisedUTF8.UTF8Encoding
instance GHC.Show.Show Codec.Serialise.Internal.GeneralisedUTF8.UTF8Encoding


-- | The <tt><a>Serialise</a></tt> class allows you to encode a given type
--   into a CBOR object, or decode a CBOR object into the user-specified
--   type.
module Codec.Serialise.Class

-- | Types that are instances of the <tt><a>Serialise</a></tt> class allow
--   values to be quickly encoded or decoded directly to a CBOR
--   representation, for object transmission or storage.
class Serialise a

-- | Definition for encoding a given type into a binary representation,
--   using the <tt><a>Encoding</a></tt> <tt><a>Monoid</a></tt>.
encode :: Serialise a => a -> Encoding

-- | Definition for encoding a given type into a binary representation,
--   using the <tt><a>Encoding</a></tt> <tt><a>Monoid</a></tt>.
encode :: (Serialise a, Generic a, GSerialiseEncode (Rep a)) => a -> Encoding

-- | Definition of a given <tt><a>Decoder</a></tt> for a type.
decode :: Serialise a => Decoder s a

-- | Definition of a given <tt><a>Decoder</a></tt> for a type.
decode :: (Serialise a, Generic a, GSerialiseDecode (Rep a)) => Decoder s a

-- | Utility to support specialised encoding for some list type - used for
--   <tt><a>Char</a></tt>/<tt><a>String</a></tt> instances in this package.
encodeList :: Serialise a => [a] -> Encoding

-- | Utility to support specialised decoding for some list type - used for
--   <tt><a>Char</a></tt>/<tt><a>String</a></tt> instances in this package.
decodeList :: Serialise a => Decoder s [a]

class GSerialiseEncode f

gencode :: GSerialiseEncode f => f a -> Encoding

class GSerialiseDecode f

gdecode :: GSerialiseDecode f => Decoder s (f a)

-- | Serialization of product types
class GSerialiseProd f

-- | Number of fields in product type
nFields :: GSerialiseProd f => Proxy f -> Word

-- | Encode fields sequentially without writing header
encodeSeq :: GSerialiseProd f => f a -> Encoding

-- | Decode fields sequentially without reading header
gdecodeSeq :: GSerialiseProd f => Decoder s (f a)

-- | Serialization of sum types
class GSerialiseSum f

-- | Number of constructor of given value
conNumber :: GSerialiseSum f => f a -> Word

-- | Number of fields of given value
numOfFields :: GSerialiseSum f => f a -> Word

-- | Encode field
encodeSum :: GSerialiseSum f => f a -> Encoding

-- | Decode field
decodeSum :: GSerialiseSum f => Word -> Decoder s (f a)

-- | Number of constructors
nConstructors :: GSerialiseSum f => Proxy f -> Word

-- | Number of fields for given constructor number
fieldsForCon :: GSerialiseSum f => Proxy f -> Word -> Decoder s Word

-- | Generic encoder for vectors. Its intended use is to allow easy
--   definition of <a>Serialise</a> instances for custom vector
encodeVector :: (Serialise a, Vector v a) => v a -> Encoding

-- | Generic decoder for vectors. Its intended use is to allow easy
--   definition of <a>Serialise</a> instances for custom vector
decodeVector :: (Serialise a, Vector v a) => Decoder s (v a)

-- | Patch functions together to obtain an <a>Encoding</a> for a container.
encodeContainerSkel :: (Word -> Encoding) -> (container -> Int) -> (accumFunc -> Encoding -> container -> Encoding) -> accumFunc -> container -> Encoding

-- | A helper function for encoding maps.
encodeMapSkel :: (Serialise k, Serialise v) => (m -> Int) -> ((k -> v -> Encoding -> Encoding) -> Encoding -> m -> Encoding) -> m -> Encoding

-- | A utility function to construct a <a>Decoder</a> for maps.
decodeMapSkel :: (Serialise k, Serialise v) => ([(k, v)] -> m) -> Decoder s m
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseSum f, Codec.Serialise.Class.GSerialiseSum g) => Codec.Serialise.Class.GSerialiseEncode (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseSum f, Codec.Serialise.Class.GSerialiseSum g) => Codec.Serialise.Class.GSerialiseDecode (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseSum f, Codec.Serialise.Class.GSerialiseSum g) => Codec.Serialise.Class.GSerialiseSum (f GHC.Generics.:+: g)
instance forall k i (f :: k -> *) (c :: GHC.Generics.Meta). (i GHC.Types.~ GHC.Generics.C, Codec.Serialise.Class.GSerialiseProd f) => Codec.Serialise.Class.GSerialiseSum (GHC.Generics.M1 i c f)
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseProd f, Codec.Serialise.Class.GSerialiseProd g) => Codec.Serialise.Class.GSerialiseEncode (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseProd f, Codec.Serialise.Class.GSerialiseProd g) => Codec.Serialise.Class.GSerialiseDecode (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). (Codec.Serialise.Class.GSerialiseProd f, Codec.Serialise.Class.GSerialiseProd g) => Codec.Serialise.Class.GSerialiseProd (f GHC.Generics.:*: g)
instance Codec.Serialise.Class.GSerialiseProd GHC.Generics.U1
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.GSerialiseProd (GHC.Generics.K1 i a)
instance forall k i (f :: k -> *) (c :: GHC.Generics.Meta). (i GHC.Types.~ GHC.Generics.S, Codec.Serialise.Class.GSerialiseProd f) => Codec.Serialise.Class.GSerialiseProd (GHC.Generics.M1 i c f)
instance Codec.Serialise.Class.Serialise Codec.CBOR.Term.Term
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise [a]
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (GHC.Base.NonEmpty a)
instance Codec.Serialise.Class.Serialise GHC.Base.Void
instance Codec.Serialise.Class.Serialise ()
instance Codec.Serialise.Class.Serialise GHC.Types.Bool
instance Codec.Serialise.Class.Serialise GHC.Types.Int
instance Codec.Serialise.Class.Serialise GHC.Int.Int8
instance Codec.Serialise.Class.Serialise GHC.Int.Int16
instance Codec.Serialise.Class.Serialise GHC.Int.Int32
instance Codec.Serialise.Class.Serialise GHC.Int.Int64
instance Codec.Serialise.Class.Serialise GHC.Types.Word
instance Codec.Serialise.Class.Serialise GHC.Word.Word8
instance Codec.Serialise.Class.Serialise GHC.Word.Word16
instance Codec.Serialise.Class.Serialise GHC.Word.Word32
instance Codec.Serialise.Class.Serialise GHC.Word.Word64
instance Codec.Serialise.Class.Serialise GHC.Num.Integer.Integer
instance Codec.Serialise.Class.Serialise GHC.Num.Natural.Natural
instance Codec.Serialise.Class.Serialise GHC.Types.Float
instance Codec.Serialise.Class.Serialise GHC.Types.Double
instance Codec.Serialise.Class.Serialise Numeric.Half.Internal.Half
instance forall k (e :: k). Codec.Serialise.Class.Serialise (Data.Fixed.Fixed e)
instance forall k (a :: k). Codec.Serialise.Class.Serialise (Data.Proxy.Proxy a)
instance Codec.Serialise.Class.Serialise GHC.Types.Char
instance Codec.Serialise.Class.Serialise Data.Text.Internal.Text
instance Codec.Serialise.Class.Serialise Data.ByteString.Internal.Type.ByteString
instance Codec.Serialise.Class.Serialise Data.ByteString.Short.Internal.ShortByteString
instance Codec.Serialise.Class.Serialise Data.Text.Internal.Lazy.Text
instance Codec.Serialise.Class.Serialise Data.ByteString.Lazy.Internal.ByteString
instance forall k a (b :: k). Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Functor.Const.Const a b)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Control.Applicative.ZipList a)
instance (Codec.Serialise.Class.Serialise a, GHC.Real.Integral a) => Codec.Serialise.Class.Serialise (GHC.Real.Ratio a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Complex.Complex a)
instance Codec.Serialise.Class.Serialise GHC.Types.Ordering
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Ord.Down a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Internal.Dual a)
instance Codec.Serialise.Class.Serialise Data.Semigroup.Internal.All
instance Codec.Serialise.Class.Serialise Data.Semigroup.Internal.Any
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Internal.Sum a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Internal.Product a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Monoid.First a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Monoid.Last a)
instance forall k (f :: k -> *) (a :: k). Codec.Serialise.Class.Serialise (f a) => Codec.Serialise.Class.Serialise (Data.Semigroup.Internal.Alt f a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Functor.Identity.Identity a)
instance Codec.Serialise.Class.Serialise GHC.IO.Exception.ExitCode
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Min a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Max a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.First a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.Last a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Semigroup.WrappedMonoid a)
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CChar
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CSChar
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUChar
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CShort
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUShort
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CInt
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUInt
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CLong
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CULong
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CPtrdiff
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CSize
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CWchar
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CSigAtomic
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CLLong
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CULLong
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CIntPtr
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUIntPtr
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CIntMax
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUIntMax
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CClock
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CTime
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CUSeconds
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CSUSeconds
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CFloat
instance Codec.Serialise.Class.Serialise Foreign.C.Types.CDouble
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (a, b)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c) => Codec.Serialise.Class.Serialise (a, b, c)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d) => Codec.Serialise.Class.Serialise (a, b, c, d)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d, Codec.Serialise.Class.Serialise e) => Codec.Serialise.Class.Serialise (a, b, c, d, e)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d, Codec.Serialise.Class.Serialise e, Codec.Serialise.Class.Serialise f) => Codec.Serialise.Class.Serialise (a, b, c, d, e, f)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d, Codec.Serialise.Class.Serialise e, Codec.Serialise.Class.Serialise f, Codec.Serialise.Class.Serialise g) => Codec.Serialise.Class.Serialise (a, b, c, d, e, f, g)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d, Codec.Serialise.Class.Serialise e, Codec.Serialise.Class.Serialise f, Codec.Serialise.Class.Serialise g, Codec.Serialise.Class.Serialise h) => Codec.Serialise.Class.Serialise (a, b, c, d, e, f, g, h)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b, Codec.Serialise.Class.Serialise c, Codec.Serialise.Class.Serialise d, Codec.Serialise.Class.Serialise e, Codec.Serialise.Class.Serialise f, Codec.Serialise.Class.Serialise g, Codec.Serialise.Class.Serialise h, Codec.Serialise.Class.Serialise i) => Codec.Serialise.Class.Serialise (a, b, c, d, e, f, g, h, i)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (GHC.Maybe.Maybe a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (Data.Either.Either a b)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (Data.These.These a b)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (Data.Strict.Tuple.Pair a b)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Strict.Maybe.Maybe a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (Data.Strict.Either.Either a b)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise b) => Codec.Serialise.Class.Serialise (Data.Strict.These.These a b)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Tree.Tree a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Sequence.Internal.Seq a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Vector.Vector a)
instance (Codec.Serialise.Class.Serialise a, Data.Vector.Unboxed.Base.Unbox a) => Codec.Serialise.Class.Serialise (Data.Vector.Unboxed.Base.Vector a)
instance (Codec.Serialise.Class.Serialise a, Foreign.Storable.Storable a) => Codec.Serialise.Class.Serialise (Data.Vector.Storable.Vector a)
instance (Codec.Serialise.Class.Serialise a, Data.Primitive.Types.Prim a) => Codec.Serialise.Class.Serialise (Data.Vector.Primitive.Vector a)
instance (GHC.Classes.Ord a, Codec.Serialise.Class.Serialise a) => Codec.Serialise.Class.Serialise (Data.Set.Internal.Set a)
instance Codec.Serialise.Class.Serialise Data.IntSet.Internal.IntSet
instance (Codec.Serialise.Class.Serialise a, Data.Hashable.Class.Hashable a, GHC.Classes.Eq a) => Codec.Serialise.Class.Serialise (Data.HashSet.Internal.HashSet a)
instance (GHC.Classes.Ord k, Codec.Serialise.Class.Serialise k, Codec.Serialise.Class.Serialise v) => Codec.Serialise.Class.Serialise (Data.Map.Internal.Map k v)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.IntMap.Internal.IntMap a)
instance (Codec.Serialise.Class.Serialise k, Data.Hashable.Class.Hashable k, GHC.Classes.Eq k, Codec.Serialise.Class.Serialise v) => Codec.Serialise.Class.Serialise (Data.HashMap.Internal.HashMap k v)
instance Codec.Serialise.Class.Serialise Data.Version.Version
instance Codec.Serialise.Class.Serialise GHC.Fingerprint.Type.Fingerprint
instance Codec.Serialise.Class.Serialise GHC.Types.TyCon
instance Codec.Serialise.Class.Serialise GHC.Types.VecCount
instance Codec.Serialise.Class.Serialise GHC.Types.VecElem
instance Codec.Serialise.Class.Serialise GHC.Types.Levity
instance Codec.Serialise.Class.Serialise GHC.Types.RuntimeRep
instance Codec.Serialise.Class.Serialise GHC.Types.KindRep
instance Codec.Serialise.Class.Serialise GHC.Types.TypeLitSort
instance forall k (a :: k). Data.Typeable.Internal.Typeable a => Codec.Serialise.Class.Serialise (Data.Typeable.Internal.TypeRep a)
instance Codec.Serialise.Class.Serialise Data.Typeable.Internal.SomeTypeRep
instance Codec.Serialise.Class.Serialise Data.Time.Clock.Internal.UTCTime.UTCTime
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.GSerialiseEncode (GHC.Generics.K1 i a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.GSerialiseDecode (GHC.Generics.K1 i a)
instance Codec.Serialise.Class.GSerialiseDecode GHC.Generics.V1
instance Codec.Serialise.Class.GSerialiseDecode GHC.Generics.U1
instance forall k (a :: k -> *) i (c :: GHC.Generics.Meta). Codec.Serialise.Class.GSerialiseDecode a => Codec.Serialise.Class.GSerialiseDecode (GHC.Generics.M1 i c a)
instance Codec.Serialise.Class.GSerialiseEncode GHC.Generics.V1
instance Codec.Serialise.Class.GSerialiseEncode GHC.Generics.U1
instance forall k (a :: k -> *) i (c :: GHC.Generics.Meta). Codec.Serialise.Class.GSerialiseEncode a => Codec.Serialise.Class.GSerialiseEncode (GHC.Generics.M1 i c a)


-- | This module provides functions to serialise and deserialise Haskell
--   values for storage or transmission, to and from lazy
--   <tt><a>ByteString</a></tt>s. It also provides a type class and
--   utilities to help you make your types serialisable.
--   
--   For a full tutorial on using this module, see
--   <a>Codec.Serialise.Tutorial</a>.
module Codec.Serialise

-- | Serialise a Haskell value to an external binary representation.
--   
--   The output is represented as a lazy <a>ByteString</a> and is
--   constructed incrementally.
serialise :: Serialise a => a -> ByteString

-- | Deserialise a Haskell value from the external binary representation
--   (which must have been made using <a>serialise</a> or related
--   function).
--   
--   <i>Throws</i>: <tt><a>DeserialiseFailure</a></tt> if the given
--   external representation is invalid or does not correspond to a value
--   of the expected type.
deserialise :: Serialise a => ByteString -> a

-- | Deserialise a Haskell value from the external binary representation,
--   or get back a <tt><tt>DeserialiseFailure</tt></tt>.
deserialiseOrFail :: Serialise a => ByteString -> Either DeserialiseFailure a
data () => DeserialiseFailure
DeserialiseFailure :: ByteOffset -> String -> DeserialiseFailure

-- | Serialise a Haskell value to an external binary representation.
--   
--   The output is represented as a <a>Builder</a> and is constructed
--   incrementally. The representation as a <a>Builder</a> allows efficient
--   concatenation with other data.
serialiseIncremental :: Serialise a => a -> Builder

-- | Deserialise a Haskell value from the external binary representation.
--   
--   This allows <i>input</i> data to be provided incrementally, rather
--   than all in one go. It also gives an explicit representation of
--   deserialisation errors.
--   
--   Note that the incremental behaviour is only for the input data, not
--   the output value: the final deserialised value is constructed and
--   returned as a whole, not incrementally.
deserialiseIncremental :: Serialise a => ST s (IDecode s a)
data () => IDecode s a
Partial :: (Maybe ByteString -> ST s (IDecode s a)) -> IDecode s a
Done :: !ByteString -> {-# UNPACK #-} !ByteOffset -> a -> IDecode s a
Fail :: !ByteString -> {-# UNPACK #-} !ByteOffset -> DeserialiseFailure -> IDecode s a

-- | Types that are instances of the <tt><a>Serialise</a></tt> class allow
--   values to be quickly encoded or decoded directly to a CBOR
--   representation, for object transmission or storage.
class Serialise a

-- | Definition for encoding a given type into a binary representation,
--   using the <tt><a>Encoding</a></tt> <tt><a>Monoid</a></tt>.
encode :: Serialise a => a -> Encoding

-- | Definition for encoding a given type into a binary representation,
--   using the <tt><a>Encoding</a></tt> <tt><a>Monoid</a></tt>.
encode :: (Serialise a, Generic a, GSerialiseEncode (Rep a)) => a -> Encoding

-- | Definition of a given <tt><a>Decoder</a></tt> for a type.
decode :: Serialise a => Decoder s a

-- | Definition of a given <tt><a>Decoder</a></tt> for a type.
decode :: (Serialise a, Generic a, GSerialiseDecode (Rep a)) => Decoder s a

-- | Utility to support specialised encoding for some list type - used for
--   <tt><a>Char</a></tt>/<tt><a>String</a></tt> instances in this package.
encodeList :: Serialise a => [a] -> Encoding

-- | Utility to support specialised decoding for some list type - used for
--   <tt><a>Char</a></tt>/<tt><a>String</a></tt> instances in this package.
decodeList :: Serialise a => Decoder s [a]

-- | Serialise a <tt><a>ByteString</a></tt> and write it directly to the
--   specified file.
writeFileSerialise :: Serialise a => FilePath -> a -> IO ()

-- | Read the specified file (internally, by reading a
--   <tt><a>ByteString</a></tt>) and attempt to decode it into a Haskell
--   value using <tt><a>deserialise</a></tt> (the type of which is
--   determined by the choice of the result type).
--   
--   <i>Throws</i>: <tt><a>DeserialiseFailure</a></tt> if the file fails to
--   deserialise properly.
readFileDeserialise :: Serialise a => FilePath -> IO a

-- | Serialise a <tt><a>ByteString</a></tt> (via <tt><a>serialise</a></tt>)
--   and write it directly to the specified <tt><a>Handle</a></tt>.
hPutSerialise :: Serialise a => Handle -> a -> IO ()


-- | High-level file-based API for serialising and deserialising values.
module Codec.Serialise.IO

-- | Serialise a <tt><a>ByteString</a></tt> and write it directly to the
--   specified file.
writeFileSerialise :: Serialise a => FilePath -> a -> IO ()

-- | Read the specified file (internally, by reading a
--   <tt><a>ByteString</a></tt>) and attempt to decode it into a Haskell
--   value using <tt><a>deserialise</a></tt> (the type of which is
--   determined by the choice of the result type).
--   
--   <i>Throws</i>: <tt><a>DeserialiseFailure</a></tt> if the file fails to
--   deserialise properly.
readFileDeserialise :: Serialise a => FilePath -> IO a

-- | Serialise a <tt><a>ByteString</a></tt> (via <tt><a>serialise</a></tt>)
--   and write it directly to the specified <tt><a>Handle</a></tt>.
hPutSerialise :: Serialise a => Handle -> a -> IO ()


-- | This module contains a set of generally useful properties, which
--   instance authors are encouraged to use in order to test their
--   instances of the <tt><a>Serialise</a></tt> class. For example, if you
--   have a data type which you might derive or write instances for:
--   
--   <pre>
--   data Foo = Foo { fooInt :: Int, fooBool :: Bool }
--     deriving (Eq, Show, <a>Generic</a>)
--   -- or, alternatively
--   instance <a>Serialise</a> Foo where
--     <a>encode</a> = ...
--     <a>decode</a> = ...
--   </pre>
--   
--   Then you can use this module to easily derive some quick properties:
--   
--   <pre>
--   import qualified <a>Codec.Serialise.Properties</a> as Props
--   
--   fooSerialiseId :: Foo -&gt; Bool
--   fooSerialiseId = Props.<a>serialiseIdentity</a>
--   
--   fooFlatTermId :: Foo -&gt; Bool
--   fooFlatTermId = Props.<a>flatTermIdentity</a>
--   
--   fooHasValidFlatTerm :: Foo -&gt; Bool
--   fooHasValidFlatTerm = Props.<a>hasValidFlatTerm</a>
--   </pre>
--   
--   You can then conveniently use these three functions with QuickCheck,
--   for example.
module Codec.Serialise.Properties

-- | Ensure that serializing and deserializing some value results in the
--   original value being returned.
serialiseIdentity :: (Serialise a, Eq a) => a -> Bool

-- | Ensure that serializing and deserializing a value with the
--   <tt><a>FlatTerm</a></tt> form results in the original value being
--   returned.
flatTermIdentity :: (Serialise a, Eq a) => a -> Bool

-- | Ensure that serializing a value into a <tt><a>FlatTerm</a></tt> gives
--   us a valid <tt><a>FlatTerm</a></tt> back.
hasValidFlatTerm :: Serialise a => a -> Bool


-- | <tt>serialise</tt> library is built on <tt>cborg</tt>, they implement
--   CBOR (Concise Binary Object Representation, specified by <a>IETF RFC
--   7049</a>) and serialisers/deserializers for it.
module Codec.Serialise.Tutorial
