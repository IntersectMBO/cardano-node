<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Lens.Micro.Type</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">microlens-0.4.13.1: A tiny lens library with no dependencies</span><ul class="links" id="page-menu"><li><a href="src/Lens.Micro.Type.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(C) 2013-2016 Edward Kmett 2015-2016 Artyom Kazak 2018 Monadfix</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Lens.Micro.Type</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides just the types (<code><a href="Lens-Micro-Type.html#t:Lens" title="Lens.Micro.Type">Lens</a></code>, <code><a href="Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code>, etc). It's needed to break the dependency cycle &#8211; <a href="Lens-Micro.html">Lens.Micro</a> depends on <a href="Lens-Micro-Internal.html">Lens.Micro.Internal</a>, but <a href="Lens-Micro-Internal.html">Lens.Micro.Internal</a> needs types like <code><a href="Lens-Micro-Type.html#t:Lens" title="Lens.Micro.Type">Lens</a></code>, so <code><a href="Lens-Micro-Type.html#t:Lens" title="Lens.Micro.Type">Lens</a></code> can't be defined in <a href="Lens-Micro.html">Lens.Micro</a>.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">type</span> <a href="#t:ASetter">ASetter</a> s t a b = (a -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> b) -&gt; s -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> t</li><li class="src short"><span class="keyword">type</span> <a href="#t:ASetter-39-">ASetter'</a> s a = <a href="Lens-Micro-Type.html#t:ASetter" title="Lens.Micro.Type">ASetter</a> s s a a</li><li class="src short"><span class="keyword">type</span> <a href="#t:SimpleGetter">SimpleGetter</a> s a = <span class="keyword">forall</span> r. <a href="Lens-Micro-Type.html#t:Getting" title="Lens.Micro.Type">Getting</a> r s a</li><li class="src short"><span class="keyword">type</span> <a href="#t:Getting">Getting</a> r s a = (a -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Const.html#t:Const" title="Data.Functor.Const">Const</a> r a) -&gt; s -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Const.html#t:Const" title="Data.Functor.Const">Const</a> r s</li><li class="src short"><span class="keyword">type</span> <a href="#t:SimpleFold">SimpleFold</a> s a = <span class="keyword">forall</span> r. <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> r =&gt; <a href="Lens-Micro-Type.html#t:Getting" title="Lens.Micro.Type">Getting</a> r s a</li><li class="src short"><span class="keyword">type</span> <a href="#t:Lens">Lens</a> s t a b = <span class="keyword">forall</span> f. <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t</li><li class="src short"><span class="keyword">type</span> <a href="#t:Lens-39-">Lens'</a> s a = <a href="Lens-Micro-Type.html#t:Lens" title="Lens.Micro.Type">Lens</a> s s a a</li><li class="src short"><span class="keyword">type</span> <a href="#t:Traversal">Traversal</a> s t a b = <span class="keyword">forall</span> f. <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t</li><li class="src short"><span class="keyword">type</span> <a href="#t:Traversal-39-">Traversal'</a> s a = <a href="Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s s a a</li><li class="src short"><span class="keyword">type</span> <a href="#t:LensLike">LensLike</a> f s t a b = (a -&gt; f b) -&gt; s -&gt; f t</li><li class="src short"><span class="keyword">type</span> <a href="#t:LensLike-39-">LensLike'</a> f s a = <a href="Lens-Micro-Type.html#t:LensLike" title="Lens.Micro.Type">LensLike</a> f s s a a</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:ASetter" class="def">ASetter</a> s t a b = (a -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> b) -&gt; s -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> t <a href="src/Lens.Micro.Type.html#ASetter" class="link">Source</a> <a href="#t:ASetter" class="selflink">#</a></p><div class="doc"><p><code>ASetter s t a b</code> is something that turns a function modifying a value into a function modifying a <em>structure</em>. If you ignore <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a></code> (as <code>Identity a</code> is the same thing as <code>a</code>), the type is:</p><pre>type ASetter s t a b = (a -&gt; b) -&gt; s -&gt; t
</pre><p>The reason <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a></code> is used here is for <code><a href="Lens-Micro-Type.html#t:ASetter" title="Lens.Micro.Type">ASetter</a></code> to be composable with other types, such as <code><a href="Lens-Micro-Type.html#t:Lens" title="Lens.Micro.Type">Lens</a></code>.</p><p>Technically, if you're writing a library, you shouldn't use this type for setters you are exporting from your library; the right type to use is <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setter">Setter</a></code>, but it is not provided by this package (because then it'd have to depend on <a href="http://hackage.haskell.org/package/distributive">distributive</a>). It's completely alright, however, to export functions which take an <code><a href="Lens-Micro-Type.html#t:ASetter" title="Lens.Micro.Type">ASetter</a></code> as an argument.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:ASetter-39-" class="def">ASetter'</a> s a = <a href="Lens-Micro-Type.html#t:ASetter" title="Lens.Micro.Type">ASetter</a> s s a a <a href="src/Lens.Micro.Type.html#ASetter%27" class="link">Source</a> <a href="#t:ASetter-39-" class="selflink">#</a></p><div class="doc"><p>This is a type alias for monomorphic setters which don't change the type of the container (or of the value inside). It's useful more often than the same type in lens, because we can't provide real setters and so it does the job of both <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:ASetter-39-">ASetter'</a></code> and <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setter-39-">Setter'</a></code>.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:SimpleGetter" class="def">SimpleGetter</a> s a = <span class="keyword">forall</span> r. <a href="Lens-Micro-Type.html#t:Getting" title="Lens.Micro.Type">Getting</a> r s a <a href="src/Lens.Micro.Type.html#SimpleGetter" class="link">Source</a> <a href="#t:SimpleGetter" class="selflink">#</a></p><div class="doc"><p>A <code>SimpleGetter s a</code> extracts <code>a</code> from <code>s</code>; so, it's the same thing as <code>(s -&gt; a)</code>, but you can use it in lens chains because its type looks like this:</p><pre>type SimpleGetter s a =
  forall r. (a -&gt; Const r a) -&gt; s -&gt; Const r s
</pre><p>Since <code>Const r</code> is a functor, <code><a href="Lens-Micro-Type.html#t:SimpleGetter" title="Lens.Micro.Type">SimpleGetter</a></code> has the same shape as other lens types and can be composed with them. To get <code>(s -&gt; a)</code> out of a <code><a href="Lens-Micro-Type.html#t:SimpleGetter" title="Lens.Micro.Type">SimpleGetter</a></code>, choose <code>r ~ a</code> and feed <code>Const :: a -&gt; Const a a</code> to the getter:</p><pre>-- the actual signature is more permissive:
-- <code><a href="Lens-Micro-Extras.html#v:view" title="Lens.Micro.Extras">view</a></code> :: <code><a href="Lens-Micro-Type.html#t:Getting" title="Lens.Micro.Type">Getting</a></code> a s a -&gt; s -&gt; a
<code><a href="Lens-Micro-Extras.html#v:view" title="Lens.Micro.Extras">view</a></code> :: <code><a href="Lens-Micro-Type.html#t:SimpleGetter" title="Lens.Micro.Type">SimpleGetter</a></code> s a -&gt; s -&gt; a
<code><a href="Lens-Micro-Extras.html#v:view" title="Lens.Micro.Extras">view</a></code> getter = <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Const.html#v:getConst" title="Data.Functor.Const">getConst</a></code> . getter <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Const.html#t:Const" title="Data.Functor.Const">Const</a></code>
</pre><p>The actual <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:Getter">Getter</a></code> from lens is more general:</p><pre>type Getter s a =
  forall f. (Contravariant f, Functor f) =&gt; (a -&gt; f a) -&gt; s -&gt; f s
</pre><p>I'm not currently aware of any functions that take lens's <code>Getter</code> but won't accept <code><a href="Lens-Micro-Type.html#t:SimpleGetter" title="Lens.Micro.Type">SimpleGetter</a></code>, but you should try to avoid exporting <code><a href="Lens-Micro-Type.html#t:SimpleGetter" title="Lens.Micro.Type">SimpleGetter</a></code>s anyway to minimise confusion. Alternatively, look at <a href="http://hackage.haskell.org/package/microlens-contra">microlens-contra</a>, which provides a fully lens-compatible <code>Getter</code>.</p><p>Lens users: you can convert a <code><a href="Lens-Micro-Type.html#t:SimpleGetter" title="Lens.Micro.Type">SimpleGetter</a></code> to <code>Getter</code> by applying <code>to . view</code> to it.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Getting" class="def">Getting</a> r s a = (a -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Const.html#t:Const" title="Data.Functor.Const">Const</a> r a) -&gt; s -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Const.html#t:Const" title="Data.Functor.Const">Const</a> r s <a href="src/Lens.Micro.Type.html#Getting" class="link">Source</a> <a href="#t:Getting" class="selflink">#</a></p><div class="doc"><p>Functions that operate on getters and folds &#8211; such as (<code><a href="Lens-Micro.html#v:-94-." title="Lens.Micro">^.</a></code>), (<code><a href="Lens-Micro.html#v:-94-.." title="Lens.Micro">^..</a></code>), (<code><a href="Lens-Micro.html#v:-94--63-" title="Lens.Micro">^?</a></code>) &#8211; use <code>Getter r s a</code> (with different values of <code>r</code>) to describe what kind of result they need. For instance, (<code><a href="Lens-Micro.html#v:-94-." title="Lens.Micro">^.</a></code>) needs the getter to be able to return a single value, and so it accepts a getter of type <code>Getting a s a</code>. (<code><a href="Lens-Micro.html#v:-94-.." title="Lens.Micro">^..</a></code>) wants the getter to gather values together, so it uses <code>Getting (Endo [a]) s a</code> (it could've used <code>Getting [a] s a</code> instead, but it's faster with <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Monoid.html#v:Endo" title="Data.Monoid">Endo</a></code>). The choice of <code>r</code> depends on what you want to do with elements you're extracting from <code>s</code>.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:SimpleFold" class="def">SimpleFold</a> s a = <span class="keyword">forall</span> r. <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> r =&gt; <a href="Lens-Micro-Type.html#t:Getting" title="Lens.Micro.Type">Getting</a> r s a <a href="src/Lens.Micro.Type.html#SimpleFold" class="link">Source</a> <a href="#t:SimpleFold" class="selflink">#</a></p><div class="doc"><p>A <code>SimpleFold s a</code> extracts several <code>a</code>s from <code>s</code>; so, it's pretty much the same thing as <code>(s -&gt; [a])</code>, but you can use it with lens operators.</p><p>The actual <code>Fold</code> from lens is more general:</p><pre>type Fold s a =
  forall f. (Contravariant f, Applicative f) =&gt; (a -&gt; f a) -&gt; s -&gt; f s
</pre><p>There are several functions in lens that accept lens's <code>Fold</code> but won't accept <code><a href="Lens-Micro-Type.html#t:SimpleFold" title="Lens.Micro.Type">SimpleFold</a></code>; I'm aware of
<code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:takingWhile">takingWhile</a></code>,
<code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:droppingWhile">droppingWhile</a></code>,
<code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:backwards">backwards</a></code>,
<code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldByOf">foldByOf</a></code>,
<code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldMapByOf">foldMapByOf</a></code>.
For this reason, try not to export <code><a href="Lens-Micro-Type.html#t:SimpleFold" title="Lens.Micro.Type">SimpleFold</a></code>s if at all possible. <a href="http://hackage.haskell.org/package/microlens-contra">microlens-contra</a> provides a fully lens-compatible <code>Fold</code>.</p><p>Lens users: you can convert a <code><a href="Lens-Micro-Type.html#t:SimpleFold" title="Lens.Micro.Type">SimpleFold</a></code> to <code>Fold</code> by applying <code>folded . toListOf</code> to it.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Lens" class="def">Lens</a> s t a b = <span class="keyword">forall</span> f. <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t <a href="src/Lens.Micro.Type.html#Lens" class="link">Source</a> <a href="#t:Lens" class="selflink">#</a></p><div class="doc"><p><code>Lens s t a b</code> is the lowest common denominator of a setter and a getter, something that has the power of both; it has a <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a></code> constraint, and since both <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Const.html#t:Const" title="Data.Functor.Const">Const</a></code> and <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a></code> are functors, it can be used whenever a getter or a setter is needed.</p><ul><li><code>a</code> is the type of the value inside of structure</li><li><code>b</code> is the type of the replaced value</li><li><code>s</code> is the type of the whole structure</li><li><code>t</code> is the type of the structure after replacing <code>a</code> in it with <code>b</code></li></ul></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Lens-39-" class="def">Lens'</a> s a = <a href="Lens-Micro-Type.html#t:Lens" title="Lens.Micro.Type">Lens</a> s s a a <a href="src/Lens.Micro.Type.html#Lens%27" class="link">Source</a> <a href="#t:Lens-39-" class="selflink">#</a></p><div class="doc"><p>This is a type alias for monomorphic lenses which don't change the type of the container (or of the value inside).</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Traversal" class="def">Traversal</a> s t a b = <span class="keyword">forall</span> f. <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t <a href="src/Lens.Micro.Type.html#Traversal" class="link">Source</a> <a href="#t:Traversal" class="selflink">#</a></p><div class="doc"><p><code>Traversal s t a b</code> is a generalisation of <code><a href="Lens-Micro-Type.html#t:Lens" title="Lens.Micro.Type">Lens</a></code> which allows many targets (possibly 0). It's achieved by changing the constraint to <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> instead of <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a></code> &#8211; indeed, the point of <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> is that you can combine effects, which is just what we need to have many targets.</p><p>Ultimately, traversals should follow 2 laws:</p><pre>t pure &#8801; pure
fmap (t f) . t g &#8801; getCompose . t (Compose . fmap f . g)
</pre><p>The 1st law states that you can't change the shape of the structure or do anything funny with elements (traverse elements which aren't in the structure, create new elements out of thin air, etc.). The 2nd law states that you should be able to fuse 2 identical traversals into one. For a more detailed explanation of the laws, see <a href="http://artyom.me/lens-over-tea-2#traversal-laws">this blog post</a> (if you prefer rambling blog posts), or <a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf">The Essence Of The Iterator Pattern</a> (if you prefer papers).</p><p>Traversing any value twice is a violation of traversal laws. You can, however, traverse values in any order.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Traversal-39-" class="def">Traversal'</a> s a = <a href="Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s s a a <a href="src/Lens.Micro.Type.html#Traversal%27" class="link">Source</a> <a href="#t:Traversal-39-" class="selflink">#</a></p><div class="doc"><p>This is a type alias for monomorphic traversals which don't change the type of the container (or of the values inside).</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:LensLike" class="def">LensLike</a> f s t a b = (a -&gt; f b) -&gt; s -&gt; f t <a href="src/Lens.Micro.Type.html#LensLike" class="link">Source</a> <a href="#t:LensLike" class="selflink">#</a></p><div class="doc"><p><code><a href="Lens-Micro-Type.html#t:LensLike" title="Lens.Micro.Type">LensLike</a></code> is a type that is often used to make combinators as general as possible. For instance, take (<code><a href="Lens-Micro.html#v:-60--60--37--126-" title="Lens.Micro">&lt;&lt;%~</a></code>), which only requires the passed lens to be able to work with the <code>(,) a</code> functor (lenses and traversals can do that). The fully expanded type is as follows:</p><pre>(<code><a href="Lens-Micro.html#v:-60--60--37--126-" title="Lens.Micro">&lt;&lt;%~</a></code>) :: ((a -&gt; (a, b)) -&gt; s -&gt; (a, t)) -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
</pre><p>With <code><a href="Lens-Micro-Type.html#t:LensLike" title="Lens.Micro.Type">LensLike</a></code>, the intent to use the <code>(,) a</code> functor can be made a bit clearer:</p><pre>(<code><a href="Lens-Micro.html#v:-60--60--37--126-" title="Lens.Micro">&lt;&lt;%~</a></code>) :: LensLike ((,) a) s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
</pre></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:LensLike-39-" class="def">LensLike'</a> f s a = <a href="Lens-Micro-Type.html#t:LensLike" title="Lens.Micro.Type">LensLike</a> f s s a a <a href="src/Lens.Micro.Type.html#LensLike%27" class="link">Source</a> <a href="#t:LensLike-39-" class="selflink">#</a></p><div class="doc"><p>A type alias for monomorphic <code><a href="Lens-Micro-Type.html#t:LensLike" title="Lens.Micro.Type">LensLike</a></code>s.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>