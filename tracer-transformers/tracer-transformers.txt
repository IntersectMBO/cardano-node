-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | tracer transformers and examples showing their use
@package tracer-transformers
@version 0.1.0.4

module Control.Tracer.Transformers
newtype Counting a
Counting :: Int -> Counting a
newtype Folding a f
Folding :: f -> Folding a f

-- | A stateful tracer transformer that substitutes messages with a
--   monotonically incrementing occurence count.
counting :: forall m a. MonadIO m => Tracer m (Counting a) -> m (Tracer m a)

-- | A pure tracer combinator that allows to decide a further tracer to
--   use, based on the message being processed.
fanning :: forall m a. (a -> Tracer m a) -> Tracer m a

-- | A generalised trace transformer that provides evolving state, defined
--   as a strict left fold.
folding :: forall m f a. MonadIO m => (f -> a -> f) -> f -> Tracer m (Folding a f) -> m (Tracer m a)


-- | Observing events with annotations of thread id and time.
module Control.Tracer.Transformers.ObserveOutcome
class (Monad m) => Outcome m a where {
    type IntermediateValue a;
    type OutcomeMetric a;
}
classifyObservable :: Outcome m a => a -> m OutcomeProgressionStatus
captureObservableValue :: Outcome m a => a -> m (IntermediateValue a)
computeOutcomeMetric :: Outcome m a => a -> IntermediateValue a -> IntermediateValue a -> m (OutcomeMetric a)

-- | The Maybe (OutcomeMetric a) captures the 'DeltaQ-ness' of the nature
--   of outcomes, may / may not complete.
type OutcomeEnhancedTracer m a = Tracer m (Either a (OutcomeFidelity (OutcomeMetric a)))

-- | Also need to know that observables happened in the "right way"
data OutcomeFidelity a
EndsBeforeStarted :: OutcomeFidelity a
StartsBeforeEnds :: a -> OutcomeFidelity a
ProgressedNormally :: a -> OutcomeFidelity a
data OutcomeProgressionStatus
OutcomeStarts :: OutcomeProgressionStatus
OutcomeOther :: OutcomeProgressionStatus
OutcomeEnds :: OutcomeProgressionStatus

-- | Generic Trace transformer. It could be written to take an initial
--   argument, but restricting the scope of that per-invocation state seems
--   more appropriate (for the moment). That may be of use if/when explict
--   management of timeout was required and/or non-termination of the
--   outcome at the end of a run was of interest.
mkOutcomeExtractor :: forall m a. (MonadIO m, MonadMask m, Outcome m a) => m (OutcomeEnhancedTracer m a -> Tracer m a)
instance GHC.Classes.Eq Control.Tracer.Transformers.ObserveOutcome.OutcomeProgressionStatus
instance GHC.Show.Show a => GHC.Show.Show (Control.Tracer.Transformers.ObserveOutcome.OutcomeFidelity a)


-- | Observing events with annotations of thread id and time.
module Control.Tracer.Transformers.WithThreadAndTime

-- | Add some operational context, time and thread
--   
--   note that this could, for example, be an instance of <tt>ToJSON</tt>
--   or <tt>Generic</tt> or similar to project it into a more general
--   framework
data WithThreadAndTime a
WithThreadAndTime :: !SystemTime -> !ThreadId -> !a -> WithThreadAndTime a
[occurredAt] :: WithThreadAndTime a -> !SystemTime
[withinThread] :: WithThreadAndTime a -> !ThreadId
[event] :: WithThreadAndTime a -> !a

-- | Add the time and thread to a trace observation
threadAndTimeTracer :: MonadIO m => Tracer m (WithThreadAndTime a) -> Tracer m a
instance GHC.Show.Show a => GHC.Show.Show (Control.Tracer.Transformers.WithThreadAndTime.WithThreadAndTime a)
