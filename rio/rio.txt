-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | See README and Haddocks at <a>https://www.stackage.org/package/rio</a>
@package rio
@version 0.1.23.0


-- | Lazy <tt>ByteString</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.ByteString.Lazy.Partial as BL'
--   </pre>
module RIO.ByteString.Lazy.Partial

-- | <i>O(1)</i> Extract the first element of a ByteString, which must be
--   non-empty.
--   
--   This is a partial function, consider using <a>uncons</a> instead.
head :: HasCallStack => ByteString -> Word8

-- | <i>O(n/c)</i> Extract the last element of a ByteString, which must be
--   finite and non-empty.
--   
--   This is a partial function, consider using <a>unsnoc</a> instead.
last :: HasCallStack => ByteString -> Word8

-- | <i>O(1)</i> Extract the elements after the head of a ByteString, which
--   must be non-empty.
--   
--   This is a partial function, consider using <a>uncons</a> instead.
tail :: HasCallStack => ByteString -> ByteString

-- | <i>O(n/c)</i> Returns all the elements of a <a>ByteString</a> except
--   the last one.
--   
--   This is a partial function, consider using <a>unsnoc</a> instead.
init :: HasCallStack => ByteString -> ByteString

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>ByteString</a>s.
foldl1 :: HasCallStack => (Word8 -> Word8 -> Word8) -> ByteString -> Word8

-- | <a>foldl1'</a> is like <a>foldl1</a>, but strict in the accumulator.
foldl1' :: HasCallStack => (Word8 -> Word8 -> Word8) -> ByteString -> Word8

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>ByteString</a>s
foldr1 :: HasCallStack => (Word8 -> Word8 -> Word8) -> ByteString -> Word8

-- | <i>O(n)</i> <a>maximum</a> returns the maximum value from a
--   <a>ByteString</a>
maximum :: HasCallStack => ByteString -> Word8

-- | <i>O(n)</i> <a>minimum</a> returns the minimum value from a
--   <a>ByteString</a>
minimum :: HasCallStack => ByteString -> Word8


-- | Strict <tt>ByteString</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.ByteString.Partial as B'
--   </pre>
module RIO.ByteString.Partial

-- | <i>O(1)</i> Extract the first element of a ByteString, which must be
--   non-empty. An exception will be thrown in the case of an empty
--   ByteString.
--   
--   This is a partial function, consider using <a>uncons</a> instead.
head :: HasCallStack => ByteString -> Word8

-- | <i>O(1)</i> Extract the last element of a ByteString, which must be
--   finite and non-empty. An exception will be thrown in the case of an
--   empty ByteString.
--   
--   This is a partial function, consider using <a>unsnoc</a> instead.
last :: HasCallStack => ByteString -> Word8

-- | <i>O(1)</i> Extract the elements after the head of a ByteString, which
--   must be non-empty. An exception will be thrown in the case of an empty
--   ByteString.
--   
--   This is a partial function, consider using <a>uncons</a> instead.
tail :: HasCallStack => ByteString -> ByteString

-- | <i>O(1)</i> Returns all the elements of a <a>ByteString</a> except the
--   last one. An exception will be thrown in the case of an empty
--   ByteString.
--   
--   This is a partial function, consider using <a>unsnoc</a> instead.
init :: HasCallStack => ByteString -> ByteString

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>ByteString</a>s. An
--   exception will be thrown in the case of an empty ByteString.
foldl1 :: HasCallStack => (Word8 -> Word8 -> Word8) -> ByteString -> Word8

-- | <a>foldl1'</a> is like <a>foldl1</a>, but strict in the accumulator.
--   An exception will be thrown in the case of an empty ByteString.
foldl1' :: HasCallStack => (Word8 -> Word8 -> Word8) -> ByteString -> Word8

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>ByteString</a>s An
--   exception will be thrown in the case of an empty ByteString.
foldr1 :: HasCallStack => (Word8 -> Word8 -> Word8) -> ByteString -> Word8

-- | <a>foldr1'</a> is a variant of <a>foldr1</a>, but is strict in the
--   accumulator.
foldr1' :: HasCallStack => (Word8 -> Word8 -> Word8) -> ByteString -> Word8

-- | <i>O(n)</i> <a>maximum</a> returns the maximum value from a
--   <a>ByteString</a> An exception will be thrown in the case of an empty
--   ByteString.
maximum :: HasCallStack => ByteString -> Word8

-- | <i>O(n)</i> <a>minimum</a> returns the minimum value from a
--   <a>ByteString</a> An exception will be thrown in the case of an empty
--   ByteString.
minimum :: HasCallStack => ByteString -> Word8


-- | Unicode <tt>Char</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.Char as C
--   </pre>
--   
--   This module does not export any partial functions. For those, see
--   <a>RIO.Char.Partial</a>
module RIO.Char

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data () => Char

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects lower-case alphabetic Unicode characters (letters).
--   
--   <b>Note:</b> this predicate does <i>not</i> work for letter-like
--   characters such as: <tt>'ⓐ'</tt> (<tt>U+24D0</tt> circled Latin small
--   letter a) and <tt>'ⅳ'</tt> (<tt>U+2173</tt> small Roman numeral four).
--   This is due to selecting only characters with the
--   <a>GeneralCategory</a> <a>LowercaseLetter</a>.
--   
--   See <a>isLowerCase</a> for a more intuitive predicate.
isLower :: Char -> Bool

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
--   
--   <b>Note:</b> this predicate does <i>not</i> work for letter-like
--   characters such as: <tt>'Ⓐ'</tt> (<tt>U+24B6</tt> circled Latin
--   capital letter A) and <tt>'Ⅳ'</tt> (<tt>U+2163</tt> Roman numeral
--   four). This is due to selecting only characters with the
--   <a>GeneralCategory</a> <a>UppercaseLetter</a> or
--   <a>TitlecaseLetter</a>.
--   
--   See <a>isUpperCase</a> for a more intuitive predicate. Note that
--   unlike <a>isUpperCase</a>, <a>isUpper</a> does select
--   <i>title-case</i> characters such as <tt>'ǅ'</tt> (<tt>U+01C5</tt>
--   Latin capital letter d with small letter z with caron) or <tt>'ᾯ'</tt>
--   (<tt>U+1FAF</tt> Greek capital letter omega with dasia and perispomeni
--   and prosgegrammeni).
isUpper :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
isAlpha :: Char -> Bool

-- | Selects alphabetic or numeric Unicode characters.
--   
--   Note that numeric digits outside the ASCII range, as well as numeric
--   characters which aren't digits, are selected by this function but not
--   by <a>isDigit</a>. Such characters may be part of identifiers but are
--   not used by the printer and reader to represent numbers.
isAlphaNum :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
isPrint :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isAlpha</a>.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Letter".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLetter 'a'
--   True
--   
--   &gt;&gt;&gt; isLetter 'A'
--   True
--   
--   &gt;&gt;&gt; isLetter 'λ'
--   True
--   
--   &gt;&gt;&gt; isLetter '0'
--   False
--   
--   &gt;&gt;&gt; isLetter '%'
--   False
--   
--   &gt;&gt;&gt; isLetter '♥'
--   False
--   
--   &gt;&gt;&gt; isLetter '\31'
--   False
--   </pre>
--   
--   Ensure that <a>isLetter</a> and <a>isAlpha</a> are equivalent.
--   
--   <pre>
--   &gt;&gt;&gt; let chars = [(chr 0)..]
--   
--   &gt;&gt;&gt; let letters = map isLetter chars
--   
--   &gt;&gt;&gt; let alphas = map isAlpha chars
--   
--   &gt;&gt;&gt; letters == alphas
--   True
--   </pre>
isLetter :: Char -> Bool

-- | Selects Unicode mark characters, for example accents and the like,
--   which combine with preceding characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>NonSpacingMark</a></li>
--   <li><a>SpacingCombiningMark</a></li>
--   <li><a>EnclosingMark</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Mark".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isMark 'a'
--   False
--   
--   &gt;&gt;&gt; isMark '0'
--   False
--   </pre>
--   
--   Combining marks such as accent characters usually need to follow
--   another character before they become printable:
--   
--   <pre>
--   &gt;&gt;&gt; map isMark "ò"
--   [False,True]
--   </pre>
--   
--   Puns are not necessarily supported:
--   
--   <pre>
--   &gt;&gt;&gt; isMark '✓'
--   False
--   </pre>
isMark :: Char -> Bool

-- | Selects Unicode numeric characters, including digits from various
--   scripts, Roman numerals, et cetera.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>DecimalNumber</a></li>
--   <li><a>LetterNumber</a></li>
--   <li><a>OtherNumber</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Number".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'a'
--   False
--   
--   &gt;&gt;&gt; isNumber '%'
--   False
--   
--   &gt;&gt;&gt; isNumber '3'
--   True
--   </pre>
--   
--   ASCII <tt>'0'</tt> through <tt>'9'</tt> are all numbers:
--   
--   <pre>
--   &gt;&gt;&gt; and $ map isNumber ['0'..'9']
--   True
--   </pre>
--   
--   Unicode Roman numerals are "numbers" as well:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'Ⅸ'
--   True
--   </pre>
isNumber :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Selects Unicode space and separator characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>Space</a></li>
--   <li><a>LineSeparator</a></li>
--   <li><a>ParagraphSeparator</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Separator".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator 'a'
--   False
--   
--   &gt;&gt;&gt; isSeparator '6'
--   False
--   
--   &gt;&gt;&gt; isSeparator ' '
--   True
--   </pre>
--   
--   Warning: newlines and tab characters are not considered separators.
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\n'
--   False
--   
--   &gt;&gt;&gt; isSeparator '\t'
--   False
--   </pre>
--   
--   But some more exotic characters are (like HTML's <tt>&amp;nbsp;</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\160'
--   True
--   </pre>
isSeparator :: Char -> Bool

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <a>Read</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data () => GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char


-- | Unicode <tt>Char</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.Char.Partial as C'
--   </pre>
module RIO.Char.Partial

-- | Convert a single digit <a>Char</a> to the corresponding <a>Int</a>.
--   This function fails unless its argument satisfies <a>isHexDigit</a>,
--   but recognises both upper- and lower-case hexadecimal digits (that is,
--   <tt>'0'</tt>..<tt>'9'</tt>, <tt>'a'</tt>..<tt>'f'</tt>,
--   <tt>'A'</tt>..<tt>'F'</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   Characters <tt>'0'</tt> through <tt>'9'</tt> are converted properly to
--   <tt>0..9</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['0'..'9']
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   Both upper- and lower-case <tt>'A'</tt> through <tt>'F'</tt> are
--   converted as well, to <tt>10..15</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['a'..'f']
--   [10,11,12,13,14,15]
--   
--   &gt;&gt;&gt; map digitToInt ['A'..'F']
--   [10,11,12,13,14,15]
--   </pre>
--   
--   Anything else throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; digitToInt 'G'
--   *** Exception: Char.digitToInt: not a digit 'G'
--   
--   &gt;&gt;&gt; digitToInt '♥'
--   *** Exception: Char.digitToInt: not a digit '\9829'
--   </pre>
digitToInt :: Char -> Int

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char

module RIO.Directory


-- | <h2>Rationale</h2>
--   
--   This module offers functions to handle files that offer better
--   durability and/or atomicity.
--   
--   See <a>UnliftIO.IO.File</a> for the rationale behind this module,
--   since all of the functions were moved upstream and are now simply
--   re-exported from here.
module RIO.File
withBinaryFile :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m a) -> m a
writeBinaryFile :: MonadIO m => FilePath -> ByteString -> m ()
withBinaryFileAtomic :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m r) -> m r
writeBinaryFileAtomic :: MonadIO m => FilePath -> ByteString -> m ()
withBinaryFileDurable :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m r) -> m r
writeBinaryFileDurable :: MonadIO m => FilePath -> ByteString -> m ()
ensureFileDurable :: MonadIO m => FilePath -> m ()
withBinaryFileDurableAtomic :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m r) -> m r
writeBinaryFileDurableAtomic :: MonadIO m => FilePath -> ByteString -> m ()

module RIO.FilePath

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | The character that is used to separate the entries in the $PATH
--   environment variable.
--   
--   <pre>
--   Windows: searchPathSeparator == ';'
--   Posix:   searchPathSeparator == ':'
--   </pre>
searchPathSeparator :: Char

-- | Normalise a file
--   
--   <ul>
--   <li>// outside of the drive can be made blank</li>
--   <li>/ -&gt; <a>pathSeparator</a></li>
--   <li>./ -&gt; ""</li>
--   </ul>
--   
--   Does not remove <tt>".."</tt>, because of symlinks.
--   
--   <pre>
--   Posix:   normalise "/file/\\test////" == "/file/\\test/"
--   Posix:   normalise "/file/./test" == "/file/test"
--   Posix:   normalise "/test/file/../bob/fred/" == "/test/file/../bob/fred/"
--   Posix:   normalise "../bob/fred/" == "../bob/fred/"
--   Posix:   normalise "/a/../c" == "/a/../c"
--   Posix:   normalise "./bob/fred/" == "bob/fred/"
--   Windows: normalise "c:\\file/bob\\" == "C:\\file\\bob\\"
--   Windows: normalise "c:\\" == "C:\\"
--   Windows: normalise "c:\\\\\\\\" == "C:\\"
--   Windows: normalise "C:.\\" == "C:"
--   Windows: normalise "\\\\server\\test" == "\\\\server\\test"
--   Windows: normalise "//server/test" == "\\\\server\\test"
--   Windows: normalise "c:/file" == "C:\\file"
--   Windows: normalise "/file" == "\\file"
--   Windows: normalise "\\" == "\\"
--   Windows: normalise "/./" == "\\"
--            normalise "." == "."
--   Posix:   normalise "./" == "./"
--   Posix:   normalise "./." == "./"
--   Posix:   normalise "/./" == "/"
--   Posix:   normalise "/" == "/"
--   Posix:   normalise "bob/fred/." == "bob/fred/"
--   Posix:   normalise "//home" == "/home"
--   </pre>
normalise :: FilePath -> FilePath

-- | Remove any trailing path separators
--   
--   <pre>
--   dropTrailingPathSeparator "file/test/" == "file/test"
--             dropTrailingPathSeparator "/" == "/"
--   Windows:  dropTrailingPathSeparator "\\" == "\\"
--   Posix:    not (hasTrailingPathSeparator (dropTrailingPathSeparator x)) || isDrive x
--   </pre>
dropTrailingPathSeparator :: FilePath -> FilePath

-- | Contract a filename, based on a relative path. Note that the resulting
--   path will never introduce <tt>..</tt> paths, as the presence of
--   symlinks means <tt>../b</tt> may not reach <tt>a/b</tt> if it starts
--   from <tt>a/c</tt>. For a worked example see <a>this blog post</a>.
--   
--   The corresponding <tt>makeAbsolute</tt> function can be found in
--   <tt>System.Directory</tt>.
--   
--   <pre>
--            makeRelative "/directory" "/directory/file.ext" == "file.ext"
--            Valid x =&gt; makeRelative (takeDirectory x) x `equalFilePath` takeFileName x
--            makeRelative x x == "."
--            Valid x y =&gt; equalFilePath x y || (isRelative x &amp;&amp; makeRelative y x == x) || equalFilePath (y &lt;/&gt; makeRelative y x) x
--   Windows: makeRelative "C:\\Home" "c:\\home\\bob" == "bob"
--   Windows: makeRelative "C:\\Home" "c:/home/bob" == "bob"
--   Windows: makeRelative "C:\\Home" "D:\\Home\\Bob" == "D:\\Home\\Bob"
--   Windows: makeRelative "C:\\Home" "C:Home\\Bob" == "C:Home\\Bob"
--   Windows: makeRelative "/Home" "/home/bob" == "bob"
--   Windows: makeRelative "/" "//" == "//"
--   Posix:   makeRelative "/Home" "/home/bob" == "/home/bob"
--   Posix:   makeRelative "/home/" "/home/bob/foo/bar" == "bob/foo/bar"
--   Posix:   makeRelative "/fred" "bob" == "bob"
--   Posix:   makeRelative "/file/test" "/file/test/fred" == "fred"
--   Posix:   makeRelative "/file/test" "/file/test/fred/" == "fred/"
--   Posix:   makeRelative "some/path" "some/path/a/b/c" == "a/b/c"
--   </pre>
makeRelative :: FilePath -> FilePath -> FilePath

-- | Combine two paths with a path separator. If the second path starts
--   with a path separator or a drive letter, then it returns the second.
--   The intention is that <tt>readFile (dir <a>&lt;/&gt;</a> file)</tt>
--   will access the same file as <tt>setCurrentDirectory dir; readFile
--   file</tt>.
--   
--   <pre>
--   Posix:   "/directory" &lt;/&gt; "file.ext" == "/directory/file.ext"
--   Windows: "/directory" &lt;/&gt; "file.ext" == "/directory\\file.ext"
--            "directory" &lt;/&gt; "/file.ext" == "/file.ext"
--   Valid x =&gt; (takeDirectory x &lt;/&gt; takeFileName x) `equalFilePath` x
--   </pre>
--   
--   Combined:
--   
--   <pre>
--   Posix:   "/" &lt;/&gt; "test" == "/test"
--   Posix:   "home" &lt;/&gt; "bob" == "home/bob"
--   Posix:   "x:" &lt;/&gt; "foo" == "x:/foo"
--   Windows: "C:\\foo" &lt;/&gt; "bar" == "C:\\foo\\bar"
--   Windows: "home" &lt;/&gt; "bob" == "home\\bob"
--   </pre>
--   
--   Not combined:
--   
--   <pre>
--   Posix:   "home" &lt;/&gt; "/bob" == "/bob"
--   Windows: "home" &lt;/&gt; "C:\\bob" == "C:\\bob"
--   </pre>
--   
--   Not combined (tricky):
--   
--   On Windows, if a filepath starts with a single slash, it is relative
--   to the root of the current drive. In [1], this is (confusingly)
--   referred to as an absolute path. The current behavior of
--   <a>&lt;/&gt;</a> is to never combine these forms.
--   
--   <pre>
--   Windows: "home" &lt;/&gt; "/bob" == "/bob"
--   Windows: "home" &lt;/&gt; "\\bob" == "\\bob"
--   Windows: "C:\\home" &lt;/&gt; "\\bob" == "\\bob"
--   </pre>
--   
--   On Windows, from [1]: "If a file name begins with only a disk
--   designator but not the backslash after the colon, it is interpreted as
--   a relative path to the current directory on the drive with the
--   specified letter." The current behavior of <a>&lt;/&gt;</a> is to
--   never combine these forms.
--   
--   <pre>
--   Windows: "D:\\foo" &lt;/&gt; "C:bar" == "C:bar"
--   Windows: "C:\\foo" &lt;/&gt; "C:bar" == "C:bar"
--   </pre>
(</>) :: FilePath -> FilePath -> FilePath
infixr 5 </>

-- | The character that separates directories. In the case where more than
--   one character is possible, <a>pathSeparator</a> is the 'ideal' one.
--   
--   <pre>
--   Windows: pathSeparator == '\\'
--   Posix:   pathSeparator ==  '/'
--   isPathSeparator pathSeparator
--   </pre>
pathSeparator :: Char

-- | The list of all possible separators.
--   
--   <pre>
--   Windows: pathSeparators == ['\\', '/']
--   Posix:   pathSeparators == ['/']
--   pathSeparator `elem` pathSeparators
--   </pre>
pathSeparators :: [Char]

-- | Rather than using <tt>(== <a>pathSeparator</a>)</tt>, use this. Test
--   if something is a path separator.
--   
--   <pre>
--   isPathSeparator a == (a `elem` pathSeparators)
--   </pre>
isPathSeparator :: Char -> Bool

-- | Is the character a file separator?
--   
--   <pre>
--   isSearchPathSeparator a == (a == searchPathSeparator)
--   </pre>
isSearchPathSeparator :: Char -> Bool

-- | File extension character
--   
--   <pre>
--   extSeparator == '.'
--   </pre>
extSeparator :: Char

-- | Is the character an extension character?
--   
--   <pre>
--   isExtSeparator a == (a == extSeparator)
--   </pre>
isExtSeparator :: Char -> Bool

-- | Take a string, split it on the <a>searchPathSeparator</a> character.
--   Blank items are ignored on Windows, and converted to <tt>.</tt> on
--   Posix. On Windows path elements are stripped of quotes.
--   
--   Follows the recommendations in
--   <a>http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html</a>
--   
--   <pre>
--   Posix:   splitSearchPath "File1:File2:File3"  == ["File1","File2","File3"]
--   Posix:   splitSearchPath "File1::File2:File3" == ["File1",".","File2","File3"]
--   Windows: splitSearchPath "File1;File2;File3"  == ["File1","File2","File3"]
--   Windows: splitSearchPath "File1;;File2;File3" == ["File1","File2","File3"]
--   Windows: splitSearchPath "File1;\"File2\";File3" == ["File1","File2","File3"]
--   </pre>
splitSearchPath :: String -> [FilePath]

-- | Split on the extension. <a>addExtension</a> is the inverse.
--   
--   <pre>
--   splitExtension "/directory/path.ext" == ("/directory/path",".ext")
--   uncurry (&lt;&gt;) (splitExtension x) == x
--   Valid x =&gt; uncurry addExtension (splitExtension x) == x
--   splitExtension "file.txt" == ("file",".txt")
--   splitExtension "file" == ("file","")
--   splitExtension "file/file.txt" == ("file/file",".txt")
--   splitExtension "file.txt/boris" == ("file.txt/boris","")
--   splitExtension "file.txt/boris.ext" == ("file.txt/boris",".ext")
--   splitExtension "file/path.txt.bob.fred" == ("file/path.txt.bob",".fred")
--   splitExtension "file/path.txt/" == ("file/path.txt/","")
--   </pre>
splitExtension :: FilePath -> (String, String)

-- | Get the extension of a file, returns <tt>""</tt> for no extension,
--   <tt>.ext</tt> otherwise.
--   
--   <pre>
--   takeExtension "/directory/path.ext" == ".ext"
--   takeExtension x == snd (splitExtension x)
--   Valid x =&gt; takeExtension (addExtension x "ext") == ".ext"
--   Valid x =&gt; takeExtension (replaceExtension x "ext") == ".ext"
--   </pre>
takeExtension :: FilePath -> String

-- | Remove the current extension and add another, equivalent to
--   <a>replaceExtension</a>.
--   
--   <pre>
--   "/directory/path.txt" -&lt;.&gt; "ext" == "/directory/path.ext"
--   "/directory/path.txt" -&lt;.&gt; ".ext" == "/directory/path.ext"
--   "foo.o" -&lt;.&gt; "c" == "foo.c"
--   </pre>
(-<.>) :: FilePath -> String -> FilePath
infixr 7 -<.>

-- | Set the extension of a file, overwriting one if already present,
--   equivalent to <a>-&lt;.&gt;</a>.
--   
--   <pre>
--   replaceExtension "/directory/path.txt" "ext" == "/directory/path.ext"
--   replaceExtension "/directory/path.txt" ".ext" == "/directory/path.ext"
--   replaceExtension "file.txt" ".bob" == "file.bob"
--   replaceExtension "file.txt" "bob" == "file.bob"
--   replaceExtension "file" ".bob" == "file.bob"
--   replaceExtension "file.txt" "" == "file"
--   replaceExtension "file.fred.bob" "txt" == "file.fred.txt"
--   replaceExtension x y == addExtension (dropExtension x) y
--   </pre>
replaceExtension :: FilePath -> String -> FilePath

-- | Add an extension, even if there is already one there, equivalent to
--   <a>addExtension</a>.
--   
--   <pre>
--   "/directory/path" &lt;.&gt; "ext" == "/directory/path.ext"
--   "/directory/path" &lt;.&gt; ".ext" == "/directory/path.ext"
--   </pre>
(<.>) :: FilePath -> String -> FilePath
infixr 7 <.>

-- | Remove last extension, and the "." preceding it.
--   
--   <pre>
--   dropExtension "/directory/path.ext" == "/directory/path"
--   dropExtension x == fst (splitExtension x)
--   </pre>
dropExtension :: FilePath -> FilePath

-- | Add an extension, even if there is already one there, equivalent to
--   <a>&lt;.&gt;</a>.
--   
--   <pre>
--   addExtension "/directory/path" "ext" == "/directory/path.ext"
--   addExtension "file.txt" "bib" == "file.txt.bib"
--   addExtension "file." ".bib" == "file..bib"
--   addExtension "file" ".bib" == "file.bib"
--   addExtension "/" "x" == "/.x"
--   addExtension x "" == x
--   Valid x =&gt; takeFileName (addExtension (addTrailingPathSeparator x) "ext") == ".ext"
--   Windows: addExtension "\\\\share" ".txt" == "\\\\share\\.txt"
--   </pre>
addExtension :: FilePath -> String -> FilePath

-- | Does the given filename have an extension?
--   
--   <pre>
--   hasExtension "/directory/path.ext" == True
--   hasExtension "/directory/path" == False
--   null (takeExtension x) == not (hasExtension x)
--   </pre>
hasExtension :: FilePath -> Bool

-- | Does the given filename have the specified extension?
--   
--   <pre>
--   "png" `isExtensionOf` "/directory/file.png" == True
--   ".png" `isExtensionOf` "/directory/file.png" == True
--   ".tar.gz" `isExtensionOf` "bar/foo.tar.gz" == True
--   "ar.gz" `isExtensionOf` "bar/foo.tar.gz" == False
--   "png" `isExtensionOf` "/directory/file.png.jpg" == False
--   "csv/table.csv" `isExtensionOf` "/data/csv/table.csv" == False
--   </pre>
isExtensionOf :: String -> FilePath -> Bool

-- | Drop the given extension from a FilePath, and the <tt>"."</tt>
--   preceding it. Returns <a>Nothing</a> if the FilePath does not have the
--   given extension, or <a>Just</a> and the part before the extension if
--   it does.
--   
--   This function can be more predictable than <a>dropExtensions</a>,
--   especially if the filename might itself contain <tt>.</tt> characters.
--   
--   <pre>
--   stripExtension "hs.o" "foo.x.hs.o" == Just "foo.x"
--   stripExtension "hi.o" "foo.x.hs.o" == Nothing
--   dropExtension x == fromJust (stripExtension (takeExtension x) x)
--   dropExtensions x == fromJust (stripExtension (takeExtensions x) x)
--   stripExtension ".c.d" "a.b.c.d"  == Just "a.b"
--   stripExtension ".c.d" "a.b..c.d" == Just "a.b."
--   stripExtension "baz"  "foo.bar"  == Nothing
--   stripExtension "bar"  "foobar"   == Nothing
--   stripExtension ""     x          == Just x
--   </pre>
stripExtension :: String -> FilePath -> Maybe FilePath

-- | Split on all extensions.
--   
--   <pre>
--   splitExtensions "/directory/path.ext" == ("/directory/path",".ext")
--   splitExtensions "file.tar.gz" == ("file",".tar.gz")
--   uncurry (&lt;&gt;) (splitExtensions x) == x
--   Valid x =&gt; uncurry addExtension (splitExtensions x) == x
--   splitExtensions "file.tar.gz" == ("file",".tar.gz")
--   </pre>
splitExtensions :: FilePath -> (FilePath, String)

-- | Drop all extensions.
--   
--   <pre>
--   dropExtensions "/directory/path.ext" == "/directory/path"
--   dropExtensions "file.tar.gz" == "file"
--   not $ hasExtension $ dropExtensions x
--   not $ any isExtSeparator $ takeFileName $ dropExtensions x
--   </pre>
dropExtensions :: FilePath -> FilePath

-- | Get all extensions.
--   
--   <pre>
--   takeExtensions "/directory/path.ext" == ".ext"
--   takeExtensions "file.tar.gz" == ".tar.gz"
--   </pre>
takeExtensions :: FilePath -> String

-- | Replace all extensions of a file with a new extension. Note that
--   <a>replaceExtension</a> and <a>addExtension</a> both work for adding
--   multiple extensions, so only required when you need to drop all
--   extensions first.
--   
--   <pre>
--   replaceExtensions "file.fred.bob" "txt" == "file.txt"
--   replaceExtensions "file.fred.bob" "tar.gz" == "file.tar.gz"
--   </pre>
replaceExtensions :: FilePath -> String -> FilePath

-- | Split a path into a drive and a path. On Posix, / is a Drive.
--   
--   <pre>
--   uncurry (&lt;&gt;) (splitDrive x) == x
--   Windows: splitDrive "file" == ("","file")
--   Windows: splitDrive "c:/file" == ("c:/","file")
--   Windows: splitDrive "c:\\file" == ("c:\\","file")
--   Windows: splitDrive "\\\\shared\\test" == ("\\\\shared\\","test")
--   Windows: splitDrive "\\\\shared" == ("\\\\shared","")
--   Windows: splitDrive "\\\\?\\UNC\\shared\\file" == ("\\\\?\\UNC\\shared\\","file")
--   Windows: splitDrive "\\\\?\\UNCshared\\file" == ("\\\\?\\","UNCshared\\file")
--   Windows: splitDrive "\\\\?\\d:\\file" == ("\\\\?\\d:\\","file")
--   Windows: splitDrive "/d" == ("","/d")
--   Posix:   splitDrive "/test" == ("/","test")
--   Posix:   splitDrive "//test" == ("//","test")
--   Posix:   splitDrive "test/file" == ("","test/file")
--   Posix:   splitDrive "file" == ("","file")
--   </pre>
splitDrive :: FilePath -> (FilePath, FilePath)

-- | Join a drive and the rest of the path.
--   
--   <pre>
--   Valid x =&gt; uncurry joinDrive (splitDrive x) == x
--   Windows: joinDrive "C:" "foo" == "C:foo"
--   Windows: joinDrive "C:\\" "bar" == "C:\\bar"
--   Windows: joinDrive "\\\\share" "foo" == "\\\\share\\foo"
--   Windows: joinDrive "/:" "foo" == "/:\\foo"
--   </pre>
joinDrive :: FilePath -> FilePath -> FilePath

-- | Get the drive from a filepath.
--   
--   <pre>
--   takeDrive x == fst (splitDrive x)
--   </pre>
takeDrive :: FilePath -> FilePath

-- | Delete the drive, if it exists.
--   
--   <pre>
--   dropDrive x == snd (splitDrive x)
--   </pre>
dropDrive :: FilePath -> FilePath

-- | Does a path have a drive.
--   
--   <pre>
--   not (hasDrive x) == null (takeDrive x)
--   Posix:   hasDrive "/foo" == True
--   Windows: hasDrive "C:\\foo" == True
--   Windows: hasDrive "C:foo" == True
--            hasDrive "foo" == False
--            hasDrive "" == False
--   </pre>
hasDrive :: FilePath -> Bool

-- | Is an element a drive
--   
--   <pre>
--   Posix:   isDrive "/" == True
--   Posix:   isDrive "/foo" == False
--   Windows: isDrive "C:\\" == True
--   Windows: isDrive "C:\\foo" == False
--            isDrive "" == False
--   </pre>
isDrive :: FilePath -> Bool

-- | Split a filename into directory and file. <a>&lt;/&gt;</a> is the
--   inverse. The first component will often end with a trailing slash.
--   
--   <pre>
--   splitFileName "/directory/file.ext" == ("/directory/","file.ext")
--   Valid x =&gt; uncurry (&lt;/&gt;) (splitFileName x) == x || fst (splitFileName x) == "./"
--   Valid x =&gt; isValid (fst (splitFileName x))
--   splitFileName "file/bob.txt" == ("file/", "bob.txt")
--   splitFileName "file/" == ("file/", "")
--   splitFileName "bob" == ("./", "bob")
--   Posix:   splitFileName "/" == ("/","")
--   Windows: splitFileName "c:" == ("c:","")
--   Windows: splitFileName "\\\\?\\A:\\fred" == ("\\\\?\\A:\\","fred")
--   Windows: splitFileName "\\\\?\\A:" == ("\\\\?\\A:","")
--   </pre>
splitFileName :: FilePath -> (String, String)

-- | Set the filename.
--   
--   <pre>
--   replaceFileName "/directory/other.txt" "file.ext" == "/directory/file.ext"
--   Valid x =&gt; replaceFileName x (takeFileName x) == x
--   </pre>
replaceFileName :: FilePath -> String -> FilePath

-- | Drop the filename. Unlike <a>takeDirectory</a>, this function will
--   leave a trailing path separator on the directory.
--   
--   <pre>
--   dropFileName "/directory/file.ext" == "/directory/"
--   dropFileName x == fst (splitFileName x)
--   </pre>
dropFileName :: FilePath -> FilePath

-- | Get the file name.
--   
--   <pre>
--   takeFileName "/directory/file.ext" == "file.ext"
--   takeFileName "test/" == ""
--   isSuffixOf (takeFileName x) x
--   takeFileName x == snd (splitFileName x)
--   Valid x =&gt; takeFileName (replaceFileName x "fred") == "fred"
--   Valid x =&gt; takeFileName (x &lt;/&gt; "fred") == "fred"
--   Valid x =&gt; isRelative (takeFileName x)
--   </pre>
takeFileName :: FilePath -> FilePath

-- | Get the base name, without an extension or path.
--   
--   <pre>
--   takeBaseName "/directory/file.ext" == "file"
--   takeBaseName "file/test.txt" == "test"
--   takeBaseName "dave.ext" == "dave"
--   takeBaseName "" == ""
--   takeBaseName "test" == "test"
--   takeBaseName (addTrailingPathSeparator x) == ""
--   takeBaseName "file/file.tar.gz" == "file.tar"
--   </pre>
takeBaseName :: FilePath -> String

-- | Set the base name.
--   
--   <pre>
--   replaceBaseName "/directory/other.ext" "file" == "/directory/file.ext"
--   replaceBaseName "file/test.txt" "bob" == "file/bob.txt"
--   replaceBaseName "fred" "bill" == "bill"
--   replaceBaseName "/dave/fred/bob.gz.tar" "new" == "/dave/fred/new.tar"
--   Valid x =&gt; replaceBaseName x (takeBaseName x) == x
--   </pre>
replaceBaseName :: FilePath -> String -> FilePath

-- | Is an item either a directory or the last character a path separator?
--   
--   <pre>
--   hasTrailingPathSeparator "test" == False
--   hasTrailingPathSeparator "test/" == True
--   </pre>
hasTrailingPathSeparator :: FilePath -> Bool

-- | Add a trailing file path separator if one is not already present.
--   
--   <pre>
--   hasTrailingPathSeparator (addTrailingPathSeparator x)
--   hasTrailingPathSeparator x ==&gt; addTrailingPathSeparator x == x
--   Posix:    addTrailingPathSeparator "test/rest" == "test/rest/"
--   </pre>
addTrailingPathSeparator :: FilePath -> FilePath

-- | Get the directory name, move up one level.
--   
--   <pre>
--             takeDirectory "/directory/other.ext" == "/directory"
--             isPrefixOf (takeDirectory x) x || takeDirectory x == "."
--             takeDirectory "foo" == "."
--             takeDirectory "/" == "/"
--             takeDirectory "/foo" == "/"
--             takeDirectory "/foo/bar/baz" == "/foo/bar"
--             takeDirectory "/foo/bar/baz/" == "/foo/bar/baz"
--             takeDirectory "foo/bar/baz" == "foo/bar"
--   Windows:  takeDirectory "foo\\bar" == "foo"
--   Windows:  takeDirectory "foo\\bar\\\\" == "foo\\bar"
--   Windows:  takeDirectory "C:\\" == "C:\\"
--   </pre>
takeDirectory :: FilePath -> FilePath

-- | Set the directory, keeping the filename the same.
--   
--   <pre>
--   replaceDirectory "root/file.ext" "/directory/" == "/directory/file.ext"
--   Valid x =&gt; replaceDirectory x (takeDirectory x) `equalFilePath` x
--   </pre>
replaceDirectory :: FilePath -> String -> FilePath

-- | An alias for <a>&lt;/&gt;</a>.
combine :: FilePath -> FilePath -> FilePath

-- | Split a path by the directory separator.
--   
--   <pre>
--   splitPath "/directory/file.ext" == ["/","directory/","file.ext"]
--   concat (splitPath x) == x
--   splitPath "test//item/" == ["test//","item/"]
--   splitPath "test/item/file" == ["test/","item/","file"]
--   splitPath "" == []
--   Windows: splitPath "c:\\test\\path" == ["c:\\","test\\","path"]
--   Posix:   splitPath "/file/test" == ["/","file/","test"]
--   </pre>
splitPath :: FilePath -> [FilePath]

-- | Just as <a>splitPath</a>, but don't add the trailing slashes to each
--   element.
--   
--   <pre>
--            splitDirectories "/directory/file.ext" == ["/","directory","file.ext"]
--            splitDirectories "test/file" == ["test","file"]
--            splitDirectories "/test/file" == ["/","test","file"]
--   Windows: splitDirectories "C:\\test\\file" == ["C:\\", "test", "file"]
--            Valid x =&gt; joinPath (splitDirectories x) `equalFilePath` x
--            splitDirectories "" == []
--   Windows: splitDirectories "C:\\test\\\\\\file" == ["C:\\", "test", "file"]
--            splitDirectories "/test///file" == ["/","test","file"]
--   </pre>
splitDirectories :: FilePath -> [FilePath]

-- | Join path elements back together.
--   
--   <pre>
--   joinPath z == foldr (&lt;/&gt;) "" z
--   joinPath ["/","directory/","file.ext"] == "/directory/file.ext"
--   Valid x =&gt; joinPath (splitPath x) == x
--   joinPath [] == ""
--   Posix: joinPath ["test","file","path"] == "test/file/path"
--   </pre>
joinPath :: [FilePath] -> FilePath

-- | Equality of two <tt>FILEPATH</tt>s. If you call
--   <tt>System.Directory.canonicalizePath</tt> first this has a much
--   better chance of working. Note that this doesn't follow symlinks or
--   DOSNAM~1s.
--   
--   Similar to <a>normalise</a>, this does not expand <tt>".."</tt>,
--   because of symlinks.
--   
--   <pre>
--            x == y ==&gt; equalFilePath x y
--            normalise x == normalise y ==&gt; equalFilePath x y
--            equalFilePath "foo" "foo/"
--            not (equalFilePath "/a/../c" "/c")
--            not (equalFilePath "foo" "/foo")
--   Posix:   not (equalFilePath "foo" "FOO")
--   Windows: equalFilePath "foo" "FOO"
--   Windows: not (equalFilePath "C:" "C:/")
--   </pre>
equalFilePath :: FilePath -> FilePath -> Bool

-- | Is a FilePath valid, i.e. could you create a file like it? This
--   function checks for invalid names, and invalid characters, but does
--   not check if length limits are exceeded, as these are typically
--   filesystem dependent.
--   
--   <pre>
--            isValid "" == False
--            isValid "\0" == False
--   Posix:   isValid "/random_ path:*" == True
--   Posix:   isValid x == not (null x)
--   Windows: isValid "c:\\test" == True
--   Windows: isValid "c:\\test:of_test" == False
--   Windows: isValid "test*" == False
--   Windows: isValid "c:\\test\\nul" == False
--   Windows: isValid "c:\\test\\prn.txt" == False
--   Windows: isValid "c:\\nul\\file" == False
--   Windows: isValid "\\\\" == False
--   Windows: isValid "\\\\\\foo" == False
--   Windows: isValid "\\\\?\\D:file" == False
--   Windows: isValid "foo\tbar" == False
--   Windows: isValid "nul .txt" == False
--   Windows: isValid " nul.txt" == True
--   </pre>
isValid :: FilePath -> Bool

-- | Take a FilePath and make it valid; does not change already valid
--   FILEPATHs.
--   
--   <pre>
--   isValid (makeValid x)
--   isValid x ==&gt; makeValid x == x
--   makeValid "" == "_"
--   makeValid "file\0name" == "file_name"
--   Windows: makeValid "c:\\already\\/valid" == "c:\\already\\/valid"
--   Windows: makeValid "c:\\test:of_test" == "c:\\test_of_test"
--   Windows: makeValid "test*" == "test_"
--   Windows: makeValid "c:\\test\\nul" == "c:\\test\\nul_"
--   Windows: makeValid "c:\\test\\prn.txt" == "c:\\test\\prn_.txt"
--   Windows: makeValid "c:\\test/prn.txt" == "c:\\test/prn_.txt"
--   Windows: makeValid "c:\\nul\\file" == "c:\\nul_\\file"
--   Windows: makeValid "\\\\\\foo" == "\\\\drive"
--   Windows: makeValid "\\\\?\\D:file" == "\\\\?\\D:\\file"
--   Windows: makeValid "nul .txt" == "nul _.txt"
--   </pre>
makeValid :: FilePath -> FilePath

-- | Is a path relative, or is it fixed to the root?
--   
--   <pre>
--   Windows: isRelative "path\\test" == True
--   Windows: isRelative "c:\\test" == False
--   Windows: isRelative "c:test" == True
--   Windows: isRelative "c:\\" == False
--   Windows: isRelative "c:/" == False
--   Windows: isRelative "c:" == True
--   Windows: isRelative "\\\\foo" == False
--   Windows: isRelative "\\\\?\\foo" == False
--   Windows: isRelative "\\\\?\\UNC\\foo" == False
--   Windows: isRelative "/foo" == True
--   Windows: isRelative "\\foo" == True
--   Posix:   isRelative "test/path" == True
--   Posix:   isRelative "/test" == False
--   Posix:   isRelative "/" == False
--   </pre>
--   
--   According to [1]:
--   
--   <ul>
--   <li>"A UNC name of any format [is never relative]."</li>
--   <li>"You cannot use the "\?" prefix with a relative path."</li>
--   </ul>
isRelative :: FilePath -> Bool

-- | <pre>
--   not . <a>isRelative</a>
--   </pre>
--   
--   <pre>
--   isAbsolute x == not (isRelative x)
--   </pre>
isAbsolute :: FilePath -> Bool

-- | Lifted version of <a>getSearchPath</a>
getSearchPath :: MonadIO m => m [FilePath]


-- | Strict <tt>Map</tt> with hashed keys. Import as:
--   
--   <pre>
--   import qualified RIO.HashMap as HM
--   </pre>
--   
--   This module does not export any partial functions. For those, see
--   <a>RIO.HashMap.Partial</a>
module RIO.HashMap
data () => HashMap k v
empty :: HashMap k v
singleton :: Hashable k => k -> v -> HashMap k v
null :: HashMap k v -> Bool
size :: HashMap k v -> Int
member :: (Eq k, Hashable k) => k -> HashMap k a -> Bool
lookup :: (Eq k, Hashable k) => k -> HashMap k v -> Maybe v
lookupDefault :: (Eq k, Hashable k) => v -> k -> HashMap k v -> v
insert :: (Eq k, Hashable k) => k -> v -> HashMap k v -> HashMap k v
insertWith :: (Eq k, Hashable k) => (v -> v -> v) -> k -> v -> HashMap k v -> HashMap k v
delete :: (Eq k, Hashable k) => k -> HashMap k v -> HashMap k v
adjust :: (Eq k, Hashable k) => (v -> v) -> k -> HashMap k v -> HashMap k v
update :: (Eq k, Hashable k) => (a -> Maybe a) -> k -> HashMap k a -> HashMap k a
alter :: (Eq k, Hashable k) => (Maybe v -> Maybe v) -> k -> HashMap k v -> HashMap k v
union :: Eq k => HashMap k v -> HashMap k v -> HashMap k v
unionWith :: Eq k => (v -> v -> v) -> HashMap k v -> HashMap k v -> HashMap k v
unionWithKey :: Eq k => (k -> v -> v -> v) -> HashMap k v -> HashMap k v -> HashMap k v
unions :: Eq k => [HashMap k v] -> HashMap k v
map :: (v1 -> v2) -> HashMap k v1 -> HashMap k v2
mapWithKey :: (k -> v1 -> v2) -> HashMap k v1 -> HashMap k v2
traverseWithKey :: Applicative f => (k -> v1 -> f v2) -> HashMap k v1 -> f (HashMap k v2)
difference :: (Eq k, Hashable k) => HashMap k v -> HashMap k w -> HashMap k v
differenceWith :: (Eq k, Hashable k) => (v -> w -> Maybe v) -> HashMap k v -> HashMap k w -> HashMap k v
intersection :: Eq k => HashMap k v -> HashMap k w -> HashMap k v
intersectionWith :: Eq k => (v1 -> v2 -> v3) -> HashMap k v1 -> HashMap k v2 -> HashMap k v3
intersectionWithKey :: Eq k => (k -> v1 -> v2 -> v3) -> HashMap k v1 -> HashMap k v2 -> HashMap k v3
foldl' :: (a -> v -> a) -> a -> HashMap k v -> a
foldlWithKey' :: (a -> k -> v -> a) -> a -> HashMap k v -> a
foldr :: (v -> a -> a) -> a -> HashMap k v -> a
foldrWithKey :: (k -> v -> a -> a) -> a -> HashMap k v -> a
filter :: (v -> Bool) -> HashMap k v -> HashMap k v
filterWithKey :: (k -> v -> Bool) -> HashMap k v -> HashMap k v
mapMaybe :: (v1 -> Maybe v2) -> HashMap k v1 -> HashMap k v2
mapMaybeWithKey :: (k -> v1 -> Maybe v2) -> HashMap k v1 -> HashMap k v2
keys :: HashMap k v -> [k]
elems :: HashMap k v -> [v]
toList :: HashMap k v -> [(k, v)]
fromList :: (Eq k, Hashable k) => [(k, v)] -> HashMap k v
fromListWith :: (Eq k, Hashable k) => (v -> v -> v) -> [(k, v)] -> HashMap k v


-- | Strict <tt>HashMap</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.HashMap.Partial as HM'
--   </pre>
module RIO.HashMap.Partial
(!) :: (Eq k, Hashable k, HasCallStack) => HashMap k v -> k -> v


-- | <tt>Set</tt> with hashed members. Import as:
--   
--   <pre>
--   import qualified RIO.HashSet as HS
--   </pre>
module RIO.HashSet
data () => HashSet a
empty :: HashSet a
singleton :: Hashable a => a -> HashSet a
union :: Eq a => HashSet a -> HashSet a -> HashSet a
unions :: Eq a => [HashSet a] -> HashSet a
null :: HashSet a -> Bool
size :: HashSet a -> Int
member :: (Eq a, Hashable a) => a -> HashSet a -> Bool
insert :: (Eq a, Hashable a) => a -> HashSet a -> HashSet a
delete :: (Eq a, Hashable a) => a -> HashSet a -> HashSet a
map :: (Hashable b, Eq b) => (a -> b) -> HashSet a -> HashSet b
difference :: (Eq a, Hashable a) => HashSet a -> HashSet a -> HashSet a
intersection :: Eq a => HashSet a -> HashSet a -> HashSet a
foldl' :: (a -> b -> a) -> a -> HashSet b -> a
foldr :: (b -> a -> a) -> a -> HashSet b -> a
filter :: (a -> Bool) -> HashSet a -> HashSet a
toList :: HashSet a -> [a]
fromList :: (Eq a, Hashable a) => [a] -> HashSet a
toMap :: HashSet a -> HashMap a ()
fromMap :: HashMap a () -> HashSet a


-- | Extra utilities from <tt>microlens</tt>.
--   
--   @since: 0.1.16.0
module RIO.Lens
type SimpleFold s a = forall r. Monoid r => Getting r s a
toListOf :: Getting (Endo [a]) s a -> s -> [a]
has :: Getting Any s a -> s -> Bool
_1 :: Field1 s t a b => Lens s t a b
_2 :: Field2 s t a b => Lens s t a b
_3 :: Field3 s t a b => Lens s t a b
_4 :: Field4 s t a b => Lens s t a b
_5 :: Field5 s t a b => Lens s t a b
at :: At m => Index m -> Lens' m (Maybe (IxValue m))
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
non :: Eq a => a -> Lens' (Maybe a) a
singular :: HasCallStack => Traversal s t a a -> Lens s t a a
failing :: Traversal s t a b -> Traversal s t a b -> Traversal s t a b
filtered :: (a -> Bool) -> Traversal' a a
both :: forall a b f. Applicative f => (a -> f b) -> (a, a) -> f (b, b)
traversed :: forall (f :: Type -> Type) a b. Traversable f => Traversal (f a) (f b) a b
each :: Each s t a b => Traversal s t a b
ix :: Ixed m => Index m -> Traversal' m (IxValue m)
_head :: Cons s s a a => Traversal' s a
_tail :: Cons s s a a => Traversal' s s
_init :: Snoc s s a a => Traversal' s s
_last :: Snoc s s a a => Traversal' s a
_Left :: forall a b a' f. Applicative f => (a -> f a') -> Either a b -> f (Either a' b)
_Right :: forall a b b' f. Applicative f => (b -> f b') -> Either a b -> f (Either a b')
_Just :: forall a a' f. Applicative f => (a -> f a') -> Maybe a -> f (Maybe a')
_Nothing :: forall a f. Applicative f => (() -> f ()) -> Maybe a -> f (Maybe a)


-- | <tt>List</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.List as L
--   </pre>
--   
--   This module does not export any partial functions. For those, see
--   <a>RIO.List.Partial</a>
module RIO.List

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   WARNING: This function takes linear time in the number of elements of
--   the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. Decompose a list into its head and tail.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (x, xs)</tt>,
--   where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   
--   &gt;&gt;&gt; uncons [1]
--   Just (1,[])
--   
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: [a] -> Maybe (a, [a])

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

headMaybe :: [a] -> Maybe a

lastMaybe :: [a] -> Maybe a

tailMaybe :: [a] -> Maybe [a]

initMaybe :: [a] -> Maybe [a]

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | &lt;math&gt;. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   For example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
--   
--   For this reason the outer list must be finite; otherwise
--   <a>transpose</a> hangs:
--   
--   <pre>
--   &gt;&gt;&gt; transpose (repeat [])
--   * Hangs forever *
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
--   
--   This function is productive on infinite inputs:
--   
--   <pre>
--   &gt;&gt;&gt; take 8 $ subsequences ['a'..]
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
--   
--   The <a>permutations</a> function is maximally lazy: for each
--   <tt>n</tt>, the value of <tt><a>permutations</a> xs</tt> starts with
--   those permutations that permute <tt><a>take</a> n xs</tt> and keep
--   <tt><a>drop</a> n xs</tt>.
--   
--   This function is productive on infinite inputs:
--   
--   <pre>
--   &gt;&gt;&gt; take 6 $ map (take 3) $ permutations ['a'..]
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
--   
--   Note that the order of permutations is not lexicographic. It satisfies
--   the following property:
--   
--   <pre>
--   map (take n) (take (product [1..n]) (permutations ([1..n] ++ undefined))) == permutations [1..n]
--   </pre>
permutations :: [a] -> [[a]]

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <i>O(n)</i> elements
--   long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a

maximumMaybe :: (Ord a, Foldable t) => t a -> Maybe a

minimumMaybe :: (Ord a, Foldable t) => t a -> Maybe a

maximumByMaybe :: Foldable t => (a -> a -> Ordering) -> t a -> Maybe a

minimumByMaybe :: Foldable t => (a -> a -> Ordering) -> t a -> Maybe a

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. A strict version of <a>scanl</a>.
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[0,1,3,6,10,15,21,28,36,45])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("012345",["0","01","012","0123","01234"])
--   </pre>
mapAccumL :: Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[54,52,49,45,40,34,27,19,10,0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("054321",["05432","0543","054","05","0"])
--   </pre>
mapAccumR :: Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: HasCallStack => [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   </pre>
--   
--   <pre>
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | &lt;math&gt;. The <a>stripPrefix</a> function drops the given prefix
--   from a list. It returns <a>Nothing</a> if the list did not start with
--   the prefix given, or <a>Just</a> the list after the prefix, if it
--   does.
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | Remove the suffix from the given list, if present
stripSuffix :: Eq a => [a] -> [a] -> Maybe [a]

-- | Drop prefix if present, otherwise return original list.
dropPrefix :: Eq a => [a] -> [a] -> [a]

-- | Drop prefix if present, otherwise return original list.
dropSuffix :: Eq a => [a] -> [a] -> [a]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result is non-empty and all elements are
--   equal to the first one. For example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   <a>group</a> is a special case of <a>groupBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   It's often preferable to use <tt>Data.List.NonEmpty.</tt><a>group</a>,
--   which provides type-level guarantees of non-emptiness of inner lists.
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
--   
--   <a>inits</a> is semantically equivalent to <tt><a>map</a>
--   <a>reverse</a> . <a>scanl</a> (<a>flip</a> (:)) []</tt>, but under the
--   hood uses a queue to amortize costs of <a>reverse</a>.
inits :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>tails</a> function returns all final segments of
--   the argument, longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite;
--   <a>False</a>, however, results from any mismatch:
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isPrefixOf` [1..]
--   False
--   
--   &gt;&gt;&gt; [0..] `isPrefixOf` [0..99]
--   False
--   
--   &gt;&gt;&gt; [0..99] `isPrefixOf` [0..]
--   True
--   
--   &gt;&gt;&gt; [0..] `isPrefixOf` [0..]
--   * Hangs forever *
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
--   
--   The second list must be finite; however the first list may be
--   infinite:
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isSuffixOf` [0..99]
--   False
--   
--   &gt;&gt;&gt; [0..99] `isSuffixOf` [0..]
--   * Hangs forever *
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite; for
--   the result to be <a>False</a>, the second list must be finite:
--   
--   <pre>
--   &gt;&gt;&gt; [20..50] `isInfixOf` [0..]
--   True
--   
--   &gt;&gt;&gt; [0..] `isInfixOf` [20..50]
--   False
--   
--   &gt;&gt;&gt; [0..] `isInfixOf` [0..]
--   * Hangs forever *
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if all the elements of the first list occur, in order, in
--   the second. The elements do not have to occur consecutively.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt><a>elem</a> x
--   (<a>subsequences</a> y)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf ['a','d'..'z'] ['a'..'z']
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf [1..10] [10,9..0]
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite; for
--   the result to be <a>False</a>, the second list must be finite:
--   
--   <pre>
--   &gt;&gt;&gt; [0,2..10] `isSubsequenceOf` [0..]
--   True
--   
--   &gt;&gt;&gt; [0..] `isSubsequenceOf` [0,2..10]
--   False
--   
--   &gt;&gt;&gt; [0,2..] `isSubsequenceOf` [0..]
--   * Hangs forever*
--   </pre>
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 42) [0, 5..]
--   Just 45
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 12) [1..7]
--   Nothing
--   </pre>
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate and a list, and
--   returns the pair of lists of elements which do and do not satisfy the
--   predicate, respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element. For the result to be
--   <a>Nothing</a>, the list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element. For the result to be
--   <a>Nothing</a>, the list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
lines :: String -> [String]

-- | <a>linesCR</a> breaks a <a>String</a> up into a list of <a>String</a>s
--   at newline <a>Char</a>s. It is very similar to <a>lines</a>, but it
--   also removes any trailing <tt>'r'</tt> <a>Char</a>s. The resulting
--   <a>String</a> values do not contain newlines or trailing <tt>'r'</tt>
--   characters.
linesCR :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
unwords :: [String] -> String

-- | &lt;math&gt;. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
--   
--   If the order of outputs does not matter and there exists <tt>instance
--   Ord a</tt>, it's faster to use <a>map</a>
--   <tt>Data.List.NonEmpty.</tt><a>head</a> .
--   <tt>Data.List.NonEmpty.</tt><a>group</a> . <a>sort</a>, which takes
--   only &lt;math&gt; time.
nub :: Eq a => [a] -> [a]

-- | &lt;math&gt;. <a>delete</a> <tt>x</tt> removes the first occurrence of
--   <tt>x</tt> from its list argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus <tt>(xs ++ ys) \\ xs == ys</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   The second list must be finite, but the first may be infinite.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 ([0..] \\ [2..4])
--   [0,1,5,6,7]
--   
--   &gt;&gt;&gt; take 5 ([0..] \\ [2..])
--   * Hangs forever *
--   </pre>
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | The <a>union</a> function returns the list union of the two lists. It
--   is a special case of <a>unionBy</a>, which allows the programmer to
--   supply their own equality test. For example,
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   If equal elements are present in both lists, an element from the first
--   list will be used. If the second list contains equal elements, only
--   the first one will be retained:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; union [Arg () "dog"] [Arg () "cow"]
--   [Arg () "dog"]
--   
--   &gt;&gt;&gt; union [] [Arg () "dog", Arg () "cow"]
--   [Arg () "dog"]
--   </pre>
--   
--   However if the first list contains duplicates, so will the result:
--   
--   <pre>
--   &gt;&gt;&gt; "coot" `union` "duck"
--   "cootduk"
--   
--   &gt;&gt;&gt; "duck" `union` "coot"
--   "duckot"
--   </pre>
--   
--   <a>union</a> is productive even if both arguments are infinite.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. For example,
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If equal elements are present in both lists, an element from the first
--   list will be used, and all duplicates from the second list quashed:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; intersect [Arg () "dog"] [Arg () "cow", Arg () "cat"]
--   [Arg () "dog"]
--   </pre>
--   
--   However if the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; "coot" `intersect` "heron"
--   "oo"
--   
--   &gt;&gt;&gt; "heron" `intersect` "coot"
--   "o"
--   </pre>
--   
--   If the second list is infinite, <a>intersect</a> either hangs or
--   returns its first argument in full. Otherwise if the first list is
--   infinite, <a>intersect</a> might be productive:
--   
--   <pre>
--   &gt;&gt;&gt; intersect [100..] [0..]
--   [100,101,102,103...
--   
--   &gt;&gt;&gt; intersect [0] [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; intersect [1..] [0]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; intersect (cycle [1..3]) [2]
--   [2,2,2,2...
--   </pre>
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   The argument must be finite.
sort :: Ord a => [a] -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt><a>sortOn</a> f</tt> is equivalent to <tt><a>sortBy</a>
--   (<a>comparing</a> f)</tt>, but has the performance advantage of only
--   evaluating <tt>f</tt> once for each element in the input list. This is
--   called the decorate-sort-undecorate paradigm, or <a>Schwartzian
--   transform</a>.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
--   
--   The argument must be finite.
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | &lt;math&gt;. The <a>insert</a> function takes an element and a list
--   and inserts the element into the list at the first position where it
--   is less than or equal to the next element. In particular, if the list
--   is sorted before the call, the result will also be sorted. It is a
--   special case of <a>insertBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1,2,3,5,6,7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. The <a>deleteBy</a> function behaves like <a>delete</a>,
--   but takes a user-supplied equality predicate.
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed. This is the non-overloaded version of
--   <a>(\\)</a>.
--   
--   The second list must be finite, but the first may be infinite.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>. Both arguments may be infinite.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>. It is productive for infinite arguments only if the
--   first one is a subset of the second.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
--   
--   When a supplied relation is not transitive, it is important to
--   remember that equality is checked against the first element in the
--   group, not against the nearest neighbour:
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (\a b -&gt; b - a &lt; 5) [0..19]
--   [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19]]
--   </pre>
--   
--   It's often preferable to use
--   <tt>Data.List.NonEmpty.</tt><a>groupBy</a>, which provides type-level
--   guarantees of non-emptiness of inner lists.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>. The argument must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
--   
--   The supplied comparison relation is supposed to be reflexive and
--   antisymmetric, otherwise, e. g., for <tt>_ _ -&gt; GT</tt>, the
--   ordered list simply does not exist. The relation is also expected to
--   be transitive: if it is not then <a>sortBy</a> might fail to find an
--   ordered permutation, even if it exists.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | &lt;math&gt;. The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | &lt;math&gt;. The <a>genericLength</a> function is an overloaded
--   version of <a>length</a>. In particular, instead of returning an
--   <a>Int</a>, it returns any type which is an instance of <a>Num</a>. It
--   is, however, less efficient than <a>length</a>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Int
--   3
--   
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Float
--   3.0
--   </pre>
--   
--   Users should take care to pick a return type that is wide enough to
--   contain the full length of the list. If the width is insufficient, the
--   overflow behaviour will depend on the <tt>(+)</tt> implementation in
--   the selected <a>Num</a> instance. The following example overflows
--   because the actual list length of 200 lies outside of the
--   <tt>Int8</tt> range of <tt>-128..127</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1..200] :: Int8
--   -56
--   </pre>
genericLength :: Num i => [a] -> i

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]


-- | <tt>List</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.List.Partial as L'
--   </pre>
module RIO.List.Partial

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching,
--   <a>uncons</a> or <a>listToMaybe</a> instead.
head :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching, <a>uncons</a> or <a>listToMaybe</a> instead.
last :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching or
--   <a>uncons</a> instead.
tail :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching or <a>uncons</a> instead.
init :: HasCallStack => [a] -> [a]

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A strict version of <a>foldl1</a>.
foldl1' :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>atMay</a> instead.
(!!) :: HasCallStack => [a] -> Int -> a
infixl 9 !!


-- | Strict <tt>Map</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.Map as Map
--   </pre>
--   
--   This module does not export any partial or unchecked functions. For
--   those, see <a>RIO.Map.Partial</a> and <a>RIO.Map.Unchecked</a>
module RIO.Map

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data () => Map k a

-- | &lt;math&gt;. Find the value at a key. Returns <a>Nothing</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5, 'a'), (3, 'b')] !? 1 == Nothing
--   </pre>
--   
--   <pre>
--   fromList [(5, 'a'), (3, 'b')] !? 5 == Just 'a'
--   </pre>
(!?) :: Ord k => Map k a -> k -> Maybe a
infixl 9 !?

-- | Same as <a>difference</a>.
(\\) :: Ord k => Map k a -> Map k b -> Map k a
infixl 9 \\

-- | &lt;math&gt;. Is the map empty?
--   
--   <pre>
--   Data.Map.null (empty)           == True
--   Data.Map.null (singleton 1 'a') == False
--   </pre>
null :: Map k a -> Bool

-- | &lt;math&gt;. The number of elements in the map.
--   
--   <pre>
--   size empty                                   == 0
--   size (singleton 1 'a')                       == 1
--   size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3
--   </pre>
size :: Map k a -> Int

-- | &lt;math&gt;. Is the key a member of the map? See also
--   <a>notMember</a>.
--   
--   <pre>
--   member 5 (fromList [(5,'a'), (3,'b')]) == True
--   member 1 (fromList [(5,'a'), (3,'b')]) == False
--   </pre>
member :: Ord k => k -> Map k a -> Bool

-- | &lt;math&gt;. Is the key not a member of the map? See also
--   <a>member</a>.
--   
--   <pre>
--   notMember 5 (fromList [(5,'a'), (3,'b')]) == False
--   notMember 1 (fromList [(5,'a'), (3,'b')]) == True
--   </pre>
notMember :: Ord k => k -> Map k a -> Bool

-- | &lt;math&gt;. Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as <tt>(<a>Just</a>
--   value)</tt>, or <a>Nothing</a> if the key isn't in the map.
--   
--   An example of using <tt>lookup</tt>:
--   
--   <pre>
--   import Prelude hiding (lookup)
--   import Data.Map
--   
--   employeeDept = fromList([("John","Sales"), ("Bob","IT")])
--   deptCountry = fromList([("IT","USA"), ("Sales","France")])
--   countryCurrency = fromList([("USA", "Dollar"), ("France", "Euro")])
--   
--   employeeCurrency :: String -&gt; Maybe String
--   employeeCurrency name = do
--       dept &lt;- lookup name employeeDept
--       country &lt;- lookup dept deptCountry
--       lookup country countryCurrency
--   
--   main = do
--       putStrLn $ "John's currency: " ++ (show (employeeCurrency "John"))
--       putStrLn $ "Pete's currency: " ++ (show (employeeCurrency "Pete"))
--   </pre>
--   
--   The output of this program:
--   
--   <pre>
--   John's currency: Just "Euro"
--   Pete's currency: Nothing
--   </pre>
lookup :: Ord k => k -> Map k a -> Maybe a

-- | &lt;math&gt;. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns default value
--   <tt>def</tt> when the key is not in the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
--   findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'
--   </pre>
findWithDefault :: Ord k => a -> k -> Map k a -> a

-- | &lt;math&gt;. Find largest key smaller than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   </pre>
lookupLT :: Ord k => k -> Map k v -> Maybe (k, v)

-- | &lt;math&gt;. Find smallest key greater than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGT :: Ord k => k -> Map k v -> Maybe (k, v)

-- | &lt;math&gt;. Find largest key smaller or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   </pre>
lookupLE :: Ord k => k -> Map k v -> Maybe (k, v)

-- | &lt;math&gt;. Find smallest key greater or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGE :: Ord k => k -> Map k v -> Maybe (k, v)

-- | &lt;math&gt;. The empty map.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: Map k a

-- | &lt;math&gt;. A map with a single element.
--   
--   <pre>
--   singleton 1 'a'        == fromList [(1, 'a')]
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: k -> a -> Map k a

-- | &lt;math&gt;. Insert a new key and value in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value. <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Ord k => k -> a -> Map k a -> Map k a

-- | &lt;math&gt;. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a

-- | &lt;math&gt;. Insert with a function, combining key, new value and old
--   value. <tt><a>insertWithKey</a> f key value mp</tt> will insert the
--   pair (key, value) into <tt>mp</tt> if key does not exist in the map.
--   If the key does exist, the function will insert the pair <tt>(key,f
--   key new_value old_value)</tt>. Note that the key passed to f is the
--   same key passed to <a>insertWithKey</a>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
--   insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a

-- | &lt;math&gt;. Combines insert operation with old value retrieval. The
--   expression (<tt><a>insertLookupWithKey</a> f k x map</tt>) is a pair
--   where the first element is equal to (<tt><a>lookup</a> k map</tt>) and
--   the second element equal to (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
--   insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
--   insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
--   insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])
--   </pre>
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)

-- | &lt;math&gt;. Delete a key and its value from the map. When the key is
--   not a member of the map, the original map is returned.
--   
--   <pre>
--   delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   delete 5 empty                         == empty
--   </pre>
delete :: Ord k => k -> Map k a -> Map k a

-- | &lt;math&gt;. Update a value at a specific key with the result of the
--   provided function. When the key is not a member of the map, the
--   original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjust ("new " ++) 7 empty                         == empty
--   </pre>
adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjustWithKey f 7 empty                         == empty
--   </pre>
adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a

-- | &lt;math&gt;. The expression (<tt><a>updateWithKey</a> f k map</tt>)
--   updates the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If
--   (<tt>f k x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a

-- | &lt;math&gt;. Lookup and update. See also <a>updateWithKey</a>. The
--   function returns changed value, if it is updated. Returns the original
--   key value if the map entry is deleted.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "5:new a", fromList [(3, "b"), (5, "5:new a")])
--   updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
--   updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")
--   </pre>
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)

-- | &lt;math&gt;. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in a <a>Map</a>. In
--   short : <tt><a>lookup</a> k (<a>alter</a> f k m) = f (<a>lookup</a> k
--   m)</tt>.
--   
--   <pre>
--   let f _ = Nothing
--   alter f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   alter f 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   
--   let f _ = Just "c"
--   alter f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "c")]
--   alter f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "c")]
--   </pre>
--   
--   Note that <tt><a>adjust</a> = alter . fmap</tt>.
alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a

-- | &lt;math&gt;. The expression (<tt><a>alterF</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alterF</a>
--   can be used to inspect, insert, delete, or update a value in a
--   <a>Map</a>. In short: <tt><a>lookup</a> k &lt;$&gt; <a>alterF</a> f k
--   m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; Map Int String -&gt; IO (Map Int String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   <a>alterF</a> is the most general operation for working with an
--   individual key that may or may not be in a given map. When used with
--   trivial functors like <a>Identity</a> and <a>Const</a>, it is often
--   slightly slower than more specialized combinators like <a>lookup</a>
--   and <a>insert</a>. However, when the functor is non-trivial and key
--   comparison is not particularly cheap, it is the fastest way.
--   
--   Note on rewrite rules:
--   
--   This module includes GHC rewrite rules to optimize <a>alterF</a> for
--   the <a>Const</a> and <a>Identity</a> functors. In general, these rules
--   improve performance. The sole exception is that when using
--   <a>Identity</a>, deleting a key that is already absent takes longer
--   than it would without the rules. If you expect this to occur a very
--   large fraction of the time, you might consider using a private copy of
--   the <a>Identity</a> type.
--   
--   Note: <a>alterF</a> is a flipped version of the <tt>at</tt> combinator
--   from <tt>Control.Lens.At</tt>.
alterF :: (Functor f, Ord k) => (Maybe a -> f (Maybe a)) -> k -> Map k a -> f (Map k a)

-- | &lt;math&gt;. The expression (<tt><a>union</a> t1 t2</tt>) takes the
--   left-biased union of <tt>t1</tt> and <tt>t2</tt>. It prefers
--   <tt>t1</tt> when duplicate keys are encountered, i.e.
--   (<tt><a>union</a> == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Ord k => Map k a -> Map k a -> Map k a

-- | &lt;math&gt;. Union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]
--   </pre>
unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a

-- | &lt;math&gt;. Union with a combining function.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]
--   </pre>
unionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a

-- | The union of a list of maps: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
--   
--   <pre>
--   unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
--       == fromList [(3, "B3"), (5, "A3"), (7, "C")]
--   </pre>
unions :: (Foldable f, Ord k) => f (Map k a) -> Map k a

-- | The union of a list of maps, with a combining operation:
--   (<tt><a>unionsWith</a> f == <a>foldl</a> (<a>unionWith</a> f)
--   <a>empty</a></tt>).
--   
--   <pre>
--   unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]
--   </pre>
unionsWith :: (Foldable f, Ord k) => (a -> a -> a) -> f (Map k a) -> Map k a

-- | &lt;math&gt;. Difference of two maps. Return elements of the first map
--   not existing in the second map.
--   
--   <pre>
--   difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"
--   </pre>
difference :: Ord k => Map k a -> Map k b -> Map k a

-- | &lt;math&gt;. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the values
--   of these keys. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
--       == singleton 3 "b:B"
--   </pre>
differenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a

-- | &lt;math&gt;. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
--       == singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a

-- | &lt;math&gt;. Intersection of two maps. Return data in the first map
--   for the keys existing in both maps. (<tt><a>intersection</a> m1 m2 ==
--   <a>intersectionWith</a> <a>const</a> m1 m2</tt>).
--   
--   <pre>
--   intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"
--   </pre>
intersection :: Ord k => Map k a -> Map k b -> Map k a

-- | &lt;math&gt;. Intersection with a combining function.
--   
--   <pre>
--   intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"
--   </pre>
intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c

-- | &lt;math&gt;. Intersection with a combining function.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c

-- | &lt;math&gt;. An unsafe universal combining function.
--   
--   WARNING: This function can produce corrupt maps and its results may
--   depend on the internal structures of its inputs. Users should prefer
--   <a>merge</a> or <a>mergeA</a>.
--   
--   When <a>mergeWithKey</a> is given three arguments, it is inlined to
--   the call site. You should therefore use <a>mergeWithKey</a> only to
--   define custom combining functions. For example, you could define
--   <a>unionWithKey</a>, <a>differenceWithKey</a> and
--   <a>intersectionWithKey</a> as
--   
--   <pre>
--   myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
--   myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
--   myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2
--   </pre>
--   
--   When calling <tt><a>mergeWithKey</a> combine only1 only2</tt>, a
--   function combining two <a>Map</a>s is created, such that
--   
--   <ul>
--   <li>if a key is present in both maps, it is passed with both
--   corresponding values to the <tt>combine</tt> function. Depending on
--   the result, the key is either present in the result with specified
--   value, or is left out;</li>
--   <li>a nonempty subtree present only in the first map is passed to
--   <tt>only1</tt> and the output is added to the result;</li>
--   <li>a nonempty subtree present only in the second map is passed to
--   <tt>only2</tt> and the output is added to the result.</li>
--   </ul>
--   
--   The <tt>only1</tt> and <tt>only2</tt> methods <i>must return a map
--   with a subset (possibly empty) of the keys of the given map</i>. The
--   values can be modified arbitrarily. Most common variants of
--   <tt>only1</tt> and <tt>only2</tt> are <a>id</a> and <tt><a>const</a>
--   <a>empty</a></tt>, but for example <tt><a>map</a> f</tt> or
--   <tt><a>filterWithKey</a> f</tt> could be used for any <tt>f</tt>.
mergeWithKey :: Ord k => (k -> a -> b -> Maybe c) -> (Map k a -> Map k c) -> (Map k b -> Map k c) -> Map k a -> Map k b -> Map k c

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]
--   </pre>
map :: (a -> b) -> Map k a -> Map k b

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]
--   </pre>
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b

-- | &lt;math&gt;. <tt><a>traverseWithKey</a> f m == <a>fromList</a>
--   &lt;$&gt; <a>traverse</a> (\(k, v) -&gt; (v' -&gt; v' `seq` (k,v'))
--   &lt;$&gt; f k v) (<a>toList</a> m)</tt> That is, it behaves much like
--   a regular <a>traverse</a> except that the traversing function also has
--   access to the key associated with a value and the values are forced
--   before they are installed in the result map.
--   
--   <pre>
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing
--   </pre>
traverseWithKey :: Applicative t => (k -> a -> t b) -> Map k a -> t (Map k b)

-- | &lt;math&gt;. Traverse keys/values and collect the <a>Just</a>
--   results.
traverseMaybeWithKey :: Applicative f => (k -> a -> f (Maybe b)) -> Map k a -> f (Map k b)

-- | &lt;math&gt;. The function <a>mapAccum</a> threads an accumulating
--   argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)

-- | &lt;math&gt;. The function <a>mapAccumWithKey</a> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)

-- | &lt;math&gt;. The function <a>mapAccumRWithKey</a> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)

-- | &lt;math&gt;. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   <pre>
--   mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
--   mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"
--   </pre>
mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a

-- | &lt;math&gt;. <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>. The value at the greater of the two
--   original keys is used as the first argument to <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a

-- | &lt;math&gt;. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> Map k a -> b

-- | &lt;math&gt;. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> Map k b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"
--   </pre>
foldrWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
--   
--   <pre>
--   let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"
--   </pre>
foldlWithKey :: (a -> k -> b -> a) -> a -> Map k b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   monoid, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Monoid m => (k -> a -> m) -> Map k a -> m

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Map k a -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Map k b -> a

-- | &lt;math&gt;. A strict version of <a>foldrWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldrWithKey' :: (k -> a -> b -> b) -> b -> Map k a -> b

-- | &lt;math&gt;. A strict version of <a>foldlWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldlWithKey' :: (a -> k -> b -> a) -> a -> Map k b -> a

-- | &lt;math&gt;. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
--   
--   <pre>
--   elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
--   elems empty == []
--   </pre>
elems :: Map k a -> [a]

-- | &lt;math&gt;. Return all keys of the map in ascending order. Subject
--   to list fusion.
--   
--   <pre>
--   keys (fromList [(5,"a"), (3,"b")]) == [3,5]
--   keys empty == []
--   </pre>
keys :: Map k a -> [k]

-- | &lt;math&gt;. An alias for <a>toAscList</a>. Return all key/value
--   pairs in the map in ascending key order. Subject to list fusion.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: Map k a -> [(k, a)]

-- | &lt;math&gt;. The set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [(5,"a"), (3,"b")]) == Data.Set.fromList [3,5]
--   keysSet empty == Data.Set.empty
--   </pre>
keysSet :: Map k a -> Set k

-- | &lt;math&gt;. Build a map from a set of keys and a function which for
--   each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; replicate k 'a') (Data.Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
--   fromSet undefined Data.Set.empty == empty
--   </pre>
fromSet :: (k -> a) -> Set k -> Map k a

-- | &lt;math&gt;. Convert the map to a list of key/value pairs. Subject to
--   list fusion.
--   
--   <pre>
--   toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   toList empty == []
--   </pre>
toList :: Map k a -> [(k, a)]

-- | &lt;math&gt;. Build a map from a list of key/value pairs. See also
--   <a>fromAscList</a>. If the list contains more than one value for the
--   same key, the last value for the key is retained.
--   
--   If the keys of the list are ordered, linear-time implementation is
--   used, with the performance equal to <a>fromDistinctAscList</a>.
--   
--   <pre>
--   fromList [] == empty
--   fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
--   fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]
--   </pre>
fromList :: Ord k => [(k, a)] -> Map k a

-- | &lt;math&gt;. Build a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a

-- | &lt;math&gt;. Build a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWithKey</a>.
--   
--   <pre>
--   let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   fromListWithKey f [] == empty
--   </pre>
fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in ascending order. Subject to list fusion.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: Map k a -> [(k, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in descending order. Subject to list fusion.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: Map k a -> [(k, a)]

-- | &lt;math&gt;. Filter all values that satisfy the predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
--   filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty
--   </pre>
filter :: (a -> Bool) -> Map k a -> Map k a

-- | &lt;math&gt;. Filter all keys/values that satisfy the predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
filterWithKey :: (k -> a -> Bool) -> Map k a -> Map k a

-- | &lt;math&gt;. Restrict a <a>Map</a> to only those keys found in a
--   <a>Set</a>.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`member`</a> s) m
--   m `restrictKeys` s = m <a>`intersection`</a> <a>fromSet</a> (const ()) s
--   </pre>
restrictKeys :: Ord k => Map k a -> Set k -> Map k a

-- | &lt;math&gt;. Remove all keys in a <a>Set</a> from a <a>Map</a>.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`notMember`</a> s) m
--   m `withoutKeys` s = m <a>`difference`</a> <a>fromSet</a> (const ()) s
--   </pre>
withoutKeys :: Ord k => Map k a -> Set k -> Map k a

-- | &lt;math&gt;. Partition the map according to a predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partition :: (a -> Bool) -> Map k a -> (Map k a, Map k a)

-- | &lt;math&gt;. Partition the map according to a predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partitionWithKey :: (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)

-- | &lt;math&gt;. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all keys <tt>j</tt> and <tt>k</tt>
--   in the map, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>. See note at
--   <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> (p . fst) . <a>toList</a>
--   takeWhileAntitone p = <a>filterWithKey</a> (k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (k -> Bool) -> Map k a -> Map k a

-- | &lt;math&gt;. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all keys <tt>j</tt> and <tt>k</tt>
--   in the map, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>. See note at
--   <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> (p . fst) . <a>toList</a>
--   dropWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (k -> Bool) -> Map k a -> Map k a

-- | &lt;math&gt;. Divide a map at the point where a predicate on the keys
--   stops holding. The user is responsible for ensuring that for all keys
--   <tt>j</tt> and <tt>k</tt> in the map, <tt>j &lt; k ==&gt; p j &gt;= p
--   k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = partitionWithKey (\k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point where the predicate switches from holding to not holding (where
--   the predicate is seen to hold before the first key and to fail after
--   the last key).
spanAntitone :: (k -> Bool) -> Map k a -> (Map k a, Map k a)

-- | &lt;math&gt;. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b

-- | &lt;math&gt;. Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b

-- | &lt;math&gt;. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])
--   
--   mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--   </pre>
mapEither :: (a -> Either b c) -> Map k a -> (Map k b, Map k c)

-- | &lt;math&gt;. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])
--   </pre>
mapEitherWithKey :: (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)

-- | &lt;math&gt;. The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where the keys in <tt>map1</tt> are smaller than
--   <tt>k</tt> and the keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
--   split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
--   split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
--   split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)
--   </pre>
split :: Ord k => k -> Map k a -> (Map k a, Map k a)

-- | &lt;math&gt;. The expression (<tt><a>splitLookup</a> k map</tt>)
--   splits a map just like <a>split</a> but also returns <tt><a>lookup</a>
--   k map</tt>.
--   
--   <pre>
--   splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
--   splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
--   splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
--   splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
--   splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)
--   </pre>
splitLookup :: Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)

-- | &lt;math&gt;. Decompose a map into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList (zip [1..6] ['a'..])) ==
--     [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d')],fromList [(5,'e'),(6,'f')]]
--   </pre>
--   
--   <pre>
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than three
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: Map k b -> [Map k b]

-- | &lt;math&gt;. This function is defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool

-- | &lt;math&gt;. The expression (<tt><a>isSubmapOfBy</a> f t1 t2</tt>)
--   returns <a>True</a> if all keys in <tt>t1</tt> are in tree
--   <tt>t2</tt>, and when <tt>f</tt> returns <a>True</a> when applied to
--   their respective values. For example, the following expressions are
--   all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (&lt;=) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1),('b',2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [('a',2)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (&lt;)  (fromList [('a',1)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1)])
--   </pre>
--   
--   Note that <tt>isSubmapOfBy (_ _ -&gt; True) m1 m2</tt> tests whether
--   all the keys in <tt>m1</tt> are also keys in <tt>m2</tt>.
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a>
--   (==)</tt>).
isProperSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns
--   <a>True</a> when <tt>keys m1</tt> and <tt>keys m2</tt> are not equal,
--   all keys in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt>
--   returns <a>True</a> when applied to their respective values. For
--   example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
--   </pre>
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool

-- | &lt;math&gt;. Lookup the <i>index</i> of a key, which is its
--   zero-based index in the sequence sorted by keys. The index is a number
--   from <i>0</i> up to, but not including, the <a>size</a> of the map.
--   
--   <pre>
--   isJust (lookupIndex 2 (fromList [(5,"a"), (3,"b")]))   == False
--   fromJust (lookupIndex 3 (fromList [(5,"a"), (3,"b")])) == 0
--   fromJust (lookupIndex 5 (fromList [(5,"a"), (3,"b")])) == 1
--   isJust (lookupIndex 6 (fromList [(5,"a"), (3,"b")]))   == False
--   </pre>
lookupIndex :: Ord k => k -> Map k a -> Maybe Int

-- | &lt;math&gt;. Retrieve an element by its <i>index</i>, i.e. by its
--   zero-based index in the sequence sorted by keys. If the <i>index</i>
--   is out of range (less than zero, greater or equal to <a>size</a> of
--   the map), <a>error</a> is called.
--   
--   <pre>
--   elemAt 0 (fromList [(5,"a"), (3,"b")]) == (3,"b")
--   elemAt 1 (fromList [(5,"a"), (3,"b")]) == (5, "a")
--   elemAt 2 (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   </pre>
elemAt :: Int -> Map k a -> (k, a)

-- | &lt;math&gt;. Delete the element at <i>index</i>, i.e. by its
--   zero-based index in the sequence sorted by keys. If the <i>index</i>
--   is out of range (less than zero, greater or equal to <a>size</a> of
--   the map), <a>error</a> is called.
--   
--   <pre>
--   deleteAt 0  (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   deleteAt 1  (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   deleteAt 2 (fromList [(5,"a"), (3,"b")])     Error: index out of range
--   deleteAt (-1) (fromList [(5,"a"), (3,"b")])  Error: index out of range
--   </pre>
deleteAt :: Int -> Map k a -> Map k a

-- | &lt;math&gt;. Take a given number of entries in key order, beginning
--   with the smallest keys.
--   
--   <pre>
--   take n = <a>fromDistinctAscList</a> . <a>take</a> n . <a>toAscList</a>
--   </pre>
take :: Int -> Map k a -> Map k a

-- | &lt;math&gt;. Drop a given number of entries in key order, beginning
--   with the smallest keys.
--   
--   <pre>
--   drop n = <a>fromDistinctAscList</a> . <a>drop</a> n . <a>toAscList</a>
--   </pre>
drop :: Int -> Map k a -> Map k a

-- | &lt;math&gt;. Split a map at a particular index.
--   
--   <pre>
--   splitAt !n !xs = (<a>take</a> n xs, <a>drop</a> n xs)
--   </pre>
splitAt :: Int -> Map k a -> (Map k a, Map k a)

-- | &lt;math&gt;. The minimal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
--   
--   <pre>
--   lookupMin (fromList [(5,"a"), (3,"b")]) == Just (3,"b")
--   lookupMin empty = Nothing
--   </pre>
lookupMin :: Map k a -> Maybe (k, a)

-- | &lt;math&gt;. The maximal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
--   
--   <pre>
--   lookupMax (fromList [(5,"a"), (3,"b")]) == Just (5,"a")
--   lookupMax empty = Nothing
--   </pre>
lookupMax :: Map k a -> Maybe (k, a)

-- | &lt;math&gt;. Delete the minimal key. Returns an empty map if the map
--   is empty.
--   
--   <pre>
--   deleteMin (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(5,"a"), (7,"c")]
--   deleteMin empty == empty
--   </pre>
deleteMin :: Map k a -> Map k a

-- | &lt;math&gt;. Delete the maximal key. Returns an empty map if the map
--   is empty.
--   
--   <pre>
--   deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(3,"b"), (5,"a")]
--   deleteMax empty == empty
--   </pre>
deleteMax :: Map k a -> Map k a

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> Map k a -> Map k a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> Map k a -> Map k a

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMinWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a

-- | &lt;math&gt;. Retrieves the value associated with minimal key of the
--   map, and the map stripped of that element, or <a>Nothing</a> if passed
--   an empty map.
--   
--   <pre>
--   minView (fromList [(5,"a"), (3,"b")]) == Just ("b", singleton 5 "a")
--   minView empty == Nothing
--   </pre>
minView :: Map k a -> Maybe (a, Map k a)

-- | &lt;math&gt;. Retrieves the value associated with maximal key of the
--   map, and the map stripped of that element, or <a>Nothing</a> if passed
--   an empty map.
--   
--   <pre>
--   maxView (fromList [(5,"a"), (3,"b")]) == Just ("a", singleton 3 "b")
--   maxView empty == Nothing
--   </pre>
maxView :: Map k a -> Maybe (a, Map k a)

-- | &lt;math&gt;. Retrieves the minimal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: Map k a -> Maybe ((k, a), Map k a)

-- | &lt;math&gt;. Retrieves the maximal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: Map k a -> Maybe ((k, a), Map k a)

-- | &lt;math&gt;. Show the tree that implements the map. The tree is shown
--   in a compressed, hanging format. See <a>showTreeWith</a>.
showTree :: (Show k, Show a) => Map k a -> String

-- | &lt;math&gt;. The expression (<tt><a>showTreeWith</a> showelem hang
--   wide map</tt>) shows the tree that implements the map. Elements are
--   shown using the <tt>showElem</tt> function. If <tt>hang</tt> is
--   <a>True</a>, a <i>hanging</i> tree is shown otherwise a rotated tree
--   is shown. If <tt>wide</tt> is <a>True</a>, an extra wide version is
--   shown.
--   
--   <pre>
--   Map&gt; let t = fromDistinctAscList [(x,()) | x &lt;- [1..5]]
--   Map&gt; putStrLn $ showTreeWith (\k x -&gt; show (k,x)) True False t
--   (4,())
--   +--(2,())
--   |  +--(1,())
--   |  +--(3,())
--   +--(5,())
--   
--   Map&gt; putStrLn $ showTreeWith (\k x -&gt; show (k,x)) True True t
--   (4,())
--   |
--   +--(2,())
--   |  |
--   |  +--(1,())
--   |  |
--   |  +--(3,())
--   |
--   +--(5,())
--   
--   Map&gt; putStrLn $ showTreeWith (\k x -&gt; show (k,x)) False True t
--   +--(5,())
--   |
--   (4,())
--   |
--   |  +--(3,())
--   |  |
--   +--(2,())
--      |
--      +--(1,())
--   </pre>
showTreeWith :: (k -> a -> String) -> Bool -> Bool -> Map k a -> String

-- | &lt;math&gt;. Test if the internal map structure is valid.
--   
--   <pre>
--   valid (fromAscList [(3,"b"), (5,"a")]) == True
--   valid (fromAscList [(5,"a"), (3,"b")]) == False
--   </pre>
valid :: Ord k => Map k a -> Bool


-- | Strict <tt>Map</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.Map.Partial as Map'
--   </pre>
module RIO.Map.Partial

-- | &lt;math&gt;. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
--   fromList [(5,'a'), (3,'b')] ! 5 == 'a'
--   </pre>
(!) :: Ord k => Map k a -> k -> a
infixl 9 !

-- | &lt;math&gt;. Retrieve an element by its <i>index</i>, i.e. by its
--   zero-based index in the sequence sorted by keys. If the <i>index</i>
--   is out of range (less than zero, greater or equal to <a>size</a> of
--   the map), <a>error</a> is called.
--   
--   <pre>
--   elemAt 0 (fromList [(5,"a"), (3,"b")]) == (3,"b")
--   elemAt 1 (fromList [(5,"a"), (3,"b")]) == (5, "a")
--   elemAt 2 (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   </pre>
elemAt :: Int -> Map k a -> (k, a)

-- | &lt;math&gt;. Delete the element at <i>index</i>, i.e. by its
--   zero-based index in the sequence sorted by keys. If the <i>index</i>
--   is out of range (less than zero, greater or equal to <a>size</a> of
--   the map), <a>error</a> is called.
--   
--   <pre>
--   deleteAt 0  (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   deleteAt 1  (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   deleteAt 2 (fromList [(5,"a"), (3,"b")])     Error: index out of range
--   deleteAt (-1) (fromList [(5,"a"), (3,"b")])  Error: index out of range
--   </pre>
deleteAt :: Int -> Map k a -> Map k a

-- | &lt;math&gt;. Return the <i>index</i> of a key, which is its
--   zero-based index in the sequence sorted by keys. The index is a number
--   from <i>0</i> up to, but not including, the <a>size</a> of the map.
--   Calls <a>error</a> when the key is not a <a>member</a> of the map.
--   
--   <pre>
--   findIndex 2 (fromList [(5,"a"), (3,"b")])    Error: element is not in the map
--   findIndex 3 (fromList [(5,"a"), (3,"b")]) == 0
--   findIndex 5 (fromList [(5,"a"), (3,"b")]) == 1
--   findIndex 6 (fromList [(5,"a"), (3,"b")])    Error: element is not in the map
--   </pre>
findIndex :: Ord k => k -> Map k a -> Int

-- | &lt;math&gt;. Update the element at <i>index</i>. Calls <a>error</a>
--   when an invalid index is used.
--   
--   <pre>
--   updateAt (\ _ _ -&gt; Just "x") 0    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "x"), (5, "a")]
--   updateAt (\ _ _ -&gt; Just "x") 1    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "x")]
--   updateAt (\ _ _ -&gt; Just "x") 2    (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   updateAt (\ _ _ -&gt; Just "x") (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   updateAt (\_ _  -&gt; Nothing)  0    (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   updateAt (\_ _  -&gt; Nothing)  1    (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   updateAt (\_ _  -&gt; Nothing)  2    (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   updateAt (\_ _  -&gt; Nothing)  (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   </pre>
updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a

-- | &lt;math&gt;. The minimal key of the map. Calls <a>error</a> if the
--   map is empty.
--   
--   <pre>
--   findMin (fromList [(5,"a"), (3,"b")]) == (3,"b")
--   findMin empty                            Error: empty map has no minimal element
--   </pre>
findMin :: Map k a -> (k, a)

-- | &lt;math&gt;. The maximal key of the map. Calls <a>error</a> if the
--   map is empty.
--   
--   <pre>
--   findMax (fromList [(5,"a"), (3,"b")]) == (5,"a")
--   findMax empty                            Error: empty map has no maximal element
--   </pre>
findMax :: Map k a -> (k, a)

-- | &lt;math&gt;. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin (fromList [(5,"a"), (3,"b"), (10,"c")]) == ((3,"b"), fromList[(5,"a"), (10,"c")])
--   deleteFindMin empty                                      Error: can not return the minimal element of an empty map
--   </pre>
deleteFindMin :: Map k a -> ((k, a), Map k a)

-- | &lt;math&gt;. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax (fromList [(5,"a"), (3,"b"), (10,"c")]) == ((10,"c"), fromList [(3,"b"), (5,"a")])
--   deleteFindMax empty                                      Error: can not return the maximal element of an empty map
--   </pre>
deleteFindMax :: Map k a -> ((k, a), Map k a)


-- | This module contains functions from <a>Data.Map.Strict</a> that have
--   unchecked preconditions on their input. If these preconditions are not
--   satisfied, the data structure may end up in an invalid state and other
--   operations may misbehave. Import as:
--   
--   <pre>
--   import qualified RIO.Map.Unchecked as Map'
--   </pre>
module RIO.Map.Unchecked

-- | &lt;math&gt;. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   valid (mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")])) == True
--   valid (mapKeysMonotonic (\ _ -&gt; 1)     (fromList [(5,"a"), (3,"b")])) == False
--   </pre>
mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in ascending order. Subject to list fusion.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: Map k a -> [(k, a)]

-- | &lt;math&gt;. Build a map from an ascending list in linear time.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   valid (fromAscList [(3,"b"), (5,"a"), (5,"b")]) == True
--   valid (fromAscList [(5,"a"), (3,"b"), (5,"b")]) == False
--   </pre>
fromAscList :: Eq k => [(k, a)] -> Map k a

-- | &lt;math&gt;. Build a map from an ascending list in linear time with a
--   combining function for equal keys. <i>The precondition (input list is
--   ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   valid (fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")]) == True
--   valid (fromAscListWith (++) [(5,"a"), (3,"b"), (5,"b")]) == False
--   </pre>
fromAscListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a

-- | &lt;math&gt;. Build a map from an ascending list in linear time with a
--   combining function for equal keys. <i>The precondition (input list is
--   ascending) is not checked.</i>
--   
--   <pre>
--   let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2
--   fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")] == fromList [(3, "b"), (5, "5:b5:ba")]
--   valid (fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")]) == True
--   valid (fromAscListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) == False
--   </pre>
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a

-- | &lt;math&gt;. Build a map from an ascending list of distinct elements
--   in linear time. <i>The precondition is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   valid (fromDistinctAscList [(3,"b"), (5,"a")])          == True
--   valid (fromDistinctAscList [(3,"b"), (5,"a"), (5,"b")]) == False
--   </pre>
fromDistinctAscList :: [(k, a)] -> Map k a

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in descending order. Subject to list fusion.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: Map k a -> [(k, a)]

-- | &lt;math&gt;. Build a map from a descending list in linear time.
--   <i>The precondition (input list is descending) is not checked.</i>
--   
--   <pre>
--   fromDescList [(5,"a"), (3,"b")]          == fromList [(3, "b"), (5, "a")]
--   fromDescList [(5,"a"), (5,"b"), (3,"a")] == fromList [(3, "b"), (5, "b")]
--   valid (fromDescList [(5,"a"), (5,"b"), (3,"b")]) == True
--   valid (fromDescList [(5,"a"), (3,"b"), (5,"b")]) == False
--   </pre>
fromDescList :: Eq k => [(k, a)] -> Map k a

-- | &lt;math&gt;. Build a map from a descending list in linear time with a
--   combining function for equal keys. <i>The precondition (input list is
--   descending) is not checked.</i>
--   
--   <pre>
--   fromDescListWith (++) [(5,"a"), (5,"b"), (3,"b")] == fromList [(3, "b"), (5, "ba")]
--   valid (fromDescListWith (++) [(5,"a"), (5,"b"), (3,"b")]) == True
--   valid (fromDescListWith (++) [(5,"a"), (3,"b"), (5,"b")]) == False
--   </pre>
fromDescListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a

-- | &lt;math&gt;. Build a map from a descending list in linear time with a
--   combining function for equal keys. <i>The precondition (input list is
--   descending) is not checked.</i>
--   
--   <pre>
--   let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2
--   fromDescListWithKey f [(5,"a"), (5,"b"), (5,"b"), (3,"b")] == fromList [(3, "b"), (5, "5:b5:ba")]
--   valid (fromDescListWithKey f [(5,"a"), (5,"b"), (5,"b"), (3,"b")]) == True
--   valid (fromDescListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) == False
--   </pre>
fromDescListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a

-- | &lt;math&gt;. Build a map from a descending list of distinct elements
--   in linear time. <i>The precondition is not checked.</i>
--   
--   <pre>
--   fromDistinctDescList [(5,"a"), (3,"b")] == fromList [(3, "b"), (5, "a")]
--   valid (fromDistinctDescList [(5,"a"), (3,"b")])          == True
--   valid (fromDistinctDescList [(5,"a"), (3,"b"), (3,"a")]) == False
--   </pre>
fromDistinctDescList :: [(k, a)] -> Map k a


-- | <tt>NonEmpty</tt> list. Import as:
--   
--   <pre>
--   import qualified RIO.NonEmpty as NE
--   </pre>
--   
--   This module does not export any partial functions. For those, see
--   <a>RIO.NonEmpty.Partial</a>
module RIO.NonEmpty

-- | Non-empty (and non-strict) list type.
data () => NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | Map a function over a <a>NonEmpty</a> stream.
map :: (a -> b) -> NonEmpty a -> NonEmpty b

-- | 'intersperse x xs' alternates elements of the list with copies of
--   <tt>x</tt>.
--   
--   <pre>
--   intersperse 0 (1 :| [2,3]) == 1 :| [0,2,0,3]
--   </pre>
intersperse :: a -> NonEmpty a -> NonEmpty a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a stream of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == z :| [z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == x1 :| [x1 `f` x2, x1 `f` (x2 `f` x3), ...]
--   </pre>
scanl1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>transpose</a> for <a>NonEmpty</a>, behaves the same as
--   <a>transpose</a> The rows/columns need not be the same length, in
--   which case &gt; transpose . transpose /= id
transpose :: NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)

-- | <a>sortBy</a> for <a>NonEmpty</a>, behaves the same as <a>sortBy</a>
sortBy :: (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a

-- | <a>sortWith</a> for <a>NonEmpty</a>, behaves the same as:
--   
--   <pre>
--   sortBy . comparing
--   </pre>
sortWith :: Ord o => (a -> o) -> NonEmpty a -> NonEmpty a

-- | Number of elements in <a>NonEmpty</a> list.
length :: NonEmpty a -> Int

-- | Extract the first element of the stream.
head :: NonEmpty a -> a

-- | Extract the possibly-empty tail of the stream.
tail :: NonEmpty a -> [a]

-- | Extract the last element of the stream.
last :: NonEmpty a -> a

-- | Extract everything except the last element of the stream.
init :: NonEmpty a -> [a]

-- | Prepend an element to the stream.
(<|) :: a -> NonEmpty a -> NonEmpty a
infixr 5 <|

-- | Synonym for <a>&lt;|</a>.
cons :: a -> NonEmpty a -> NonEmpty a

-- | <a>uncons</a> produces the first element of the stream, and a stream
--   of the remaining elements, if any.
uncons :: NonEmpty a -> (a, Maybe (NonEmpty a))

-- | The <a>unfoldr</a> function is analogous to <a>Data.List</a>'s
--   <a>unfoldr</a> operation.
unfoldr :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | Sort a stream.
sort :: Ord a => NonEmpty a -> NonEmpty a

-- | <a>reverse</a> a finite NonEmpty stream.
reverse :: NonEmpty a -> NonEmpty a

-- | The <a>inits</a> function takes a stream <tt>xs</tt> and returns all
--   the finite prefixes of <tt>xs</tt>, starting with the shortest. The
--   result is <a>NonEmpty</a> because the result always contains the empty
--   list as the first element.
--   
--   <pre>
--   inits [1,2,3] == [] :| [[1], [1,2], [1,2,3]]
--   inits [1] == [] :| [[1]]
--   inits [] == [] :| []
--   </pre>
inits :: Foldable f => f a -> NonEmpty [a]

-- | The <a>tails</a> function takes a stream <tt>xs</tt> and returns all
--   the suffixes of <tt>xs</tt>, starting with the longest. The result is
--   <a>NonEmpty</a> because the result always contains the empty list as
--   the last element.
--   
--   <pre>
--   tails [1,2,3] == [1,2,3] :| [[2,3], [3], []]
--   tails [1] == [1] :| [[]]
--   tails [] == [] :| []
--   </pre>
tails :: Foldable f => f a -> NonEmpty [a]

-- | <tt><a>iterate</a> f x</tt> produces the infinite sequence of repeated
--   applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   iterate f x = x :| [f x, f (f x), ..]
--   </pre>
iterate :: (a -> a) -> a -> NonEmpty a

-- | <tt><a>repeat</a> x</tt> returns a constant stream, where all elements
--   are equal to <tt>x</tt>.
repeat :: a -> NonEmpty a

-- | <tt><a>cycle</a> xs</tt> returns the infinite repetition of
--   <tt>xs</tt>:
--   
--   <pre>
--   cycle (1 :| [2,3]) = 1 :| [2,3,1,2,3,...]
--   </pre>
cycle :: NonEmpty a -> NonEmpty a

-- | <tt><a>insert</a> x xs</tt> inserts <tt>x</tt> into the last position
--   in <tt>xs</tt> where it is still less than or equal to the next
--   element. In particular, if the list is sorted beforehand, the result
--   will also be sorted.
insert :: (Foldable f, Ord a) => a -> f a -> NonEmpty a

-- | <tt><a>some1</a> x</tt> sequences <tt>x</tt> one or more times.
some1 :: Alternative f => f a -> f (NonEmpty a)

-- | <tt><a>take</a> n xs</tt> returns the first <tt>n</tt> elements of
--   <tt>xs</tt>.
take :: Int -> NonEmpty a -> [a]

-- | <tt><a>drop</a> n xs</tt> drops the first <tt>n</tt> elements off the
--   front of the sequence <tt>xs</tt>.
drop :: Int -> NonEmpty a -> [a]

-- | <tt><a>splitAt</a> n xs</tt> returns a pair consisting of the prefix
--   of <tt>xs</tt> of length <tt>n</tt> and the remaining stream
--   immediately following this prefix.
--   
--   <pre>
--   'splitAt' n xs == ('take' n xs, 'drop' n xs)
--   xs == ys ++ zs where (ys, zs) = 'splitAt' n xs
--   </pre>
splitAt :: Int -> NonEmpty a -> ([a], [a])

-- | <tt><a>takeWhile</a> p xs</tt> returns the longest prefix of the
--   stream <tt>xs</tt> for which the predicate <tt>p</tt> holds.
takeWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>dropWhile</a> p xs</tt> returns the suffix remaining after
--   <tt><a>takeWhile</a> p xs</tt>.
dropWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>span</a> p xs</tt> returns the longest prefix of <tt>xs</tt>
--   that satisfies <tt>p</tt>, together with the remainder of the stream.
--   
--   <pre>
--   'span' p xs == ('takeWhile' p xs, 'dropWhile' p xs)
--   xs == ys ++ zs where (ys, zs) = 'span' p xs
--   </pre>
span :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <tt><a>break</a> p</tt> function is equivalent to <tt><a>span</a>
--   (not . p)</tt>.
break :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | <tt><a>filter</a> p xs</tt> removes any elements from <tt>xs</tt> that
--   do not satisfy <tt>p</tt>.
filter :: (a -> Bool) -> NonEmpty a -> [a]

-- | The <a>partition</a> function takes a predicate <tt>p</tt> and a
--   stream <tt>xs</tt>, and returns a pair of lists. The first list
--   corresponds to the elements of <tt>xs</tt> for which <tt>p</tt> holds;
--   the second corresponds to the elements of <tt>xs</tt> for which
--   <tt>p</tt> does not hold.
--   
--   <pre>
--   'partition' p xs = ('filter' p xs, 'filter' (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <a>group</a> function takes a stream and returns a list of streams
--   such that flattening the resulting list is equal to the argument.
--   Moreover, each stream in the resulting list contains only equal
--   elements. For example, in list notation:
--   
--   <pre>
--   'group' $ 'cycle' "Mississippi"
--     = "M" : "i" : "ss" : "i" : "ss" : "i" : "pp" : "i" : "M" : "i" : ...
--   </pre>
group :: (Foldable f, Eq a) => f a -> [NonEmpty a]

-- | <a>groupBy</a> operates like <a>group</a>, but uses the provided
--   equality predicate instead of <a>==</a>.
groupBy :: Foldable f => (a -> a -> Bool) -> f a -> [NonEmpty a]

-- | <a>groupWith</a> operates like <a>group</a>, but uses the provided
--   projection when comparing for equality
groupWith :: (Foldable f, Eq b) => (a -> b) -> f a -> [NonEmpty a]

-- | <a>groupAllWith</a> operates like <a>groupWith</a>, but sorts the list
--   first so that each equivalence class has, at most, one list in the
--   output
groupAllWith :: Ord b => (a -> b) -> [a] -> [NonEmpty a]

-- | <a>group1</a> operates like <a>group</a>, but uses the knowledge that
--   its input is non-empty to produce guaranteed non-empty output.
group1 :: Eq a => NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupBy1</a> is to <a>group1</a> as <a>groupBy</a> is to
--   <a>group</a>.
groupBy1 :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupWith1</a> is to <a>group1</a> as <a>groupWith</a> is to
--   <a>group</a>
groupWith1 :: Eq b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupAllWith1</a> is to <a>groupWith1</a> as <a>groupAllWith</a> is
--   to <a>groupWith</a>
groupAllWith1 :: Ord b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | The <a>isPrefixOf</a> function returns <a>True</a> if the first
--   argument is a prefix of the second.
isPrefixOf :: Eq a => [a] -> NonEmpty a -> Bool

-- | The <a>nub</a> function removes duplicate elements from a list. In
--   particular, it keeps only the first occurrence of each element. (The
--   name <a>nub</a> means 'essence'.) It is a special case of
--   <a>nubBy</a>, which allows the programmer to supply their own
--   inequality test.
nub :: Eq a => NonEmpty a -> NonEmpty a

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty a

-- | The <a>zip</a> function takes two streams and returns a stream of
--   corresponding pairs.
zip :: NonEmpty a -> NonEmpty b -> NonEmpty (a, b)

-- | The <a>zipWith</a> function generalizes <a>zip</a>. Rather than
--   tupling the elements, the elements are combined using the function
--   passed as the first argument.
zipWith :: (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c

-- | The <a>unzip</a> function is the inverse of the <a>zip</a> function.
unzip :: Functor f => f (a, b) -> (f a, f b)

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: [a] -> Maybe (NonEmpty a)

-- | Convert a stream to a normal list efficiently.
toList :: NonEmpty a -> [a]

-- | Compute n-ary logic exclusive OR operation on <a>NonEmpty</a> list.
xor :: NonEmpty Bool -> Bool


-- | <tt>NonEmpty</tt> list partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.NonEmpty.Partial as NE'
--   </pre>
module RIO.NonEmpty.Partial

-- | <tt>xs !! n</tt> returns the element of the stream <tt>xs</tt> at
--   index <tt>n</tt>. Note that the head of the stream has index 0.
--   
--   <i>Beware</i>: a negative or out-of-bounds index will cause an error.
(!!) :: HasCallStack => NonEmpty a -> Int -> a
infixl 9 !!

-- | Converts a normal list to a <a>NonEmpty</a> stream.
--   
--   Raises an error if given an empty list.
fromList :: HasCallStack => [a] -> NonEmpty a


-- | Partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.Partial as RIO'
--   </pre>
module RIO.Partial

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   ...
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching instead.
fromJust :: HasCallStack => Maybe a -> a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

module RIO.Prelude.Types
data () => Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data () => Char

-- | <a>String</a> is an alias for a list of characters.
--   
--   String constants in Haskell are values of type <a>String</a>. That
--   means if you write a string literal like <tt>"hello world"</tt>, it
--   will have the type <tt>[Char]</tt>, which is the same as
--   <tt>String</tt>.
--   
--   <b>Note:</b> You can ask the compiler to automatically infer different
--   types with the <tt>-XOverloadedStrings</tt> language extension, for
--   example <tt>"hello world" :: Text</tt>. See <a>IsString</a> for more
--   information.
--   
--   Because <tt>String</tt> is just a list of characters, you can use
--   normal list functions to do basic string manipulation. See
--   <a>Data.List</a> for operations on lists.
--   
--   <h3><b>Performance considerations</b></h3>
--   
--   <tt>[Char]</tt> is a relatively memory-inefficient type. It is a
--   linked list of boxed word-size characters, internally it looks
--   something like:
--   
--   <pre>
--   ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭────╮
--   │ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ [] │
--   ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰────╯
--           v               v               v
--          'a'             'b'             'c'
--   </pre>
--   
--   The <tt>String</tt> "abc" will use <tt>5*3+1 = 16</tt> (in general
--   <tt>5n+1</tt>) words of space in memory.
--   
--   Furthermore, operations like <a>(++)</a> (string concatenation) are
--   <tt>O(n)</tt> (in the left argument).
--   
--   For historical reasons, the <tt>base</tt> library uses <tt>String</tt>
--   in a lot of places for the conceptual simplicity, but library code
--   dealing with user-data should use the <a>text</a> package for Unicode
--   text, or the the <a>bytestring</a> package for binary data.
type String = [Char]

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String
data () => Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data () => Int

-- | 8-bit signed integer type
data () => Int8

-- | 16-bit signed integer type
data () => Int16

-- | 32-bit signed integer type
data () => Int32

-- | 64-bit signed integer type
data () => Int64

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data () => Word

-- | 8-bit unsigned integer type
data () => Word8

-- | 16-bit unsigned integer type
data () => Word16

-- | 32-bit unsigned integer type
data () => Word32

-- | 64-bit unsigned integer type
data () => Word64

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data () => Integer

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data () => Natural

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data () => Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data () => Double

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data () => Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data () => Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Non-empty (and non-strict) list type.
data () => NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data () => Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | Uninhabited data type
data () => Void

-- | The <a>Const</a> functor.
newtype () => Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a

-- | Identity functor and monad. (a non-strict monad)
newtype () => Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data () => IO a

-- | The strict <a>ST</a> monad. The <a>ST</a> monad allows for destructive
--   updates, but is escapable (unlike IO). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and execute
--   in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data () => ST s a

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class () => Eq a

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class () => Bounded a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class () => Enum a

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class () => Show a

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class () => Read a

-- | <a>IsString</a> is used in combination with the
--   <tt>-XOverloadedStrings</tt> language extension to convert the
--   literals to different string types.
--   
--   For example, if you use the <a>text</a> package, you can say
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings  #-}
--   
--   myText = "hello world" :: Text
--   </pre>
--   
--   Internally, the extension will convert this to the equivalent of
--   
--   <pre>
--   myText = fromString @Text ("hello world" :: String)
--   </pre>
--   
--   <b>Note:</b> You can use <tt>fromString</tt> in normal code as well,
--   but the usual performance/memory efficiency problems with
--   <a>String</a> apply.
class () => IsString a

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   <li><i><b>Coherence with <tt>toInteger</tt></b></i> if the type also
--   implements <a>Integral</a>, then <a>fromInteger</a> is a left inverse
--   for <a>toInteger</a>, i.e. <tt>fromInteger (toInteger i) ==
--   i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class () => Num a

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   <li><i><b>Totality of <a>toRational</a></b></i> <a>toRational</a> is
--   total</li>
--   <li><i><b>Coherence with <a>toRational</a></b></i> if the type also
--   implements <a>Real</a>, then <a>fromRational</a> is a left inverse for
--   <a>toRational</a>, i.e. <tt>fromRational (toRational i) = i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a

-- | Real numbers.
--   
--   The Haskell report defines no laws for <a>Real</a>, however
--   <a>Real</a> instances are customarily expected to adhere to the
--   following law:
--   
--   <ul>
--   <li><i><b>Coherence with <a>fromRational</a></b></i> if the type also
--   implements <a>Fractional</a>, then <a>fromRational</a> is a left
--   inverse for <a>toRational</a>, i.e. <tt>fromRational (toRational i) =
--   i</tt></li>
--   </ul>
class (Num a, Ord a) => Real a

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
--   
--   In addition, <a>toInteger</a> should be total, and <a>fromInteger</a>
--   should be a left inverse for it, i.e. <tt>fromInteger (toInteger i) =
--   i</tt>.
class (Real a, Enum a) => Integral a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>. A partially applied
--   <a>Bifunctor</a> must be a <a>Functor</a> and the <a>second</a> method
--   must agree with <a>fmap</a>. From this it follows that:
--   
--   <pre>
--   <a>second</a> <a>id</a> = <a>id</a>
--   </pre>
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   Since 4.18.0.0 <a>Functor</a> is a superclass of 'Bifunctor.
class forall a. () => Functor p a => Bifunctor (p :: Type -> Type -> Type)

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class () => Foldable (t :: Type -> Type)

-- | <a>Bifoldable</a> identifies foldable structures with two different
--   varieties of elements (as opposed to <a>Foldable</a>, which has one
--   variety of element). Common examples are <a>Either</a> and
--   <tt>(,)</tt>:
--   
--   <pre>
--   instance Bifoldable Either where
--     bifoldMap f _ (Left  a) = f a
--     bifoldMap _ g (Right b) = g b
--   
--   instance Bifoldable (,) where
--     bifoldr f g z (a, b) = f a (g b z)
--   </pre>
--   
--   Some examples below also use the following BiList to showcase empty
--   Bifoldable behaviors when relevant (<a>Either</a> and <tt>(,)</tt>
--   containing always exactly resp. 1 and 2 elements):
--   
--   <pre>
--   data BiList a b = BiList [a] [b]
--   
--   instance Bifoldable BiList where
--     bifoldr f g z (BiList as bs) = foldr f (foldr g z bs) as
--   </pre>
--   
--   A minimal <a>Bifoldable</a> definition consists of either
--   <a>bifoldMap</a> or <a>bifoldr</a>. When defining more than this
--   minimal set, one should ensure that the following identities hold:
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   <a>bifoldr</a> f g z t ≡ <a>appEndo</a> (<a>bifoldMap</a> (Endo . f) (Endo . g) t) z
--   </pre>
--   
--   If the type is also a <a>Bifunctor</a> instance, it should satisfy:
--   
--   <pre>
--   <a>bifoldMap</a> f g ≡ <a>bifold</a> . <a>bimap</a> f g
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   <a>bifoldMap</a> f g . <a>bimap</a> h i ≡ <a>bifoldMap</a> (f . h) (g . i)
--   </pre>
class () => Bifoldable (p :: Type -> Type -> Type)

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class () => Semigroup a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | <a>Bitraversable</a> identifies bifunctorial data structures whose
--   elements can be traversed in order, performing <a>Applicative</a> or
--   <a>Monad</a> actions at each element, and collecting a result
--   structure with the same shape.
--   
--   As opposed to <a>Traversable</a> data structures, which have one
--   variety of element on which an action can be performed,
--   <a>Bitraversable</a> data structures have two such varieties of
--   elements.
--   
--   A definition of <a>bitraverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt><a>bitraverse</a> (t . f) (t . g) ≡ t .
--   <a>bitraverse</a> f g</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>bitraverse</a> <a>Identity</a>
--   <a>Identity</a> ≡ <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>Compose</a> . <a>fmap</a>
--   (<a>bitraverse</a> g1 g2) . <a>bitraverse</a> f1 f2 ≡
--   <a>bitraverse</a> (<a>Compose</a> . <a>fmap</a> g1 . f1)
--   (<a>Compose</a> . <a>fmap</a> g2 . f2)</tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (<a>Applicative</a> f, <a>Applicative</a> g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations:
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   Some simple examples are <a>Either</a> and <tt>(,)</tt>:
--   
--   <pre>
--   instance Bitraversable Either where
--     bitraverse f _ (Left x) = Left &lt;$&gt; f x
--     bitraverse _ g (Right y) = Right &lt;$&gt; g y
--   
--   instance Bitraversable (,) where
--     bitraverse f g (x, y) = (,) &lt;$&gt; f x &lt;*&gt; g y
--   </pre>
--   
--   <a>Bitraversable</a> relates to its superclasses in the following
--   ways:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>runIdentity</a> . <a>bitraverse</a> (<a>Identity</a> . f) (<a>Identity</a> . g)
--   <a>bifoldMap</a> f g = <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
--   
--   These are available as <a>bimapDefault</a> and <a>bifoldMapDefault</a>
--   respectively.
class (Bifunctor t, Bifoldable t) => Bitraversable (t :: Type -> Type -> Type)

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | A class for categories. Instances should satisfy the laws
--   
--   <ul>
--   <li><i>Right identity</i> <tt>f <a>.</a> <a>id</a> = f</tt></li>
--   <li><i>Left identity</i> <tt><a>id</a> <a>.</a> f = f</tt></li>
--   <li><i>Associativity</i> <tt>f <a>.</a> (g <a>.</a> h) = (f <a>.</a>
--   g) <a>.</a> h</tt></li>
--   </ul>
class () => Category (cat :: k -> k -> Type)

-- | The basic arrow class.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>arr</a> id = <a>id</a></pre></li>
--   <li><pre><a>arr</a> (f &gt;&gt;&gt; g) = <a>arr</a> f &gt;&gt;&gt;
--   <a>arr</a> g</pre></li>
--   <li><pre><a>first</a> (<a>arr</a> f) = <a>arr</a> (<a>first</a>
--   f)</pre></li>
--   <li><pre><a>first</a> (f &gt;&gt;&gt; g) = <a>first</a> f &gt;&gt;&gt;
--   <a>first</a> g</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> <a>fst</a> =
--   <a>arr</a> <a>fst</a> &gt;&gt;&gt; f</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> *** g) =
--   <a>arr</a> (<a>id</a> *** g) &gt;&gt;&gt; <a>first</a> f</pre></li>
--   <li><pre><a>first</a> (<a>first</a> f) &gt;&gt;&gt; <a>arr</a> assoc =
--   <a>arr</a> assoc &gt;&gt;&gt; <a>first</a> f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Category a => Arrow (a :: Type -> Type -> Type)

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail (m :: Type -> Type)

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class () => Typeable (a :: k)

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type within generic folding is <tt>r -&gt;
--   r</tt>. So the result of folding is a function to which we finally
--   pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a

-- | Left-associative fold operation for constructor applications.
--   
--   The type of <a>gfoldl</a> is a headache, but operationally it is a
--   simple generalisation of a list fold.
--   
--   The default definition for <a>gfoldl</a> is <tt><a>const</a>
--   <a>id</a></tt>, which is suitable for abstract datatypes with no
--   substructures.
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. () => g -> c g) -> a -> c a

-- | Unfolding constructor applications
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. () => r -> c r) -> Constr -> c a

-- | Obtaining the constructor from a given datum. For proper terms, this
--   is meant to be the top-level constructor. Primitive datatypes are here
--   viewed as potentially infinite sets of values (i.e., constructors).
toConstr :: Data a => a -> Constr

-- | The outer type constructor of the type
dataTypeOf :: Data a => a -> DataType

-- | Mediate types and unary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, ...) =&gt; Data (T a)
--   </pre>
--   
--   <a>dataCast1</a> should be defined as <a>gcast1</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c a)

-- | Mediate types and binary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, Data b, ...) =&gt; Data (T a b)
--   </pre>
--   
--   <a>dataCast2</a> should be defined as <a>gcast2</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)

-- | A generic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to an identity datatype constructor, using
--   the isomorphism pair as injection and projection.
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a

-- | A generic query with a left-associative binary operator
gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query with a right-associative binary operator
gmapQr :: forall r r'. Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query that processes the immediate subterms and returns a
--   list of results. The list is given in the same order as originally
--   specified in the declaration of the data constructors.
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]

-- | A generic query that processes one child by index (zero-based)
gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u

-- | A generic monadic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to the monad datatype constructor, defining
--   injection and projection using <a>return</a> and <a>&gt;&gt;=</a>.
gmapM :: (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of at least one immediate subterm does not fail
gmapMp :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of one immediate subterm with success
gmapMo :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class () => Generic a

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class () => Storable a

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | Lifted, homogeneous equality. By lifted, we mean that it can be bogus
--   (deferred type error). By homogeneous, the two types <tt>a</tt> and
--   <tt>b</tt> must have the same kinds.
class a ~# b => (a :: k) ~ (b :: k)
infix 4 ~

-- | A class of types that can be fully evaluated.
class () => NFData a

-- | The class of monad transformers. For any monad <tt>m</tt>, the result
--   <tt>t m</tt> should also be a monad, and <a>lift</a> should be a monad
--   transformation from <tt>m</tt> to <tt>t m</tt>, i.e. it should satisfy
--   the following laws:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
--   
--   Since 0.6.0.0 and for GHC 8.6 and later, the requirement that <tt>t
--   m</tt> be a <a>Monad</a> is enforced by the implication constraint
--   <tt>forall m. <a>Monad</a> m =&gt; <a>Monad</a> (t m)</tt> enabled by
--   the <tt>QuantifiedConstraints</tt> extension.
--   
--   <h3><b>Ambiguity error with GHC 9.0 to 9.2.2</b></h3>
--   
--   These versions of GHC have a bug
--   (<a>https://gitlab.haskell.org/ghc/ghc/-/issues/20582</a>) which
--   causes constraints like
--   
--   <pre>
--   (MonadTrans t, forall m. Monad m =&gt; Monad (t m)) =&gt; ...
--   </pre>
--   
--   to be reported as ambiguous. For transformers 0.6 and later, this can
--   be fixed by removing the second constraint, which is implied by the
--   first.
class forall (m :: Type -> Type). Monad m => Monad t m => MonadTrans (t :: Type -> Type -> Type -> Type)

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: Type -> Type) | m -> r

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
type Reader r = ReaderT r Identity

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype () => ReaderT r (m :: Type -> Type) a
ReaderT :: (r -> m a) -> ReaderT r (m :: Type -> Type) a

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow (m :: Type -> Type)

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data () => ByteString
type LByteString = ByteString

-- | <a>Builder</a>s denote sequences of bytes. They are <a>Monoid</a>s
--   where <a>mempty</a> is the zero-length sequence and <a>mappend</a> is
--   concatenation, which runs in <i>O(1)</i>.
data () => Builder

-- | A compact representation of a <a>Word8</a> vector.
--   
--   It has a lower memory overhead than a <a>ByteString</a> and does not
--   contribute to heap fragmentation. It can be converted to or from a
--   <a>ByteString</a> (at the cost of copying the string data). It
--   supports very few other operations.
data () => ShortByteString

-- | A space efficient, packed, unboxed Unicode text type.
data () => Text
type LText = Text

-- | An exception type for representing Unicode encoding errors.
data () => UnicodeException

-- | Could not decode a byte sequence because it was invalid under the
--   given encoding, or ran out of input in mid-decode.
DecodeError :: String -> Maybe Word8 -> UnicodeException

-- | Tried to encode a character that could not be represented under the
--   given encoding, or ran out of input in mid-encode.
EncodeError :: String -> Maybe Char -> UnicodeException
data () => Vector a
type UVector = Vector
class (Vector Vector a, MVector MVector a) => Unbox a
type SVector = Vector
type GVector = Vector

-- | A map of integers to values <tt>a</tt>.
data () => IntMap a

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data () => Map k a

-- | A set of integers.
data () => IntSet

-- | A set of values <tt>a</tt>.
data () => Set a

-- | General-purpose finite sequences.
data () => Seq a
class Eq a => Hashable a
data () => HashMap k v
data () => HashSet a
class Monad m => PrimMonad (m :: Type -> Type) where {
    type family PrimState (m :: Type -> Type);
}

module RIO.Prelude

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>fromMaybe</a> function takes a default value and a <a>Maybe</a>
--   value. If the <a>Maybe</a> is <a>Nothing</a>, it returns the default
--   value; otherwise, it returns the value contained in the <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | Get a <a>First</a> value with a default fallback
fromFirst :: a -> First a -> a

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | Applicative <a>mapMaybe</a>.
mapMaybeA :: Applicative f => (a -> f (Maybe b)) -> [a] -> f [b]

-- | Monadic <a>mapMaybe</a>.
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> [a] -> m [b]

-- | <pre>
--   <a>forMaybeA</a> <a>==</a> <a>flip</a> <a>mapMaybeA</a>
--   </pre>
forMaybeA :: Applicative f => [a] -> (a -> f (Maybe b)) -> f [b]

-- | <pre>
--   <a>forMaybeM</a> <a>==</a> <a>flip</a> <a>mapMaybeM</a>
--   </pre>
forMaybeM :: Monad m => [a] -> (a -> m (Maybe b)) -> m [b]

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Return the contents of a <a>Left</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 1 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 1 (Right "foo")
--   1
--   </pre>
fromLeft :: a -> Either a b -> a

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Apply a function to a <a>Left</a> constructor
mapLeft :: (a1 -> a2) -> Either a1 b -> Either a2 b

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c
(==) :: Eq a => a -> a -> Bool
infix 4 ==
(/=) :: Eq a => a -> a -> Bool
infix 4 /=
(<) :: Ord a => a -> a -> Bool
infix 4 <
(<=) :: Ord a => a -> a -> Bool
infix 4 <=
(>) :: Ord a => a -> a -> Bool
infix 4 >
(>=) :: Ord a => a -> a -> Bool
infix 4 >=
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
compare :: Ord a => a -> a -> Ordering

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>).
--   
--   If <tt>a</tt> has an <tt><a>Ord</a></tt> instance associated with it
--   then comparing two values thus wrapped will give you the opposite of
--   their normal sort order. This is particularly useful when sorting in
--   generalised list comprehensions, as in: <tt>then sortWith by
--   <a>Down</a> x</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; compare True False
--   GT
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compare (Down True) (Down False)
--   LT
--   </pre>
--   
--   If <tt>a</tt> has a <tt><a>Bounded</a></tt> instance then the wrapped
--   instance also respects the reversed ordering by exchanging the values
--   of <tt><a>minBound</a></tt> and <tt><a>maxBound</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: Int
--   -9223372036854775808
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: Down Int
--   Down 9223372036854775807
--   </pre>
--   
--   All other instances of <tt><a>Down</a> a</tt> behave as they do for
--   <tt>a</tt>.
newtype () => Down a
Down :: a -> Down a

[getDown] :: Down a -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int
minBound :: Bounded a => a
maxBound :: Bounded a => a
(+) :: Num a => a -> a -> a
infixl 6 +
(-) :: Num a => a -> a -> a
infixl 6 -
(*) :: Num a => a -> a -> a
infixl 7 *

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | integer division truncated toward zero
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quot :: Integral a => a -> a -> a
infixl 7 `quot`

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
rem :: Integral a => a -> a -> a
infixl 7 `rem`

-- | integer division truncated toward negative infinity
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
div :: Integral a => a -> a -> a
infixl 7 `div`

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
mod :: Integral a => a -> a -> a
infixl 7 `mod`

-- | simultaneous <a>quot</a> and <a>rem</a>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
even :: Integral a => a -> Bool
odd :: Integral a => a -> Bool

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | General coercion from <a>Integral</a> types.
--   
--   WARNING: This function performs silent truncation if the result type
--   is not at least as big as the argument's type.
fromIntegral :: (Integral a, Num b) => a -> b

-- | Fractional division.
(/) :: Fractional a => a -> a -> a
infixl 7 /

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a

-- | General coercion to <a>Fractional</a> types.
--   
--   WARNING: This function goes through the <a>Rational</a> type, which
--   does not have values for <tt>NaN</tt> for example. This means it does
--   not round-trip.
--   
--   For <a>Double</a> it also behaves differently with or without -O0:
--   
--   <pre>
--   Prelude&gt; realToFrac nan -- With -O0
--   -Infinity
--   Prelude&gt; realToFrac nan
--   NaN
--   </pre>
realToFrac :: (Real a, Fractional b) => a -> b
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
infixr 8 **
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Reverse order of bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>
sappend :: Semigroup s => s -> s -> s

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
infixl 4 <*>

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b
infixl 4 *>

-- | Lift a function to actions. Equivalent to Functor's <a>fmap</a> but
--   implemented using only <a>Applicative</a>'s methods: <tt><a>liftA</a>
--   f a = <a>pure</a> f <a>&lt;*&gt;</a> a</tt>
--   
--   As such this function may be used to implement a <a>Functor</a>
--   instance from an <a>Applicative</a> one.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the Applicative instance for Lists:
--   
--   <pre>
--   &gt;&gt;&gt; liftA (+1) [1, 2]
--   [2,3]
--   </pre>
--   
--   Or the Applicative instance for <a>Maybe</a>
--   
--   <pre>
--   &gt;&gt;&gt; liftA (+1) (Just 3)
--   Just 4
--   </pre>
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
--   
--   Note that "forever" isn't necessarily non-terminating. If the action
--   is in a <tt><a>MonadPlus</a></tt> and short-circuits after some number
--   of iterations. then <tt><a>forever</a></tt> actually returns
--   <a>mzero</a>, effectively short-circuiting its caller.
forever :: Applicative f => f a -> f b

-- | Map each element of a structure to an <a>Applicative</a> action,
--   evaluate these actions from left to right, and ignore the results. For
--   a version that doesn't ignore the results see <a>traverse</a>.
--   
--   <a>traverse_</a> is just like <a>mapM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; traverse_ print ["Hello", "world", "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>. This is
--   <a>forM_</a> generalised to <a>Applicative</a> actions.
--   
--   <a>for_</a> is just like <a>forM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
--   
--   <a>sequenceA_</a> is just like <a>sequence_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA_ [print "Hello", print "world", print "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM_ 3 (putStrLn "a")
--   a
--   a
--   a
--   </pre>
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a
fail :: MonadFail m => String -> m a

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b
infixl 1 >>=

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b
infixl 1 >>

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Run the second value if the first value returns <a>True</a>
whenM :: Monad m => m Bool -> m () -> m ()

-- | Run the second value if the first value returns <a>False</a>
unlessM :: Monad m => m Bool -> m () -> m ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   <a>forM_</a> is just like <a>for_</a>, but specialised to monadic
--   actions.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Given a structure with elements whose type is a <a>Monoid</a>, combine
--   them via the monoid's <tt>(<a>&lt;&gt;</a>)</tt> operator. This fold
--   is right-associative and lazy in the accumulator. When you need a
--   strict left-associative fold, use <a>foldMap'</a> instead, with
--   <a>id</a> as the map.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fold [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fold $ Node (Leaf (Sum 1)) (Sum 3) (Leaf (Sum 5))
--   Sum {getSum = 9}
--   </pre>
--   
--   Folds of unbounded structures do not terminate when the monoid's
--   <tt>(<a>&lt;&gt;</a>)</tt> operator is strict:
--   
--   <pre>
--   &gt;&gt;&gt; fold (repeat Nothing)
--   * Hangs forever *
--   </pre>
--   
--   Lazy corecursive folds of unbounded structures are fine:
--   
--   <pre>
--   &gt;&gt;&gt; take 12 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   [0,1,2,1,2,3,2,3,4,3,4,5]
--   
--   &gt;&gt;&gt; sum $ take 4000000 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   2666668666666
--   </pre>
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Extend <a>foldMap</a> to allow side effects.
--   
--   Internally, this is implemented using a strict left fold. This is used
--   for performance reasons. It also necessitates that this function has a
--   <tt>Monad</tt> constraint and not just an <tt>Applicative</tt>
--   constraint. For more information, see
--   <a>https://github.com/commercialhaskell/rio/pull/99#issuecomment-394179757</a>.
foldMapM :: (Monad m, Monoid w, Foldable t) => (a -> m w) -> t a -> m w

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | List of elements of a structure, from left to right. If the entire
--   list is intended to be reduced via a fold, just fold the structure
--   directly bypassing the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; toList Nothing
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Just 42)
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Left "foo")
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Node (Leaf 5) 17 (Node Empty 12 (Leaf 8)))
--   [5,17,12,8]
--   </pre>
--   
--   For lists, <a>toList</a> is the identity:
--   
--   <pre>
--   &gt;&gt;&gt; toList [1, 2, 3]
--   [1,2,3]
--   </pre>
toList :: Foldable t => t a -> [a]

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a
infixl 3 <|>

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]

-- | One or none.
--   
--   It is useful for modelling any computation that is allowed to fail.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the <a>Alternative</a> instance of <a>Control.Monad.Except</a>,
--   the following functions:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.Except
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; canFail = throwError "it failed" :: Except String Int
--   
--   &gt;&gt;&gt; final = return 42                :: Except String Int
--   </pre>
--   
--   Can be combined by allowing the first function to fail:
--   
--   <pre>
--   &gt;&gt;&gt; runExcept $ canFail *&gt; final
--   Left "it failed"
--   
--   &gt;&gt;&gt; runExcept $ optional canFail *&gt; final
--   Right 42
--   </pre>
optional :: Alternative f => f a -> f (Maybe a)

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>asum</a> is just like <a>msum</a>, but generalised to
--   <a>Alternative</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c

-- | Combines the elements of a structure using a monoid.
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifold (Right [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifold (Left [5, 6])
--   [5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifold ([1, 2, 3], [4, 5])
--   [1,2,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifold (Product 6, Product 7)
--   Product {getProduct = 42}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifold (Sum 6, Sum 7)
--   Sum {getSum = 13}
--   </pre>
bifold :: (Bifoldable p, Monoid m) => p m m -> m

-- | Combines the elements of a structure, given ways of mapping them to a
--   common monoid.
--   
--   <pre>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldMap (take 3) (fmap digitToInt) ([1..], "89")
--   [1,2,3,8,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldMap (take 3) (fmap digitToInt) (Left [1..])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldMap (take 3) (fmap digitToInt) (Right "89")
--   [8,9]
--   </pre>
bifoldMap :: (Bifoldable p, Monoid m) => (a -> m) -> (b -> m) -> p a b -> m

-- | Combines the elements of a structure in a right associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldr</a> f g z ≡ <a>foldr</a> (<a>either</a> f g) z . toEitherList
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt; bifoldr (+) (*) 3 (5, 7)
--   26 -- 5 + (7 * 3)
--   
--   &gt; bifoldr (+) (*) 3 (7, 5)
--   22 -- 7 + (5 * 3)
--   
--   &gt; bifoldr (+) (*) 3 (Right 5)
--   15 -- 5 * 3
--   
--   &gt; bifoldr (+) (*) 3 (Left 5)
--   8 -- 5 + 3
--   </pre>
bifoldr :: Bifoldable p => (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c

-- | Combines the elements of a structure in a left associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldl</a> f g z
--        ≡ <a>foldl</a> (acc -&gt; <a>either</a> (f acc) (g acc)) z . toEitherList
--   </pre>
--   
--   Note that if you want an efficient left-fold, you probably want to use
--   <a>bifoldl'</a> instead of <a>bifoldl</a>. The reason is that the
--   latter does not force the "inner" results, resulting in a thunk chain
--   which then must be evaluated from the outside-in.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt; bifoldl (+) (*) 3 (5, 7)
--   56 -- (5 + 3) * 7
--   
--   &gt; bifoldl (+) (*) 3 (7, 5)
--   50 -- (7 + 3) * 5
--   
--   &gt; bifoldl (+) (*) 3 (Right 5)
--   15 -- 5 * 3
--   
--   &gt; bifoldl (+) (*) 3 (Left 5)
--   8 -- 5 + 3
--   </pre>
bifoldl :: Bifoldable p => (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c

-- | As <a>bifoldr</a>, but strict in the result of the reduction functions
--   at each step.
bifoldr' :: Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c

-- | A variant of <a>bifoldr</a> that has no base case, and thus may only
--   be applied to non-empty structures.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldr1 (+) (5, 7)
--   12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldr1 (+) (Right 7)
--   7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldr1 (+) (Left 5)
--   5
--   </pre>
--   
--   <pre>
--   &gt; bifoldr1 (+) (BiList [1, 2] [3, 4])
--   10 -- 1 + (2 + (3 + 4))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldr1 (+) (BiList [1, 2] [])
--   3
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldr1 (+) (BiList [] [])
--   *** Exception: bifoldr1: empty structure
--   ...
--   </pre>
bifoldr1 :: Bifoldable t => (a -> a -> a) -> t a a -> a

-- | Right associative monadic bifold over a structure.
bifoldrM :: (Bifoldable t, Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c

-- | As <a>bifoldl</a>, but strict in the result of the reduction functions
--   at each step.
--   
--   This ensures that each step of the bifold is forced to weak head
--   normal form before being applied, avoiding the collection of thunks
--   that would otherwise occur. This is often what you want to strictly
--   reduce a finite structure to a single, monolithic result (e.g.,
--   <a>bilength</a>).
bifoldl' :: Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a

-- | A variant of <a>bifoldl</a> that has no base case, and thus may only
--   be applied to non-empty structures.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldl1 (+) (5, 7)
--   12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldl1 (+) (Right 7)
--   7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldl1 (+) (Left 5)
--   5
--   </pre>
--   
--   <pre>
--   &gt; bifoldl1 (+) (BiList [1, 2] [3, 4])
--   10 -- ((1 + 2) + 3) + 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldl1 (+) (BiList [1, 2] [])
--   3
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldl1 (+) (BiList [] [])
--   *** Exception: bifoldl1: empty structure
--   ...
--   </pre>
bifoldl1 :: Bifoldable t => (a -> a -> a) -> t a a -> a

-- | Left associative monadic bifold over a structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldlM (\a b -&gt; print b &gt;&gt; pure a) (\a c -&gt; print (show c) &gt;&gt; pure a) 42 ("Hello", True)
--   "Hello"
--   "True"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldlM (\a b -&gt; print b &gt;&gt; pure a) (\a c -&gt; print (show c) &gt;&gt; pure a) 42 (Right True)
--   "True"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldlM (\a b -&gt; print b &gt;&gt; pure a) (\a c -&gt; print (show c) &gt;&gt; pure a) 42 (Left "Hello")
--   "Hello"
--   42
--   </pre>
bifoldlM :: (Bifoldable t, Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a

-- | Map each element of a structure using one of two actions, evaluate
--   these actions from left to right, and ignore the results. For a
--   version that doesn't ignore the results, see <a>bitraverse</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse_ print (print . show) ("Hello", True)
--   "Hello"
--   "True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse_ print (print . show) (Right True)
--   "True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse_ print (print . show) (Left "Hello")
--   "Hello"
--   </pre>
bitraverse_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | As <a>bitraverse_</a>, but with the structure as the primary argument.
--   For a version that doesn't ignore the results, see <a>bifor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifor_ ("Hello", True) print (print . show)
--   "Hello"
--   "True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor_ (Right True) print (print . show)
--   "True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor_ (Left "Hello") print (print . show)
--   "Hello"
--   </pre>
bifor_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results, see
--   <a>bisequence</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bisequence_ (print "Hello", print "World")
--   "Hello"
--   "World"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisequence_ (Left (print "Hello"))
--   "Hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisequence_ (Right (print "World"))
--   "World"
--   </pre>
bisequence_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | The sum of a collection of actions, generalizing <a>biconcat</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biasum (Nothing, Nothing)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biasum (Nothing, Just 42)
--   Just 42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biasum (Just 18, Nothing)
--   Just 18
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biasum (Just 18, Just 42)
--   Just 18
--   </pre>
biasum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a

-- | Collects the list of elements of a structure, from left to right.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biList (18, 42)
--   [18,42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biList (Left 18)
--   [18]
--   </pre>
biList :: Bifoldable t => t a a -> [a]

-- | Test whether the structure is empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; binull (18, 42)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binull (Right 42)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binull (BiList [] [])
--   True
--   </pre>
binull :: Bifoldable t => t a b -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bilength (True, 42)
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bilength (Right 42)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bilength (BiList [1,2,3] [4,5])
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bilength (BiList [] [])
--   0
--   </pre>
--   
--   On infinite structures, this function hangs:
--   
--   <pre>
--   &gt; bilength (BiList [1..] [])
--   * Hangs forever *
--   </pre>
bilength :: Bifoldable t => t a b -> Int

-- | Does the element occur in the structure?
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (17, 42)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (17, 43)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (Left 42)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (Right 13)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (BiList [1..5] [1..100])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (BiList [1..5] [1..41])
--   False
--   </pre>
bielem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | The largest element of a non-empty structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bimaximum (42, 17)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimaximum (Right 42)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimaximum (BiList [13, 29, 4] [18, 1, 7])
--   29
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimaximum (BiList [13, 29, 4] [])
--   29
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; bimaximum (BiList [] [])
--   *** Exception: bimaximum: empty structure
--   ...
--   </pre>
bimaximum :: (Bifoldable t, Ord a) => t a a -> a

-- | The least element of a non-empty structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biminimum (42, 17)
--   17
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biminimum (Right 42)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biminimum (BiList [13, 29, 4] [18, 1, 7])
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biminimum (BiList [13, 29, 4] [])
--   4
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; biminimum (BiList [] [])
--   *** Exception: biminimum: empty structure
--   ...
--   </pre>
biminimum :: (Bifoldable t, Ord a) => t a a -> a

-- | The <a>bisum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bisum (42, 17)
--   59
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisum (Right 42)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisum (BiList [13, 29, 4] [18, 1, 7])
--   72
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisum (BiList [13, 29, 4] [])
--   46
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisum (BiList [] [])
--   0
--   </pre>
bisum :: (Bifoldable t, Num a) => t a a -> a

-- | The <a>biproduct</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biproduct (42, 17)
--   714
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biproduct (Right 42)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biproduct (BiList [13, 29, 4] [18, 1, 7])
--   190008
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biproduct (BiList [13, 29, 4] [])
--   1508
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biproduct (BiList [] [])
--   1
--   </pre>
biproduct :: (Bifoldable t, Num a) => t a a -> a

-- | Reduces a structure of lists to the concatenation of those lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biconcat ([1, 2, 3], [4, 5])
--   [1,2,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biconcat (Left [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biconcat (BiList [[1, 2, 3, 4, 5], [6, 7, 8]] [[9]])
--   [1,2,3,4,5,6,7,8,9]
--   </pre>
biconcat :: Bifoldable t => t [a] [a] -> [a]

-- | Given a means of mapping the elements of a structure to lists,
--   computes the concatenation of all such lists in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biconcatMap (take 3) (fmap digitToInt) ([1..], "89")
--   [1,2,3,8,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biconcatMap (take 3) (fmap digitToInt) (Left [1..])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biconcatMap (take 3) (fmap digitToInt) (Right "89")
--   [8,9]
--   </pre>
biconcatMap :: Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]

-- | <a>biand</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biand (True, False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biand (True, True)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biand (Left True)
--   True
--   </pre>
--   
--   Empty structures yield <a>True</a>:
--   
--   <pre>
--   &gt;&gt;&gt; biand (BiList [] [])
--   True
--   </pre>
--   
--   A <a>False</a> value finitely far from the left end yields
--   <a>False</a> (short circuit):
--   
--   <pre>
--   &gt;&gt;&gt; biand (BiList [True, True, False, True] (repeat True))
--   False
--   </pre>
--   
--   A <a>False</a> value infinitely far from the left end hangs:
--   
--   <pre>
--   &gt; biand (BiList (repeat True) [False])
--   * Hangs forever *
--   </pre>
--   
--   An infinitely <a>True</a> value hangs:
--   
--   <pre>
--   &gt; biand (BiList (repeat True) [])
--   * Hangs forever *
--   </pre>
biand :: Bifoldable t => t Bool Bool -> Bool

-- | <a>bior</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bior (True, False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bior (False, False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bior (Left True)
--   True
--   </pre>
--   
--   Empty structures yield <a>False</a>:
--   
--   <pre>
--   &gt;&gt;&gt; bior (BiList [] [])
--   False
--   </pre>
--   
--   A <a>True</a> value finitely far from the left end yields <a>True</a>
--   (short circuit):
--   
--   <pre>
--   &gt;&gt;&gt; bior (BiList [False, False, True, False] (repeat False))
--   True
--   </pre>
--   
--   A <a>True</a> value infinitely far from the left end hangs:
--   
--   <pre>
--   &gt; bior (BiList (repeat False) [True])
--   * Hangs forever *
--   </pre>
--   
--   An infinitely <a>False</a> value hangs:
--   
--   <pre>
--   &gt; bior (BiList (repeat False) [])
--   * Hangs forever *
--   </pre>
bior :: Bifoldable t => t Bool Bool -> Bool

-- | Determines whether any element of the structure satisfies its
--   appropriate predicate argument. Empty structures yield <a>False</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (27, 't')
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (27, '8')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (26, 't')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (Left 27)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (Left 26)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (BiList [27, 53] ['t', '8'])
--   True
--   </pre>
--   
--   Empty structures yield <a>False</a>:
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (BiList [] [])
--   False
--   </pre>
biany :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | Determines whether all elements of the structure satisfy their
--   appropriate predicate argument. Empty structures yield <a>True</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (27, 't')
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (26, '8')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (Left 27)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (Left 26)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (BiList [26, 52] ['3', '8'])
--   True
--   </pre>
--   
--   Empty structures yield <a>True</a>:
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (BiList [] [])
--   True
--   </pre>
biall :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bimaximumBy compare (42, 17)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimaximumBy compare (Left 17)
--   17
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimaximumBy compare (BiList [42, 17, 23] [-5, 18])
--   42
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; bimaximumBy compare (BiList [] [])
--   *** Exception: bifoldr1: empty structure
--   ...
--   </pre>
bimaximumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biminimumBy compare (42, 17)
--   17
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biminimumBy compare (Left 17)
--   17
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biminimumBy compare (BiList [42, 17, 23] [-5, 18])
--   -5
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; biminimumBy compare (BiList [] [])
--   *** Exception: bifoldr1: empty structure
--   ...
--   </pre>
biminimumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a

-- | <a>binotElem</a> is the negation of <a>bielem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (17, 42)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (17, 43)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (Left 42)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (Right 13)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (BiList [1..5] [1..100])
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (BiList [1..5] [1..41])
--   True
--   </pre>
binotElem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | The <a>bifind</a> function takes a predicate and a structure and
--   returns the leftmost element of the structure matching the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifind even (27, 53)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifind even (27, 52)
--   Just 52
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifind even (26, 52)
--   Just 26
--   </pre>
--   
--   Empty structures always yield <a>Nothing</a>:
--   
--   <pre>
--   &gt;&gt;&gt; bifind even (BiList [] [])
--   Nothing
--   </pre>
bifind :: Bifoldable t => (a -> Bool) -> t a a -> Maybe a

-- | Evaluates the relevant functions at each element in the structure,
--   running the action, and builds a new structure with the same shape,
--   using the results produced from sequencing the actions.
--   
--   <pre>
--   <a>bitraverse</a> f g ≡ <a>bisequenceA</a> . <a>bimap</a> f g
--   </pre>
--   
--   For a version that ignores the results, see <a>bitraverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse listToMaybe (find odd) (Left [])
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse listToMaybe (find odd) (Left [1, 2, 3])
--   Just (Left 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse listToMaybe (find odd) (Right [4, 5])
--   Just (Right 5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse listToMaybe (find odd) ([1, 2, 3], [4, 5])
--   Just (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse listToMaybe (find odd) ([], [4, 5])
--   Nothing
--   </pre>
bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

-- | Sequences all the actions in a structure, building a new structure
--   with the same shape using the results of the actions. For a version
--   that ignores the results, see <a>bisequence_</a>.
--   
--   <pre>
--   <a>bisequence</a> ≡ <a>bitraverse</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bisequence (Just 4, Nothing)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisequence (Just 4, Just 5)
--   Just (4,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisequence ([1, 2, 3], [4, 5])
--   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
--   </pre>
bisequence :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)

-- | <a>bifor</a> is <a>bitraverse</a> with the structure as the first
--   argument. For a version that ignores the results, see <a>bifor_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifor (Left []) listToMaybe (find even)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor (Left [1, 2, 3]) listToMaybe (find even)
--   Just (Left 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor (Right [4, 5]) listToMaybe (find even)
--   Just (Right 4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor ([1, 2, 3], [4, 5]) listToMaybe (find even)
--   Just (1,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor ([], [4, 5]) listToMaybe (find even)
--   Nothing
--   </pre>
bifor :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | The <a>bimapAccumL</a> function behaves like a combination of
--   <a>bimap</a> and <a>bifoldl</a>; it traverses a structure from left to
--   right, threading a state of type <tt>a</tt> and using the given
--   actions to compute new elements for the structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bimapAccumL (\acc bool -&gt; (acc + 1, show bool)) (\acc string -&gt; (acc * 2, reverse string)) 3 (True, "foo")
--   (8,("True","oof"))
--   </pre>
bimapAccumL :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | The <a>bimapAccumR</a> function behaves like a combination of
--   <a>bimap</a> and <a>bifoldr</a>; it traverses a structure from right
--   to left, threading a state of type <tt>a</tt> and using the given
--   actions to compute new elements for the structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bimapAccumR (\acc bool -&gt; (acc + 1, show bool)) (\acc string -&gt; (acc * 2, reverse string)) 3 (True, "foo")
--   (7,("True","oof"))
--   </pre>
bimapAccumR :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>msum</a> is just like <a>asum</a>, but specialised to
--   <a>MonadPlus</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage, using the <a>MonadPlus</a> instance for <a>Maybe</a>:
--   
--   <pre>
--   &gt;&gt;&gt; msum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 &&&

-- | Split the input between the two argument arrows and combine their
--   output. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
infixr 3 ***

-- | Left-to-right composition
(>>>) :: forall {k} cat (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt>const x y</tt> always evaluates to <tt>x</tt>, ignoring its second
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is representation-polymorphic in its
--   result type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool
--   -&gt; Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a>’s argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | The value of <tt><a>seq</a> a b</tt> is bottom if <tt>a</tt> is
--   bottom, and otherwise equal to <tt>b</tt>. In other words, it
--   evaluates the first argument <tt>a</tt> to weak head normal form
--   (WHNF). <a>seq</a> is usually introduced to improve performance by
--   avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt><a>seq</a> a b</tt>
--   does <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <a>seq</a> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <a>seq</a> returns
--   a value. In particular, this means that <tt>b</tt> may be evaluated
--   before <tt>a</tt>. If you need to guarantee a specific order of
--   evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | Helper function to force an action to run in <a>IO</a>. Especially
--   useful for overly general contexts, like hspec tests.
asIO :: IO a -> IO a

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   WARNING: This function takes linear time in the number of elements of
--   the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | Strip out duplicates
nubOrd :: Ord a => [a] -> [a]
fromString :: IsString a => String -> a

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
lines :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
unwords :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a

-- | the deep analogue of <a>$!</a>. In the expression <tt>f $!! x</tt>,
--   <tt>x</tt> is fully evaluated before the function <tt>f</tt> is
--   applied to it.
($!!) :: NFData a => (a -> b) -> a -> b
infixr 0 $!!

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return <tt>()</tt>.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b
infixr 0 `deepseq`

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Runs a <tt>Reader</tt> and extracts the final value from it. (The
--   inverse of <a>reader</a>.)
runReader :: Reader r a -> r -> a
runReaderT :: ReaderT r m a -> r -> m a
toStrictBytes :: LByteString -> ByteString
fromStrictBytes :: ByteString -> LByteString

-- | <i>O(n)</i>. Convert a <a>ByteString</a> into a
--   <a>ShortByteString</a>.
--   
--   This makes a copy, so does not retain the input string.
toShort :: ByteString -> ShortByteString

-- | <i>O(n)</i>. Convert a <a>ShortByteString</a> into a
--   <a>ByteString</a>.
fromShort :: ShortByteString -> ByteString
tshow :: Show a => a -> Text
decodeUtf8Lenient :: ByteString -> Text

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   If the input contains any invalid UTF-8 data, the relevant exception
--   will be returned, otherwise the decoded text.
decodeUtf8' :: ByteString -> Either UnicodeException Text

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   Surrogate code points in replacement character returned by
--   <a>OnDecodeError</a> will be automatically remapped to the replacement
--   char <tt>U+FFFD</tt>.
decodeUtf8With :: OnDecodeError -> ByteString -> Text

-- | Encode text using UTF-8 encoding.
encodeUtf8 :: Text -> ByteString

-- | Encode text to a ByteString <a>Builder</a> using UTF-8 encoding.
encodeUtf8Builder :: Text -> Builder

-- | Replace an invalid input byte with the Unicode replacement character
--   U+FFFD.
lenientDecode :: OnDecodeError
primitive :: PrimMonad m => (State# (PrimState m) -> (# State# (PrimState m), a #)) -> m a

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. () => ST s a) -> a

module RIO.Deque

-- | A double-ended queue supporting any underlying vector type and any
--   monad.
--   
--   This implements a circular double-ended queue with exponential growth.
data Deque v s a

-- | A <a>Deque</a> specialized to unboxed vectors.
type UDeque = Deque MVector

-- | A <a>Deque</a> specialized to storable vectors.
type SDeque = Deque MVector

-- | A <a>Deque</a> specialized to boxed vectors.
type BDeque = Deque MVector

-- | Create a new, empty <a>Deque</a>
newDeque :: (MVector v a, PrimMonad m) => m (Deque v (PrimState m) a)

-- | <i>O(1)</i> - Get the number of elements that is currently in the
--   <a>Deque</a>
getDequeSize :: PrimMonad m => Deque v (PrimState m) a -> m Int

-- | Pop the first value from the beginning of the <a>Deque</a>
popFrontDeque :: (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m (Maybe a)

-- | Pop the first value from the end of the <a>Deque</a>
popBackDeque :: (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m (Maybe a)

-- | Push a new value to the beginning of the <a>Deque</a>
pushFrontDeque :: (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> a -> m ()

-- | Push a new value to the end of the <a>Deque</a>
pushBackDeque :: (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> a -> m ()

-- | Fold over a <a>Deque</a>, starting at the beginning. Does not modify
--   the <a>Deque</a>.
foldlDeque :: (MVector v a, PrimMonad m) => (acc -> a -> m acc) -> acc -> Deque v (PrimState m) a -> m acc

-- | Fold over a <a>Deque</a>, starting at the end. Does not modify the
--   <a>Deque</a>.
foldrDeque :: (MVector v a, PrimMonad m) => (a -> acc -> m acc) -> acc -> Deque v (PrimState m) a -> m acc

-- | Convert a <a>Deque</a> into a list. Does not modify the <a>Deque</a>.
dequeToList :: (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m [a]

-- | Convert to an immutable vector of any type. If resulting pure vector
--   corresponds to the mutable one used by the <a>Deque</a>, it will be
--   more efficient to use <a>freezeDeque</a> instead.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import qualified RIO.Vector.Unboxed as U
--   
--   &gt;&gt;&gt; import qualified RIO.Vector.Storable as S
--   
--   &gt;&gt;&gt; d &lt;- newDeque @U.MVector @Int
--   
--   &gt;&gt;&gt; mapM_ (pushFrontDeque d) [0..10]
--   
--   &gt;&gt;&gt; dequeToVector @S.Vector d
--   [10,9,8,7,6,5,4,3,2,1,0]
--   </pre>
dequeToVector :: (Vector v' a, MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m (v' a)

-- | Yield an immutable copy of the underlying mutable vector. The
--   difference from <a>dequeToVector</a> is that the the copy will be
--   performed with a more efficient <tt>memcpy</tt>, rather than element
--   by element. The downside is that the resulting vector type must be the
--   one that corresponds to the mutable one that is used in the
--   <a>Deque</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import qualified RIO.Vector.Unboxed as U
--   
--   &gt;&gt;&gt; d &lt;- newDeque @U.MVector @Int
--   
--   &gt;&gt;&gt; mapM_ (pushFrontDeque d) [0..10]
--   
--   &gt;&gt;&gt; freezeDeque @U.Vector d
--   [10,9,8,7,6,5,4,3,2,1,0]
--   </pre>
freezeDeque :: (Vector v a, PrimMonad m) => Deque (Mutable v) (PrimState m) a -> m (v a)

-- | Helper function to assist with type inference, forcing usage of an
--   unboxed vector.
asUDeque :: UDeque s a -> UDeque s a

-- | Helper function to assist with type inference, forcing usage of a
--   storable vector.
asSDeque :: SDeque s a -> SDeque s a

-- | Helper function to assist with type inference, forcing usage of a
--   boxed vector.
asBDeque :: BDeque s a -> BDeque s a


-- | Interacting with external processes.
--   
--   This module provides a layer on top of <a>System.Process.Typed</a>,
--   with the following additions:
--   
--   <ul>
--   <li>For efficiency, it will cache <tt>PATH</tt> lookups.</li>
--   <li>For convenience, you can set the working directory and env vars
--   overrides in a <a>RIO</a> environment instead of on the individual
--   calls to the process.</li>
--   <li>Built-in support for logging at the debug level.</li>
--   </ul>
--   
--   In order to switch over to this API, the main idea is:
--   
--   <ul>
--   <li>Like most of the rio library, you need to create an environment
--   value (this time <a>ProcessContext</a>), and include it in your
--   <a>RIO</a> environment. See <a>mkProcessContext</a>.</li>
--   <li>Instead of using the <a>proc</a> function from
--   <a>System.Process.Typed</a> for creating a <a>ProcessConfig</a>, use
--   the locally defined <a>proc</a> function, which will handle overriding
--   environment variables, looking up paths, performing logging, etc.</li>
--   </ul>
--   
--   Once you have your <a>ProcessConfig</a>, use the standard functions
--   from <a>Typed</a> (reexported here for convenient) for running the
--   <a>ProcessConfig</a>.
module RIO.Process

-- | Context in which to run processes.
data ProcessContext

-- | Get the <a>ProcessContext</a> from the environment.
class HasProcessContext env
processContextL :: HasProcessContext env => Lens' env ProcessContext

-- | The environment variable map
type EnvVars = Map Text Text

-- | Create a new <a>ProcessContext</a> from the given environment variable
--   map.
mkProcessContext :: MonadIO m => EnvVars -> m ProcessContext

-- | Same as <a>mkProcessContext</a> but uses the system environment (from
--   <a>getEnvironment</a>).
mkDefaultProcessContext :: MonadIO m => m ProcessContext

-- | Modify the environment variables of a <a>ProcessContext</a>. This will
--   not change the working directory.
--   
--   Note that this requires <a>MonadIO</a>, as it will create a new
--   <a>IORef</a> for the cache.
modifyEnvVars :: MonadIO m => ProcessContext -> (EnvVars -> EnvVars) -> m ProcessContext

-- | Use <a>modifyEnvVars</a> to create a new <a>ProcessContext</a>, and
--   then use it in the provided action.
withModifyEnvVars :: (HasProcessContext env, MonadReader env m, MonadIO m) => (EnvVars -> EnvVars) -> m a -> m a

-- | Look into the <a>ProcessContext</a> and return the specified
--   environmet variable if one is available.
lookupEnvFromContext :: (MonadReader env m, HasProcessContext env) => Text -> m (Maybe Text)

-- | Set the working directory to be used by child processes.
withWorkingDir :: (HasProcessContext env, MonadReader env m, MonadIO m) => FilePath -> m a -> m a

-- | Override the working directory processes run in. <tt>Nothing</tt>
--   means the current process's working directory.
workingDirL :: HasProcessContext env => Lens' env (Maybe FilePath)

-- | Get the environment variables. We cannot provide a <tt>Lens</tt> here,
--   since updating the environment variables requires an <tt>IO</tt>
--   action to allocate a new <tt>IORef</tt> for holding the executable
--   path cache.
envVarsL :: HasProcessContext env => SimpleGetter env EnvVars

-- | Get the <a>EnvVars</a> as an associated list of <a>String</a>s.
--   
--   Useful for interacting with other libraries.
envVarsStringsL :: HasProcessContext env => SimpleGetter env [(String, String)]

-- | Get the list of directories searched for executables (the
--   <tt>PATH</tt>).
--   
--   Similar to <tt>envVarMapL</tt>, this cannot be a full <tt>Lens</tt>.
exeSearchPathL :: HasProcessContext env => SimpleGetter env [FilePath]

-- | Reset the executable cache.
resetExeCache :: (MonadIO m, MonadReader env m, HasProcessContext env) => m ()

-- | Provide a <a>ProcessConfig</a> based on the <a>ProcessContext</a> in
--   scope. Deals with resolving the full path, setting the child process's
--   environment variables, setting the working directory, and wrapping the
--   call with <a>withProcessTimeLog</a> for debugging output.
--   
--   This is intended to be analogous to the <tt>proc</tt> function
--   provided by the <tt>System.Process.Typed</tt> module, but has a
--   different type signature to (1) allow it to perform <tt>IO</tt>
--   actions for looking up paths, and (2) allow logging and timing of the
--   running action.
proc :: (HasProcessContext env, HasLogFunc env, MonadReader env m, MonadIO m, HasCallStack) => FilePath -> [String] -> (ProcessConfig () () () -> m a) -> m a

-- | Same as <a>withProcess</a>, but generalized to <a>MonadUnliftIO</a>.

-- | <i>Deprecated: Please consider using withProcessWait, or instead use
--   withProcessTerm</i>
withProcess :: MonadUnliftIO m => ProcessConfig stdin stdout stderr -> (Process stdin stdout stderr -> m a) -> m a

-- | Same as <a>withProcess_</a>, but generalized to <a>MonadUnliftIO</a>.

-- | <i>Deprecated: Please consider using withProcessWait, or instead use
--   withProcessTerm</i>
withProcess_ :: MonadUnliftIO m => ProcessConfig stdin stdout stderr -> (Process stdin stdout stderr -> m a) -> m a

-- | Same as <a>withProcessWait</a>, but generalized to
--   <a>MonadUnliftIO</a>.
withProcessWait :: MonadUnliftIO m => ProcessConfig stdin stdout stderr -> (Process stdin stdout stderr -> m a) -> m a

-- | Same as <a>withProcessWait_</a>, but generalized to
--   <a>MonadUnliftIO</a>.
withProcessWait_ :: MonadUnliftIO m => ProcessConfig stdin stdout stderr -> (Process stdin stdout stderr -> m a) -> m a

-- | Same as <a>withProcessTerm</a>, but generalized to
--   <a>MonadUnliftIO</a>.
withProcessTerm :: MonadUnliftIO m => ProcessConfig stdin stdout stderr -> (Process stdin stdout stderr -> m a) -> m a

-- | Same as <a>withProcessTerm_</a>, but generalized to
--   <a>MonadUnliftIO</a>.
withProcessTerm_ :: MonadUnliftIO m => ProcessConfig stdin stdout stderr -> (Process stdin stdout stderr -> m a) -> m a

-- | Execute a process within the configured environment.
--   
--   Execution will not return, because either:
--   
--   1) On non-windows, execution is taken over by execv of the
--   sub-process. This allows signals to be propagated (#527)
--   
--   2) On windows, an <a>ExitCode</a> exception will be thrown.
exec :: (HasProcessContext env, HasLogFunc env) => String -> [String] -> RIO env b

-- | Like <a>exec</a>, but does not use <tt>execv</tt> on non-windows. This
--   way, there is a sub-process, which is helpful in some cases
--   (<a>https://github.com/commercialhaskell/stack/issues/1306</a>).
--   
--   This function only exits by throwing <a>ExitCode</a>.
execSpawn :: (HasProcessContext env, HasLogFunc env) => String -> [String] -> RIO env a

-- | A convenience environment combining a <a>LogFunc</a> and a
--   <a>ProcessContext</a>
data LoggedProcessContext
LoggedProcessContext :: ProcessContext -> LogFunc -> LoggedProcessContext

-- | Run an action using a <a>LoggedProcessContext</a> with default
--   settings and no logging.
withProcessContextNoLogging :: MonadIO m => RIO LoggedProcessContext a -> m a

-- | Exception type which may be generated in this module.
--   
--   <i>NOTE</i> Other exceptions may be thrown by underlying libraries!
data ProcessException
NoPathFound :: ProcessException
ExecutableNotFound :: String -> [FilePath] -> ProcessException
ExecutableNotFoundAt :: FilePath -> ProcessException
PathsInvalidInPath :: [FilePath] -> ProcessException

-- | Check if the given executable exists on the given PATH.
doesExecutableExist :: (MonadIO m, MonadReader env m, HasProcessContext env) => String -> m Bool

-- | Find the complete path for the given executable name.
--   
--   On POSIX systems, filenames that match but are not exectuables are
--   excluded.
--   
--   On Windows systems, the executable names tried, in turn, are the
--   supplied name (only if it has an extension) and that name extended by
--   each of the <a>exeExtensions</a>. Also, this function may behave
--   differently from <a>findExecutable</a>. The latter excludes as
--   executables filenames without a <tt>.bat</tt>, <tt>.cmd</tt>,
--   <tt>.com</tt> or <tt>.exe</tt> extension (case-insensitive).
findExecutable :: (MonadIO m, MonadReader env m, HasProcessContext env) => String -> m (Either ProcessException FilePath)

-- | Get the filename extensions for executable files, including the dot
--   (if any).
--   
--   On POSIX systems, this is <tt>[""]</tt>.
--   
--   On Windows systems, the list is determined by the value of the
--   <tt>PATHEXT</tt> environment variable, if it present in the
--   environment. If the variable is absent, this is its default value on a
--   Windows system. This function may, therefore, behave differently from
--   <a>exeExtension</a>, which returns only <tt>".exe"</tt>.
exeExtensions :: (MonadIO m, MonadReader env m, HasProcessContext env) => m [String]

-- | Augment the given value (assumed to be that of an environment variable
--   that lists paths, such as PATH; this is not checked) with the given
--   extra paths. Those paths are prepended (as in: they take precedence).
augmentPath :: [FilePath] -> Maybe Text -> Either ProcessException Text

-- | Apply <a>augmentPath</a> on the value of the PATH environment variable
--   in the given <a>EnvVars</a>.
augmentPathMap :: [FilePath] -> EnvVars -> Either ProcessException EnvVars

-- | Apply <a>augmentPath</a> on the value of the given environment
--   variable in the given <a>EnvVars</a>.
augmentPathMap' :: Text -> [FilePath] -> EnvVars -> Either ProcessException EnvVars

-- | Show a process arg including speechmarks when necessary. Just for
--   debugging purposes, not functionally important.
showProcessArgDebug :: String -> Text
data () => ProcessConfig stdin stdout stderr
data () => StreamSpec (streamType :: StreamType) a
data () => StreamType
STInput :: StreamType
STOutput :: StreamType
data () => Process stdin stdout stderr
setStdin :: StreamSpec 'STInput stdin -> ProcessConfig stdin0 stdout stderr -> ProcessConfig stdin stdout stderr
setStdout :: StreamSpec 'STOutput stdout -> ProcessConfig stdin stdout0 stderr -> ProcessConfig stdin stdout stderr
setStderr :: StreamSpec 'STOutput stderr -> ProcessConfig stdin stdout stderr0 -> ProcessConfig stdin stdout stderr
setCloseFds :: Bool -> ProcessConfig stdin stdout stderr -> ProcessConfig stdin stdout stderr
setCreateGroup :: Bool -> ProcessConfig stdin stdout stderr -> ProcessConfig stdin stdout stderr
setDelegateCtlc :: Bool -> ProcessConfig stdin stdout stderr -> ProcessConfig stdin stdout stderr
setDetachConsole :: Bool -> ProcessConfig stdin stdout stderr -> ProcessConfig stdin stdout stderr
setCreateNewConsole :: Bool -> ProcessConfig stdin stdout stderr -> ProcessConfig stdin stdout stderr
setNewSession :: Bool -> ProcessConfig stdin stdout stderr -> ProcessConfig stdin stdout stderr
setChildGroup :: GroupID -> ProcessConfig stdin stdout stderr -> ProcessConfig stdin stdout stderr
setChildUser :: UserID -> ProcessConfig stdin stdout stderr -> ProcessConfig stdin stdout stderr
mkStreamSpec :: forall a (streamType :: StreamType). StdStream -> (ProcessConfig () () () -> Maybe Handle -> IO (a, IO ())) -> StreamSpec streamType a
inherit :: forall (anyStreamType :: StreamType). StreamSpec anyStreamType ()
closed :: forall (anyStreamType :: StreamType). StreamSpec anyStreamType ()
byteStringInput :: ByteString -> StreamSpec 'STInput ()
byteStringOutput :: StreamSpec 'STOutput (STM ByteString)
createPipe :: forall (anyStreamType :: StreamType). StreamSpec anyStreamType Handle
useHandleOpen :: forall (anyStreamType :: StreamType). Handle -> StreamSpec anyStreamType ()
useHandleClose :: forall (anyStreamType :: StreamType). Handle -> StreamSpec anyStreamType ()
startProcess :: MonadIO m => ProcessConfig stdin stdout stderr -> m (Process stdin stdout stderr)
stopProcess :: MonadIO m => Process stdin stdout stderr -> m ()
readProcess :: MonadIO m => ProcessConfig stdin stdoutIgnored stderrIgnored -> m (ExitCode, ByteString, ByteString)
readProcess_ :: MonadIO m => ProcessConfig stdin stdoutIgnored stderrIgnored -> m (ByteString, ByteString)
runProcess :: MonadIO m => ProcessConfig stdin stdout stderr -> m ExitCode
runProcess_ :: MonadIO m => ProcessConfig stdin stdout stderr -> m ()
readProcessStdout :: MonadIO m => ProcessConfig stdin stdoutIgnored stderr -> m (ExitCode, ByteString)
readProcessStdout_ :: MonadIO m => ProcessConfig stdin stdoutIgnored stderr -> m ByteString
readProcessStderr :: MonadIO m => ProcessConfig stdin stdout stderrIgnored -> m (ExitCode, ByteString)
readProcessStderr_ :: MonadIO m => ProcessConfig stdin stdout stderrIgnored -> m ByteString
waitExitCode :: MonadIO m => Process stdin stdout stderr -> m ExitCode
waitExitCodeSTM :: Process stdin stdout stderr -> STM ExitCode
getExitCode :: MonadIO m => Process stdin stdout stderr -> m (Maybe ExitCode)
getExitCodeSTM :: Process stdin stdout stderr -> STM (Maybe ExitCode)
checkExitCode :: MonadIO m => Process stdin stdout stderr -> m ()
checkExitCodeSTM :: Process stdin stdout stderr -> STM ()
getStdin :: Process stdin stdout stderr -> stdin
getStdout :: Process stdin stdout stderr -> stdout
getStderr :: Process stdin stdout stderr -> stderr
data () => ExitCodeException
ExitCodeException :: ExitCode -> ProcessConfig () () () -> ByteString -> ByteString -> ExitCodeException
[eceExitCode] :: ExitCodeException -> ExitCode
[eceProcessConfig] :: ExitCodeException -> ProcessConfig () () ()
[eceStdout] :: ExitCodeException -> ByteString
[eceStderr] :: ExitCodeException -> ByteString
data () => ByteStringOutputException
ByteStringOutputException :: SomeException -> ProcessConfig () () () -> ByteStringOutputException
unsafeProcessHandle :: Process stdin stdout stderr -> ProcessHandle
instance GHC.Classes.Eq RIO.Process.ProcessException
instance RIO.Prelude.Logger.HasLogFunc RIO.Process.LoggedProcessContext
instance RIO.Process.HasProcessContext RIO.Process.LoggedProcessContext
instance RIO.Process.HasProcessContext RIO.Process.ProcessContext
instance GHC.Show.Show RIO.Process.ProcessException
instance GHC.Exception.Type.Exception RIO.Process.ProcessException


-- | Provide a <tt><a>SimpleApp</a></tt> datatype, for providing a basic
--   <tt>App</tt>-like environment with common functionality built in. This
--   is intended to make it easier to, e.g., use rio's logging and process
--   code from within short scripts.
module RIO.Prelude.Simple

-- | A simple, non-customizable environment type for <tt>RIO</tt>, which
--   provides common functionality. If it's insufficient for your needs,
--   define your own, custom <tt>App</tt> data type.
data SimpleApp

-- | Constructor for <a>SimpleApp</a>. In case when <a>ProcessContext</a>
--   is not supplied <a>mkDefaultProcessContext</a> will be used to create
--   it.
mkSimpleApp :: MonadIO m => LogFunc -> Maybe ProcessContext -> m SimpleApp

-- | Run with a default configured <tt>SimpleApp</tt>, consisting of:
--   
--   <ul>
--   <li>Logging to stderr</li>
--   <li>If the <tt>RIO_VERBOSE</tt> environment variable is set, turns on
--   verbose logging</li>
--   <li>Default process context</li>
--   </ul>
runSimpleApp :: MonadIO m => RIO SimpleApp a -> m a
instance RIO.Prelude.Logger.HasLogFunc RIO.Prelude.Simple.SimpleApp
instance RIO.Process.HasProcessContext RIO.Prelude.Simple.SimpleApp


-- | <tt>Seq</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.Seq as Seq
--   </pre>
module RIO.Seq

-- | General-purpose finite sequences.
data () => Seq a

-- | A bidirectional pattern synonym matching an empty sequence.
pattern Empty :: Seq a

-- | A bidirectional pattern synonym viewing the rear of a non-empty
--   sequence.
pattern (:|>) :: Seq a -> a -> Seq a

-- | A bidirectional pattern synonym viewing the front of a non-empty
--   sequence.
pattern (:<|) :: a -> Seq a -> Seq a
infixl 5 :|>
infixr 5 :<|

-- | &lt;math&gt;. The empty sequence.
empty :: Seq a

-- | &lt;math&gt;. A singleton sequence.
singleton :: a -> Seq a

-- | &lt;math&gt;. Add an element to the left end of a sequence. Mnemonic:
--   a triangle with the single element at the pointy end.
(<|) :: a -> Seq a -> Seq a
infixr 5 <|

-- | &lt;math&gt;. Add an element to the right end of a sequence. Mnemonic:
--   a triangle with the single element at the pointy end.
(|>) :: Seq a -> a -> Seq a
infixl 5 |>

-- | &lt;math&gt;. Concatenate two sequences.
(><) :: Seq a -> Seq a -> Seq a
infixr 5 ><

-- | &lt;math&gt;. Create a sequence from a finite list of elements. There
--   is a function <a>toList</a> in the opposite direction for all
--   instances of the <a>Foldable</a> class, including <a>Seq</a>.
fromList :: [a] -> Seq a

-- | &lt;math&gt;. Convert a given sequence length and a function
--   representing that sequence into a sequence.
fromFunction :: Int -> (Int -> a) -> Seq a

-- | &lt;math&gt;. Create a sequence consisting of the elements of an
--   <a>Array</a>. Note that the resulting sequence elements may be
--   evaluated lazily (as on GHC), so you must force the entire structure
--   to be sure that the original array can be garbage-collected.
fromArray :: Ix i => Array i a -> Seq a

-- | &lt;math&gt;. <tt>replicate n x</tt> is a sequence consisting of
--   <tt>n</tt> copies of <tt>x</tt>.
replicate :: Int -> a -> Seq a

-- | <a>replicateA</a> is an <a>Applicative</a> version of
--   <a>replicate</a>, and makes &lt;math&gt; calls to <a>liftA2</a> and
--   <a>pure</a>.
--   
--   <pre>
--   replicateA n x = sequenceA (replicate n x)
--   </pre>
replicateA :: Applicative f => Int -> f a -> f (Seq a)

-- | <a>replicateM</a> is a sequence counterpart of <a>replicateM</a>.
--   
--   <pre>
--   replicateM n x = sequence (replicate n x)
--   </pre>
--   
--   For <tt>base &gt;= 4.8.0</tt> and <tt>containers &gt;= 0.5.11</tt>,
--   <a>replicateM</a> is a synonym for <a>replicateA</a>.
replicateM :: Applicative m => Int -> m a -> m (Seq a)

-- | &lt;math&gt;. <tt><a>cycleTaking</a> k xs</tt> forms a sequence of
--   length <tt>k</tt> by repeatedly concatenating <tt>xs</tt> with itself.
--   <tt>xs</tt> may only be empty if <tt>k</tt> is 0.
--   
--   <pre>
--   cycleTaking k = fromList . take k . cycle . toList
--   </pre>
cycleTaking :: Int -> Seq a -> Seq a

-- | &lt;math&gt;. Constructs a sequence by repeated application of a
--   function to a seed value.
--   
--   <pre>
--   iterateN n f x = fromList (Prelude.take n (Prelude.iterate f x))
--   </pre>
iterateN :: Int -> (a -> a) -> a -> Seq a

-- | Builds a sequence from a seed value. Takes time linear in the number
--   of generated elements. <i>WARNING:</i> If the number of generated
--   elements is infinite, this method will not terminate.
unfoldr :: (b -> Maybe (a, b)) -> b -> Seq a

-- | <tt><a>unfoldl</a> f x</tt> is equivalent to <tt><a>reverse</a>
--   (<a>unfoldr</a> (<a>fmap</a> swap . f) x)</tt>.
unfoldl :: (b -> Maybe (b, a)) -> b -> Seq a

-- | &lt;math&gt;. Is this the empty sequence?
null :: Seq a -> Bool

-- | &lt;math&gt;. The number of elements in the sequence.
length :: Seq a -> Int

-- | View of the left end of a sequence.
data () => ViewL a

-- | empty sequence
EmptyL :: ViewL a

-- | leftmost element and the rest of the sequence
(:<) :: a -> Seq a -> ViewL a
infixr 5 :<

-- | &lt;math&gt;. Analyse the left end of a sequence.
viewl :: Seq a -> ViewL a

-- | View of the right end of a sequence.
data () => ViewR a

-- | empty sequence
EmptyR :: ViewR a

-- | the sequence minus the rightmost element, and the rightmost element
(:>) :: Seq a -> a -> ViewR a
infixl 5 :>

-- | &lt;math&gt;. Analyse the right end of a sequence.
viewr :: Seq a -> ViewR a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a sequence of
--   reduced values from the left:
--   
--   <pre>
--   scanl f z (fromList [x1, x2, ...]) = fromList [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
scanl :: (a -> b -> a) -> a -> Seq b -> Seq a

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f (fromList [x1, x2, ...]) = fromList [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> Seq a -> Seq a

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
scanr :: (a -> b -> b) -> b -> Seq a -> Seq b

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> Seq a -> Seq a

-- | &lt;math&gt;. Returns a sequence of all suffixes of this sequence,
--   longest first. For example,
--   
--   <pre>
--   tails (fromList "abc") = fromList [fromList "abc", fromList "bc", fromList "c", fromList ""]
--   </pre>
--   
--   Evaluating the &lt;math&gt;th suffix takes &lt;math&gt;, but
--   evaluating every suffix in the sequence takes &lt;math&gt; due to
--   sharing.
tails :: Seq a -> Seq (Seq a)

-- | &lt;math&gt;. Returns a sequence of all prefixes of this sequence,
--   shortest first. For example,
--   
--   <pre>
--   inits (fromList "abc") = fromList [fromList "", fromList "a", fromList "ab", fromList "abc"]
--   </pre>
--   
--   Evaluating the &lt;math&gt;th prefix takes &lt;math&gt;, but
--   evaluating every prefix in the sequence takes &lt;math&gt; due to
--   sharing.
inits :: Seq a -> Seq (Seq a)

-- | &lt;math&gt;. <tt>chunksOf c xs</tt> splits <tt>xs</tt> into chunks of
--   size <tt>c&gt;0</tt>. If <tt>c</tt> does not divide the length of
--   <tt>xs</tt> evenly, then the last element of the result will be short.
--   
--   Side note: the given performance bound is missing some messy terms
--   that only really affect edge cases. Performance degrades smoothly from
--   &lt;math&gt; (for &lt;math&gt;) to &lt;math&gt; (for &lt;math&gt;).
--   The true bound is more like &lt;math&gt;
chunksOf :: Int -> Seq a -> Seq (Seq a)

-- | &lt;math&gt; where &lt;math&gt; is the prefix length.
--   <a>takeWhileL</a>, applied to a predicate <tt>p</tt> and a sequence
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
takeWhileL :: (a -> Bool) -> Seq a -> Seq a

-- | &lt;math&gt; where &lt;math&gt; is the suffix length.
--   <a>takeWhileR</a>, applied to a predicate <tt>p</tt> and a sequence
--   <tt>xs</tt>, returns the longest suffix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <tt><a>takeWhileR</a> p xs</tt> is equivalent to <tt><a>reverse</a>
--   (<a>takeWhileL</a> p (<a>reverse</a> xs))</tt>.
takeWhileR :: (a -> Bool) -> Seq a -> Seq a

-- | &lt;math&gt; where &lt;math&gt; is the prefix length.
--   <tt><a>dropWhileL</a> p xs</tt> returns the suffix remaining after
--   <tt><a>takeWhileL</a> p xs</tt>.
dropWhileL :: (a -> Bool) -> Seq a -> Seq a

-- | &lt;math&gt; where &lt;math&gt; is the suffix length.
--   <tt><a>dropWhileR</a> p xs</tt> returns the prefix remaining after
--   <tt><a>takeWhileR</a> p xs</tt>.
--   
--   <tt><a>dropWhileR</a> p xs</tt> is equivalent to <tt><a>reverse</a>
--   (<a>dropWhileL</a> p (<a>reverse</a> xs))</tt>.
dropWhileR :: (a -> Bool) -> Seq a -> Seq a

-- | &lt;math&gt; where &lt;math&gt; is the prefix length. <a>spanl</a>,
--   applied to a predicate <tt>p</tt> and a sequence <tt>xs</tt>, returns
--   a pair whose first element is the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt> and the second element
--   is the remainder of the sequence.
spanl :: (a -> Bool) -> Seq a -> (Seq a, Seq a)

-- | &lt;math&gt; where &lt;math&gt; is the suffix length. <a>spanr</a>,
--   applied to a predicate <tt>p</tt> and a sequence <tt>xs</tt>, returns
--   a pair whose <i>first</i> element is the longest <i>suffix</i>
--   (possibly empty) of <tt>xs</tt> of elements that satisfy <tt>p</tt>
--   and the second element is the remainder of the sequence.
spanr :: (a -> Bool) -> Seq a -> (Seq a, Seq a)

-- | &lt;math&gt; where &lt;math&gt; is the breakpoint index.
--   <a>breakl</a>, applied to a predicate <tt>p</tt> and a sequence
--   <tt>xs</tt>, returns a pair whose first element is the longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and the second element is the remainder of the sequence.
--   
--   <tt><a>breakl</a> p</tt> is equivalent to <tt><a>spanl</a> (not .
--   p)</tt>.
breakl :: (a -> Bool) -> Seq a -> (Seq a, Seq a)

-- | <tt><a>breakr</a> p</tt> is equivalent to <tt><a>spanr</a> (not .
--   p)</tt>.
breakr :: (a -> Bool) -> Seq a -> (Seq a, Seq a)

-- | &lt;math&gt;. The <a>partition</a> function takes a predicate
--   <tt>p</tt> and a sequence <tt>xs</tt> and returns sequences of those
--   elements which do and do not satisfy the predicate.
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)

-- | &lt;math&gt;. The <a>filter</a> function takes a predicate <tt>p</tt>
--   and a sequence <tt>xs</tt> and returns a sequence of those elements
--   which satisfy the predicate.
filter :: (a -> Bool) -> Seq a -> Seq a

-- | &lt;math&gt;. <a>sort</a> sorts the specified <a>Seq</a> by the
--   natural ordering of its elements. The sort is stable. If stability is
--   not required, <a>unstableSort</a> can be slightly faster.
sort :: Ord a => Seq a -> Seq a

-- | &lt;math&gt;. <a>sortBy</a> sorts the specified <a>Seq</a> according
--   to the specified comparator. The sort is stable. If stability is not
--   required, <a>unstableSortBy</a> can be slightly faster.
sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a

-- | &lt;math&gt;. <a>unstableSort</a> sorts the specified <a>Seq</a> by
--   the natural ordering of its elements, but the sort is not stable. This
--   algorithm is frequently faster and uses less memory than <a>sort</a>.
unstableSort :: Ord a => Seq a -> Seq a

-- | &lt;math&gt;. A generalization of <a>unstableSort</a>,
--   <a>unstableSortBy</a> takes an arbitrary comparator and sorts the
--   specified sequence. The sort is not stable. This algorithm is
--   frequently faster and uses less memory than <a>sortBy</a>.
unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a

-- | &lt;math&gt;. The element at the specified position, counting from 0.
--   If the specified position is negative or at least the length of the
--   sequence, <a>lookup</a> returns <a>Nothing</a>.
--   
--   <pre>
--   0 &lt;= i &lt; length xs ==&gt; lookup i xs == Just (toList xs !! i)
--   </pre>
--   
--   <pre>
--   i &lt; 0 || i &gt;= length xs ==&gt; lookup i xs = Nothing
--   </pre>
--   
--   Unlike <a>index</a>, this can be used to retrieve an element without
--   forcing it. For example, to insert the fifth element of a sequence
--   <tt>xs</tt> into a <a>Map</a> <tt>m</tt> at key <tt>k</tt>, you could
--   use
--   
--   <pre>
--   case lookup 5 xs of
--     Nothing -&gt; m
--     Just x -&gt; <a>insert</a> k x m
--   </pre>
lookup :: Int -> Seq a -> Maybe a

-- | &lt;math&gt;. A flipped, infix version of <a>lookup</a>.
(!?) :: Seq a -> Int -> Maybe a

-- | &lt;math&gt;. The element at the specified position, counting from 0.
--   The argument should thus be a non-negative integer less than the size
--   of the sequence. If the position is out of range, <a>index</a> fails
--   with an error.
--   
--   <pre>
--   xs `index` i = toList xs !! i
--   </pre>
--   
--   Caution: <a>index</a> necessarily delays retrieving the requested
--   element until the result is forced. It can therefore lead to a space
--   leak if the result is stored, unforced, in another structure. To
--   retrieve an element immediately without forcing it, use <a>lookup</a>
--   or <a>(!?)</a>.
index :: Seq a -> Int -> a

-- | &lt;math&gt;. Update the element at the specified position. If the
--   position is out of range, the original sequence is returned.
--   <a>adjust</a> can lead to poor performance and even memory leaks,
--   because it does not force the new value before installing it in the
--   sequence. <a>adjust'</a> should usually be preferred.
adjust :: (a -> a) -> Int -> Seq a -> Seq a

-- | &lt;math&gt;. Update the element at the specified position. If the
--   position is out of range, the original sequence is returned. The new
--   value is forced before it is installed in the sequence.
--   
--   <pre>
--   adjust' f i xs =
--    case xs !? i of
--      Nothing -&gt; xs
--      Just x -&gt; let !x' = f x
--                in update i x' xs
--   </pre>
adjust' :: (a -> a) -> Int -> Seq a -> Seq a

-- | &lt;math&gt;. Replace the element at the specified position. If the
--   position is out of range, the original sequence is returned.
update :: Int -> a -> Seq a -> Seq a

-- | &lt;math&gt;. The first <tt>i</tt> elements of a sequence. If
--   <tt>i</tt> is negative, <tt><a>take</a> i s</tt> yields the empty
--   sequence. If the sequence contains fewer than <tt>i</tt> elements, the
--   whole sequence is returned.
take :: Int -> Seq a -> Seq a

-- | &lt;math&gt;. Elements of a sequence after the first <tt>i</tt>. If
--   <tt>i</tt> is negative, <tt><a>drop</a> i s</tt> yields the whole
--   sequence. If the sequence contains fewer than <tt>i</tt> elements, the
--   empty sequence is returned.
drop :: Int -> Seq a -> Seq a

-- | &lt;math&gt;. <tt><a>insertAt</a> i x xs</tt> inserts <tt>x</tt> into
--   <tt>xs</tt> at the index <tt>i</tt>, shifting the rest of the sequence
--   over.
--   
--   <pre>
--   insertAt 2 x (fromList [a,b,c,d]) = fromList [a,b,x,c,d]
--   insertAt 4 x (fromList [a,b,c,d]) = insertAt 10 x (fromList [a,b,c,d])
--                                     = fromList [a,b,c,d,x]
--   </pre>
--   
--   <pre>
--   insertAt i x xs = take i xs &gt;&lt; singleton x &gt;&lt; drop i xs
--   </pre>
insertAt :: Int -> a -> Seq a -> Seq a

-- | &lt;math&gt;. Delete the element of a sequence at a given index.
--   Return the original sequence if the index is out of range.
--   
--   <pre>
--   deleteAt 2 [a,b,c,d] = [a,b,d]
--   deleteAt 4 [a,b,c,d] = deleteAt (-1) [a,b,c,d] = [a,b,c,d]
--   </pre>
deleteAt :: Int -> Seq a -> Seq a

-- | &lt;math&gt;. Split a sequence at a given position. <tt><a>splitAt</a>
--   i s = (<a>take</a> i s, <a>drop</a> i s)</tt>.
splitAt :: Int -> Seq a -> (Seq a, Seq a)

-- | <a>elemIndexL</a> finds the leftmost index of the specified element,
--   if it is present, and otherwise <a>Nothing</a>.
elemIndexL :: Eq a => a -> Seq a -> Maybe Int

-- | <a>elemIndicesL</a> finds the indices of the specified element, from
--   left to right (i.e. in ascending order).
elemIndicesL :: Eq a => a -> Seq a -> [Int]

-- | <a>elemIndexR</a> finds the rightmost index of the specified element,
--   if it is present, and otherwise <a>Nothing</a>.
elemIndexR :: Eq a => a -> Seq a -> Maybe Int

-- | <a>elemIndicesR</a> finds the indices of the specified element, from
--   right to left (i.e. in descending order).
elemIndicesR :: Eq a => a -> Seq a -> [Int]

-- | <tt><a>findIndexL</a> p xs</tt> finds the index of the leftmost
--   element that satisfies <tt>p</tt>, if any exist.
findIndexL :: (a -> Bool) -> Seq a -> Maybe Int

-- | <tt><a>findIndicesL</a> p</tt> finds all indices of elements that
--   satisfy <tt>p</tt>, in ascending order.
findIndicesL :: (a -> Bool) -> Seq a -> [Int]

-- | <tt><a>findIndexR</a> p xs</tt> finds the index of the rightmost
--   element that satisfies <tt>p</tt>, if any exist.
findIndexR :: (a -> Bool) -> Seq a -> Maybe Int

-- | <tt><a>findIndicesR</a> p</tt> finds all indices of elements that
--   satisfy <tt>p</tt>, in descending order.
findIndicesR :: (a -> Bool) -> Seq a -> [Int]
foldMapWithIndex :: Monoid m => (Int -> a -> m) -> Seq a -> m

-- | <a>foldlWithIndex</a> is a version of <a>foldl</a> that also provides
--   access to the index of each element.
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b

-- | <a>foldrWithIndex</a> is a version of <a>foldr</a> that also provides
--   access to the index of each element.
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b

-- | A generalization of <a>fmap</a>, <a>mapWithIndex</a> takes a mapping
--   function that also depends on the element's index, and applies it to
--   every element in the sequence.
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b

-- | <a>traverseWithIndex</a> is a version of <a>traverse</a> that also
--   offers access to the index of each element.
traverseWithIndex :: Applicative f => (Int -> a -> f b) -> Seq a -> f (Seq b)

-- | &lt;math&gt;. The reverse of a sequence.
reverse :: Seq a -> Seq a

-- | &lt;math&gt;. Intersperse an element between the elements of a
--   sequence.
--   
--   <pre>
--   intersperse a empty = empty
--   intersperse a (singleton x) = singleton x
--   intersperse a (fromList [x,y]) = fromList [x,a,y]
--   intersperse a (fromList [x,y,z]) = fromList [x,a,y,a,z]
--   </pre>
intersperse :: a -> Seq a -> Seq a

-- | &lt;math&gt;. <a>zip</a> takes two sequences and returns a sequence of
--   corresponding pairs. If one input is short, excess elements are
--   discarded from the right end of the longer sequence.
zip :: Seq a -> Seq b -> Seq (a, b)

-- | &lt;math&gt;. <a>zipWith</a> generalizes <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function. For example, <tt>zipWith (+)</tt> is applied to two
--   sequences to take the sequence of corresponding sums.
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c

-- | &lt;math&gt;. <a>zip3</a> takes three sequences and returns a sequence
--   of triples, analogous to <a>zip</a>.
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)

-- | &lt;math&gt;. <a>zipWith3</a> takes a function which combines three
--   elements, as well as three sequences and returns a sequence of their
--   point-wise combinations, analogous to <a>zipWith</a>.
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d

-- | &lt;math&gt;. <a>zip4</a> takes four sequences and returns a sequence
--   of quadruples, analogous to <a>zip</a>.
zip4 :: Seq a -> Seq b -> Seq c -> Seq d -> Seq (a, b, c, d)

-- | &lt;math&gt;. <a>zipWith4</a> takes a function which combines four
--   elements, as well as four sequences and returns a sequence of their
--   point-wise combinations, analogous to <a>zipWith</a>.
zipWith4 :: (a -> b -> c -> d -> e) -> Seq a -> Seq b -> Seq c -> Seq d -> Seq e


-- | <tt>Set</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.Set as Set
--   </pre>
--   
--   This module does not export any partial or unchecked functions. For
--   those, see <a>RIO.Set.Partial</a> and <a>RIO.Set.Unchecked</a>
module RIO.Set

-- | A set of values <tt>a</tt>.
data () => Set a

-- | &lt;math&gt;. See <a>difference</a>.
(\\) :: Ord a => Set a -> Set a -> Set a
infixl 9 \\

-- | &lt;math&gt;. Is this the empty set?
null :: Set a -> Bool

-- | &lt;math&gt;. The number of elements in the set.
size :: Set a -> Int

-- | &lt;math&gt;. Is the element in the set?
member :: Ord a => a -> Set a -> Bool

-- | &lt;math&gt;. Is the element not in the set?
notMember :: Ord a => a -> Set a -> Bool

-- | &lt;math&gt;. Find largest element smaller than the given one.
--   
--   <pre>
--   lookupLT 3 (fromList [3, 5]) == Nothing
--   lookupLT 5 (fromList [3, 5]) == Just 3
--   </pre>
lookupLT :: Ord a => a -> Set a -> Maybe a

-- | &lt;math&gt;. Find smallest element greater than the given one.
--   
--   <pre>
--   lookupGT 4 (fromList [3, 5]) == Just 5
--   lookupGT 5 (fromList [3, 5]) == Nothing
--   </pre>
lookupGT :: Ord a => a -> Set a -> Maybe a

-- | &lt;math&gt;. Find largest element smaller or equal to the given one.
--   
--   <pre>
--   lookupLE 2 (fromList [3, 5]) == Nothing
--   lookupLE 4 (fromList [3, 5]) == Just 3
--   lookupLE 5 (fromList [3, 5]) == Just 5
--   </pre>
lookupLE :: Ord a => a -> Set a -> Maybe a

-- | &lt;math&gt;. Find smallest element greater or equal to the given one.
--   
--   <pre>
--   lookupGE 3 (fromList [3, 5]) == Just 3
--   lookupGE 4 (fromList [3, 5]) == Just 5
--   lookupGE 6 (fromList [3, 5]) == Nothing
--   </pre>
lookupGE :: Ord a => a -> Set a -> Maybe a

-- | &lt;math&gt;. <tt>(s1 `isSubsetOf` s2)</tt> indicates whether
--   <tt>s1</tt> is a subset of <tt>s2</tt>.
--   
--   <pre>
--   s1 `isSubsetOf` s2 = all (<a>`member`</a> s2) s1
--   s1 `isSubsetOf` s2 = null (s1 <a>`difference`</a> s2)
--   s1 `isSubsetOf` s2 = s1 <a>`union`</a> s2 == s2
--   s1 `isSubsetOf` s2 = s1 <a>`intersection`</a> s2 == s1
--   </pre>
isSubsetOf :: Ord a => Set a -> Set a -> Bool

-- | &lt;math&gt;. <tt>(s1 `isProperSubsetOf` s2)</tt> indicates whether
--   <tt>s1</tt> is a proper subset of <tt>s2</tt>.
--   
--   <pre>
--   s1 `isProperSubsetOf` s2 = s1 <a>`isSubsetOf`</a> s2 &amp;&amp; s1 /= s2
--   </pre>
isProperSubsetOf :: Ord a => Set a -> Set a -> Bool

-- | &lt;math&gt;. The empty set.
empty :: Set a

-- | &lt;math&gt;. Create a singleton set.
singleton :: a -> Set a

-- | &lt;math&gt;. Insert an element in a set. If the set already contains
--   an element equal to the given value, it is replaced with the new
--   value.
insert :: Ord a => a -> Set a -> Set a

-- | &lt;math&gt;. Delete an element from a set.
delete :: Ord a => a -> Set a -> Set a

-- | &lt;math&gt;. The union of two sets, preferring the first set when
--   equal elements are encountered.
union :: Ord a => Set a -> Set a -> Set a

-- | The union of the sets in a Foldable structure : (<tt><a>unions</a> ==
--   <a>foldl</a> <a>union</a> <a>empty</a></tt>).
unions :: (Foldable f, Ord a) => f (Set a) -> Set a

-- | &lt;math&gt;. Difference of two sets.
--   
--   Return elements of the first set not existing in the second set.
--   
--   <pre>
--   difference (fromList [5, 3]) (fromList [5, 7]) == singleton 3
--   </pre>
difference :: Ord a => Set a -> Set a -> Set a

-- | &lt;math&gt;. The intersection of two sets. Elements of the result
--   come from the first set, so for example
--   
--   <pre>
--   import qualified Data.Set as S
--   data AB = A | B deriving Show
--   instance Ord AB where compare _ _ = EQ
--   instance Eq AB where _ == _ = True
--   main = print (S.singleton A `S.intersection` S.singleton B,
--                 S.singleton B `S.intersection` S.singleton A)
--   </pre>
--   
--   prints <tt>(fromList [A],fromList [B])</tt>.
intersection :: Ord a => Set a -> Set a -> Set a

-- | &lt;math&gt;. Filter all elements that satisfy the predicate.
filter :: (a -> Bool) -> Set a -> Set a

-- | &lt;math&gt;. Take while a predicate on the elements holds. The user
--   is responsible for ensuring that for all elements <tt>j</tt> and
--   <tt>k</tt> in the set, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>. See
--   note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> p . <a>toList</a>
--   takeWhileAntitone p = <a>filter</a> p
--   </pre>
takeWhileAntitone :: (a -> Bool) -> Set a -> Set a

-- | &lt;math&gt;. Drop while a predicate on the elements holds. The user
--   is responsible for ensuring that for all elements <tt>j</tt> and
--   <tt>k</tt> in the set, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>. See
--   note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> p . <a>toList</a>
--   dropWhileAntitone p = <a>filter</a> (not . p)
--   </pre>
dropWhileAntitone :: (a -> Bool) -> Set a -> Set a

-- | &lt;math&gt;. Divide a set at the point where a predicate on the
--   elements stops holding. The user is responsible for ensuring that for
--   all elements <tt>j</tt> and <tt>k</tt> in the set, <tt>j &lt; k ==&gt;
--   p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = partition p xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the set at some <i>unspecified</i>
--   point where the predicate switches from holding to not holding (where
--   the predicate is seen to hold before the first element and to fail
--   after the last element).
spanAntitone :: (a -> Bool) -> Set a -> (Set a, Set a)

-- | &lt;math&gt;. Partition the set into two sets, one with all elements
--   that satisfy the predicate and one with all elements that don't
--   satisfy the predicate. See also <a>split</a>.
partition :: (a -> Bool) -> Set a -> (Set a, Set a)

-- | &lt;math&gt;. The expression (<tt><a>split</a> x set</tt>) is a pair
--   <tt>(set1,set2)</tt> where <tt>set1</tt> comprises the elements of
--   <tt>set</tt> less than <tt>x</tt> and <tt>set2</tt> comprises the
--   elements of <tt>set</tt> greater than <tt>x</tt>.
split :: Ord a => a -> Set a -> (Set a, Set a)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot element was found in the original set.
splitMember :: Ord a => a -> Set a -> (Set a, Bool, Set a)

-- | &lt;math&gt;. Decompose a set into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a set in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first subset less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList [1..6]) ==
--     [fromList [1,2,3],fromList [4],fromList [5,6]]
--   </pre>
--   
--   <pre>
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than three
--   subsets, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: Set a -> [Set a]

-- | &lt;math&gt;. Lookup the <i>index</i> of an element, which is its
--   zero-based index in the sorted sequence of elements. The index is a
--   number from <i>0</i> up to, but not including, the <a>size</a> of the
--   set.
--   
--   <pre>
--   isJust   (lookupIndex 2 (fromList [5,3])) == False
--   fromJust (lookupIndex 3 (fromList [5,3])) == 0
--   fromJust (lookupIndex 5 (fromList [5,3])) == 1
--   isJust   (lookupIndex 6 (fromList [5,3])) == False
--   </pre>
lookupIndex :: Ord a => a -> Set a -> Maybe Int

-- | &lt;math&gt;. Take a given number of elements in order, beginning with
--   the smallest ones.
--   
--   <pre>
--   take n = <a>fromDistinctAscList</a> . <a>take</a> n . <a>toAscList</a>
--   </pre>
take :: Int -> Set a -> Set a

-- | &lt;math&gt;. Drop a given number of elements in order, beginning with
--   the smallest ones.
--   
--   <pre>
--   drop n = <a>fromDistinctAscList</a> . <a>drop</a> n . <a>toAscList</a>
--   </pre>
drop :: Int -> Set a -> Set a

-- | &lt;math&gt;. Split a set at a particular index.
--   
--   <pre>
--   splitAt !n !xs = (<a>take</a> n xs, <a>drop</a> n xs)
--   </pre>
splitAt :: Int -> Set a -> (Set a, Set a)

-- | &lt;math&gt;. <tt><a>map</a> f s</tt> is the set obtained by applying
--   <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: Ord b => (a -> b) -> Set a -> Set b

-- | &lt;math&gt;. Fold the elements in the set using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toAscList set = foldr (:) [] set
--   </pre>
foldr :: (a -> b -> b) -> b -> Set a -> b

-- | &lt;math&gt;. Fold the elements in the set using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toDescList set = foldl (flip (:)) [] set
--   </pre>
foldl :: (a -> b -> a) -> a -> Set b -> a

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Set a -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Set b -> a

-- | &lt;math&gt;. The minimal element of a set.
lookupMin :: Set a -> Maybe a

-- | &lt;math&gt;. The maximal element of a set.
lookupMax :: Set a -> Maybe a

-- | &lt;math&gt;. Delete the minimal element. Returns an empty set if the
--   set is empty.
deleteMin :: Set a -> Set a

-- | &lt;math&gt;. Delete the maximal element. Returns an empty set if the
--   set is empty.
deleteMax :: Set a -> Set a

-- | &lt;math&gt;. Retrieves the maximal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
maxView :: Set a -> Maybe (a, Set a)

-- | &lt;math&gt;. Retrieves the minimal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
minView :: Set a -> Maybe (a, Set a)

-- | &lt;math&gt;. An alias of <a>toAscList</a>. The elements of a set in
--   ascending order. Subject to list fusion.
elems :: Set a -> [a]

-- | &lt;math&gt;. Convert the set to a list of elements. Subject to list
--   fusion.
toList :: Set a -> [a]

-- | &lt;math&gt;. Create a set from a list of elements.
--   
--   If the elements are ordered, a linear-time implementation is used,
--   with the performance equal to <a>fromDistinctAscList</a>.
fromList :: Ord a => [a] -> Set a

-- | &lt;math&gt;. Convert the set to an ascending list of elements.
--   Subject to list fusion.
toAscList :: Set a -> [a]

-- | &lt;math&gt;. Convert the set to a descending list of elements.
--   Subject to list fusion.
toDescList :: Set a -> [a]

-- | &lt;math&gt;. Show the tree that implements the set. The tree is shown
--   in a compressed, hanging format.
showTree :: Show a => Set a -> String

-- | &lt;math&gt;. The expression (<tt>showTreeWith hang wide map</tt>)
--   shows the tree that implements the set. If <tt>hang</tt> is
--   <tt>True</tt>, a <i>hanging</i> tree is shown otherwise a rotated tree
--   is shown. If <tt>wide</tt> is <a>True</a>, an extra wide version is
--   shown.
--   
--   <pre>
--   Set&gt; putStrLn $ showTreeWith True False $ fromDistinctAscList [1..5]
--   4
--   +--2
--   |  +--1
--   |  +--3
--   +--5
--   
--   Set&gt; putStrLn $ showTreeWith True True $ fromDistinctAscList [1..5]
--   4
--   |
--   +--2
--   |  |
--   |  +--1
--   |  |
--   |  +--3
--   |
--   +--5
--   
--   Set&gt; putStrLn $ showTreeWith False True $ fromDistinctAscList [1..5]
--   +--5
--   |
--   4
--   |
--   |  +--3
--   |  |
--   +--2
--      |
--      +--1
--   </pre>
showTreeWith :: Show a => Bool -> Bool -> Set a -> String

-- | &lt;math&gt;. Test if the internal set structure is valid.
valid :: Ord a => Set a -> Bool


-- | <tt>Set</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.Set.Partial as Set'
--   </pre>
module RIO.Set.Partial

-- | &lt;math&gt;. Return the <i>index</i> of an element, which is its
--   zero-based index in the sorted sequence of elements. The index is a
--   number from <i>0</i> up to, but not including, the <a>size</a> of the
--   set. Calls <a>error</a> when the element is not a <a>member</a> of the
--   set.
--   
--   <pre>
--   findIndex 2 (fromList [5,3])    Error: element is not in the set
--   findIndex 3 (fromList [5,3]) == 0
--   findIndex 5 (fromList [5,3]) == 1
--   findIndex 6 (fromList [5,3])    Error: element is not in the set
--   </pre>
findIndex :: Ord a => a -> Set a -> Int

-- | &lt;math&gt;. Retrieve an element by its <i>index</i>, i.e. by its
--   zero-based index in the sorted sequence of elements. If the
--   <i>index</i> is out of range (less than zero, greater or equal to
--   <a>size</a> of the set), <a>error</a> is called.
--   
--   <pre>
--   elemAt 0 (fromList [5,3]) == 3
--   elemAt 1 (fromList [5,3]) == 5
--   elemAt 2 (fromList [5,3])    Error: index out of range
--   </pre>
elemAt :: Int -> Set a -> a

-- | &lt;math&gt;. Delete the element at <i>index</i>, i.e. by its
--   zero-based index in the sorted sequence of elements. If the
--   <i>index</i> is out of range (less than zero, greater or equal to
--   <a>size</a> of the set), <a>error</a> is called.
--   
--   <pre>
--   deleteAt 0    (fromList [5,3]) == singleton 5
--   deleteAt 1    (fromList [5,3]) == singleton 3
--   deleteAt 2    (fromList [5,3])    Error: index out of range
--   deleteAt (-1) (fromList [5,3])    Error: index out of range
--   </pre>
deleteAt :: Int -> Set a -> Set a

-- | &lt;math&gt;. The minimal element of a set.
findMin :: Set a -> a

-- | &lt;math&gt;. The maximal element of a set.
findMax :: Set a -> a

-- | &lt;math&gt;. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin set = (findMin set, deleteMin set)
--   </pre>
deleteFindMin :: Set a -> (a, Set a)

-- | &lt;math&gt;. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax set = (findMax set, deleteMax set)
--   </pre>
deleteFindMax :: Set a -> (a, Set a)


-- | This module contains functions from <a>Data.Set</a> that have
--   unchecked preconditions on their input. If these preconditions are not
--   satisfied, the data structure may end up in an invalid state and other
--   operations may misbehave. Import as:
--   
--   <pre>
--   import qualified RIO.Set.Unchecked as Set'
--   </pre>
module RIO.Set.Unchecked

-- | &lt;math&gt;. The
--   
--   <tt><a>mapMonotonic</a> f s == <a>map</a> f s</tt>, but works only
--   when <tt>f</tt> is strictly increasing. <i>The precondition is not
--   checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapMonotonic f s == map f s
--       where ls = toList s
--   </pre>
mapMonotonic :: (a -> b) -> Set a -> Set b

-- | &lt;math&gt;. Build a set from an ascending list in linear time.
--   <i>The precondition (input list is ascending) is not checked.</i>
fromAscList :: Eq a => [a] -> Set a

-- | &lt;math&gt;. Build a set from a descending list in linear time.
--   <i>The precondition (input list is descending) is not checked.</i>
fromDescList :: Eq a => [a] -> Set a

-- | &lt;math&gt;. Build a set from an ascending list of distinct elements
--   in linear time. <i>The precondition (input list is strictly ascending)
--   is not checked.</i>
fromDistinctAscList :: [a] -> Set a

-- | &lt;math&gt;. Build a set from a descending list of distinct elements
--   in linear time. <i>The precondition (input list is strictly
--   descending) is not checked.</i>
fromDistinctDescList :: [a] -> Set a


-- | Provides reexports of <tt>MonadState</tt> and related helpers.
module RIO.State

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: MonadState s m => (s -> s) -> m ()

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: (s -> s) -> State s a -> State s a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype () => StateT s (m :: Type -> Type) a
StateT :: (s -> m (a, s)) -> StateT s (m :: Type -> Type) a
[runStateT] :: StateT s (m :: Type -> Type) a -> s -> m (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: forall s (m :: Type -> Type) a. (s -> s) -> StateT s m a -> StateT s m a


-- | Strict <tt>Text</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.Text as T
--   </pre>
--   
--   This module does not export any partial functions. For those, see
--   <a>RIO.Text.Partial</a>
module RIO.Text

-- | A space efficient, packed, unboxed Unicode text type.
data () => Text

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>Text</a>. Performs
--   replacement on invalid scalar values, so <tt><a>unpack</a> .
--   <a>pack</a></tt> is not <a>id</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Data.Text.unpack (pack "\55555")
--   "\65533"
--   </pre>
pack :: String -> Text

-- | <i>O(n)</i> Convert a <a>Text</a> into a <a>String</a>.
unpack :: Text -> String

-- | <i>O(1)</i> Convert a character into a Text. Performs replacement on
--   invalid scalar values.
singleton :: Char -> Text

-- | <i>O(1)</i> The empty <a>Text</a>.
empty :: Text

-- | <i>O(n)</i> Adds a character to the front of a <a>Text</a>. This
--   function is more costly than its <tt>List</tt> counterpart because it
--   requires copying a new array. Performs replacement on invalid scalar
--   values.
cons :: Char -> Text -> Text
infixr 5 `cons`

-- | <i>O(n)</i> Adds a character to the end of a <a>Text</a>. This copies
--   the entire array in the process. Performs replacement on invalid
--   scalar values.
snoc :: Text -> Char -> Text

-- | <i>O(n)</i> Appends one <a>Text</a> to the other by copying both of
--   them into a new <a>Text</a>.
append :: Text -> Text -> Text

-- | <i>O(1)</i> Returns the first character and rest of a <a>Text</a>, or
--   <a>Nothing</a> if empty.
uncons :: Text -> Maybe (Char, Text)

-- | <i>O(1)</i> Tests whether a <a>Text</a> is empty or not.
null :: Text -> Bool

-- | <i>O(n)</i> Returns the number of characters in a <a>Text</a>.
length :: Text -> Int

-- | <i>O(min(n,c))</i> Compare the count of characters in a <a>Text</a> to
--   a number.
--   
--   <pre>
--   <a>compareLength</a> t c = <a>compare</a> (<a>length</a> t) c
--   </pre>
--   
--   This function gives the same answer as comparing against the result of
--   <a>length</a>, but can short circuit if the count of characters is
--   greater than the number, and hence be more efficient.
compareLength :: Text -> Int -> Ordering

-- | <i>O(n)</i> <a>map</a> <tt>f</tt> <tt>t</tt> is the <a>Text</a>
--   obtained by applying <tt>f</tt> to each element of <tt>t</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; let message = pack "I am not angry. Not at all."
--   
--   &gt;&gt;&gt; T.map (\c -&gt; if c == '.' then '!' else c) message
--   "I am not angry! Not at all!"
--   </pre>
--   
--   Performs replacement on invalid scalar values.
map :: (Char -> Char) -> Text -> Text

-- | <i>O(n)</i> The <a>intercalate</a> function takes a <a>Text</a> and a
--   list of <a>Text</a>s and concatenates the list after interspersing the
--   first argument between each element of the list.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; T.intercalate "NI!" ["We", "seek", "the", "Holy", "Grail"]
--   "WeNI!seekNI!theNI!HolyNI!Grail"
--   </pre>
intercalate :: Text -> [Text] -> Text

-- | <i>O(n)</i> The <a>intersperse</a> function takes a character and
--   places it between the characters of a <a>Text</a>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; T.intersperse '.' "SHIELD"
--   "S.H.I.E.L.D"
--   </pre>
--   
--   Performs replacement on invalid scalar values.
intersperse :: Char -> Text -> Text

-- | <i>O(n)</i> The <a>transpose</a> function transposes the rows and
--   columns of its <a>Text</a> argument. Note that this function uses
--   <a>pack</a>, <a>unpack</a>, and the list version of transpose, and is
--   thus not very efficient.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; transpose ["green","orange"]
--   ["go","rr","ea","en","ng","e"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; transpose ["blue","red"]
--   ["br","le","ud","e"]
--   </pre>
transpose :: [Text] -> [Text]

-- | <i>O(n)</i> Reverse the characters of a string.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; T.reverse "desrever"
--   "reversed"
--   </pre>
reverse :: Text -> Text

-- | <i>O(n)</i> Convert a string to folded case.
--   
--   This function is mainly useful for performing caseless (also known as
--   case insensitive) string comparisons.
--   
--   A string <tt>x</tt> is a caseless match for a string <tt>y</tt> if and
--   only if:
--   
--   <pre>
--   toCaseFold x == toCaseFold y
--   </pre>
--   
--   The result string may be longer than the input string, and may differ
--   from applying <a>toLower</a> to the input string. For instance, the
--   Armenian small ligature "ﬓ" (men now, U+FB13) is case folded to the
--   sequence "մ" (men, U+0574) followed by "ն" (now, U+0576), while the
--   Greek "µ" (micro sign, U+00B5) is case folded to "μ" (small letter mu,
--   U+03BC) instead of itself.
toCaseFold :: Text -> Text

-- | <i>O(n)</i> Convert a string to lower case, using simple case
--   conversion.
--   
--   The result string may be longer than the input string. For instance,
--   "İ" (Latin capital letter I with dot above, U+0130) maps to the
--   sequence "i" (Latin small letter i, U+0069) followed by " ̇"
--   (combining dot above, U+0307).
toLower :: Text -> Text

-- | <i>O(n)</i> Convert a string to upper case, using simple case
--   conversion.
--   
--   The result string may be longer than the input string. For instance,
--   the German "ß" (eszett, U+00DF) maps to the two-letter sequence "SS".
toUpper :: Text -> Text

-- | <i>O(n)</i> Convert a string to title case, using simple case
--   conversion.
--   
--   The first letter (as determined by <a>isLetter</a>) of the input is
--   converted to title case, as is every subsequent letter that
--   immediately follows a non-letter. Every letter that immediately
--   follows another letter is converted to lower case.
--   
--   This function is not idempotent. Consider lower-case letter <tt>ŉ</tt>
--   (U+0149 LATIN SMALL LETTER N PRECEDED BY APOSTROPHE). Then
--   <a>toTitle</a> <tt>"ŉ"</tt> = <tt>"ʼN"</tt>: the first (and the only)
--   letter of the input is converted to title case, becoming two letters.
--   Now <tt>ʼ</tt> (U+02BC MODIFIER LETTER APOSTROPHE) is a modifier
--   letter and as such is recognised as a letter by <a>isLetter</a>, so
--   <a>toTitle</a> <tt>"ʼN"</tt> = <tt>"'n"</tt>.
--   
--   The result string may be longer than the input string. For example,
--   the Latin small ligature ﬂ (U+FB02) is converted to the sequence Latin
--   capital letter F (U+0046) followed by Latin small letter l (U+006C).
--   
--   <i>Note</i>: this function does not take language or culture specific
--   rules into account. For instance, in English, different style guides
--   disagree on whether the book name "The Hill of the Red Fox" is
--   correctly title cased—but this function will capitalize <i>every</i>
--   word.
toTitle :: Text -> Text

-- | <i>O(n)</i> Left-justify a string to the given length, using the
--   specified fill character on the right. Performs replacement on invalid
--   scalar values.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; justifyLeft 7 'x' "foo"
--   "fooxxxx"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; justifyLeft 3 'x' "foobar"
--   "foobar"
--   </pre>
justifyLeft :: Int -> Char -> Text -> Text

-- | <i>O(n)</i> Right-justify a string to the given length, using the
--   specified fill character on the left. Performs replacement on invalid
--   scalar values.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; justifyRight 7 'x' "bar"
--   "xxxxbar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; justifyRight 3 'x' "foobar"
--   "foobar"
--   </pre>
justifyRight :: Int -> Char -> Text -> Text

-- | <i>O(n)</i> Center a string to the given length, using the specified
--   fill character on either side. Performs replacement on invalid scalar
--   values.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; center 8 'x' "HS"
--   "xxxHSxxx"
--   </pre>
center :: Int -> Char -> Text -> Text

-- | <i>O(n)</i> <a>foldl</a>, applied to a binary operator, a starting
--   value (typically the left-identity of the operator), and a
--   <a>Text</a>, reduces the <a>Text</a> using the binary operator, from
--   left to right.
foldl :: (a -> Char -> a) -> a -> Text -> a

-- | <i>O(n)</i> A strict version of <a>foldl</a>.
foldl' :: (a -> Char -> a) -> a -> Text -> a

-- | <i>O(n)</i> <a>foldr</a>, applied to a binary operator, a starting
--   value (typically the right-identity of the operator), and a
--   <a>Text</a>, reduces the <a>Text</a> using the binary operator, from
--   right to left.
--   
--   If the binary operator is strict in its second argument, use
--   <a>foldr'</a> instead.
--   
--   <a>foldr</a> is lazy like <a>foldr</a> for lists: evaluation actually
--   traverses the <a>Text</a> from left to right, only as far as it needs
--   to.
--   
--   For example, <a>head</a> can be defined with <i>O(1)</i> complexity
--   using <a>foldr</a>:
--   
--   <pre>
--   head :: Text -&gt; Char
--   head = foldr const (error "head empty")
--   </pre>
--   
--   Searches from left to right with short-circuiting behavior can also be
--   defined using <a>foldr</a> (<i>e.g.</i>, <a>any</a>, <a>all</a>,
--   <a>find</a>, <a>elem</a>).
foldr :: (Char -> a -> a) -> a -> Text -> a

-- | <i>O(n)</i> Concatenate a list of <a>Text</a>s.
concat :: [Text] -> Text

-- | <i>O(n)</i> Map a function over a <a>Text</a> that results in a
--   <a>Text</a>, and concatenate the results.
concatMap :: (Char -> Text) -> Text -> Text

-- | <i>O(n)</i> <a>any</a> <tt>p</tt> <tt>t</tt> determines whether any
--   character in the <a>Text</a> <tt>t</tt> satisfies the predicate
--   <tt>p</tt>.
any :: (Char -> Bool) -> Text -> Bool

-- | <i>O(n)</i> <a>all</a> <tt>p</tt> <tt>t</tt> determines whether all
--   characters in the <a>Text</a> <tt>t</tt> satisfy the predicate
--   <tt>p</tt>.
all :: (Char -> Bool) -> Text -> Bool

-- | <i>O(n)</i> <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left. Performs replacement
--   on invalid scalar values.
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   <b>Properties</b>
--   
--   <pre>
--   <a>head</a> (<a>scanl</a> f z xs) = z
--   </pre>
--   
--   <pre>
--   <a>last</a> (<a>scanl</a> f z xs) = <a>foldl</a> f z xs
--   </pre>
scanl :: (Char -> Char -> Char) -> Char -> Text -> Text

-- | <i>O(n)</i> <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument. Performs replacement on invalid scalar
--   values.
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (Char -> Char -> Char) -> Text -> Text

-- | <i>O(n)</i> <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Performs replacement on invalid scalar values.
--   
--   <pre>
--   scanr f v == reverse . scanl (flip f) v . reverse
--   </pre>
scanr :: (Char -> Char -> Char) -> Char -> Text -> Text

-- | <i>O(n)</i> <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument. Performs replacement on invalid scalar
--   values.
scanr1 :: (Char -> Char -> Char) -> Text -> Text

-- | <i>O(n)</i> Like a combination of <a>map</a> and <a>foldl'</a>.
--   Applies a function to each element of a <a>Text</a>, passing an
--   accumulating parameter from left to right, and returns a final
--   <a>Text</a>. Performs replacement on invalid scalar values.
mapAccumL :: (a -> Char -> (a, Char)) -> a -> Text -> (a, Text)

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and a strict <a>foldr</a>; it applies a function to each element of a
--   <a>Text</a>, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   <a>Text</a>. Performs replacement on invalid scalar values.
mapAccumR :: (a -> Char -> (a, Char)) -> a -> Text -> (a, Text)

-- | <i>O(n*m)</i> <a>replicate</a> <tt>n</tt> <tt>t</tt> is a <a>Text</a>
--   consisting of the input <tt>t</tt> repeated <tt>n</tt> times.
replicate :: Int -> Text -> Text

-- | <i>O(n)</i>, where <tt>n</tt> is the length of the result. The
--   <a>unfoldr</a> function is analogous to the List <a>unfoldr</a>.
--   <a>unfoldr</a> builds a <a>Text</a> from a seed value. The function
--   takes the element and returns <a>Nothing</a> if it is done producing
--   the <a>Text</a>, otherwise <a>Just</a> <tt>(a,b)</tt>. In this case,
--   <tt>a</tt> is the next <a>Char</a> in the string, and <tt>b</tt> is
--   the seed value for further production. Performs replacement on invalid
--   scalar values.
unfoldr :: (a -> Maybe (Char, a)) -> a -> Text

-- | <i>O(n)</i> Like <a>unfoldr</a>, <a>unfoldrN</a> builds a <a>Text</a>
--   from a seed value. However, the length of the result should be limited
--   by the first argument to <a>unfoldrN</a>. This function is more
--   efficient than <a>unfoldr</a> when the maximum length of the result is
--   known and correct, otherwise its performance is similar to
--   <a>unfoldr</a>. Performs replacement on invalid scalar values.
unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> Text

-- | <i>O(n)</i> <a>take</a> <tt>n</tt>, applied to a <a>Text</a>, returns
--   the prefix of the <a>Text</a> of length <tt>n</tt>, or the <a>Text</a>
--   itself if <tt>n</tt> is greater than the length of the Text.
take :: Int -> Text -> Text

-- | <i>O(n)</i> <a>takeEnd</a> <tt>n</tt> <tt>t</tt> returns the suffix
--   remaining after taking <tt>n</tt> characters from the end of
--   <tt>t</tt>.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; takeEnd 3 "foobar"
--   "bar"
--   </pre>
takeEnd :: Int -> Text -> Text

-- | <i>O(n)</i> <a>drop</a> <tt>n</tt>, applied to a <a>Text</a>, returns
--   the suffix of the <a>Text</a> after the first <tt>n</tt> characters,
--   or the empty <a>Text</a> if <tt>n</tt> is greater than the length of
--   the <a>Text</a>.
drop :: Int -> Text -> Text

-- | <i>O(n)</i> <a>dropEnd</a> <tt>n</tt> <tt>t</tt> returns the prefix
--   remaining after dropping <tt>n</tt> characters from the end of
--   <tt>t</tt>.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; dropEnd 3 "foobar"
--   "foo"
--   </pre>
dropEnd :: Int -> Text -> Text

-- | <i>O(n)</i> <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a
--   <a>Text</a>, returns the longest prefix (possibly empty) of elements
--   that satisfy <tt>p</tt>.
takeWhile :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> <a>takeWhileEnd</a>, applied to a predicate <tt>p</tt> and
--   a <a>Text</a>, returns the longest suffix (possibly empty) of elements
--   that satisfy <tt>p</tt>. Examples:
--   
--   <pre>
--   &gt;&gt;&gt; takeWhileEnd (=='o') "foo"
--   "oo"
--   </pre>
takeWhileEnd :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> <a>dropWhile</a> <tt>p</tt> <tt>t</tt> returns the suffix
--   remaining after <a>takeWhile</a> <tt>p</tt> <tt>t</tt>.
dropWhile :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> <a>dropWhileEnd</a> <tt>p</tt> <tt>t</tt> returns the
--   prefix remaining after dropping characters that satisfy the predicate
--   <tt>p</tt> from the end of <tt>t</tt>.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd (=='.') "foo..."
--   "foo"
--   </pre>
dropWhileEnd :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> <a>dropAround</a> <tt>p</tt> <tt>t</tt> returns the
--   substring remaining after dropping characters that satisfy the
--   predicate <tt>p</tt> from both the beginning and end of <tt>t</tt>.
dropAround :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> Remove leading and trailing white space from a string.
--   Equivalent to:
--   
--   <pre>
--   dropAround isSpace
--   </pre>
strip :: Text -> Text

-- | <i>O(n)</i> Remove leading white space from a string. Equivalent to:
--   
--   <pre>
--   dropWhile isSpace
--   </pre>
stripStart :: Text -> Text

-- | <i>O(n)</i> Remove trailing white space from a string. Equivalent to:
--   
--   <pre>
--   dropWhileEnd isSpace
--   </pre>
stripEnd :: Text -> Text

-- | <i>O(n)</i> <a>splitAt</a> <tt>n t</tt> returns a pair whose first
--   element is a prefix of <tt>t</tt> of length <tt>n</tt>, and whose
--   second is the remainder of the string. It is equivalent to
--   <tt>(<a>take</a> n t, <a>drop</a> n t)</tt>.
splitAt :: Int -> Text -> (Text, Text)

-- | <i>O(n)</i> <a>break</a> is like <a>span</a>, but the prefix returned
--   is over elements that fail the predicate <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; T.break (=='c') "180cm"
--   ("180","cm")
--   </pre>
break :: (Char -> Bool) -> Text -> (Text, Text)

-- | <i>O(n)</i> <a>span</a>, applied to a predicate <tt>p</tt> and text
--   <tt>t</tt>, returns a pair whose first element is the longest prefix
--   (possibly empty) of <tt>t</tt> of elements that satisfy <tt>p</tt>,
--   and whose second is the remainder of the text.
--   
--   <pre>
--   &gt;&gt;&gt; T.span (=='0') "000AB"
--   ("000","AB")
--   </pre>
span :: (Char -> Bool) -> Text -> (Text, Text)

-- | <i>O(n)</i> Group characters in a string by equality.
group :: Text -> [Text]

-- | <i>O(n)</i> Group characters in a string according to a predicate.
groupBy :: (Char -> Char -> Bool) -> Text -> [Text]

-- | <i>O(n)</i> Return all initial segments of the given <a>Text</a>,
--   shortest first.
inits :: Text -> [Text]

-- | <i>O(n)</i> Return all final segments of the given <a>Text</a>,
--   longest first.
tails :: Text -> [Text]

-- | <i>O(n)</i> Splits a <a>Text</a> into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. eg.
--   
--   <pre>
--   &gt;&gt;&gt; split (=='a') "aabbaca"
--   ["","","bb","c",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (=='a') ""
--   [""]
--   </pre>
split :: (Char -> Bool) -> Text -> [Text]

-- | <i>O(n)</i> Splits a <a>Text</a> into components of length <tt>k</tt>.
--   The last element may be shorter than the other chunks, depending on
--   the length of the input. Examples:
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 3 "foobarbaz"
--   ["foo","bar","baz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 4 "haskell.org"
--   ["hask","ell.","org"]
--   </pre>
chunksOf :: Int -> Text -> [Text]

-- | <i>O(n)</i> Breaks a <a>Text</a> up into a list of <a>Text</a>s at
--   newline characters <tt>'\n'</tt> (LF, line feed). The resulting
--   strings do not contain newlines.
--   
--   <a>lines</a> <b>does not</b> treat <tt>'\r'</tt> (CR, carriage return)
--   as a newline character.
lines :: Text -> [Text]

-- | <a>linesCR</a> breaks a <a>Text</a> up into a list of <a>Text</a>s at
--   newline <a>Char</a>s. It is very similar to <a>lines</a>, but it also
--   removes any trailing <tt>'r'</tt> characters. The resulting
--   <a>Text</a> values do not contain newlines or trailing <tt>'r'</tt>
--   characters.
linesCR :: Text -> [Text]

-- | <i>O(n)</i> Breaks a <a>Text</a> up into a list of words, delimited by
--   <a>Char</a>s representing white space.
words :: Text -> [Text]

-- | <i>O(n)</i> Joins lines, after appending a terminating newline to
--   each.
unlines :: [Text] -> Text

-- | <i>O(n)</i> Joins words using single space characters.
unwords :: [Text] -> Text

-- | <i>O(n)</i> The <a>isPrefixOf</a> function takes two <a>Text</a>s and
--   returns <a>True</a> if and only if the first is a prefix of the
--   second.
isPrefixOf :: Text -> Text -> Bool

-- | <i>O(n)</i> The <a>isSuffixOf</a> function takes two <a>Text</a>s and
--   returns <a>True</a> if and only if the first is a suffix of the
--   second.
isSuffixOf :: Text -> Text -> Bool

-- | <i>O(n+m)</i> The <a>isInfixOf</a> function takes two <a>Text</a>s and
--   returns <a>True</a> if and only if the first is contained, wholly and
--   intact, anywhere within the second.
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
isInfixOf :: Text -> Text -> Bool

-- | <i>O(n)</i> Return the suffix of the second string if its prefix
--   matches the entire first string.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix ""    "baz"
--   Just "baz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "quux"
--   Nothing
--   </pre>
--   
--   This is particularly useful with the <tt>ViewPatterns</tt> extension
--   to GHC, as follows:
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns #-}
--   import Data.Text as T
--   
--   fnordLength :: Text -&gt; Int
--   fnordLength (stripPrefix "fnord" -&gt; Just suf) = T.length suf
--   fnordLength _                                 = -1
--   </pre>
stripPrefix :: Text -> Text -> Maybe Text

-- | <i>O(n)</i> Return the prefix of the second string if its suffix
--   matches the entire first string.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix "bar" "foobar"
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix ""    "baz"
--   Just "baz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix "foo" "quux"
--   Nothing
--   </pre>
--   
--   This is particularly useful with the <tt>ViewPatterns</tt> extension
--   to GHC, as follows:
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns #-}
--   import Data.Text as T
--   
--   quuxLength :: Text -&gt; Int
--   quuxLength (stripSuffix "quux" -&gt; Just pre) = T.length pre
--   quuxLength _                                = -1
--   </pre>
stripSuffix :: Text -> Text -> Maybe Text

-- | Drop prefix if present, otherwise return original <a>Text</a>.
dropPrefix :: Text -> Text -> Text

-- | Drop prefix if present, otherwise return original <a>Text</a>.
dropSuffix :: Text -> Text -> Text

-- | <i>O(n)</i> Find the longest non-empty common prefix of two strings
--   and return it, along with the suffixes of each string at which they no
--   longer match.
--   
--   If the strings do not have a common prefix or either one is empty,
--   this function returns <a>Nothing</a>.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; commonPrefixes "foobar" "fooquux"
--   Just ("foo","bar","quux")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; commonPrefixes "veeble" "fetzer"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; commonPrefixes "" "baz"
--   Nothing
--   </pre>
commonPrefixes :: Text -> Text -> Maybe (Text, Text, Text)

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a <a>Text</a>,
--   returns a <a>Text</a> containing those characters that satisfy the
--   predicate.
filter :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   <a>Text</a>, and returns the first element matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: (Char -> Bool) -> Text -> Maybe Char

-- | <i>O(n)</i> The <a>partition</a> function takes a predicate and a
--   <a>Text</a>, and returns the pair of <a>Text</a>s with elements which
--   do and do not satisfy the predicate, respectively; i.e.
--   
--   <pre>
--   partition p t == (filter p t, filter (not . p) t)
--   </pre>
partition :: (Char -> Bool) -> Text -> (Text, Text)

-- | <i>O(n)</i> <a>Text</a> index (subscript) operator, starting from 0.
index :: HasCallStack => Text -> Int -> Char

-- | <i>O(n)</i> The <a>findIndex</a> function takes a predicate and a
--   <a>Text</a> and returns the index of the first element in the
--   <a>Text</a> satisfying the predicate.
findIndex :: (Char -> Bool) -> Text -> Maybe Int

-- | <i>O(n)</i> <a>zip</a> takes two <a>Text</a>s and returns a list of
--   corresponding pairs of bytes. If one input <a>Text</a> is short,
--   excess elements of the longer <a>Text</a> are discarded. This is
--   equivalent to a pair of <a>unpack</a> operations.
zip :: Text -> Text -> [(Char, Char)]

-- | <i>O(n)</i> <a>zipWith</a> generalises <a>zip</a> by zipping with the
--   function given as the first argument, instead of a tupling function.
--   Performs replacement on invalid scalar values.
zipWith :: (Char -> Char -> Char) -> Text -> Text -> Text

-- | <i>O(n)</i> Make a distinct copy of the given string, sharing no
--   storage with the original string.
--   
--   As an example, suppose you read a large string, of which you need only
--   a small portion. If you do not use <a>copy</a>, the entire original
--   array will be kept alive in memory by the smaller string. Making a
--   copy "breaks the link" to the original array, allowing it to be
--   garbage collected if there are no other live references to it.
copy :: Text -> Text

-- | <i>O(n)</i> Convert a null-terminated <a>modified UTF-8</a> (but with
--   a standard UTF-8 representation of characters from supplementary
--   planes) string to a <a>Text</a>. Counterpart to
--   <a>unpackCStringUtf8#</a>. No validation is performed, malformed input
--   can lead to memory access violation.
unpackCString# :: Addr# -> Text

-- | Encode text using UTF-8 encoding.
encodeUtf8 :: Text -> ByteString

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   Surrogate code points in replacement character returned by
--   <a>OnDecodeError</a> will be automatically remapped to the replacement
--   char <tt>U+FFFD</tt>.
decodeUtf8With :: OnDecodeError -> ByteString -> Text

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   If the input contains any invalid UTF-8 data, the relevant exception
--   will be returned, otherwise the decoded text.
decodeUtf8' :: ByteString -> Either UnicodeException Text

-- | Replace an invalid input byte with the Unicode replacement character
--   U+FFFD.
lenientDecode :: OnDecodeError

module RIO

-- | The Reader+IO monad. This is different from a <a>ReaderT</a> because:
--   
--   <ul>
--   <li>It's not a transformer, it hardcodes IO for simpler usage and
--   error messages.</li>
--   <li>Instances of typeclasses like <tt>MonadLogger</tt> are implemented
--   using classes defined on the environment, instead of using an
--   underlying monad.</li>
--   </ul>
newtype RIO env a
RIO :: ReaderT env IO a -> RIO env a
[unRIO] :: RIO env a -> ReaderT env IO a

-- | Abstract <a>RIO</a> to an arbitrary <a>MonadReader</a> instance, which
--   can handle IO.
liftRIO :: (MonadIO m, MonadReader env m) => RIO env a -> m a

-- | Using the environment run in IO the action that requires that
--   environment.
runRIO :: MonadIO m => env -> RIO env a -> m a

-- | Given a <a>LogOptions</a> value, run the given function with the
--   specified <a>LogFunc</a>. A common way to use this function is:
--   
--   <pre>
--   let isVerbose = False -- get from the command line instead
--   logOptions' &lt;- logOptionsHandle stderr isVerbose
--   let logOptions = setLogUseTime True logOptions'
--   withLogFunc logOptions $ \lf -&gt; do
--     let app = App -- application specific environment
--           { appLogFunc = lf
--           , appOtherStuff = ...
--           }
--     runRIO app $ do
--       logInfo "Starting app"
--       myApp
--   </pre>
withLogFunc :: MonadUnliftIO m => LogOptions -> (LogFunc -> m a) -> m a

-- | Given a <a>LogOptions</a> value, returns both a new <a>LogFunc</a> and
--   a sub-routine that disposes it.
--   
--   Intended for use if you want to deal with the teardown of
--   <a>LogFunc</a> yourself, otherwise prefer the <a>withLogFunc</a>
--   function instead.
newLogFunc :: (MonadIO n, MonadIO m) => LogOptions -> n (LogFunc, m ())

-- | A logging function, wrapped in a newtype for better error messages.
--   
--   An implementation may choose any behavior of this value it wishes,
--   including printing to standard output or no action at all.
data LogFunc

-- | Environment values with a logging function.
class HasLogFunc env
logFuncL :: HasLogFunc env => Lens' env LogFunc

-- | Create a <a>LogOptions</a> value from the given <a>Handle</a> and
--   whether to perform verbose logging or not. Individiual settings can be
--   overridden using appropriate <tt>set</tt> functions. Logging output is
--   guaranteed to be non-interleaved only for a UTF-8 <a>Handle</a> in a
--   multi-thread environment.
--   
--   When Verbose Flag is <tt>True</tt>, the following happens:
--   
--   <ul>
--   <li><tt>setLogVerboseFormat</tt> is called with <tt>True</tt></li>
--   <li><tt>setLogUseColor</tt> is called with <tt>True</tt> (except on
--   Windows)</li>
--   <li><tt>setLogUseLoc</tt> is called with <tt>True</tt></li>
--   <li><tt>setLogUseTime</tt> is called with <tt>True</tt></li>
--   <li><tt>setLogMinLevel</tt> is called with <tt>Debug</tt> log
--   level</li>
--   </ul>
logOptionsHandle :: MonadIO m => Handle -> Bool -> m LogOptions

-- | Configuration for how to create a <a>LogFunc</a>. Intended to be used
--   with the <a>withLogFunc</a> function.
data LogOptions

-- | Set the minimum log level. Messages below this level will not be
--   printed.
--   
--   Default: in verbose mode, <a>LevelDebug</a>. Otherwise,
--   <a>LevelInfo</a>.
setLogMinLevel :: LogLevel -> LogOptions -> LogOptions

-- | Refer to <a>setLogMinLevel</a>. This modifier allows to alter the
--   verbose format value dynamically at runtime.
--   
--   Default: in verbose mode, <a>LevelDebug</a>. Otherwise,
--   <a>LevelInfo</a>.
setLogMinLevelIO :: IO LogLevel -> LogOptions -> LogOptions

-- | Use the verbose format for printing log messages.
--   
--   Default: follows the value of the verbose flag.
setLogVerboseFormat :: Bool -> LogOptions -> LogOptions

-- | Refer to <a>setLogVerboseFormat</a>. This modifier allows to alter the
--   verbose format value dynamically at runtime.
--   
--   Default: follows the value of the verbose flag.
setLogVerboseFormatIO :: IO Bool -> LogOptions -> LogOptions

-- | Do we treat output as a terminal. If <tt>True</tt>, we will enable
--   sticky logging functionality.
--   
--   Default: checks if the <tt>Handle</tt> provided to
--   <a>logOptionsHandle</a> is a terminal with <a>hIsTerminalDevice</a>.
setLogTerminal :: Bool -> LogOptions -> LogOptions

-- | Include the time when printing log messages.
--   
--   Default: <a>True</a> in debug mode, <a>False</a> otherwise.
setLogUseTime :: Bool -> LogOptions -> LogOptions

-- | Use ANSI color codes in the log output.
--   
--   Default: <a>True</a> if in verbose mode <i>and</i> the <a>Handle</a>
--   is a terminal device.
setLogUseColor :: Bool -> LogOptions -> LogOptions

-- | Use code location in the log output.
--   
--   Default: <a>True</a> if in verbose mode, <a>False</a> otherwise.
setLogUseLoc :: Bool -> LogOptions -> LogOptions

-- | Set format method for messages
--   
--   Default: <a>id</a>
setLogFormat :: (Utf8Builder -> Utf8Builder) -> LogOptions -> LogOptions

-- | ANSI color codes for <a>LogLevel</a> in the log output.
--   
--   Default: <a>LevelDebug</a> = "\ESC[32m" -- Green <a>LevelInfo</a> =
--   "\ESC[34m" -- Blue <a>LevelWarn</a> = "\ESC[33m" -- Yellow
--   <a>LevelError</a> = "\ESC[31m" -- Red <a>LevelOther</a> _ = "\ESC[35m"
--   -- Magenta
setLogLevelColors :: (LogLevel -> Utf8Builder) -> LogOptions -> LogOptions

-- | ANSI color codes for secondary content in the log output.
--   
--   Default: "\ESC[90m" -- Bright black (gray)
setLogSecondaryColor :: Utf8Builder -> LogOptions -> LogOptions

-- | ANSI color codes for accents in the log output. Accent colors are
--   indexed by <a>Int</a>.
--   
--   Default: <a>const</a> "\ESC[92m" -- Bright green, for all indicies
setLogAccentColors :: (Int -> Utf8Builder) -> LogOptions -> LogOptions

-- | Log a debug level message with no source.
logDebug :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Utf8Builder -> m ()

-- | Log an info level message with no source.
logInfo :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Utf8Builder -> m ()

-- | Log a warn level message with no source.
logWarn :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Utf8Builder -> m ()

-- | Log an error level message with no source.
logError :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Utf8Builder -> m ()

-- | Log a message with the specified textual level and no source.
logOther :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Text -> Utf8Builder -> m ()

-- | Write a "sticky" line to the terminal. Any subsequent lines will
--   overwrite this one, and that same line will be repeated below again.
--   In other words, the line sticks at the bottom of the output forever.
--   Running this function again will replace the sticky line with a new
--   sticky line. When you want to get rid of the sticky line, run
--   <a>logStickyDone</a>.
--   
--   Note that not all <a>LogFunc</a> implementations will support sticky
--   messages as described. However, the <a>withLogFunc</a> implementation
--   provided by this module does.
logSticky :: (MonadIO m, HasCallStack, MonadReader env m, HasLogFunc env) => Utf8Builder -> m ()

-- | This will print out the given message with a newline and disable any
--   further stickiness of the line until a new call to <a>logSticky</a>
--   happens.
logStickyDone :: (MonadIO m, HasCallStack, MonadReader env m, HasLogFunc env) => Utf8Builder -> m ()

-- | Log a debug level message with the given source.
logDebugS :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> Utf8Builder -> m ()

-- | Log an info level message with the given source.
logInfoS :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> Utf8Builder -> m ()

-- | Log a warn level message with the given source.
logWarnS :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> Utf8Builder -> m ()

-- | Log an error level message with the given source.
logErrorS :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> Utf8Builder -> m ()

-- | Log a message with the specified textual level and the given source.
logOtherS :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Text -> LogSource -> Utf8Builder -> m ()

-- | Generic, basic function for creating other logging functions.
logGeneric :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> LogLevel -> Utf8Builder -> m ()

-- | Create a <a>LogFunc</a> from the given function.
mkLogFunc :: (CallStack -> LogSource -> LogLevel -> Utf8Builder -> IO ()) -> LogFunc

-- | Create a <a>LogOptions</a> value which will store its data in memory.
--   This is primarily intended for testing purposes. This will return both
--   a <a>LogOptions</a> value and an <a>IORef</a> containing the resulting
--   <a>Builder</a> value.
--   
--   This will default to non-verbose settings and assume there is a
--   terminal attached. These assumptions can be overridden using the
--   appropriate <tt>set</tt> functions.
logOptionsMemory :: MonadIO m => m (IORef Builder, LogOptions)

-- | The log level of a message.
data LogLevel
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
LevelOther :: !Text -> LogLevel

-- | Where in the application a log message came from. Used for display
--   purposes only.
type LogSource = Text

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   :}
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:... in interactive:Ghci...
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data () => CallStack

-- | Convert a <a>CallStack</a> value into a <a>Utf8Builder</a> indicating
--   the first source location.
--   
--   TODO Consider showing the entire call stack instead.
displayCallStack :: CallStack -> Utf8Builder

-- | Disable logging capabilities in a given sub-routine
--   
--   Intended to skip logging in general purpose implementations, where
--   secrets might be logged accidently.
noLogging :: (HasLogFunc env, MonadReader env m) => m a -> m a

-- | Is the log func configured to use color output?
--   
--   Intended for use by code which wants to optionally add additional
--   color to its log messages.
logFuncUseColorL :: HasLogFunc env => SimpleGetter env Bool

-- | What color is the log func configured to use for each <a>LogLevel</a>?
--   
--   Intended for use by code which wants to optionally add additional
--   color to its log messages.
logFuncLogLevelColorsL :: HasLogFunc env => SimpleGetter env (LogLevel -> Utf8Builder)

-- | What color is the log func configured to use for secondary content?
--   
--   Intended for use by code which wants to optionally add additional
--   color to its log messages.
logFuncSecondaryColorL :: HasLogFunc env => SimpleGetter env Utf8Builder

-- | What accent colors, indexed by <a>Int</a>, is the log func configured
--   to use?
--   
--   Intended for use by code which wants to optionally add additional
--   color to its log messages.
logFuncAccentColorsL :: HasLogFunc env => SimpleGetter env (Int -> Utf8Builder)

-- | Log a value generically.
glog :: (MonadIO m, HasCallStack, HasGLogFunc env, MonadReader env m) => GMsg env -> m ()

-- | A generic logger of some type <tt>msg</tt>.
--   
--   Your <tt>GLocFunc</tt> can re-use the existing classical logging
--   framework of RIO, and/or implement additional transforms, filters.
--   Alternatively, you may log to a JSON source in a database, or anywhere
--   else as needed. You can decide how to log levels or severities based
--   on the constructors in your type. You will normally determine this in
--   your main app entry point.
data GLogFunc msg

-- | Make a <a>GLogFunc</a> via classic <a>LogFunc</a>. Use this if you'd
--   like to log your generic data type via the classic RIO terminal
--   logger.
gLogFuncClassic :: (HasLogLevel msg, HasLogSource msg, Display msg) => LogFunc -> GLogFunc msg

-- | Make a custom generic logger. With this you could, for example, write
--   to a database or a log digestion service. For example:
--   
--   <pre>
--   mkGLogFunc (\stack msg -&gt; send (Data.Aeson.encode (JsonLog stack msg)))
--   </pre>
mkGLogFunc :: (CallStack -> msg -> IO ()) -> GLogFunc msg

-- | A vesion of <a>contramapMaybeGLogFunc</a> which supports filering.
contramapMaybeGLogFunc :: (a -> Maybe b) -> GLogFunc b -> GLogFunc a

-- | A contramap. Use this to wrap sub-loggers via <a>mapRIO</a>.
--   
--   If you are on base &gt; 4.12.0, you can just use <a>contramap</a>.
contramapGLogFunc :: (a -> b) -> GLogFunc b -> GLogFunc a

-- | An app is capable of generic logging if it implements this.
class HasGLogFunc env where {
    type GMsg env;
}
gLogFuncL :: HasGLogFunc env => Lens' env (GLogFunc (GMsg env))

-- | Level, if any, of your logs. If unknown, use <tt>LogOther</tt>. Use
--   for your generic log data types that want to sit inside the classic
--   log framework.
class HasLogLevel msg
getLogLevel :: HasLogLevel msg => msg -> LogLevel

-- | Source of a log. This can be whatever you want. Use for your generic
--   log data types that want to sit inside the classic log framework.
class HasLogSource msg
getLogSource :: HasLogSource msg => msg -> LogSource

-- | A builder of binary data, with the invariant that the underlying data
--   is supposed to be UTF-8 encoded.
newtype Utf8Builder
Utf8Builder :: Builder -> Utf8Builder
[getUtf8Builder] :: Utf8Builder -> Builder

-- | A typeclass for values which can be converted to a <a>Utf8Builder</a>.
--   The intention of this typeclass is to provide a human-friendly display
--   of the data.
class Display a
display :: Display a => a -> Utf8Builder

-- | Display data as <a>Text</a>, which will also be used for
--   <a>display</a> if it is not overriden.
textDisplay :: Display a => a -> Text

-- | Use the <a>Show</a> instance for a value to convert it to a
--   <a>Utf8Builder</a>.
displayShow :: Show a => a -> Utf8Builder

-- | Convert a <a>Utf8Builder</a> value into a strict <a>Text</a>.
utf8BuilderToText :: Utf8Builder -> Text

-- | Convert a <a>Utf8Builder</a> value into a lazy <a>Text</a>.
utf8BuilderToLazyText :: Utf8Builder -> Text

-- | Convert a <a>ByteString</a> into a <a>Utf8Builder</a>.
--   
--   <i>NOTE</i> This function performs no checks to ensure that the data
--   is, in fact, UTF8 encoded. If you provide non-UTF8 data, later
--   functions may fail.
displayBytesUtf8 :: ByteString -> Utf8Builder

-- | Write the given <a>Utf8Builder</a> value to a file.
writeFileUtf8Builder :: MonadIO m => FilePath -> Utf8Builder -> m ()
view :: MonadReader s m => Getting a s a -> m a
preview :: MonadReader s m => Getting (First a) s a -> m (Maybe a)
type ASetter s t a b = a -> Identity b -> s -> Identity t
type ASetter' s a = ASetter s s a a
type Getting r s a = a -> Const r a -> s -> Const r s
type Lens s t a b = forall (f :: Type -> Type). Functor f => a -> f b -> s -> f t
type Lens' s a = Lens s s a a
type SimpleGetter s a = forall r. () => Getting r s a
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
over :: ASetter s t a b -> (a -> b) -> s -> t
set :: ASetter s t a b -> b -> s -> t
sets :: ((a -> b) -> s -> t) -> ASetter s t a b
to :: (s -> a) -> SimpleGetter s a
(^.) :: s -> Getting a s a -> a
(^?) :: s -> Getting (First a) s a -> Maybe a
(^..) :: s -> Getting (Endo [a]) s a -> [a]
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
(.~) :: ASetter s t a b -> b -> s -> t

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data () => ThreadId
myThreadId :: MonadIO m => m ThreadId
isCurrentThreadBound :: MonadIO m => m Bool
threadWaitRead :: MonadIO m => Fd -> m ()
threadWaitWrite :: MonadIO m => Fd -> m ()
threadDelay :: MonadIO m => Int -> m ()
yieldThread :: MonadIO m => m ()

-- | Throw an exception. Note that this throws when this action is run in
--   the monad <tt>m</tt>, not when it is applied. It is a generalization
--   of <a>Control.Exception</a>'s <a>throwIO</a>.
--   
--   Should satisfy the law:
--   
--   <pre>
--   throwM e &gt;&gt; f = throwM e
--   </pre>
throwM :: (MonadThrow m, HasCallStack, Exception e) => e -> m a

-- | Lazily get the contents of a file. Unlike <a>readFile</a>, this
--   ensures that if an exception is thrown, the file handle is closed
--   immediately.
withLazyFile :: MonadUnliftIO m => FilePath -> (ByteString -> m a) -> m a

-- | Lazily read a file in UTF8 encoding.
withLazyFileUtf8 :: MonadUnliftIO m => FilePath -> (Text -> m a) -> m a

-- | Same as <a>readFile</a>, but generalized to <a>MonadIO</a>
readFileBinary :: MonadIO m => FilePath -> m ByteString

-- | Same as <a>writeFile</a>, but generalized to <a>MonadIO</a>
writeFileBinary :: MonadIO m => FilePath -> ByteString -> m ()

-- | Read a file in UTF8 encoding, throwing an exception on invalid
--   character encoding.
--   
--   This function will use OS-specific line ending handling.
readFileUtf8 :: MonadIO m => FilePath -> m Text

-- | Write a file in UTF8 encoding
--   
--   This function will use OS-specific line ending handling.
writeFileUtf8 :: MonadIO m => FilePath -> Text -> m ()
hPutBuilder :: MonadIO m => Handle -> Builder -> m ()

-- | Lifted version of "System.Exit.exitFailure".
--   
--   @since 0.1.9.0.
exitFailure :: MonadIO m => m a

-- | Lifted version of "System.Exit.exitSuccess".
--   
--   @since 0.1.9.0.
exitSuccess :: MonadIO m => m a

-- | Lifted version of "System.Exit.exitWith".
--   
--   @since 0.1.9.0.
exitWith :: MonadIO m => ExitCode -> m a

-- | Defines the exit codes that a program can return.
data () => ExitCode

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | Abstraction over how to read from and write to a mutable reference
data SomeRef a

-- | Environment values with stateful capabilities to SomeRef
class HasStateRef s env | env -> s
stateRefL :: HasStateRef s env => Lens' env (SomeRef s)

-- | Environment values with writing capabilities to SomeRef
class HasWriteRef w env | env -> w
writeRefL :: HasWriteRef w env => Lens' env (SomeRef w)

-- | Lift one RIO env to another.
mapRIO :: (outer -> inner) -> RIO inner a -> RIO outer a

-- | create a new boxed SomeRef
newSomeRef :: MonadIO m => a -> m (SomeRef a)

-- | create a new unboxed SomeRef
newUnboxedSomeRef :: (MonadIO m, Unbox a) => a -> m (SomeRef a)

-- | Read from a SomeRef
readSomeRef :: MonadIO m => SomeRef a -> m a

-- | Write to a SomeRef
writeSomeRef :: MonadIO m => SomeRef a -> a -> m ()

-- | Modify a SomeRef This function is subject to change due to the lack of
--   atomic operations
modifySomeRef :: MonadIO m => SomeRef a -> (a -> a) -> m ()

-- | An unboxed reference. This works like an <a>IORef</a>, but the data is
--   stored in a bytearray instead of a heap object, avoiding significant
--   allocation overhead in some cases. For a concrete example, see this
--   Stack Overflow question:
--   <a>https://stackoverflow.com/questions/27261813/why-is-my-little-stref-int-require-allocating-gigabytes</a>.
--   
--   The first parameter is the state token type, the same as would be used
--   for the <a>ST</a> monad. If you're using an <a>IO</a>-based monad, you
--   can use the convenience <a>IOURef</a> type synonym instead.
data URef s a

-- | Helpful type synonym for using a <a>URef</a> from an <a>IO</a>-based
--   stack.
type IOURef = URef (PrimState IO)

-- | Create a new <a>URef</a>
newURef :: (PrimMonad m, Unbox a) => a -> m (URef (PrimState m) a)

-- | Read the value in a <a>URef</a>
readURef :: (PrimMonad m, Unbox a) => URef (PrimState m) a -> m a

-- | Write a value into a <a>URef</a>. Note that this action is strict, and
--   will force evalution of the value.
writeURef :: (PrimMonad m, Unbox a) => URef (PrimState m) a -> a -> m ()

-- | Modify a value in a <a>URef</a>. Note that this action is strict, and
--   will force evaluation of the result value.
modifyURef :: (PrimMonad m, Unbox a) => URef (PrimState m) a -> (a -> a) -> m ()


-- | <i>Warning: Trace statement left in code</i>
trace :: Text -> a -> a


-- | <i>Warning: Trace statement left in code</i>
traceId :: Text -> Text


-- | <i>Warning: Trace statement left in code</i>
traceIO :: MonadIO m => Text -> m ()


-- | <i>Warning: Trace statement left in code</i>
traceM :: Applicative f => Text -> f ()


-- | <i>Warning: Trace statement left in code</i>
traceEvent :: Text -> a -> a


-- | <i>Warning: Trace statement left in code</i>
traceEventIO :: MonadIO m => Text -> m ()


-- | <i>Warning: Trace statement left in code</i>
traceMarker :: Text -> a -> a


-- | <i>Warning: Trace statement left in code</i>
traceMarkerIO :: MonadIO m => Text -> m ()


-- | <i>Warning: Trace statement left in code</i>
traceStack :: Text -> a -> a


-- | <i>Warning: Trace statement left in code</i>
traceShow :: Show a => a -> b -> b


-- | <i>Warning: Trace statement left in code</i>
traceShowId :: Show a => a -> a


-- | <i>Warning: Trace statement left in code</i>
traceShowIO :: (Show a, MonadIO m) => a -> m ()


-- | <i>Warning: Trace statement left in code</i>
traceShowM :: (Show a, Applicative f) => a -> f ()


-- | <i>Warning: Trace statement left in code</i>
traceShowEvent :: Show a => a -> b -> b


-- | <i>Warning: Trace statement left in code</i>
traceShowEventIO :: (Show a, MonadIO m) => a -> m ()


-- | <i>Warning: Trace statement left in code</i>
traceShowMarker :: Show a => a -> b -> b


-- | <i>Warning: Trace statement left in code</i>
traceShowMarkerIO :: (Show a, MonadIO m) => a -> m ()


-- | <i>Warning: Trace statement left in code</i>
traceShowStack :: Show a => a -> b -> b


-- | <i>Warning: Trace statement left in code</i>
traceDisplay :: Display a => a -> b -> b


-- | <i>Warning: Trace statement left in code</i>
traceDisplayId :: Display a => a -> a


-- | <i>Warning: Trace statement left in code</i>
traceDisplayIO :: (Display a, MonadIO m) => a -> m ()


-- | <i>Warning: Trace statement left in code</i>
traceDisplayM :: (Display a, Applicative f) => a -> f ()


-- | <i>Warning: Trace statement left in code</i>
traceDisplayEvent :: Display a => a -> b -> b


-- | <i>Warning: Trace statement left in code</i>
traceDisplayEventIO :: (Display a, MonadIO m) => a -> m ()


-- | <i>Warning: Trace statement left in code</i>
traceDisplayMarker :: Display a => a -> b -> b


-- | <i>Warning: Trace statement left in code</i>
traceDisplayMarkerIO :: (Display a, MonadIO m) => a -> m ()


-- | <i>Warning: Trace statement left in code</i>
traceDisplayStack :: Display a => a -> b -> b


-- | Lazy <tt>ByteString</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.ByteString.Lazy as BL
--   </pre>
--   
--   This module does not export any partial functions. For those, see
--   <a>RIO.ByteString.Lazy.Partial</a>
module RIO.ByteString.Lazy

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A lazy <a>ByteString</a> contains 8-bit bytes, or by using the
--   operations from <a>Data.ByteString.Lazy.Char8</a> it can be
--   interpreted as containing 8-bit characters.
data () => ByteString

-- | <i>O(1)</i> The empty <a>ByteString</a>
empty :: ByteString

-- | <i>O(1)</i> Convert a <a>Word8</a> into a <a>ByteString</a>
singleton :: Word8 -> ByteString

-- | <i>O(n)</i> Convert a '[Word8]' into a <a>ByteString</a>.
pack :: [Word8] -> ByteString

-- | <i>O(n)</i> Converts a <a>ByteString</a> to a '[Word8]'.
unpack :: ByteString -> [Word8]

-- | <i>O(1)</i> Convert a strict <a>ByteString</a> into a lazy
--   <a>ByteString</a>.
fromStrict :: ByteString -> ByteString

-- | <i>O(n)</i> Convert a lazy <a>ByteString</a> into a strict
--   <a>ByteString</a>.
--   
--   Note that this is an <i>expensive</i> operation that forces the whole
--   lazy ByteString into memory and then copies all the data. If possible,
--   try to avoid converting back and forth between strict and lazy
--   bytestrings.
toStrict :: ByteString -> ByteString

-- | <i>O(c)</i> Convert a list of strict <a>ByteString</a> into a lazy
--   <a>ByteString</a>
fromChunks :: [ByteString] -> ByteString

-- | <i>O(c)</i> Convert a lazy <a>ByteString</a> into a list of strict
--   <a>ByteString</a>
toChunks :: ByteString -> [ByteString]

-- | Consume the chunks of a lazy ByteString with a natural right fold.
foldrChunks :: (ByteString -> a -> a) -> a -> ByteString -> a

-- | Consume the chunks of a lazy ByteString with a strict, tail-recursive,
--   accumulating left fold.
foldlChunks :: (a -> ByteString -> a) -> a -> ByteString -> a

-- | <i>O(1)</i> <a>cons</a> is analogous to <a>(:)</a> for lists.
cons :: Word8 -> ByteString -> ByteString
infixr 5 `cons`

-- | <i>O(1)</i> Unlike <a>cons</a>, <a>cons'</a> is strict in the
--   ByteString that we are consing onto. More precisely, it forces the
--   head and the first chunk. It does this because, for space efficiency,
--   it may coalesce the new byte onto the first 'chunk' rather than
--   starting a new 'chunk'.
--   
--   So that means you can't use a lazy recursive contruction like this:
--   
--   <pre>
--   let xs = cons' c xs in xs
--   </pre>
--   
--   You can however use <a>cons</a>, as well as <a>repeat</a> and
--   <a>cycle</a>, to build infinite lazy ByteStrings.
cons' :: Word8 -> ByteString -> ByteString
infixr 5 `cons'`

-- | <i>O(n/c)</i> Append a byte to the end of a <a>ByteString</a>
snoc :: ByteString -> Word8 -> ByteString
infixl 5 `snoc`

-- | <i>O(n/c)</i> Append two ByteStrings
append :: ByteString -> ByteString -> ByteString

-- | <i>O(1)</i> Extract the <a>head</a> and <a>tail</a> of a ByteString,
--   returning <a>Nothing</a> if it is empty.
uncons :: ByteString -> Maybe (Word8, ByteString)

-- | <i>O(n/c)</i> Extract the <a>init</a> and <a>last</a> of a ByteString,
--   returning <a>Nothing</a> if it is empty.
--   
--   <ul>
--   <li>It is no faster than using <a>init</a> and <a>last</a></li>
--   </ul>
unsnoc :: ByteString -> Maybe (ByteString, Word8)

-- | <i>O(1)</i> Test whether a ByteString is empty.
null :: ByteString -> Bool

-- | <i>O(c)</i> <a>length</a> returns the length of a ByteString as an
--   <a>Int64</a>
length :: ByteString -> Int64

-- | <i>O(n)</i> <a>map</a> <tt>f xs</tt> is the ByteString obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>.
map :: (Word8 -> Word8) -> ByteString -> ByteString

-- | <i>O(n)</i> <a>reverse</a> <tt>xs</tt> returns the elements of
--   <tt>xs</tt> in reverse order.
reverse :: ByteString -> ByteString

-- | The <a>intersperse</a> function takes a <a>Word8</a> and a
--   <a>ByteString</a> and `intersperses' that byte between the elements of
--   the <a>ByteString</a>. It is analogous to the intersperse function on
--   Lists.
intersperse :: Word8 -> ByteString -> ByteString

-- | <i>O(n)</i> The <a>intercalate</a> function takes a <a>ByteString</a>
--   and a list of <a>ByteString</a>s and concatenates the list after
--   interspersing the first argument between each element of the list.
intercalate :: ByteString -> [ByteString] -> ByteString

-- | The <a>transpose</a> function transposes the rows and columns of its
--   <a>ByteString</a> argument.
transpose :: [ByteString] -> [ByteString]

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a ByteString,
--   reduces the ByteString using the binary operator, from left to right.
foldl :: (a -> Word8 -> a) -> a -> ByteString -> a

-- | <a>foldl'</a> is like <a>foldl</a>, but strict in the accumulator.
foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a ByteString,
--   reduces the ByteString using the binary operator, from right to left.
foldr :: (Word8 -> a -> a) -> a -> ByteString -> a

-- | <i>O(n)</i> Concatenate a list of ByteStrings.
concat :: [ByteString] -> ByteString

-- | Map a function over a <a>ByteString</a> and concatenate the results
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString

-- | <i>O(n)</i> Applied to a predicate and a ByteString, <a>any</a>
--   determines if any element of the <a>ByteString</a> satisfies the
--   predicate.
any :: (Word8 -> Bool) -> ByteString -> Bool

-- | <i>O(n)</i> Applied to a predicate and a <a>ByteString</a>, <a>all</a>
--   determines if all elements of the <a>ByteString</a> satisfy the
--   predicate.
all :: (Word8 -> Bool) -> ByteString -> Bool

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left.
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   head (scanl f z xs) == z
--   last (scanl f z xs) == foldl f z xs
--   </pre>
scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a
--   ByteString, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   ByteString.
mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a
--   ByteString, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   ByteString.
mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)

-- | <tt><a>repeat</a> x</tt> is an infinite ByteString, with <tt>x</tt>
--   the value of every element.
repeat :: Word8 -> ByteString

-- | <i>O(n)</i> <tt><a>replicate</a> n x</tt> is a ByteString of length
--   <tt>n</tt> with <tt>x</tt> the value of every element.
replicate :: Int64 -> Word8 -> ByteString

-- | <a>cycle</a> ties a finite ByteString into a circular one, or
--   equivalently, the infinite repetition of the original ByteString.
cycle :: HasCallStack => ByteString -> ByteString

-- | <tt><a>iterate</a> f x</tt> returns an infinite ByteString of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
iterate :: (Word8 -> Word8) -> Word8 -> ByteString

-- | <i>O(n)</i> The <a>unfoldr</a> function is analogous to the List
--   'unfoldr'. <a>unfoldr</a> builds a ByteString from a seed value. The
--   function takes the element and returns <a>Nothing</a> if it is done
--   producing the ByteString or returns <a>Just</a> <tt>(a,b)</tt>, in
--   which case, <tt>a</tt> is a prepending to the ByteString and
--   <tt>b</tt> is used as the next element in a recursive call.
unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString

-- | <i>O(n/c)</i> <a>take</a> <tt>n</tt>, applied to a ByteString
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>.
take :: Int64 -> ByteString -> ByteString

-- | <i>O(n/c)</i> <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> elements, or <a>empty</a> if
--   <tt>n &gt; <a>length</a> xs</tt>.
drop :: Int64 -> ByteString -> ByteString

-- | <i>O(n/c)</i> <a>splitAt</a> <tt>n xs</tt> is equivalent to
--   <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>.
splitAt :: Int64 -> ByteString -> (ByteString, ByteString)

-- | Similar to <a>takeWhile</a>, returns the longest (possibly empty)
--   prefix of elements satisfying the predicate.
takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString

-- | Similar to <a>dropWhile</a>, drops the longest (possibly empty) prefix
--   of elements satisfying the predicate and returns the remainder.
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString

-- | Similar to <a>span</a>, returns the longest (possibly empty) prefix of
--   elements satisfying the predicate and the remainder of the string.
--   
--   <a>span</a> <tt>p</tt> is equivalent to <tt><a>break</a> (not .
--   p)</tt> and to <tt>(<a>takeWhile</a> p &amp;&amp;&amp;
--   <a>dropWhile</a> p)</tt>.
span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

-- | Similar to <a>break</a>, returns the longest (possibly empty) prefix
--   of elements which <b>do not</b> satisfy the predicate and the
--   remainder of the string.
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (not .
--   p)</tt> and to <tt>(<a>takeWhile</a> (not . p) &amp;&amp;&amp;
--   <a>dropWhile</a> (not . p))</tt>.
break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

-- | The <a>group</a> function takes a ByteString and returns a list of
--   ByteStrings such that the concatenation of the result is equal to the
--   argument. Moreover, each string in the result contains only equal
--   elements. For example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: ByteString -> [ByteString]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]

-- | Returns all initial segments of the given <a>ByteString</a>, shortest
--   first.
inits :: ByteString -> [ByteString]

-- | <i>O(n)</i> Returns all final segments of the given <a>ByteString</a>,
--   longest first.
tails :: ByteString -> [ByteString]

-- | <i>O(n)</i> The <a>stripPrefix</a> function takes two ByteStrings and
--   returns <a>Just</a> the remainder of the second iff the first is its
--   prefix, and otherwise <a>Nothing</a>.
stripPrefix :: ByteString -> ByteString -> Maybe ByteString

-- | <i>O(n)</i> The <a>stripSuffix</a> function takes two ByteStrings and
--   returns <a>Just</a> the remainder of the second iff the first is its
--   suffix, and otherwise <a>Nothing</a>.
stripSuffix :: ByteString -> ByteString -> Maybe ByteString

-- | <i>O(n)</i> Break a <a>ByteString</a> into pieces separated by the
--   byte argument, consuming the delimiter. I.e.
--   
--   <pre>
--   split 10  "a\nb\nd\ne" == ["a","b","d","e"]   -- fromEnum '\n' == 10
--   split 97  "aXaXaXa"    == ["","X","X","X",""] -- fromEnum 'a' == 97
--   split 120 "x"          == ["",""]             -- fromEnum 'x' == 120
--   split undefined ""     == []                  -- and not [""]
--   </pre>
--   
--   and
--   
--   <pre>
--   intercalate [c] . split c == id
--   split == splitWith . (==)
--   </pre>
--   
--   As for all splitting functions in this library, this function does not
--   copy the substrings, it just constructs new <a>ByteString</a>s that
--   are slices of the original.
split :: Word8 -> ByteString -> [ByteString]

-- | <i>O(n)</i> Splits a <a>ByteString</a> into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. eg.
--   
--   <pre>
--   splitWith (==97) "aabbaca" == ["","","bb","c",""] -- fromEnum 'a' == 97
--   splitWith undefined ""     == []                  -- and not [""]
--   </pre>
splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]

-- | <i>O(n)</i> The <a>isPrefixOf</a> function takes two ByteStrings and
--   returns <a>True</a> iff the first is a prefix of the second.
isPrefixOf :: ByteString -> ByteString -> Bool

-- | <i>O(n)</i> The <a>isSuffixOf</a> function takes two ByteStrings and
--   returns <a>True</a> iff the first is a suffix of the second.
--   
--   The following holds:
--   
--   <pre>
--   isSuffixOf x y == reverse x `isPrefixOf` reverse y
--   </pre>
isSuffixOf :: ByteString -> ByteString -> Bool

-- | <i>O(n)</i> <a>elem</a> is the <a>ByteString</a> membership predicate.
elem :: Word8 -> ByteString -> Bool

-- | <i>O(n)</i> <a>notElem</a> is the inverse of <a>elem</a>
notElem :: Word8 -> ByteString -> Bool

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   ByteString, and returns the first element in matching the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   find f p = case findIndex f p of Just n -&gt; Just (p ! n) ; _ -&gt; Nothing
--   </pre>
find :: (Word8 -> Bool) -> ByteString -> Maybe Word8

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a ByteString,
--   returns a ByteString containing those characters that satisfy the
--   predicate.
filter :: (Word8 -> Bool) -> ByteString -> ByteString

-- | <i>O(n)</i> The <a>partition</a> function takes a predicate a
--   ByteString and returns the pair of ByteStrings with elements which do
--   and do not satisfy the predicate, respectively; i.e.,
--   
--   <pre>
--   partition p bs == (filter p xs, filter (not . p) xs)
--   </pre>
partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

-- | <i>O(c)</i> <a>ByteString</a> index (subscript) operator, starting
--   from 0.
--   
--   This is a partial function, consider using <a>indexMaybe</a> instead.
index :: HasCallStack => ByteString -> Int64 -> Word8

-- | <i>O(n)</i> The <a>elemIndex</a> function returns the index of the
--   first element in the given <a>ByteString</a> which is equal to the
--   query element, or <a>Nothing</a> if there is no such element. This
--   implementation uses memchr(3).
elemIndex :: Word8 -> ByteString -> Maybe Int64

-- | <i>O(n)</i> The <a>elemIndexEnd</a> function returns the last index of
--   the element in the given <a>ByteString</a> which is equal to the query
--   element, or <a>Nothing</a> if there is no such element. The following
--   holds:
--   
--   <pre>
--   elemIndexEnd c xs = case elemIndex c (reverse xs) of
--     Nothing -&gt; Nothing
--     Just i  -&gt; Just (length xs - 1 - i)
--   </pre>
elemIndexEnd :: Word8 -> ByteString -> Maybe Int64

-- | <i>O(n)</i> The <a>elemIndices</a> function extends <a>elemIndex</a>,
--   by returning the indices of all elements equal to the query element,
--   in ascending order. This implementation uses memchr(3).
elemIndices :: Word8 -> ByteString -> [Int64]

-- | The <a>findIndex</a> function takes a predicate and a
--   <a>ByteString</a> and returns the index of the first element in the
--   ByteString satisfying the predicate.
findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int64

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
findIndices :: (Word8 -> Bool) -> ByteString -> [Int64]

-- | count returns the number of times its argument appears in the
--   ByteString
--   
--   <pre>
--   count = length . elemIndices
--   </pre>
--   
--   But more efficiently than using length on the intermediate list.
count :: Word8 -> ByteString -> Int64

-- | <i>O(n)</i> <a>zip</a> takes two ByteStrings and returns a list of
--   corresponding pairs of bytes. If one input ByteString is short, excess
--   elements of the longer ByteString are discarded. This is equivalent to
--   a pair of <a>unpack</a> operations.
zip :: ByteString -> ByteString -> [(Word8, Word8)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two ByteStrings to
--   produce the list of corresponding sums.
zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]

-- | <i>O(n)</i> <a>unzip</a> transforms a list of pairs of bytes into a
--   pair of ByteStrings. Note that this performs two <a>pack</a>
--   operations.
unzip :: [(Word8, Word8)] -> (ByteString, ByteString)

-- | <i>O(n)</i> Make a copy of the <a>ByteString</a> with its own storage.
--   This is mainly useful to allow the rest of the data pointed to by the
--   <a>ByteString</a> to be garbage collected, for example if a large
--   string has been read in, and only a small part of it is needed in the
--   rest of the program.
copy :: ByteString -> ByteString

-- | Lifted <a>getContents</a>
getContents :: MonadIO m => m LByteString

-- | Lifted <a>putStr</a>
putStr :: MonadIO m => LByteString -> m ()

-- | Lifted <a>putStrLn</a>
putStrLn :: MonadIO m => LByteString -> m ()

-- | Lifted <a>interact</a>
interact :: MonadIO m => (LByteString -> LByteString) -> m ()

-- | Lifted <a>readFile</a>
readFile :: MonadIO m => FilePath -> m LByteString

-- | Lifted <a>writeFile</a>
writeFile :: MonadIO m => FilePath -> LByteString -> m ()

-- | Lifted <a>appendFile</a>
appendFile :: MonadIO m => FilePath -> LByteString -> m ()

-- | Lifted <a>hGetContents</a>
hGetContents :: MonadIO m => Handle -> m LByteString

-- | Lifted <a>hGet</a>
hGet :: MonadIO m => Handle -> Int -> m LByteString

-- | Lifted <a>hGetNonBlocking</a>
hGetNonBlocking :: MonadIO m => Handle -> Int -> m LByteString

-- | Lifted <a>hPut</a>
hPut :: MonadIO m => Handle -> LByteString -> m ()

-- | Lifted <a>hPutNonBlocking</a>
hPutNonBlocking :: MonadIO m => Handle -> LByteString -> m LByteString

-- | Lifted <a>hPutStr</a>
hPutStr :: MonadIO m => Handle -> LByteString -> m ()


-- | Strict <tt>ByteString</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.ByteString as B
--   </pre>
--   
--   This module does not export any partial functions. For those, see
--   <a>RIO.ByteString.Partial</a>
module RIO.ByteString

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data () => ByteString

-- | Type synonym for the strict flavour of <a>ByteString</a>.
type StrictByteString = ByteString

-- | <i>O(1)</i> <a>ByteString</a> index, starting from 0, that returns
--   <a>Just</a> if:
--   
--   <pre>
--   0 &lt;= n &lt; length bs
--   </pre>
(!?) :: ByteString -> Int -> Maybe Word8

-- | <i>O(1)</i> <a>ByteString</a> index (subscript) operator, starting
--   from 0.
--   
--   This is a partial function, consider using <a>indexMaybe</a> instead.
index :: HasCallStack => ByteString -> Int -> Word8

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two ByteStrings to
--   produce the list of corresponding sums.
zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]

-- | <i>O(1)</i> <a>length</a> returns the length of a ByteString as an
--   <a>Int</a>.
length :: ByteString -> Int

-- | The <a>group</a> function takes a ByteString and returns a list of
--   ByteStrings such that the concatenation of the result is equal to the
--   argument. Moreover, each string in the result contains only equal
--   elements. For example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test. It is about 40% faster than <i>groupBy
--   (==)</i>
group :: ByteString -> [ByteString]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a ByteString,
--   returns a ByteString containing those characters that satisfy the
--   predicate.
filter :: (Word8 -> Bool) -> ByteString -> ByteString

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a ByteString,
--   reduces the ByteString using the binary operator, from left to right.
foldl :: (a -> Word8 -> a) -> a -> ByteString -> a

-- | <i>O(n)</i>, where <i>n</i> is the length of the result. The
--   <a>unfoldr</a> function is analogous to the List 'unfoldr'.
--   <a>unfoldr</a> builds a ByteString from a seed value. The function
--   takes the element and returns <a>Nothing</a> if it is done producing
--   the ByteString or returns <a>Just</a> <tt>(a,b)</tt>, in which case,
--   <tt>a</tt> is the next byte in the string, and <tt>b</tt> is the seed
--   value for further production.
--   
--   Examples:
--   
--   <pre>
--      unfoldr (\x -&gt; if x &lt;= 5 then Just (x, x + 1) else Nothing) 0
--   == pack [0, 1, 2, 3, 4, 5]
--   </pre>
unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString

-- | The <a>transpose</a> function transposes the rows and columns of its
--   <a>ByteString</a> argument.
transpose :: [ByteString] -> [ByteString]

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a ByteString,
--   reduces the ByteString using the binary operator, from right to left.
foldr :: (Word8 -> a -> a) -> a -> ByteString -> a

-- | <i>O(n)</i> Concatenate a list of ByteStrings.
concat :: [ByteString] -> ByteString

-- | <i>O(n)</i> <a>zip</a> takes two ByteStrings and returns a list of
--   corresponding pairs of bytes. If one input ByteString is short, excess
--   elements of the longer ByteString are discarded. This is equivalent to
--   a pair of <a>unpack</a> operations.
zip :: ByteString -> ByteString -> [(Word8, Word8)]

-- | <i>O(n)</i> <a>map</a> <tt>f xs</tt> is the ByteString obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>.
map :: (Word8 -> Word8) -> ByteString -> ByteString

-- | <i>O(1)</i> The empty <a>ByteString</a>
empty :: ByteString

-- | <i>O(1)</i> Extract the <a>head</a> and <a>tail</a> of a ByteString,
--   returning <a>Nothing</a> if it is empty.
uncons :: ByteString -> Maybe (Word8, ByteString)

-- | <i>O(1)</i> Test whether a ByteString is empty.
null :: ByteString -> Bool

-- | <a>foldl'</a> is like <a>foldl</a>, but strict in the accumulator.
foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left.
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   head (scanl f z xs) == z
--   last (scanl f z xs) == foldl f z xs
--   </pre>
scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument.
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString

-- | <a>foldr'</a> is like <a>foldr</a>, but strict in the accumulator.
foldr' :: (Word8 -> a -> a) -> a -> ByteString -> a

-- | <a>scanr</a> is similar to <a>foldr</a>, but returns a list of
--   successive reduced values from the right.
--   
--   <pre>
--   scanr f z [..., x{n-1}, xn] == [..., x{n-1} `f` (xn `f` z), xn `f` z, z]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs
--   last (scanr f z xs) == z
--   </pre>
scanr :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString

-- | <i>O(n)</i> <a>replicate</a> <tt>n x</tt> is a ByteString of length
--   <tt>n</tt> with <tt>x</tt> the value of every element. The following
--   holds:
--   
--   <pre>
--   replicate w c = fst (unfoldrN w (\u -&gt; Just (u,u)) c)
--   </pre>
replicate :: Int -> Word8 -> ByteString

-- | Similar to <a>takeWhile</a>, returns the longest (possibly empty)
--   prefix of elements satisfying the predicate.
takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString

-- | Similar to <a>dropWhile</a>, drops the longest (possibly empty) prefix
--   of elements satisfying the predicate and returns the remainder.
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString

-- | <i>O(1)</i> <a>take</a> <tt>n</tt>, applied to a ByteString
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>.
take :: Int -> ByteString -> ByteString

-- | <i>O(1)</i> <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> elements, or <a>empty</a> if
--   <tt>n &gt; <a>length</a> xs</tt>.
drop :: Int -> ByteString -> ByteString

-- | <i>O(1)</i> <a>splitAt</a> <tt>n xs</tt> is equivalent to
--   <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>.
splitAt :: Int -> ByteString -> (ByteString, ByteString)

-- | Similar to <a>span</a>, returns the longest (possibly empty) prefix of
--   elements satisfying the predicate and the remainder of the string.
--   
--   <a>span</a> <tt>p</tt> is equivalent to <tt><a>break</a> (not .
--   p)</tt> and to <tt>(<a>takeWhile</a> p &amp;&amp;&amp;
--   <a>dropWhile</a> p)</tt>.
span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

-- | Similar to <a>break</a>, returns the longest (possibly empty) prefix
--   of elements which <b>do not</b> satisfy the predicate and the
--   remainder of the string.
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (not .
--   p)</tt> and to <tt>(<a>takeWhile</a> (not . p) &amp;&amp;&amp;
--   <a>dropWhile</a> (not . p))</tt>.
--   
--   Under GHC, a rewrite rule will transform break (==) into a call to the
--   specialised breakByte:
--   
--   <pre>
--   break ((==) x) = breakByte x
--   break (==x) = breakByte x
--   </pre>
break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

-- | <i>O(n)</i> <a>reverse</a> <tt>xs</tt> efficiently returns the
--   elements of <tt>xs</tt> in reverse order.
reverse :: ByteString -> ByteString

-- | <i>O(n)</i> Applied to a predicate and a ByteString, <a>any</a>
--   determines if any element of the <a>ByteString</a> satisfies the
--   predicate.
any :: (Word8 -> Bool) -> ByteString -> Bool

-- | <i>O(n)</i> Applied to a predicate and a <a>ByteString</a>, <a>all</a>
--   determines if all elements of the <a>ByteString</a> satisfy the
--   predicate.
all :: (Word8 -> Bool) -> ByteString -> Bool

-- | <i>O(n)</i> <a>elem</a> is the <a>ByteString</a> membership predicate.
elem :: Word8 -> ByteString -> Bool

-- | <i>O(n)</i> <a>notElem</a> is the inverse of <a>elem</a>
notElem :: Word8 -> ByteString -> Bool

-- | Map a function over a <a>ByteString</a> and concatenate the results
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString

-- | <i>O(n)</i> <a>unzip</a> transforms a list of pairs of bytes into a
--   pair of ByteStrings. Note that this performs two <a>pack</a>
--   operations.
unzip :: [(Word8, Word8)] -> (ByteString, ByteString)

-- | count returns the number of times its argument appears in the
--   ByteString
--   
--   <pre>
--   count = length . elemIndices
--   </pre>
--   
--   But more efficiently than using length on the intermediate list.
count :: Word8 -> ByteString -> Int

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   ByteString, and returns the first element in matching the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   find f p = case findIndex f p of Just n -&gt; Just (p ! n) ; _ -&gt; Nothing
--   </pre>
find :: (Word8 -> Bool) -> ByteString -> Maybe Word8

-- | Similar to <a>dropWhileEnd</a>, drops the longest (possibly empty)
--   suffix of elements satisfying the predicate and returns the remainder.
--   
--   <tt><a>dropWhileEnd</a> p</tt> is equivalent to <tt><a>reverse</a> .
--   <a>dropWhile</a> p . <a>reverse</a></tt>.
dropWhileEnd :: (Word8 -> Bool) -> ByteString -> ByteString

-- | <i>O(n)</i> The <a>stripPrefix</a> function takes two ByteStrings and
--   returns <a>Just</a> the remainder of the second iff the first is its
--   prefix, and otherwise <a>Nothing</a>.
stripPrefix :: ByteString -> ByteString -> Maybe ByteString

-- | <i>O(n)</i> The <a>elemIndex</a> function returns the index of the
--   first element in the given <a>ByteString</a> which is equal to the
--   query element, or <a>Nothing</a> if there is no such element. This
--   implementation uses memchr(3).
elemIndex :: Word8 -> ByteString -> Maybe Int

-- | <i>O(n)</i> The <a>elemIndices</a> function extends <a>elemIndex</a>,
--   by returning the indices of all elements equal to the query element,
--   in ascending order. This implementation uses memchr(3).
elemIndices :: Word8 -> ByteString -> [Int]

-- | <i>O(n)</i> The <a>findIndex</a> function takes a predicate and a
--   <a>ByteString</a> and returns the index of the first element in the
--   ByteString satisfying the predicate.
findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int

-- | <i>O(n)</i> The <a>findIndices</a> function extends <a>findIndex</a>,
--   by returning the indices of all elements satisfying the predicate, in
--   ascending order.
findIndices :: (Word8 -> Bool) -> ByteString -> [Int]

-- | <i>O(n)</i> The <a>isPrefixOf</a> function takes two ByteStrings and
--   returns <a>True</a> if the first is a prefix of the second.
isPrefixOf :: ByteString -> ByteString -> Bool

-- | <i>O(n)</i> The <a>isSuffixOf</a> function takes two ByteStrings and
--   returns <a>True</a> iff the first is a suffix of the second.
--   
--   The following holds:
--   
--   <pre>
--   isSuffixOf x y == reverse x `isPrefixOf` reverse y
--   </pre>
--   
--   However, the real implementation uses memcmp to compare the end of the
--   string only, with no reverse required..
isSuffixOf :: ByteString -> ByteString -> Bool

-- | Check whether one string is a substring of another.
isInfixOf :: ByteString -> ByteString -> Bool

-- | <i>O(n)</i> The <a>intersperse</a> function takes a <a>Word8</a> and a
--   <a>ByteString</a> and `intersperses' that byte between the elements of
--   the <a>ByteString</a>. It is analogous to the intersperse function on
--   Lists.
intersperse :: Word8 -> ByteString -> ByteString

-- | <i>O(n)</i> The <a>intercalate</a> function takes a <a>ByteString</a>
--   and a list of <a>ByteString</a>s and concatenates the list after
--   interspersing the first argument between each element of the list.
intercalate :: ByteString -> [ByteString] -> ByteString

-- | <i>O(n)</i> The <a>partition</a> function takes a predicate a
--   ByteString and returns the pair of ByteStrings with elements which do
--   and do not satisfy the predicate, respectively; i.e.,
--   
--   <pre>
--   partition p bs == (filter p xs, filter (not . p) xs)
--   </pre>
partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a
--   ByteString, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   ByteString.
mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a
--   ByteString, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   ByteString.
mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)

-- | <i>O(n)</i> Returns all initial segments of the given
--   <a>ByteString</a>, shortest first.
inits :: ByteString -> [ByteString]

-- | <i>O(n)</i> Returns all final segments of the given <a>ByteString</a>,
--   longest first.
tails :: ByteString -> [ByteString]

-- | <i>O(n)</i> Sort a ByteString efficiently, using counting sort.
sort :: ByteString -> ByteString

-- | <i>O(1)</i> Convert a <a>Word8</a> into a <a>ByteString</a>
singleton :: Word8 -> ByteString

-- | <i>O(n)</i> <a>cons</a> is analogous to (:) for lists, but of
--   different complexity, as it requires making a copy.
cons :: Word8 -> ByteString -> ByteString
infixr 5 `cons`

-- | <i>O(n)</i> Append two ByteStrings
append :: ByteString -> ByteString -> ByteString

-- | <i>O(n)</i> Make a copy of the <a>ByteString</a> with its own storage.
--   This is mainly useful to allow the rest of the data pointed to by the
--   <a>ByteString</a> to be garbage collected, for example if a large
--   string has been read in, and only a small part of it is needed in the
--   rest of the program.
copy :: ByteString -> ByteString

-- | <i>O(n)</i> Append a byte to the end of a <a>ByteString</a>
snoc :: ByteString -> Word8 -> ByteString
infixl 5 `snoc`

-- | <i>O(1)</i> Convert a strict <a>ByteString</a> into a lazy
--   <a>ByteString</a>.
fromStrict :: ByteString -> ByteString

-- | <i>O(n)</i> Convert a lazy <a>ByteString</a> into a strict
--   <a>ByteString</a>.
--   
--   Note that this is an <i>expensive</i> operation that forces the whole
--   lazy ByteString into memory and then copies all the data. If possible,
--   try to avoid converting back and forth between strict and lazy
--   bytestrings.
toStrict :: ByteString -> ByteString

-- | <i>O(1)</i> <a>ByteString</a> index, starting from 0, that returns
--   <a>Just</a> if:
--   
--   <pre>
--   0 &lt;= n &lt; length bs
--   </pre>
indexMaybe :: ByteString -> Int -> Maybe Word8

-- | <i>O(n)</i> Convert a <tt>[<a>Word8</a>]</tt> into a
--   <a>ByteString</a>.
--   
--   For applications with large numbers of string literals, <a>pack</a>
--   can be a bottleneck. In such cases, consider using
--   <a>unsafePackAddress</a> (GHC only).
pack :: [Word8] -> ByteString

-- | <i>O(n)</i> Converts a <a>ByteString</a> to a <tt>[<a>Word8</a>]</tt>.
unpack :: ByteString -> [Word8]

-- | <i>O(1)</i> Extract the <a>init</a> and <a>last</a> of a ByteString,
--   returning <a>Nothing</a> if it is empty.
unsnoc :: ByteString -> Maybe (ByteString, Word8)

-- | <i>O(1)</i> <tt><a>takeEnd</a> n xs</tt> is equivalent to
--   <tt><a>drop</a> (<a>length</a> xs - n) xs</tt>. Takes <tt>n</tt>
--   elements from end of bytestring.
--   
--   <pre>
--   &gt;&gt;&gt; takeEnd 3 "abcdefg"
--   "efg"
--   
--   &gt;&gt;&gt; takeEnd 0 "abcdefg"
--   ""
--   
--   &gt;&gt;&gt; takeEnd 4 "abc"
--   "abc"
--   </pre>
takeEnd :: Int -> ByteString -> ByteString

-- | Returns the longest (possibly empty) suffix of elements satisfying the
--   predicate.
--   
--   <tt><a>takeWhileEnd</a> p</tt> is equivalent to <tt><a>reverse</a> .
--   <a>takeWhile</a> p . <a>reverse</a></tt>.
takeWhileEnd :: (Word8 -> Bool) -> ByteString -> ByteString

-- | <i>O(1)</i> <tt><a>dropEnd</a> n xs</tt> is equivalent to
--   <tt><a>take</a> (<a>length</a> xs - n) xs</tt>. Drops <tt>n</tt>
--   elements from end of bytestring.
--   
--   <pre>
--   &gt;&gt;&gt; dropEnd 3 "abcdefg"
--   "abcd"
--   
--   &gt;&gt;&gt; dropEnd 0 "abcdefg"
--   "abcdefg"
--   
--   &gt;&gt;&gt; dropEnd 4 "abc"
--   ""
--   </pre>
dropEnd :: Int -> ByteString -> ByteString

-- | Returns the longest (possibly empty) suffix of elements which <b>do
--   not</b> satisfy the predicate and the remainder of the string.
--   
--   <a>breakEnd</a> <tt>p</tt> is equivalent to <tt><a>spanEnd</a> (not .
--   p)</tt> and to <tt>(<a>takeWhileEnd</a> (not . p) &amp;&amp;&amp;
--   <a>dropWhileEnd</a> (not . p))</tt>.
breakEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

-- | Returns the longest (possibly empty) suffix of elements satisfying the
--   predicate and the remainder of the string.
--   
--   <a>spanEnd</a> <tt>p</tt> is equivalent to <tt><a>breakEnd</a> (not .
--   p)</tt> and to <tt>(<a>takeWhileEnd</a> p &amp;&amp;&amp;
--   <a>dropWhileEnd</a> p)</tt>.
--   
--   We have
--   
--   <pre>
--   spanEnd (not . isSpace) "x y z" == ("x y ", "z")
--   </pre>
--   
--   and
--   
--   <pre>
--   spanEnd (not . isSpace) ps
--      ==
--   let (x, y) = span (not . isSpace) (reverse ps) in (reverse y, reverse x)
--   </pre>
spanEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

-- | <i>O(n)</i> Break a <a>ByteString</a> into pieces separated by the
--   byte argument, consuming the delimiter. I.e.
--   
--   <pre>
--   split 10  "a\nb\nd\ne" == ["a","b","d","e"]   -- fromEnum '\n' == 10
--   split 97  "aXaXaXa"    == ["","X","X","X",""] -- fromEnum 'a' == 97
--   split 120 "x"          == ["",""]             -- fromEnum 'x' == 120
--   split undefined ""     == []                  -- and not [""]
--   </pre>
--   
--   and
--   
--   <pre>
--   intercalate [c] . split c == id
--   split == splitWith . (==)
--   </pre>
--   
--   As for all splitting functions in this library, this function does not
--   copy the substrings, it just constructs new <a>ByteString</a>s that
--   are slices of the original.
split :: Word8 -> ByteString -> [ByteString]

-- | <i>O(n)</i> Splits a <a>ByteString</a> into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. eg.
--   
--   <pre>
--   splitWith (==97) "aabbaca" == ["","","bb","c",""] -- fromEnum 'a' == 97
--   splitWith undefined ""     == []                  -- and not [""]
--   </pre>
splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]

-- | <i>O(n)</i> The <a>stripSuffix</a> function takes two ByteStrings and
--   returns <a>Just</a> the remainder of the second iff the first is its
--   suffix, and otherwise <a>Nothing</a>.
stripSuffix :: ByteString -> ByteString -> Maybe ByteString

-- | <i>O(n)</i> Like <a>unfoldr</a>, <a>unfoldrN</a> builds a ByteString
--   from a seed value. However, the length of the result is limited by the
--   first argument to <a>unfoldrN</a>. This function is more efficient
--   than <a>unfoldr</a> when the maximum length of the result is known.
--   
--   The following equation relates <a>unfoldrN</a> and <a>unfoldr</a>:
--   
--   <pre>
--   fst (unfoldrN n f s) == take n (unfoldr f s)
--   </pre>
unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)

-- | Break a string on a substring, returning a pair of the part of the
--   string prior to the match, and the rest of the string.
--   
--   The following relationships hold:
--   
--   <pre>
--   break (== c) l == breakSubstring (singleton c) l
--   </pre>
--   
--   For example, to tokenise a string, dropping delimiters:
--   
--   <pre>
--   tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
--       where (h,t) = breakSubstring x y
--   </pre>
--   
--   To skip to the first occurrence of a string:
--   
--   <pre>
--   snd (breakSubstring x y)
--   </pre>
--   
--   To take the parts of a string before a delimiter:
--   
--   <pre>
--   fst (breakSubstring x y)
--   </pre>
--   
--   Note that calling `breakSubstring x` does some preprocessing work, so
--   you should avoid unnecessarily duplicating breakSubstring calls with
--   the same pattern.
breakSubstring :: ByteString -> ByteString -> (ByteString, ByteString)

-- | <i>O(n)</i> Check whether a <a>ByteString</a> represents valid UTF-8.
isValidUtf8 :: ByteString -> Bool

-- | Convert a <a>FilePath</a> to a <a>ByteString</a>.
--   
--   The <a>FilePath</a> type is expected to use the file system encoding
--   as reported by <a>getFileSystemEncoding</a>. This encoding allows for
--   round-tripping of arbitrary data on platforms that allow arbitrary
--   bytes in their paths. This conversion function does the same thing
--   that <a>openFile</a> would do when decoding the <a>FilePath</a>.
--   
--   This function is in <a>IO</a> because the file system encoding can be
--   changed. If the encoding can be assumed to be constant in your use
--   case, you may invoke this function via <tt>unsafePerformIO</tt>.
fromFilePath :: FilePath -> IO ByteString

-- | Convert a <a>ByteString</a> to a <a>FilePath</a>.
--   
--   This function uses the file system encoding, and resulting
--   <a>FilePath</a>s can be safely used with standard IO functions and
--   will reference the correct path in the presence of arbitrary non-UTF-8
--   encoded paths.
--   
--   This function is in <a>IO</a> because the file system encoding can be
--   changed. If the encoding can be assumed to be constant in your use
--   case, you may invoke this function via <tt>unsafePerformIO</tt>.
toFilePath :: ByteString -> IO FilePath

-- | <i>O(n)</i> The <a>elemIndexEnd</a> function returns the last index of
--   the element in the given <a>ByteString</a> which is equal to the query
--   element, or <a>Nothing</a> if there is no such element. The following
--   holds:
--   
--   <pre>
--   elemIndexEnd c xs = case elemIndex c (reverse xs) of
--     Nothing -&gt; Nothing
--     Just i  -&gt; Just (length xs - 1 - i)
--   </pre>
elemIndexEnd :: Word8 -> ByteString -> Maybe Int

-- | <i>O(n)</i> The <a>findIndexEnd</a> function takes a predicate and a
--   <a>ByteString</a> and returns the index of the last element in the
--   ByteString satisfying the predicate.
findIndexEnd :: (Word8 -> Bool) -> ByteString -> Maybe Int

-- | A specialised version of <a>zipWith</a> for the common case of a
--   simultaneous map over two ByteStrings, to build a 3rd.
packZipWith :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString

-- | <i>O(n)</i> Returns all initial segments of the given
--   <a>ByteString</a>, shortest first.
initsNE :: ByteString -> NonEmpty ByteString

-- | <i>O(n)</i> Returns all final segments of the given <a>ByteString</a>,
--   longest first.
tailsNE :: ByteString -> NonEmpty ByteString

-- | Lifted <a>hGetContents</a>
hGetContents :: MonadIO m => Handle -> m ByteString

-- | Lifted <a>writeFile</a>
writeFile :: MonadIO m => FilePath -> ByteString -> m ()

-- | Lifted <a>getLine</a>
getLine :: MonadIO m => m ByteString

-- | Lifted <a>hGetLine</a>
hGetLine :: MonadIO m => Handle -> m ByteString

-- | Lifted <a>hPutStr</a>
hPutStr :: MonadIO m => Handle -> ByteString -> m ()

-- | Lifted <a>putStr</a>
putStr :: MonadIO m => ByteString -> m ()

-- | Lifted <a>getContents</a>
getContents :: MonadIO m => m ByteString

-- | Lifted <a>interact</a>
interact :: MonadIO m => (ByteString -> ByteString) -> m ()

-- | Lifted <a>readFile</a>
readFile :: MonadIO m => FilePath -> m ByteString

-- | Lifted <a>appendFile</a>
appendFile :: MonadIO m => FilePath -> ByteString -> m ()

-- | Unlifted <a>useAsCString</a>
useAsCString :: MonadUnliftIO m => ByteString -> (CString -> m a) -> m a

-- | Unlifted <a>useAsCStringLen</a>
useAsCStringLen :: MonadUnliftIO m => ByteString -> (CStringLen -> m a) -> m a

-- | Lifted <a>hPut</a>
hPut :: MonadIO m => Handle -> ByteString -> m ()

-- | Lifted <a>packCString</a>
packCString :: MonadIO m => CString -> m ByteString

-- | Lifted <a>packCStringLen</a>
packCStringLen :: MonadIO m => CStringLen -> m ByteString

-- | Lifted <a>hPutNonBlocking</a>
hPutNonBlocking :: MonadIO m => Handle -> ByteString -> m ByteString

-- | Lifted <a>hGet</a>
hGet :: MonadIO m => Handle -> Int -> m ByteString

-- | Lifted <a>hGetNonBlocking</a>
hGetNonBlocking :: MonadIO m => Handle -> Int -> m ByteString

-- | Lifted <a>hGetSome</a>
hGetSome :: MonadIO m => Handle -> Int -> m ByteString


-- | Lazy <tt>Text</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.Text.Lazy as TL
--   </pre>
--   
--   This module does not export any partial functions. For those, see
--   <a>RIO.Text.Lazy.Partial</a>
module RIO.Text.Lazy
data () => Text

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>Text</a>.
--   
--   Performs replacement on invalid scalar values, so <tt><a>unpack</a> .
--   <a>pack</a></tt> is not <tt>id</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Data.Text.Lazy.unpack (Data.Text.Lazy.pack "\55555")
--   "\65533"
--   </pre>
pack :: String -> Text

-- | <i>O(n)</i> Convert a <a>Text</a> into a <a>String</a>.
unpack :: Text -> String

-- | <i>O(1)</i> Convert a character into a Text. Performs replacement on
--   invalid scalar values.
singleton :: Char -> Text

-- | Smart constructor for <a>Empty</a>.
empty :: Text

-- | <i>O(c)</i> Convert a list of strict <a>Text</a>s into a lazy
--   <a>Text</a>.
fromChunks :: [Text] -> Text

-- | <i>O(n)</i> Convert a lazy <a>Text</a> into a list of strict
--   <a>Text</a>s.
toChunks :: Text -> [Text]

-- | <i>O(n)</i> Convert a lazy <a>Text</a> into a strict <a>Text</a>.
toStrict :: Text -> Text

-- | <i>O(c)</i> Convert a strict <a>Text</a> into a lazy <a>Text</a>.
fromStrict :: Text -> Text

-- | Consume the chunks of a lazy <a>Text</a> with a natural right fold.
foldrChunks :: (Text -> a -> a) -> a -> Text -> a

-- | Consume the chunks of a lazy <a>Text</a> with a strict,
--   tail-recursive, accumulating left fold.
foldlChunks :: (a -> Text -> a) -> a -> Text -> a

-- | <i>O(1)</i> Adds a character to the front of a <a>Text</a>.
cons :: Char -> Text -> Text
infixr 5 `cons`

-- | <i>O(n)</i> Adds a character to the end of a <a>Text</a>. This copies
--   the entire array in the process.
snoc :: Text -> Char -> Text

-- | <i>O(n/c)</i> Appends one <a>Text</a> to another.
append :: Text -> Text -> Text

-- | <i>O(1)</i> Returns the first character and rest of a <a>Text</a>, or
--   <a>Nothing</a> if empty.
uncons :: Text -> Maybe (Char, Text)

-- | <i>O(1)</i> Tests whether a <a>Text</a> is empty or not.
null :: Text -> Bool

-- | <i>O(n)</i> Returns the number of characters in a <a>Text</a>.
length :: Text -> Int64

-- | <i>O(min(n,c))</i> Compare the count of characters in a <a>Text</a> to
--   a number.
--   
--   <pre>
--   <a>compareLength</a> t c = <a>compare</a> (<a>length</a> t) c
--   </pre>
--   
--   This function gives the same answer as comparing against the result of
--   <a>length</a>, but can short circuit if the count of characters is
--   greater than the number, and hence be more efficient.
compareLength :: Text -> Int64 -> Ordering

-- | <i>O(n)</i> <a>map</a> <tt>f</tt> <tt>t</tt> is the <a>Text</a>
--   obtained by applying <tt>f</tt> to each element of <tt>t</tt>.
--   Performs replacement on invalid scalar values.
map :: (Char -> Char) -> Text -> Text

-- | <i>O(n)</i> The <a>intercalate</a> function takes a <a>Text</a> and a
--   list of <a>Text</a>s and concatenates the list after interspersing the
--   first argument between each element of the list.
intercalate :: Text -> [Text] -> Text

-- | <i>O(n)</i> The <a>intersperse</a> function takes a character and
--   places it between the characters of a <a>Text</a>. Performs
--   replacement on invalid scalar values.
intersperse :: Char -> Text -> Text

-- | <i>O(n)</i> The <a>transpose</a> function transposes the rows and
--   columns of its <a>Text</a> argument. Note that this function uses
--   <a>pack</a>, <a>unpack</a>, and the list version of transpose, and is
--   thus not very efficient.
transpose :: [Text] -> [Text]

-- | <i>O(n)</i> <a>reverse</a> <tt>t</tt> returns the elements of
--   <tt>t</tt> in reverse order.
reverse :: Text -> Text

-- | <i>O(n)</i> Convert a string to folded case.
--   
--   This function is mainly useful for performing caseless (or case
--   insensitive) string comparisons.
--   
--   A string <tt>x</tt> is a caseless match for a string <tt>y</tt> if and
--   only if:
--   
--   <pre>
--   toCaseFold x == toCaseFold y
--   </pre>
--   
--   The result string may be longer than the input string, and may differ
--   from applying <a>toLower</a> to the input string. For instance, the
--   Armenian small ligature men now (U+FB13) is case folded to the bigram
--   men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded
--   to the Greek small letter letter mu (U+03BC) instead of itself.
toCaseFold :: Text -> Text

-- | <i>O(n)</i> Convert a string to lower case, using simple case
--   conversion.
--   
--   The result string may be longer than the input string. For instance,
--   the Latin capital letter I with dot above (U+0130) maps to the
--   sequence Latin small letter i (U+0069) followed by combining dot above
--   (U+0307).
toLower :: Text -> Text

-- | <i>O(n)</i> Convert a string to upper case, using simple case
--   conversion.
--   
--   The result string may be longer than the input string. For instance,
--   the German eszett (U+00DF) maps to the two-letter sequence SS.
toUpper :: Text -> Text

-- | <i>O(n)</i> Convert a string to title case, using simple case
--   conversion.
--   
--   The first letter (as determined by <a>isLetter</a>) of the input is
--   converted to title case, as is every subsequent letter that
--   immediately follows a non-letter. Every letter that immediately
--   follows another letter is converted to lower case.
--   
--   The result string may be longer than the input string. For example,
--   the Latin small ligature ﬂ (U+FB02) is converted to the sequence Latin
--   capital letter F (U+0046) followed by Latin small letter l (U+006C).
--   
--   This function is not idempotent. Consider lower-case letter <tt>ŉ</tt>
--   (U+0149 LATIN SMALL LETTER N PRECEDED BY APOSTROPHE). Then
--   <a>toTitle</a> <tt>"ŉ"</tt> = <tt>"ʼN"</tt>: the first (and the only)
--   letter of the input is converted to title case, becoming two letters.
--   Now <tt>ʼ</tt> (U+02BC MODIFIER LETTER APOSTROPHE) is a modifier
--   letter and as such is recognised as a letter by <a>isLetter</a>, so
--   <a>toTitle</a> <tt>"ʼN"</tt> = <tt>"'n"</tt>.
--   
--   <i>Note</i>: this function does not take language or culture specific
--   rules into account. For instance, in English, different style guides
--   disagree on whether the book name "The Hill of the Red Fox" is
--   correctly title cased—but this function will capitalize <i>every</i>
--   word.
toTitle :: Text -> Text

-- | <i>O(n)</i> Left-justify a string to the given length, using the
--   specified fill character on the right. Performs replacement on invalid
--   scalar values.
--   
--   Examples:
--   
--   <pre>
--   justifyLeft 7 'x' "foo"    == "fooxxxx"
--   justifyLeft 3 'x' "foobar" == "foobar"
--   </pre>
justifyLeft :: Int64 -> Char -> Text -> Text

-- | <i>O(n)</i> Right-justify a string to the given length, using the
--   specified fill character on the left. Performs replacement on invalid
--   scalar values.
--   
--   Examples:
--   
--   <pre>
--   justifyRight 7 'x' "bar"    == "xxxxbar"
--   justifyRight 3 'x' "foobar" == "foobar"
--   </pre>
justifyRight :: Int64 -> Char -> Text -> Text

-- | <i>O(n)</i> Center a string to the given length, using the specified
--   fill character on either side. Performs replacement on invalid scalar
--   values.
--   
--   Examples:
--   
--   <pre>
--   center 8 'x' "HS" = "xxxHSxxx"
--   </pre>
center :: Int64 -> Char -> Text -> Text

-- | <i>O(n)</i> <a>foldl</a>, applied to a binary operator, a starting
--   value (typically the left-identity of the operator), and a
--   <a>Text</a>, reduces the <a>Text</a> using the binary operator, from
--   left to right.
foldl :: (a -> Char -> a) -> a -> Text -> a

-- | <i>O(n)</i> A strict version of <a>foldl</a>.
foldl' :: (a -> Char -> a) -> a -> Text -> a

-- | <i>O(n)</i> <a>foldr</a>, applied to a binary operator, a starting
--   value (typically the right-identity of the operator), and a
--   <a>Text</a>, reduces the <a>Text</a> using the binary operator, from
--   right to left.
--   
--   <a>foldr</a> is lazy like <a>foldr</a> for lists: evaluation actually
--   traverses the <a>Text</a> from left to right, only as far as it needs
--   to.
--   
--   For example, <a>head</a> can be defined with <i>O(1)</i> complexity
--   using <a>foldr</a>:
--   
--   <pre>
--   head :: Text -&gt; Char
--   head = foldr const (error "head empty")
--   </pre>
foldr :: (Char -> a -> a) -> a -> Text -> a

-- | <i>O(n)</i> Concatenate a list of <a>Text</a>s.
concat :: [Text] -> Text

-- | <i>O(n)</i> Map a function over a <a>Text</a> that results in a
--   <a>Text</a>, and concatenate the results.
concatMap :: (Char -> Text) -> Text -> Text

-- | <i>O(n)</i> <a>any</a> <tt>p</tt> <tt>t</tt> determines whether any
--   character in the <a>Text</a> <tt>t</tt> satisfies the predicate
--   <tt>p</tt>.
any :: (Char -> Bool) -> Text -> Bool

-- | <i>O(n)</i> <a>all</a> <tt>p</tt> <tt>t</tt> determines whether all
--   characters in the <a>Text</a> <tt>t</tt> satisfy the predicate
--   <tt>p</tt>.
all :: (Char -> Bool) -> Text -> Bool

-- | <i>O(n)</i> <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left. Performs replacement
--   on invalid scalar values.
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (Char -> Char -> Char) -> Char -> Text -> Text

-- | <i>O(n)</i> <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument. Performs replacement on invalid scalar
--   values.
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (Char -> Char -> Char) -> Text -> Text

-- | <i>O(n)</i> <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Performs replacement on invalid scalar values.
--   
--   <pre>
--   scanr f v == reverse . scanl (flip f) v . reverse
--   </pre>
scanr :: (Char -> Char -> Char) -> Char -> Text -> Text

-- | <i>O(n)</i> <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument. Performs replacement on invalid scalar
--   values.
scanr1 :: (Char -> Char -> Char) -> Text -> Text

-- | <i>O(n)</i> Like a combination of <a>map</a> and <a>foldl'</a>.
--   Applies a function to each element of a <a>Text</a>, passing an
--   accumulating parameter from left to right, and returns a final
--   <a>Text</a>. Performs replacement on invalid scalar values.
mapAccumL :: (a -> Char -> (a, Char)) -> a -> Text -> (a, Text)

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and a strict <a>foldr</a>; it applies a function to each element of a
--   <a>Text</a>, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   <a>Text</a>. Performs replacement on invalid scalar values.
mapAccumR :: (a -> Char -> (a, Char)) -> a -> Text -> (a, Text)

-- | <tt><a>repeat</a> x</tt> is an infinite <a>Text</a>, with <tt>x</tt>
--   the value of every element.
repeat :: Char -> Text

-- | <i>O(n*m)</i> <a>replicate</a> <tt>n</tt> <tt>t</tt> is a <a>Text</a>
--   consisting of the input <tt>t</tt> repeated <tt>n</tt> times.
replicate :: Int64 -> Text -> Text

-- | <a>cycle</a> ties a finite, non-empty <a>Text</a> into a circular one,
--   or equivalently, the infinite repetition of the original <a>Text</a>.
cycle :: HasCallStack => Text -> Text

-- | <tt><a>iterate</a> f x</tt> returns an infinite <a>Text</a> of
--   repeated applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
iterate :: (Char -> Char) -> Char -> Text

-- | <i>O(n)</i>, where <tt>n</tt> is the length of the result. The
--   <a>unfoldr</a> function is analogous to the List <a>unfoldr</a>.
--   <a>unfoldr</a> builds a <a>Text</a> from a seed value. The function
--   takes the element and returns <a>Nothing</a> if it is done producing
--   the <a>Text</a>, otherwise <a>Just</a> <tt>(a,b)</tt>. In this case,
--   <tt>a</tt> is the next <a>Char</a> in the string, and <tt>b</tt> is
--   the seed value for further production. Performs replacement on invalid
--   scalar values.
unfoldr :: (a -> Maybe (Char, a)) -> a -> Text

-- | <i>O(n)</i> Like <a>unfoldr</a>, <a>unfoldrN</a> builds a <a>Text</a>
--   from a seed value. However, the length of the result should be limited
--   by the first argument to <a>unfoldrN</a>. This function is more
--   efficient than <a>unfoldr</a> when the maximum length of the result is
--   known and correct, otherwise its performance is similar to
--   <a>unfoldr</a>. Performs replacement on invalid scalar values.
unfoldrN :: Int64 -> (a -> Maybe (Char, a)) -> a -> Text

-- | <i>O(n)</i> <a>take</a> <tt>n</tt>, applied to a <a>Text</a>, returns
--   the prefix of the <a>Text</a> of length <tt>n</tt>, or the <a>Text</a>
--   itself if <tt>n</tt> is greater than the length of the Text.
take :: Int64 -> Text -> Text

-- | <i>O(n)</i> <a>takeEnd</a> <tt>n</tt> <tt>t</tt> returns the suffix
--   remaining after taking <tt>n</tt> characters from the end of
--   <tt>t</tt>.
--   
--   Examples:
--   
--   <pre>
--   takeEnd 3 "foobar" == "bar"
--   </pre>
takeEnd :: Int64 -> Text -> Text

-- | <i>O(n)</i> <a>drop</a> <tt>n</tt>, applied to a <a>Text</a>, returns
--   the suffix of the <a>Text</a> after the first <tt>n</tt> characters,
--   or the empty <a>Text</a> if <tt>n</tt> is greater than the length of
--   the <a>Text</a>.
drop :: Int64 -> Text -> Text

-- | <i>O(n)</i> <a>dropEnd</a> <tt>n</tt> <tt>t</tt> returns the prefix
--   remaining after dropping <tt>n</tt> characters from the end of
--   <tt>t</tt>.
--   
--   Examples:
--   
--   <pre>
--   dropEnd 3 "foobar" == "foo"
--   </pre>
dropEnd :: Int64 -> Text -> Text

-- | <i>O(n)</i> <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a
--   <a>Text</a>, returns the longest prefix (possibly empty) of elements
--   that satisfy <tt>p</tt>.
takeWhile :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> <a>takeWhileEnd</a>, applied to a predicate <tt>p</tt> and
--   a <a>Text</a>, returns the longest suffix (possibly empty) of elements
--   that satisfy <tt>p</tt>. Examples:
--   
--   <pre>
--   takeWhileEnd (=='o') "foo" == "oo"
--   </pre>
takeWhileEnd :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> <a>dropWhile</a> <tt>p</tt> <tt>t</tt> returns the suffix
--   remaining after <a>takeWhile</a> <tt>p</tt> <tt>t</tt>.
dropWhile :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> <a>dropWhileEnd</a> <tt>p</tt> <tt>t</tt> returns the
--   prefix remaining after dropping characters that satisfy the predicate
--   <tt>p</tt> from the end of <tt>t</tt>.
--   
--   Examples:
--   
--   <pre>
--   dropWhileEnd (=='.') "foo..." == "foo"
--   </pre>
dropWhileEnd :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> <a>dropAround</a> <tt>p</tt> <tt>t</tt> returns the
--   substring remaining after dropping characters that satisfy the
--   predicate <tt>p</tt> from both the beginning and end of <tt>t</tt>.
dropAround :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> Remove leading and trailing white space from a string.
--   Equivalent to:
--   
--   <pre>
--   dropAround isSpace
--   </pre>
strip :: Text -> Text

-- | <i>O(n)</i> Remove leading white space from a string. Equivalent to:
--   
--   <pre>
--   dropWhile isSpace
--   </pre>
stripStart :: Text -> Text

-- | <i>O(n)</i> Remove trailing white space from a string. Equivalent to:
--   
--   <pre>
--   dropWhileEnd isSpace
--   </pre>
stripEnd :: Text -> Text

-- | <i>O(n)</i> <a>splitAt</a> <tt>n t</tt> returns a pair whose first
--   element is a prefix of <tt>t</tt> of length <tt>n</tt>, and whose
--   second is the remainder of the string. It is equivalent to
--   <tt>(<a>take</a> n t, <a>drop</a> n t)</tt>.
splitAt :: Int64 -> Text -> (Text, Text)

-- | <i>O(n)</i> <a>span</a>, applied to a predicate <tt>p</tt> and text
--   <tt>t</tt>, returns a pair whose first element is the longest prefix
--   (possibly empty) of <tt>t</tt> of elements that satisfy <tt>p</tt>,
--   and whose second is the remainder of the text.
--   
--   <pre>
--   &gt;&gt;&gt; T.span (=='0') "000AB"
--   ("000","AB")
--   </pre>
span :: (Char -> Bool) -> Text -> (Text, Text)

-- | <i>O(n)</i> <a>break</a> is like <a>span</a>, but the prefix returned
--   is over elements that fail the predicate <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; T.break (=='c') "180cm"
--   ("180","cm")
--   </pre>
break :: (Char -> Bool) -> Text -> (Text, Text)

-- | The <a>group</a> function takes a <a>Text</a> and returns a list of
--   <a>Text</a>s such that the concatenation of the result is equal to the
--   argument. Moreover, each sublist in the result contains only equal
--   elements. For example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Text -> [Text]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (Char -> Char -> Bool) -> Text -> [Text]

-- | <i>O(n)</i> Return all initial segments of the given <a>Text</a>,
--   shortest first.
inits :: Text -> [Text]

-- | <i>O(n)</i> Return all final segments of the given <a>Text</a>,
--   longest first.
tails :: Text -> [Text]

-- | <i>O(n)</i> Splits a <a>Text</a> into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. eg.
--   
--   <pre>
--   split (=='a') "aabbaca" == ["","","bb","c",""]
--   split (=='a') []        == [""]
--   </pre>
split :: (Char -> Bool) -> Text -> [Text]

-- | <i>O(n)</i> Splits a <a>Text</a> into components of length <tt>k</tt>.
--   The last element may be shorter than the other chunks, depending on
--   the length of the input. Examples:
--   
--   <pre>
--   chunksOf 3 "foobarbaz"   == ["foo","bar","baz"]
--   chunksOf 4 "haskell.org" == ["hask","ell.","org"]
--   </pre>
chunksOf :: Int64 -> Text -> [Text]

-- | <i>O(n)</i> Breaks a <a>Text</a> up into a list of <a>Text</a>s at
--   newline characters <tt>'\n'</tt> (LF, line feed). The resulting
--   strings do not contain newlines.
--   
--   <a>lines</a> <b>does not</b> treat <tt>'\r'</tt> (CR, carriage return)
--   as a newline character.
lines :: Text -> [Text]

-- | <i>O(n)</i> Breaks a <a>Text</a> up into a list of words, delimited by
--   <a>Char</a>s representing white space.
words :: Text -> [Text]

-- | <i>O(n)</i> Joins lines, after appending a terminating newline to
--   each.
unlines :: [Text] -> Text

-- | <i>O(n)</i> Joins words using single space characters.
unwords :: [Text] -> Text

-- | <i>O(n)</i> The <a>isPrefixOf</a> function takes two <a>Text</a>s and
--   returns <a>True</a> if and only if the first is a prefix of the
--   second.
isPrefixOf :: Text -> Text -> Bool

-- | <i>O(n)</i> The <a>isSuffixOf</a> function takes two <a>Text</a>s and
--   returns <a>True</a> if and only if the first is a suffix of the
--   second.
isSuffixOf :: Text -> Text -> Bool

-- | <i>O(n+m)</i> The <a>isInfixOf</a> function takes two <a>Text</a>s and
--   returns <a>True</a> if and only if the first is contained, wholly and
--   intact, anywhere within the second.
--   
--   This function is strict in its first argument, and lazy in its second.
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
isInfixOf :: Text -> Text -> Bool

-- | <i>O(n)</i> Return the suffix of the second string if its prefix
--   matches the entire first string.
--   
--   Examples:
--   
--   <pre>
--   stripPrefix "foo" "foobar" == Just "bar"
--   stripPrefix ""    "baz"    == Just "baz"
--   stripPrefix "foo" "quux"   == Nothing
--   </pre>
--   
--   This is particularly useful with the <tt>ViewPatterns</tt> extension
--   to GHC, as follows:
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns #-}
--   import Data.Text.Lazy as T
--   
--   fnordLength :: Text -&gt; Int
--   fnordLength (stripPrefix "fnord" -&gt; Just suf) = T.length suf
--   fnordLength _                                 = -1
--   </pre>
stripPrefix :: Text -> Text -> Maybe Text

-- | <i>O(n)</i> Return the prefix of the second string if its suffix
--   matches the entire first string.
--   
--   Examples:
--   
--   <pre>
--   stripSuffix "bar" "foobar" == Just "foo"
--   stripSuffix ""    "baz"    == Just "baz"
--   stripSuffix "foo" "quux"   == Nothing
--   </pre>
--   
--   This is particularly useful with the <tt>ViewPatterns</tt> extension
--   to GHC, as follows:
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns #-}
--   import Data.Text.Lazy as T
--   
--   quuxLength :: Text -&gt; Int
--   quuxLength (stripSuffix "quux" -&gt; Just pre) = T.length pre
--   quuxLength _                                = -1
--   </pre>
stripSuffix :: Text -> Text -> Maybe Text

-- | <i>O(n)</i> Find the longest non-empty common prefix of two strings
--   and return it, along with the suffixes of each string at which they no
--   longer match.
--   
--   If the strings do not have a common prefix or either one is empty,
--   this function returns <a>Nothing</a>.
--   
--   Examples:
--   
--   <pre>
--   commonPrefixes "foobar" "fooquux" == Just ("foo","bar","quux")
--   commonPrefixes "veeble" "fetzer"  == Nothing
--   commonPrefixes "" "baz"           == Nothing
--   </pre>
commonPrefixes :: Text -> Text -> Maybe (Text, Text, Text)

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a <a>Text</a>,
--   returns a <a>Text</a> containing those characters that satisfy the
--   predicate.
filter :: (Char -> Bool) -> Text -> Text

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   <a>Text</a>, and returns the first element in matching the predicate,
--   or <a>Nothing</a> if there is no such element.
find :: (Char -> Bool) -> Text -> Maybe Char

-- | <i>O(n)</i> The <a>partition</a> function takes a predicate and a
--   <a>Text</a>, and returns the pair of <a>Text</a>s with elements which
--   do and do not satisfy the predicate, respectively; i.e.
--   
--   <pre>
--   partition p t == (filter p t, filter (not . p) t)
--   </pre>
partition :: (Char -> Bool) -> Text -> (Text, Text)

-- | <i>O(n)</i> <a>Text</a> index (subscript) operator, starting from 0.
index :: HasCallStack => Text -> Int64 -> Char

-- | <i>O(n+m)</i> The <a>count</a> function returns the number of times
--   the query string appears in the given <a>Text</a>. An empty query
--   string is invalid, and will cause an error to be raised.
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
count :: HasCallStack => Text -> Text -> Int64

-- | <i>O(n)</i> <a>zip</a> takes two <a>Text</a>s and returns a list of
--   corresponding pairs of bytes. If one input <a>Text</a> is short,
--   excess elements of the longer <a>Text</a> are discarded. This is
--   equivalent to a pair of <a>unpack</a> operations.
zip :: Text -> Text -> [(Char, Char)]

-- | <i>O(n)</i> <a>zipWith</a> generalises <a>zip</a> by zipping with the
--   function given as the first argument, instead of a tupling function.
--   Performs replacement on invalid scalar values.
zipWith :: (Char -> Char -> Char) -> Text -> Text -> Text


-- | Lazy <tt>Text</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.Text.Lazy.Partial as TL'
--   </pre>
module RIO.Text.Lazy.Partial

-- | <i>O(1)</i> Returns the first character of a <a>Text</a>, which must
--   be non-empty. This is a partial function, consider using <a>uncons</a>
--   instead.
head :: HasCallStack => Text -> Char

-- | <i>O(n/c)</i> Returns the last character of a <a>Text</a>, which must
--   be non-empty. This is a partial function, consider using <a>unsnoc</a>
--   instead.
last :: HasCallStack => Text -> Char

-- | <i>O(1)</i> Returns all characters after the head of a <a>Text</a>,
--   which must be non-empty. This is a partial function, consider using
--   <a>uncons</a> instead.
tail :: HasCallStack => Text -> Text

-- | <i>O(n/c)</i> Returns all but the last character of a <a>Text</a>,
--   which must be non-empty. This is a partial function, consider using
--   <a>unsnoc</a> instead.
init :: HasCallStack => Text -> Text

-- | <i>O(m+n)</i> Replace every non-overlapping occurrence of
--   <tt>needle</tt> in <tt>haystack</tt> with <tt>replacement</tt>.
--   
--   This function behaves as though it was defined as follows:
--   
--   <pre>
--   replace needle replacement haystack =
--     <a>intercalate</a> replacement (<a>splitOn</a> needle haystack)
--   </pre>
--   
--   As this suggests, each occurrence is replaced exactly once. So if
--   <tt>needle</tt> occurs in <tt>replacement</tt>, that occurrence will
--   <i>not</i> itself be replaced recursively:
--   
--   <pre>
--   replace "oo" "foo" "oo" == "foo"
--   </pre>
--   
--   In cases where several instances of <tt>needle</tt> overlap, only the
--   first one will be replaced:
--   
--   <pre>
--   replace "ofo" "bar" "ofofo" == "barfo"
--   </pre>
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
replace :: HasCallStack => Text -> Text -> Text -> Text

-- | <i>O(n)</i> A variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to a non-empty <a>Text</a>.
foldl1 :: HasCallStack => (Char -> Char -> Char) -> Text -> Char

-- | <i>O(n)</i> A strict version of <a>foldl1</a>.
foldl1' :: HasCallStack => (Char -> Char -> Char) -> Text -> Char

-- | <i>O(n)</i> A variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to a non-empty <a>Text</a>.
foldr1 :: HasCallStack => (Char -> Char -> Char) -> Text -> Char

-- | <i>O(n)</i> <a>maximum</a> returns the maximum value from a
--   <a>Text</a>, which must be non-empty.
maximum :: HasCallStack => Text -> Char

-- | <i>O(n)</i> <a>minimum</a> returns the minimum value from a
--   <a>Text</a>, which must be non-empty.
minimum :: HasCallStack => Text -> Char

-- | <i>O(n+m)</i> Find the first instance of <tt>needle</tt> (which must
--   be non-<a>null</a>) in <tt>haystack</tt>. The first element of the
--   returned tuple is the prefix of <tt>haystack</tt> before
--   <tt>needle</tt> is matched. The second is the remainder of
--   <tt>haystack</tt>, starting with the match.
--   
--   Examples:
--   
--   <pre>
--   breakOn "::" "a::b::c" ==&gt; ("a", "::b::c")
--   breakOn "/" "foobar"   ==&gt; ("foobar", "")
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   append prefix match == haystack
--     where (prefix, match) = breakOn needle haystack
--   </pre>
--   
--   If you need to break a string by a substring repeatedly (e.g. you want
--   to break on every instance of a substring), use <a>breakOnAll</a>
--   instead, as it has lower startup overhead.
--   
--   This function is strict in its first argument, and lazy in its second.
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
breakOn :: HasCallStack => Text -> Text -> (Text, Text)

-- | <i>O(n+m)</i> Similar to <a>breakOn</a>, but searches from the end of
--   the string.
--   
--   The first element of the returned tuple is the prefix of
--   <tt>haystack</tt> up to and including the last match of
--   <tt>needle</tt>. The second is the remainder of <tt>haystack</tt>,
--   following the match.
--   
--   <pre>
--   breakOnEnd "::" "a::b::c" ==&gt; ("a::b::", "c")
--   </pre>
breakOnEnd :: HasCallStack => Text -> Text -> (Text, Text)

-- | <i>O(m+n)</i> Break a <a>Text</a> into pieces separated by the first
--   <a>Text</a> argument (which cannot be an empty string), consuming the
--   delimiter. An empty delimiter is invalid, and will cause an error to
--   be raised.
--   
--   Examples:
--   
--   <pre>
--   splitOn "\r\n" "a\r\nb\r\nd\r\ne" == ["a","b","d","e"]
--   splitOn "aaa"  "aaaXaaaXaaaXaaa"  == ["","X","X","X",""]
--   splitOn "x"    "x"                == ["",""]
--   </pre>
--   
--   and
--   
--   <pre>
--   intercalate s . splitOn s         == id
--   splitOn (singleton c)             == split (==c)
--   </pre>
--   
--   (Note: the string <tt>s</tt> to split on above cannot be empty.)
--   
--   This function is strict in its first argument, and lazy in its second.
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
splitOn :: HasCallStack => Text -> Text -> [Text]

-- | <i>O(n+m)</i> Find all non-overlapping instances of <tt>needle</tt> in
--   <tt>haystack</tt>. Each element of the returned list consists of a
--   pair:
--   
--   <ul>
--   <li>The entire string prior to the <i>k</i>th match (i.e. the
--   prefix)</li>
--   <li>The <i>k</i>th match, followed by the remainder of the string</li>
--   </ul>
--   
--   Examples:
--   
--   <pre>
--   breakOnAll "::" ""
--   ==&gt; []
--   breakOnAll "/" "a/b/c/"
--   ==&gt; [("a", "/b/c/"), ("a/b", "/c/"), ("a/b/c", "/")]
--   </pre>
--   
--   This function is strict in its first argument, and lazy in its second.
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
--   
--   The <tt>needle</tt> parameter may not be empty.
breakOnAll :: HasCallStack => Text -> Text -> [(Text, Text)]


-- | Strict <tt>Text</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.Text.Partial as T'
--   </pre>
module RIO.Text.Partial

-- | <i>O(1)</i> Returns the first character of a <a>Text</a>, which must
--   be non-empty. This is a partial function, consider using <a>uncons</a>
--   instead.
head :: HasCallStack => Text -> Char

-- | <i>O(1)</i> Returns the last character of a <a>Text</a>, which must be
--   non-empty. This is a partial function, consider using <a>unsnoc</a>
--   instead.
last :: HasCallStack => Text -> Char

-- | <i>O(1)</i> Returns all characters after the head of a <a>Text</a>,
--   which must be non-empty. This is a partial function, consider using
--   <a>uncons</a> instead.
tail :: HasCallStack => Text -> Text

-- | <i>O(1)</i> Returns all but the last character of a <a>Text</a>, which
--   must be non-empty. This is a partial function, consider using
--   <a>unsnoc</a> instead.
init :: HasCallStack => Text -> Text

-- | <i>O(m+n)</i> Replace every non-overlapping occurrence of
--   <tt>needle</tt> in <tt>haystack</tt> with <tt>replacement</tt>.
--   
--   This function behaves as though it was defined as follows:
--   
--   <pre>
--   replace needle replacement haystack =
--     <a>intercalate</a> replacement (<a>splitOn</a> needle haystack)
--   </pre>
--   
--   As this suggests, each occurrence is replaced exactly once. So if
--   <tt>needle</tt> occurs in <tt>replacement</tt>, that occurrence will
--   <i>not</i> itself be replaced recursively:
--   
--   <pre>
--   &gt;&gt;&gt; replace "oo" "foo" "oo"
--   "foo"
--   </pre>
--   
--   In cases where several instances of <tt>needle</tt> overlap, only the
--   first one will be replaced:
--   
--   <pre>
--   &gt;&gt;&gt; replace "ofo" "bar" "ofofo"
--   "barfo"
--   </pre>
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
replace :: HasCallStack => Text -> Text -> Text -> Text

-- | <i>O(n)</i> A variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to a non-empty <a>Text</a>.
foldl1 :: HasCallStack => (Char -> Char -> Char) -> Text -> Char

-- | <i>O(n)</i> A strict version of <a>foldl1</a>.
foldl1' :: HasCallStack => (Char -> Char -> Char) -> Text -> Char

-- | <i>O(n)</i> A variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to a non-empty <a>Text</a>.
foldr1 :: HasCallStack => (Char -> Char -> Char) -> Text -> Char

-- | <i>O(n)</i> <a>maximum</a> returns the maximum value from a
--   <a>Text</a>, which must be non-empty.
maximum :: HasCallStack => Text -> Char

-- | <i>O(n)</i> <a>minimum</a> returns the minimum value from a
--   <a>Text</a>, which must be non-empty.
minimum :: HasCallStack => Text -> Char

-- | <i>O(n+m)</i> Find the first instance of <tt>needle</tt> (which must
--   be non-<a>null</a>) in <tt>haystack</tt>. The first element of the
--   returned tuple is the prefix of <tt>haystack</tt> before
--   <tt>needle</tt> is matched. The second is the remainder of
--   <tt>haystack</tt>, starting with the match.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; breakOn "::" "a::b::c"
--   ("a","::b::c")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; breakOn "/" "foobar"
--   ("foobar","")
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   append prefix match == haystack
--     where (prefix, match) = breakOn needle haystack
--   </pre>
--   
--   If you need to break a string by a substring repeatedly (e.g. you want
--   to break on every instance of a substring), use <a>breakOnAll</a>
--   instead, as it has lower startup overhead.
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
breakOn :: HasCallStack => Text -> Text -> (Text, Text)

-- | <i>O(n+m)</i> Similar to <a>breakOn</a>, but searches from the end of
--   the string.
--   
--   The first element of the returned tuple is the prefix of
--   <tt>haystack</tt> up to and including the last match of
--   <tt>needle</tt>. The second is the remainder of <tt>haystack</tt>,
--   following the match.
--   
--   <pre>
--   &gt;&gt;&gt; breakOnEnd "::" "a::b::c"
--   ("a::b::","c")
--   </pre>
breakOnEnd :: HasCallStack => Text -> Text -> (Text, Text)

-- | <i>O(m+n)</i> Break a <a>Text</a> into pieces separated by the first
--   <a>Text</a> argument (which cannot be empty), consuming the delimiter.
--   An empty delimiter is invalid, and will cause an error to be raised.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; splitOn "\r\n" "a\r\nb\r\nd\r\ne"
--   ["a","b","d","e"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitOn "aaa"  "aaaXaaaXaaaXaaa"
--   ["","X","X","X",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitOn "x"    "x"
--   ["",""]
--   </pre>
--   
--   and
--   
--   <pre>
--   intercalate s . splitOn s         == id
--   splitOn (singleton c)             == split (==c)
--   </pre>
--   
--   (Note: the string <tt>s</tt> to split on above cannot be empty.)
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
splitOn :: HasCallStack => Text -> Text -> [Text]

-- | <i>O(n+m)</i> Find all non-overlapping instances of <tt>needle</tt> in
--   <tt>haystack</tt>. Each element of the returned list consists of a
--   pair:
--   
--   <ul>
--   <li>The entire string prior to the <i>k</i>th match (i.e. the
--   prefix)</li>
--   <li>The <i>k</i>th match, followed by the remainder of the string</li>
--   </ul>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; breakOnAll "::" ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; breakOnAll "/" "a/b/c/"
--   [("a","/b/c/"),("a/b","/c/"),("a/b/c","/")]
--   </pre>
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
--   
--   The <tt>needle</tt> parameter may not be empty.
breakOnAll :: HasCallStack => Text -> Text -> [(Text, Text)]

-- | <i>O(n+m)</i> The <a>count</a> function returns the number of times
--   the query string appears in the given <a>Text</a>. An empty query
--   string is invalid, and will cause an error to be raised.
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
count :: HasCallStack => Text -> Text -> Int

module RIO.Time
data () => CalendarDiffDays
CalendarDiffDays :: Integer -> Integer -> CalendarDiffDays
[cdMonths] :: CalendarDiffDays -> Integer
[cdDays] :: CalendarDiffDays -> Integer

-- | The class of types which can be represented as a period of days.
class Ord p => DayPeriod p

-- | Returns the first <a>Day</a> in a period of days.
periodFirstDay :: DayPeriod p => p -> Day

-- | Returns the last <a>Day</a> in a period of days.
periodLastDay :: DayPeriod p => p -> Day

-- | Get the period this day is in.
dayPeriod :: DayPeriod p => Day -> p

-- | The Modified Julian Day is a standard count of days, with zero being
--   the day 1858-11-17.
newtype () => Day
ModifiedJulianDay :: Integer -> Day
[toModifiedJulianDay] :: Day -> Integer

-- | Day of month, in range 1 to 31.
type DayOfMonth = Int

-- | Month of year, in range 1 (January) to 12 (December).
type MonthOfYear = Int

-- | Year of Common Era (when positive).
type Year = Integer
data () => DayOfWeek
Monday :: DayOfWeek
Tuesday :: DayOfWeek
Wednesday :: DayOfWeek
Thursday :: DayOfWeek
Friday :: DayOfWeek
Saturday :: DayOfWeek
Sunday :: DayOfWeek

-- | This is a length of time, as measured by a clock. Conversion functions
--   such as <a>fromInteger</a> and <a>realToFrac</a> will treat it as
--   seconds. For example, <tt>(0.010 :: DiffTime)</tt> corresponds to 10
--   milliseconds.
--   
--   It has a precision of one picosecond (= 10^-12 s). Enumeration
--   functions will treat it as picoseconds.
data () => DiffTime

-- | This is a length of time, as measured by UTC. It has a precision of
--   10^-12 s.
--   
--   Conversion functions such as <a>fromInteger</a> and <a>realToFrac</a>
--   will treat it as seconds. For example, <tt>(0.010 ::
--   NominalDiffTime)</tt> corresponds to 10 milliseconds.
--   
--   It has a precision of one picosecond (= 10^-12 s). Enumeration
--   functions will treat it as picoseconds.
--   
--   It ignores leap-seconds, so it's not necessarily a fixed amount of
--   clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime =
--   01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.
data () => NominalDiffTime

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data () => UTCTime
UTCTime :: Day -> DiffTime -> UTCTime

-- | the day
[utctDay] :: UTCTime -> Day

-- | the time from midnight, 0 &lt;= t &lt; 86401s (because of
--   leap-seconds)
[utctDayTime] :: UTCTime -> DiffTime

-- | The Modified Julian Date is the day with the fraction of the day,
--   measured from UT midnight. It's used to represent UT1, which is time
--   as measured by the earth's rotation, adjusted for various wobbles.
newtype () => UniversalTime
ModJulianDate :: Rational -> UniversalTime
[getModJulianDate] :: UniversalTime -> Rational
data () => CalendarDiffTime
CalendarDiffTime :: Integer -> NominalDiffTime -> CalendarDiffTime
[ctMonths] :: CalendarDiffTime -> Integer
[ctTime] :: CalendarDiffTime -> NominalDiffTime

-- | A TimeZone is a whole number of minutes offset from UTC, together with
--   a name and a "just for summer" flag.
data () => TimeZone
TimeZone :: Int -> Bool -> String -> TimeZone

-- | The number of minutes offset from UTC. Positive means local time will
--   be later in the day than UTC.
[timeZoneMinutes] :: TimeZone -> Int

-- | Is this time zone just persisting for the summer?
[timeZoneSummerOnly] :: TimeZone -> Bool

-- | The name of the zone, typically a three- or four-letter acronym.
[timeZoneName] :: TimeZone -> String

-- | Time of day as represented in hour, minute and second (with
--   picoseconds), typically used to express local time of day.
--   
--   <tt>TimeOfDay 24 0 0</tt> is considered invalid for the purposes of
--   <a>makeTimeOfDayValid</a>, as well as reading and parsing, but valid
--   for ISO 8601 parsing in <a>Data.Time.Format.ISO8601</a>.
data () => TimeOfDay
TimeOfDay :: Int -> Int -> Pico -> TimeOfDay

-- | range 0 - 23
[todHour] :: TimeOfDay -> Int

-- | range 0 - 59
[todMin] :: TimeOfDay -> Int

-- | Note that 0 &lt;= <a>todSec</a> &lt; 61, accomodating leap seconds.
--   Any local minute may have a leap second, since leap seconds happen in
--   all zones simultaneously
[todSec] :: TimeOfDay -> Pico

-- | A simple day and time aggregate, where the day is of the specified
--   parameter, and the time is a TimeOfDay. Conversion of this (as local
--   civil time) to UTC depends on the time zone. Conversion of this (as
--   local mean time) to UT1 depends on the longitude.
data () => LocalTime
LocalTime :: Day -> TimeOfDay -> LocalTime
[localDay] :: LocalTime -> Day
[localTimeOfDay] :: LocalTime -> TimeOfDay
data () => TimeLocale
TimeLocale :: [(String, String)] -> [(String, String)] -> (String, String) -> String -> String -> String -> String -> [TimeZone] -> TimeLocale

-- | full and abbreviated week days, starting with Sunday
[wDays] :: TimeLocale -> [(String, String)]

-- | full and abbreviated months
[months] :: TimeLocale -> [(String, String)]

-- | AM/PM symbols
[amPm] :: TimeLocale -> (String, String)

-- | formatting strings
[dateTimeFmt] :: TimeLocale -> String

-- | formatting strings
[dateFmt] :: TimeLocale -> String

-- | formatting strings
[timeFmt] :: TimeLocale -> String

-- | formatting strings
[time12Fmt] :: TimeLocale -> String

-- | time zones known by name
[knownTimeZones] :: TimeLocale -> [TimeZone]

-- | The class of types which can be parsed given a UNIX-style time format
--   string.
class () => ParseTime t
class () => FormatTime t

-- | A local time together with a time zone.
--   
--   There is no <a>Eq</a> instance for <tt>ZonedTime</tt>. If you want to
--   compare local times, use <a>zonedTimeToLocalTime</a>. If you want to
--   compare absolute times, use <a>zonedTimeToUTC</a>.
data () => ZonedTime
ZonedTime :: LocalTime -> TimeZone -> ZonedTime
[zonedTimeToLocalTime] :: ZonedTime -> LocalTime
[zonedTimeZone] :: ZonedTime -> TimeZone

-- | The twelve <a>MonthOfYear</a> patterns form a <tt>COMPLETE</tt> set.
pattern December :: MonthOfYear
pattern November :: MonthOfYear
pattern October :: MonthOfYear
pattern September :: MonthOfYear
pattern August :: MonthOfYear
pattern July :: MonthOfYear
pattern June :: MonthOfYear
pattern May :: MonthOfYear
pattern April :: MonthOfYear
pattern March :: MonthOfYear
pattern February :: MonthOfYear
pattern January :: MonthOfYear

-- | Also known as Before Christ. Note that Year 1 = 1 CE, and the previous
--   Year 0 = 1 BCE. <a>CommonEra</a> and <a>BeforeCommonEra</a> form a
--   <tt>COMPLETE</tt> set.
pattern BeforeCommonEra :: Integer -> Year

-- | Also known as Anno Domini.
pattern CommonEra :: Integer -> Year

-- | Bidirectional abstract constructor for the proleptic Gregorian
--   calendar. Invalid values will be clipped to the correct range, month
--   first, then day.
pattern YearMonthDay :: Year -> MonthOfYear -> DayOfMonth -> Day

-- | Substitute various time-related information for each %-code in the
--   string, as per <a>formatCharacter</a>.
--   
--   The general form is
--   <tt>%&lt;modifier&gt;&lt;width&gt;&lt;alternate&gt;&lt;specifier&gt;</tt>,
--   where <tt>&lt;modifier&gt;</tt>, <tt>&lt;width&gt;</tt>, and
--   <tt>&lt;alternate&gt;</tt> are optional.
--   
--   <h2><tt>&lt;modifier&gt;</tt></h2>
--   
--   glibc-style modifiers can be used before the specifier (here marked as
--   <tt>z</tt>):
--   
--   <ul>
--   <li><i><tt>%-z</tt></i> no padding</li>
--   <li><i><tt>%_z</tt></i> pad with spaces</li>
--   <li><i><tt>%0z</tt></i> pad with zeros</li>
--   <li><i><tt>%^z</tt></i> convert to upper case</li>
--   <li><i><tt>%#z</tt></i> convert to lower case (consistently, unlike
--   glibc)</li>
--   </ul>
--   
--   <h2><tt>&lt;width&gt;</tt></h2>
--   
--   Width digits can also be used after any modifiers and before the
--   specifier (here marked as <tt>z</tt>), for example:
--   
--   <ul>
--   <li><i><tt>%4z</tt></i> pad to 4 characters (with default padding
--   character)</li>
--   <li><i><tt>%_12z</tt></i> pad with spaces to 12 characters</li>
--   </ul>
--   
--   <h2><tt>&lt;alternate&gt;</tt></h2>
--   
--   An optional <tt>E</tt> character indicates an alternate formatting.
--   Currently this only affects <tt>%Z</tt> and <tt>%z</tt>.
--   
--   <ul>
--   <li><i><tt>%Ez</tt></i> alternate formatting</li>
--   </ul>
--   
--   <h2><tt>&lt;specifier&gt;</tt></h2>
--   
--   For all types (note these three are done by <a>formatTime</a>, not by
--   <a>formatCharacter</a>):
--   
--   <ul>
--   <li><i><tt>%%</tt></i> <tt>%</tt></li>
--   <li><i><tt>%t</tt></i> tab</li>
--   <li><i><tt>%n</tt></i> newline</li>
--   </ul>
--   
--   <h3><tt>TimeZone</tt></h3>
--   
--   For <tt>TimeZone</tt> (and <tt>ZonedTime</tt> and <tt>UTCTime</tt>):
--   
--   <ul>
--   <li><i><tt>%z</tt></i> timezone offset in the format
--   <tt>±HHMM</tt></li>
--   <li><i><tt>%Ez</tt></i> timezone offset in the format
--   <tt>±HH:MM</tt></li>
--   <li><i><tt>%Z</tt></i> timezone name (or else offset in the format
--   <tt>±HHMM</tt>)</li>
--   <li><i><tt>%EZ</tt></i> timezone name (or else offset in the format
--   <tt>±HH:MM</tt>)</li>
--   </ul>
--   
--   <h3><tt>LocalTime</tt></h3>
--   
--   For <tt>LocalTime</tt> (and <tt>ZonedTime</tt> and <tt>UTCTime</tt>
--   and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%c</tt></i> as <a>dateTimeFmt</a> <tt>locale</tt> (e.g.
--   <tt>%a %b %e %H:%M:%S %Z %Y</tt>)</li>
--   </ul>
--   
--   <h3><tt>TimeOfDay</tt></h3>
--   
--   For <tt>TimeOfDay</tt> (and <tt>LocalTime</tt> and <tt>ZonedTime</tt>
--   and <tt>UTCTime</tt> and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%R</tt></i> same as <tt>%H:%M</tt></li>
--   <li><i><tt>%T</tt></i> same as <tt>%H:%M:%S</tt></li>
--   <li><i><tt>%X</tt></i> as <a>timeFmt</a> <tt>locale</tt> (e.g.
--   <tt>%H:%M:%S</tt>)</li>
--   <li><i><tt>%r</tt></i> as <a>time12Fmt</a> <tt>locale</tt> (e.g.
--   <tt>%I:%M:%S %p</tt>)</li>
--   <li><i><tt>%P</tt></i> day-half of day from (<a>amPm</a>
--   <tt>locale</tt>), converted to lowercase, <tt>am</tt>,
--   <tt>pm</tt></li>
--   <li><i><tt>%p</tt></i> day-half of day from (<a>amPm</a>
--   <tt>locale</tt>), <tt>AM</tt>, <tt>PM</tt></li>
--   <li><i><tt>%H</tt></i> hour of day (24-hour), 0-padded to two chars,
--   <tt>00</tt> - <tt>23</tt></li>
--   <li><i><tt>%k</tt></i> hour of day (24-hour), space-padded to two
--   chars, <tt> 0</tt> - <tt>23</tt></li>
--   <li><i><tt>%I</tt></i> hour of day-half (12-hour), 0-padded to two
--   chars, <tt>01</tt> - <tt>12</tt></li>
--   <li><i><tt>%l</tt></i> hour of day-half (12-hour), space-padded to two
--   chars, <tt> 1</tt> - <tt>12</tt></li>
--   <li><i><tt>%M</tt></i> minute of hour, 0-padded to two chars,
--   <tt>00</tt> - <tt>59</tt></li>
--   <li><i><tt>%S</tt></i> second of minute (without decimal part),
--   0-padded to two chars, <tt>00</tt> - <tt>60</tt></li>
--   <li><i><tt>%q</tt></i> picosecond of second, 0-padded to twelve chars,
--   <tt>000000000000</tt> - <tt>999999999999</tt>.</li>
--   <li><i><tt>%Q</tt></i> decimal point and fraction of second, up to 12
--   second decimals, without trailing zeros. For a whole number of
--   seconds, <tt>%Q</tt> omits the decimal point unless padding is
--   specified.</li>
--   </ul>
--   
--   <h3><tt>UTCTime</tt> and <tt>ZonedTime</tt></h3>
--   
--   For <tt>UTCTime</tt> and <tt>ZonedTime</tt>:
--   
--   <ul>
--   <li><i><tt>%s</tt></i> number of whole seconds since the Unix epoch.
--   For times before the Unix epoch, this is a negative number. Note that
--   in <tt>%s.%q</tt> and <tt>%s%Q</tt> the decimals are positive, not
--   negative. For example, 0.9 seconds before the Unix epoch is formatted
--   as <tt>-1.1</tt> with <tt>%s%Q</tt>.</li>
--   </ul>
--   
--   <h3><tt>DayOfWeek</tt></h3>
--   
--   For <tt>DayOfWeek</tt> (and <tt>Day</tt> and <tt>LocalTime</tt> and
--   <tt>ZonedTime</tt> and <tt>UTCTime</tt> and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%u</tt></i> day of week number for Week Date format,
--   <tt>1</tt> (= Monday) - <tt>7</tt> (= Sunday)</li>
--   <li><i><tt>%w</tt></i> day of week number, <tt>0</tt> (= Sunday) -
--   <tt>6</tt> (= Saturday)</li>
--   <li><i><tt>%a</tt></i> day of week, short form (<a>snd</a> from
--   <a>wDays</a> <tt>locale</tt>), <tt>Sun</tt> - <tt>Sat</tt></li>
--   <li><i><tt>%A</tt></i> day of week, long form (<a>fst</a> from
--   <a>wDays</a> <tt>locale</tt>), <tt>Sunday</tt> -
--   <tt>Saturday</tt></li>
--   </ul>
--   
--   <h3><tt>Month</tt></h3>
--   
--   For <tt>Month</tt> (and <tt>Day</tt> and <tt>LocalTime</tt> and
--   <tt>ZonedTime</tt> and <tt>UTCTime</tt> and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%Y</tt></i> year, no padding. Note <tt>%0Y</tt> and
--   <tt>%_Y</tt> pad to four chars</li>
--   <li><i><tt>%y</tt></i> year of century, 0-padded to two chars,
--   <tt>00</tt> - <tt>99</tt></li>
--   <li><i><tt>%C</tt></i> century, no padding. Note <tt>%0C</tt> and
--   <tt>%_C</tt> pad to two chars</li>
--   <li><i><tt>%B</tt></i> month name, long form (<a>fst</a> from
--   <a>months</a> <tt>locale</tt>), <tt>January</tt> -
--   <tt>December</tt></li>
--   <li><i><tt>%b</tt>, <tt>%h</tt></i> month name, short form (<a>snd</a>
--   from <a>months</a> <tt>locale</tt>), <tt>Jan</tt> - <tt>Dec</tt></li>
--   <li><i><tt>%m</tt></i> month of year, 0-padded to two chars,
--   <tt>01</tt> - <tt>12</tt></li>
--   </ul>
--   
--   <h3><tt>Day</tt></h3>
--   
--   For <tt>Day</tt> (and <tt>LocalTime</tt> and <tt>ZonedTime</tt> and
--   <tt>UTCTime</tt> and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%D</tt></i> same as <tt>%m/%d/%y</tt></li>
--   <li><i><tt>%F</tt></i> same as <tt>%Y-%m-%d</tt></li>
--   <li><i><tt>%x</tt></i> as <a>dateFmt</a> <tt>locale</tt> (e.g.
--   <tt>%m/%d/%y</tt>)</li>
--   <li><i><tt>%d</tt></i> day of month, 0-padded to two chars,
--   <tt>01</tt> - <tt>31</tt></li>
--   <li><i><tt>%e</tt></i> day of month, space-padded to two chars, <tt>
--   1</tt> - <tt>31</tt></li>
--   <li><i><tt>%j</tt></i> day of year, 0-padded to three chars,
--   <tt>001</tt> - <tt>366</tt></li>
--   <li><i><tt>%f</tt></i> century for Week Date format, no padding. Note
--   <tt>%0f</tt> and <tt>%_f</tt> pad to two chars</li>
--   <li><i><tt>%V</tt></i> week of year for Week Date format, 0-padded to
--   two chars, <tt>01</tt> - <tt>53</tt></li>
--   <li><i><tt>%U</tt></i> week of year where weeks start on Sunday (as
--   <tt>sundayStartWeek</tt>), 0-padded to two chars, <tt>00</tt> -
--   <tt>53</tt></li>
--   <li><i><tt>%W</tt></i> week of year where weeks start on Monday (as
--   <tt>mondayStartWeek</tt>), 0-padded to two chars, <tt>00</tt> -
--   <tt>53</tt></li>
--   </ul>
--   
--   <h2>Duration types</h2>
--   
--   The specifiers for <tt>DiffTime</tt>, <tt>NominalDiffTime</tt>,
--   <tt>CalendarDiffDays</tt>, and <tt>CalendarDiffTime</tt> are
--   semantically separate from the other types. Specifiers on negative
--   time differences will generally be negative (think <a>rem</a> rather
--   than <a>mod</a>).
--   
--   <h3><tt>NominalDiffTime</tt> and <tt>DiffTime</tt></h3>
--   
--   Note that a "minute" of <tt>DiffTime</tt> is simply 60 SI seconds,
--   rather than a minute of civil time. Use <tt>NominalDiffTime</tt> to
--   work with civil time, ignoring any leap seconds.
--   
--   For <tt>NominalDiffTime</tt> and <tt>DiffTime</tt>:
--   
--   <ul>
--   <li><i><tt>%w</tt></i> total whole weeks</li>
--   <li><i><tt>%d</tt></i> total whole days</li>
--   <li><i><tt>%D</tt></i> whole days of week</li>
--   <li><i><tt>%h</tt></i> total whole hours</li>
--   <li><i><tt>%H</tt></i> whole hours of day</li>
--   <li><i><tt>%m</tt></i> total whole minutes</li>
--   <li><i><tt>%M</tt></i> whole minutes of hour</li>
--   <li><i><tt>%s</tt></i> total whole seconds</li>
--   <li><i><tt>%Es</tt></i> total seconds, with decimal point and up to
--   &lt;width&gt; (default 12) decimal places, without trailing zeros. For
--   a whole number of seconds, <tt>%Es</tt> omits the decimal point unless
--   padding is specified.</li>
--   <li><i><tt>%0Es</tt></i> total seconds, with decimal point and
--   &lt;width&gt; (default 12) decimal places.</li>
--   <li><i><tt>%S</tt></i> whole seconds of minute</li>
--   <li><i><tt>%ES</tt></i> seconds of minute, with decimal point and up
--   to &lt;width&gt; (default 12) decimal places, without trailing zeros.
--   For a whole number of seconds, <tt>%ES</tt> omits the decimal point
--   unless padding is specified.</li>
--   <li><i><tt>%0ES</tt></i> seconds of minute as two digits, with decimal
--   point and &lt;width&gt; (default 12) decimal places.</li>
--   </ul>
--   
--   <h3><tt>CalendarDiffDays</tt></h3>
--   
--   For <tt>CalendarDiffDays</tt> (and <tt>CalendarDiffTime</tt>):
--   
--   <ul>
--   <li><i><tt>%y</tt></i> total years</li>
--   <li><i><tt>%b</tt></i> total months</li>
--   <li><i><tt>%B</tt></i> months of year</li>
--   <li><i><tt>%w</tt></i> total weeks, not including months</li>
--   <li><i><tt>%d</tt></i> total days, not including months</li>
--   <li><i><tt>%D</tt></i> days of week</li>
--   </ul>
--   
--   <h3><tt>CalendarDiffTime</tt></h3>
--   
--   For <tt>CalendarDiffTime</tt>:
--   
--   <ul>
--   <li><i><tt>%h</tt></i> total hours, not including months</li>
--   <li><i><tt>%H</tt></i> hours of day</li>
--   <li><i><tt>%m</tt></i> total minutes, not including months</li>
--   <li><i><tt>%M</tt></i> minutes of hour</li>
--   <li><i><tt>%s</tt></i> total whole seconds, not including months</li>
--   <li><i><tt>%Es</tt></i> total seconds, not including months, with
--   decimal point and up to &lt;width&gt; (default 12) decimal places,
--   without trailing zeros. For a whole number of seconds, <tt>%Es</tt>
--   omits the decimal point unless padding is specified.</li>
--   <li><i><tt>%0Es</tt></i> total seconds, not including months, with
--   decimal point and &lt;width&gt; (default 12) decimal places.</li>
--   <li><i><tt>%S</tt></i> whole seconds of minute</li>
--   <li><i><tt>%ES</tt></i> seconds of minute, with decimal point and up
--   to &lt;width&gt; (default 12) decimal places, without trailing zeros.
--   For a whole number of seconds, <tt>%ES</tt> omits the decimal point
--   unless padding is specified.</li>
--   <li><i><tt>%0ES</tt></i> seconds of minute as two digits, with decimal
--   point and &lt;width&gt; (default 12) decimal places.</li>
--   </ul>
formatTime :: FormatTime t => TimeLocale -> String -> t -> String

-- | Convert from proleptic Gregorian calendar. Invalid values will be
--   clipped to the correct range, month first, then day.
fromGregorian :: Year -> MonthOfYear -> DayOfMonth -> Day
calendarDay :: CalendarDiffDays
calendarWeek :: CalendarDiffDays
calendarMonth :: CalendarDiffDays
calendarYear :: CalendarDiffDays

-- | Scale by a factor. Note that <tt>scaleCalendarDiffDays (-1)</tt> will
--   not perfectly invert a duration, due to variable month lengths.
scaleCalendarDiffDays :: Integer -> CalendarDiffDays -> CalendarDiffDays
addDays :: Integer -> Day -> Day
diffDays :: Day -> Day -> Integer

-- | A list of all the days in this period.
periodAllDays :: DayPeriod p => p -> [Day]

-- | The number of days in this period.
periodLength :: DayPeriod p => p -> Int

-- | Get the period this day is in, with the 1-based day number within the
--   period.
--   
--   <pre>
--   periodFromDay (periodFirstDay p) = (p,1)
--   </pre>
periodFromDay :: DayPeriod p => Day -> (p, Int)

-- | Inverse of <a>periodFromDay</a>.
periodToDay :: DayPeriod p => p -> Int -> Day

-- | Validating inverse of <a>periodFromDay</a>.
periodToDayValid :: DayPeriod p => p -> Int -> Maybe Day

-- | Is this year a leap year according to the proleptic Gregorian
--   calendar?
isLeapYear :: Year -> Bool

-- | Convert to proleptic Gregorian calendar.
toGregorian :: Day -> (Year, MonthOfYear, DayOfMonth)

-- | Convert from proleptic Gregorian calendar. Invalid values will return
--   Nothing
fromGregorianValid :: Year -> MonthOfYear -> DayOfMonth -> Maybe Day

-- | Show in ISO 8601 format (yyyy-mm-dd)
showGregorian :: Day -> String

-- | The number of days in a given month according to the proleptic
--   Gregorian calendar.
gregorianMonthLength :: Year -> MonthOfYear -> DayOfMonth

-- | Add months, with days past the last day of the month clipped to the
--   last day. For instance, 2005-01-30 + 1 month = 2005-02-28.
addGregorianMonthsClip :: Integer -> Day -> Day

-- | Add months, with days past the last day of the month rolling over to
--   the next month. For instance, 2005-01-30 + 1 month = 2005-03-02.
addGregorianMonthsRollOver :: Integer -> Day -> Day

-- | Add years, matching month and day, with Feb 29th clipped to Feb 28th
--   if necessary. For instance, 2004-02-29 + 2 years = 2006-02-28.
addGregorianYearsClip :: Integer -> Day -> Day

-- | Add years, matching month and day, with Feb 29th rolled over to Mar
--   1st if necessary. For instance, 2004-02-29 + 2 years = 2006-03-01.
addGregorianYearsRollOver :: Integer -> Day -> Day

-- | Add months (clipped to last day), then add days
addGregorianDurationClip :: CalendarDiffDays -> Day -> Day

-- | Add months (rolling over to next month), then add days
addGregorianDurationRollOver :: CalendarDiffDays -> Day -> Day

-- | Calendrical difference, with as many whole months as possible
diffGregorianDurationClip :: Day -> Day -> CalendarDiffDays

-- | Calendrical difference, with as many whole months as possible. Same as
--   <a>diffGregorianDurationClip</a> for positive durations.
diffGregorianDurationRollOver :: Day -> Day -> CalendarDiffDays
dayOfWeek :: Day -> DayOfWeek

-- | <tt>dayOfWeekDiff a b = a - b</tt> in range 0 to 6. The number of days
--   from b to the next a.
dayOfWeekDiff :: DayOfWeek -> DayOfWeek -> Int

-- | The first day-of-week on or after some day
firstDayOfWeekOnAfter :: DayOfWeek -> Day -> Day

-- | Returns a week containing the given <a>Day</a> where the first day is
--   the <a>DayOfWeek</a> specified.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; weekAllDays Sunday (YearMonthDay 2022 02 21)
--   [YearMonthDay 2022 2 20 .. YearMonthDay 2022 2 26]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; weekAllDays Monday (YearMonthDay 2022 02 21)
--   [YearMonthDay 2022 2 21 .. YearMonthDay 2022 2 27]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; weekAllDays Tuesday (YearMonthDay 2022 02 21)
--   [YearMonthDay 2022 2 15 .. YearMonthDay 2022 2 21]
--   </pre>
weekAllDays :: DayOfWeek -> Day -> [Day]

-- | Returns the first day of a week containing the given <a>Day</a>.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; weekFirstDay Sunday (YearMonthDay 2022 02 21)
--   YearMonthDay 2022 2 20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; weekFirstDay Monday (YearMonthDay 2022 02 21)
--   YearMonthDay 2022 2 21
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; weekFirstDay Tuesday (YearMonthDay 2022 02 21)
--   YearMonthDay 2022 2 15
--   </pre>
weekFirstDay :: DayOfWeek -> Day -> Day

-- | Returns the last day of a week containing the given <a>Day</a>.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; weekLastDay Sunday (YearMonthDay 2022 02 21)
--   YearMonthDay 2022 2 26
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; weekLastDay Monday (YearMonthDay 2022 02 21)
--   YearMonthDay 2022 2 27
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; weekLastDay Tuesday (YearMonthDay 2022 02 21)
--   YearMonthDay 2022 2 21
--   </pre>
weekLastDay :: DayOfWeek -> Day -> Day

-- | Create a <a>DiffTime</a> which represents an integral number of
--   seconds.
secondsToDiffTime :: Integer -> DiffTime

-- | Create a <a>DiffTime</a> from a number of picoseconds.
picosecondsToDiffTime :: Integer -> DiffTime

-- | Get the number of picoseconds in a <a>DiffTime</a>.
diffTimeToPicoseconds :: DiffTime -> Integer

-- | Create a <a>NominalDiffTime</a> from a number of seconds.
secondsToNominalDiffTime :: Pico -> NominalDiffTime

-- | Get the seconds in a <a>NominalDiffTime</a>.
nominalDiffTimeToSeconds :: NominalDiffTime -> Pico

-- | One day in <a>NominalDiffTime</a>.
nominalDay :: NominalDiffTime

-- | The resolution of <a>getSystemTime</a>, <tt>getCurrentTime</tt>,
--   <tt>getPOSIXTime</tt>. On UNIX systems this uses
--   <tt>clock_getres</tt>, which may be <a>wrong on WSL2</a>.
getTime_resolution :: DiffTime

-- | addUTCTime a b = a + b
addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime

-- | diffUTCTime a b = a - b
diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
calendarTimeDays :: CalendarDiffDays -> CalendarDiffTime
calendarTimeTime :: NominalDiffTime -> CalendarDiffTime

-- | Scale by a factor. Note that <tt>scaleCalendarDiffTime (-1)</tt> will
--   not perfectly invert a duration, due to variable month lengths.
scaleCalendarDiffTime :: Integer -> CalendarDiffTime -> CalendarDiffTime

-- | Create a nameless non-summer timezone for this number of minutes.
minutesToTimeZone :: Int -> TimeZone

-- | Create a nameless non-summer timezone for this number of hours.
hoursToTimeZone :: Int -> TimeZone

-- | Text representing the offset of this timezone, such as "-0800" or
--   "+0400" (like <tt>%z</tt> in formatTime), with arbitrary padding.
timeZoneOffsetString' :: Maybe Char -> TimeZone -> String

-- | Text representing the offset of this timezone, such as "-0800" or
--   "+0400" (like <tt>%z</tt> in formatTime).
timeZoneOffsetString :: TimeZone -> String

-- | The UTC time zone.
utc :: TimeZone

-- | Hour zero
midnight :: TimeOfDay

-- | Hour twelve
midday :: TimeOfDay
makeTimeOfDayValid :: Int -> Int -> Pico -> Maybe TimeOfDay

-- | Convert a period of time into a count of days and a time of day since
--   midnight. The time of day will never have a leap second.
timeToDaysAndTimeOfDay :: NominalDiffTime -> (Integer, TimeOfDay)

-- | Convert a count of days and a time of day since midnight into a period
--   of time.
daysAndTimeOfDayToTime :: Integer -> TimeOfDay -> NominalDiffTime

-- | Convert a time of day in UTC to a time of day in some timezone,
--   together with a day adjustment.
utcToLocalTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)

-- | Convert a time of day in some timezone to a time of day in UTC,
--   together with a day adjustment.
localToUTCTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)

-- | Get the time of day given a time since midnight. Time more than 24h
--   will be converted to leap-seconds.
timeToTimeOfDay :: DiffTime -> TimeOfDay

-- | Same as <a>timeToTimeOfDay</a>.
pastMidnight :: DiffTime -> TimeOfDay

-- | Get the time since midnight for a given time of day.
timeOfDayToTime :: TimeOfDay -> DiffTime

-- | Same as <a>timeOfDayToTime</a>.
sinceMidnight :: TimeOfDay -> DiffTime

-- | Get the time of day given the fraction of a day since midnight.
dayFractionToTimeOfDay :: Rational -> TimeOfDay

-- | Get the fraction of a day since midnight given a time of day.
timeOfDayToDayFraction :: TimeOfDay -> Rational

-- | addLocalTime a b = a + b
addLocalTime :: NominalDiffTime -> LocalTime -> LocalTime

-- | diffLocalTime a b = a - b
diffLocalTime :: LocalTime -> LocalTime -> NominalDiffTime

-- | Get the local time of a UTC time in a time zone.
utcToLocalTime :: TimeZone -> UTCTime -> LocalTime

-- | Get the UTC time of a local time in a time zone.
localTimeToUTC :: TimeZone -> LocalTime -> UTCTime

-- | Get the local time of a UT1 time on a particular meridian (in degrees,
--   positive is East).
ut1ToLocalTime :: Rational -> UniversalTime -> LocalTime

-- | Get the UT1 time of a local time on a particular meridian (in degrees,
--   positive is East).
localTimeToUT1 :: Rational -> LocalTime -> UniversalTime

-- | Locale representing American usage.
--   
--   <a>knownTimeZones</a> contains only the ten time-zones mentioned in
--   RFC 822 sec. 5: "UT", "GMT", "EST", "EDT", "CST", "CDT", "MST", "MDT",
--   "PST", "PDT". Note that the parsing functions will regardless parse
--   "UTC", single-letter military time-zones, and +HHMM format.
defaultTimeLocale :: TimeLocale

-- | Construct format string according to <a>ISO-8601</a>.
--   
--   The <tt>Maybe String</tt> argument allows to supply an optional time
--   specification. E.g.:
--   
--   <pre>
--   <a>iso8601DateFormat</a> Nothing            == "%Y-%m-%d"           -- i.e. <tt><i>YYYY-MM-DD</i></tt>
--   <a>iso8601DateFormat</a> (Just "%H:%M:%S")  == "%Y-%m-%dT%H:%M:%S"  -- i.e. <tt><i>YYYY-MM-DD</i>T<i>HH:MM:SS</i></tt>
--   </pre>
iso8601DateFormat :: Maybe String -> String

-- | Format string according to <a>RFC822</a>.
rfc822DateFormat :: String
utcToZonedTime :: TimeZone -> UTCTime -> ZonedTime
zonedTimeToUTC :: ZonedTime -> UTCTime

-- | Parses a time value given a format string. Missing information will be
--   derived from 1970-01-01 00:00 UTC (which was a Thursday). Supports the
--   same %-codes as <tt>formatTime</tt>, including <tt>%-</tt>,
--   <tt>%_</tt> and <tt>%0</tt> modifiers, however padding widths are not
--   supported. Case is not significant in the input string. Some
--   variations in the input are accepted:
--   
--   <ul>
--   <li><i><tt>%z</tt> <tt>%Ez</tt></i> accepts any of <tt>±HHMM</tt> or
--   <tt>±HH:MM</tt>.</li>
--   <li><i><tt>%Z</tt> <tt>%EZ</tt></i> accepts any string of letters, or
--   any of the formats accepted by <tt>%z</tt>.</li>
--   <li><i><tt>%0Y</tt></i> accepts exactly four digits.</li>
--   <li><i><tt>%0G</tt></i> accepts exactly four digits.</li>
--   <li><i><tt>%0C</tt></i> accepts exactly two digits.</li>
--   <li><i><tt>%0f</tt></i> accepts exactly two digits.</li>
--   </ul>
--   
--   For example, to parse a date in YYYY-MM-DD format, while allowing the
--   month and date to have optional leading zeros (notice the <tt>-</tt>
--   modifier used for <tt>%m</tt> and <tt>%d</tt>):
--   
--   <pre>
--   Prelude Data.Time&gt; parseTimeM True defaultTimeLocale "%Y-%-m-%-d" "2010-3-04" :: Maybe Day
--   Just 2010-03-04
--   </pre>
parseTimeM :: (MonadFail m, ParseTime t) => Bool -> TimeLocale -> String -> String -> m t

-- | Parses a time value given a list of pairs of format and input.
--   Resulting value is constructed from all provided specifiers.
parseTimeMultipleM :: (MonadFail m, ParseTime t) => Bool -> TimeLocale -> [(String, String)] -> m t

-- | Parse a time value given a format string. Fails if the input could not
--   be parsed using the given format. See <a>parseTimeM</a> for details.
parseTimeOrError :: ParseTime t => Bool -> TimeLocale -> String -> String -> t

-- | Parse a time value given a format string. See <a>parseTimeM</a> for
--   details.
readSTime :: ParseTime t => Bool -> TimeLocale -> String -> ReadS t

-- | Parse a time value given a format string. See <a>parseTimeM</a> for
--   details.
readPTime :: ParseTime t => Bool -> TimeLocale -> String -> ReadP t
getCurrentTime :: MonadIO m => m UTCTime
getTimeZone :: MonadIO m => UTCTime -> m TimeZone
getCurrentTimeZone :: MonadIO m => m TimeZone
getZonedTime :: MonadIO m => m ZonedTime
utcToLocalZonedTime :: MonadIO m => UTCTime -> m ZonedTime


-- | Generic <tt>Vector</tt> interface. Import as:
--   
--   <pre>
--   import qualified RIO.Vector as V
--   </pre>
--   
--   This module does not export any partial or unsafe functions. For
--   those, see <a>RIO.Vector.Partial</a> and <a>RIO.Vector.Unsafe</a>
module RIO.Vector
class MVector Mutable v a => Vector (v :: Type -> Type) a
length :: Vector v a => v a -> Int
null :: Vector v a => v a -> Bool
(!?) :: Vector v a => v a -> Int -> Maybe a
slice :: (HasCallStack, Vector v a) => Int -> Int -> v a -> v a
take :: Vector v a => Int -> v a -> v a
drop :: Vector v a => Int -> v a -> v a
splitAt :: Vector v a => Int -> v a -> (v a, v a)
empty :: Vector v a => v a
singleton :: Vector v a => a -> v a
replicate :: Vector v a => Int -> a -> v a
generate :: Vector v a => Int -> (Int -> a) -> v a
iterateN :: Vector v a => Int -> (a -> a) -> a -> v a
replicateM :: (Monad m, Vector v a) => Int -> m a -> m (v a)
generateM :: (Monad m, Vector v a) => Int -> (Int -> m a) -> m (v a)
iterateNM :: (Monad m, Vector v a) => Int -> (a -> m a) -> a -> m (v a)
create :: Vector v a => (forall s. () => ST s (Mutable v s a)) -> v a
createT :: (Traversable f, Vector v a) => (forall s. () => ST s (f (Mutable v s a))) -> f (v a)
unfoldr :: Vector v a => (b -> Maybe (a, b)) -> b -> v a
unfoldrN :: Vector v a => Int -> (b -> Maybe (a, b)) -> b -> v a
unfoldrM :: (Monad m, Vector v a) => (b -> m (Maybe (a, b))) -> b -> m (v a)
unfoldrNM :: (Monad m, Vector v a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (v a)
constructN :: Vector v a => Int -> (v a -> a) -> v a
constructrN :: Vector v a => Int -> (v a -> a) -> v a
enumFromN :: (Vector v a, Num a) => a -> Int -> v a
enumFromStepN :: (Vector v a, Num a) => a -> a -> Int -> v a
enumFromTo :: (Vector v a, Enum a) => a -> a -> v a
enumFromThenTo :: (Vector v a, Enum a) => a -> a -> a -> v a
cons :: Vector v a => a -> v a -> v a
snoc :: Vector v a => v a -> a -> v a
(++) :: Vector v a => v a -> v a -> v a
concat :: Vector v a => [v a] -> v a
concatNE :: Vector v a => NonEmpty (v a) -> v a
force :: Vector v a => v a -> v a
reverse :: Vector v a => v a -> v a
modify :: Vector v a => (forall s. () => Mutable v s a -> ST s ()) -> v a -> v a
indexed :: (Vector v a, Vector v (Int, a)) => v a -> v (Int, a)
map :: (Vector v a, Vector v b) => (a -> b) -> v a -> v b
imap :: (Vector v a, Vector v b) => (Int -> a -> b) -> v a -> v b
concatMap :: (Vector v a, Vector v b) => (a -> v b) -> v a -> v b
mapM :: (Monad m, Vector v a, Vector v b) => (a -> m b) -> v a -> m (v b)
imapM :: (Monad m, Vector v a, Vector v b) => (Int -> a -> m b) -> v a -> m (v b)
mapM_ :: (Monad m, Vector v a) => (a -> m b) -> v a -> m ()
imapM_ :: (Monad m, Vector v a) => (Int -> a -> m b) -> v a -> m ()
forM :: (Monad m, Vector v a, Vector v b) => v a -> (a -> m b) -> m (v b)
forM_ :: (Monad m, Vector v a) => v a -> (a -> m b) -> m ()
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> v a -> v b -> v c
zipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> v a -> v b -> v c -> v d
zipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (a -> b -> c -> d -> e) -> v a -> v b -> v c -> v d -> v e
zipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (a -> b -> c -> d -> e -> f) -> v a -> v b -> v c -> v d -> v e -> v f
zipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (a -> b -> c -> d -> e -> f -> g) -> v a -> v b -> v c -> v d -> v e -> v f -> v g
izipWith :: (Vector v a, Vector v b, Vector v c) => (Int -> a -> b -> c) -> v a -> v b -> v c
izipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (Int -> a -> b -> c -> d) -> v a -> v b -> v c -> v d
izipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (Int -> a -> b -> c -> d -> e) -> v a -> v b -> v c -> v d -> v e
izipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (Int -> a -> b -> c -> d -> e -> f) -> v a -> v b -> v c -> v d -> v e -> v f
izipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> v a -> v b -> v c -> v d -> v e -> v f -> v g
zip :: (Vector v a, Vector v b, Vector v (a, b)) => v a -> v b -> v (a, b)
zip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => v a -> v b -> v c -> v (a, b, c)
zip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => v a -> v b -> v c -> v d -> v (a, b, c, d)
zip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => v a -> v b -> v c -> v d -> v e -> v (a, b, c, d, e)
zip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => v a -> v b -> v c -> v d -> v e -> v f -> v (a, b, c, d, e, f)
zipWithM :: (Monad m, Vector v a, Vector v b, Vector v c) => (a -> b -> m c) -> v a -> v b -> m (v c)
izipWithM :: (Monad m, Vector v a, Vector v b, Vector v c) => (Int -> a -> b -> m c) -> v a -> v b -> m (v c)
zipWithM_ :: (Monad m, Vector v a, Vector v b) => (a -> b -> m c) -> v a -> v b -> m ()
izipWithM_ :: (Monad m, Vector v a, Vector v b) => (Int -> a -> b -> m c) -> v a -> v b -> m ()
unzip :: (Vector v a, Vector v b, Vector v (a, b)) => v (a, b) -> (v a, v b)
unzip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => v (a, b, c) -> (v a, v b, v c)
unzip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => v (a, b, c, d) -> (v a, v b, v c, v d)
unzip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => v (a, b, c, d, e) -> (v a, v b, v c, v d, v e)
unzip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => v (a, b, c, d, e, f) -> (v a, v b, v c, v d, v e, v f)
filter :: Vector v a => (a -> Bool) -> v a -> v a
ifilter :: Vector v a => (Int -> a -> Bool) -> v a -> v a
uniq :: (Vector v a, Eq a) => v a -> v a
mapMaybe :: (Vector v a, Vector v b) => (a -> Maybe b) -> v a -> v b
imapMaybe :: (Vector v a, Vector v b) => (Int -> a -> Maybe b) -> v a -> v b
filterM :: (Monad m, Vector v a) => (a -> m Bool) -> v a -> m (v a)
takeWhile :: Vector v a => (a -> Bool) -> v a -> v a
dropWhile :: Vector v a => (a -> Bool) -> v a -> v a
partition :: Vector v a => (a -> Bool) -> v a -> (v a, v a)
unstablePartition :: Vector v a => (a -> Bool) -> v a -> (v a, v a)
span :: Vector v a => (a -> Bool) -> v a -> (v a, v a)
break :: Vector v a => (a -> Bool) -> v a -> (v a, v a)
elem :: (Vector v a, Eq a) => a -> v a -> Bool
notElem :: (Vector v a, Eq a) => a -> v a -> Bool
find :: Vector v a => (a -> Bool) -> v a -> Maybe a
findIndex :: Vector v a => (a -> Bool) -> v a -> Maybe Int
findIndices :: (Vector v a, Vector v Int) => (a -> Bool) -> v a -> v Int
elemIndex :: (Vector v a, Eq a) => a -> v a -> Maybe Int
elemIndices :: (Vector v a, Vector v Int, Eq a) => a -> v a -> v Int
foldl :: Vector v b => (a -> b -> a) -> a -> v b -> a
foldl' :: Vector v b => (a -> b -> a) -> a -> v b -> a
foldr :: Vector v a => (a -> b -> b) -> b -> v a -> b
foldr' :: Vector v a => (a -> b -> b) -> b -> v a -> b
ifoldl :: Vector v b => (a -> Int -> b -> a) -> a -> v b -> a
ifoldl' :: Vector v b => (a -> Int -> b -> a) -> a -> v b -> a
ifoldr :: Vector v a => (Int -> a -> b -> b) -> b -> v a -> b
ifoldr' :: Vector v a => (Int -> a -> b -> b) -> b -> v a -> b
all :: Vector v a => (a -> Bool) -> v a -> Bool
any :: Vector v a => (a -> Bool) -> v a -> Bool
and :: Vector v Bool => v Bool -> Bool
or :: Vector v Bool => v Bool -> Bool
sum :: (Vector v a, Num a) => v a -> a
product :: (Vector v a, Num a) => v a -> a
foldM :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m a
ifoldM :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m a
foldM' :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m a
ifoldM' :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m a
foldM_ :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m ()
ifoldM_ :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m ()
foldM'_ :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m ()
ifoldM'_ :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m ()
sequence :: (Monad m, Vector v a, Vector v (m a)) => v (m a) -> m (v a)
sequence_ :: (Monad m, Vector v (m a)) => v (m a) -> m ()
prescanl :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
prescanl' :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
postscanl :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
postscanl' :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
scanl :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
scanl' :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a
iscanl :: (Vector v a, Vector v b) => (Int -> a -> b -> a) -> a -> v b -> v a
iscanl' :: (Vector v a, Vector v b) => (Int -> a -> b -> a) -> a -> v b -> v a
prescanr :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
prescanr' :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
postscanr :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
postscanr' :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
scanr :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
scanr' :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b
iscanr :: (Vector v a, Vector v b) => (Int -> a -> b -> b) -> b -> v a -> v b
iscanr' :: (Vector v a, Vector v b) => (Int -> a -> b -> b) -> b -> v a -> v b
toList :: Vector v a => v a -> [a]
fromList :: Vector v a => [a] -> v a
fromListN :: Vector v a => Int -> [a] -> v a
convert :: (Vector v a, Vector w a) => v a -> w a
freeze :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m (v a)
thaw :: (PrimMonad m, Vector v a) => v a -> m (Mutable v (PrimState m) a)
copy :: (HasCallStack, PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> v a -> m ()
stream :: Vector v a => v a -> Bundle v a
unstream :: Vector v a => Bundle v a -> v a
streamR :: forall v a (u :: Type -> Type). Vector v a => v a -> Bundle u a
unstreamR :: Vector v a => Bundle v a -> v a
new :: Vector v a => New v a -> v a
clone :: Vector v a => v a -> New v a
eq :: (Vector v a, Eq a) => v a -> v a -> Bool
cmp :: (Vector v a, Ord a) => v a -> v a -> Ordering
eqBy :: (Vector v a, Vector v b) => (a -> b -> Bool) -> v a -> v b -> Bool
cmpBy :: (Vector v a, Vector v b) => (a -> b -> Ordering) -> v a -> v b -> Ordering
showsPrec :: (Vector v a, Show a) => Int -> v a -> ShowS
readPrec :: (Vector v a, Read a) => ReadPrec (v a)
liftShowsPrec :: Vector v a => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> v a -> ShowS
liftReadsPrec :: Vector v a => (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (v a)
gfoldl :: (Vector v a, Data a) => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. () => g -> c g) -> v a -> c (v a)
dataCast :: (Vector v a, Data a, Typeable v, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c (v a))
mkType :: String -> DataType


-- | Boxed <tt>Vector</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Boxed as VB
--   </pre>
--   
--   This module does not export any partial or unsafe functions. For
--   those, see <a>RIO.Vector.Boxed.Partial</a> and
--   <a>RIO.Vector.Boxed.Unsafe</a>
module RIO.Vector.Boxed
data () => Vector a
data () => MVector s a
length :: Vector a -> Int
null :: Vector a -> Bool
(!?) :: Vector a -> Int -> Maybe a
slice :: Int -> Int -> Vector a -> Vector a
take :: Int -> Vector a -> Vector a
drop :: Int -> Vector a -> Vector a
splitAt :: Int -> Vector a -> (Vector a, Vector a)
empty :: Vector a
singleton :: a -> Vector a
replicate :: Int -> a -> Vector a
generate :: Int -> (Int -> a) -> Vector a
iterateN :: Int -> (a -> a) -> a -> Vector a
replicateM :: Monad m => Int -> m a -> m (Vector a)
generateM :: Monad m => Int -> (Int -> m a) -> m (Vector a)
iterateNM :: Monad m => Int -> (a -> m a) -> a -> m (Vector a)
create :: (forall s. () => ST s (MVector s a)) -> Vector a
createT :: Traversable f => (forall s. () => ST s (f (MVector s a))) -> f (Vector a)
unfoldr :: (b -> Maybe (a, b)) -> b -> Vector a
unfoldrN :: Int -> (b -> Maybe (a, b)) -> b -> Vector a
unfoldrM :: Monad m => (b -> m (Maybe (a, b))) -> b -> m (Vector a)
unfoldrNM :: Monad m => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)
constructN :: Int -> (Vector a -> a) -> Vector a
constructrN :: Int -> (Vector a -> a) -> Vector a
enumFromN :: Num a => a -> Int -> Vector a
enumFromStepN :: Num a => a -> a -> Int -> Vector a
enumFromTo :: Enum a => a -> a -> Vector a
enumFromThenTo :: Enum a => a -> a -> a -> Vector a
cons :: a -> Vector a -> Vector a
snoc :: Vector a -> a -> Vector a
(++) :: Vector a -> Vector a -> Vector a
concat :: [Vector a] -> Vector a
force :: Vector a -> Vector a
reverse :: Vector a -> Vector a
modify :: (forall s. () => MVector s a -> ST s ()) -> Vector a -> Vector a
indexed :: Vector a -> Vector (Int, a)
map :: (a -> b) -> Vector a -> Vector b
imap :: (Int -> a -> b) -> Vector a -> Vector b
concatMap :: (a -> Vector b) -> Vector a -> Vector b
mapM :: Monad m => (a -> m b) -> Vector a -> m (Vector b)
imapM :: Monad m => (Int -> a -> m b) -> Vector a -> m (Vector b)
mapM_ :: Monad m => (a -> m b) -> Vector a -> m ()
imapM_ :: Monad m => (Int -> a -> m b) -> Vector a -> m ()
forM :: Monad m => Vector a -> (a -> m b) -> m (Vector b)
forM_ :: Monad m => Vector a -> (a -> m b) -> m ()
zipWith :: (a -> b -> c) -> Vector a -> Vector b -> Vector c
zipWith3 :: (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
izipWith :: (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c
izipWith3 :: (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
zip :: Vector a -> Vector b -> Vector (a, b)
zip3 :: Vector a -> Vector b -> Vector c -> Vector (a, b, c)
zip4 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector (a, b, c, d)
zip5 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector (a, b, c, d, e)
zip6 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector (a, b, c, d, e, f)
zipWithM :: Monad m => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
izipWithM :: Monad m => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
zipWithM_ :: Monad m => (a -> b -> m c) -> Vector a -> Vector b -> m ()
izipWithM_ :: Monad m => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()
unzip :: Vector (a, b) -> (Vector a, Vector b)
unzip3 :: Vector (a, b, c) -> (Vector a, Vector b, Vector c)
unzip4 :: Vector (a, b, c, d) -> (Vector a, Vector b, Vector c, Vector d)
unzip5 :: Vector (a, b, c, d, e) -> (Vector a, Vector b, Vector c, Vector d, Vector e)
unzip6 :: Vector (a, b, c, d, e, f) -> (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)
filter :: (a -> Bool) -> Vector a -> Vector a
ifilter :: (Int -> a -> Bool) -> Vector a -> Vector a
uniq :: Eq a => Vector a -> Vector a
mapMaybe :: (a -> Maybe b) -> Vector a -> Vector b
imapMaybe :: (Int -> a -> Maybe b) -> Vector a -> Vector b
filterM :: Monad m => (a -> m Bool) -> Vector a -> m (Vector a)
takeWhile :: (a -> Bool) -> Vector a -> Vector a
dropWhile :: (a -> Bool) -> Vector a -> Vector a
partition :: (a -> Bool) -> Vector a -> (Vector a, Vector a)
unstablePartition :: (a -> Bool) -> Vector a -> (Vector a, Vector a)
span :: (a -> Bool) -> Vector a -> (Vector a, Vector a)
break :: (a -> Bool) -> Vector a -> (Vector a, Vector a)
elem :: Eq a => a -> Vector a -> Bool
notElem :: Eq a => a -> Vector a -> Bool
find :: (a -> Bool) -> Vector a -> Maybe a
findIndex :: (a -> Bool) -> Vector a -> Maybe Int
findIndices :: (a -> Bool) -> Vector a -> Vector Int
elemIndex :: Eq a => a -> Vector a -> Maybe Int
elemIndices :: Eq a => a -> Vector a -> Vector Int
foldl :: (a -> b -> a) -> a -> Vector b -> a
foldl' :: (a -> b -> a) -> a -> Vector b -> a
foldr :: (a -> b -> b) -> b -> Vector a -> b
foldr' :: (a -> b -> b) -> b -> Vector a -> b
ifoldl :: (a -> Int -> b -> a) -> a -> Vector b -> a
ifoldl' :: (a -> Int -> b -> a) -> a -> Vector b -> a
ifoldr :: (Int -> a -> b -> b) -> b -> Vector a -> b
ifoldr' :: (Int -> a -> b -> b) -> b -> Vector a -> b
all :: (a -> Bool) -> Vector a -> Bool
any :: (a -> Bool) -> Vector a -> Bool
and :: Vector Bool -> Bool
or :: Vector Bool -> Bool
sum :: Num a => Vector a -> a
product :: Num a => Vector a -> a
foldM :: Monad m => (a -> b -> m a) -> a -> Vector b -> m a
ifoldM :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m a
foldM' :: Monad m => (a -> b -> m a) -> a -> Vector b -> m a
ifoldM' :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m a
foldM_ :: Monad m => (a -> b -> m a) -> a -> Vector b -> m ()
ifoldM_ :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m ()
foldM'_ :: Monad m => (a -> b -> m a) -> a -> Vector b -> m ()
ifoldM'_ :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m ()
sequence :: Monad m => Vector (m a) -> m (Vector a)
sequence_ :: Monad m => Vector (m a) -> m ()
prescanl :: (a -> b -> a) -> a -> Vector b -> Vector a
prescanl' :: (a -> b -> a) -> a -> Vector b -> Vector a
postscanl :: (a -> b -> a) -> a -> Vector b -> Vector a
postscanl' :: (a -> b -> a) -> a -> Vector b -> Vector a
scanl :: (a -> b -> a) -> a -> Vector b -> Vector a
scanl' :: (a -> b -> a) -> a -> Vector b -> Vector a
iscanl :: (Int -> a -> b -> a) -> a -> Vector b -> Vector a
iscanl' :: (Int -> a -> b -> a) -> a -> Vector b -> Vector a
prescanr :: (a -> b -> b) -> b -> Vector a -> Vector b
prescanr' :: (a -> b -> b) -> b -> Vector a -> Vector b
postscanr :: (a -> b -> b) -> b -> Vector a -> Vector b
postscanr' :: (a -> b -> b) -> b -> Vector a -> Vector b
scanr :: (a -> b -> b) -> b -> Vector a -> Vector b
scanr' :: (a -> b -> b) -> b -> Vector a -> Vector b
iscanr :: (Int -> a -> b -> b) -> b -> Vector a -> Vector b
iscanr' :: (Int -> a -> b -> b) -> b -> Vector a -> Vector b
toList :: Vector a -> [a]
fromList :: [a] -> Vector a
fromListN :: Int -> [a] -> Vector a
convert :: (Vector v a, Vector w a) => v a -> w a
freeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)
thaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)
copy :: PrimMonad m => MVector (PrimState m) a -> Vector a -> m ()


-- | Boxed <tt>Vector</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Boxed.Partial as VB'
--   </pre>
module RIO.Vector.Boxed.Partial
(!) :: Vector a -> Int -> a
head :: Vector a -> a
last :: Vector a -> a
indexM :: Monad m => Vector a -> Int -> m a
headM :: Monad m => Vector a -> m a
lastM :: Monad m => Vector a -> m a
init :: Vector a -> Vector a
tail :: Vector a -> Vector a
(//) :: Vector a -> [(Int, a)] -> Vector a
update :: Vector a -> Vector (Int, a) -> Vector a
update_ :: Vector a -> Vector Int -> Vector a -> Vector a
accum :: (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a
accumulate :: (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a
accumulate_ :: (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a
backpermute :: Vector a -> Vector Int -> Vector a
foldl1 :: (a -> a -> a) -> Vector a -> a
foldl1' :: (a -> a -> a) -> Vector a -> a
foldr1 :: (a -> a -> a) -> Vector a -> a
foldr1' :: (a -> a -> a) -> Vector a -> a
maximum :: Ord a => Vector a -> a
maximumBy :: (a -> a -> Ordering) -> Vector a -> a
minimum :: Ord a => Vector a -> a
minimumBy :: (a -> a -> Ordering) -> Vector a -> a
minIndex :: Ord a => Vector a -> Int
minIndexBy :: (a -> a -> Ordering) -> Vector a -> Int
maxIndex :: Ord a => Vector a -> Int
maxIndexBy :: (a -> a -> Ordering) -> Vector a -> Int
fold1M :: Monad m => (a -> a -> m a) -> Vector a -> m a
fold1M' :: Monad m => (a -> a -> m a) -> Vector a -> m a
fold1M_ :: Monad m => (a -> a -> m a) -> Vector a -> m ()
fold1M'_ :: Monad m => (a -> a -> m a) -> Vector a -> m ()
scanl1 :: (a -> a -> a) -> Vector a -> Vector a
scanl1' :: (a -> a -> a) -> Vector a -> Vector a
scanr1 :: (a -> a -> a) -> Vector a -> Vector a
scanr1' :: (a -> a -> a) -> Vector a -> Vector a


-- | Boxed <tt>Vector</tt> unsafe functions. These perform no bounds
--   checking, and may cause segmentation faults etc.! Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Boxed.Unsafe as VB'
--   </pre>
module RIO.Vector.Boxed.Unsafe
unsafeIndex :: Vector a -> Int -> a
unsafeHead :: Vector a -> a
unsafeLast :: Vector a -> a
unsafeIndexM :: Monad m => Vector a -> Int -> m a
unsafeHeadM :: Monad m => Vector a -> m a
unsafeLastM :: Monad m => Vector a -> m a
unsafeSlice :: Int -> Int -> Vector a -> Vector a
unsafeInit :: Vector a -> Vector a
unsafeTail :: Vector a -> Vector a
unsafeTake :: Int -> Vector a -> Vector a
unsafeDrop :: Int -> Vector a -> Vector a
unsafeUpd :: Vector a -> [(Int, a)] -> Vector a
unsafeUpdate :: Vector a -> Vector (Int, a) -> Vector a
unsafeUpdate_ :: Vector a -> Vector Int -> Vector a -> Vector a
unsafeAccum :: (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a
unsafeAccumulate :: (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a
unsafeAccumulate_ :: (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a
unsafeBackpermute :: Vector a -> Vector Int -> Vector a
unsafeFreeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)
unsafeThaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)
unsafeCopy :: PrimMonad m => MVector (PrimState m) a -> Vector a -> m ()


-- | Generic <tt>Vector</tt> interface partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Partial as V'
--   </pre>
module RIO.Vector.Partial
(!) :: (HasCallStack, Vector v a) => v a -> Int -> a
head :: Vector v a => v a -> a
last :: Vector v a => v a -> a
indexM :: (HasCallStack, Vector v a, Monad m) => v a -> Int -> m a
headM :: (Vector v a, Monad m) => v a -> m a
lastM :: (Vector v a, Monad m) => v a -> m a
init :: Vector v a => v a -> v a
tail :: Vector v a => v a -> v a
(//) :: Vector v a => v a -> [(Int, a)] -> v a
update :: (Vector v a, Vector v (Int, a)) => v a -> v (Int, a) -> v a
update_ :: (Vector v a, Vector v Int) => v a -> v Int -> v a -> v a
accum :: Vector v a => (a -> b -> a) -> v a -> [(Int, b)] -> v a
accumulate :: (Vector v a, Vector v (Int, b)) => (a -> b -> a) -> v a -> v (Int, b) -> v a
accumulate_ :: (Vector v a, Vector v Int, Vector v b) => (a -> b -> a) -> v a -> v Int -> v b -> v a
backpermute :: (HasCallStack, Vector v a, Vector v Int) => v a -> v Int -> v a
foldl1 :: Vector v a => (a -> a -> a) -> v a -> a
foldl1' :: Vector v a => (a -> a -> a) -> v a -> a
foldr1 :: Vector v a => (a -> a -> a) -> v a -> a
foldr1' :: Vector v a => (a -> a -> a) -> v a -> a
maximum :: (Vector v a, Ord a) => v a -> a
maximumBy :: Vector v a => (a -> a -> Ordering) -> v a -> a
minimum :: (Vector v a, Ord a) => v a -> a
minimumBy :: Vector v a => (a -> a -> Ordering) -> v a -> a
minIndex :: (Vector v a, Ord a) => v a -> Int
minIndexBy :: Vector v a => (a -> a -> Ordering) -> v a -> Int
maxIndex :: (Vector v a, Ord a) => v a -> Int
maxIndexBy :: Vector v a => (a -> a -> Ordering) -> v a -> Int
fold1M :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m a
fold1M' :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m a
fold1M_ :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m ()
fold1M'_ :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m ()
scanl1 :: Vector v a => (a -> a -> a) -> v a -> v a
scanl1' :: Vector v a => (a -> a -> a) -> v a -> v a
scanr1 :: Vector v a => (a -> a -> a) -> v a -> v a
scanr1' :: Vector v a => (a -> a -> a) -> v a -> v a


-- | Storable <tt>Vector</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Storable as VS
--   </pre>
--   
--   This module does not export any partial or unsafe functions. For
--   those, see <a>RIO.Vector.Storable.Partial</a> and
--   <a>RIO.Vector.Storable.Unsafe</a>
module RIO.Vector.Storable
data () => Vector a
data () => MVector s a
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !ForeignPtr a -> MVector s a

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class () => Storable a
length :: Storable a => Vector a -> Int
null :: Storable a => Vector a -> Bool
(!?) :: Storable a => Vector a -> Int -> Maybe a
slice :: Storable a => Int -> Int -> Vector a -> Vector a
take :: Storable a => Int -> Vector a -> Vector a
drop :: Storable a => Int -> Vector a -> Vector a
splitAt :: Storable a => Int -> Vector a -> (Vector a, Vector a)
empty :: Storable a => Vector a
singleton :: Storable a => a -> Vector a
replicate :: Storable a => Int -> a -> Vector a
generate :: Storable a => Int -> (Int -> a) -> Vector a
iterateN :: Storable a => Int -> (a -> a) -> a -> Vector a
replicateM :: (Monad m, Storable a) => Int -> m a -> m (Vector a)
generateM :: (Monad m, Storable a) => Int -> (Int -> m a) -> m (Vector a)
iterateNM :: (Monad m, Storable a) => Int -> (a -> m a) -> a -> m (Vector a)
create :: Storable a => (forall s. () => ST s (MVector s a)) -> Vector a
createT :: (Traversable f, Storable a) => (forall s. () => ST s (f (MVector s a))) -> f (Vector a)
unfoldr :: Storable a => (b -> Maybe (a, b)) -> b -> Vector a
unfoldrN :: Storable a => Int -> (b -> Maybe (a, b)) -> b -> Vector a
unfoldrM :: (Monad m, Storable a) => (b -> m (Maybe (a, b))) -> b -> m (Vector a)
unfoldrNM :: (Monad m, Storable a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)
constructN :: Storable a => Int -> (Vector a -> a) -> Vector a
constructrN :: Storable a => Int -> (Vector a -> a) -> Vector a
enumFromN :: (Storable a, Num a) => a -> Int -> Vector a
enumFromStepN :: (Storable a, Num a) => a -> a -> Int -> Vector a
enumFromTo :: (Storable a, Enum a) => a -> a -> Vector a
enumFromThenTo :: (Storable a, Enum a) => a -> a -> a -> Vector a
cons :: Storable a => a -> Vector a -> Vector a
snoc :: Storable a => Vector a -> a -> Vector a
(++) :: Storable a => Vector a -> Vector a -> Vector a
concat :: Storable a => [Vector a] -> Vector a
force :: Storable a => Vector a -> Vector a
reverse :: Storable a => Vector a -> Vector a
modify :: Storable a => (forall s. () => MVector s a -> ST s ()) -> Vector a -> Vector a
map :: (Storable a, Storable b) => (a -> b) -> Vector a -> Vector b
imap :: (Storable a, Storable b) => (Int -> a -> b) -> Vector a -> Vector b
concatMap :: (Storable a, Storable b) => (a -> Vector b) -> Vector a -> Vector b
mapM :: (Monad m, Storable a, Storable b) => (a -> m b) -> Vector a -> m (Vector b)
mapM_ :: (Monad m, Storable a) => (a -> m b) -> Vector a -> m ()
forM :: (Monad m, Storable a, Storable b) => Vector a -> (a -> m b) -> m (Vector b)
forM_ :: (Monad m, Storable a) => Vector a -> (a -> m b) -> m ()
zipWith :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c
zipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
izipWith :: (Storable a, Storable b, Storable c) => (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c
izipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
zipWithM :: (Monad m, Storable a, Storable b, Storable c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
zipWithM_ :: (Monad m, Storable a, Storable b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()
filter :: Storable a => (a -> Bool) -> Vector a -> Vector a
ifilter :: Storable a => (Int -> a -> Bool) -> Vector a -> Vector a
uniq :: (Storable a, Eq a) => Vector a -> Vector a
mapMaybe :: (Storable a, Storable b) => (a -> Maybe b) -> Vector a -> Vector b
imapMaybe :: (Storable a, Storable b) => (Int -> a -> Maybe b) -> Vector a -> Vector b
filterM :: (Monad m, Storable a) => (a -> m Bool) -> Vector a -> m (Vector a)
takeWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a
dropWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a
partition :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)
unstablePartition :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)
span :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)
break :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)
elem :: (Storable a, Eq a) => a -> Vector a -> Bool
notElem :: (Storable a, Eq a) => a -> Vector a -> Bool
find :: Storable a => (a -> Bool) -> Vector a -> Maybe a
findIndex :: Storable a => (a -> Bool) -> Vector a -> Maybe Int
findIndices :: Storable a => (a -> Bool) -> Vector a -> Vector Int
elemIndex :: (Storable a, Eq a) => a -> Vector a -> Maybe Int
elemIndices :: (Storable a, Eq a) => a -> Vector a -> Vector Int
foldl :: Storable b => (a -> b -> a) -> a -> Vector b -> a
foldl' :: Storable b => (a -> b -> a) -> a -> Vector b -> a
foldr :: Storable a => (a -> b -> b) -> b -> Vector a -> b
foldr' :: Storable a => (a -> b -> b) -> b -> Vector a -> b
ifoldl :: Storable b => (a -> Int -> b -> a) -> a -> Vector b -> a
ifoldl' :: Storable b => (a -> Int -> b -> a) -> a -> Vector b -> a
ifoldr :: Storable a => (Int -> a -> b -> b) -> b -> Vector a -> b
ifoldr' :: Storable a => (Int -> a -> b -> b) -> b -> Vector a -> b
all :: Storable a => (a -> Bool) -> Vector a -> Bool
any :: Storable a => (a -> Bool) -> Vector a -> Bool
and :: Vector Bool -> Bool
or :: Vector Bool -> Bool
sum :: (Storable a, Num a) => Vector a -> a
product :: (Storable a, Num a) => Vector a -> a
foldM :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m a
foldM' :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m a
foldM_ :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m ()
foldM'_ :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m ()
prescanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
prescanl' :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
postscanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
postscanl' :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
scanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
scanl' :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
prescanr :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
prescanr' :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
postscanr :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
postscanr' :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
scanr :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
scanr' :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b
toList :: Storable a => Vector a -> [a]
fromList :: Storable a => [a] -> Vector a
fromListN :: Storable a => Int -> [a] -> Vector a
convert :: (Vector v a, Vector w a) => v a -> w a
freeze :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)
thaw :: (Storable a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)
copy :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()


-- | Storable <tt>Vector</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Storable.Partial as VS'
--   </pre>
module RIO.Vector.Storable.Partial
(!) :: Storable a => Vector a -> Int -> a
head :: Storable a => Vector a -> a
last :: Storable a => Vector a -> a
indexM :: (Storable a, Monad m) => Vector a -> Int -> m a
headM :: (Storable a, Monad m) => Vector a -> m a
lastM :: (Storable a, Monad m) => Vector a -> m a
init :: Storable a => Vector a -> Vector a
tail :: Storable a => Vector a -> Vector a
(//) :: Storable a => Vector a -> [(Int, a)] -> Vector a
update_ :: Storable a => Vector a -> Vector Int -> Vector a -> Vector a
accum :: Storable a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a
accumulate_ :: (Storable a, Storable b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a
backpermute :: Storable a => Vector a -> Vector Int -> Vector a
foldl1 :: Storable a => (a -> a -> a) -> Vector a -> a
foldl1' :: Storable a => (a -> a -> a) -> Vector a -> a
foldr1 :: Storable a => (a -> a -> a) -> Vector a -> a
foldr1' :: Storable a => (a -> a -> a) -> Vector a -> a
maximum :: (Storable a, Ord a) => Vector a -> a
maximumBy :: Storable a => (a -> a -> Ordering) -> Vector a -> a
minimum :: (Storable a, Ord a) => Vector a -> a
minimumBy :: Storable a => (a -> a -> Ordering) -> Vector a -> a
minIndex :: (Storable a, Ord a) => Vector a -> Int
minIndexBy :: Storable a => (a -> a -> Ordering) -> Vector a -> Int
maxIndex :: (Storable a, Ord a) => Vector a -> Int
maxIndexBy :: Storable a => (a -> a -> Ordering) -> Vector a -> Int
fold1M :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m a
fold1M' :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m a
fold1M_ :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m ()
fold1M'_ :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m ()
scanl1 :: Storable a => (a -> a -> a) -> Vector a -> Vector a
scanl1' :: Storable a => (a -> a -> a) -> Vector a -> Vector a
scanr1 :: Storable a => (a -> a -> a) -> Vector a -> Vector a
scanr1' :: Storable a => (a -> a -> a) -> Vector a -> Vector a


-- | Storable <tt>Vector</tt> unsafe functions. These perform no bounds
--   checking, and may cause segmentation faults etc.! Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Storable.Unsafe as VS'
--   </pre>
module RIO.Vector.Storable.Unsafe
unsafeIndex :: Storable a => Vector a -> Int -> a
unsafeHead :: Storable a => Vector a -> a
unsafeLast :: Storable a => Vector a -> a
unsafeIndexM :: (Storable a, Monad m) => Vector a -> Int -> m a
unsafeHeadM :: (Storable a, Monad m) => Vector a -> m a
unsafeLastM :: (Storable a, Monad m) => Vector a -> m a
unsafeSlice :: Storable a => Int -> Int -> Vector a -> Vector a
unsafeInit :: Storable a => Vector a -> Vector a
unsafeTail :: Storable a => Vector a -> Vector a
unsafeTake :: Storable a => Int -> Vector a -> Vector a
unsafeDrop :: Storable a => Int -> Vector a -> Vector a
unsafeUpd :: Storable a => Vector a -> [(Int, a)] -> Vector a
unsafeUpdate_ :: Storable a => Vector a -> Vector Int -> Vector a -> Vector a
unsafeAccum :: Storable a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a
unsafeAccumulate_ :: (Storable a, Storable b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a
unsafeBackpermute :: Storable a => Vector a -> Vector Int -> Vector a
unsafeFreeze :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)
unsafeThaw :: (Storable a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)
unsafeCopy :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()
unsafeFromForeignPtr :: Storable a => ForeignPtr a -> Int -> Int -> Vector a
unsafeFromForeignPtr0 :: ForeignPtr a -> Int -> Vector a
unsafeToForeignPtr :: Vector a -> (ForeignPtr a, Int, Int)
unsafeToForeignPtr0 :: Vector a -> (ForeignPtr a, Int)

-- | Lifted version of <a>unsafeWith</a>
unsafeWith :: (MonadUnliftIO m, Storable a) => Vector a -> (Ptr a -> m b) -> m b


-- | Unboxed <tt>Vector</tt>. Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Unboxed as VU
--   </pre>
--   
--   This module does not export any partial or unsafe functions. For
--   those, see <a>RIO.Vector.Unboxed.Partial</a> and
--   <a>RIO.Vector.Unboxed.Unsafe</a>
module RIO.Vector.Unboxed
data family Vector a
data family MVector s a
class (Vector Vector a, MVector MVector a) => Unbox a
length :: Unbox a => Vector a -> Int
null :: Unbox a => Vector a -> Bool
(!?) :: Unbox a => Vector a -> Int -> Maybe a
slice :: Unbox a => Int -> Int -> Vector a -> Vector a
take :: Unbox a => Int -> Vector a -> Vector a
drop :: Unbox a => Int -> Vector a -> Vector a
splitAt :: Unbox a => Int -> Vector a -> (Vector a, Vector a)
empty :: Unbox a => Vector a
singleton :: Unbox a => a -> Vector a
replicate :: Unbox a => Int -> a -> Vector a
generate :: Unbox a => Int -> (Int -> a) -> Vector a
iterateN :: Unbox a => Int -> (a -> a) -> a -> Vector a
replicateM :: (Monad m, Unbox a) => Int -> m a -> m (Vector a)
generateM :: (Monad m, Unbox a) => Int -> (Int -> m a) -> m (Vector a)
iterateNM :: (Monad m, Unbox a) => Int -> (a -> m a) -> a -> m (Vector a)
create :: Unbox a => (forall s. () => ST s (MVector s a)) -> Vector a
createT :: (Traversable f, Unbox a) => (forall s. () => ST s (f (MVector s a))) -> f (Vector a)
unfoldr :: Unbox a => (b -> Maybe (a, b)) -> b -> Vector a
unfoldrN :: Unbox a => Int -> (b -> Maybe (a, b)) -> b -> Vector a
unfoldrM :: (Monad m, Unbox a) => (b -> m (Maybe (a, b))) -> b -> m (Vector a)
unfoldrNM :: (Monad m, Unbox a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)
constructN :: Unbox a => Int -> (Vector a -> a) -> Vector a
constructrN :: Unbox a => Int -> (Vector a -> a) -> Vector a
enumFromN :: (Unbox a, Num a) => a -> Int -> Vector a
enumFromStepN :: (Unbox a, Num a) => a -> a -> Int -> Vector a
enumFromTo :: (Unbox a, Enum a) => a -> a -> Vector a
enumFromThenTo :: (Unbox a, Enum a) => a -> a -> a -> Vector a
cons :: Unbox a => a -> Vector a -> Vector a
snoc :: Unbox a => Vector a -> a -> Vector a
(++) :: Unbox a => Vector a -> Vector a -> Vector a
concat :: Unbox a => [Vector a] -> Vector a
force :: Unbox a => Vector a -> Vector a
reverse :: Unbox a => Vector a -> Vector a
modify :: Unbox a => (forall s. () => MVector s a -> ST s ()) -> Vector a -> Vector a
indexed :: Unbox a => Vector a -> Vector (Int, a)
map :: (Unbox a, Unbox b) => (a -> b) -> Vector a -> Vector b
imap :: (Unbox a, Unbox b) => (Int -> a -> b) -> Vector a -> Vector b
concatMap :: (Unbox a, Unbox b) => (a -> Vector b) -> Vector a -> Vector b
mapM :: (Monad m, Unbox a, Unbox b) => (a -> m b) -> Vector a -> m (Vector b)
imapM :: (Monad m, Unbox a, Unbox b) => (Int -> a -> m b) -> Vector a -> m (Vector b)
mapM_ :: (Monad m, Unbox a) => (a -> m b) -> Vector a -> m ()
imapM_ :: (Monad m, Unbox a) => (Int -> a -> m b) -> Vector a -> m ()
forM :: (Monad m, Unbox a, Unbox b) => Vector a -> (a -> m b) -> m (Vector b)
forM_ :: (Monad m, Unbox a) => Vector a -> (a -> m b) -> m ()
zipWith :: (Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c
zipWith3 :: (Unbox a, Unbox b, Unbox c, Unbox d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
izipWith :: (Unbox a, Unbox b, Unbox c) => (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c
izipWith3 :: (Unbox a, Unbox b, Unbox c, Unbox d) => (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g
zip :: (Unbox a, Unbox b) => Vector a -> Vector b -> Vector (a, b)
zip3 :: (Unbox a, Unbox b, Unbox c) => Vector a -> Vector b -> Vector c -> Vector (a, b, c)
zip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vector a -> Vector b -> Vector c -> Vector d -> Vector (a, b, c, d)
zip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector (a, b, c, d, e)
zip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector (a, b, c, d, e, f)
zipWithM :: (Monad m, Unbox a, Unbox b, Unbox c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
izipWithM :: (Monad m, Unbox a, Unbox b, Unbox c) => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
zipWithM_ :: (Monad m, Unbox a, Unbox b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()
izipWithM_ :: (Monad m, Unbox a, Unbox b) => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()
unzip :: (Unbox a, Unbox b) => Vector (a, b) -> (Vector a, Vector b)
unzip3 :: (Unbox a, Unbox b, Unbox c) => Vector (a, b, c) -> (Vector a, Vector b, Vector c)
unzip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vector (a, b, c, d) -> (Vector a, Vector b, Vector c, Vector d)
unzip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector (a, b, c, d, e) -> (Vector a, Vector b, Vector c, Vector d, Vector e)
unzip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vector (a, b, c, d, e, f) -> (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)
filter :: Unbox a => (a -> Bool) -> Vector a -> Vector a
ifilter :: Unbox a => (Int -> a -> Bool) -> Vector a -> Vector a
uniq :: (Unbox a, Eq a) => Vector a -> Vector a
mapMaybe :: (Unbox a, Unbox b) => (a -> Maybe b) -> Vector a -> Vector b
imapMaybe :: (Unbox a, Unbox b) => (Int -> a -> Maybe b) -> Vector a -> Vector b
filterM :: (Monad m, Unbox a) => (a -> m Bool) -> Vector a -> m (Vector a)
takeWhile :: Unbox a => (a -> Bool) -> Vector a -> Vector a
dropWhile :: Unbox a => (a -> Bool) -> Vector a -> Vector a
partition :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)
unstablePartition :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)
span :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)
break :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)
elem :: (Unbox a, Eq a) => a -> Vector a -> Bool
notElem :: (Unbox a, Eq a) => a -> Vector a -> Bool
find :: Unbox a => (a -> Bool) -> Vector a -> Maybe a
findIndex :: Unbox a => (a -> Bool) -> Vector a -> Maybe Int
findIndices :: Unbox a => (a -> Bool) -> Vector a -> Vector Int
elemIndex :: (Unbox a, Eq a) => a -> Vector a -> Maybe Int
elemIndices :: (Unbox a, Eq a) => a -> Vector a -> Vector Int
foldl :: Unbox b => (a -> b -> a) -> a -> Vector b -> a
foldl' :: Unbox b => (a -> b -> a) -> a -> Vector b -> a
foldr :: Unbox a => (a -> b -> b) -> b -> Vector a -> b
foldr' :: Unbox a => (a -> b -> b) -> b -> Vector a -> b
ifoldl :: Unbox b => (a -> Int -> b -> a) -> a -> Vector b -> a
ifoldl' :: Unbox b => (a -> Int -> b -> a) -> a -> Vector b -> a
ifoldr :: Unbox a => (Int -> a -> b -> b) -> b -> Vector a -> b
ifoldr' :: Unbox a => (Int -> a -> b -> b) -> b -> Vector a -> b
all :: Unbox a => (a -> Bool) -> Vector a -> Bool
any :: Unbox a => (a -> Bool) -> Vector a -> Bool
and :: Vector Bool -> Bool
or :: Vector Bool -> Bool
sum :: (Unbox a, Num a) => Vector a -> a
product :: (Unbox a, Num a) => Vector a -> a
foldM :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m a
ifoldM :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m a
foldM' :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m a
ifoldM' :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m a
foldM_ :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m ()
ifoldM_ :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m ()
foldM'_ :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m ()
ifoldM'_ :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m ()
prescanl :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
prescanl' :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
postscanl :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
postscanl' :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
scanl :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
scanl' :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a
prescanr :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
prescanr' :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
postscanr :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
postscanr' :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
scanr :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
scanr' :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b
toList :: Unbox a => Vector a -> [a]
fromList :: Unbox a => [a] -> Vector a
fromListN :: Unbox a => Int -> [a] -> Vector a
convert :: (Vector v a, Vector w a) => v a -> w a
freeze :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)
thaw :: (Unbox a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)
copy :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()


-- | Unboxed <tt>Vector</tt> partial functions. Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Unboxed.Partial as VU'
--   </pre>
module RIO.Vector.Unboxed.Partial
(!) :: Unbox a => Vector a -> Int -> a
head :: Unbox a => Vector a -> a
last :: Unbox a => Vector a -> a
indexM :: (Unbox a, Monad m) => Vector a -> Int -> m a
headM :: (Unbox a, Monad m) => Vector a -> m a
lastM :: (Unbox a, Monad m) => Vector a -> m a
init :: Unbox a => Vector a -> Vector a
tail :: Unbox a => Vector a -> Vector a
(//) :: Unbox a => Vector a -> [(Int, a)] -> Vector a
update :: Unbox a => Vector a -> Vector (Int, a) -> Vector a
update_ :: Unbox a => Vector a -> Vector Int -> Vector a -> Vector a
accum :: Unbox a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a
accumulate :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a
accumulate_ :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a
backpermute :: Unbox a => Vector a -> Vector Int -> Vector a
foldl1 :: Unbox a => (a -> a -> a) -> Vector a -> a
foldl1' :: Unbox a => (a -> a -> a) -> Vector a -> a
foldr1 :: Unbox a => (a -> a -> a) -> Vector a -> a
foldr1' :: Unbox a => (a -> a -> a) -> Vector a -> a
maximum :: (Unbox a, Ord a) => Vector a -> a
maximumBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> a
minimum :: (Unbox a, Ord a) => Vector a -> a
minimumBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> a
minIndex :: (Unbox a, Ord a) => Vector a -> Int
minIndexBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> Int
maxIndex :: (Unbox a, Ord a) => Vector a -> Int
maxIndexBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> Int
fold1M :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m a
fold1M' :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m a
fold1M_ :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m ()
fold1M'_ :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m ()
scanl1 :: Unbox a => (a -> a -> a) -> Vector a -> Vector a
scanl1' :: Unbox a => (a -> a -> a) -> Vector a -> Vector a
scanr1 :: Unbox a => (a -> a -> a) -> Vector a -> Vector a
scanr1' :: Unbox a => (a -> a -> a) -> Vector a -> Vector a


-- | Unoxed <tt>Vector</tt> unsafe functions. These perform no bounds
--   checking, and may cause segmentation faults etc.! Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Unoxed.Unsafe as VU'
--   </pre>
module RIO.Vector.Unboxed.Unsafe
unsafeIndex :: Unbox a => Vector a -> Int -> a
unsafeHead :: Unbox a => Vector a -> a
unsafeLast :: Unbox a => Vector a -> a
unsafeIndexM :: (Unbox a, Monad m) => Vector a -> Int -> m a
unsafeHeadM :: (Unbox a, Monad m) => Vector a -> m a
unsafeLastM :: (Unbox a, Monad m) => Vector a -> m a
unsafeSlice :: Unbox a => Int -> Int -> Vector a -> Vector a
unsafeInit :: Unbox a => Vector a -> Vector a
unsafeTail :: Unbox a => Vector a -> Vector a
unsafeTake :: Unbox a => Int -> Vector a -> Vector a
unsafeDrop :: Unbox a => Int -> Vector a -> Vector a
unsafeUpd :: Unbox a => Vector a -> [(Int, a)] -> Vector a
unsafeUpdate :: Unbox a => Vector a -> Vector (Int, a) -> Vector a
unsafeUpdate_ :: Unbox a => Vector a -> Vector Int -> Vector a -> Vector a
unsafeAccum :: Unbox a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a
unsafeAccumulate :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a
unsafeAccumulate_ :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a
unsafeBackpermute :: Unbox a => Vector a -> Vector Int -> Vector a
unsafeFreeze :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)
unsafeThaw :: (Unbox a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)
unsafeCopy :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()


-- | Generic <tt>Vector</tt> interface unsafe functions. These perform no
--   bounds checking, and may cause segmentation faults etc.! Import as:
--   
--   <pre>
--   import qualified RIO.Vector.Unsafe as V'
--   </pre>
module RIO.Vector.Unsafe
class MVector Mutable v a => Vector (v :: Type -> Type) a
basicUnsafeFreeze :: Vector v a => Mutable v s a -> ST s (v a)
basicUnsafeThaw :: Vector v a => v a -> ST s (Mutable v s a)
basicLength :: Vector v a => v a -> Int
basicUnsafeSlice :: Vector v a => Int -> Int -> v a -> v a
basicUnsafeIndexM :: Vector v a => v a -> Int -> Box a
basicUnsafeCopy :: Vector v a => Mutable v s a -> v a -> ST s ()
elemseq :: Vector v a => v a -> a -> b -> b
unsafeIndex :: Vector v a => v a -> Int -> a
unsafeHead :: Vector v a => v a -> a
unsafeLast :: Vector v a => v a -> a
unsafeIndexM :: (Vector v a, Monad m) => v a -> Int -> m a
unsafeHeadM :: (Vector v a, Monad m) => v a -> m a
unsafeLastM :: (Vector v a, Monad m) => v a -> m a
unsafeSlice :: Vector v a => Int -> Int -> v a -> v a
unsafeInit :: Vector v a => v a -> v a
unsafeTail :: Vector v a => v a -> v a
unsafeTake :: Vector v a => Int -> v a -> v a
unsafeDrop :: Vector v a => Int -> v a -> v a
unsafeUpd :: Vector v a => v a -> [(Int, a)] -> v a
unsafeUpdate :: (Vector v a, Vector v (Int, a)) => v a -> v (Int, a) -> v a
unsafeUpdate_ :: (Vector v a, Vector v Int) => v a -> v Int -> v a -> v a
unsafeAccum :: Vector v a => (a -> b -> a) -> v a -> [(Int, b)] -> v a
unsafeAccumulate :: (Vector v a, Vector v (Int, b)) => (a -> b -> a) -> v a -> v (Int, b) -> v a
unsafeAccumulate_ :: (Vector v a, Vector v Int, Vector v b) => (a -> b -> a) -> v a -> v Int -> v b -> v a
unsafeBackpermute :: (Vector v a, Vector v Int) => v a -> v Int -> v a
unsafeFreeze :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m (v a)
unsafeThaw :: (PrimMonad m, Vector v a) => v a -> m (Mutable v (PrimState m) a)
unsafeCopy :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> v a -> m ()


-- | Provides reexports of <tt>MonadWriter</tt> and related helpers.
module RIO.Writer
class (Monoid w, Monad m) => MonadWriter w (m :: Type -> Type) | m -> w

-- | <tt><a>writer</a> (a,w)</tt> embeds a simple writer action.
writer :: MonadWriter w m => (a, w) -> m a

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: MonadWriter w m => w -> m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
listen :: MonadWriter w m => m a -> m (a, w)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
pass :: MonadWriter w m => m (a, w -> w) -> m a

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <tt>liftM</tt> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   </ul>
listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<tt>liftM</tt> (\x -&gt;
--   (x,f)) m)</pre></li>
--   </ul>
censor :: MonadWriter w m => (w -> w) -> m a -> m a

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Writer w a -> (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriter</a> m = <a>snd</a> (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
execWriter :: Writer w a -> w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriter</a> (<a>mapWriter</a> f m) = f (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
newtype () => WriterT w (m :: Type -> Type) a
WriterT :: m (a, w) -> WriterT w (m :: Type -> Type) a
[runWriterT] :: WriterT w (m :: Type -> Type) a -> m (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriterT</a> m = <a>liftM</a> <a>snd</a>
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
execWriterT :: Monad m => WriterT w m a -> m w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>mapWriterT</a> f m) = f
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
