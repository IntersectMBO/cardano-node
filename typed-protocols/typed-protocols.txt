-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for strongly typed protocols
--   
--   A framework for strongly typed protocols
@package typed-protocols
@version 0.3.0.0


-- | This module defines the core of the typed protocol framework.
module Network.TypedProtocol.Core

-- | The protocol type class bundles up all the requirements for a typed
--   protocol.
--   
--   Each protocol consists of four components:
--   
--   <ul>
--   <li>the protocol itself, which is also expected to be the kind of the
--   types of the protocol states. The class is indexed on the protocol
--   itself;</li>
--   <li>the protocol messages;</li>
--   <li>a type level map from the protocol states to agency: in each state
--   either client or server or nobody has the agency.</li>
--   <li>a singleton type for the protocol states (e.g. <a>StateToken</a>
--   type family instance), together with <a>StateTokenI</a>
--   instances.</li>
--   </ul>
--   
--   It is required provide <a>StateToken</a> type family instance as well
--   as <a>StateTokenI</a> instances for all protocol states. These
--   singletons allow one to pattern match on the state, which is useful
--   when defining codecs, or providing informative error messages, however
--   they are not necessary for proving correctness of the protocol. These
--   type families are similar to <a>Sing</a> and <a>SingI</a> in the
--   "singletons" package.
class Protocol ps where {
    
    -- | The messages for this protocol. It is expected to be a GADT that is
    --   indexed by the <tt>from</tt> and <tt>to</tt> protocol states. That is
    --   the protocol state the message transitions from, and the protocol
    --   state it transitions into. These are the edges of the protocol state
    --   transition system.
    data Message ps (st :: ps) (st' :: ps);
    
    -- | Associate an <a>Agency</a> for each state.
    type StateAgency (st :: ps) :: Agency;
    
    -- | A type family for protocol state token, e.g. term level representation
    --   of type level state (also known as singleton).
    --   
    --   This type family is similar to <a>Sing</a> type class in the
    --   "singletons" package, but specific for protocol states.
    type StateToken :: ps -> Type;
}

-- | A type class which hides a state token / singleton inside a class
--   dictionary.
--   
--   This is similar to the <a>SingI</a> instance, but specific to protocol
--   state singletons.
class StateTokenI st
stateToken :: StateTokenI st => StateToken st

-- | Types for client and server peer roles. As protocol can be viewed from
--   either client or server side.
--   
--   Note that technically "client" and "server" are arbitrary labels. The
--   framework is completely symmetric between the two peers.
--   
--   This definition is only used as promoted types and kinds, never as
--   values.
data PeerRole
AsClient :: PeerRole
AsServer :: PeerRole

-- | Singletons for <a>PeerRole</a>. We provide <a>Sing</a> and
--   <a>SingI</a> instances from the "singletons" package.
data SingPeerRole pr
[SingAsClient] :: SingPeerRole AsClient
[SingAsServer] :: SingPeerRole AsServer

-- | A promoted data type which denotes three possible agencies a protocol
--   state might be assigned.
data Agency

-- | The client has agency.
[ClientAgency] :: Agency

-- | The server has agency.
[ServerAgency] :: Agency

-- | Nobody has agency, terminal state.
[NobodyAgency] :: Agency
data SingAgency a
[SingClientAgency] :: SingAgency ClientAgency
[SingServerAgency] :: SingAgency ServerAgency
[SingNobodyAgency] :: SingAgency NobodyAgency

-- | A promoted data type which indicates the effective agency (which is
--   relative to current role). It is computed by <a>Relative</a> type
--   family.
data RelativeAgency
[WeHaveAgency] :: RelativeAgency
[TheyHaveAgency] :: RelativeAgency
[NobodyHasAgency] :: RelativeAgency

-- | Compute effective agency with respect to the peer role, for client
--   role, agency is preserved, while for the server role it is flipped.
type family Relative pr a

-- | Type equality for <a>RelativeAgency</a> which also carries information
--   about agency. It is isomorphic to a product of <a>Agency</a> singleton
--   and <tt>r :~: r'</tt>, where both <tt>r</tt> and <tt>r'</tt> have kind
--   <a>RelativeAgency</a>.
--   
--   This is a proper type with values used by the <tt>Peer</tt>, however
--   they are hidden by using <a>Network.TypedProtocol.Peer.Client</a> and
--   <a>Network.TypedProtocol.Peer.Server</a> APIs.
data ReflRelativeAgency a r r'
[ReflClientAgency] :: ReflRelativeAgency ClientAgency r r
[ReflServerAgency] :: ReflRelativeAgency ServerAgency r r
[ReflNobodyAgency] :: ReflRelativeAgency NobodyAgency r r

-- | Type of the proof that we have the agency.
--   
--   <a>ReflClientAgency</a> has this type only iff `<a>StateAgency</a> st
--   ~ <tt>ClientAgency'</tt> and `pr ~ <tt>AsClient'</tt>.
--   
--   <a>ReflServerAgency</a> has this type only iff `<a>StateAgency</a> st
--   ~ <tt>ServerAgency'</tt> and `pr ~ <tt>AsServer'</tt>
type WeHaveAgencyProof pr st = ReflRelativeAgency (StateAgency st) WeHaveAgency (Relative pr (StateAgency st))

-- | Type of the proof that the remote side has the agency.
--   
--   <a>ReflClientAgency</a> has this type only iff `<a>StateAgency</a> st
--   ~ <tt>ClientAgency'</tt> and `pr ~ <tt>AsServer'</tt>.
--   
--   <a>ReflServerAgency</a> has this type only iff `<a>StateAgency</a> st
--   ~ <tt>ServerAgency'</tt> and `pr ~ <tt>AsClient'</tt>
type TheyHaveAgencyProof pr st = ReflRelativeAgency (StateAgency st) TheyHaveAgency (Relative pr (StateAgency st))

-- | Type of the proof that nobody has agency in this state.
--   
--   Only <a>ReflNobodyAgency</a> can fulfil the proof obligation.
type NobodyHasAgencyProof pr st = ReflRelativeAgency (StateAgency st) NobodyHasAgency (Relative pr (StateAgency st))

-- | A type function to flip the client and server roles.
type family FlipAgency pr

-- | A type class which restricts states to ones that have
--   <a>ClientAgency</a> or <a>ServerAgency</a>, excluding
--   <a>NobodyAgency</a>.
--   
--   One can use <tt>notActive</tt> to eliminate cases for which both
--   <tt><a>IsActiveState</a> st</tt> is in scope and for which we have an
--   evidence that the state is not active (i.e. a singleton). This is
--   useful when writing a <tt>Codec</tt>.
class IsActiveState st (agency :: Agency)
activeAgency :: IsActiveState st agency => ActiveAgency' st agency

-- | A constraint which provides an evidence that the protocol isn't in a
--   terminal state.
type ActiveState st = IsActiveState st (StateAgency st)

-- | This is useful function to eliminate cases where the `ActiveState st`
--   is provided but we are given a state in which neither side has agency
--   (<a>NobodyAgency</a>). For example when writing a codec, we only need
--   to encode / decode messages which are in active states, but to make
--   such functions total, <a>notActiveState</a> needs to be used to
--   eliminate the states in which nobody has agency.
--   
--   A good analogy for this function is <tt><a>absurd</a> :: <tt>Void</tt>
--   -&gt; a</tt>.
notActiveState :: forall ps (st :: ps). StateAgency st ~ NobodyAgency => ActiveState st => StateToken st -> forall a. a

-- | Evidence that the protocol isn't in a terminal state.
type ActiveAgency st = ActiveAgency' st (StateAgency st)

-- | Evidence that one side of the protocol has the agency, and thus that
--   the protocol hasn't yet terminated.
data ActiveAgency' st agency

-- | Evidence that the client has the agency.
[ClientHasAgency] :: StateAgency st ~ ClientAgency => ActiveAgency' st ClientAgency

-- | Evidence that the server has the agency.
[ServerHasAgency] :: StateAgency st ~ ServerAgency => ActiveAgency' st ServerAgency

-- | Promoted data type which indicates if <tt>Peer</tt> is used in
--   pipelined mode or not.
data IsPipelined

-- | Pipelined peer which is using `c :: Type` for collecting responses
--   from a pipelined messages. <a>N</a> indicates depth of pipelining.
[Pipelined] :: N -> Type -> IsPipelined

-- | Non-pipelined peer.
[NonPipelined] :: IsPipelined

-- | Type level count of the number of outstanding pipelined yields for
--   which we have not yet collected a receiver result. Used to ensure that
--   <tt>Collect</tt> is only used when there are outstanding results to
--   collect (e.g. after <tt>YieldPipeliend</tt> was used); and to ensure
--   that the non-pipelined primitives <tt>Yield</tt>, <tt>Await</tt> and
--   <tt>Done</tt> are only used when there are none unsatisfied pipelined
--   requests.
type family Outstanding pl

-- | A type level inductive natural number.
data N
Z :: N
S :: N -> N

-- | A value level inductive natural number, indexed by the corresponding
--   type level natural number <a>N</a>.
--   
--   This is often needed when writing pipelined peers to be able to count
--   the number of outstanding pipelined yields, and show to the type
--   checker that <a>Collect</a> and <a>Done</a> are being used correctly.
data Nat (n :: N)
pattern Succ :: () => m ~ S n => Nat n -> Nat m
pattern Zero :: () => Z ~ n => Nat n
natToInt :: Nat n -> Int
unsafeIntToNat :: Int -> Nat n
instance GHC.Show.Show (Network.TypedProtocol.Core.Nat n)
instance GHC.Show.Show (Network.TypedProtocol.Core.SingPeerRole pr)
instance GHC.Show.Show (Network.TypedProtocol.Core.SingAgency a)
instance forall ps (st :: ps) (agency :: Network.TypedProtocol.Core.Agency). GHC.Show.Show (Network.TypedProtocol.Core.ActiveAgency' st agency)
instance forall ps (st :: ps). ('Network.TypedProtocol.Core.ClientAgency GHC.Types.~ Network.TypedProtocol.Core.StateAgency st) => Network.TypedProtocol.Core.IsActiveState st 'Network.TypedProtocol.Core.ClientAgency
instance forall ps (st :: ps). ('Network.TypedProtocol.Core.ServerAgency GHC.Types.~ Network.TypedProtocol.Core.StateAgency st) => Network.TypedProtocol.Core.IsActiveState st 'Network.TypedProtocol.Core.ServerAgency
instance Data.Singletons.SingI 'Network.TypedProtocol.Core.ClientAgency
instance Data.Singletons.SingI 'Network.TypedProtocol.Core.ServerAgency
instance Data.Singletons.SingI 'Network.TypedProtocol.Core.NobodyAgency
instance Data.Singletons.SingI 'Network.TypedProtocol.Core.AsClient
instance Data.Singletons.SingI 'Network.TypedProtocol.Core.AsServer


-- | Protocol EDSL.
module Network.TypedProtocol.Peer

-- | A description of a peer that engages in a protocol.
--   
--   <b>Note</b>: You should use pattern synonyms exposed in
--   <a>Network.TypedProtocol.Peer.Client</a> and
--   <a>Network.TypedProtocol.Peer.Server</a>, however here we provide
--   in-depth documentation.
--   
--   The protocol describes what messages peers <i>may</i> send or
--   <i>must</i> accept. A particular peer implementation decides what to
--   actually do within the constraints of the protocol.
--   
--   Peers engage in a protocol in either the client or server role. Of
--   course the client role can only interact with the serve role for the
--   same protocol and vice versa.
--   
--   <a>Peer</a> has several type arguments:
--   
--   <ul>
--   <li>the protocol itself;</li>
--   <li>the client/server role;</li>
--   <li>whether the peer is using pipelining or not, if pipelined it holds
--   the depth of pipelining and a type used to collect data from pipelined
--   transitions;</li>
--   <li>the current protocol state;</li>
--   <li>the monad in which the peer operates (e.g. <a>IO</a>);</li>
--   <li>the type of the final result once the peer terminates.</li>
--   </ul>
--   
--   For example:
--   
--   <pre>
--   pingPongClientExample :: Peer PingPong AsClient (Pipelined Z Int) StIdle IO ()
--   pingPongServerExample :: Peer PingPong AsServer NonPipeliend      StIdle IO Int
--   </pre>
--   
--   The actions that a non-pipelining peer can take are:
--   
--   <ul>
--   <li>to perform local monadic effects</li>
--   <li>to terminate with a result (but only in a terminal protocol
--   state)</li>
--   <li>to send a message (but only in a protocol state in which we have
--   agency)</li>
--   <li>to wait to receive a message (but only in a protocol state in
--   which the other peer has agency)</li>
--   </ul>
--   
--   In addition a pipelining peer can:
--   
--   <ul>
--   <li>pipeline a message, which requires upfront declaration at which
--   state we continue at and passing a receiver which will run in
--   parallel. When receiver terminates it pushes the result into the
--   pipelining queue.</li>
--   <li>collect a response from the pipelining queue.</li>
--   </ul>
--   
--   The <a>Yield</a>, <a>Await</a>, <a>Done</a>, <a>YieldPipelined</a>,
--   <a>Collect</a>, constructors require to provide an evidence that the
--   peer has agency in the current state. The types guarantee that it is
--   not possible to supply incorrect evidence, however the pattern
--   synonyms exposed in <a>Network.TypedProtocol.Peer.Client</a> and
--   <a>Network.TypedProtocol.Peer.Client</a> supply this evidence for you,
--   and hence are easier to use and let you avoid some kinds of type
--   errors.
data Peer ps pr pl st m a

-- | Perform a local monadic effect and then continue.
--   
--   Example:
--   
--   <pre>
--   Effect $ do
--     ...          -- actions in the monad
--     return $ ... -- another Peer value
--   </pre>
[Effect] :: forall ps pr pl st m a. m (Peer ps pr pl st m a) -> Peer ps pr pl st m a

-- | Send a message to the other peer and then continue. This takes the
--   message and the continuation. It also requires evidence that we have
--   agency for this protocol state and thus are allowed to send messages.
--   
--   Example:
--   
--   <pre>
--   Yield ReflClientAgency MsgPing $ ...
--   </pre>
[Yield] :: forall ps pr pl (st :: ps) (st' :: ps) m a. (StateTokenI st, StateTokenI st', ActiveState st, Outstanding pl ~ Z) => WeHaveAgencyProof pr st -> Message ps st st' -> Peer ps pr pl st' m a -> Peer ps pr pl st m a

-- | Waits to receive a message from the other peer and then continues.
--   This takes the continuation that is supplied with the received
--   message. It also requires evidence that the other peer has agency for
--   this protocol state and thus we are expected to wait to receive
--   messages.
--   
--   Note that the continuation that gets supplied with the message must be
--   prepared to deal with <i>any</i> message that is allowed in
--   <i>this</i> protocol state. This is why the continuation <i>must</i>
--   be polymorphic in the target state of the message (the third type
--   argument of <a>Message</a>).
--   
--   Example:
--   
--   <pre>
--   Await ReflClientAgency $ \msg -&gt;
--   case msg of
--     MsgDone -&gt; ...
--     MsgPing -&gt; ...
--   </pre>
[Await] :: forall ps pr pl (st :: ps) m a. (StateTokenI st, ActiveState st, Outstanding pl ~ Z) => TheyHaveAgencyProof pr st -> (forall (st' :: ps). Message ps st st' -> Peer ps pr pl st' m a) -> Peer ps pr pl st m a

-- | Terminate with a result. A state token must be provided from the
--   <a>NobodyHasAgency</a> states, to show that this is a state in which
--   we can terminate.
--   
--   Example:
--   
--   <pre>
--   Yield ReflClientAgency
--          MsgDone
--         (Done ReflNobodyAgency TokDone result)
--   </pre>
[Done] :: forall ps pr pl (st :: ps) m a. (StateTokenI st, StateAgency st ~ NobodyAgency, Outstanding pl ~ Z) => NobodyHasAgencyProof pr st -> a -> Peer ps pr pl st m a

-- | Pipelined send. We statically decide from which state we continue (the
--   <tt>st''</tt> state here), the gap (between <tt>st'</tt> and
--   <tt>st''</tt>) must be fulfilled by <a>Receiver</a> which runs will
--   run in parallel.
[YieldPipelined] :: forall ps pr (st :: ps) (st' :: ps) c n st'' m a. (StateTokenI st, StateTokenI st', ActiveState st) => WeHaveAgencyProof pr st -> Message ps st st' -> Receiver ps pr st' st'' m c -> Peer ps pr (Pipelined (S n) c) st'' m a -> Peer ps pr (Pipelined n c) st m a

-- | Collect results returned by a <a>Receiver</a>. Results are collected
--   in the first-in-first-out way.
[Collect] :: forall ps pr c n st m a. (StateTokenI st, ActiveState st) => Maybe (Peer ps pr (Pipelined (S n) c) st m a) -> (c -> Peer ps pr (Pipelined n c) st m a) -> Peer ps pr (Pipelined (S n) c) st m a

-- | A description of a peer that engages in a protocol in a pipelined
--   fashion.
--   
--   This type is useful for wrapping pipelined peers to hide information
--   which is only relevant in peer lift. It is expected by
--   <a>runPeerPipelinedWithDriver</a>.
data PeerPipelined ps pr (st :: ps) m a
[PeerPipelined] :: Peer ps pr (Pipelined Z c) st m a -> PeerPipelined ps pr st m a

-- | Receiver. It is limited to only awaiting for messages and running
--   monadic computations. This means that one can only pipeline messages
--   if they can be connected by state transitions which all have remote
--   agency.
--   
--   The receiver runs in parallel, see
--   <tt>runPipelinedPeerWithDriver</tt>. This makes pipelining quite
--   effective, since the receiver callbacks are called in a separate
--   thread which can effectively use CPU cache and can avoids unnecessary
--   context switches.
data Receiver ps pr st stdone m c

-- | Execute a monadic computation.
[ReceiverEffect] :: m (Receiver ps pr st stdone m c) -> Receiver ps pr st stdone m c

-- | Return value.
[ReceiverDone] :: c -> Receiver ps pr stdone stdone m c

-- | Await for for a remote transition.
[ReceiverAwait] :: (StateTokenI st, ActiveState st) => TheyHaveAgencyProof pr st -> (forall st'. Message ps st st' -> Receiver ps pr st' stdone m c) -> Receiver ps pr st stdone m c

-- | Type level count of the number of outstanding pipelined yields for
--   which we have not yet collected a receiver result. Used to ensure that
--   <tt>Collect</tt> is only used when there are outstanding results to
--   collect (e.g. after <tt>YieldPipeliend</tt> was used); and to ensure
--   that the non-pipelined primitives <tt>Yield</tt>, <tt>Await</tt> and
--   <tt>Done</tt> are only used when there are none unsatisfied pipelined
--   requests.
type family Outstanding pl

-- | A type level inductive natural number.
data N
Z :: N
S :: N -> N

-- | A value level inductive natural number, indexed by the corresponding
--   type level natural number <a>N</a>.
--   
--   This is often needed when writing pipelined peers to be able to count
--   the number of outstanding pipelined yields, and show to the type
--   checker that <a>Collect</a> and <a>Done</a> are being used correctly.
data Nat (n :: N)
pattern Zero :: () => Z ~ n => Nat n
pattern Succ :: () => m ~ S n => Nat n -> Nat m
natToInt :: Nat n -> Int
unsafeIntToNat :: Int -> Nat n
instance forall (m :: * -> *) ps (pr :: Network.TypedProtocol.Core.PeerRole) (pl :: Network.TypedProtocol.Core.IsPipelined) (st :: ps). GHC.Base.Functor m => GHC.Base.Functor (Network.TypedProtocol.Peer.Peer ps pr pl st m)
instance forall (m :: * -> *) ps (pr :: Network.TypedProtocol.Core.PeerRole) (st :: ps) (stdone :: ps). GHC.Base.Functor m => GHC.Base.Functor (Network.TypedProtocol.Peer.Receiver ps pr st stdone m)
instance forall (m :: * -> *) ps (pr :: Network.TypedProtocol.Core.PeerRole) (st :: ps). GHC.Base.Functor m => GHC.Base.Functor (Network.TypedProtocol.Peer.PeerPipelined ps pr st m)


-- | Actions for running <a>Peer</a>s with a <a>Driver</a>
module Network.TypedProtocol.Driver
data Driver ps (pr :: PeerRole) dstate m
Driver :: (forall (st :: ps) (st' :: ps). StateTokenI st => StateTokenI st' => ActiveState st => WeHaveAgencyProof pr st -> Message ps st st' -> m ()) -> (forall (st :: ps). StateTokenI st => ActiveState st => TheyHaveAgencyProof pr st -> dstate -> m (SomeMessage st, dstate)) -> dstate -> Driver ps (pr :: PeerRole) dstate m

-- | Send a message; the message must transition from an active state. One
--   needs to supply agency evidence.
[sendMessage] :: Driver ps (pr :: PeerRole) dstate m -> forall (st :: ps) (st' :: ps). StateTokenI st => StateTokenI st' => ActiveState st => WeHaveAgencyProof pr st -> Message ps st st' -> m ()

-- | Receive some message, since we don't know the final state of the
--   protocol it is wrapped in <a>SomeMessage</a> type; the message must
--   transition from an active state. One needs to supply agency evidence.
[recvMessage] :: Driver ps (pr :: PeerRole) dstate m -> forall (st :: ps). StateTokenI st => ActiveState st => TheyHaveAgencyProof pr st -> dstate -> m (SomeMessage st, dstate)

-- | Initial state of the driver
[initialDState] :: Driver ps (pr :: PeerRole) dstate m -> dstate

-- | When decoding a <a>Message</a> we only know the expected "from" state.
--   We cannot know the "to" state as this depends on the message we
--   decode. To resolve this we use the <a>SomeMessage</a> wrapper which
--   uses an existential type to hide the "to" state.
data SomeMessage (st :: ps)
[SomeMessage] :: (StateTokenI st, StateTokenI st', ActiveState st) => Message ps st st' -> SomeMessage st

-- | Run a peer with the given driver.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
runPeerWithDriver :: forall ps (st :: ps) pr dstate m a. Monad m => Driver ps pr dstate m -> Peer ps pr NonPipelined st m a -> m (a, dstate)

-- | Run a pipelined peer with the given driver.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
--   
--   Unlike normal peers, running pipelined peers rely on concurrency,
--   hence the <a>MonadAsync</a> constraint.
runPipelinedPeerWithDriver :: forall ps (st :: ps) pr dstate m a. MonadAsync m => Driver ps pr dstate m -> PeerPipelined ps pr st m a -> m (a, dstate)

module Network.TypedProtocol.Codec

-- | A codec for a <a>Protocol</a> handles the encoding and decoding of
--   typed protocol messages. This is typically used when sending protocol
--   messages over untyped channels. The codec chooses the exact encoding,
--   for example encoding in some text-based syntax, or some choice of
--   binary format.
--   
--   The codec is parametrised by:
--   
--   <ul>
--   <li>The protocol</li>
--   <li>the type of decoding failures</li>
--   <li>the monad in which the decoder runs</li>
--   <li>the type of the encoded data (typically strings or bytes)</li>
--   </ul>
--   
--   A codec consists of a message encoder and a decoder.
--   
--   The encoder is supplied both with the message to encode and the
--   current protocol state (matching the message). The protocol state can
--   be either a client or server state, but for either peer role it is a
--   protocol state in which the peer has agency, since those are the only
--   states where a peer needs to encode a message to be able to send it.
--   
--   For example a simple text encoder for the ping/pong protocol could be:
--   
--   <pre>
--   encode :: SingI st
--          =&gt; Message PingPong st st'
--          -&gt; String
--   encode MsgPing = "ping\n"
--   encode MsgDone = "done\n"
--   encode MsgPong = "pong\n"
--   </pre>
--   
--   The decoder is also given the current protocol state and it is
--   expected to be able to decode <i>any</i> message that is valid in that
--   state, but <i>only</i> messages that are valid in that state. Messages
--   that are unexpected for the current state should be treated like any
--   other decoding format error.
--   
--   While the current protocol state is known, the state that the message
--   will have the peer transition to is not known. For this reason the
--   decoded message is wrapped in the <a>SomeMessage</a> constructor which
--   hides the "to" state.
--   
--   The decoder uses an incremental decoding interface <a>DecodeStep</a>
--   so that input can be supplied (e.g. from a Channel) bit by bit. This
--   style of decoder allows but does not require a format with message
--   framing where the decoder input matches exactly with the message
--   boundaries.
--   
--   <pre>
--   decode :: forall st m. SingI st
--          =&gt; StateToken st
--          -&gt; m (DecodeStep String String m (SomeMessage st))
--   decode stok =
--     decodeTerminatedFrame '\n' $ \str trailing -&gt;
--       case (stok, str) of
--         (SingBusy, "pong") -&gt;
--              DecodeDone (SomeMessage MsgPong) trailing
--         (SingIdle, "ping") -&gt;
--              DecodeDone (SomeMessage MsgPing) trailing
--         (SingIdle, "done") -&gt;
--              DecodeDone (SomeMessage MsgDone) trailing
--         _ -&gt; DecodeFail ("unexpected message: " ++ str)
--   </pre>
--   
--   See "typed-protocols-examples" for the full example.
--   
--   Note that the pattern matching on the combination of the message
--   string and the protocol state. This neatly fulfils the requirement
--   that we only return messages that are of the correct type for the
--   given protocol state.
--   
--   This toy example format uses newlines <tt>n</tt> as a framing format.
--   See <a>DecodeStep</a> for suggestions on how to use it for more
--   realistic formats.
data Codec ps failure m bytes
Codec :: (forall (st :: ps) (st' :: ps). StateTokenI st => ActiveState st => Message ps st st' -> bytes) -> (forall (st :: ps). ActiveState st => StateToken st -> m (DecodeStep bytes failure m (SomeMessage st))) -> Codec ps failure m bytes
[encode] :: Codec ps failure m bytes -> forall (st :: ps) (st' :: ps). StateTokenI st => ActiveState st => Message ps st st' -> bytes
[decode] :: Codec ps failure m bytes -> forall (st :: ps). ActiveState st => StateToken st -> m (DecodeStep bytes failure m (SomeMessage st))

-- | Change functor in which the codec is running.
hoistCodec :: Functor n => (forall x. m x -> n x) -> Codec ps failure m bytes -> Codec ps failure n bytes

-- | Change bytes of a codec.
isoCodec :: Functor m => (bytes -> bytes') -> (bytes' -> bytes) -> Codec ps failure m bytes -> Codec ps failure m bytes'

-- | Modify failure type.
mapFailureCodec :: Functor m => (failure -> failure') -> Codec ps failure m bytes -> Codec ps failure' m bytes

-- | An incremental decoder with return a value of type <tt>a</tt>.
--   
--   This interface is not designed to be used directly for implementing
--   decoders, only for running them. In real applications it is expected
--   to use libraries for text or binary decoding and to implement
--   appropriate wrappers to match up with this incremental decoder
--   interface.
--   
--   This style of interface already closely matches that provided by
--   libraries such as <tt>attoparsec</tt> for text formats, and
--   <tt>binary</tt>, <tt>cereal</tt> and <tt>cborg</tt> for binary
--   formats.
data DecodeStep bytes failure m a

-- | The decoder has consumed the available input and needs more to
--   continue. Provide <tt><a>Just</a></tt> if more input is available and
--   <tt><a>Nothing</a></tt> otherwise, and you will get a new
--   <tt><a>DecodeStep</a></tt>.
DecodePartial :: (Maybe bytes -> m (DecodeStep bytes failure m a)) -> DecodeStep bytes failure m a

-- | The decoder has successfully finished. This provides the decoded
--   result value plus any unused input.
DecodeDone :: a -> Maybe bytes -> DecodeStep bytes failure m a

-- | The decoder ran into an error. The decoder either used
--   <tt><a>fail</a></tt> or was not provided enough input.
DecodeFail :: failure -> DecodeStep bytes failure m a

-- | Run a codec incremental decoder <a>DecodeStep</a> against a list of
--   input.
--   
--   It ignores any unused trailing data. This is useful for demos, quick
--   experiments and tests.
--   
--   See also <a>runDecoderWithChannel</a>
runDecoder :: Monad m => [bytes] -> DecodeStep bytes failure m a -> m (Either failure a)

-- | A variant of <a>runDecoder</a> that is suitable for "pure" monads that
--   have a run function. This includes <tt>ST</tt>, using <a>runST</a>.
runDecoderPure :: Monad m => (forall b. m b -> b) -> m (DecodeStep bytes failure m a) -> [bytes] -> Either failure a

-- | Change functor in which the codec is running.
hoistDecodeStep :: Functor n => (forall x. m x -> n x) -> DecodeStep bytes failure m a -> DecodeStep bytes failure n a

-- | Change bytes of <a>DecodeStep</a>.
isoDecodeStep :: Functor m => (bytes -> bytes') -> (bytes' -> bytes) -> DecodeStep bytes failure m a -> DecodeStep bytes' failure m a

-- | Modify failure type.
mapFailureDecodeStep :: Functor m => (failure -> failure') -> DecodeStep bytes failure m a -> DecodeStep bytes failure' m a

-- | When decoding a <a>Message</a> we only know the expected "from" state.
--   We cannot know the "to" state as this depends on the message we
--   decode. To resolve this we use the <a>SomeMessage</a> wrapper which
--   uses an existential type to hide the "to" state.
data SomeMessage (st :: ps)
[SomeMessage] :: (StateTokenI st, StateTokenI st', ActiveState st) => Message ps st st' -> SomeMessage st

-- | A type family for protocol state token, e.g. term level representation
--   of type level state (also known as singleton).
--   
--   This type family is similar to <a>Sing</a> type class in the
--   "singletons" package, but specific for protocol states.
type StateToken :: ps -> Type

-- | A type class which hides a state token / singleton inside a class
--   dictionary.
--   
--   This is similar to the <a>SingI</a> instance, but specific to protocol
--   state singletons.
class StateTokenI st
stateToken :: StateTokenI st => StateToken st

-- | A type class which restricts states to ones that have
--   <a>ClientAgency</a> or <a>ServerAgency</a>, excluding
--   <a>NobodyAgency</a>.
--   
--   One can use <tt>notActive</tt> to eliminate cases for which both
--   <tt><a>IsActiveState</a> st</tt> is in scope and for which we have an
--   evidence that the state is not active (i.e. a singleton). This is
--   useful when writing a <tt>Codec</tt>.
class IsActiveState st (agency :: Agency)
activeAgency :: IsActiveState st agency => ActiveAgency' st agency

-- | A constraint which provides an evidence that the protocol isn't in a
--   terminal state.
type ActiveState st = IsActiveState st (StateAgency st)

-- | Evidence that the protocol isn't in a terminal state.
type ActiveAgency st = ActiveAgency' st (StateAgency st)

-- | Evidence that one side of the protocol has the agency, and thus that
--   the protocol hasn't yet terminated.
data ActiveAgency' st agency

-- | Evidence that the client has the agency.
[ClientHasAgency] :: StateAgency st ~ ClientAgency => ActiveAgency' st ClientAgency

-- | Evidence that the server has the agency.
[ServerHasAgency] :: StateAgency st ~ ServerAgency => ActiveAgency' st ServerAgency

-- | This is useful function to eliminate cases where the `ActiveState st`
--   is provided but we are given a state in which neither side has agency
--   (<a>NobodyAgency</a>). For example when writing a codec, we only need
--   to encode / decode messages which are in active states, but to make
--   such functions total, <a>notActiveState</a> needs to be used to
--   eliminate the states in which nobody has agency.
--   
--   A good analogy for this function is <tt><a>absurd</a> :: <tt>Void</tt>
--   -&gt; a</tt>.
notActiveState :: forall ps (st :: ps). StateAgency st ~ NobodyAgency => ActiveState st => StateToken st -> forall a. a

-- | Types for client and server peer roles. As protocol can be viewed from
--   either client or server side.
--   
--   Note that technically "client" and "server" are arbitrary labels. The
--   framework is completely symmetric between the two peers.
--   
--   This definition is only used as promoted types and kinds, never as
--   values.
data PeerRole
AsClient :: PeerRole
AsServer :: PeerRole

-- | Each <a>Codec</a> can use whatever <tt>failure</tt> type is
--   appropriate. This simple exception type is provided for use by simple
--   codecs (e.g. "identity") when nothing more than a <a>String</a> is
--   needed. It is an instance of <a>Exception</a>.
data CodecFailure
CodecFailureOutOfInput :: CodecFailure
CodecFailure :: String -> CodecFailure

-- | Any message for a protocol, with a <a>StateTokenI</a> constraint which
--   gives access to protocol state.
--   
--   Used where we don't know statically what the state type is, but need
--   the agency and message to match each other.
data AnyMessage ps
[AnyMessage] :: forall ps (st :: ps) (st' :: ps). (StateTokenI st, ActiveState st) => Message ps (st :: ps) (st' :: ps) -> AnyMessage ps

-- | A convenient pattern synonym which unwrap <a>AnyMessage</a> giving
--   both the singleton for the state and the message.
pattern AnyMessageAndAgency :: forall ps. () => forall (st :: ps) (st' :: ps). (StateTokenI st, ActiveState st) => StateToken st -> Message ps st st' -> AnyMessage ps

-- | The <a>Codec</a> round-trip property: decode after encode gives the
--   same message. Every codec must satisfy this property.
prop_codecM :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps)) => Codec ps failure m bytes -> AnyMessage ps -> m Bool

-- | The <a>Codec</a> round-trip property in a pure monad.
prop_codec :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps)) => (forall a. m a -> a) -> Codec ps failure m bytes -> AnyMessage ps -> Bool

-- | A variant on the codec round-trip property: given the encoding of a
--   message, check that decode always gives the same result irrespective
--   of how the chunks of input are fed to the incremental decoder.
--   
--   This property guards against boundary errors in incremental decoders.
--   It is not necessary to check this for every message type, just for
--   each generic codec construction. For example given some binary
--   serialisation library one would write a generic adaptor to the codec
--   interface. This adaptor has to deal with the incremental decoding and
--   this is what needs to be checked.
prop_codec_splitsM :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps)) => (bytes -> [[bytes]]) -> Codec ps failure m bytes -> AnyMessage ps -> m Bool

-- | Like <tt><a>prop_codec_splitsM</a></tt> but run in a pure monad
--   <tt>m</tt>, e.g. <tt>Identity</tt>.
prop_codec_splits :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps)) => (bytes -> [[bytes]]) -> (forall a. m a -> a) -> Codec ps failure m bytes -> AnyMessage ps -> Bool

-- | Binary compatibility of two protocols
--   
--   We check the following property:
--   
--   <ol>
--   <li>Using codec A, we encode a message of protocol <tt>psA</tt> to
--   <tt>bytes</tt>.</li>
--   <li>When we decode those <tt>bytes</tt> using codec B, we get a
--   message of protocol <tt>ps</tt>B.</li>
--   <li>When we encode that message again using codec B, we get
--   <tt>bytes</tt>.</li>
--   <li>When we decode those <tt>bytes</tt> using codec A, we get the
--   original message again.</li>
--   </ol>
prop_codec_binary_compatM :: forall psA psB failure m bytes. (Monad m, Eq (AnyMessage psA)) => Codec psA failure m bytes -> Codec psB failure m bytes -> (forall (stA :: psA). ActiveState stA => StateToken stA -> SomeState psB) -> AnyMessage psA -> m Bool

-- | Like <tt><a>prop_codec_splitsM</a></tt> but run in a pure monad
--   <tt>m</tt>, e.g. <tt>Identity</tt>.
prop_codec_binary_compat :: forall psA psB failure m bytes. (Monad m, Eq (AnyMessage psA)) => (forall a. m a -> a) -> Codec psA failure m bytes -> Codec psB failure m bytes -> (forall (stA :: psA). StateToken stA -> SomeState psB) -> AnyMessage psA -> Bool

-- | Compatibility between two codecs of the same protocol. Encode a
--   message with one codec and decode it with the other one, then compare
--   if the result is the same as initial message.
prop_codecs_compatM :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps), forall a. Monoid a => Monoid (m a)) => Codec ps failure m bytes -> Codec ps failure m bytes -> AnyMessage ps -> m Bool

-- | Like <tt><a>prop_codecs_compatM</a></tt> but run in a pure monad
--   <tt>m</tt>, e.g. <tt>Identity</tt>.
prop_codecs_compat :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps), forall a. Monoid a => Monoid (m a)) => (forall a. m a -> a) -> Codec ps failure m bytes -> Codec ps failure m bytes -> AnyMessage ps -> Bool

-- | Auxiliary definition for <a>prop_codec_binary_compatM</a>.
--   
--   Used for the existential <tt>st :: ps</tt> parameter when expressing
--   that for each value of <tt>PeerHasAgency</tt> for protocol A, there is
--   a corresponding <tt>PeerHasAgency</tt> for protocol B of some <tt>st
--   :: ps</tt>.
data SomeState (ps :: Type)
[SomeState] :: forall ps (st :: ps). ActiveState st => StateToken st -> SomeState ps
instance GHC.Show.Show Network.TypedProtocol.Codec.CodecFailure
instance GHC.Classes.Eq Network.TypedProtocol.Codec.CodecFailure
instance (forall (st :: ps) (st' :: ps). GHC.Show.Show (Network.TypedProtocol.Core.Message ps st st')) => GHC.Show.Show (Network.TypedProtocol.Codec.AnyMessage ps)
instance GHC.Exception.Type.Exception Network.TypedProtocol.Codec.CodecFailure


-- | Bidirectional patterns for <tt><a>Peer</a> ps <a>AsClient</a></tt>.
--   The advantage of these patterns is that they automatically provide the
--   <a>ReflRelativeAgency</a> evidence.
module Network.TypedProtocol.Peer.Client
type Client ps pl st m a = Peer ps AsClient pl st m a

-- | Client role pattern for <a>Effect</a>.
pattern Effect :: forall ps pl st m a. m (Client ps pl st m a) -> Client ps pl st m a

-- | Client role pattern for <a>Yield</a>
pattern Yield :: forall ps pl st m a. () => forall st'. (StateTokenI st, StateTokenI st', StateAgency st ~ ClientAgency, Outstanding pl ~ Z) => Message ps st st' -> Client ps pl st' m a -> Client ps pl st m a

-- | Client role pattern for <a>Await</a>
pattern Await :: forall ps pl st m a. () => (StateTokenI st, StateAgency st ~ ServerAgency, Outstanding pl ~ Z) => (forall st'. Message ps st st' -> Client ps pl st' m a) -> Client ps pl st m a

-- | Client role pattern for <a>Done</a>
pattern Done :: forall ps pl st m a. () => (StateTokenI st, StateAgency st ~ NobodyAgency, Outstanding pl ~ Z) => a -> Client ps pl st m a

-- | Client role pattern for <a>YieldPipelined</a>
pattern YieldPipelined :: forall ps st n c m a. () => forall st' st''. (StateTokenI st, StateTokenI st', StateAgency st ~ ClientAgency) => Message ps st st' -> Receiver ps st' st'' m c -> Client ps (Pipelined (S n) c) st'' m a -> Client ps (Pipelined n c) st m a

-- | Client role pattern for <a>Collect</a>
pattern Collect :: forall ps st n c m a. () => (StateTokenI st, ActiveState st) => Maybe (Client ps (Pipelined (S n) c) st m a) -> (c -> Client ps (Pipelined n c) st m a) -> Client ps (Pipelined (S n) c) st m a
type Receiver ps st stdone m c = Receiver ps AsClient st stdone m c
pattern ReceiverEffect :: forall ps st stdone m c. m (Receiver ps st stdone m c) -> Receiver ps st stdone m c
pattern ReceiverAwait :: forall ps st stdone m c. () => (StateTokenI st, ActiveState st, StateAgency st ~ ServerAgency) => (forall st'. Message ps st st' -> Receiver ps st' stdone m c) -> Receiver ps st stdone m c
pattern ReceiverDone :: forall ps stdone m c. c -> Receiver ps stdone stdone m c

-- | A description of a peer that engages in a protocol in a pipelined
--   fashion.
type ClientPipelined ps st m a = PeerPipelined ps AsClient st m a

-- | A description of a peer that engages in a protocol in a pipelined
--   fashion.
--   
--   This type is useful for wrapping pipelined peers to hide information
--   which is only relevant in peer lift. It is expected by
--   <a>runPeerPipelinedWithDriver</a>.
data PeerPipelined ps pr (st :: ps) m a
pattern ClientPipelined :: forall ps st m a. () => forall c. () => Client ps (Pipelined Z c) st m a -> ClientPipelined ps st m a

-- | Promoted data type which indicates if <tt>Peer</tt> is used in
--   pipelined mode or not.
data IsPipelined

-- | Pipelined peer which is using `c :: Type` for collecting responses
--   from a pipelined messages. <a>N</a> indicates depth of pipelining.
[Pipelined] :: N -> Type -> IsPipelined

-- | Non-pipelined peer.
[NonPipelined] :: IsPipelined

-- | Type level count of the number of outstanding pipelined yields for
--   which we have not yet collected a receiver result. Used to ensure that
--   <tt>Collect</tt> is only used when there are outstanding results to
--   collect (e.g. after <tt>YieldPipeliend</tt> was used); and to ensure
--   that the non-pipelined primitives <tt>Yield</tt>, <tt>Await</tt> and
--   <tt>Done</tt> are only used when there are none unsatisfied pipelined
--   requests.
type family Outstanding pl

-- | A type level inductive natural number.
data N
Z :: N
S :: N -> N

-- | A value level inductive natural number, indexed by the corresponding
--   type level natural number <a>N</a>.
--   
--   This is often needed when writing pipelined peers to be able to count
--   the number of outstanding pipelined yields, and show to the type
--   checker that <a>Collect</a> and <a>Done</a> are being used correctly.
data Nat (n :: N)
pattern Succ :: () => m ~ S n => Nat n -> Nat m
pattern Zero :: () => Z ~ n => Nat n


-- | Bidirectional patterns for <tt><a>Peer</a> ps <a>AsServer</a></tt>.
--   The advantage of these patterns is that they automatically provide the
--   <a>ReflRelativeAgency</a> evidence.
module Network.TypedProtocol.Peer.Server
type Server ps pl st m a = Peer ps AsServer pl st m a

-- | Server role pattern for <a>Effect</a>.
pattern Effect :: forall ps pl st m a. m (Server ps pl st m a) -> Server ps pl st m a

-- | Server role pattern for <a>Yield</a>
pattern Yield :: forall ps pl st m a. () => forall st'. (StateTokenI st, StateTokenI st', StateAgency st ~ ServerAgency, Outstanding pl ~ Z) => Message ps st st' -> Server ps pl st' m a -> Server ps pl st m a

-- | Server role pattern for <a>Await</a>
pattern Await :: forall ps pl st m a. () => (StateTokenI st, StateAgency st ~ ClientAgency, Outstanding pl ~ Z) => (forall st'. Message ps st st' -> Server ps pl st' m a) -> Server ps pl st m a

-- | Server role pattern for <a>Done</a>
pattern Done :: forall ps pl st m a. () => (StateTokenI st, StateAgency st ~ NobodyAgency, Outstanding pl ~ Z) => a -> Server ps pl st m a

-- | Server role pattern for <a>YieldPipelined</a>
pattern YieldPipelined :: forall ps st n c m a. () => forall st' st''. (StateTokenI st, StateTokenI st', StateAgency st ~ ServerAgency) => Message ps st st' -> Receiver ps st' st'' m c -> Server ps (Pipelined (S n) c) st'' m a -> Server ps (Pipelined n c) st m a

-- | Server role pattern for <a>Collect</a>
pattern Collect :: forall ps st n c m a. () => (StateTokenI st, ActiveState st) => Maybe (Server ps (Pipelined (S n) c) st m a) -> (c -> Server ps (Pipelined n c) st m a) -> Server ps (Pipelined (S n) c) st m a
type Receiver ps st stdone m c = Receiver ps AsServer st stdone m c
pattern ReceiverEffect :: forall ps st stdone m c. m (Receiver ps st stdone m c) -> Receiver ps st stdone m c
pattern ReceiverAwait :: forall ps st stdone m c. () => (StateTokenI st, ActiveState st, StateAgency st ~ ClientAgency) => (forall st'. Message ps st st' -> Receiver ps st' stdone m c) -> Receiver ps st stdone m c
pattern ReceiverDone :: forall ps stdone m c. c -> Receiver ps stdone stdone m c

-- | A description of a peer that engages in a protocol in a pipelined
--   fashion.
type ServerPipelined ps st m a = PeerPipelined ps AsServer st m a

-- | A description of a peer that engages in a protocol in a pipelined
--   fashion.
--   
--   This type is useful for wrapping pipelined peers to hide information
--   which is only relevant in peer lift. It is expected by
--   <a>runPeerPipelinedWithDriver</a>.
data PeerPipelined ps pr (st :: ps) m a
pattern ServerPipelined :: forall ps st m a. () => forall c. () => Server ps (Pipelined Z c) st m a -> ServerPipelined ps st m a

-- | Promoted data type which indicates if <tt>Peer</tt> is used in
--   pipelined mode or not.
data IsPipelined

-- | Pipelined peer which is using `c :: Type` for collecting responses
--   from a pipelined messages. <a>N</a> indicates depth of pipelining.
[Pipelined] :: N -> Type -> IsPipelined

-- | Non-pipelined peer.
[NonPipelined] :: IsPipelined

-- | Type level count of the number of outstanding pipelined yields for
--   which we have not yet collected a receiver result. Used to ensure that
--   <tt>Collect</tt> is only used when there are outstanding results to
--   collect (e.g. after <tt>YieldPipeliend</tt> was used); and to ensure
--   that the non-pipelined primitives <tt>Yield</tt>, <tt>Await</tt> and
--   <tt>Done</tt> are only used when there are none unsatisfied pipelined
--   requests.
type family Outstanding pl

-- | A type level inductive natural number.
data N
Z :: N
S :: N -> N

-- | A value level inductive natural number, indexed by the corresponding
--   type level natural number <a>N</a>.
--   
--   This is often needed when writing pipelined peers to be able to count
--   the number of outstanding pipelined yields, and show to the type
--   checker that <a>Collect</a> and <a>Done</a> are being used correctly.
data Nat (n :: N)
pattern Succ :: () => m ~ S n => Nat n -> Nat m
pattern Zero :: () => Z ~ n => Nat n


-- | Proofs and helpful testing utilities.
module Network.TypedProtocol.Proofs

-- | The <a>connect</a> function takes two peers that agree on a protocol
--   and runs them in lock step, until (and if) they complete.
--   
--   The <a>connect</a> function serves a few purposes.
--   
--   <ul>
--   <li>The fact we can define this function at at all proves some minimal
--   sanity property of the typed protocol framework.</li>
--   <li>It demonstrates that all protocols defined in the framework can be
--   run with synchronous communication rather than requiring buffered
--   communication.</li>
--   <li>It is useful for testing peer implementations against each other
--   in a minimalistic setting.</li>
--   </ul>
connect :: forall ps (pr :: PeerRole) (initSt :: ps) m a b. (Monad m, SingI pr) => Peer ps pr NonPipelined initSt m a -> Peer ps (FlipAgency pr) NonPipelined initSt m b -> m (a, b, TerminalStates ps)

-- | Analogous to <a>connect</a> but also for pipelined peers.
--   
--   Since pipelining allows multiple possible interleavings, we provide a
--   <tt>[Bool]</tt> parameter to control the choices. Each <tt>True</tt>
--   will trigger picking the first choice in the <tt>SenderCollect</tt>
--   construct (if possible), leading to more results outstanding. This can
--   also be interpreted as a greater pipeline depth, or more messages
--   in-flight.
--   
--   This can be exercised using a QuickCheck style generator.
connectPipelined :: forall ps (pr :: PeerRole) (st :: ps) m a b. (Monad m, SingI pr) => [Bool] -> PeerPipelined ps pr st m a -> Peer ps (FlipAgency pr) NonPipelined st m b -> m (a, b, TerminalStates ps)

-- | The terminal states for the protocol. Used in <a>connect</a> and
--   <a>connectPipelined</a> to return the states in which the peers
--   terminated.
data TerminalStates ps
[TerminalStates] :: forall ps (st :: ps). StateAgency st ~ NobodyAgency => StateToken st -> StateToken st -> TerminalStates ps

-- | Proof that we have a total conversion from pipelined peers to regular
--   peers. This is a sanity property that shows that pipelining did not
--   give us extra expressiveness or to break the protocol state machine.
forgetPipelined :: forall ps (pr :: PeerRole) (st :: ps) m a. Functor m => [Bool] -> PeerPipelined ps pr st m a -> Peer ps pr NonPipelined st m a

-- | Promote a peer to a pipelined one.
--   
--   This is a right inverse of <a>forgetPipelined</a>, e.g.
--   
--   <pre>
--   &gt;&gt;&gt; forgetPipelined . promoteToPipelined = id
--   </pre>
promoteToPipelined :: forall ps (pr :: PeerRole) st m a. Functor m => Peer ps pr NonPipelined st m a -> PeerPipelined ps pr st m a

-- | A size indexed queue. This is useful for proofs, including
--   <a>connectPipelined</a> but also as so-called <tt>direct</tt>
--   functions for running a client and server wrapper directly against
--   each other.
data Queue (n :: N) a
[EmptyQ] :: Queue Z a
[ConsQ] :: a -> Queue n a -> Queue (S n) a

-- | At an element to the end of a <a>Queue</a>. This is not intended to be
--   efficient. It is only for proofs and tests.
enqueue :: a -> Queue n a -> Queue (S n) a

-- | A reference specification for interleaving of requests and responses
--   with pipelining, where the environment can choose whether a response
--   is available yet.
--   
--   This also supports bounded choice where the maximum number of
--   outstanding in-flight responses is limited.
pipelineInterleaving :: Int -> [Bool] -> [req] -> [resp] -> [Either req resp]


-- | This package defines the typed protocol framework. This module
--   re-exports the public API.
module Network.TypedProtocol
