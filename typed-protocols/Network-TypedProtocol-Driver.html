<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Network.TypedProtocol.Driver</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">typed-protocols-0.3.0.0: A framework for strongly typed protocols</span><ul class="links" id="page-menu"><li><a href="src/Network.TypedProtocol.Driver.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.TypedProtocol.Driver</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Introduction</a></li><li><a href="#g:2">Normal peers</a></li><li><a href="#g:3">Pipelined peers</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Actions for running <code><a href="Network-TypedProtocol-Peer.html#t:Peer" title="Network.TypedProtocol.Peer">Peer</a></code>s with a <code><a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a></code></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Driver">Driver</a> ps (pr :: <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) dstate m = <a href="#v:Driver">Driver</a> {<ul class="subs"><li><a href="#v:sendMessage">sendMessage</a> :: <span class="keyword">forall</span> (st :: ps) (st' :: ps). <a href="Network-TypedProtocol-Core.html#t:StateTokenI" title="Network.TypedProtocol.Core">StateTokenI</a> st =&gt; <a href="Network-TypedProtocol-Core.html#t:StateTokenI" title="Network.TypedProtocol.Core">StateTokenI</a> st' =&gt; <a href="Network-TypedProtocol-Core.html#t:ActiveState" title="Network.TypedProtocol.Core">ActiveState</a> st =&gt; <a href="Network-TypedProtocol-Core.html#t:WeHaveAgencyProof" title="Network.TypedProtocol.Core">WeHaveAgencyProof</a> pr st -&gt; <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' -&gt; m ()</li><li><a href="#v:recvMessage">recvMessage</a> :: <span class="keyword">forall</span> (st :: ps). <a href="Network-TypedProtocol-Core.html#t:StateTokenI" title="Network.TypedProtocol.Core">StateTokenI</a> st =&gt; <a href="Network-TypedProtocol-Core.html#t:ActiveState" title="Network.TypedProtocol.Core">ActiveState</a> st =&gt; <a href="Network-TypedProtocol-Core.html#t:TheyHaveAgencyProof" title="Network.TypedProtocol.Core">TheyHaveAgencyProof</a> pr st -&gt; dstate -&gt; m (<a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a> st, dstate)</li><li><a href="#v:initialDState">initialDState</a> :: dstate</li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:SomeMessage">SomeMessage</a> (st :: ps) <span class="keyword">where</span><ul class="subs"><li><a href="#v:SomeMessage">SomeMessage</a> :: (<a href="Network-TypedProtocol-Core.html#t:StateTokenI" title="Network.TypedProtocol.Core">StateTokenI</a> st, <a href="Network-TypedProtocol-Core.html#t:StateTokenI" title="Network.TypedProtocol.Core">StateTokenI</a> st', <a href="Network-TypedProtocol-Core.html#t:ActiveState" title="Network.TypedProtocol.Core">ActiveState</a> st) =&gt; <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' -&gt; <a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a> st</li></ul></li><li class="src short"><a href="#v:runPeerWithDriver">runPeerWithDriver</a> :: <span class="keyword">forall</span> ps (st :: ps) pr dstate m a. <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a> ps pr dstate m -&gt; <a href="Network-TypedProtocol-Peer.html#t:Peer" title="Network.TypedProtocol.Peer">Peer</a> ps pr <a href="Network-TypedProtocol-Core.html#v:NonPipelined" title="Network.TypedProtocol.Core">NonPipelined</a> st m a -&gt; m (a, dstate)</li><li class="src short"><a href="#v:runPipelinedPeerWithDriver">runPipelinedPeerWithDriver</a> :: <span class="keyword">forall</span> ps (st :: ps) pr dstate m a. MonadAsync m =&gt; <a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a> ps pr dstate m -&gt; <a href="Network-TypedProtocol-Peer.html#t:PeerPipelined" title="Network.TypedProtocol.Peer">PeerPipelined</a> ps pr st m a -&gt; m (a, dstate)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Introduction</h1></a><div class="doc"><p>A <code><a href="Network-TypedProtocol-Peer.html#t:Peer" title="Network.TypedProtocol.Peer">Peer</a></code> is a particular implementation of an agent that engages in a
 typed protocol. To actually run one we need an untyped channel representing
 one end of an untyped duplex message transport, which allows to send and
 receive bytes.  One will also need a <code>Codec</code> which handles conversion
 between the typed protocol messages and the untyped channel.</p><p>Given the <code><a href="Network-TypedProtocol-Peer.html#t:Peer" title="Network.TypedProtocol.Peer">Peer</a></code>, a compatible <code><a href="Network-TypedProtocol-Codec.html#v:Codec" title="Network.TypedProtocol.Codec">Codec</a></code> and
 an untyped channel we can run the peer in some appropriate monad (e.g. <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a></code>,
 or a simulation monad for testing purposes). The peer and codec have to
 agree on the same protocol. The codec and channel have to agree on the same
 untyped medium, e.g. text or bytes. All three have to agree on the same
 monad in which they will run.</p><p>This module provides drivers for normal and pipelined peers. There is
 very little policy involved here so typically it should be possible to
 use these drivers, and customise things by adjusting the peer, or codec
 or channel (together with an implementation of a <code><a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a></code> based on it).</p><p>For implementing a <code><a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a></code> based on some untyped channel, the
 <code><a href="Network-TypedProtocol-Codec.html#v:runDecoder" title="Network.TypedProtocol.Codec">runDecoder</a></code> function may be a helpful utility.</p><p>For a possible definition of an untyped channel and how to construct
 a <code><a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a></code> from it see <code>typed-protocols-examples</code> package.  For production
 grade examples see <a href="https://github.com/IntersectMBO/ouroboros-network">https://github.com/IntersectMBO/ouroboros-network</a>
 repository.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Driver" class="def">Driver</a> ps (pr :: <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) dstate m <a href="src/Network.TypedProtocol.Driver.html#Driver" class="link">Source</a> <a href="#t:Driver" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Driver" class="def">Driver</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:sendMessage" class="def">sendMessage</a> :: <span class="keyword">forall</span> (st :: ps) (st' :: ps). <a href="Network-TypedProtocol-Core.html#t:StateTokenI" title="Network.TypedProtocol.Core">StateTokenI</a> st =&gt; <a href="Network-TypedProtocol-Core.html#t:StateTokenI" title="Network.TypedProtocol.Core">StateTokenI</a> st' =&gt; <a href="Network-TypedProtocol-Core.html#t:ActiveState" title="Network.TypedProtocol.Core">ActiveState</a> st =&gt; <a href="Network-TypedProtocol-Core.html#t:WeHaveAgencyProof" title="Network.TypedProtocol.Core">WeHaveAgencyProof</a> pr st -&gt; <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' -&gt; m ()</dfn><div class="doc"><p>Send a message; the message must transition from an active state.
 One needs to supply agency evidence.</p></div></li><li><dfn class="src"><a id="v:recvMessage" class="def">recvMessage</a> :: <span class="keyword">forall</span> (st :: ps). <a href="Network-TypedProtocol-Core.html#t:StateTokenI" title="Network.TypedProtocol.Core">StateTokenI</a> st =&gt; <a href="Network-TypedProtocol-Core.html#t:ActiveState" title="Network.TypedProtocol.Core">ActiveState</a> st =&gt; <a href="Network-TypedProtocol-Core.html#t:TheyHaveAgencyProof" title="Network.TypedProtocol.Core">TheyHaveAgencyProof</a> pr st -&gt; dstate -&gt; m (<a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a> st, dstate)</dfn><div class="doc"><p>Receive some message, since we don't know the final state of
 the protocol it is wrapped in <code><a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a></code> type; the message must
 transition from an active state. One needs to supply agency
 evidence.</p></div></li><li><dfn class="src"><a id="v:initialDState" class="def">initialDState</a> :: dstate</dfn><div class="doc"><p>Initial state of the driver</p></div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:SomeMessage" class="def">SomeMessage</a> (st :: ps) <span class="keyword">where</span> <a href="src/Network.TypedProtocol.Driver.html#SomeMessage" class="link">Source</a> <a href="#t:SomeMessage" class="selflink">#</a></p><div class="doc"><p>When decoding a <code><a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a></code> we only know the expected &quot;from&quot; state. We
 cannot know the &quot;to&quot; state as this depends on the message we decode. To
 resolve this we use the <code><a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a></code> wrapper which uses an existential
 type to hide the &quot;to&quot; state.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:SomeMessage" class="def">SomeMessage</a> :: (<a href="Network-TypedProtocol-Core.html#t:StateTokenI" title="Network.TypedProtocol.Core">StateTokenI</a> st, <a href="Network-TypedProtocol-Core.html#t:StateTokenI" title="Network.TypedProtocol.Core">StateTokenI</a> st', <a href="Network-TypedProtocol-Core.html#t:ActiveState" title="Network.TypedProtocol.Core">ActiveState</a> st) =&gt; <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' -&gt; <a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a> st</td><td class="doc empty">&nbsp;</td></tr></table></div></div><a href="#g:2" id="g:2"><h1>Normal peers</h1></a><div class="top"><p class="src"><a id="v:runPeerWithDriver" class="def">runPeerWithDriver</a> :: <span class="keyword">forall</span> ps (st :: ps) pr dstate m a. <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a> ps pr dstate m -&gt; <a href="Network-TypedProtocol-Peer.html#t:Peer" title="Network.TypedProtocol.Peer">Peer</a> ps pr <a href="Network-TypedProtocol-Core.html#v:NonPipelined" title="Network.TypedProtocol.Core">NonPipelined</a> st m a -&gt; m (a, dstate) <a href="src/Network.TypedProtocol.Driver.html#runPeerWithDriver" class="link">Source</a> <a href="#v:runPeerWithDriver" class="selflink">#</a></p><div class="doc"><p>Run a peer with the given driver.</p><p>This runs the peer to completion (if the protocol allows for termination).</p></div></div><a href="#g:3" id="g:3"><h1>Pipelined peers</h1></a><div class="top"><p class="src"><a id="v:runPipelinedPeerWithDriver" class="def">runPipelinedPeerWithDriver</a> :: <span class="keyword">forall</span> ps (st :: ps) pr dstate m a. MonadAsync m =&gt; <a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a> ps pr dstate m -&gt; <a href="Network-TypedProtocol-Peer.html#t:PeerPipelined" title="Network.TypedProtocol.Peer">PeerPipelined</a> ps pr st m a -&gt; m (a, dstate) <a href="src/Network.TypedProtocol.Driver.html#runPipelinedPeerWithDriver" class="link">Source</a> <a href="#v:runPipelinedPeerWithDriver" class="selflink">#</a></p><div class="doc"><p>Run a pipelined peer with the given driver.</p><p>This runs the peer to completion (if the protocol allows for termination).</p><p>Unlike normal peers, running pipelined peers rely on concurrency, hence the
 <code>MonadAsync</code> constraint.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>