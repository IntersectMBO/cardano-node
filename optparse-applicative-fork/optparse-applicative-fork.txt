-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities and combinators for parsing command line options
--   
--   optparse-applicative-fork is a haskell library for parsing options on
--   the command line, and providing a powerful applicative interface for
--   composing them.
--   
--   optparse-applicative-fork takes care of reading and validating the
--   arguments passed to the command line, handling and reporting errors,
--   generating a usage line, a comprehensive help screen, and enabling
--   context-sensitive bash, zsh, and fish completions.
--   
--   See the included README for detailed instructions and examples, which
--   is also available on github
--   <a>https://github.com/pcapriotti/optparse-applicative-fork</a>.
@package optparse-applicative-fork
@version 0.18.1.0

module Options.Applicative.Help.Levenshtein

-- | Calculate the Damerau-Levenshtein edit distance between two lists
--   (strings).
--   
--   This is modified from <a>https://wiki.haskell.org/Edit_distance</a>
--   and is originally from Lloyd Allison's paper "Lazy Dynamic-Programming
--   can be Eager"
--   
--   It's been changed though from Levenshtein to Damerau-Levenshtein,
--   which treats transposition of adjacent characters as one change
--   instead of two.
--   
--   Complexity O(|a|*(1 + editDistance a b))
editDistance :: Eq a => [a] -> [a] -> Int

module Options.Applicative.Help.Style
data SetStyle
SetStyle :: Bool -> Maybe (ColorIntensity, Color) -> Maybe (ColorIntensity, Color) -> Maybe ConsoleIntensity -> Maybe Italicized -> Maybe Underlining -> SetStyle
[ansiReset] :: SetStyle -> Bool

-- | Set the foreground color, or keep the old one.
[ansiForeground] :: SetStyle -> Maybe (ColorIntensity, Color)

-- | Set the background color, or keep the old one.
[ansiBackground] :: SetStyle -> Maybe (ColorIntensity, Color)

-- | Adjust boldness
[ansiConsoleIntensity] :: SetStyle -> Maybe ConsoleIntensity

-- | Adjust italics
[ansiItalics] :: SetStyle -> Maybe Italicized

-- | Adjust underlining
[ansiUnderlining] :: SetStyle -> Maybe Underlining
data () => ColorIntensity
Dull :: ColorIntensity
Vivid :: ColorIntensity
data Layer
Foreground :: Layer
Background :: Layer
data () => ConsoleIntensity
BoldIntensity :: ConsoleIntensity
FaintIntensity :: ConsoleIntensity
NormalIntensity :: ConsoleIntensity
data () => Underlining
SingleUnderline :: Underlining
DoubleUnderline :: Underlining
CurlyUnderline :: Underlining
DottedUnderline :: Underlining
DashedUnderline :: Underlining
NoUnderline :: Underlining
data Italicized
Italicized :: Italicized
NoItalics :: Italicized
data Color
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Magenta :: Color
Cyan :: Color
White :: Color

-- | Style the foreground with a vivid color.
color :: Color -> SetStyle

-- | Style the background with a vivid color.
bgColor :: Color -> SetStyle

-- | Style the foreground with a dull color.
colorDull :: Color -> SetStyle

-- | Style the background with a dull color.
bgColorDull :: Color -> SetStyle

-- | Render in <b>bold</b>.
bold :: SetStyle

-- | Render underlined.
underlined :: SetStyle

-- | Render in <i>italics</i>.
italicized :: SetStyle
styleToRawText :: SetStyle -> String
defaultStyle :: SetStyle
instance GHC.Show.Show Options.Applicative.Help.Style.Layer
instance GHC.Classes.Ord Options.Applicative.Help.Style.Layer
instance GHC.Classes.Eq Options.Applicative.Help.Style.Layer
instance GHC.Show.Show Options.Applicative.Help.Style.Italicized
instance GHC.Classes.Ord Options.Applicative.Help.Style.Italicized
instance GHC.Classes.Eq Options.Applicative.Help.Style.Italicized
instance GHC.Show.Show Options.Applicative.Help.Style.Color
instance GHC.Classes.Ord Options.Applicative.Help.Style.Color
instance GHC.Classes.Eq Options.Applicative.Help.Style.Color
instance GHC.Show.Show Options.Applicative.Help.Style.SetStyle
instance GHC.Classes.Ord Options.Applicative.Help.Style.SetStyle
instance GHC.Classes.Eq Options.Applicative.Help.Style.SetStyle
instance GHC.Base.Monoid Options.Applicative.Help.Style.SetStyle
instance GHC.Base.Semigroup Options.Applicative.Help.Style.SetStyle

module Options.Applicative.Help.Ann
data Ann
AnnTrace :: Int -> String -> Ann
AnnStyle :: SetStyle -> Ann
class CanAnnotate a

-- | Annotate trace a value
annTrace :: CanAnnotate a => Int -> String -> a -> a
instance GHC.Show.Show Options.Applicative.Help.Ann.Ann
instance GHC.Classes.Eq Options.Applicative.Help.Ann.Ann
instance Options.Applicative.Help.Ann.CanAnnotate (Prettyprinter.Internal.Doc Options.Applicative.Help.Ann.Ann)

module Options.Applicative.Help.Pretty
type Doc = Doc Ann
(.$.) :: Doc -> Doc -> Doc
(</>) :: Doc -> Doc -> Doc

-- | Render flattened text on this line, or start a new line before
--   rendering any text.
--   
--   This will also nest subsequent lines in the group.
groupOrNestLine :: Doc -> Doc

-- | Separate items in an alternative with a pipe.
--   
--   If the first document and the pipe don't fit on the line, then
--   mandatorily flow the next entry onto the following line.
--   
--   The (<a>//</a>) softbreak ensures that if the document does fit on the
--   line, there is at least a space, but it's possible for y to still
--   appear on the next line.
altSep :: Doc -> Doc -> Doc

-- | Printer hacks to get nice indentation for long commands and
--   subcommands.
--   
--   If we're starting this section over the desired width (usually 1/3 of
--   the ribbon), then we will make a line break, indent all of the usage,
--   and go.
--   
--   The ifAtRoot is an interesting clause. If this whole operation is put
--   under a <a>group</a> then the linebreak will disappear; then item d
--   will therefore not be at the starting column, and it won't be indented
--   more.
hangAtIfOver :: Int -> Int -> Doc -> Doc
data Ann
AnnTrace :: Int -> String -> Ann
AnnStyle :: SetStyle -> Ann

-- | Traced version of <a>enclose</a>.
enclose :: Doc -> Doc -> Doc -> Doc

-- | Traced version of <a>parens</a>.
parens :: Doc -> Doc

-- | Traced version of <a>brackets</a>.
brackets :: Doc -> Doc

-- | Traced version of <a>hang</a>.
hang :: Int -> Doc -> Doc

-- | Traced version of <a>indent</a>.
indent :: Int -> Doc -> Doc

-- | Traced version of <a>nest</a>.
nest :: Int -> Doc -> Doc
text :: String -> Doc
plain :: Doc -> Doc
deunderline :: Doc -> Doc
underline :: Doc -> Doc
debold :: Doc -> Doc
bold :: Doc -> Doc
ondullwhite :: Doc -> Doc
onwhite :: Doc -> Doc
ondullcyan :: Doc -> Doc
oncyan :: Doc -> Doc
ondullmagenta :: Doc -> Doc
onmagenta :: Doc -> Doc
ondullblue :: Doc -> Doc
onblue :: Doc -> Doc
ondullyellow :: Doc -> Doc
onyellow :: Doc -> Doc
ondullgreen :: Doc -> Doc
ongreen :: Doc -> Doc
ondullred :: Doc -> Doc
onred :: Doc -> Doc
ondullblack :: Doc -> Doc
onblack :: Doc -> Doc
dullwhite :: Doc -> Doc
white :: Doc -> Doc
dullcyan :: Doc -> Doc
cyan :: Doc -> Doc
dullmagenta :: Doc -> Doc
magenta :: Doc -> Doc
dullblue :: Doc -> Doc
blue :: Doc -> Doc
dullyellow :: Doc -> Doc
yellow :: Doc -> Doc
dullgreen :: Doc -> Doc
green :: Doc -> Doc
dullred :: Doc -> Doc
red :: Doc -> Doc
dullblack :: Doc -> Doc
black :: Doc -> Doc
(</>) :: Doc -> Doc -> Doc
(<$$>) :: Doc -> Doc -> Doc
(<//>) :: Doc -> Doc -> Doc

-- | Traced version of <a>string</a>.
string :: String -> Doc

-- | Determine if the document is empty when rendered
isEffectivelyEmpty :: Doc -> Bool
renderShowS :: SimpleDocStream ann -> ShowS

module Options.Applicative.Help.Chunk

-- | The free monoid on a semigroup <tt>a</tt>.
newtype Chunk a
Chunk :: Maybe a -> Chunk a
[unChunk] :: Chunk a -> Maybe a

-- | Given a semigroup structure on <tt>a</tt>, return a monoid structure
--   on 'Chunk a'.
--   
--   Note that this is <i>not</i> the same as <a>liftA2</a>.
chunked :: (a -> a -> a) -> Chunk a -> Chunk a -> Chunk a

-- | Concatenate a list into a Chunk. <a>listToChunk</a> satisfies:
--   
--   <pre>
--   isEmpty . listToChunk = null
--   listToChunk = mconcat . fmap pure
--   </pre>
listToChunk :: Semigroup a => [a] -> Chunk a

-- | Concatenate two <a>Chunk</a>s with a space in between. If one is
--   empty, this just returns the other one.
--   
--   Unlike <a>&lt;+&gt;</a> for <a>Doc</a>, this operation has a unit
--   element, namely the empty <a>Chunk</a>.
(<<+>>) :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Concatenate two <a>Chunk</a>s with a softline in between. This is
--   exactly like <a>&lt;&lt;+&gt;&gt;</a>, but uses a softline instead of
--   a space.
(<</>>) :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Concatenate <a>Chunk</a>s vertically.
vcatChunks :: [Chunk Doc] -> Chunk Doc

-- | Concatenate <a>Chunk</a>s vertically separated by empty lines.
vsepChunks :: [Chunk Doc] -> Chunk Doc

-- | Whether a <a>Chunk</a> is empty. Note that something like 'pure
--   mempty' is not considered an empty chunk, even though the underlying
--   <a>Doc</a> is empty.
isEmpty :: Chunk a -> Bool

-- | Convert a <a>String</a> into a <a>Chunk</a>. This satisfies:
--   
--   <pre>
--   isEmpty . stringChunk = null
--   extractChunk . stringChunk = string
--   </pre>
stringChunk :: String -> Chunk Doc

-- | Convert a paragraph into a <a>Chunk</a>. The resulting chunk is
--   composed by the words of the original paragraph separated by
--   softlines, so it will be automatically word-wrapped when rendering the
--   underlying document.
--   
--   This satisfies:
--   
--   <pre>
--   isEmpty . paragraph = null . words
--   </pre>
paragraph :: String -> Chunk Doc

-- | Part of a constrained comonad instance.
--   
--   This is the counit of the adjunction between <a>Chunk</a> and the
--   forgetful functor from monoids to semigroups. It satisfies:
--   
--   <pre>
--   extractChunk . pure = id
--   extractChunk . fmap pure = id
--   </pre>
extractChunk :: Monoid a => Chunk a -> a

-- | Display pairs of strings in a table.
tabulate :: Int -> [(Doc, Doc)] -> Chunk Doc

-- | By default, <tt>(<a>chunkFlatAlt</a> x y)</tt> renders as <tt>x</tt>.
--   However when <a>group</a>ed, <tt>y</tt> will be preferred, with
--   <tt>x</tt> as the fallback for the case when <tt>y</tt> doesn't fit.
chunkFlatAlt :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Determine if the document chunk is empty when rendered
chunkIsEffectivelyEmpty :: Chunk Doc -> Bool
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Options.Applicative.Help.Chunk.Chunk a)
instance Options.Applicative.Help.Ann.CanAnnotate (Options.Applicative.Help.Chunk.Chunk Options.Applicative.Help.Pretty.Doc)
instance GHC.Base.Functor Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Applicative Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Alternative Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Monad Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.MonadPlus Options.Applicative.Help.Chunk.Chunk

module Options.Applicative.Help.Types
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpDescription] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpGlobals] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc

-- | Convert a help text to <a>String</a>.
renderHelp :: Int -> ParserHelp -> String
helpText :: ParserHelp -> Doc
instance GHC.Show.Show Options.Applicative.Help.Types.ParserHelp
instance GHC.Base.Monoid Options.Applicative.Help.Types.ParserHelp
instance GHC.Base.Semigroup Options.Applicative.Help.Types.ParserHelp

module Options.Applicative.Types
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: Maybe String -> ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Backtracking -> Int -> Bool -> Bool -> (Doc -> Doc) -> Int -> (Int -> ParserHelp -> String) -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default:
--   Backtrack)
[prefBacktrack] :: ParserPrefs -> Backtracking

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int

-- | when displaying long names in usage and help, use an '=' sign for long
--   names, rather than a single space (default: False)
[prefHelpLongEquals] :: ParserPrefs -> Bool

-- | when displaying subparsers' usage help, show parent options under a
--   "global options" section (default: False)
[prefHelpShowGlobal] :: ParserPrefs -> Bool

-- | how usage overflow over lines is handled
[prefEmbedBriefDesc] :: ParserPrefs -> Doc -> Doc

-- | Indentation width for tables
[prefTabulateFill] :: ParserPrefs -> Int

-- | Render help function
[prefRenderHelp] :: ParserPrefs -> Int -> ParserHelp -> String
data UsageOverflow

-- | usage is aligned to the right of the command
UsageOverflowAlign :: UsageOverflow

-- | usage follows a hanging indent with indent level supplied
UsageOverflowHang :: Int -> UsageOverflow

-- | A single option of a parser.
data Option a
Option :: OptReader a -> OptProperties -> Option a

-- | reader for this option
[optMain] :: Option a -> OptReader a

-- | properties of this option
[optProps] :: Option a -> OptProperties
data OptName
OptShort :: !Char -> OptName
OptLong :: !String -> OptName
isShortName :: OptName -> Bool
isLongName :: OptName -> Bool

-- | An <a>OptReader</a> defines whether an option matches an command line
--   argument.
data OptReader a

-- | option reader
OptReader :: [OptName] -> CReader a -> (String -> ParseError) -> OptReader a

-- | flag reader
FlagReader :: [OptName] -> !a -> OptReader a

-- | argument reader
ArgReader :: CReader a -> OptReader a

-- | command reader
CmdReader :: Maybe String -> [(String, ParserInfo a)] -> OptReader a

-- | Specification for an individual parser option.
data OptProperties
OptProperties :: OptVisibility -> Chunk Doc -> String -> Maybe String -> Bool -> Maybe (Doc -> Doc) -> OptProperties

-- | whether this flag is shown in the brief description
[propVisibility] :: OptProperties -> OptVisibility

-- | help text for this option
[propHelp] :: OptProperties -> Chunk Doc

-- | metavariable for this option
[propMetaVar] :: OptProperties -> String

-- | what to show in the help text as the default
[propShowDefault] :: OptProperties -> Maybe String

-- | whether the option is presented in global options text
[propShowGlobal] :: OptProperties -> Bool

-- | a function to run over the brief description
[propDescMod] :: OptProperties -> Maybe (Doc -> Doc)

-- | Visibility of an option in the help text.
data OptVisibility

-- | does not appear in the help text at all
Internal :: OptVisibility

-- | only visible in the full description
Hidden :: OptVisibility

-- | visible both in the full and brief descriptions
Visible :: OptVisibility
data Backtracking
Backtrack :: Backtracking
NoBacktrack :: Backtracking
SubparserInline :: Backtracking

-- | A newtype over 'ReaderT String Except', used by option readers.
newtype ReadM a
ReadM :: ReaderT String (Except ParseError) a -> ReadM a
[unReadM] :: ReadM a -> ReaderT String (Except ParseError) a

-- | Return the value being read.
readerAsk :: ReadM String

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a
data CReader a
CReader :: Completer -> ReadM a -> CReader a
[crCompleter] :: CReader a -> Completer
[crReader] :: CReader a -> ReadM a

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a
NilP :: Maybe a -> Parser a
OptP :: Option a -> Parser a
MultP :: Parser (x -> a) -> Parser x -> Parser a
AltP :: Parser a -> Parser a -> Parser a
BindP :: Parser x -> (x -> Parser a) -> Parser a
newtype ParserM r
ParserM :: (forall x. (r -> Parser x) -> Parser x) -> ParserM r
[runParserM] :: ParserM r -> forall x. (r -> Parser x) -> Parser x

-- | A shell complete function.
newtype Completer
Completer :: (String -> IO [String]) -> Completer
[runCompleter] :: Completer -> String -> IO [String]

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a
type Args = [String]

-- | Policy for how to handle options within the parse
data ArgPolicy

-- | The default policy, options and arguments can be interspersed. A `--`
--   option can be passed to ensure all following commands are treated as
--   arguments.
Intersperse :: ArgPolicy

-- | Options must all come before arguments, once a single positional
--   argument or subcommand is parsed, all remaining arguments are treated
--   as positionals. A `--` option can be passed if the first positional
--   one needs starts with <a>-</a>.
NoIntersperse :: ArgPolicy

-- | No options are parsed at all, all arguments are treated as
--   positionals. Is the policy used after `--` is encountered.
AllPositionals :: ArgPolicy

-- | Options and arguments can be interspersed, but if a given option is
--   not found, it is treated as a positional argument. This is sometimes
--   useful if one is passing through most options to another tool, but are
--   supplying just a few of their own options.
ForwardOptions :: ArgPolicy
newtype ArgumentReachability
ArgumentReachability :: Bool -> ArgumentReachability

-- | If the result is a positional, if it can't be accessed in the current
--   parser position ( first arg )
[argumentIsUnreachable] :: ArgumentReachability -> Bool

-- | This type encapsulates whether an <a>AltNode</a> of an <a>OptTree</a>
--   should be displayed with brackets around it.
data AltNodeType
MarkDefault :: AltNodeType
NoDefault :: AltNodeType
data OptTree a
Leaf :: a -> OptTree a
MultNode :: [OptTree a] -> OptTree a
AltNode :: AltNodeType -> [OptTree a] -> OptTree a
BindNode :: OptTree a -> OptTree a
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpDescription] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpGlobals] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
data SomeParser
SomeParser :: Parser a -> SomeParser

-- | Subparser context, containing the <tt>name</tt> of the subparser and
--   its parser info. Used by parserFailure to display relevant usage
--   information when parsing inside a subparser fails.
data Context
Context :: String -> ParserInfo a -> Context
data IsCmdStart
CmdStart :: IsCmdStart
CmdCont :: IsCmdStart
fromM :: ParserM a -> Parser a
oneM :: Parser a -> ParserM a
manyM :: Parser a -> ParserM [a]
someM :: Parser a -> ParserM [a]
filterOptional :: OptTree a -> OptTree a
optVisibility :: Option a -> OptVisibility
optMetaVar :: Option a -> String
optHelp :: Option a -> Chunk Doc
optShowDefault :: Option a -> Maybe String
optDescMod :: Option a -> Maybe (Doc -> Doc)
instance GHC.Show.Show Options.Applicative.Types.IsCmdStart
instance GHC.Show.Show Options.Applicative.Types.Backtracking
instance GHC.Classes.Eq Options.Applicative.Types.Backtracking
instance GHC.Show.Show Options.Applicative.Types.UsageOverflow
instance GHC.Classes.Eq Options.Applicative.Types.UsageOverflow
instance GHC.Show.Show Options.Applicative.Types.OptName
instance GHC.Classes.Ord Options.Applicative.Types.OptName
instance GHC.Classes.Eq Options.Applicative.Types.OptName
instance GHC.Show.Show Options.Applicative.Types.OptVisibility
instance GHC.Classes.Ord Options.Applicative.Types.OptVisibility
instance GHC.Classes.Eq Options.Applicative.Types.OptVisibility
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Types.ParserResult a)
instance GHC.Show.Show Options.Applicative.Types.ArgPolicy
instance GHC.Classes.Ord Options.Applicative.Types.ArgPolicy
instance GHC.Classes.Eq Options.Applicative.Types.ArgPolicy
instance GHC.Show.Show Options.Applicative.Types.ArgumentReachability
instance GHC.Classes.Eq Options.Applicative.Types.ArgumentReachability
instance GHC.Classes.Eq Options.Applicative.Types.AltNodeType
instance GHC.Show.Show Options.Applicative.Types.AltNodeType
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Types.OptTree a)
instance GHC.Base.Monad Options.Applicative.Types.ParserM
instance GHC.Base.Functor Options.Applicative.Types.ParserM
instance GHC.Base.Applicative Options.Applicative.Types.ParserM
instance GHC.Base.Monoid Options.Applicative.Types.ParseError
instance GHC.Base.Semigroup Options.Applicative.Types.ParseError
instance GHC.Base.Functor Options.Applicative.Types.ParserInfo
instance GHC.Show.Show (Options.Applicative.Types.Option a)
instance GHC.Base.Functor Options.Applicative.Types.Option
instance GHC.Base.Functor Options.Applicative.Types.ReadM
instance GHC.Base.Applicative Options.Applicative.Types.ReadM
instance GHC.Base.Alternative Options.Applicative.Types.ReadM
instance GHC.Base.Monad Options.Applicative.Types.ReadM
instance Control.Monad.Fail.MonadFail Options.Applicative.Types.ReadM
instance GHC.Base.MonadPlus Options.Applicative.Types.ReadM
instance GHC.Base.Functor Options.Applicative.Types.CReader
instance GHC.Base.Functor Options.Applicative.Types.OptReader
instance GHC.Base.Functor Options.Applicative.Types.Parser
instance GHC.Base.Applicative Options.Applicative.Types.Parser
instance GHC.Base.Alternative Options.Applicative.Types.Parser
instance GHC.Base.Functor Options.Applicative.Types.ParserResult
instance GHC.Base.Applicative Options.Applicative.Types.ParserResult
instance GHC.Base.Monad Options.Applicative.Types.ParserResult
instance GHC.Show.Show h => GHC.Show.Show (Options.Applicative.Types.ParserFailure h)
instance GHC.Base.Functor Options.Applicative.Types.ParserFailure
instance GHC.Show.Show Options.Applicative.Types.CompletionResult
instance GHC.Base.Semigroup Options.Applicative.Types.Completer
instance GHC.Base.Monoid Options.Applicative.Types.Completer
instance GHC.Show.Show Options.Applicative.Types.OptProperties

module Options.Applicative.NonEmpty

-- | Sequences an action one or more times.
--   
--   Functionally identical to <a>some1</a>, but is preferred as it gives a
--   nicer help text.
some1 :: Parser a -> Parser (NonEmpty a)

module Options.Applicative.Internal
data P a
class (Alternative m, MonadPlus m) => MonadP m
enterContext :: MonadP m => String -> ParserInfo a -> m ()
exitContext :: MonadP m => m ()
getPrefs :: MonadP m => m ParserPrefs
missingArgP :: MonadP m => ParseError -> Completer -> m a
errorP :: MonadP m => ParseError -> m a
exitP :: MonadP m => IsCmdStart -> ArgPolicy -> Parser b -> Maybe a -> m a
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: Maybe String -> ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError
uncons :: [a] -> Maybe (a, [a])
hoistMaybe :: MonadPlus m => Maybe a -> m a
hoistEither :: MonadP m => Either ParseError a -> m a
runReadM :: MonadP m => ReadM a -> String -> m a
withReadM :: (String -> String) -> ReadM a -> ReadM a
runP :: P a -> ParserPrefs -> (Either ParseError a, [Context])
data Completion a
runCompletion :: Completion r -> ParserPrefs -> Maybe (Either (SomeParser, ArgPolicy) Completer)
contextNames :: [Context] -> [String]
data ListT m a
takeListT :: Monad m => Int -> ListT m a -> ListT m a
runListT :: Monad m => ListT m a -> m [a]
hoistList :: Alternative m => [a] -> m a
data NondetT m a
cut :: Monad m => NondetT m ()
(<!>) :: Monad m => NondetT m a -> NondetT m a -> NondetT m a
disamb :: Monad m => Bool -> NondetT m a -> m (Maybe a)
instance GHC.Base.Monad m => GHC.Base.Functor (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Options.Applicative.Internal.NondetT m)
instance Control.Monad.Trans.Class.MonadTrans Options.Applicative.Internal.NondetT
instance GHC.Base.Monad m => GHC.Base.Functor (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Options.Applicative.Internal.ListT m)
instance Control.Monad.Trans.Class.MonadTrans Options.Applicative.Internal.ListT
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Options.Applicative.Internal.ListT m)
instance GHC.Base.Functor Options.Applicative.Internal.Completion
instance GHC.Base.Applicative Options.Applicative.Internal.Completion
instance GHC.Base.Alternative Options.Applicative.Internal.Completion
instance GHC.Base.Monad Options.Applicative.Internal.Completion
instance GHC.Base.MonadPlus Options.Applicative.Internal.Completion
instance Options.Applicative.Internal.MonadP Options.Applicative.Internal.Completion
instance GHC.Base.Functor Options.Applicative.Internal.ComplResult
instance GHC.Base.Applicative Options.Applicative.Internal.ComplResult
instance GHC.Base.Monad Options.Applicative.Internal.ComplResult
instance GHC.Base.Functor Options.Applicative.Internal.P
instance GHC.Base.Applicative Options.Applicative.Internal.P
instance GHC.Base.Alternative Options.Applicative.Internal.P
instance GHC.Base.Monad Options.Applicative.Internal.P
instance GHC.Base.MonadPlus Options.Applicative.Internal.P
instance Options.Applicative.Internal.MonadP Options.Applicative.Internal.P

module Options.Applicative.Common

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a

-- | Create a parser composed of a single option.
liftOpt :: Option a -> Parser a
showOption :: OptName -> String

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Backtracking -> Int -> Bool -> Bool -> (Doc -> Doc) -> Int -> (Int -> ParserHelp -> String) -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default:
--   Backtrack)
[prefBacktrack] :: ParserPrefs -> Backtracking

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int

-- | when displaying long names in usage and help, use an '=' sign for long
--   names, rather than a single space (default: False)
[prefHelpLongEquals] :: ParserPrefs -> Bool

-- | when displaying subparsers' usage help, show parent options under a
--   "global options" section (default: False)
[prefHelpShowGlobal] :: ParserPrefs -> Bool

-- | how usage overflow over lines is handled
[prefEmbedBriefDesc] :: ParserPrefs -> Doc -> Doc

-- | Indentation width for tables
[prefTabulateFill] :: ParserPrefs -> Int

-- | Render help function
[prefRenderHelp] :: ParserPrefs -> Int -> ParserHelp -> String
runParserInfo :: MonadP m => ParserInfo a -> Args -> m a
runParserFully :: MonadP m => ArgPolicy -> Parser a -> Args -> m a
runParserStep :: MonadP m => ArgPolicy -> Parser a -> String -> Args -> m (Maybe (Parser a), Args)

-- | Apply a <a>Parser</a> to a command line, and return a result and
--   leftover arguments. This function returns an error if any parsing
--   error occurs, or if any options are missing and don't have a default
--   value.
runParser :: MonadP m => ArgPolicy -> IsCmdStart -> Parser a -> Args -> m (a, Args)

-- | The default value of a <a>Parser</a>. This function returns an error
--   if any of the options don't have a default value.
evalParser :: Parser a -> Maybe a

-- | Map a polymorphic function over all the options of a parser, and
--   collect the results in a list.
mapParser :: (forall x. ArgumentReachability -> Option x -> b) -> Parser a -> [b]

-- | Like <a>mapParser</a>, but collect the results in a tree structure.
treeMapParser :: (forall x. ArgumentReachability -> Option x -> b) -> Parser a -> OptTree b
optionNames :: OptReader a -> [OptName]

module Options.Applicative.Help.Core

-- | Generate descriptions for commands.
cmdDesc :: ParserPrefs -> Parser a -> [(Maybe String, Chunk Doc)]

-- | Generate a brief help text for a parser.
briefDesc :: ParserPrefs -> Parser a -> Chunk Doc

-- | Generate a brief help text for a parser, only including mandatory
--   options and arguments.
missingDesc :: ParserPrefs -> Parser a -> Chunk Doc

-- | Generate a full help text for a parser
fullDesc :: ParserPrefs -> Parser a -> Chunk Doc

-- | Generate a help text for the parser, showing only what is relevant in
--   the "Global options: section"
globalDesc :: ParserPrefs -> Parser a -> Chunk Doc
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpDescription] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpGlobals] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
errorHelp :: Chunk Doc -> ParserHelp
headerHelp :: Chunk Doc -> ParserHelp
suggestionsHelp :: Chunk Doc -> ParserHelp
usageHelp :: Chunk Doc -> ParserHelp
descriptionHelp :: Chunk Doc -> ParserHelp
bodyHelp :: Chunk Doc -> ParserHelp
footerHelp :: Chunk Doc -> ParserHelp
globalsHelp :: Chunk Doc -> ParserHelp

-- | Generate the help text for a program.
parserHelp :: ParserPrefs -> Parser a -> ParserHelp

-- | Generate option summary.
parserUsage :: ParserPrefs -> Parser a -> String -> Doc
parserGlobals :: ParserPrefs -> Parser a -> ParserHelp
instance GHC.Show.Show Options.Applicative.Help.Core.Parenthetic
instance GHC.Classes.Ord Options.Applicative.Help.Core.Parenthetic
instance GHC.Classes.Eq Options.Applicative.Help.Core.Parenthetic

module Options.Applicative.Help

module Options.Applicative.Builder.Internal

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a
Mod :: (f a -> f a) -> DefaultProp a -> (OptProperties -> OptProperties) -> Mod f a
class HasName f
name :: HasName f => OptName -> f a -> f a
class HasCompleter f
modCompleter :: HasCompleter f => (Completer -> Completer) -> f a -> f a
class HasValue f
hasValueDummy :: HasValue f => f a -> ()
class HasMetavar f
hasMetavarDummy :: HasMetavar f => f a -> ()
data OptionFields a
OptionFields :: [OptName] -> Completer -> (String -> ParseError) -> OptionFields a
[optNames] :: OptionFields a -> [OptName]
[optCompleter] :: OptionFields a -> Completer
[optNoArgError] :: OptionFields a -> String -> ParseError
data FlagFields a
FlagFields :: [OptName] -> a -> FlagFields a
[flagNames] :: FlagFields a -> [OptName]
[flagActive] :: FlagFields a -> a
data CommandFields a
CommandFields :: [(String, ParserInfo a)] -> Maybe String -> CommandFields a
[cmdCommands] :: CommandFields a -> [(String, ParserInfo a)]
[cmdGroup] :: CommandFields a -> Maybe String
data ArgumentFields a
ArgumentFields :: Completer -> ArgumentFields a
[argCompleter] :: ArgumentFields a -> Completer
data DefaultProp a
DefaultProp :: Maybe a -> Maybe (a -> String) -> DefaultProp a
optionMod :: (OptProperties -> OptProperties) -> Mod f a
fieldMod :: (f a -> f a) -> Mod f a

-- | Base default properties.
baseProps :: OptProperties
mkCommand :: Mod CommandFields a -> (Maybe String, [(String, ParserInfo a)])
mkParser :: DefaultProp a -> (OptProperties -> OptProperties) -> OptReader a -> Parser a
mkOption :: DefaultProp a -> (OptProperties -> OptProperties) -> OptReader a -> Option a
mkProps :: DefaultProp a -> (OptProperties -> OptProperties) -> OptProperties

-- | Hide this option completely from the help text
--   
--   Use <tt>hidden</tt> if the option should remain visible in the full
--   description.
internal :: Mod f a

-- | Suppress this option from appearing in global options
noGlobal :: Mod f a
instance GHC.Base.Monoid (Options.Applicative.Builder.Internal.Mod f a)
instance GHC.Base.Semigroup (Options.Applicative.Builder.Internal.Mod f a)
instance GHC.Base.Monoid (Options.Applicative.Builder.Internal.DefaultProp a)
instance GHC.Base.Semigroup (Options.Applicative.Builder.Internal.DefaultProp a)
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.CommandFields
instance Options.Applicative.Builder.Internal.HasValue Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasValue Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasCompleter Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasCompleter Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasName Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasName Options.Applicative.Builder.Internal.FlagFields

module Options.Applicative.Builder.Completer

-- | A shell complete function.
data Completer

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer

-- | Create a <a>Completer</a> from an IO action
listIOCompleter :: IO [String] -> Completer

-- | Create a <a>Completer</a> from a constant list of strings.
listCompleter :: [String] -> Completer

-- | Run a compgen completion action.
--   
--   Common actions include <tt>file</tt> and <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
bashCompleter :: String -> Completer

-- | Strongly quote the string we pass to compgen.
--   
--   We need to do this so bash doesn't expand out any ~ or other chars we
--   want to complete on, or emit an end of line error when seeking the
--   close to the quote.
requote :: String -> String

module Options.Applicative.Builder

-- | Builder for a command parser. The <a>command</a> modifier can be used
--   to specify individual commands.
--   
--   By default, sub-parsers allow backtracking to their parent's options
--   when they are completed. To allow full mixing of parent and sub-parser
--   options, turn on <a>subparserInline</a>; otherwise, to disable
--   backtracking completely, use <a>noBacktrack</a>.
subparser :: Mod CommandFields a -> Parser a

-- | Builder for a <a>String</a> argument.
strArgument :: IsString s => Mod ArgumentFields s -> Parser s

-- | Builder for an argument parser.
argument :: ReadM a -> Mod ArgumentFields a -> Parser a

-- | Builder for a flag parser.
--   
--   A flag that switches from a "default value" to an "active value" when
--   encountered. For a simple boolean value, use <a>switch</a> instead.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
flag :: a -> a -> Mod FlagFields a -> Parser a

-- | Builder for a flag parser without a default value.
--   
--   Same as <a>flag</a>, but with no default value. In particular, this
--   flag will never parse successfully by itself.
--   
--   It still makes sense to use it as part of a composite parser. For
--   example
--   
--   <pre>
--   length &lt;$&gt; many (flag' () (short 't'))
--   </pre>
--   
--   is a parser that counts the number of "-t" arguments on the command
--   line, alternatively
--   
--   <pre>
--   flag' True (long "on") &lt;|&gt; flag' False (long "off")
--   </pre>
--   
--   will require the user to enter '--on' or '--off' on the command line.
flag' :: a -> Mod FlagFields a -> Parser a

-- | Builder for a boolean flag.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
--   
--   <pre>
--   switch = flag False True
--   </pre>
switch :: Mod FlagFields Bool -> Parser Bool

-- | An option that always fails.
--   
--   When this option is encountered, the option parser immediately aborts
--   with the given parse error. If you simply want to output a message,
--   use <a>infoOption</a> instead.
abortOption :: ParseError -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | An option that always fails and displays a message.
infoOption :: String -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | Builder for an option taking a <a>String</a> argument.
strOption :: IsString s => Mod OptionFields s -> Parser s

-- | Builder for an option using the given reader.
--   
--   This is a regular option, and should always have either a
--   <tt>long</tt> or <tt>short</tt> name specified in the modifiers (or
--   both).
--   
--   <pre>
--   nameParser = option str ( long "name" &lt;&gt; short 'n' )
--   </pre>
option :: ReadM a -> Mod OptionFields a -> Parser a

-- | Specify a short name for an option.
short :: HasName f => Char -> Mod f a

-- | Specify a long name for an option.
long :: HasName f => String -> Mod f a

-- | Specify the help text for an option.
help :: String -> Mod f a

-- | Specify the help text for an option as a 'Prettyprinter.Doc AnsiStyle'
--   value.
helpDoc :: Doc -> Mod f a

-- | Specify a default value for an option.
--   
--   <i>Note</i>: Because this modifier means the parser will never fail,
--   do not use it with combinators such as <a>some</a> or <a>many</a>, as
--   these combinators continue until a failure occurs. Careless use will
--   thus result in a hang.
--   
--   To display the default value, combine with showDefault or
--   showDefaultWith.
value :: HasValue f => a -> Mod f a

-- | Specify a function to show the default value for an option.
showDefaultWith :: (a -> String) -> Mod f a

-- | Show the default value for this option using its <a>Show</a> instance.
showDefault :: Show a => Mod f a

-- | Specify a metavariable for the argument.
--   
--   Metavariables have no effect on the actual parser, and only serve to
--   specify the symbolic name for an argument to be displayed in the help
--   text.
metavar :: HasMetavar f => String -> Mod f a

-- | Specify the error to display when no argument is provided to this
--   option.
noArgError :: ParseError -> Mod OptionFields a
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: Maybe String -> ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError

-- | Hide this option from the brief description.
--   
--   Use <a>internal</a> to hide the option from the help text too.
hidden :: Mod f a

-- | Hide this option completely from the help text
--   
--   Use <tt>hidden</tt> if the option should remain visible in the full
--   description.
internal :: Mod f a

-- | Apply a function to the option description in the usage text.
--   
--   <pre>
--   import Options.Applicative.Help
--   flag' () (short 't' &lt;&gt; style (annotate bold))
--   </pre>
--   
--   <i>NOTE</i>: This builder is more flexible than its name and example
--   allude. One of the motivating examples for its addition was to use
--   <a>const</a> to completely replace the usage text of an option.
style :: (Doc -> Doc) -> Mod f a

-- | Add a command to a subparser option.
--   
--   Suggested usage for multiple commands is to add them to a single
--   subparser. e.g.
--   
--   <pre>
--   sample :: Parser Sample
--   sample = subparser
--          ( command "hello"
--            (info hello (progDesc "Print greeting"))
--         &lt;&gt; command "goodbye"
--            (info goodbye (progDesc "Say goodbye"))
--          )
--   </pre>
command :: String -> ParserInfo a -> Mod CommandFields a

-- | Add a description to a group of commands.
--   
--   Advanced feature for separating logical groups of commands on the
--   parse line.
--   
--   If using the same <a>metavar</a> for each group of commands, it may
--   yield a more attractive usage text combined with <a>hidden</a> for
--   some groups.
commandGroup :: String -> Mod CommandFields a

-- | Add a list of possible completion values.
completeWith :: HasCompleter f => [String] -> Mod f a

-- | Add a bash completion action. Common actions include <tt>file</tt> and
--   <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
action :: HasCompleter f => String -> Mod f a

-- | Add a completer to an argument.
--   
--   A completer is a function String -&gt; IO String which, given a
--   partial argument, returns all possible completions for that argument.
completer :: HasCompleter f => Completer -> Mod f a

-- | Trivial option modifier.
idm :: Monoid m => m

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | <a>Option</a> reader based on the <a>Read</a> type class.
auto :: Read a => ReadM a

-- | String <a>Option</a> reader.
--   
--   Polymorphic over the <a>IsString</a> type class since 0.14.
str :: IsString s => ReadM s

-- | Convert a function producing a <a>Maybe</a> into a reader.
maybeReader :: (String -> Maybe a) -> ReadM a

-- | Convert a function producing an <a>Either</a> into a reader.
--   
--   As an example, one can create a ReadM from an attoparsec Parser easily
--   with
--   
--   <pre>
--   import qualified Data.Attoparsec.Text as A
--   import qualified Data.Text as T
--   attoparsecReader :: A.Parser a -&gt; ReadM a
--   attoparsecReader p = eitherReader (A.parseOnly p . T.pack)
--   </pre>
eitherReader :: (String -> Either String a) -> ReadM a

-- | Null <a>Option</a> reader. All arguments will fail validation.
disabled :: ReadM a

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a

-- | Modifier for <a>ParserInfo</a>.
data InfoMod a

-- | Show a full description in the help text of this parser (default).
fullDesc :: InfoMod a

-- | Only show a brief description in the help text of this parser.
briefDesc :: InfoMod a

-- | Specify a header for this parser.
header :: String -> InfoMod a

-- | Specify a header for this parser as a 'Prettyprinter.Doc AnsiStyle'
--   value.
headerDoc :: Maybe Doc -> InfoMod a

-- | Specify a footer for this parser.
footer :: String -> InfoMod a

-- | Specify a footer for this parser as a 'Prettyprinter.Doc AnsiStyle'
--   value.
footerDoc :: Maybe Doc -> InfoMod a

-- | Specify a short program description.
progDesc :: String -> InfoMod a

-- | Specify a short program description as a 'Prettyprinter.Doc AnsiStyle'
--   value.
progDescDoc :: Maybe Doc -> InfoMod a

-- | Specify an exit code if a parse error occurs.
failureCode :: Int -> InfoMod a

-- | Disable parsing of regular options after arguments. After a positional
--   argument is parsed, all remaining options and arguments will be
--   treated as a positional arguments. Not recommended in general as users
--   often expect to be able to freely intersperse regular options and
--   flags within command line options.
noIntersperse :: InfoMod a

-- | Intersperse matched options and arguments normally, but allow
--   unmatched options to be treated as positional arguments. This is
--   sometimes useful if one is wrapping a third party cli tool and needs
--   to pass options through, while also providing a handful of their own
--   options. Not recommended in general as typos by the user may not yield
--   a parse error and cause confusion.
forwardOptions :: InfoMod a

-- | Disable parsing of regular options completely. All options and
--   arguments will be treated as a positional arguments. Obviously not
--   recommended in general as options will be unreachable. This is the
--   same behaviour one sees after the "--" pseudo-argument.
allPositional :: InfoMod a

-- | Create a <a>ParserInfo</a> given a <a>Parser</a> and a modifier.
info :: Parser a -> InfoMod a -> ParserInfo a
data PrefsMod

-- | Include a suffix to attach to the metavar when multiple values can be
--   entered.
multiSuffix :: String -> PrefsMod

-- | Turn on disambiguation.
--   
--   See
--   <a>https://github.com/pcapriotti/optparse-applicative#disambiguation</a>
disambiguate :: PrefsMod

-- | Show full help text on any error.
showHelpOnError :: PrefsMod

-- | Show the help text if the user enters only the program name or
--   subcommand.
--   
--   This will suppress a "Missing:" error and show the full usage instead
--   if a user just types the name of the program.
showHelpOnEmpty :: PrefsMod

-- | Turn off backtracking after subcommand is parsed.
noBacktrack :: PrefsMod

-- | Allow full mixing of subcommand and parent arguments by inlining
--   selected subparsers into the parent parser.
--   
--   <i>NOTE:</i> When this option is used, preferences for the subparser
--   which effect the parser behaviour (such as noIntersperse) are ignored.
subparserInline :: PrefsMod

-- | Set the maximum width of the generated help text.
columns :: Int -> PrefsMod

-- | Show equals sign, rather than space, in usage and help text for
--   options with long names.
helpLongEquals :: PrefsMod

-- | Align usage overflow to the right
helpEmbedBriefDesc :: (Doc -> Doc) -> PrefsMod

-- | Show global help information in subparser usage.
helpShowGlobals :: PrefsMod

-- | Set fill width in help text presentation.
helpIndent :: Int -> PrefsMod

-- | Custom render function
helpRenderHelp :: (Int -> ParserHelp -> String) -> PrefsMod

-- | Create a <a>ParserPrefs</a> given a modifier
prefs :: PrefsMod -> ParserPrefs

-- | Default preferences.
defaultPrefs :: ParserPrefs

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a

-- | A newtype over 'ReaderT String Except', used by option readers.
data ReadM a
data OptionFields a
data FlagFields a
data ArgumentFields a
data CommandFields a
class HasName f
class HasCompleter f
class HasValue f
class HasMetavar f
instance GHC.Base.Monoid Options.Applicative.Builder.PrefsMod
instance GHC.Base.Semigroup Options.Applicative.Builder.PrefsMod
instance GHC.Base.Monoid (Options.Applicative.Builder.InfoMod a)
instance GHC.Base.Semigroup (Options.Applicative.Builder.InfoMod a)


-- | You don't need to import this module to enable bash completion.
--   
--   See <a>the wiki</a> for more information on bash completion.
module Options.Applicative.BashCompletion
bashCompletionParser :: ParserInfo a -> ParserPrefs -> Parser CompletionResult

-- | Generated bash shell completion script
bashCompletionScript :: String -> String -> String

-- | Generated fish shell completion script
fishCompletionScript :: String -> String -> String

-- | Generated zsh shell completion script
zshCompletionScript :: String -> String -> String
instance GHC.Show.Show Options.Applicative.BashCompletion.Richness
instance GHC.Classes.Ord Options.Applicative.BashCompletion.Richness
instance GHC.Classes.Eq Options.Applicative.BashCompletion.Richness

module Options.Applicative.Extra

-- | A hidden "helper" option which always fails.
--   
--   A common usage pattern is to apply this applicatively when creating a
--   <a>ParserInfo</a>
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; helper) mempty
--   </pre>
helper :: Parser (a -> a)

-- | Like helper, but with a minimal set of modifiers that can be extended
--   as desired.
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; helperWith (mconcat [
--            long "help",
--            short 'h',
--            help "Show this help text",
--            hidden
--          ])) mempty
--   </pre>
helperWith :: Mod OptionFields (a -> a) -> Parser (a -> a)

-- | Builder for a command parser with a "helper" option attached. Used in
--   the same way as <a>subparser</a>, but includes a "--help|-h" inside
--   the subcommand.
hsubparser :: Mod CommandFields a -> Parser a

-- | A hidden "--version" option that displays the version.
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; simpleVersioner "v1.2.3") mempty
--   </pre>
simpleVersioner :: String -> Parser (a -> a)

-- | Run a program description.
--   
--   Parse command line arguments. Display help text and exit if any parse
--   error occurs.
execParser :: ParserInfo a -> IO a

-- | Run a program description with custom preferences.
customExecParser :: ParserPrefs -> ParserInfo a -> IO a

-- | The most general way to run a program description in pure code.
execParserPure :: ParserPrefs -> ParserInfo a -> [String] -> ParserResult a

-- | Extract the actual result from a <a>ParserResult</a> value.
--   
--   This function returns <a>Nothing</a> in case of errors. Possible error
--   messages or completion actions are simply discarded.
--   
--   If you want to display error messages and invoke completion actions
--   appropriately, use <a>handleParseResult</a> instead.
getParseResult :: ParserResult a -> Maybe a

-- | Handle <a>ParserResult</a>.
handleParseResult :: ParserResult a -> IO a

-- | Generate a <a>ParserFailure</a> from a <a>ParseError</a> in a given
--   <a>Context</a>.
--   
--   This function can be used, for example, to show the help text for a
--   parser:
--   
--   <pre>
--   handleParseResult . Failure $ parserFailure pprefs pinfo (ShowHelpText Nothing) mempty
--   </pre>
parserFailure :: ParserPrefs -> ParserInfo a -> ParseError -> [Context] -> ParserFailure ParserHelp
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
renderFailure' :: ParserPrefs -> ParserFailure ParserHelp -> String -> (String, ExitCode)
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Backtracking -> Int -> Bool -> Bool -> (Doc -> Doc) -> Int -> (Int -> ParserHelp -> String) -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default:
--   Backtrack)
[prefBacktrack] :: ParserPrefs -> Backtracking

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int

-- | when displaying long names in usage and help, use an '=' sign for long
--   names, rather than a single space (default: False)
[prefHelpLongEquals] :: ParserPrefs -> Bool

-- | when displaying subparsers' usage help, show parent options under a
--   "global options" section (default: False)
[prefHelpShowGlobal] :: ParserPrefs -> Bool

-- | how usage overflow over lines is handled
[prefEmbedBriefDesc] :: ParserPrefs -> Doc -> Doc

-- | Indentation width for tables
[prefTabulateFill] :: ParserPrefs -> Int

-- | Render help function
[prefRenderHelp] :: ParserPrefs -> Int -> ParserHelp -> String
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String

module Options.Applicative

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a

-- | Builder for a flag parser.
--   
--   A flag that switches from a "default value" to an "active value" when
--   encountered. For a simple boolean value, use <a>switch</a> instead.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
flag :: a -> a -> Mod FlagFields a -> Parser a

-- | Builder for a flag parser without a default value.
--   
--   Same as <a>flag</a>, but with no default value. In particular, this
--   flag will never parse successfully by itself.
--   
--   It still makes sense to use it as part of a composite parser. For
--   example
--   
--   <pre>
--   length &lt;$&gt; many (flag' () (short 't'))
--   </pre>
--   
--   is a parser that counts the number of "-t" arguments on the command
--   line, alternatively
--   
--   <pre>
--   flag' True (long "on") &lt;|&gt; flag' False (long "off")
--   </pre>
--   
--   will require the user to enter '--on' or '--off' on the command line.
flag' :: a -> Mod FlagFields a -> Parser a

-- | Builder for a boolean flag.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
--   
--   <pre>
--   switch = flag False True
--   </pre>
switch :: Mod FlagFields Bool -> Parser Bool

-- | Builder for an option taking a <a>String</a> argument.
strOption :: IsString s => Mod OptionFields s -> Parser s

-- | Builder for an option using the given reader.
--   
--   This is a regular option, and should always have either a
--   <tt>long</tt> or <tt>short</tt> name specified in the modifiers (or
--   both).
--   
--   <pre>
--   nameParser = option str ( long "name" &lt;&gt; short 'n' )
--   </pre>
option :: ReadM a -> Mod OptionFields a -> Parser a

-- | Builder for a <a>String</a> argument.
strArgument :: IsString s => Mod ArgumentFields s -> Parser s

-- | Builder for an argument parser.
argument :: ReadM a -> Mod ArgumentFields a -> Parser a

-- | Builder for a command parser. The <a>command</a> modifier can be used
--   to specify individual commands.
--   
--   By default, sub-parsers allow backtracking to their parent's options
--   when they are completed. To allow full mixing of parent and sub-parser
--   options, turn on <a>subparserInline</a>; otherwise, to disable
--   backtracking completely, use <a>noBacktrack</a>.
subparser :: Mod CommandFields a -> Parser a

-- | Builder for a command parser with a "helper" option attached. Used in
--   the same way as <a>subparser</a>, but includes a "--help|-h" inside
--   the subcommand.
hsubparser :: Mod CommandFields a -> Parser a

-- | An option that always fails.
--   
--   When this option is encountered, the option parser immediately aborts
--   with the given parse error. If you simply want to output a message,
--   use <a>infoOption</a> instead.
abortOption :: ParseError -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | An option that always fails and displays a message.
infoOption :: String -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | A hidden "helper" option which always fails.
--   
--   A common usage pattern is to apply this applicatively when creating a
--   <a>ParserInfo</a>
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; helper) mempty
--   </pre>
helper :: Parser (a -> a)

-- | A hidden "--version" option that displays the version.
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; simpleVersioner "v1.2.3") mempty
--   </pre>
simpleVersioner :: String -> Parser (a -> a)

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a

-- | Specify a short name for an option.
short :: HasName f => Char -> Mod f a

-- | Specify a long name for an option.
long :: HasName f => String -> Mod f a

-- | Specify the help text for an option.
help :: String -> Mod f a

-- | Specify the help text for an option as a 'Prettyprinter.Doc AnsiStyle'
--   value.
helpDoc :: Doc -> Mod f a

-- | Specify a default value for an option.
--   
--   <i>Note</i>: Because this modifier means the parser will never fail,
--   do not use it with combinators such as <a>some</a> or <a>many</a>, as
--   these combinators continue until a failure occurs. Careless use will
--   thus result in a hang.
--   
--   To display the default value, combine with showDefault or
--   showDefaultWith.
value :: HasValue f => a -> Mod f a

-- | Specify a function to show the default value for an option.
showDefaultWith :: (a -> String) -> Mod f a

-- | Show the default value for this option using its <a>Show</a> instance.
showDefault :: Show a => Mod f a

-- | Specify a metavariable for the argument.
--   
--   Metavariables have no effect on the actual parser, and only serve to
--   specify the symbolic name for an argument to be displayed in the help
--   text.
metavar :: HasMetavar f => String -> Mod f a

-- | Specify the error to display when no argument is provided to this
--   option.
noArgError :: ParseError -> Mod OptionFields a

-- | Hide this option from the brief description.
--   
--   Use <a>internal</a> to hide the option from the help text too.
hidden :: Mod f a

-- | Hide this option completely from the help text
--   
--   Use <tt>hidden</tt> if the option should remain visible in the full
--   description.
internal :: Mod f a

-- | Apply a function to the option description in the usage text.
--   
--   <pre>
--   import Options.Applicative.Help
--   flag' () (short 't' &lt;&gt; style (annotate bold))
--   </pre>
--   
--   <i>NOTE</i>: This builder is more flexible than its name and example
--   allude. One of the motivating examples for its addition was to use
--   <a>const</a> to completely replace the usage text of an option.
style :: (Doc -> Doc) -> Mod f a

-- | Add a command to a subparser option.
--   
--   Suggested usage for multiple commands is to add them to a single
--   subparser. e.g.
--   
--   <pre>
--   sample :: Parser Sample
--   sample = subparser
--          ( command "hello"
--            (info hello (progDesc "Print greeting"))
--         &lt;&gt; command "goodbye"
--            (info goodbye (progDesc "Say goodbye"))
--          )
--   </pre>
command :: String -> ParserInfo a -> Mod CommandFields a

-- | Add a description to a group of commands.
--   
--   Advanced feature for separating logical groups of commands on the
--   parse line.
--   
--   If using the same <a>metavar</a> for each group of commands, it may
--   yield a more attractive usage text combined with <a>hidden</a> for
--   some groups.
commandGroup :: String -> Mod CommandFields a

-- | Add a list of possible completion values.
completeWith :: HasCompleter f => [String] -> Mod f a

-- | Add a bash completion action. Common actions include <tt>file</tt> and
--   <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
action :: HasCompleter f => String -> Mod f a

-- | Add a completer to an argument.
--   
--   A completer is a function String -&gt; IO String which, given a
--   partial argument, returns all possible completions for that argument.
completer :: HasCompleter f => Completer -> Mod f a

-- | Trivial option modifier.
idm :: Monoid m => m

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a
data OptionFields a
data FlagFields a
data ArgumentFields a
data CommandFields a
class HasName f
class HasCompleter f
class HasValue f
class HasMetavar f

-- | A newtype over 'ReaderT String Except', used by option readers.
data ReadM a

-- | <a>Option</a> reader based on the <a>Read</a> type class.
auto :: Read a => ReadM a

-- | String <a>Option</a> reader.
--   
--   Polymorphic over the <a>IsString</a> type class since 0.14.
str :: IsString s => ReadM s

-- | Convert a function producing a <a>Maybe</a> into a reader.
maybeReader :: (String -> Maybe a) -> ReadM a

-- | Convert a function producing an <a>Either</a> into a reader.
--   
--   As an example, one can create a ReadM from an attoparsec Parser easily
--   with
--   
--   <pre>
--   import qualified Data.Attoparsec.Text as A
--   import qualified Data.Text as T
--   attoparsecReader :: A.Parser a -&gt; ReadM a
--   attoparsecReader p = eitherReader (A.parseOnly p . T.pack)
--   </pre>
eitherReader :: (String -> Either String a) -> ReadM a

-- | Null <a>Option</a> reader. All arguments will fail validation.
disabled :: ReadM a

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a

-- | Create a <a>ParserInfo</a> given a <a>Parser</a> and a modifier.
info :: Parser a -> InfoMod a -> ParserInfo a

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Modifier for <a>ParserInfo</a>.
data InfoMod a

-- | Show a full description in the help text of this parser (default).
fullDesc :: InfoMod a

-- | Only show a brief description in the help text of this parser.
briefDesc :: InfoMod a

-- | Specify a header for this parser.
header :: String -> InfoMod a

-- | Specify a header for this parser as a 'Prettyprinter.Doc AnsiStyle'
--   value.
headerDoc :: Maybe Doc -> InfoMod a

-- | Specify a footer for this parser.
footer :: String -> InfoMod a

-- | Specify a footer for this parser as a 'Prettyprinter.Doc AnsiStyle'
--   value.
footerDoc :: Maybe Doc -> InfoMod a

-- | Specify a short program description.
progDesc :: String -> InfoMod a

-- | Specify a short program description as a 'Prettyprinter.Doc AnsiStyle'
--   value.
progDescDoc :: Maybe Doc -> InfoMod a

-- | Specify an exit code if a parse error occurs.
failureCode :: Int -> InfoMod a

-- | Disable parsing of regular options after arguments. After a positional
--   argument is parsed, all remaining options and arguments will be
--   treated as a positional arguments. Not recommended in general as users
--   often expect to be able to freely intersperse regular options and
--   flags within command line options.
noIntersperse :: InfoMod a

-- | Intersperse matched options and arguments normally, but allow
--   unmatched options to be treated as positional arguments. This is
--   sometimes useful if one is wrapping a third party cli tool and needs
--   to pass options through, while also providing a handful of their own
--   options. Not recommended in general as typos by the user may not yield
--   a parse error and cause confusion.
forwardOptions :: InfoMod a

-- | Run a program description.
--   
--   Parse command line arguments. Display help text and exit if any parse
--   error occurs.
execParser :: ParserInfo a -> IO a

-- | Run a program description with custom preferences.
customExecParser :: ParserPrefs -> ParserInfo a -> IO a

-- | The most general way to run a program description in pure code.
execParserPure :: ParserPrefs -> ParserInfo a -> [String] -> ParserResult a

-- | Extract the actual result from a <a>ParserResult</a> value.
--   
--   This function returns <a>Nothing</a> in case of errors. Possible error
--   messages or completion actions are simply discarded.
--   
--   If you want to display error messages and invoke completion actions
--   appropriately, use <a>handleParseResult</a> instead.
getParseResult :: ParserResult a -> Maybe a

-- | Handle <a>ParserResult</a>.
handleParseResult :: ParserResult a -> IO a

-- | Generate a <a>ParserFailure</a> from a <a>ParseError</a> in a given
--   <a>Context</a>.
--   
--   This function can be used, for example, to show the help text for a
--   parser:
--   
--   <pre>
--   handleParseResult . Failure $ parserFailure pprefs pinfo (ShowHelpText Nothing) mempty
--   </pre>
parserFailure :: ParserPrefs -> ParserInfo a -> ParseError -> [Context] -> ParserFailure ParserHelp
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a

-- | Create a <a>ParserPrefs</a> given a modifier
prefs :: PrefsMod -> ParserPrefs

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Backtracking -> Int -> Bool -> Bool -> (Doc -> Doc) -> Int -> (Int -> ParserHelp -> String) -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default:
--   Backtrack)
[prefBacktrack] :: ParserPrefs -> Backtracking

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int

-- | when displaying long names in usage and help, use an '=' sign for long
--   names, rather than a single space (default: False)
[prefHelpLongEquals] :: ParserPrefs -> Bool

-- | when displaying subparsers' usage help, show parent options under a
--   "global options" section (default: False)
[prefHelpShowGlobal] :: ParserPrefs -> Bool

-- | how usage overflow over lines is handled
[prefEmbedBriefDesc] :: ParserPrefs -> Doc -> Doc

-- | Indentation width for tables
[prefTabulateFill] :: ParserPrefs -> Int

-- | Render help function
[prefRenderHelp] :: ParserPrefs -> Int -> ParserHelp -> String
data PrefsMod

-- | Include a suffix to attach to the metavar when multiple values can be
--   entered.
multiSuffix :: String -> PrefsMod

-- | Turn on disambiguation.
--   
--   See
--   <a>https://github.com/pcapriotti/optparse-applicative#disambiguation</a>
disambiguate :: PrefsMod

-- | Show full help text on any error.
showHelpOnError :: PrefsMod

-- | Show the help text if the user enters only the program name or
--   subcommand.
--   
--   This will suppress a "Missing:" error and show the full usage instead
--   if a user just types the name of the program.
showHelpOnEmpty :: PrefsMod

-- | Turn off backtracking after subcommand is parsed.
noBacktrack :: PrefsMod

-- | Allow full mixing of subcommand and parent arguments by inlining
--   selected subparsers into the parent parser.
--   
--   <i>NOTE:</i> When this option is used, preferences for the subparser
--   which effect the parser behaviour (such as noIntersperse) are ignored.
subparserInline :: PrefsMod

-- | Set the maximum width of the generated help text.
columns :: Int -> PrefsMod

-- | Show equals sign, rather than space, in usage and help text for
--   options with long names.
helpLongEquals :: PrefsMod

-- | Align usage overflow to the right
helpEmbedBriefDesc :: (Doc -> Doc) -> PrefsMod

-- | Show global help information in subparser usage.
helpShowGlobals :: PrefsMod

-- | Set fill width in help text presentation.
helpIndent :: Int -> PrefsMod

-- | Custom render function
helpRenderHelp :: (Int -> ParserHelp -> String) -> PrefsMod

-- | Default preferences.
defaultPrefs :: ParserPrefs

-- | A shell complete function.
data Completer

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer

-- | Create a <a>Completer</a> from an IO action
listIOCompleter :: IO [String] -> Completer

-- | Create a <a>Completer</a> from a constant list of strings.
listCompleter :: [String] -> Completer

-- | Run a compgen completion action.
--   
--   Common actions include <tt>file</tt> and <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
bashCompleter :: String -> Completer
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: Maybe String -> ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpDescription] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpGlobals] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String


-- | This module contains an arrow interface for option parsers, which
--   allows to define and combine parsers using the arrow notation and
--   arrow combinators.
--   
--   The arrow syntax is particularly useful to create parsers of nested
--   structures, or records where the order of fields is different from the
--   order in which the parsers should be applied.
--   
--   For example, an <a>arguments</a> parser often needs to be applied
--   last, and that makes it inconvenient to use it for a field which is
--   not the last one in a record.
--   
--   Using the arrow syntax and the functions in this module, one can
--   write, e.g.:
--   
--   <pre>
--   data Options = Options
--     { optArgs :: [String]
--     , optVerbose :: Bool }
--   
--   opts :: Parser Options
--   opts = runA $ proc () -&gt; do
--     verbose &lt;- asA (switch (short 'v')) -&lt; ()
--     args &lt;- asA (arguments str idm) -&lt; ()
--     returnA -&lt; Options args verbose
--   </pre>
--   
--   Parser arrows, created out of regular <a>Parser</a> values using the
--   <a>asA</a> function, are arrows taking <tt>()</tt> as argument and
--   returning the parsed value.
module Options.Applicative.Arrows

-- | For any <a>Applicative</a> functor <tt>f</tt>, <tt>A f</tt> is the
--   <a>Arrow</a> instance associated to <tt>f</tt>.
--   
--   The <a>A</a> constructor can be used to convert a value of type <tt>f
--   (a -&gt; b)</tt> into an arrow.
newtype A f a b
A :: f (a -> b) -> A f a b
[unA] :: A f a b -> f (a -> b)

-- | Convert a value of type <tt>f a</tt> into an arrow taking <tt>()</tt>
--   as argument.
--   
--   Applied to a value of type <a>Parser</a>, it turns it into an arrow
--   that can be used inside an arrow command, or passed to arrow
--   combinators.
asA :: Applicative f => f a -> A f () a

-- | Convert an arrow back to an applicative value.
--   
--   This function can be used to return a result of type <a>Parser</a>
--   from an arrow command.
runA :: Applicative f => A f () a -> f a

-- | The type of arrows associated to the applicative <a>Parser</a>
--   functor.
type ParserA = A Parser
instance GHC.Base.Applicative f => Control.Category.Category (Options.Applicative.Arrows.A f)
instance GHC.Base.Applicative f => Control.Arrow.Arrow (Options.Applicative.Arrows.A f)
