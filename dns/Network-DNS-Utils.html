<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Network.DNS.Utils</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">dns-4.2.0: DNS library in Haskell</span><ul class="links" id="page-menu"><li><a href="src/Network.DNS.Utils.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.DNS.Utils</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Miscellaneous utility functions for processing DNS data.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:normalize">normalize</a> :: <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> -&gt; <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a></li><li class="src short"><a href="#v:normalizeCase">normalizeCase</a> :: <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> -&gt; <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a></li><li class="src short"><a href="#v:normalizeRoot">normalizeRoot</a> :: <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> -&gt; <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a></li><li class="src short"><a href="#v:splitDomain">splitDomain</a> :: <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Network-DNS-Types.html#t:DNSError" title="Network.DNS.Types">DNSError</a> (<a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a>)</li><li class="src short"><a href="#v:splitMailbox">splitMailbox</a> :: <a href="Network-DNS-Types.html#t:Mailbox" title="Network.DNS.Types">Mailbox</a> -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Network-DNS-Types.html#t:DNSError" title="Network.DNS.Types">DNSError</a> (<a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a>)</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:normalize" class="def">normalize</a> :: <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> -&gt; <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> <a href="src/Network.DNS.Utils.html#normalize" class="link">Source</a> <a href="#v:normalize" class="selflink">#</a></p><div class="doc"><p>Perform both <code><a href="Network-DNS-Utils.html#v:normalizeCase" title="Network.DNS.Utils">normalizeCase</a></code> and <code><a href="Network-DNS-Utils.html#v:normalizeRoot" title="Network.DNS.Utils">normalizeRoot</a></code> on the given
   <code><a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a></code>. When comparing DNS names taken from user input, this is
   often necessary to avoid unexpected results.</p><p><em>Examples</em>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let domain1 = BS.pack &quot;ExAmPlE.COM&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let domain2 = BS.pack &quot;example.com.&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>domain1 == domain2
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>normalize domain1 == normalize domain2
</code></strong>True
</pre><p>The <code><a href="Network-DNS-Utils.html#v:normalize" title="Network.DNS.Utils">normalize</a></code> function should be idempotent:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>normalize (normalize domain1) == normalize domain1
</code></strong>True
</pre><p>Ensure that we don't crash on the empty <code><a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import qualified Data.ByteString.Char8 as BS
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>normalize BS.empty
</code></strong>&quot;.&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:normalizeCase" class="def">normalizeCase</a> :: <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> -&gt; <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> <a href="src/Network.DNS.Utils.html#normalizeCase" class="link">Source</a> <a href="#v:normalizeCase" class="selflink">#</a></p><div class="doc"><p>Normalize the case of the given DNS name for comparisons.</p><p>According to RFC #1035, &quot;For all parts of the DNS that are part
   of the official protocol, all comparisons between character
   strings (e.g., labels, domain names, etc.) are done in a
   case-insensitive manner.&quot; This function chooses to lowercase
   its argument, but that should be treated as an implementation
   detail if at all possible.</p><p><em>Examples</em>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let domain1 = BS.pack &quot;ExAmPlE.COM&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let domain2 = BS.pack &quot;exAMPle.com&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>domain1 == domain2
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>normalizeCase domain1 == normalizeCase domain2
</code></strong>True
</pre><p>The <code><a href="Network-DNS-Utils.html#v:normalizeCase" title="Network.DNS.Utils">normalizeCase</a></code> function should be idempotent:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>normalizeCase (normalizeCase domain2) == normalizeCase domain2
</code></strong>True
</pre><p>Ensure that we don't crash on the empty <code><a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import qualified Data.ByteString.Char8 as BS
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>normalizeCase BS.empty
</code></strong>&quot;&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:normalizeRoot" class="def">normalizeRoot</a> :: <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> -&gt; <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> <a href="src/Network.DNS.Utils.html#normalizeRoot" class="link">Source</a> <a href="#v:normalizeRoot" class="selflink">#</a></p><div class="doc"><p>Normalize the given name by appending a trailing dot (the DNS
   root) if one does not already exist.</p><p>Warning: this does not produce an equivalent DNS name! However,
   users are often unaware of the effect that the absence of the
   root will have. In user interface design, it may therefore be
   wise to act as if the user supplied the trailing dot during
   comparisons.</p><p>Per RFC #1034,</p><p>&quot;Since a complete domain name ends with the root label, this leads
   to a printed form which ends in a dot. We use this property to
   distinguish between:</p><ul><li>a character string which represents a complete domain name
     (often called 'absolute'). For example, 'poneria.ISI.EDU.'</li><li>a character string that represents the starting labels of a
     domain name which is incomplete, and should be completed by
     local software using knowledge of the local domain (often
     called 'relative'). For example, 'poneria' used in the
     ISI.EDU domain.</li></ul><p>Relative names are either taken relative to a well known origin,
   or to a list of domains used as a search list. Relative names
   appear mostly at the user interface, where their interpretation
   varies from implementation to implementation, and in master
   files, where they are relative to a single origin domain name.&quot;</p><p><em>Examples</em>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let domain1 = BS.pack &quot;example.com&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let domain2 = BS.pack &quot;example.com.&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>domain1 == domain2
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>normalizeRoot domain1 == normalizeRoot domain2
</code></strong>True
</pre><p>The <code><a href="Network-DNS-Utils.html#v:normalizeRoot" title="Network.DNS.Utils">normalizeRoot</a></code> function should be idempotent:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>normalizeRoot (normalizeRoot domain1) == normalizeRoot domain1
</code></strong>True
</pre><p>Ensure that we don't crash on the empty <code><a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import qualified Data.ByteString.Char8 as BS
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>normalizeRoot BS.empty
</code></strong>&quot;.&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:splitDomain" class="def">splitDomain</a> :: <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a> -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Network-DNS-Types.html#t:DNSError" title="Network.DNS.Types">DNSError</a> (<a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a>) <a href="src/Network.DNS.Utils.html#splitDomain" class="link">Source</a> <a href="#v:splitDomain" class="selflink">#</a></p><div class="doc"><p>Split a domain name in A-label form into its initial label and the rest of
 the domain.  Returns an error if the initial label is malformed.  When no
 more labels remain, the initial label will satisfy <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/bytestring-0.11.5.3/Data-ByteString.html#v:null" title="Data.ByteString">null</a></code>.</p><p>This also decodes any escaped characters in the initial label, which may
 therefore contain whitespace, binary data, or unescaped internal dots.  To
 reconstruct the original domain, the initial label may sometimes require
 correct escaping of special characters.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:splitDomain0">Examples</h4><details id="ch:splitDomain0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.ByteString.Char8 as BS
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitDomain $ BS.pack &quot;abc\\.def.xyz&quot;
</code></strong>Right (&quot;abc.def&quot;,&quot;xyz&quot;)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitDomain $ BS.pack &quot;.abc.def.xyz&quot;
</code></strong>Left (DecodeError &quot;invalid domain: .abc.def.xyz&quot;)
</pre></details></div></div><div class="top"><p class="src"><a id="v:splitMailbox" class="def">splitMailbox</a> :: <a href="Network-DNS-Types.html#t:Mailbox" title="Network.DNS.Types">Mailbox</a> -&gt; <a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Network-DNS-Types.html#t:DNSError" title="Network.DNS.Types">DNSError</a> (<a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a>) <a href="src/Network.DNS.Utils.html#splitMailbox" class="link">Source</a> <a href="#v:splitMailbox" class="selflink">#</a></p><div class="doc"><p>Split a <code><a href="Network-DNS-Types.html#t:Mailbox" title="Network.DNS.Types">Mailbox</a></code> in A-label form into its initial label <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code>
 (the <em>localpart</em> of the email address) and the remaining <code><a href="Network-DNS-Types.html#t:Domain" title="Network.DNS.Types">Domain</a></code> (the
 <em>domainpart</em> of the email address, with a possible trailing <code><code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Function.html#v:." title="Data.Function">.</a></code></code>).  Returns
 an error if the initial label is malformed.  When no more labels remain, the
 initial label will satisfy <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/bytestring-0.11.5.3/Data-ByteString.html#v:null" title="Data.ByteString">null</a></code>.  The remaining labels can be obtained
 by applying <code><a href="Network-DNS-Utils.html#v:splitDomain" title="Network.DNS.Utils">splitDomain</a></code> the returned domain part.</p><p>This also decodes any escaped characters in the initial label, which may
 therefore contain whitespace, binary data, or unescaped internal dots.  To
 reconstruct the original mailbox, the initial label may sometimes require
 correct escaping of special characters.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:splitMailbox0">Example</h4><details id="ch:splitMailbox0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.ByteString.Char8 as BS
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitMailbox $ BS.pack &quot;Joe.Admin@example.com.&quot;
</code></strong>Right (&quot;Joe.Admin&quot;,&quot;example.com.&quot;)
</pre></details></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>