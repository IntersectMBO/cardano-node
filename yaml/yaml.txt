-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support for parsing and rendering YAML documents.
--   
--   README and API documentation are available at
--   <a>https://www.stackage.org/package/yaml</a>
@package yaml
@version 0.11.11.2

module Data.Yaml.Internal
data ParseException
NonScalarKey :: ParseException
UnknownAlias :: AnchorName -> ParseException
[_anchorName] :: ParseException -> AnchorName
UnexpectedEvent :: Maybe Event -> Maybe Event -> ParseException
[_received] :: ParseException -> Maybe Event
[_expected] :: ParseException -> Maybe Event
InvalidYaml :: Maybe YamlException -> ParseException
MultipleDocuments :: ParseException
AesonException :: String -> ParseException
OtherParseException :: SomeException -> ParseException
NonStringKey :: JSONPath -> ParseException
NonStringKeyAlias :: AnchorName -> Value -> ParseException
CyclicIncludes :: ParseException
LoadSettingsException :: FilePath -> ParseException -> ParseException

-- | Alternative to <a>show</a> to display a <a>ParseException</a> on the
--   screen. Instead of displaying the data constructors applied to their
--   arguments, a more textual output is returned. For example, instead of
--   printing:
--   
--   <pre>
--   InvalidYaml (Just (YamlParseException {yamlProblem = "did not find expected ',' or '}'", yamlContext = "while parsing a flow mapping", yamlProblemMark = YamlMark {yamlIndex = 42, yamlLine = 2, yamlColumn = 12}})))
--   </pre>
--   
--   It looks more pleasant to print:
--   
--   <pre>
--   YAML parse exception at line 2, column 12,
--   while parsing a flow mapping:
--   did not find expected ',' or '}'
--   </pre>
--   
--   Since 0.8.11
prettyPrintParseException :: ParseException -> String
data Warning
DuplicateKey :: JSONPath -> Warning
parse :: ReaderT JSONPath (ConduitM Event o Parse) Value
type Parse = StateT ParseState (ResourceT IO)
decodeHelper :: FromJSON a => ConduitM () Event Parse () -> IO (Either ParseException ([Warning], Either String a))
decodeHelper_ :: FromJSON a => ConduitM () Event Parse () -> IO (Either ParseException ([Warning], a))
decodeAllHelper :: FromJSON a => ConduitM () Event Parse () -> IO (Either ParseException ([Warning], Either String [a]))
decodeAllHelper_ :: FromJSON a => ConduitM () Event Parse () -> IO (Either ParseException ([Warning], [a]))
textToScientific :: Text -> Either String Scientific

-- | Encodes a string with the supplied style. This function handles the
--   empty string case properly to avoid
--   <a>https://github.com/snoyberg/yaml/issues/24</a>
stringScalar :: StringStyle -> Maybe Text -> Text -> Event
type StringStyle = Text -> (Tag, Style)

defaultStringStyle :: StringStyle

-- | Determine whether a string must be quoted in YAML and can't appear as
--   plain text. Useful if you want to use <tt>setStringStyle</tt>.
isSpecialString :: Text -> Bool

-- | Strings which must be escaped so as not to be treated as non-string
--   scalars.
specialStrings :: HashSet Text

isNumeric :: Text -> Bool

-- | Encode a value as a YAML document stream.
objToStream :: ToJSON a => StringStyle -> a -> [Event]

-- | Encode a value as a list of <a>Event</a>s.
objToEvents :: ToJSON a => StringStyle -> a -> [Event] -> [Event]
instance GHC.Show.Show Data.Yaml.Internal.ParseException
instance GHC.Show.Show Data.Yaml.Internal.Warning
instance GHC.Classes.Eq Data.Yaml.Internal.Warning
instance GHC.Exception.Type.Exception Data.Yaml.Internal.ParseException

module Data.Yaml.Include

-- | Like <a>decodeFile</a> but with support for relative and absolute
--   includes.
--   
--   The syntax for includes follows the form:
--   
--   <pre>
--   somekey: !include ./somefile.yaml
--   </pre>
decodeFile :: FromJSON a => FilePath -> IO (Maybe a)

-- | Like <a>decodeFileEither</a> but with support for relative and
--   absolute includes.
--   
--   The syntax for includes follows the form:
--   
--   <pre>
--   somekey: !include ./somefile.yaml
--   </pre>
decodeFileEither :: FromJSON a => FilePath -> IO (Either ParseException a)

-- | A version of <a>decodeFileEither</a> that returns warnings along with
--   the parse result.
decodeFileWithWarnings :: FromJSON a => FilePath -> IO (Either ParseException ([Warning], a))


-- | drastically, or be entirely removed, in a future release.
module Data.Yaml.Builder
newtype YamlBuilder
YamlBuilder :: ([Event] -> [Event]) -> YamlBuilder
[unYamlBuilder] :: YamlBuilder -> [Event] -> [Event]
class ToYaml a
toYaml :: ToYaml a => a -> YamlBuilder

mapping :: [(Text, YamlBuilder)] -> YamlBuilder

namedMapping :: Text -> [(Text, YamlBuilder)] -> YamlBuilder

maybeNamedMapping :: Maybe Text -> [(Text, YamlBuilder)] -> YamlBuilder

mappingComplex :: [(YamlBuilder, YamlBuilder)] -> YamlBuilder

namedMappingComplex :: Text -> [(YamlBuilder, YamlBuilder)] -> YamlBuilder

maybeNamedMappingComplex :: Maybe Text -> [(YamlBuilder, YamlBuilder)] -> YamlBuilder

array :: [YamlBuilder] -> YamlBuilder

namedArray :: Text -> [YamlBuilder] -> YamlBuilder

maybeNamedArray :: Maybe Text -> [YamlBuilder] -> YamlBuilder

string :: Text -> YamlBuilder

namedString :: Text -> Text -> YamlBuilder

maybeNamedString :: Maybe Text -> Text -> YamlBuilder

bool :: Bool -> YamlBuilder

namedBool :: Text -> Bool -> YamlBuilder

maybeNamedBool :: Maybe Text -> Bool -> YamlBuilder

null :: YamlBuilder

namedNull :: Text -> YamlBuilder

maybeNamedNull :: Maybe Text -> YamlBuilder

scientific :: Scientific -> YamlBuilder

namedScientific :: Text -> Scientific -> YamlBuilder

maybeNamedScientific :: Maybe Text -> Scientific -> YamlBuilder

alias :: Text -> YamlBuilder


-- | <i>Deprecated: Use scientific</i>
number :: Scientific -> YamlBuilder

toByteString :: ToYaml a => a -> ByteString

toByteStringWith :: ToYaml a => FormatOptions -> a -> ByteString
writeYamlFile :: ToYaml a => FilePath -> a -> IO ()

writeYamlFileWith :: ToYaml a => FormatOptions -> FilePath -> a -> IO ()
(.=) :: ToYaml a => Text -> a -> (Text, YamlBuilder)
data () => FormatOptions
setWidth :: Maybe Int -> FormatOptions -> FormatOptions
instance Data.Yaml.Builder.ToYaml Data.Yaml.Builder.YamlBuilder
instance (Data.Yaml.Builder.ToYaml a, Data.Yaml.Builder.ToYaml b) => Data.Yaml.Builder.ToYaml [(a, b)]
instance Data.Yaml.Builder.ToYaml a => Data.Yaml.Builder.ToYaml [a]
instance Data.Yaml.Builder.ToYaml Data.Text.Internal.Text
instance Data.Yaml.Builder.ToYaml GHC.Base.String
instance Data.Yaml.Builder.ToYaml GHC.Types.Int
instance Data.Yaml.Builder.ToYaml GHC.Types.Double
instance Data.Yaml.Builder.ToYaml Data.Scientific.Scientific
instance Data.Yaml.Builder.ToYaml GHC.Types.Bool
instance Data.Yaml.Builder.ToYaml a => Data.Yaml.Builder.ToYaml (GHC.Maybe.Maybe a)


-- | Provides a high-level interface for processing YAML files.
--   
--   This module reuses most of the infrastructure from the <tt>aeson</tt>
--   package. This means that you can use all of the existing tools for
--   JSON processing for processing YAML files. As a result, much of the
--   documentation below mentions JSON; do not let that confuse you, it's
--   intentional.
--   
--   For the most part, YAML content translates directly into JSON, and
--   therefore there is very little data loss. If you need to deal with
--   YAML more directly (e.g., directly deal with aliases), you should use
--   the <a>Text.Libyaml</a> module instead.
--   
--   For documentation on the <tt>aeson</tt> types, functions, classes, and
--   operators, please see the <tt>Data.Aeson</tt> module of the
--   <tt>aeson</tt> package.
--   
--   Look in the examples directory of the source repository for some
--   initial pointers on how to use this library.
module Data.Yaml

-- | Encode a value into its YAML representation.
encode :: ToJSON a => a -> ByteString

-- | Encode a value into its YAML representation with custom styling.
encodeWith :: ToJSON a => EncodeOptions -> a -> ByteString

-- | Encode a value into its YAML representation and save to the given
--   file.
encodeFile :: ToJSON a => FilePath -> a -> IO ()

-- | Encode a value into its YAML representation with custom styling and
--   save to the given file.
encodeFileWith :: ToJSON a => EncodeOptions -> FilePath -> a -> IO ()

-- | More helpful version of <a>decodeEither</a> which returns the
--   <a>YamlException</a>.
decodeEither' :: FromJSON a => ByteString -> Either ParseException a

-- | A version of <a>decodeFile</a> which should not throw runtime
--   exceptions.
decodeFileEither :: FromJSON a => FilePath -> IO (Either ParseException a)

-- | A version of <a>decodeFileEither</a> that returns warnings along with
--   the parse result.
decodeFileWithWarnings :: FromJSON a => FilePath -> IO (Either ParseException ([Warning], a))

-- | A version of <a>decodeEither'</a> lifted to MonadThrow
decodeThrow :: (MonadThrow m, FromJSON a) => ByteString -> m a

-- | A version of <a>decodeFileEither</a> lifted to MonadIO
decodeFileThrow :: (MonadIO m, FromJSON a) => FilePath -> m a

-- | Like <a>decodeEither'</a>, but decode multiple documents.
decodeAllEither' :: FromJSON a => ByteString -> Either ParseException [a]

-- | Like <a>decodeFileEither</a>, but decode multiple documents.
decodeAllFileEither :: FromJSON a => FilePath -> IO (Either ParseException [a])

-- | Like <a>decodeFileWithWarnings</a>, but decode multiple documents.
decodeAllFileWithWarnings :: FromJSON a => FilePath -> IO (Either ParseException ([Warning], [a]))

-- | Like <a>decodeThrow</a>, but decode multiple documents.
decodeAllThrow :: (MonadThrow m, FromJSON a) => ByteString -> m [a]

-- | Like <a>decodeFileThrow</a>, but decode multiple documents.
decodeAllFileThrow :: (MonadIO m, FromJSON a) => FilePath -> m [a]
decodeHelper :: FromJSON a => ConduitM () Event Parse () -> IO (Either ParseException ([Warning], Either String a))
data () => Value
Object :: !Object -> Value
Array :: !Array -> Value
String :: !Text -> Value
Number :: !Scientific -> Value
Bool :: !Bool -> Value
Null :: Value
data () => Parser a
type Object = KeyMap Value
type Array = Vector Value
data ParseException
NonScalarKey :: ParseException
UnknownAlias :: AnchorName -> ParseException
[_anchorName] :: ParseException -> AnchorName
UnexpectedEvent :: Maybe Event -> Maybe Event -> ParseException
[_received] :: ParseException -> Maybe Event
[_expected] :: ParseException -> Maybe Event
InvalidYaml :: Maybe YamlException -> ParseException
MultipleDocuments :: ParseException
AesonException :: String -> ParseException
OtherParseException :: SomeException -> ParseException
NonStringKey :: JSONPath -> ParseException
NonStringKeyAlias :: AnchorName -> Value -> ParseException
CyclicIncludes :: ParseException
LoadSettingsException :: FilePath -> ParseException -> ParseException

-- | Alternative to <a>show</a> to display a <a>ParseException</a> on the
--   screen. Instead of displaying the data constructors applied to their
--   arguments, a more textual output is returned. For example, instead of
--   printing:
--   
--   <pre>
--   InvalidYaml (Just (YamlParseException {yamlProblem = "did not find expected ',' or '}'", yamlContext = "while parsing a flow mapping", yamlProblemMark = YamlMark {yamlIndex = 42, yamlLine = 2, yamlColumn = 12}})))
--   </pre>
--   
--   It looks more pleasant to print:
--   
--   <pre>
--   YAML parse exception at line 2, column 12,
--   while parsing a flow mapping:
--   did not find expected ',' or '}'
--   </pre>
--   
--   Since 0.8.11
prettyPrintParseException :: ParseException -> String
data () => YamlException
YamlException :: String -> YamlException
YamlParseException :: String -> String -> YamlMark -> YamlException
[yamlProblem] :: YamlException -> String
[yamlContext] :: YamlException -> String
[yamlProblemMark] :: YamlException -> YamlMark
data () => YamlMark
YamlMark :: Int -> Int -> Int -> YamlMark
[yamlIndex] :: YamlMark -> Int
[yamlLine] :: YamlMark -> Int
[yamlColumn] :: YamlMark -> Int
object :: [Pair] -> Value

-- | Construct a new <a>Value</a> from a list of <a>Value</a>s.
array :: [Value] -> Value
(.=) :: (KeyValue e kv, ToJSON v) => Key -> v -> kv
(.:) :: FromJSON a => Object -> Key -> Parser a
(.:?) :: FromJSON a => Object -> Key -> Parser (Maybe a)
(.!=) :: Parser (Maybe a) -> a -> Parser a
withObject :: String -> (Object -> Parser a) -> Value -> Parser a
withText :: String -> (Text -> Parser a) -> Value -> Parser a
withArray :: String -> (Array -> Parser a) -> Value -> Parser a
withScientific :: String -> (Scientific -> Parser a) -> Value -> Parser a
withBool :: String -> (Bool -> Parser a) -> Value -> Parser a

-- | <i>Deprecated: With the MonadFail split, this function is going to be
--   removed in the future. Please migrate to parseEither.</i>
parseMonad :: MonadFail m => (a -> Parser b) -> a -> m b
parseEither :: (a -> Parser b) -> a -> Either String b
parseMaybe :: (a -> Parser b) -> a -> Maybe b
class () => ToJSON a
toJSON :: ToJSON a => a -> Value
toEncoding :: ToJSON a => a -> Encoding
toJSONList :: ToJSON a => [a] -> Value
toEncodingList :: ToJSON a => [a] -> Encoding
omitField :: ToJSON a => a -> Bool
class () => FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONList :: FromJSON a => Value -> Parser [a]
omittedField :: FromJSON a => Maybe a

-- | Determine whether a string must be quoted in YAML and can't appear as
--   plain text. Useful if you want to use <tt>setStringStyle</tt>.
isSpecialString :: Text -> Bool

data EncodeOptions

defaultEncodeOptions :: EncodeOptions

defaultStringStyle :: StringStyle

-- | Set the string style in the encoded YAML. This is a function that
--   decides for each string the type of YAML string to output.
--   
--   <b>WARNING</b>: You must ensure that special strings (like
--   <tt>"yes"</tt>/<tt>"no"</tt>/<tt>"null"</tt>/<tt>"1234"</tt>) are not
--   encoded with the <a>Plain</a> style, because then they will be decoded
--   as boolean, null or numeric values. You can use <a>isSpecialString</a>
--   to detect them.
--   
--   By default, strings are encoded as follows:
--   
--   <ul>
--   <li>Any string containing a newline character uses the <a>Literal</a>
--   style</li>
--   <li>Otherwise, any special string (see <a>isSpecialString</a>) uses
--   <a>SingleQuoted</a></li>
--   <li>Otherwise, use <a>Plain</a></li>
--   </ul>
setStringStyle :: (Text -> (Tag, Style)) -> EncodeOptions -> EncodeOptions

-- | Set the encoding formatting for the encoded YAML. By default, this is
--   <a>defaultFormatOptions</a>.
setFormat :: FormatOptions -> EncodeOptions -> EncodeOptions
data () => FormatOptions
defaultFormatOptions :: FormatOptions
setWidth :: Maybe Int -> FormatOptions -> FormatOptions

-- | <i>Deprecated: Please use decodeEither or decodeThrow, which provide
--   information on how the decode failed</i>
decode :: FromJSON a => ByteString -> Maybe a

-- | <i>Deprecated: Please use decodeFileEither, which does not confused
--   type-directed and runtime exceptions.</i>
decodeFile :: FromJSON a => FilePath -> IO (Maybe a)

-- | <i>Deprecated: Please use decodeEither' or decodeThrow, which provide
--   more useful failures</i>
decodeEither :: FromJSON a => ByteString -> Either String a


-- | Functionality for using YAML as configuration files
--   
--   In particular, merging environment variables with yaml values
--   
--   <a>loadYamlSettings</a> is a high-level API for loading YAML and
--   merging environment variables. A yaml value of
--   <tt>_env:ENV_VAR:default</tt> will lookup the environment variable
--   <tt>ENV_VAR</tt>.
--   
--   On a historical note, this code was taken directly from the yesod web
--   framework's configuration module.
module Data.Yaml.Config

-- | Load the settings from the following three sources:
--   
--   <ul>
--   <li>Run time config files</li>
--   <li>Run time environment variables</li>
--   <li>The default compile time config file</li>
--   </ul>
--   
--   For example, to load up settings from <tt>config/foo.yaml</tt> and
--   allow overriding from the actual environment, you can use:
--   
--   <pre>
--   loadYamlSettings ["config/foo.yaml"] [] useEnv
--   </pre>
loadYamlSettings :: FromJSON settings => [FilePath] -> [Value] -> EnvUsage -> IO settings

-- | Same as <tt>loadYamlSettings</tt>, but get the list of runtime config
--   files from the command line arguments.
loadYamlSettingsArgs :: FromJSON settings => [Value] -> EnvUsage -> IO settings

-- | Defines how we want to use the environment variables when loading a
--   config file. Use the smart constructors provided by this module.
data EnvUsage

-- | Do not use any environment variables, instead relying on defaults
--   values in the config file.
ignoreEnv :: EnvUsage

-- | Use environment variables when available, otherwise use defaults.
useEnv :: EnvUsage

-- | Do not use default values from the config file, but instead take all
--   overrides from the environment. If a value is missing, loading the
--   file will throw an exception.
requireEnv :: EnvUsage

-- | Same as <a>useEnv</a>, but instead of the actual environment, use the
--   provided <tt>HashMap</tt> as the environment.
useCustomEnv :: KeyMap Text -> EnvUsage

-- | Same as <a>requireEnv</a>, but instead of the actual environment, use
--   the provided <tt>HashMap</tt> as the environment.
requireCustomEnv :: KeyMap Text -> EnvUsage

-- | A convenience wrapper around <a>applyEnvValue</a> and
--   <a>getCurrentEnv</a>
applyCurrentEnv :: Bool -> Value -> IO Value

-- | Get the actual environment as a <tt>HashMap</tt> from <tt>Text</tt> to
--   <tt>Text</tt>.
getCurrentEnv :: IO (KeyMap Text)

-- | Override environment variable placeholders in the given <tt>Value</tt>
--   with values from the environment.
--   
--   If the first argument is <tt>True</tt>, then all placeholders _must_
--   be provided by the actual environment. Otherwise, default values from
--   the <tt>Value</tt> will be used.
applyEnvValue :: Bool -> KeyMap Text -> Value -> Value
instance GHC.Base.Semigroup Data.Yaml.Config.MergedValue


-- | Just a re-export of <tt>Data.Yaml</tt>. In the future, this will be
--   the canonical name for that module's contents.
module Data.Yaml.Aeson


-- | drastically, or be entirely removed, in a future release.
module Data.Yaml.Parser
newtype YamlParser a
YamlParser :: (AnchorMap -> Either Text a) -> YamlParser a
[unYamlParser] :: YamlParser a -> AnchorMap -> Either Text a
lookupAnchor :: AnchorName -> YamlParser (Maybe YamlValue)
withAnchor :: AnchorName -> Text -> (YamlValue -> YamlParser a) -> YamlParser a
withMapping :: Text -> ([(Text, YamlValue)] -> YamlParser a) -> YamlValue -> YamlParser a
withSequence :: Text -> ([YamlValue] -> YamlParser a) -> YamlValue -> YamlParser a
withText :: Text -> (Text -> YamlParser a) -> YamlValue -> YamlParser a
typeMismatch :: Text -> YamlValue -> YamlParser a
class FromYaml a
fromYaml :: FromYaml a => YamlValue -> YamlParser a
data YamlValue
Mapping :: [(Text, YamlValue)] -> Anchor -> YamlValue
Sequence :: [YamlValue] -> Anchor -> YamlValue
Scalar :: ByteString -> Tag -> Style -> Anchor -> YamlValue
Alias :: AnchorName -> YamlValue
type AnchorMap = Map AnchorName YamlValue
data RawDoc
RawDoc :: YamlValue -> AnchorMap -> RawDoc
parseRawDoc :: (FromYaml a, MonadThrow m) => RawDoc -> m a
(.:) :: FromYaml a => [(Text, YamlValue)] -> Text -> YamlParser a
data YamlParseException
UnexpectedEndOfEvents :: YamlParseException
UnexpectedEvent :: Event -> YamlParseException
FromYamlException :: Text -> YamlParseException
sinkValue :: MonadThrow m => ConduitM Event o (WriterT AnchorMap m) YamlValue
sinkRawDoc :: MonadThrow m => ConduitM Event o m RawDoc
readYamlFile :: FromYaml a => FilePath -> IO a
instance GHC.Show.Show Data.Yaml.Parser.YamlValue
instance GHC.Show.Show Data.Yaml.Parser.RawDoc
instance GHC.Show.Show Data.Yaml.Parser.YamlParseException
instance GHC.Exception.Type.Exception Data.Yaml.Parser.YamlParseException
instance Data.Yaml.Parser.FromYaml Data.Yaml.Parser.YamlValue
instance Data.Yaml.Parser.FromYaml a => Data.Yaml.Parser.FromYaml [a]
instance Data.Yaml.Parser.FromYaml Data.Text.Internal.Text
instance Data.Yaml.Parser.FromYaml GHC.Types.Int
instance GHC.Base.Functor Data.Yaml.Parser.YamlParser
instance GHC.Base.Applicative Data.Yaml.Parser.YamlParser
instance GHC.Base.Alternative Data.Yaml.Parser.YamlParser
instance GHC.Base.Semigroup (Data.Yaml.Parser.YamlParser a)
instance GHC.Base.Monoid (Data.Yaml.Parser.YamlParser a)
instance GHC.Base.Monad Data.Yaml.Parser.YamlParser
instance Control.Monad.Fail.MonadFail Data.Yaml.Parser.YamlParser
instance GHC.Base.MonadPlus Data.Yaml.Parser.YamlParser


-- | Prettier YAML encoding.
module Data.Yaml.Pretty

-- | Configurable <tt>encode</tt>.
encodePretty :: ToJSON a => Config -> a -> ByteString

data Config

getConfCompare :: Config -> Text -> Text -> Ordering

-- | Sets ordering for object keys
setConfCompare :: (Text -> Text -> Ordering) -> Config -> Config

getConfDropNull :: Config -> Bool

-- | Drop entries with <a>Null</a> value from objects, if set to
--   <a>True</a>
setConfDropNull :: Bool -> Config -> Config

-- | The default configuration: do not sort objects or drop keys
defConfig :: Config
pretty :: Config -> Value -> YamlBuilder

module Data.Yaml.TH

-- | A <tt>QuasiQuoter</tt> for YAML.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   {-# LANGUAGE QuasiQuotes #-}
--   import Data.Yaml.TH
--   
--   value :: Value
--   value = [yamlQQ|
--   name: John Doe
--   age: 23
--   |]
--   </pre>
yamlQQ :: QuasiQuoter

-- | Decode a YAML file at compile time. Only available on GHC version
--   <tt>7.8.1</tt> or higher.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   
--   config :: Config
--   config = $$(<a>decodeFile</a> "config.yaml")
--   </pre>
decodeFile :: forall a. (Lift a, FromJSON a) => FilePath -> Q (TExp a)
data () => Value
Object :: !Object -> Value
Array :: !Array -> Value
String :: !Text -> Value
Number :: !Scientific -> Value
Bool :: !Bool -> Value
Null :: Value
data () => Parser a
type Object = KeyMap Value
type Array = Vector Value
object :: [Pair] -> Value

-- | Construct a new <a>Value</a> from a list of <a>Value</a>s.
array :: [Value] -> Value
(.=) :: (KeyValue e kv, ToJSON v) => Key -> v -> kv
(.:) :: FromJSON a => Object -> Key -> Parser a
(.:?) :: FromJSON a => Object -> Key -> Parser (Maybe a)
(.!=) :: Parser (Maybe a) -> a -> Parser a
class () => FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONList :: FromJSON a => Value -> Parser [a]
omittedField :: FromJSON a => Maybe a
