-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic implementations of standard type classes. Operations on
--   generic representations to help using <a>GHC.Generics</a>. See README.
@package generic-data
@version 1.1.0.2


-- | Shim for backwards compatibility.
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Compat

-- | Lift the standard <a>readPrec</a> and <a>readListPrec</a> functions
--   through the type constructor.
readPrec1 :: (Read1 f, Read a) => ReadPrec (f a)

-- | Division (round down) of natural numbers. <tt>Div x 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Div (a :: Natural) (b :: Natural) :: Natural
infixl 7 `Div`


-- | Generic deriving for <a>Enum</a>, <a>Bounded</a> and <a>Ix</a>.
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Enum

-- | Generic <a>toEnum</a> generated with the <a>StandardEnum</a> option.
--   
--   <pre>
--   instance <a>Enum</a> MyType where
--     <a>toEnum</a> = <a>gtoEnum</a>
--     <a>fromEnum</a> = <a>gfromEnum</a>
--     <a>enumFrom</a> = <a>genumFrom</a>
--     <a>enumFromThen</a> = <a>genumFromThen</a>
--     <a>enumFromTo</a> = <a>genumFromTo</a>
--     <a>enumFromThenTo</a> = <a>genumFromThenTo</a>
--   </pre>
gtoEnum :: (Generic a, GEnum StandardEnum (Rep a)) => Int -> a

-- | Generic <a>fromEnum</a> generated with the <a>StandardEnum</a> option.
--   
--   See also <a>gtoEnum</a>.
gfromEnum :: (Generic a, GEnum StandardEnum (Rep a)) => a -> Int

-- | Generic <a>enumFrom</a> generated with the <a>StandardEnum</a> option.
--   
--   See also <a>gtoEnum</a>.
genumFrom :: (Generic a, GEnum StandardEnum (Rep a)) => a -> [a]

-- | Generic <a>enumFromThen</a> generated with the <a>StandardEnum</a>
--   option.
--   
--   See also <a>gtoEnum</a>.
genumFromThen :: (Generic a, GEnum StandardEnum (Rep a)) => a -> a -> [a]

-- | Generic <a>enumFromTo</a> generated with the <a>StandardEnum</a>
--   option.
--   
--   See also <a>gtoEnum</a>.
genumFromTo :: (Generic a, GEnum StandardEnum (Rep a)) => a -> a -> [a]

-- | Generic <a>enumFromThenTo</a> generated with the <a>StandardEnum</a>
--   option.
--   
--   See also <a>gtoEnum</a>.
genumFromThenTo :: (Generic a, GEnum StandardEnum (Rep a)) => a -> a -> a -> [a]

-- | Generic <a>toEnum</a> generated with the <a>FiniteEnum</a> option.
--   
--   <pre>
--   instance <a>Enum</a> MyType where
--     <a>toEnum</a> = <a>gtoFiniteEnum</a>
--     <a>fromEnum</a> = <a>gfromFiniteEnum</a>
--     <a>enumFrom</a> = <a>gfiniteEnumFrom</a>
--     <a>enumFromThen</a> = <a>gfiniteEnumFromThen</a>
--     <a>enumFromTo</a> = <a>gfiniteEnumFromTo</a>
--     <a>enumFromThenTo</a> = <a>gfiniteEnumFromThenTo</a>
--   </pre>
gtoFiniteEnum :: (Generic a, GEnum FiniteEnum (Rep a)) => Int -> a

-- | Generic <a>fromEnum</a> generated with the <a>FiniteEnum</a> option.
--   
--   See also <a>gtoFiniteEnum</a>.
gfromFiniteEnum :: (Generic a, GEnum FiniteEnum (Rep a)) => a -> Int

-- | Generic <a>enumFrom</a> generated with the <a>FiniteEnum</a> option.
--   
--   See also <a>gtoFiniteEnum</a>.
gfiniteEnumFrom :: (Generic a, GEnum FiniteEnum (Rep a)) => a -> [a]

-- | Generic <a>enumFromThen</a> generated with the <a>FiniteEnum</a>
--   option.
--   
--   See also <a>gtoFiniteEnum</a>.
gfiniteEnumFromThen :: (Generic a, GEnum FiniteEnum (Rep a)) => a -> a -> [a]

-- | Generic <a>enumFromTo</a> generated with the <a>FiniteEnum</a> option.
--   
--   See also <a>gtoFiniteEnum</a>.
gfiniteEnumFromTo :: (Generic a, GEnum FiniteEnum (Rep a)) => a -> a -> [a]

-- | Generic <a>enumFromThenTo</a> generated with the <a>FiniteEnum</a>
--   option.
--   
--   See also <a>gtoFiniteEnum</a>.
gfiniteEnumFromThenTo :: (Generic a, GEnum FiniteEnum (Rep a)) => a -> a -> a -> [a]

-- | Unsafe generic <a>toEnum</a>. Does not check whether the argument is
--   within valid bounds. Use <a>gtoEnum</a> or <a>gtoFiniteEnum</a>
--   instead.
gtoEnumRaw' :: forall opts a. (Generic a, GEnum opts (Rep a)) => Int -> a

-- | Generic <a>toEnum</a>. Use <a>gfromEnum</a> or <a>gfromFiniteEnum</a>
--   instead.
gtoEnum' :: forall opts a. (Generic a, GEnum opts (Rep a)) => String -> Int -> a

-- | Generic <a>fromEnum</a>. Use <a>gfromEnum</a> or
--   <a>gfromFiniteEnum</a> instead.
gfromEnum' :: forall opts a. (Generic a, GEnum opts (Rep a)) => a -> Int

-- | <pre>
--   genumMin == gfromEnum gminBound
--   </pre>
genumMin :: Int

-- | <pre>
--   genumMax == gfromEnum gmaxBound
--   </pre>
genumMax :: forall opts a. (Generic a, GEnum opts (Rep a)) => Int

-- | Generic <a>enumFrom</a>. Use <a>genumFrom</a> or
--   <a>gfiniteEnumFrom</a> instead.
genumFrom' :: forall opts a. (Generic a, GEnum opts (Rep a)) => a -> [a]

-- | Generic <a>enumFromThen</a>. Use <a>genumFromThen</a> or
--   <a>gfiniteEnumFromThen</a> instead.
genumFromThen' :: forall opts a. (Generic a, GEnum opts (Rep a)) => a -> a -> [a]

-- | Generic <a>enumFromTo</a>. Use <a>genumFromTo</a> or
--   <a>gfiniteEnumFromTo</a> instead.
genumFromTo' :: forall opts a. (Generic a, GEnum opts (Rep a)) => a -> a -> [a]

-- | Generic <a>enumFromThenTo</a>. Use <a>genumFromThenTo</a> or
--   <a>gfiniteEnumFromThenTo</a> instead.
genumFromThenTo' :: forall opts a. (Generic a, GEnum opts (Rep a)) => a -> a -> a -> [a]

-- | Generic <a>minBound</a>.
--   
--   <pre>
--   instance <a>Bounded</a> MyType where
--     <a>minBound</a> = <a>gminBound</a>
--     <a>maxBound</a> = <a>gmaxBound</a>
--   </pre>
gminBound :: (Generic a, GBounded (Rep a)) => a

-- | Generic <a>maxBound</a>.
--   
--   See also <a>gminBound</a>.
gmaxBound :: (Generic a, GBounded (Rep a)) => a

-- | Generic <a>range</a>.
--   
--   <pre>
--   import <a>Data.Ix</a>
--   instance <a>Ix</a> MyType where
--     <a>range</a> = <a>grange</a>
--     <a>index</a> = <a>gindex</a>
--     <a>inRange</a> = <a>ginRange</a>
--   </pre>
grange :: (Generic a, GIx (Rep a)) => (a, a) -> [a]

-- | Generic <a>index</a>.
--   
--   See also <a>grange</a>.
gindex :: (Generic a, GIx (Rep a)) => (a, a) -> a -> Int

-- | Generic <tt>unsafeIndex</tt>.
--   
--   <h3><b>Details</b></h3>
--   
--   The functions <tt>unsafeIndex</tt> and <tt>unsafeRangeSize</tt> belong
--   to <a>Ix</a> but are internal to GHC and hence not exported from the
--   module <a>Data.Ix</a>. However they are exported from the module
--   <tt>GHC.Arr</tt>. See <a>grange</a> for how to define an instance of
--   <a>Ix</a> such that it does not depend on the stability of GHCs
--   internal API. Unfortunately this results in additional (unnecessary)
--   bound checks. With the danger of having no stability guarantees for
--   GHC's internal API one can alternatively define an instance of
--   <a>Ix</a> as
--   
--   <pre>
--   import GHC.Arr
--   instance <a>Ix</a> MyType where
--     <a>range</a> = <a>grange</a>
--     unsafeIndex = <a>gunsafeIndex</a>
--     <a>inRange</a> = <a>ginRange</a>
--   </pre>
gunsafeIndex :: (Generic a, GIx (Rep a)) => (a, a) -> a -> Int

-- | Generic <a>inRange</a>.
--   
--   See also <a>grange</a>.
ginRange :: (Generic a, GIx (Rep a)) => (a, a) -> a -> Bool

-- | Generic representation of <a>Enum</a> types.
--   
--   The <tt>opts</tt> parameter is a type-level option to select different
--   implementations.
class GEnum opts f
gCardinality :: GEnum opts f => Int
gFromEnum :: GEnum opts f => f p -> Int
gToEnum :: GEnum opts f => Int -> f p

-- | Standard option for <a>GEnum</a>: derive <a>Enum</a> for types with
--   only nullary constructors (the same restrictions as in the <a>Haskell
--   2010 report</a>).
data StandardEnum

-- | Extends the <a>StandardEnum</a> option for <a>GEnum</a> to allow all
--   constructors to have arbitrary many fields. Each field type must be an
--   instance of both <a>Enum</a> and <a>Bounded</a>. Avoid fields of types
--   <a>Int</a> and <a>Word</a>.
--   
--   <h3><b>Details</b></h3>
--   
--   Two restrictions require the user's attention:
--   
--   <ul>
--   <li>The <a>Enum</a> instances of the field types need to start
--   enumerating from 0. In particular, <a>Int</a> is an unfit field type,
--   because the enumeration of the negative values starts before 0.</li>
--   <li>There can only be up to <tt><a>maxBound</a> :: <a>Int</a></tt>
--   values (because the implementation represents the cardinality
--   explicitly as an <a>Int</a>). This restriction makes <a>Word</a> an
--   invalid field type as well. Notably, it is insufficient for each
--   individual field types to stay below this limit. Instead it applies to
--   the generic type as a whole.</li>
--   </ul>
--   
--   Elements are numbered by <a>toEnum</a>, from <tt>0</tt> up to
--   <tt>(cardinality - 1)</tt>. The resulting ordering matches the generic
--   <a>Ord</a> instance defined by <a>gcompare</a>. The values from
--   different constructors are enumerated sequentially.
--   
--   <pre>
--   data Example = C0 Bool Bool | C1 Bool
--     deriving (<a>Eq</a>, <a>Ord</a>, <a>Show</a>, <a>Generic</a>)
--   
--   cardinality = 6  -- 2    * 2    + 2
--                    -- Bool * Bool | Bool
--   
--   enumeration =
--       [ C0 False False
--       , C0 False  True
--       , C0  True False
--       , C0  True  True
--       , C1 False
--       , C1 True
--       ]
--   
--   enumeration == map <a>gtoFiniteEnum</a> [0 .. 5]
--   [0 .. 5] == map <a>gfromFiniteEnum</a> enumeration
--   </pre>
data FiniteEnum

-- | Generic representation of <a>Bounded</a> types.
class GBounded f
gMinBound :: GBounded f => f p
gMaxBound :: GBounded f => f p

-- | Generic representation of <a>Ix</a> types.
class GIx f
gRange :: GIx f => (f p, f p) -> [f p]
gUnsafeIndex :: GIx f => (f p, f p) -> f p -> Int
gInRange :: GIx f => (f p, f p) -> f p -> Bool
instance Generic.Data.Internal.Enum.GBounded f => Generic.Data.Internal.Enum.GBounded (GHC.Generics.M1 i c f)
instance Generic.Data.Internal.Enum.GIx f => Generic.Data.Internal.Enum.GIx (GHC.Generics.M1 i c f)
instance (Generic.Data.Internal.Enum.GEnum Generic.Data.Internal.Enum.StandardEnum f, Generic.Data.Internal.Enum.GEnum Generic.Data.Internal.Enum.StandardEnum g) => Generic.Data.Internal.Enum.GIx (f GHC.Generics.:+: g)
instance (Generic.Data.Internal.Enum.GIx f, Generic.Data.Internal.Enum.GIx g) => Generic.Data.Internal.Enum.GIx (f GHC.Generics.:*: g)
instance Generic.Data.Internal.Enum.GIx GHC.Generics.U1
instance GHC.Ix.Ix c => Generic.Data.Internal.Enum.GIx (GHC.Generics.K1 i c)
instance Generic.Data.Internal.Enum.GBounded GHC.Generics.U1
instance GHC.Enum.Bounded c => Generic.Data.Internal.Enum.GBounded (GHC.Generics.K1 i c)
instance (Generic.Data.Internal.Enum.GBounded f, Generic.Data.Internal.Enum.GBounded g) => Generic.Data.Internal.Enum.GBounded (f GHC.Generics.:+: g)
instance (Generic.Data.Internal.Enum.GBounded f, Generic.Data.Internal.Enum.GBounded g) => Generic.Data.Internal.Enum.GBounded (f GHC.Generics.:*: g)
instance (Generic.Data.Internal.Enum.GEnum Generic.Data.Internal.Enum.FiniteEnum f, Generic.Data.Internal.Enum.GEnum Generic.Data.Internal.Enum.FiniteEnum g) => Generic.Data.Internal.Enum.GEnum Generic.Data.Internal.Enum.FiniteEnum (f GHC.Generics.:*: g)
instance (GHC.Enum.Bounded c, GHC.Enum.Enum c) => Generic.Data.Internal.Enum.GEnum Generic.Data.Internal.Enum.FiniteEnum (GHC.Generics.K1 i c)
instance Generic.Data.Internal.Enum.GEnum opts f => Generic.Data.Internal.Enum.GEnum opts (GHC.Generics.M1 i c f)
instance (Generic.Data.Internal.Enum.GEnum opts f, Generic.Data.Internal.Enum.GEnum opts g) => Generic.Data.Internal.Enum.GEnum opts (f GHC.Generics.:+: g)
instance Generic.Data.Internal.Enum.GEnum opts GHC.Generics.U1


-- | Error messages.
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Error
type family HasSum f
class Assert (pred :: Bool) (msg :: ErrorMessage)

-- | <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric -XDerivingVia
--   
--   &gt;&gt;&gt; import Generic.Data (Generically(..))
--   
--   &gt;&gt;&gt; :{
--     data AB = A | B
--       deriving stock Generic
--       deriving Semigroup via Generically AB
--   :}
--   ...
--       • Cannot derive Semigroup instance for AB due to sum type
--       • When deriving the instance for (Semigroup AB)
--   </pre>
type AssertNoSum (constraint :: Type -> Constraint) a = Assert (Not (HasSum (Rep a))) ('Text "Cannot derive " ':<>: 'ShowType constraint ':<>: 'Text " instance for " ':<>: 'ShowType a ':<>: 'Text " due to sum type")
instance Generic.Data.Internal.Error.Assert 'GHC.Types.True msg
instance ((TypeError ...) GHC.Types.~ '()) => Generic.Data.Internal.Error.Assert 'GHC.Types.False msg


-- | Type-level functions on generic representations.
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Functions

-- | Number of constructors of a data type.
type family NConstructors (r :: k -> Type) :: Nat

-- | Number of constructors of a data type.
nconstructors :: forall r. KnownNat (NConstructors r) => Integer

-- | Arity of a constructor.
type family NFields (r :: k -> Type) :: Nat

-- | Arity of a constructor.
nfields :: forall r. KnownNat (NFields r) => Integer


-- | Type metadata accessors
--   
--   Type names, constructor names...
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Meta

-- | Name of the first data constructor in a type as a string.
--   
--   <pre>
--   &gt;&gt;&gt; gdatatypeName @(Maybe Int)
--   "Maybe"
--   </pre>
gdatatypeName :: forall a. (Generic a, GDatatype (Rep a)) => String

-- | Name of the module where the first type constructor is defined.
--   
--   <pre>
--   &gt;&gt;&gt; gmoduleName @(ZipList Int)
--   "Control.Applicative"
--   </pre>
gmoduleName :: forall a. (Generic a, GDatatype (Rep a)) => String

-- | Name of the package where the first type constructor is defined.
--   
--   <pre>
--   &gt;&gt;&gt; gpackageName @(Maybe Int)
--   "base"
--   </pre>
gpackageName :: forall a. (Generic a, GDatatype (Rep a)) => String

-- | <a>True</a> if the first type constructor is a newtype.
--   
--   <pre>
--   &gt;&gt;&gt; gisNewtype @[Int]
--   False
--   
--   &gt;&gt;&gt; gisNewtype @(ZipList Int)
--   True
--   </pre>
gisNewtype :: forall a. (Generic a, GDatatype (Rep a)) => Bool
fromDatatype :: forall d r. Datatype d => (M1 D d Proxy () -> r) -> r

-- | Generic representations that contain datatype metadata.
class GDatatype f
gDatatypeName :: GDatatype f => String
gModuleName :: GDatatype f => String
gPackageName :: GDatatype f => String
gIsNewtype :: GDatatype f => Bool

-- | Name of the first constructor in a value.
--   
--   <pre>
--   &gt;&gt;&gt; gconName (Just 0)
--   "Just"
--   </pre>
gconName :: forall a. Constructors a => a -> String

-- | The fixity of the first constructor.
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Generics ((:*:)(..))
--   
--   &gt;&gt;&gt; gconFixity (Just 0)
--   Prefix
--   
--   &gt;&gt;&gt; gconFixity ([] :*: id)
--   Infix RightAssociative 6
--   </pre>
gconFixity :: forall a. Constructors a => a -> Fixity

-- | <a>True</a> if the constructor is a record.
--   
--   <pre>
--   &gt;&gt;&gt; gconIsRecord (Just 0)
--   False
--   
--   &gt;&gt;&gt; gconIsRecord (Sum 0)   -- Note:  newtype Sum a = Sum { getSum :: a }
--   True
--   </pre>
gconIsRecord :: forall a. Constructors a => a -> Bool

-- | Number of constructors.
--   
--   <pre>
--   &gt;&gt;&gt; gconNum @(Maybe Int)
--   2
--   </pre>
gconNum :: forall a. Constructors a => Int

-- | Index of a constructor.
--   
--   <pre>
--   &gt;&gt;&gt; gconIndex Nothing
--   0
--   
--   &gt;&gt;&gt; gconIndex (Just "test")
--   1
--   </pre>
gconIndex :: forall a. Constructors a => a -> Int

-- | An opaque identifier for a constructor.
newtype ConId a
ConId :: Int -> ConId a

-- | Identifier of a constructor.
conId :: forall a. Constructors a => a -> ConId a

-- | Index of a constructor, given its identifier. See also
--   <a>gconIndex</a>.
conIdToInt :: forall a. ConId a -> Int

-- | Name of a constructor. See also <a>gconName</a>.
conIdToString :: forall a. Constructors a => ConId a -> String

-- | All constructor identifiers.
--   
--   <pre>
--   <a>gconNum</a> @a = length (<a>conIdEnum</a> @a)
--   </pre>
conIdEnum :: forall a. Constructors a => [ConId a]

-- | The first constructor. This must not be called on an empty type.
conIdMin :: forall a. (Constructors a, NonEmptyType "conIdMin" a) => ConId a

-- | The last constructor. This must not be called on an empty type.
conIdMax :: forall a. (Constructors a, NonEmptyType "conIdMax" a) => ConId a

-- | Get a <a>ConId</a> by name.
--   
--   <pre>
--   &gt;&gt;&gt; conIdNamed @"Nothing" :: ConId (Maybe Int)
--   ConId 0
--   
--   &gt;&gt;&gt; conIdNamed @"Just"    :: ConId (Maybe Int)
--   ConId 1
--   </pre>
conIdNamed :: forall s a. ConIdNamed s a => ConId a

-- | Constraint synonym for <a>Generic</a> and <a>GConstructors</a>.
class (Generic a, GConstructors (Rep a)) => Constructors a

-- | Constraint synonym for generic types <tt>a</tt> with a constructor
--   named <tt>n</tt>.
class (Generic a, KnownNat (ConIdNamed' n a)) => ConIdNamed n a
newtype GConId r
GConId :: Int -> GConId r
gConIdToInt :: GConId r -> Int
toConId :: forall a. Generic a => GConId (Rep a) -> ConId a
fromConId :: forall a. Generic a => ConId a -> GConId (Rep a)
reGConId :: GConId r -> GConId s
gConIdMin :: forall r. GConstructors r => GConId r
gConIdMax :: forall r. GConstructors r => GConId r

-- | Generic representations that contain constructor metadata.
class GConstructors r
gConIdToString :: GConstructors r => GConId r -> String
gConId :: GConstructors r => r p -> GConId r
gConNum :: GConstructors r => Int
gConFixity :: GConstructors r => r p -> Fixity
gConIsRecord :: GConstructors r => r p -> Bool
type ConIdNamed' n t = GConIdNamedIf n t (GConIdNamed n (Rep t))
type GConIdNamed n f = GConIdNamed' n f 0 'Nothing
type family GConIdNamed' (n :: Symbol) (f :: k -> Type) (i :: Nat) (o :: Maybe Nat) :: Maybe Nat
type family GConIdNamedIf (n :: Symbol) (t :: Type) (o :: Maybe Nat) :: Nat

-- | Constraint that a generic type <tt>a</tt> is not empty. Producing an
--   error message otherwise.
--   
--   The <a>Symbol</a> parameter <tt>fname</tt> is used only for error
--   messages.
--   
--   It is implied by the simpler constraint <tt><a>IsEmptyType</a> a ~
--   'False</tt>
class NonEmptyType_ fname a => NonEmptyType fname a

-- | Internal definition of <a>NonEmptyType</a>. It is implied by the
--   simpler constraint <tt><a>IsEmptyType</a> a ~ 'False</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeFamilies
--   
--   &gt;&gt;&gt; :{
--   conIdMin' :: (Constructors a, IsEmptyType a ~ 'False) =&gt; ConId a
--   conIdMin' = conIdMin
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   conIdMax' :: (Constructors a, IsEmptyType a ~ 'False) =&gt; ConId a
--   conIdMax' = conIdMax
--   :}
--   </pre>
type NonEmptyType_ fname a = (ErrorIfEmpty fname a (IsEmptyType a) ~ '())
type family GIsEmptyType (r :: k -> Type) :: Bool

-- | <a>True</a> if the generic type <tt>a</tt> is empty.
type IsEmptyType a = IsEmptyType_ a

-- | Internal definition of <a>IsEmptyType</a>.
type IsEmptyType_ a = GIsEmptyType (Rep a)

-- | Throw an error if the boolean <tt>b</tt> is true, meaning that the
--   type <tt>a</tt> is empty.
--   
--   Example:
--   
--   <pre>
--   ghci&gt; data E deriving Generic
--   ghci&gt; conIdMin :: ConId E
--   </pre>
--   
--   Error message:
--   
--   <pre>
--   The function 'conIdMin' cannot be used with the empty type E
--   </pre>
type family ErrorIfEmpty (fname :: Symbol) (a :: Type) (b :: Bool) :: ()

-- | <a>Meta</a> field of the <a>M1</a> type constructor.
type family MetaOf (f :: Type -> Type) :: Meta

-- | Name of the data type (<a>MetaData</a>).
type family MetaDataName (m :: Meta) :: Symbol

-- | Name of the module where the data type is defined (<a>MetaData</a>)
type family MetaDataModule (m :: Meta) :: Symbol

-- | Name of the package where the data type is defined (<a>MetaData</a>)
type family MetaDataPackage (m :: Meta) :: Symbol

-- | <tt>True</tt> if the data type is a newtype (<a>MetaData</a>).
type family MetaDataNewtype (m :: Meta) :: Bool

-- | Name of the constructor (<a>MetaCons</a>).
type family MetaConsName (m :: Meta) :: Symbol

-- | Fixity of the constructor (<a>MetaCons</a>).
type family MetaConsFixity (m :: Meta) :: FixityI

-- | <tt>True</tt> for a record constructor (<a>MetaCons</a>).
type family MetaConsRecord (m :: Meta) :: Bool

-- | <tt>Just</tt> the name of the record field, if it is one
--   (<a>MetaSel</a>).
type family MetaSelNameM (m :: Meta) :: Maybe Symbol

-- | Name of the record field; undefined for non-record fields
--   (<a>MetaSel</a>).
type family MetaSelName (m :: Meta) :: Symbol

-- | Unpackedness annotation of a field (<a>MetaSel</a>).
type family MetaSelUnpack (m :: Meta) :: SourceUnpackedness

-- | Strictness annotation of a field (<a>MetaSel</a>).
type family MetaSelSourceStrictness (m :: Meta) :: SourceStrictness

-- | Inferred strictness of a field (<a>MetaSel</a>).
type family MetaSelStrictness (m :: Meta) :: DecidedStrictness

-- | A placeholder for <a>Meta</a> values.
type DummyMeta = 'MetaData "" "" "" 'False

-- | Remove an <a>M1</a> type constructor.
type family UnM1 (f :: k -> Type) :: k -> Type
instance forall k (a :: k). GHC.Show.Show (Generic.Data.Internal.Meta.ConId a)
instance forall k (a :: k). GHC.Classes.Ord (Generic.Data.Internal.Meta.ConId a)
instance forall k (a :: k). GHC.Classes.Eq (Generic.Data.Internal.Meta.ConId a)
instance forall k (r :: k). GHC.Classes.Ord (Generic.Data.Internal.Meta.GConId r)
instance forall k (r :: k). GHC.Classes.Eq (Generic.Data.Internal.Meta.GConId r)
instance Generic.Data.Internal.Meta.NonEmptyType_ fname a => Generic.Data.Internal.Meta.NonEmptyType fname a
instance (GHC.Generics.Generic a, GHC.TypeNats.KnownNat (Generic.Data.Internal.Meta.ConIdNamed' n a)) => Generic.Data.Internal.Meta.ConIdNamed n a
instance (GHC.Generics.Generic a, Generic.Data.Internal.Meta.GConstructors (GHC.Generics.Rep a)) => Generic.Data.Internal.Meta.Constructors a
instance forall k (f :: k -> *) (c :: GHC.Generics.Meta). Generic.Data.Internal.Meta.GConstructors f => Generic.Data.Internal.Meta.GConstructors (GHC.Generics.M1 GHC.Generics.D c f)
instance forall k (f :: k -> *) (g :: k -> *). (Generic.Data.Internal.Meta.GConstructors f, Generic.Data.Internal.Meta.GConstructors g) => Generic.Data.Internal.Meta.GConstructors (f GHC.Generics.:+: g)
instance forall k (c :: GHC.Generics.Meta) (f :: k -> *). GHC.Generics.Constructor c => Generic.Data.Internal.Meta.GConstructors (GHC.Generics.M1 GHC.Generics.C c f)
instance Generic.Data.Internal.Meta.GConstructors GHC.Generics.V1
instance forall k (d :: GHC.Generics.Meta) (f :: k -> *). GHC.Generics.Datatype d => Generic.Data.Internal.Meta.GDatatype (GHC.Generics.M1 GHC.Generics.D d f)


-- | Pack/unpack newtypes.
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Newtype

-- | Class of newtypes. There is an instance <tt><a>Newtype</a> a</tt> if
--   and only if <tt>a</tt> is a newtype and an instance of <a>Generic</a>.
class (Generic a, Coercible a (Old a), Newtype' a) => Newtype a

-- | The type wrapped by a newtype.
--   
--   <pre>
--   newtype Foo = Foo { bar :: Bar } deriving <a>Generic</a>
--   -- Old Foo ~ Bar
--   </pre>
type Old a = GOld (Rep a)
type family GOld (f :: Type -> Type)

-- | Use <a>Newtype</a> instead.
type Newtype' a = NewtypeErr a (MetaDataNewtype (MetaOf (Rep a)))
type family NewtypeErr a (b :: Bool) :: Constraint

-- | Generic newtype destructor.
unpack :: Newtype a => a -> Old a

-- | Generic newtype constructor.
pack :: Newtype a => Old a -> a
instance (GHC.Generics.Generic a, GHC.Types.Coercible a (Generic.Data.Internal.Newtype.Old a), Generic.Data.Internal.Newtype.Newtype' a) => Generic.Data.Internal.Newtype.Newtype a


-- | Newtypes with special instances for deriving.
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Resolvers

-- | A newtype whose instances for simple classes (<a>Eq</a>, <a>Ord</a>,
--   <a>Read</a>, <a>Show</a>) use higher-kinded class instances for
--   <tt>f</tt> (<a>Eq1</a>, <a>Ord1</a>, <a>Read1</a>, <a>Show1</a>).
newtype Id1 f a
Id1 :: f a -> Id1 f a
[unId1] :: Id1 f a -> f a

-- | A newtype with trivial instances, that considers every value
--   equivalent to every other one, and shows as just <tt>"_"</tt>.
newtype Opaque a
Opaque :: a -> Opaque a
[unOpaque] :: Opaque a -> a

-- | A higher-kinded version of <a>Opaque</a>.
newtype Opaque1 f a
Opaque1 :: f a -> Opaque1 f a
[unOpaque1] :: Opaque1 f a -> f a
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Generic.Data.Internal.Resolvers.Id1 f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Generic.Data.Internal.Resolvers.Id1 f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Generic.Data.Internal.Resolvers.Id1 f)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Generic.Data.Internal.Resolvers.Id1 f)
instance GHC.Classes.Eq (Generic.Data.Internal.Resolvers.Opaque1 f a)
instance GHC.Classes.Ord (Generic.Data.Internal.Resolvers.Opaque1 f a)
instance GHC.Show.Show (Generic.Data.Internal.Resolvers.Opaque1 f a)
instance Data.Functor.Classes.Eq1 (Generic.Data.Internal.Resolvers.Opaque1 f)
instance Data.Functor.Classes.Ord1 (Generic.Data.Internal.Resolvers.Opaque1 f)
instance Data.Functor.Classes.Show1 (Generic.Data.Internal.Resolvers.Opaque1 f)
instance GHC.Classes.Eq (Generic.Data.Internal.Resolvers.Opaque a)
instance GHC.Classes.Ord (Generic.Data.Internal.Resolvers.Opaque a)
instance GHC.Show.Show (Generic.Data.Internal.Resolvers.Opaque a)
instance Data.Functor.Classes.Eq1 Generic.Data.Internal.Resolvers.Opaque
instance Data.Functor.Classes.Ord1 Generic.Data.Internal.Resolvers.Opaque
instance Data.Functor.Classes.Show1 Generic.Data.Internal.Resolvers.Opaque
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Generic.Data.Internal.Resolvers.Id1 f a)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Generic.Data.Internal.Resolvers.Id1 f a)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => GHC.Read.Read (Generic.Data.Internal.Resolvers.Id1 f a)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Generic.Data.Internal.Resolvers.Id1 f a)


-- | Generic implementation of <a>Foldable</a> and <a>Traversable</a>.
--   
--   There is already a naive implementation using the generic
--   <tt><a>Rep</a></tt>'s own instances of <a>Foldable</a> and
--   <a>Traversable</a>. However, deriving then generates a lot of code
--   that may not be simplified away by GHC, that results in unnecessary
--   run-time overhead.
--   
--   In contrast, this implementation guarantees that the generated code is
--   identical to stock-derived instances of <a>Foldable</a> and
--   <a>Traversable</a>, which have the following syntactic properties:
--   
--   <ul>
--   <li>constructors with zero fields use <a>pure</a> once;</li>
--   <li>constructors with one field use <a>fmap</a> once;</li>
--   <li>constructors with n &gt;= 2 fields use <a>liftA2</a> once and
--   <tt>(<a>&lt;*&gt;</a>)</tt> n-2 times.</li>
--   </ul>
--   
--   The heavy lifting is actually done by the ap-normalize library.
module Generic.Data.Internal.Traversable

-- | Generic <a>foldMap</a>.
--   
--   <pre>
--   instance <a>Foldable</a> MyTypeF where
--     <a>foldMap</a> = <a>gfoldMap</a>
--   </pre>
gfoldMap :: (Generic1 f, GFoldable (Rep1 f), Monoid m) => (a -> m) -> f a -> m

-- | Generic <a>traverse</a>.
--   
--   <pre>
--   instance <a>Traversable</a> MyTypeF where
--     <a>traverse</a> = <a>gtraverse</a>
--   </pre>
gtraverse :: (Generic1 f, GTraversable (Rep1 f), Applicative m) => (a -> m b) -> f a -> m (f b)

-- | Generic <a>sequenceA</a>.
--   
--   <pre>
--   instance <a>Traversable</a> MyTypeF where
--     <a>sequenceA</a> = <a>gsequenceA</a>
--   </pre>
--   
--   See also <a>gtraverse</a>.
gsequenceA :: (Generic1 f, GTraversable (Rep1 f), Applicative m) => f (m a) -> m (f a)

-- | Class of generic representations for which <a>Foldable</a> can be
--   derived.
class GFoldable_ t => GFoldable t

-- | Class of generic representations for which <a>Traversable</a> can be
--   derived.
class GTraversable_ t => GTraversable t

-- | Internal definition of <a>GFoldable</a>.
class (GFoldMap t, Foldable t) => GFoldable_ t

-- | Internal definition of <a>GTraversable</a>.
class (GTraverse Kleisli t, GTraverse Equal t) => GTraversable_ t

-- | Isomorphic to <tt>Maybe m</tt>, but we need to micromanage the use of
--   Monoid vs Semigroup to match exactly the output of stock deriving, for
--   inspection testing.
data Maybe' m
Nothing' :: Maybe' m
Just' :: m -> Maybe' m
type EndoM m = Endo (Maybe' m)
liftEndoM :: Monoid m => m -> EndoM m
lowerEndoM :: Monoid m => EndoM m -> m
lowerMaybe :: Monoid m => Maybe' m -> m
class GFoldMap t
gfoldMap_ :: (GFoldMap t, Monoid m) => (a -> m) -> t a -> EndoM m
data Equal (f :: Type -> Type) a b
[Refl] :: Equal f (f b) b
newtype Kleisli f a b
Kleisli :: (a -> f b) -> Kleisli f a b
class GTraverse arr t
gtraverse_ :: (GTraverse arr t, Applicative f) => arr f a b -> t a -> Aps f (t b)
instance Generic.Data.Internal.Traversable.GTraversable_ t => Generic.Data.Internal.Traversable.GTraversable t
instance (Generic.Data.Internal.Traversable.GTraverse Generic.Data.Internal.Traversable.Kleisli t, Generic.Data.Internal.Traversable.GTraverse Generic.Data.Internal.Traversable.Equal t) => Generic.Data.Internal.Traversable.GTraversable_ t
instance Generic.Data.Internal.Traversable.GTraverse arr f => Generic.Data.Internal.Traversable.GTraverse arr (GHC.Generics.M1 i c f)
instance (Generic.Data.Internal.Traversable.GTraverse arr f, Generic.Data.Internal.Traversable.GTraverse arr g) => Generic.Data.Internal.Traversable.GTraverse arr (f GHC.Generics.:+: g)
instance (Generic.Data.Internal.Traversable.GTraverse arr f, Generic.Data.Internal.Traversable.GTraverse arr g) => Generic.Data.Internal.Traversable.GTraverse arr (f GHC.Generics.:*: g)
instance Generic.Data.Internal.Traversable.GTraverse arr GHC.Generics.U1
instance Generic.Data.Internal.Traversable.GTraverse arr GHC.Generics.V1
instance Generic.Data.Internal.Traversable.GTraverse arr (GHC.Generics.K1 i a)
instance Generic.Data.Internal.Traversable.GTraverse Generic.Data.Internal.Traversable.Kleisli GHC.Generics.Par1
instance Data.Traversable.Traversable t => Generic.Data.Internal.Traversable.GTraverse Generic.Data.Internal.Traversable.Kleisli (GHC.Generics.Rec1 t)
instance (Data.Traversable.Traversable t, Data.Traversable.Traversable f) => Generic.Data.Internal.Traversable.GTraverse Generic.Data.Internal.Traversable.Kleisli (t GHC.Generics.:.: f)
instance Generic.Data.Internal.Traversable.GTraverse Generic.Data.Internal.Traversable.Equal GHC.Generics.Par1
instance Data.Traversable.Traversable t => Generic.Data.Internal.Traversable.GTraverse Generic.Data.Internal.Traversable.Equal (GHC.Generics.Rec1 t)
instance (Data.Traversable.Traversable t, Data.Traversable.Traversable f) => Generic.Data.Internal.Traversable.GTraverse Generic.Data.Internal.Traversable.Equal (t GHC.Generics.:.: f)
instance Generic.Data.Internal.Traversable.GFoldable_ t => Generic.Data.Internal.Traversable.GFoldable t
instance (Generic.Data.Internal.Traversable.GFoldMap t, Data.Foldable.Foldable t) => Generic.Data.Internal.Traversable.GFoldable_ t
instance Generic.Data.Internal.Traversable.GFoldMap f => Generic.Data.Internal.Traversable.GFoldMap (GHC.Generics.M1 i c f)
instance (Generic.Data.Internal.Traversable.GFoldMap f, Generic.Data.Internal.Traversable.GFoldMap g) => Generic.Data.Internal.Traversable.GFoldMap (f GHC.Generics.:+: g)
instance (Generic.Data.Internal.Traversable.GFoldMap f, Generic.Data.Internal.Traversable.GFoldMap g) => Generic.Data.Internal.Traversable.GFoldMap (f GHC.Generics.:*: g)
instance Generic.Data.Internal.Traversable.GFoldMap GHC.Generics.U1
instance Generic.Data.Internal.Traversable.GFoldMap GHC.Generics.V1
instance Generic.Data.Internal.Traversable.GFoldMap (GHC.Generics.K1 i a)
instance Generic.Data.Internal.Traversable.GFoldMap GHC.Generics.Par1
instance Data.Foldable.Foldable t => Generic.Data.Internal.Traversable.GFoldMap (GHC.Generics.Rec1 t)
instance (Data.Foldable.Foldable t, Data.Foldable.Foldable f) => Generic.Data.Internal.Traversable.GFoldMap (t GHC.Generics.:.: f)


-- | Utilities.
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Utils

-- | Convert between types with representationally equivalent generic
--   representations.
gcoerce :: (Generic a, Generic b, Coercible (Rep a) (Rep b)) => a -> b

-- | Compose <a>gcoerce</a> with a binary operation.
gcoerceBinop :: (Generic a, Generic b, Coercible (Rep a) (Rep b)) => (a -> a -> a) -> b -> b -> b

-- | Coerce while preserving the type index.
coerce' :: Coercible (f x) (g x) => f x -> g x
coerce1 :: Coercible f g => f x -> g x

-- | Elimination of <tt>V1</tt>.
absurd1 :: V1 x -> a

-- | A helper for better type inference.
from' :: Generic a => a -> Rep a ()

-- | A helper for better type inference.
to' :: Generic a => Rep a () -> a

-- | Lift binary combinators generically.
liftG2 :: Generic1 f => (Rep1 f a -> Rep1 f b -> Rep1 f c) -> f a -> f b -> f c

-- | Returns <a>True</a> if the argument is a symbolic data constructor
--   name (e.g., <tt>(:+:)</tt>). Returns <a>False</a> otherwise.
isSymDataCon :: String -> Bool

-- | Returns <a>True</a> if the argument is a symbolic value name (e.g.,
--   <tt>(+++)</tt>). Returns <a>False</a> otherwise.
isSymVar :: String -> Bool


-- | Generic implementation of Show
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Show

-- | Generic <a>showsPrec</a>.
--   
--   <pre>
--   instance <a>Show</a> MyType where
--     <a>showsPrec</a> = <a>gshowsPrec</a>
--   </pre>
gshowsPrec :: (Generic a, GShow0 (Rep a)) => Int -> a -> ShowS
gprecShows :: (Generic a, GShow0 (Rep a)) => a -> PrecShowS

-- | Generic representation of <a>Show</a> types.
type GShow0 = GShow Proxy

-- | Generic <a>liftShowsPrec</a>.
gliftShowsPrec :: (Generic1 f, GShow1 (Rep1 f)) => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS
gLiftPrecShows :: GShow1 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> f a -> PrecShowS
type ShowsPrec a = (Int -> a -> ShowS, [a] -> ShowS)

-- | Generic representation of <a>Show1</a> types.
type GShow1 = GShow Identity
class GShow p f
gPrecShows :: GShow p f => p (ShowsPrec a) -> f a -> PrecShowS
class GShowC p c f
gPrecShowsC :: GShowC p c f => p (ShowsPrec a) -> String -> Fixity -> M1 C c f a -> PrecShowS
class GShowFields p f
gPrecShowsFields :: GShowFields p f => p (ShowsPrec a) -> f a -> [PrecShowS]
class GShowNamed p f
gPrecShowsNamed :: GShowNamed p f => p (ShowsPrec a) -> f a -> ShowFields
class GShowSingle p f
gPrecShowsSingle :: GShowSingle p f => p (ShowsPrec a) -> f a -> PrecShowS
surroundConName :: Fixity -> String -> String
instance Generic.Data.Internal.Show.GShowSingle p f => Generic.Data.Internal.Show.GShowFields p (GHC.Generics.M1 GHC.Generics.S c f)
instance (GHC.Generics.Selector c, Generic.Data.Internal.Show.GShowSingle p f) => Generic.Data.Internal.Show.GShowNamed p (GHC.Generics.M1 GHC.Generics.S c f)
instance GHC.Show.Show a => Generic.Data.Internal.Show.GShowSingle p (GHC.Generics.K1 i a)
instance Data.Functor.Classes.Show1 f => Generic.Data.Internal.Show.GShowSingle Data.Functor.Identity.Identity (GHC.Generics.Rec1 f)
instance Generic.Data.Internal.Show.GShowSingle Data.Functor.Identity.Identity GHC.Generics.Par1
instance (Data.Functor.Classes.Show1 f, Generic.Data.Internal.Show.GShowSingle p g) => Generic.Data.Internal.Show.GShowSingle p (f GHC.Generics.:.: g)
instance Generic.Data.Internal.Show.GShowNamed p f => Generic.Data.Internal.Show.GShowC p ('GHC.Generics.MetaCons s y 'GHC.Types.True) f
instance (Generic.Data.Internal.Show.GShowNamed p f, Generic.Data.Internal.Show.GShowNamed p g) => Generic.Data.Internal.Show.GShowNamed p (f GHC.Generics.:*: g)
instance Generic.Data.Internal.Show.GShowNamed p GHC.Generics.U1
instance Generic.Data.Internal.Show.GShowFields p f => Generic.Data.Internal.Show.GShowC p ('GHC.Generics.MetaCons s y 'GHC.Types.False) f
instance (Generic.Data.Internal.Show.GShowFields p f, Generic.Data.Internal.Show.GShowFields p g) => Generic.Data.Internal.Show.GShowFields p (f GHC.Generics.:*: g)
instance Generic.Data.Internal.Show.GShowFields p GHC.Generics.U1
instance (GHC.Generics.Constructor c, Generic.Data.Internal.Show.GShowC p c f) => Generic.Data.Internal.Show.GShow p (GHC.Generics.M1 GHC.Generics.C c f)
instance Generic.Data.Internal.Show.GShow p f => Generic.Data.Internal.Show.GShow p (GHC.Generics.M1 GHC.Generics.D d f)
instance (Generic.Data.Internal.Show.GShow p f, Generic.Data.Internal.Show.GShow p g) => Generic.Data.Internal.Show.GShow p (f GHC.Generics.:+: g)
instance Generic.Data.Internal.Show.GShow p GHC.Generics.V1


-- | Generic representations as data types.
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Data

-- | Synthetic data type.
--   
--   A wrapper to view a generic <a>Rep</a> as the datatype it's supposed
--   to represent, without needing a declaration.
newtype Data r p
Data :: r p -> Data r p
[unData] :: Data r p -> r p

-- | Conversion between a generic type and the synthetic type made using
--   its representation. Inverse of <a>fromData</a>.
toData :: Generic a => a -> Data (Rep a) p

-- | Inverse of <a>toData</a>.
fromData :: Generic a => Data (Rep a) p -> a
instance GHC.Base.Monoid (r p) => GHC.Base.Monoid (Generic.Data.Internal.Data.Data r p)
instance GHC.Base.Semigroup (r p) => GHC.Base.Semigroup (Generic.Data.Internal.Data.Data r p)
instance Data.Functor.Classes.Ord1 r => Data.Functor.Classes.Ord1 (Generic.Data.Internal.Data.Data r)
instance Data.Functor.Classes.Eq1 r => Data.Functor.Classes.Eq1 (Generic.Data.Internal.Data.Data r)
instance GHC.Classes.Ord (r p) => GHC.Classes.Ord (Generic.Data.Internal.Data.Data r p)
instance GHC.Classes.Eq (r p) => GHC.Classes.Eq (Generic.Data.Internal.Data.Data r p)
instance Data.Functor.Contravariant.Contravariant r => Data.Functor.Contravariant.Contravariant (Generic.Data.Internal.Data.Data r)
instance GHC.Base.MonadPlus r => GHC.Base.MonadPlus (Generic.Data.Internal.Data.Data r)
instance GHC.Base.Monad r => GHC.Base.Monad (Generic.Data.Internal.Data.Data r)
instance GHC.Base.Alternative r => GHC.Base.Alternative (Generic.Data.Internal.Data.Data r)
instance GHC.Base.Applicative r => GHC.Base.Applicative (Generic.Data.Internal.Data.Data r)
instance Data.Traversable.Traversable r => Data.Traversable.Traversable (Generic.Data.Internal.Data.Data r)
instance Data.Foldable.Foldable r => Data.Foldable.Foldable (Generic.Data.Internal.Data.Data r)
instance GHC.Base.Functor r => GHC.Base.Functor (Generic.Data.Internal.Data.Data r)
instance (GHC.Base.Functor r, Data.Functor.Contravariant.Contravariant r) => GHC.Generics.Generic (Generic.Data.Internal.Data.Data r p)
instance GHC.Generics.Generic1 (Generic.Data.Internal.Data.Data r)
instance (Generic.Data.Internal.Show.GShow1 r, GHC.Show.Show p) => GHC.Show.Show (Generic.Data.Internal.Data.Data r p)
instance Generic.Data.Internal.Show.GShow1 r => Data.Functor.Classes.Show1 (Generic.Data.Internal.Data.Data r)
instance Generic.Data.Internal.Enum.GEnum Generic.Data.Internal.Enum.StandardEnum r => GHC.Enum.Enum (Generic.Data.Internal.Data.Data r p)
instance Generic.Data.Internal.Enum.GBounded r => GHC.Enum.Bounded (Generic.Data.Internal.Data.Data r p)


-- | Generic implementation of Read
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Read

-- | Generic <a>readPrec</a>.
--   
--   <pre>
--   instance <a>Read</a> MyType where
--     <a>readPrec</a> = <a>greadPrec</a>
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
greadPrec :: (Generic a, GRead0 (Rep a)) => ReadPrec a

-- | Generic representation of <a>Read</a> types.
type GRead0 = GRead Proxy

-- | Generic <a>liftReadPrec</a>.
gliftReadPrec :: (Generic1 f, GRead1 (Rep1 f)) => ReadPrec a -> ReadPrec [a] -> ReadPrec (f a)

-- | Generic representation of <a>Read1</a> types.
type GRead1 = GRead Identity
class GRead p f
gPrecRead :: GRead p f => p (ReadPrec a, ReadPrec [a]) -> ReadPrec (f a)
class IsNullaryDataType f
isNullaryDataType :: IsNullaryDataType f => f a -> Bool
class GReadC p c f
gPrecReadC :: GReadC p c f => p (ReadPrec a, ReadPrec [a]) -> String -> Fixity -> ReadPrec (M1 C c f a)
class GReadFields p f
gPrecReadFields :: GReadFields p f => p (ReadPrec a, ReadPrec [a]) -> ReadPrecTree (f a)
class GReadNamed p f
gPrecReadNamed :: GReadNamed p f => p (ReadPrec a, ReadPrec [a]) -> ReadPrec (f a)
class GReadSingle p f
gPrecReadSingle :: GReadSingle p f => p (ReadPrec a, ReadPrec [a]) -> ReadPrec (f a)
coerceM1 :: ReadPrec (f p) -> ReadPrec (M1 i c f p)

-- | A backwards-compatible version of <a>liftReadPrec</a>. This is needed
--   for compatibility with <tt>base-4.9</tt>, where <a>Read1</a> only
--   offers <a>liftReadsPrec</a>, not <a>liftReadPrec</a>.
liftReadPrecCompat :: Read1 f => (ReadPrec a, ReadPrec [a]) -> ReadPrec (f a)
data ReadPrecTree a
[U1Leaf] :: ReadPrecTree (U1 a)
[M1Leaf] :: ReadPrec (f a) -> ReadPrecTree (M1 i c f a)
[Branch] :: ReadPrecTree (f a) -> ReadPrecTree (g a) -> ReadPrecTree ((f :*: g) a)
toReadPrec :: ReadPrecTree a -> ReadPrec a
identHLexemes :: String -> [Lexeme]
readPrefixCon :: String -> ReadPrec ()
readSurround :: Char -> ReadPrec a -> Char -> ReadPrec a
snocView :: [a] -> Maybe ([a], a)
instance Generic.Data.Internal.Read.GReadFields p f => Generic.Data.Internal.Read.GReadC p ('GHC.Generics.MetaCons s y 'GHC.Types.False) f
instance (Generic.Data.Internal.Read.GReadFields p f, Generic.Data.Internal.Read.GReadFields p g) => Generic.Data.Internal.Read.GReadFields p (f GHC.Generics.:*: g)
instance Generic.Data.Internal.Read.GReadSingle p f => Generic.Data.Internal.Read.GReadFields p (GHC.Generics.M1 GHC.Generics.S c f)
instance Generic.Data.Internal.Read.GReadFields p GHC.Generics.U1
instance (GHC.Generics.Selector c, Generic.Data.Internal.Read.GReadSingle p f) => Generic.Data.Internal.Read.GReadNamed p (GHC.Generics.M1 GHC.Generics.S c f)
instance GHC.Read.Read a => Generic.Data.Internal.Read.GReadSingle p (GHC.Generics.K1 i a)
instance Data.Functor.Classes.Read1 f => Generic.Data.Internal.Read.GReadSingle Data.Functor.Identity.Identity (GHC.Generics.Rec1 f)
instance Generic.Data.Internal.Read.GReadSingle Data.Functor.Identity.Identity GHC.Generics.Par1
instance (Data.Functor.Classes.Read1 f, Generic.Data.Internal.Read.GReadSingle p g) => Generic.Data.Internal.Read.GReadSingle p (f GHC.Generics.:.: g)
instance Generic.Data.Internal.Read.GReadNamed p f => Generic.Data.Internal.Read.GReadC p ('GHC.Generics.MetaCons s y 'GHC.Types.True) f
instance (Generic.Data.Internal.Read.GReadNamed p f, Generic.Data.Internal.Read.GReadNamed p g) => Generic.Data.Internal.Read.GReadNamed p (f GHC.Generics.:*: g)
instance Generic.Data.Internal.Read.GReadNamed p GHC.Generics.U1
instance (GHC.Generics.Constructor c, Generic.Data.Internal.Read.GReadC p c f) => Generic.Data.Internal.Read.GRead p (GHC.Generics.M1 GHC.Generics.C c f)
instance (Generic.Data.Internal.Read.GRead p f, Generic.Data.Internal.Read.IsNullaryDataType f) => Generic.Data.Internal.Read.GRead p (GHC.Generics.M1 GHC.Generics.D d f)
instance Generic.Data.Internal.Read.IsNullaryDataType (f GHC.Generics.:+: g)
instance Generic.Data.Internal.Read.IsNullaryDataType (GHC.Generics.C1 c f)
instance Generic.Data.Internal.Read.IsNullaryDataType GHC.Generics.V1
instance (Generic.Data.Internal.Read.GRead p f, Generic.Data.Internal.Read.GRead p g) => Generic.Data.Internal.Read.GRead p (f GHC.Generics.:+: g)
instance Generic.Data.Internal.Read.GRead p GHC.Generics.V1


-- | Generic deriving for standard classes in base
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Prelude

-- | Generic <tt>(<a>==</a>)</tt>.
--   
--   <pre>
--   instance <a>Eq</a> MyType where
--     (<a>==</a>) = <a>geq</a>
--   </pre>
geq :: (Generic a, Eq (Rep a ())) => a -> a -> Bool

-- | Generic <a>compare</a>.
--   
--   <pre>
--   instance <a>Ord</a> MyType where
--     <a>compare</a> = <a>gcompare</a>
--   </pre>
gcompare :: (Generic a, Ord (Rep a ())) => a -> a -> Ordering

-- | Generic <tt>(<a>&lt;&gt;</a>)</tt> (or <a>mappend</a>).
--   
--   <pre>
--   instance <a>Semigroup</a> MyType where
--     (<a>&lt;&gt;</a>) = <a>gmappend</a>
--   </pre>
--   
--   See also <a>gmempty</a>.
gmappend :: (Generic a, Semigroup (Rep a ())) => a -> a -> a

-- | Generic <a>mempty</a>.
--   
--   <pre>
--   instance <a>Monoid</a> MyType where
--     <a>mempty</a> = <a>gmempty</a>
--   </pre>
gmempty :: (Generic a, Monoid (Rep a ())) => a

-- | Generic <tt>(<a>&lt;&gt;</a>)</tt> (or <tt><a>mappend</a></tt>).
--   
--   The difference from <a>gmappend</a> is the <a>Monoid</a> constraint
--   instead of <a>Semigroup</a>, for older versions of base where
--   <a>Semigroup</a> is not a superclass of <a>Monoid</a>.
gmappend' :: (Generic a, Monoid (Rep a ())) => a -> a -> a

-- | Generic <a>fmap</a>.
--   
--   <pre>
--   instance <a>Functor</a> MyTypeF where
--     <a>fmap</a> = <a>gfmap</a>
--   </pre>
gfmap :: (Generic1 f, Functor (Rep1 f)) => (a -> b) -> f a -> f b

-- | Generic <tt>(<a>&lt;$</a>)</tt>.
--   
--   See also <a>gfmap</a>.
gconstmap :: (Generic1 f, Functor (Rep1 f)) => a -> f b -> f a

-- | Generic <a>pure</a>.
--   
--   <pre>
--   instance <a>Applicative</a> MyTypeF where
--     <a>pure</a> = <a>gpure</a>
--     (<a>&lt;*&gt;</a>) = <a>gap</a>
--   </pre>
gpure :: (Generic1 f, Applicative (Rep1 f)) => a -> f a

-- | Generic <tt>(<a>&lt;*&gt;</a>)</tt> (or <a>ap</a>).
--   
--   See also <a>gpure</a>.
gap :: (Generic1 f, Applicative (Rep1 f)) => f (a -> b) -> f a -> f b

-- | Generic <a>liftA2</a>.
--   
--   See also <a>gpure</a>.
gliftA2 :: (Generic1 f, Applicative (Rep1 f)) => (a -> b -> c) -> f a -> f b -> f c

-- | Generic <a>empty</a>.
--   
--   <pre>
--   instance <a>Alternative</a> MyTypeF where
--     <a>empty</a> = <a>gempty</a>
--     (<a>&lt;|&gt;</a>) = <a>galt</a>
--   </pre>
gempty :: (Generic1 f, Alternative (Rep1 f)) => f a

-- | Generic (<a>&lt;|&gt;</a>).
--   
--   See also <a>gempty</a>.
galt :: (Generic1 f, Alternative (Rep1 f)) => f a -> f a -> f a

-- | Generic <a>foldMap</a>.
--   
--   <pre>
--   instance <a>Foldable</a> MyTypeF where
--     <a>foldMap</a> = <a>gfoldMap</a>
--   </pre>
--   
--   This is deprecated but kept around just for reference.

-- | <i>Deprecated: This definition has been replaced with
--   <a>gfoldMap</a>.</i>
gfoldMap :: (Generic1 f, Foldable (Rep1 f), Monoid m) => (a -> m) -> f a -> m

-- | Generic <a>foldr</a>.
--   
--   <pre>
--   instance <a>Foldable</a> MyTypeF where
--     <a>foldr</a> = <a>gfoldr</a>
--   </pre>
--   
--   See also <a>gfoldMap</a>.
gfoldr :: (Generic1 f, Foldable (Rep1 f)) => (a -> b -> b) -> b -> f a -> b

-- | Generic <a>traverse</a>.
--   
--   <pre>
--   instance <a>Traversable</a> MyTypeF where
--     <a>traverse</a> = <a>gtraverse</a>
--   </pre>
--   
--   This is deprecated but kept around just for reference.

-- | <i>Deprecated: This definition has been replaced with
--   <a>gtraverse</a>.</i>
gtraverse :: (Generic1 f, Traversable (Rep1 f), Applicative m) => (a -> m b) -> f a -> m (f b)

-- | Generic <a>sequenceA</a>.
--   
--   <pre>
--   instance <a>Traversable</a> MyTypeF where
--     <a>sequenceA</a> = <a>gsequenceA</a>
--   </pre>
--   
--   See also <a>gtraverse</a>.
--   
--   This is deprecated but kept around just for reference.

-- | <i>Deprecated: This definition has been replaced with
--   <a>gsequenceA</a>.</i>
gsequenceA :: (Generic1 f, Traversable (Rep1 f), Applicative m) => f (m a) -> m (f a)

-- | Generic <a>liftEq</a>.
gliftEq :: (Generic1 f, Eq1 (Rep1 f)) => (a -> b -> Bool) -> f a -> f b -> Bool

-- | Generic <a>liftCompare</a>.
gliftCompare :: (Generic1 f, Ord1 (Rep1 f)) => (a -> b -> Ordering) -> f a -> f b -> Ordering


-- | Newtypes with instances implemented using generic combinators.
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Generically

-- | A datatype whose instances are defined generically, using the
--   <a>Generic</a> representation. <a>Generically1</a> is a higher-kinded
--   version of <a>Generically</a> that uses <a>Generic1</a>.
--   
--   Generic instances can be derived via <tt><a>Generically</a> A</tt>
--   using <tt>-XDerivingVia</tt>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE DerivingStrategies #-}
--   {-# LANGUAGE DerivingVia        #-}
--   
--   import GHC.Generics (Generic)
--   
--   data V4 a = V4 a a a a
--     deriving stock Generic
--   
--     deriving (Semigroup, Monoid)
--     via Generically (V4 a)
--   </pre>
--   
--   This corresponds to <a>Semigroup</a> and <a>Monoid</a> instances
--   defined by pointwise lifting:
--   
--   <pre>
--   instance Semigroup a =&gt; Semigroup (V4 a) where
--     (&lt;&gt;) :: V4 a -&gt; V4 a -&gt; V4 a
--     V4 a1 b1 c1 d1 &lt;&gt; V4 a2 b2 c2 d2 =
--       V4 (a1 &lt;&gt; a2) (b1 &lt;&gt; b2) (c1 &lt;&gt; c2) (d1 &lt;&gt; d2)
--   
--   instance Monoid a =&gt; Monoid (V4 a) where
--     mempty :: V4 a
--     mempty = V4 mempty mempty mempty mempty
--   </pre>
--   
--   Historically this required modifying the type class to include generic
--   method definitions (<tt>-XDefaultSignatures</tt>) and deriving it with
--   the <tt>anyclass</tt> strategy (<tt>-XDeriveAnyClass</tt>). Having a
--   /via type/ like <a>Generically</a> decouples the instance from the
--   type class.
newtype () => Generically a
Generically :: a -> Generically a

-- | A type whose instances are defined generically, using the
--   <a>Generic1</a> representation. <a>Generically1</a> is a higher-kinded
--   version of <a>Generically</a> that uses <a>Generic</a>.
--   
--   Generic instances can be derived for type constructors via
--   <tt><a>Generically1</a> F</tt> using <tt>-XDerivingVia</tt>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE DerivingStrategies #-}
--   {-# LANGUAGE DerivingVia        #-}
--   
--   import GHC.Generics (Generic)
--   
--   data V4 a = V4 a a a a
--     deriving stock (Functor, Generic1)
--   
--     deriving Applicative
--     via Generically1 V4
--   </pre>
--   
--   This corresponds to <a>Applicative</a> instances defined by pointwise
--   lifting:
--   
--   <pre>
--   instance Applicative V4 where
--     pure :: a -&gt; V4 a
--     pure a = V4 a a a a
--   
--     liftA2 :: (a -&gt; b -&gt; c) -&gt; (V4 a -&gt; V4 b -&gt; V4 c)
--     liftA2 (·) (V4 a1 b1 c1 d1) (V4 a2 b2 c2 d2) =
--       V4 (a1 · a2) (b1 · b2) (c1 · c2) (d1 · d2)
--   </pre>
--   
--   Historically this required modifying the type class to include generic
--   method definitions (<tt>-XDefaultSignatures</tt>) and deriving it with
--   the <tt>anyclass</tt> strategy (<tt>-XDeriveAnyClass</tt>). Having a
--   /via type/ like <a>Generically1</a> decouples the instance from the
--   type class.
newtype () => Generically1 (f :: k -> Type) (a :: k)
[Generically1] :: forall {k} (f :: k -> Type) (a :: k). f a -> Generically1 f a

-- | Type with <a>Enum</a> instance derived via <a>Generic</a> with
--   <a>FiniteEnum</a> option. This allows deriving <a>Enum</a> for types
--   whose constructors have fields.
--   
--   Some caution is advised; see details in <a>FiniteEnum</a>.
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   data Booool = Booool Bool Bool
--     deriving Generic
--     deriving (Enum, Bounded) via (FiniteEnumeration Booool)
--   :}
--   </pre>
newtype FiniteEnumeration a
FiniteEnumeration :: a -> FiniteEnumeration a

-- | Product type with generic instances of <a>Semigroup</a> and
--   <a>Monoid</a>.
--   
--   This is similar to <a>Generically</a> in most cases, but
--   <a>GenericProduct</a> also works for types <tt>T</tt> with deriving
--   <tt>via <a>GenericProduct</a> U</tt>, where <tt>U</tt> is a generic
--   product type coercible to, but distinct from <tt>T</tt>. In
--   particular, <tt>U</tt> may not have an instance of <a>Semigroup</a>,
--   which <a>Generically</a> requires.
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Monoid (Sum(..))
--   
--   &gt;&gt;&gt; data Point a = Point a a deriving Generic
--   
--   &gt;&gt;&gt; :{
--     newtype Vector a = Vector (Point a)
--       deriving (Semigroup, Monoid)
--         via GenericProduct (Point (Sum a))
--   :}
--   </pre>
--   
--   If it were <tt>via <a>Generically</a> (Point (Sum a))</tt> instead,
--   then <tt>Vector</tt>'s <a>mappend</a> (the <a>Monoid</a> method) would
--   be defined as <tt>Point</tt>'s <tt>(<a>&lt;&gt;</a>)</tt> (the
--   <a>Semigroup</a> method), which might not exist, or might not be
--   equivalent to <tt>Vector</tt>'s generic <a>Semigroup</a> instance,
--   which would be unlawful.
newtype GenericProduct a
GenericProduct :: a -> GenericProduct a
instance GHC.Generics.Generic a => GHC.Generics.Generic (Generic.Data.Internal.Generically.GenericProduct a)
instance (Generic.Data.Internal.Error.AssertNoSum GHC.Base.Semigroup a, GHC.Generics.Generic a, GHC.Base.Semigroup (GHC.Generics.Rep a ())) => GHC.Base.Semigroup (Generic.Data.Internal.Generically.GenericProduct a)
instance (Generic.Data.Internal.Error.AssertNoSum GHC.Base.Semigroup a, GHC.Generics.Generic a, GHC.Base.Monoid (GHC.Generics.Rep a ())) => GHC.Base.Monoid (Generic.Data.Internal.Generically.GenericProduct a)
instance GHC.Generics.Generic a => GHC.Generics.Generic (Generic.Data.Internal.Generically.FiniteEnumeration a)
instance (GHC.Generics.Generic a, Generic.Data.Internal.Enum.GEnum Generic.Data.Internal.Enum.FiniteEnum (GHC.Generics.Rep a)) => GHC.Enum.Enum (Generic.Data.Internal.Generically.FiniteEnumeration a)
instance (GHC.Generics.Generic a, Generic.Data.Internal.Enum.GBounded (GHC.Generics.Rep a)) => GHC.Enum.Bounded (Generic.Data.Internal.Generically.FiniteEnumeration a)
instance GHC.Generics.Generic a => GHC.Generics.Generic (GHC.Generics.Generically a)
instance (GHC.Generics.Generic a, GHC.Classes.Eq (GHC.Generics.Rep a ())) => GHC.Classes.Eq (GHC.Generics.Generically a)
instance (GHC.Generics.Generic a, GHC.Classes.Ord (GHC.Generics.Rep a ())) => GHC.Classes.Ord (GHC.Generics.Generically a)
instance (GHC.Generics.Generic a, Generic.Data.Internal.Read.GRead0 (GHC.Generics.Rep a)) => GHC.Read.Read (GHC.Generics.Generically a)
instance (GHC.Generics.Generic a, Generic.Data.Internal.Show.GShow0 (GHC.Generics.Rep a)) => GHC.Show.Show (GHC.Generics.Generically a)
instance (GHC.Generics.Generic a, Generic.Data.Internal.Enum.GEnum Generic.Data.Internal.Enum.StandardEnum (GHC.Generics.Rep a)) => GHC.Enum.Enum (GHC.Generics.Generically a)
instance (GHC.Generics.Generic a, GHC.Classes.Ord (GHC.Generics.Rep a ()), Generic.Data.Internal.Enum.GIx (GHC.Generics.Rep a)) => GHC.Ix.Ix (GHC.Generics.Generically a)
instance (GHC.Generics.Generic a, Generic.Data.Internal.Enum.GBounded (GHC.Generics.Rep a)) => GHC.Enum.Bounded (GHC.Generics.Generically a)
instance GHC.Generics.Generic (f a) => GHC.Generics.Generic (GHC.Generics.Generically1 f a)
instance GHC.Generics.Generic1 f => GHC.Generics.Generic1 (GHC.Generics.Generically1 f)
instance (GHC.Generics.Generic1 f, Generic.Data.Internal.Read.GRead1 (GHC.Generics.Rep1 f)) => Data.Functor.Classes.Read1 (GHC.Generics.Generically1 f)
instance (GHC.Generics.Generic1 f, Generic.Data.Internal.Read.GRead1 (GHC.Generics.Rep1 f), GHC.Read.Read a) => GHC.Read.Read (GHC.Generics.Generically1 f a)
instance (GHC.Generics.Generic1 f, Generic.Data.Internal.Show.GShow1 (GHC.Generics.Rep1 f)) => Data.Functor.Classes.Show1 (GHC.Generics.Generically1 f)
instance (GHC.Generics.Generic1 f, Generic.Data.Internal.Show.GShow1 (GHC.Generics.Rep1 f), GHC.Show.Show a) => GHC.Show.Show (GHC.Generics.Generically1 f a)
instance (GHC.Generics.Generic1 f, Generic.Data.Internal.Traversable.GFoldable (GHC.Generics.Rep1 f)) => Data.Foldable.Foldable (GHC.Generics.Generically1 f)
instance (GHC.Generics.Generic1 f, GHC.Base.Functor (GHC.Generics.Rep1 f), Generic.Data.Internal.Traversable.GFoldable (GHC.Generics.Rep1 f), Generic.Data.Internal.Traversable.GTraversable (GHC.Generics.Rep1 f)) => Data.Traversable.Traversable (GHC.Generics.Generically1 f)


-- | Generic combinators to derive type class instances.
--   
--   <h2>Orphans</h2>
--   
--   The <a>Orphans</a> module should be imported to derive the following
--   classes using this library:
--   
--   <ul>
--   <li><tt>Eq1</tt> and <tt>Ord1</tt></li>
--   <li><a>Semigroup</a> and <a>Monoid</a> on GHC 8.4 or older (base &lt;=
--   4.11)</li>
--   </ul>
--   
--   <h2><b>Minor discrepancies</b></h2>
--   
--   Here are documented some corner cases of deriving, both by GHC and
--   generic-data. They are all minor and unlikely to cause problems in
--   practice.
--   
--   <h3>Empty types</h3>
--   
--   <ul>
--   <li>Some of the derived methods are lazy, which might result in errors
--   being silenced, though unlikely.</li>
--   <li>The only generic-data implementation which differs from GHC stock
--   instances is <a>gfoldMap</a>.</li>
--   </ul>
--   
--   TODO: table
--   
--   <h3>Single-constructor single-field types</h3>
--   
--   <tt>data</tt> types with one constructor and one field are extremely
--   rare. <tt>newtype</tt> is almost always more appropriate (for which
--   there is no issue).
--   
--   That said, for <tt>data</tt> types both strict and lazy, all
--   generic-data implementations are lazy (they don't even force the
--   constructor), whereas GHC stock implementations, when they exist, are
--   strict.
--   
--   <h3>Functor composition</h3>
--   
--   Fields of functors involving the composition of two or more functors
--   <tt>f (g (h a))</tt> result in some overhead using
--   <a>GHC.Generics.Generic1</a>.
--   
--   This is due to a particular encoding choice of <tt>GHC.Generics</tt>,
--   where composition are nested to the right instead of to the left.
--   <tt>f (g (h _))</tt> is represented by the functor <tt>f <a>:.:</a> (g
--   <a>:.:</a> <a>Rec1</a> h)</tt>, so one must use <a>fmap</a> on
--   <tt>f</tt> to convert that back to <tt>f (g (h _))</tt>. A better
--   choice would have been to encode it as <tt>(<a>Rec1</a> f <a>:.:</a>
--   g) <a>:.:</a> h</tt>, because that is coercible back to <tt>f (g (h
--   _))</tt>.
module Generic.Data

-- | A datatype whose instances are defined generically, using the
--   <a>Generic</a> representation. <a>Generically1</a> is a higher-kinded
--   version of <a>Generically</a> that uses <a>Generic1</a>.
--   
--   Generic instances can be derived via <tt><a>Generically</a> A</tt>
--   using <tt>-XDerivingVia</tt>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE DerivingStrategies #-}
--   {-# LANGUAGE DerivingVia        #-}
--   
--   import GHC.Generics (Generic)
--   
--   data V4 a = V4 a a a a
--     deriving stock Generic
--   
--     deriving (Semigroup, Monoid)
--     via Generically (V4 a)
--   </pre>
--   
--   This corresponds to <a>Semigroup</a> and <a>Monoid</a> instances
--   defined by pointwise lifting:
--   
--   <pre>
--   instance Semigroup a =&gt; Semigroup (V4 a) where
--     (&lt;&gt;) :: V4 a -&gt; V4 a -&gt; V4 a
--     V4 a1 b1 c1 d1 &lt;&gt; V4 a2 b2 c2 d2 =
--       V4 (a1 &lt;&gt; a2) (b1 &lt;&gt; b2) (c1 &lt;&gt; c2) (d1 &lt;&gt; d2)
--   
--   instance Monoid a =&gt; Monoid (V4 a) where
--     mempty :: V4 a
--     mempty = V4 mempty mempty mempty mempty
--   </pre>
--   
--   Historically this required modifying the type class to include generic
--   method definitions (<tt>-XDefaultSignatures</tt>) and deriving it with
--   the <tt>anyclass</tt> strategy (<tt>-XDeriveAnyClass</tt>). Having a
--   /via type/ like <a>Generically</a> decouples the instance from the
--   type class.
newtype () => Generically a
Generically :: a -> Generically a

-- | Product type with generic instances of <a>Semigroup</a> and
--   <a>Monoid</a>.
--   
--   This is similar to <a>Generically</a> in most cases, but
--   <a>GenericProduct</a> also works for types <tt>T</tt> with deriving
--   <tt>via <a>GenericProduct</a> U</tt>, where <tt>U</tt> is a generic
--   product type coercible to, but distinct from <tt>T</tt>. In
--   particular, <tt>U</tt> may not have an instance of <a>Semigroup</a>,
--   which <a>Generically</a> requires.
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Monoid (Sum(..))
--   
--   &gt;&gt;&gt; data Point a = Point a a deriving Generic
--   
--   &gt;&gt;&gt; :{
--     newtype Vector a = Vector (Point a)
--       deriving (Semigroup, Monoid)
--         via GenericProduct (Point (Sum a))
--   :}
--   </pre>
--   
--   If it were <tt>via <a>Generically</a> (Point (Sum a))</tt> instead,
--   then <tt>Vector</tt>'s <a>mappend</a> (the <a>Monoid</a> method) would
--   be defined as <tt>Point</tt>'s <tt>(<a>&lt;&gt;</a>)</tt> (the
--   <a>Semigroup</a> method), which might not exist, or might not be
--   equivalent to <tt>Vector</tt>'s generic <a>Semigroup</a> instance,
--   which would be unlawful.
newtype GenericProduct a
GenericProduct :: a -> GenericProduct a

-- | Type with <a>Enum</a> instance derived via <a>Generic</a> with
--   <a>FiniteEnum</a> option. This allows deriving <a>Enum</a> for types
--   whose constructors have fields.
--   
--   Some caution is advised; see details in <a>FiniteEnum</a>.
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   data Booool = Booool Bool Bool
--     deriving Generic
--     deriving (Enum, Bounded) via (FiniteEnumeration Booool)
--   :}
--   </pre>
newtype FiniteEnumeration a
FiniteEnumeration :: a -> FiniteEnumeration a

-- | A type whose instances are defined generically, using the
--   <a>Generic1</a> representation. <a>Generically1</a> is a higher-kinded
--   version of <a>Generically</a> that uses <a>Generic</a>.
--   
--   Generic instances can be derived for type constructors via
--   <tt><a>Generically1</a> F</tt> using <tt>-XDerivingVia</tt>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE DerivingStrategies #-}
--   {-# LANGUAGE DerivingVia        #-}
--   
--   import GHC.Generics (Generic)
--   
--   data V4 a = V4 a a a a
--     deriving stock (Functor, Generic1)
--   
--     deriving Applicative
--     via Generically1 V4
--   </pre>
--   
--   This corresponds to <a>Applicative</a> instances defined by pointwise
--   lifting:
--   
--   <pre>
--   instance Applicative V4 where
--     pure :: a -&gt; V4 a
--     pure a = V4 a a a a
--   
--     liftA2 :: (a -&gt; b -&gt; c) -&gt; (V4 a -&gt; V4 b -&gt; V4 c)
--     liftA2 (·) (V4 a1 b1 c1 d1) (V4 a2 b2 c2 d2) =
--       V4 (a1 · a2) (b1 · b2) (c1 · c2) (d1 · d2)
--   </pre>
--   
--   Historically this required modifying the type class to include generic
--   method definitions (<tt>-XDefaultSignatures</tt>) and deriving it with
--   the <tt>anyclass</tt> strategy (<tt>-XDeriveAnyClass</tt>). Having a
--   /via type/ like <a>Generically1</a> decouples the instance from the
--   type class.
newtype () => Generically1 (f :: k -> Type) (a :: k)
[Generically1] :: forall {k} (f :: k -> Type) (a :: k). f a -> Generically1 f a

-- | Generic <tt>(<a>&lt;&gt;</a>)</tt> (or <a>mappend</a>).
--   
--   <pre>
--   instance <a>Semigroup</a> MyType where
--     (<a>&lt;&gt;</a>) = <a>gmappend</a>
--   </pre>
--   
--   See also <a>gmempty</a>.
gmappend :: (Generic a, Semigroup (Rep a ())) => a -> a -> a

-- | Generic <a>mempty</a>.
--   
--   <pre>
--   instance <a>Monoid</a> MyType where
--     <a>mempty</a> = <a>gmempty</a>
--   </pre>
gmempty :: (Generic a, Monoid (Rep a ())) => a

-- | Generic <tt>(<a>&lt;&gt;</a>)</tt> (or <tt><a>mappend</a></tt>).
--   
--   The difference from <a>gmappend</a> is the <a>Monoid</a> constraint
--   instead of <a>Semigroup</a>, for older versions of base where
--   <a>Semigroup</a> is not a superclass of <a>Monoid</a>.
gmappend' :: (Generic a, Monoid (Rep a ())) => a -> a -> a

-- | Generic <tt>(<a>==</a>)</tt>.
--   
--   <pre>
--   instance <a>Eq</a> MyType where
--     (<a>==</a>) = <a>geq</a>
--   </pre>
geq :: (Generic a, Eq (Rep a ())) => a -> a -> Bool

-- | Generic <a>compare</a>.
--   
--   <pre>
--   instance <a>Ord</a> MyType where
--     <a>compare</a> = <a>gcompare</a>
--   </pre>
gcompare :: (Generic a, Ord (Rep a ())) => a -> a -> Ordering

-- | Generic <a>readPrec</a>.
--   
--   <pre>
--   instance <a>Read</a> MyType where
--     <a>readPrec</a> = <a>greadPrec</a>
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
greadPrec :: (Generic a, GRead0 (Rep a)) => ReadPrec a

-- | Generic representation of <a>Read</a> types.
type GRead0 = GRead Proxy

-- | Generic <a>showsPrec</a>.
--   
--   <pre>
--   instance <a>Show</a> MyType where
--     <a>showsPrec</a> = <a>gshowsPrec</a>
--   </pre>
gshowsPrec :: (Generic a, GShow0 (Rep a)) => Int -> a -> ShowS

-- | Generic representation of <a>Show</a> types.
type GShow0 = GShow Proxy

-- | Generic representation of <a>Enum</a> types.
--   
--   The <tt>opts</tt> parameter is a type-level option to select different
--   implementations.
class GEnum opts f

-- | Standard option for <a>GEnum</a>: derive <a>Enum</a> for types with
--   only nullary constructors (the same restrictions as in the <a>Haskell
--   2010 report</a>).
data StandardEnum

-- | Generic <a>toEnum</a> generated with the <a>StandardEnum</a> option.
--   
--   <pre>
--   instance <a>Enum</a> MyType where
--     <a>toEnum</a> = <a>gtoEnum</a>
--     <a>fromEnum</a> = <a>gfromEnum</a>
--     <a>enumFrom</a> = <a>genumFrom</a>
--     <a>enumFromThen</a> = <a>genumFromThen</a>
--     <a>enumFromTo</a> = <a>genumFromTo</a>
--     <a>enumFromThenTo</a> = <a>genumFromThenTo</a>
--   </pre>
gtoEnum :: (Generic a, GEnum StandardEnum (Rep a)) => Int -> a

-- | Generic <a>fromEnum</a> generated with the <a>StandardEnum</a> option.
--   
--   See also <a>gtoEnum</a>.
gfromEnum :: (Generic a, GEnum StandardEnum (Rep a)) => a -> Int

-- | Generic <a>enumFrom</a> generated with the <a>StandardEnum</a> option.
--   
--   See also <a>gtoEnum</a>.
genumFrom :: (Generic a, GEnum StandardEnum (Rep a)) => a -> [a]

-- | Generic <a>enumFromThen</a> generated with the <a>StandardEnum</a>
--   option.
--   
--   See also <a>gtoEnum</a>.
genumFromThen :: (Generic a, GEnum StandardEnum (Rep a)) => a -> a -> [a]

-- | Generic <a>enumFromTo</a> generated with the <a>StandardEnum</a>
--   option.
--   
--   See also <a>gtoEnum</a>.
genumFromTo :: (Generic a, GEnum StandardEnum (Rep a)) => a -> a -> [a]

-- | Generic <a>enumFromThenTo</a> generated with the <a>StandardEnum</a>
--   option.
--   
--   See also <a>gtoEnum</a>.
genumFromThenTo :: (Generic a, GEnum StandardEnum (Rep a)) => a -> a -> a -> [a]

-- | Extends the <a>StandardEnum</a> option for <a>GEnum</a> to allow all
--   constructors to have arbitrary many fields. Each field type must be an
--   instance of both <a>Enum</a> and <a>Bounded</a>. Avoid fields of types
--   <a>Int</a> and <a>Word</a>.
--   
--   <h3><b>Details</b></h3>
--   
--   Two restrictions require the user's attention:
--   
--   <ul>
--   <li>The <a>Enum</a> instances of the field types need to start
--   enumerating from 0. In particular, <a>Int</a> is an unfit field type,
--   because the enumeration of the negative values starts before 0.</li>
--   <li>There can only be up to <tt><a>maxBound</a> :: <a>Int</a></tt>
--   values (because the implementation represents the cardinality
--   explicitly as an <a>Int</a>). This restriction makes <a>Word</a> an
--   invalid field type as well. Notably, it is insufficient for each
--   individual field types to stay below this limit. Instead it applies to
--   the generic type as a whole.</li>
--   </ul>
--   
--   Elements are numbered by <a>toEnum</a>, from <tt>0</tt> up to
--   <tt>(cardinality - 1)</tt>. The resulting ordering matches the generic
--   <a>Ord</a> instance defined by <a>gcompare</a>. The values from
--   different constructors are enumerated sequentially.
--   
--   <pre>
--   data Example = C0 Bool Bool | C1 Bool
--     deriving (<a>Eq</a>, <a>Ord</a>, <a>Show</a>, <a>Generic</a>)
--   
--   cardinality = 6  -- 2    * 2    + 2
--                    -- Bool * Bool | Bool
--   
--   enumeration =
--       [ C0 False False
--       , C0 False  True
--       , C0  True False
--       , C0  True  True
--       , C1 False
--       , C1 True
--       ]
--   
--   enumeration == map <a>gtoFiniteEnum</a> [0 .. 5]
--   [0 .. 5] == map <a>gfromFiniteEnum</a> enumeration
--   </pre>
data FiniteEnum

-- | Generic <a>toEnum</a> generated with the <a>FiniteEnum</a> option.
--   
--   <pre>
--   instance <a>Enum</a> MyType where
--     <a>toEnum</a> = <a>gtoFiniteEnum</a>
--     <a>fromEnum</a> = <a>gfromFiniteEnum</a>
--     <a>enumFrom</a> = <a>gfiniteEnumFrom</a>
--     <a>enumFromThen</a> = <a>gfiniteEnumFromThen</a>
--     <a>enumFromTo</a> = <a>gfiniteEnumFromTo</a>
--     <a>enumFromThenTo</a> = <a>gfiniteEnumFromThenTo</a>
--   </pre>
gtoFiniteEnum :: (Generic a, GEnum FiniteEnum (Rep a)) => Int -> a

-- | Generic <a>fromEnum</a> generated with the <a>FiniteEnum</a> option.
--   
--   See also <a>gtoFiniteEnum</a>.
gfromFiniteEnum :: (Generic a, GEnum FiniteEnum (Rep a)) => a -> Int

-- | Generic <a>enumFrom</a> generated with the <a>FiniteEnum</a> option.
--   
--   See also <a>gtoFiniteEnum</a>.
gfiniteEnumFrom :: (Generic a, GEnum FiniteEnum (Rep a)) => a -> [a]

-- | Generic <a>enumFromThen</a> generated with the <a>FiniteEnum</a>
--   option.
--   
--   See also <a>gtoFiniteEnum</a>.
gfiniteEnumFromThen :: (Generic a, GEnum FiniteEnum (Rep a)) => a -> a -> [a]

-- | Generic <a>enumFromTo</a> generated with the <a>FiniteEnum</a> option.
--   
--   See also <a>gtoFiniteEnum</a>.
gfiniteEnumFromTo :: (Generic a, GEnum FiniteEnum (Rep a)) => a -> a -> [a]

-- | Generic <a>enumFromThenTo</a> generated with the <a>FiniteEnum</a>
--   option.
--   
--   See also <a>gtoFiniteEnum</a>.
gfiniteEnumFromThenTo :: (Generic a, GEnum FiniteEnum (Rep a)) => a -> a -> a -> [a]

-- | Generic <a>minBound</a>.
--   
--   <pre>
--   instance <a>Bounded</a> MyType where
--     <a>minBound</a> = <a>gminBound</a>
--     <a>maxBound</a> = <a>gmaxBound</a>
--   </pre>
gminBound :: (Generic a, GBounded (Rep a)) => a

-- | Generic <a>maxBound</a>.
--   
--   See also <a>gminBound</a>.
gmaxBound :: (Generic a, GBounded (Rep a)) => a

-- | Generic representation of <a>Bounded</a> types.
class GBounded f

-- | Generic <a>range</a>.
--   
--   <pre>
--   import <a>Data.Ix</a>
--   instance <a>Ix</a> MyType where
--     <a>range</a> = <a>grange</a>
--     <a>index</a> = <a>gindex</a>
--     <a>inRange</a> = <a>ginRange</a>
--   </pre>
grange :: (Generic a, GIx (Rep a)) => (a, a) -> [a]

-- | Generic <a>index</a>.
--   
--   See also <a>grange</a>.
gindex :: (Generic a, GIx (Rep a)) => (a, a) -> a -> Int

-- | Generic <a>inRange</a>.
--   
--   See also <a>grange</a>.
ginRange :: (Generic a, GIx (Rep a)) => (a, a) -> a -> Bool

-- | Generic representation of <a>Ix</a> types.
class GIx f

-- | Generic <tt>unsafeIndex</tt>.
--   
--   <h3><b>Details</b></h3>
--   
--   The functions <tt>unsafeIndex</tt> and <tt>unsafeRangeSize</tt> belong
--   to <a>Ix</a> but are internal to GHC and hence not exported from the
--   module <a>Data.Ix</a>. However they are exported from the module
--   <tt>GHC.Arr</tt>. See <a>grange</a> for how to define an instance of
--   <a>Ix</a> such that it does not depend on the stability of GHCs
--   internal API. Unfortunately this results in additional (unnecessary)
--   bound checks. With the danger of having no stability guarantees for
--   GHC's internal API one can alternatively define an instance of
--   <a>Ix</a> as
--   
--   <pre>
--   import GHC.Arr
--   instance <a>Ix</a> MyType where
--     <a>range</a> = <a>grange</a>
--     unsafeIndex = <a>gunsafeIndex</a>
--     <a>inRange</a> = <a>ginRange</a>
--   </pre>
gunsafeIndex :: (Generic a, GIx (Rep a)) => (a, a) -> a -> Int

-- | Generic <a>fmap</a>.
--   
--   <pre>
--   instance <a>Functor</a> MyTypeF where
--     <a>fmap</a> = <a>gfmap</a>
--   </pre>
gfmap :: (Generic1 f, Functor (Rep1 f)) => (a -> b) -> f a -> f b

-- | Generic <tt>(<a>&lt;$</a>)</tt>.
--   
--   See also <a>gfmap</a>.
gconstmap :: (Generic1 f, Functor (Rep1 f)) => a -> f b -> f a

-- | Generic <a>foldMap</a>.
--   
--   <pre>
--   instance <a>Foldable</a> MyTypeF where
--     <a>foldMap</a> = <a>gfoldMap</a>
--   </pre>
gfoldMap :: (Generic1 f, GFoldable (Rep1 f), Monoid m) => (a -> m) -> f a -> m

-- | Generic <a>foldr</a>.
--   
--   <pre>
--   instance <a>Foldable</a> MyTypeF where
--     <a>foldr</a> = <a>gfoldr</a>
--   </pre>
--   
--   See also <a>gfoldMap</a>.
gfoldr :: (Generic1 f, Foldable (Rep1 f)) => (a -> b -> b) -> b -> f a -> b

-- | Class of generic representations for which <a>Foldable</a> can be
--   derived.
class GFoldable_ t => GFoldable t

-- | Generic <a>traverse</a>.
--   
--   <pre>
--   instance <a>Traversable</a> MyTypeF where
--     <a>traverse</a> = <a>gtraverse</a>
--   </pre>
gtraverse :: (Generic1 f, GTraversable (Rep1 f), Applicative m) => (a -> m b) -> f a -> m (f b)

-- | Generic <a>sequenceA</a>.
--   
--   <pre>
--   instance <a>Traversable</a> MyTypeF where
--     <a>sequenceA</a> = <a>gsequenceA</a>
--   </pre>
--   
--   See also <a>gtraverse</a>.
gsequenceA :: (Generic1 f, GTraversable (Rep1 f), Applicative m) => f (m a) -> m (f a)

-- | Class of generic representations for which <a>Traversable</a> can be
--   derived.
class GTraversable_ t => GTraversable t

-- | Generic <a>pure</a>.
--   
--   <pre>
--   instance <a>Applicative</a> MyTypeF where
--     <a>pure</a> = <a>gpure</a>
--     (<a>&lt;*&gt;</a>) = <a>gap</a>
--   </pre>
gpure :: (Generic1 f, Applicative (Rep1 f)) => a -> f a

-- | Generic <tt>(<a>&lt;*&gt;</a>)</tt> (or <a>ap</a>).
--   
--   See also <a>gpure</a>.
gap :: (Generic1 f, Applicative (Rep1 f)) => f (a -> b) -> f a -> f b

-- | Generic <a>liftA2</a>.
--   
--   See also <a>gpure</a>.
gliftA2 :: (Generic1 f, Applicative (Rep1 f)) => (a -> b -> c) -> f a -> f b -> f c

-- | Generic <a>empty</a>.
--   
--   <pre>
--   instance <a>Alternative</a> MyTypeF where
--     <a>empty</a> = <a>gempty</a>
--     (<a>&lt;|&gt;</a>) = <a>galt</a>
--   </pre>
gempty :: (Generic1 f, Alternative (Rep1 f)) => f a

-- | Generic (<a>&lt;|&gt;</a>).
--   
--   See also <a>gempty</a>.
galt :: (Generic1 f, Alternative (Rep1 f)) => f a -> f a -> f a

-- | Generic <a>liftEq</a>.
gliftEq :: (Generic1 f, Eq1 (Rep1 f)) => (a -> b -> Bool) -> f a -> f b -> Bool

-- | Generic <a>liftCompare</a>.
gliftCompare :: (Generic1 f, Ord1 (Rep1 f)) => (a -> b -> Ordering) -> f a -> f b -> Ordering

-- | Generic <a>liftReadPrec</a>.
gliftReadPrec :: (Generic1 f, GRead1 (Rep1 f)) => ReadPrec a -> ReadPrec [a] -> ReadPrec (f a)

-- | Generic representation of <a>Read1</a> types.
type GRead1 = GRead Identity

-- | Generic <a>liftShowsPrec</a>.
gliftShowsPrec :: (Generic1 f, GShow1 (Rep1 f)) => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS

-- | Generic representation of <a>Show1</a> types.
type GShow1 = GShow Identity

-- | A newtype whose instances for simple classes (<a>Eq</a>, <a>Ord</a>,
--   <a>Read</a>, <a>Show</a>) use higher-kinded class instances for
--   <tt>f</tt> (<a>Eq1</a>, <a>Ord1</a>, <a>Read1</a>, <a>Show1</a>).
newtype Id1 f a
Id1 :: f a -> Id1 f a
[unId1] :: Id1 f a -> f a

-- | A newtype with trivial instances, that considers every value
--   equivalent to every other one, and shows as just <tt>"_"</tt>.
newtype Opaque a
Opaque :: a -> Opaque a
[unOpaque] :: Opaque a -> a

-- | A higher-kinded version of <a>Opaque</a>.
newtype Opaque1 f a
Opaque1 :: f a -> Opaque1 f a
[unOpaque1] :: Opaque1 f a -> f a

-- | Class of newtypes. There is an instance <tt><a>Newtype</a> a</tt> if
--   and only if <tt>a</tt> is a newtype and an instance of <a>Generic</a>.
class (Generic a, Coercible a (Old a), Newtype' a) => Newtype a

-- | The type wrapped by a newtype.
--   
--   <pre>
--   newtype Foo = Foo { bar :: Bar } deriving <a>Generic</a>
--   -- Old Foo ~ Bar
--   </pre>
type Old a = GOld (Rep a)

-- | Generic newtype constructor.
pack :: Newtype a => Old a -> a

-- | Generic newtype destructor.
unpack :: Newtype a => a -> Old a

-- | Convert between types with representationally equivalent generic
--   representations.
gcoerce :: (Generic a, Generic b, Coercible (Rep a) (Rep b)) => a -> b

-- | Compose <a>gcoerce</a> with a binary operation.
gcoerceBinop :: (Generic a, Generic b, Coercible (Rep a) (Rep b)) => (a -> a -> a) -> b -> b -> b

-- | Name of the first data constructor in a type as a string.
--   
--   <pre>
--   &gt;&gt;&gt; gdatatypeName @(Maybe Int)
--   "Maybe"
--   </pre>
gdatatypeName :: forall a. (Generic a, GDatatype (Rep a)) => String

-- | Name of the module where the first type constructor is defined.
--   
--   <pre>
--   &gt;&gt;&gt; gmoduleName @(ZipList Int)
--   "Control.Applicative"
--   </pre>
gmoduleName :: forall a. (Generic a, GDatatype (Rep a)) => String

-- | Name of the package where the first type constructor is defined.
--   
--   <pre>
--   &gt;&gt;&gt; gpackageName @(Maybe Int)
--   "base"
--   </pre>
gpackageName :: forall a. (Generic a, GDatatype (Rep a)) => String

-- | <a>True</a> if the first type constructor is a newtype.
--   
--   <pre>
--   &gt;&gt;&gt; gisNewtype @[Int]
--   False
--   
--   &gt;&gt;&gt; gisNewtype @(ZipList Int)
--   True
--   </pre>
gisNewtype :: forall a. (Generic a, GDatatype (Rep a)) => Bool

-- | Generic representations that contain datatype metadata.
class GDatatype f

-- | Name of the first constructor in a value.
--   
--   <pre>
--   &gt;&gt;&gt; gconName (Just 0)
--   "Just"
--   </pre>
gconName :: forall a. Constructors a => a -> String

-- | The fixity of the first constructor.
--   
--   <pre>
--   &gt;&gt;&gt; import GHC.Generics ((:*:)(..))
--   
--   &gt;&gt;&gt; gconFixity (Just 0)
--   Prefix
--   
--   &gt;&gt;&gt; gconFixity ([] :*: id)
--   Infix RightAssociative 6
--   </pre>
gconFixity :: forall a. Constructors a => a -> Fixity

-- | <a>True</a> if the constructor is a record.
--   
--   <pre>
--   &gt;&gt;&gt; gconIsRecord (Just 0)
--   False
--   
--   &gt;&gt;&gt; gconIsRecord (Sum 0)   -- Note:  newtype Sum a = Sum { getSum :: a }
--   True
--   </pre>
gconIsRecord :: forall a. Constructors a => a -> Bool

-- | Number of constructors.
--   
--   <pre>
--   &gt;&gt;&gt; gconNum @(Maybe Int)
--   2
--   </pre>
gconNum :: forall a. Constructors a => Int

-- | Index of a constructor.
--   
--   <pre>
--   &gt;&gt;&gt; gconIndex Nothing
--   0
--   
--   &gt;&gt;&gt; gconIndex (Just "test")
--   1
--   </pre>
gconIndex :: forall a. Constructors a => a -> Int

-- | Constraint synonym for <a>Generic</a> and <a>GConstructors</a>.
class (Generic a, GConstructors (Rep a)) => Constructors a

-- | Generic representations that contain constructor metadata.
class GConstructors r

-- | An opaque identifier for a constructor.
data ConId a

-- | Identifier of a constructor.
conId :: forall a. Constructors a => a -> ConId a

-- | Index of a constructor, given its identifier. See also
--   <a>gconIndex</a>.
conIdToInt :: forall a. ConId a -> Int

-- | Name of a constructor. See also <a>gconName</a>.
conIdToString :: forall a. Constructors a => ConId a -> String

-- | All constructor identifiers.
--   
--   <pre>
--   <a>gconNum</a> @a = length (<a>conIdEnum</a> @a)
--   </pre>
conIdEnum :: forall a. Constructors a => [ConId a]

-- | Get a <a>ConId</a> by name.
--   
--   <pre>
--   &gt;&gt;&gt; conIdNamed @"Nothing" :: ConId (Maybe Int)
--   ConId 0
--   
--   &gt;&gt;&gt; conIdNamed @"Just"    :: ConId (Maybe Int)
--   ConId 1
--   </pre>
conIdNamed :: forall s a. ConIdNamed s a => ConId a

-- | Constraint synonym for generic types <tt>a</tt> with a constructor
--   named <tt>n</tt>.
class (Generic a, KnownNat (ConIdNamed' n a)) => ConIdNamed n a

-- | The first constructor. This must not be called on an empty type.
conIdMin :: forall a. (Constructors a, NonEmptyType "conIdMin" a) => ConId a

-- | The last constructor. This must not be called on an empty type.
conIdMax :: forall a. (Constructors a, NonEmptyType "conIdMax" a) => ConId a

-- | Constraint that a generic type <tt>a</tt> is not empty. Producing an
--   error message otherwise.
--   
--   The <a>Symbol</a> parameter <tt>fname</tt> is used only for error
--   messages.
--   
--   It is implied by the simpler constraint <tt><a>IsEmptyType</a> a ~
--   'False</tt>
class NonEmptyType_ fname a => NonEmptyType fname a

-- | <a>True</a> if the generic type <tt>a</tt> is empty.
type IsEmptyType a = IsEmptyType_ a

-- | <a>Meta</a> field of the <a>M1</a> type constructor.
type family MetaOf (f :: Type -> Type) :: Meta

-- | Name of the data type (<a>MetaData</a>).
type family MetaDataName (m :: Meta) :: Symbol

-- | Name of the module where the data type is defined (<a>MetaData</a>)
type family MetaDataModule (m :: Meta) :: Symbol

-- | Name of the package where the data type is defined (<a>MetaData</a>)
type family MetaDataPackage (m :: Meta) :: Symbol

-- | <tt>True</tt> if the data type is a newtype (<a>MetaData</a>).
type family MetaDataNewtype (m :: Meta) :: Bool

-- | Name of the constructor (<a>MetaCons</a>).
type family MetaConsName (m :: Meta) :: Symbol

-- | Fixity of the constructor (<a>MetaCons</a>).
type family MetaConsFixity (m :: Meta) :: FixityI

-- | <tt>True</tt> for a record constructor (<a>MetaCons</a>).
type family MetaConsRecord (m :: Meta) :: Bool

-- | <tt>Just</tt> the name of the record field, if it is one
--   (<a>MetaSel</a>).
type family MetaSelNameM (m :: Meta) :: Maybe Symbol

-- | Name of the record field; undefined for non-record fields
--   (<a>MetaSel</a>).
type family MetaSelName (m :: Meta) :: Symbol

-- | Unpackedness annotation of a field (<a>MetaSel</a>).
type family MetaSelUnpack (m :: Meta) :: SourceUnpackedness

-- | Strictness annotation of a field (<a>MetaSel</a>).
type family MetaSelSourceStrictness (m :: Meta) :: SourceStrictness

-- | Inferred strictness of a field (<a>MetaSel</a>).
type family MetaSelStrictness (m :: Meta) :: DecidedStrictness

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class () => Generic a

-- | Representable types of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled). This class is derivable
--   in GHC with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic1</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from1</a> . <a>to1</a> ≡ <a>id</a>
--   <a>to1</a> . <a>from1</a> ≡ <a>id</a>
--   </pre>
class () => Generic1 (f :: k -> Type)


-- | Orphan instances.
--   
--   The orphan instances in this module have been upstreamed in base 4.21
--   (GHC 9.12). The base_orphans package includes these instances from
--   version 0.9.3 onward. This module is empty starting from that version.
--   It remains for backwards compatiblity.
module Generic.Data.Orphans


-- | Utilities to derive and transform generic types.
module Generic.Data.Types

-- | Synthetic data type.
--   
--   A wrapper to view a generic <a>Rep</a> as the datatype it's supposed
--   to represent, without needing a declaration.
newtype Data r p
Data :: r p -> Data r p
[unData] :: Data r p -> r p

-- | Conversion between a generic type and the synthetic type made using
--   its representation. Inverse of <a>fromData</a>.
toData :: Generic a => a -> Data (Rep a) p

-- | Inverse of <a>toData</a>.
fromData :: Generic a => Data (Rep a) p -> a


-- | Surgeries that are just <a>coerce</a>.
--   
--   <h3>Warning</h3>
--   
--   This is an internal module: it is not subject to any versioning
--   policy, breaking changes can happen at any time.
--   
--   If something here seems useful, please report it or create a pull
--   request to export it from an external module.
module Generic.Data.Internal.Microsurgery

-- | Apply a microsurgery <tt>s</tt> to a type <tt>a</tt> for
--   <tt>DerivingVia</tt>.
--   
--   For the <a>Monoid</a> class, see <a>ProductSurgery</a>.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   {-# LANGUAGE DerivingVia #-}
--   
--   -- The constructors must be visible.
--   import <a>Generic.Data.Microsurgery</a>
--     (<a>Surgery</a>, <a>Surgery'</a>(..), <a>Generically</a>(..), <a>Derecordify</a>)
--   
--   data T = T { unT :: Int }
--     deriving <a>Show</a> via (<a>Surgery</a> <a>Derecordify</a> T)
--   
--   -- T won't be shown as a record:
--   --   show (T {unT = 3}) == "T 3"
--   </pre>
type Surgery (s :: Type) (a :: Type) = Generically (Surgery' s a)

-- | Apply a microsurgery <tt>s</tt> to a type <tt>a</tt> for
--   <tt>DerivingVia</tt> for the <a>Monoid</a> class.
type ProductSurgery (s :: Type) (a :: Type) = GenericProduct (Surgery' s a)

-- | Plural of <a>Surgery</a>. Apply a list of microsurgeries.
type Surgeries (s :: [Type]) (a :: Type) = Surgery (Cat s) a

-- | Plural of <a>ProductSurgery</a>. Apply a list of microsurgeries.
type ProductSurgeries (s :: [Type]) (a :: Type) = ProductSurgery (Cat s) a

-- | See <a>Surgery</a>.
newtype Surgery' (s :: Type) (a :: Type)
Surgery' :: a -> Surgery' (s :: Type) (a :: Type)
[unSurgery'] :: Surgery' (s :: Type) (a :: Type) -> a

-- | Apply a microsurgery represented by a symbol <tt>s</tt> (declared as a
--   dummy data type) to a generic representation <tt>f</tt>.
type family GSurgery (s :: Type) (f :: k -> Type) :: k -> Type
derecordify :: Coercible (GSurgery Derecordify f) f => Data f p -> Data (GSurgery Derecordify f) p
underecordify :: Coercible f (GSurgery Derecordify f) => Data (GSurgery Derecordify f) p -> Data f p

-- | Forget that a type was declared using record syntax.
--   
--   <pre>
--   data Foo = Bar { baz :: Zap }
--   
--   -- becomes --
--   
--   data Foo = Bar Zap
--   </pre>
--   
--   Concretely, set the last field of <a>MetaCons</a> to <a>False</a> and
--   forget field names.
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>.
data Derecordify :: Type
type family GDerecordify (f :: k -> Type) :: k -> Type
typeage :: Coercible (GSurgery Typeage f) f => Data f p -> Data (GSurgery Typeage f) p
untypeage :: Coercible f (GSurgery Typeage f) => Data (GSurgery Typeage f) p -> Data f p

-- | Forget that a type is a <tt>newtype</tt>. (The pun is that "aging" a
--   type makes it no longer "new".)
--   
--   <pre>
--   newtype Foo = Bar Baz
--   
--   -- becomes --
--   
--   data Foo = Bar Baz
--   </pre>
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>.
data Typeage :: Type
renameFields :: forall rnm f p. Coercible (GSurgery (RenameFields rnm) f) f => Data f p -> Data (GSurgery (RenameFields rnm) f) p
unrenameFields :: forall rnm f p. Coercible (GSurgery (RenameFields rnm) f) f => Data f p -> Data (GSurgery (RenameFields rnm) f) p
renameConstrs :: forall rnm f p. Coercible (GSurgery (RenameConstrs rnm) f) f => Data f p -> Data (GSurgery (RenameConstrs rnm) f) p
unrenameConstrs :: forall rnm f p. Coercible (GSurgery (RenameConstrs rnm) f) f => Data f p -> Data (GSurgery (RenameConstrs rnm) f) p

-- | Rename fields using the function <tt>rnm</tt> given as a parameter.
--   
--   <pre>
--   data Foo = Bar { baz :: Zap }
--   
--   -- becomes, renaming "baz" to "bag" --
--   
--   data Foo = Bar { bag :: Zap }
--   </pre>
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>.
data RenameFields (rnm :: Type) :: Type
type family GRenameFields (rnm :: Type) (f :: k -> Type) :: k -> Type

-- | Rename constructors using the function <tt>rnm</tt> given as a
--   parameter.
--   
--   <pre>
--   data Foo = Bar { baz :: Zap }
--   
--   -- becomes, renaming "Bar" to "Car" --
--   
--   data Foo = Car { baz :: Zap }
--   </pre>
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>.
data RenameConstrs (rnm :: Type) :: Type
type family GRenameConstrs (rnm :: Type) (f :: k -> Type) :: k -> Type

-- | <tt>f @@ s</tt> is the application of a type-level function symbolized
--   by <tt>f</tt> to a <tt>s :: <a>Symbol</a></tt>.
--   
--   A function <tt>FooToBar</tt> can be defined as follows:
--   
--   <pre>
--   data FooToBar
--   type instance FooToBar <a>@@</a> "foo" = "bar"
--   </pre>
type family (f :: Type) @@ (s :: Symbol) :: Symbol

-- | Identity function <tt><a>Symbol</a> -&gt; <a>Symbol</a></tt>.
data SId

-- | Empty function (compile-time error when applied).
data SError

-- | Constant function.
data SConst (s :: Symbol)

-- | Define a function for a fixed set of strings, and fall back to
--   <tt>f</tt> for the others.
data SRename (xs :: [(Symbol, Symbol)]) (f :: Type)

-- | Closed type family for <a>SRename</a>.
type family SRename' (xs :: [(Symbol, Symbol)]) (f :: Type) (s :: Symbol)

-- | Unify the "spines" of two generic representations (the "spine" is
--   everything except the field types).
class UnifyRep (f :: k -> Type) (g :: k -> Type)

-- | <pre>
--   onData :: _ =&gt; (Data r x -&gt; Data s y) -&gt; (Data r x -&gt; Data s y)  -- possible specialization
--   </pre>
--   
--   Can be used with <tt>generic-lens</tt> for type-changing field updates
--   with <tt>field_</tt> (and possibly other generic optics).
--   
--   A specialization of the identity function to be used to fix types of
--   functions on <a>Data</a>, unifying the "spines" of input and output
--   generic representations (the "spine" is everything except field types,
--   which may thus change).
onData :: (UnifyRep r s, UnifyRep s r) => p (Data r x) (Data s y) -> p (Data r x) (Data s y)

-- | Apply a type constructor <tt>f</tt> to every field type of a generic
--   representation <tt>r</tt>.
--   
--   <pre>
--   data Color = RGB
--     { r :: Int
--     , g :: Int
--     , b :: Int }
--   
--   -- becomes --
--   
--   data Color f = RGB
--     { r :: f Int
--     , g :: f Int
--     , b :: f Int }
--   </pre>
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>.
data OnFields (f :: Type -> Type) :: Type
type family GOnFields (f :: Type -> Type) (g :: k -> Type) :: k -> Type

-- | Apply a type constructor <tt>f</tt> to every field type of a type
--   <tt>a</tt> to make a synthetic type.
type DOnFields (f :: Type -> Type) (a :: Type) = Data (GSurgery (OnFields f) (Rep a)) ()

-- | Apply a type constructor <tt>f</tt> to the field named <tt>s</tt> in a
--   generic record <tt>r</tt>.
--   
--   <pre>
--   data Vec a = Vec
--     { len :: Int
--     , contents :: [a] }
--   
--   -- with (OnField "len" Sum) becomes --
--   
--   data Vec a = Vec
--     { len :: Sum Int
--     , contents :: [a] }
--   </pre>
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>. See also the synonym <tt>(<a>%~</a>)</tt>.
data OnField (s :: Symbol) (f :: Type -> Type) :: Type
type family GOnField (x :: Symbol) (f :: Type -> Type) (g :: k -> Type) :: k -> Type

-- | Infix name for <a>OnField</a>. To be used with <a>Surgeries</a> or
--   <a>Cat</a>.
--   
--   <h3><b>Examples</b></h3>
--   
--   Transform one <tt>Int</tt> field into <tt><a>Sum</a> Int</tt> for
--   deriving <a>Monoid</a>:
--   
--   <pre>
--   data Vec a = Vec
--     { len :: Int
--     , contents :: [a] }
--     deriving Generic
--     deriving (Eq, Show) via Generically (Vec a)
--     deriving (Semigroup, Monoid) via <a>ProductSurgeries</a> '["len" <a>%~</a> <a>Sum</a>] (Vec a)
--   </pre>
--   
--   Wrap unshowable fields in <a>Opaque</a> for deriving <a>Show</a>:
--   
--   <pre>
--   data Unshowable = Unshowable
--     { fun :: Int -&gt; Int
--     , io :: IO Bool
--     , int :: Int }
--     deriving Generic
--     deriving Show via <a>Surgeries</a> '["fun" <a>%~</a> <a>Opaque</a>, "io" <a>%~</a> <a>Opaque</a>] Unshowable
--   
--   -- show (Unshowable id (pure True) 42) = "Unshowable _ _ 42"
--   </pre>
type (%~) = OnField
infixr 4 %~

-- | Compose surgeries together.
data Cat (ss :: [Type]) :: Type

-- | Make a synthetic type (<a>Data</a>) by chaining multiple surgeries.
type DCat (ss :: [Type]) (a :: Type) = Data (GSurgery (Cat ss) (Rep a)) ()

-- | Change the generic representation to that of another type <tt>a</tt>.
data CopyRep (a :: Type) :: Type
copyRep :: forall a f p. Coercible (GSurgery (CopyRep a) f) f => Data f p -> Data (GSurgery (CopyRep a) f) p
uncopyRep :: forall a f p. Coercible f (GSurgery (CopyRep a) f) => Data (GSurgery (CopyRep a) f) p -> Data f p
instance forall k (g' :: k -> *) s (c :: GHC.Generics.Meta) (g :: k -> *) (f :: k -> *). (g' GHC.Types.~ GHC.Generics.M1 s c g, Generic.Data.Internal.Microsurgery.UnifyRep f g) => Generic.Data.Internal.Microsurgery.UnifyRep (GHC.Generics.M1 s c f) g'
instance forall k (g' :: k -> *) (g1 :: k -> *) (g2 :: k -> *) (f1 :: k -> *) (f2 :: k -> *). (g' GHC.Types.~ (g1 GHC.Generics.:+: g2), Generic.Data.Internal.Microsurgery.UnifyRep f1 g1, Generic.Data.Internal.Microsurgery.UnifyRep f2 g2) => Generic.Data.Internal.Microsurgery.UnifyRep (f1 GHC.Generics.:+: f2) g'
instance forall k (g' :: k -> *) (g1 :: k -> *) (g2 :: k -> *) (f1 :: k -> *) (f2 :: k -> *). (g' GHC.Types.~ (g1 GHC.Generics.:*: g2), Generic.Data.Internal.Microsurgery.UnifyRep f1 g1, Generic.Data.Internal.Microsurgery.UnifyRep f2 g2) => Generic.Data.Internal.Microsurgery.UnifyRep (f1 GHC.Generics.:*: f2) g'
instance forall k (g' :: k -> *) i b a. (g' GHC.Types.~ GHC.Generics.K1 i b) => Generic.Data.Internal.Microsurgery.UnifyRep (GHC.Generics.K1 i a) g'
instance forall k (g' :: k -> *). (g' GHC.Types.~ GHC.Generics.U1) => Generic.Data.Internal.Microsurgery.UnifyRep GHC.Generics.U1 g'
instance forall k (g' :: k -> *). (g' GHC.Types.~ GHC.Generics.V1) => Generic.Data.Internal.Microsurgery.UnifyRep GHC.Generics.V1 g'
instance (GHC.Generics.Generic a, GHC.Types.Coercible (Generic.Data.Internal.Microsurgery.GSurgery s (GHC.Generics.Rep a)) (GHC.Generics.Rep a)) => GHC.Generics.Generic (Generic.Data.Internal.Microsurgery.Surgery' s a)


-- | Simple operations on generic representations: modify <a>Generic</a>
--   instances to tweak the behavior of generic implementations as if you
--   had declared a slightly different type.
--   
--   This module provides the following microsurgeries:
--   
--   <ul>
--   <li><a>RenameFields</a>: rename the fields of a record type.</li>
--   <li><a>RenameConstrs</a>: rename the constructors.</li>
--   <li><a>OnFields</a>: apply a type constructor <tt>f :: Type -&gt;
--   Type</tt> to every field.</li>
--   <li><a>CopyRep</a>: use the generic representation of another type of
--   the same shape.</li>
--   <li><a>Typeage</a>: treat a <tt>newtype</tt> as a <tt>data</tt>
--   type.</li>
--   <li><a>Derecordify</a>: treat a type as if it weren't a record.</li>
--   </ul>
--   
--   More complex surgeries can be found in <a>generic-data-surgery</a> but
--   also, perhaps surprisingly, in <a>generic-lens</a> (read more about
--   this just below) and <a>one-liner</a>.
--   
--   Surgeries can be used:
--   
--   <ul>
--   <li>to derive type class instances with the <tt>DerivingVia</tt>
--   extension, using the <a>Surgery</a> or <a>ProductSurgery</a> type
--   synonyms (for classes with instances for <a>Generically</a> or
--   <a>GenericProduct</a>);</li>
--   <li>with the <a>Data</a> "synthetic type" for more involved
--   transformations, for example using lenses in the next section.</li>
--   </ul>
module Generic.Data.Microsurgery

-- | Apply a microsurgery <tt>s</tt> to a type <tt>a</tt> for
--   <tt>DerivingVia</tt>.
--   
--   For the <a>Monoid</a> class, see <a>ProductSurgery</a>.
--   
--   <h3>Example</h3>
--   
--   <pre>
--   {-# LANGUAGE DerivingVia #-}
--   
--   -- The constructors must be visible.
--   import <a>Generic.Data.Microsurgery</a>
--     (<a>Surgery</a>, <a>Surgery'</a>(..), <a>Generically</a>(..), <a>Derecordify</a>)
--   
--   data T = T { unT :: Int }
--     deriving <a>Show</a> via (<a>Surgery</a> <a>Derecordify</a> T)
--   
--   -- T won't be shown as a record:
--   --   show (T {unT = 3}) == "T 3"
--   </pre>
type Surgery (s :: Type) (a :: Type) = Generically (Surgery' s a)

-- | Apply a microsurgery <tt>s</tt> to a type <tt>a</tt> for
--   <tt>DerivingVia</tt> for the <a>Monoid</a> class.
type ProductSurgery (s :: Type) (a :: Type) = GenericProduct (Surgery' s a)

-- | Plural of <a>Surgery</a>. Apply a list of microsurgeries.
type Surgeries (s :: [Type]) (a :: Type) = Surgery (Cat s) a

-- | Plural of <a>ProductSurgery</a>. Apply a list of microsurgeries.
type ProductSurgeries (s :: [Type]) (a :: Type) = ProductSurgery (Cat s) a

-- | See <a>Surgery</a>.
newtype Surgery' (s :: Type) (a :: Type)
Surgery' :: a -> Surgery' (s :: Type) (a :: Type)
[unSurgery'] :: Surgery' (s :: Type) (a :: Type) -> a

-- | Apply a microsurgery represented by a symbol <tt>s</tt> (declared as a
--   dummy data type) to a generic representation <tt>f</tt>.
type family GSurgery (s :: Type) (f :: k -> Type) :: k -> Type

-- | A datatype whose instances are defined generically, using the
--   <a>Generic</a> representation. <a>Generically1</a> is a higher-kinded
--   version of <a>Generically</a> that uses <a>Generic1</a>.
--   
--   Generic instances can be derived via <tt><a>Generically</a> A</tt>
--   using <tt>-XDerivingVia</tt>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE DerivingStrategies #-}
--   {-# LANGUAGE DerivingVia        #-}
--   
--   import GHC.Generics (Generic)
--   
--   data V4 a = V4 a a a a
--     deriving stock Generic
--   
--     deriving (Semigroup, Monoid)
--     via Generically (V4 a)
--   </pre>
--   
--   This corresponds to <a>Semigroup</a> and <a>Monoid</a> instances
--   defined by pointwise lifting:
--   
--   <pre>
--   instance Semigroup a =&gt; Semigroup (V4 a) where
--     (&lt;&gt;) :: V4 a -&gt; V4 a -&gt; V4 a
--     V4 a1 b1 c1 d1 &lt;&gt; V4 a2 b2 c2 d2 =
--       V4 (a1 &lt;&gt; a2) (b1 &lt;&gt; b2) (c1 &lt;&gt; c2) (d1 &lt;&gt; d2)
--   
--   instance Monoid a =&gt; Monoid (V4 a) where
--     mempty :: V4 a
--     mempty = V4 mempty mempty mempty mempty
--   </pre>
--   
--   Historically this required modifying the type class to include generic
--   method definitions (<tt>-XDefaultSignatures</tt>) and deriving it with
--   the <tt>anyclass</tt> strategy (<tt>-XDeriveAnyClass</tt>). Having a
--   /via type/ like <a>Generically</a> decouples the instance from the
--   type class.
newtype () => Generically a
Generically :: a -> Generically a

-- | Product type with generic instances of <a>Semigroup</a> and
--   <a>Monoid</a>.
--   
--   This is similar to <a>Generically</a> in most cases, but
--   <a>GenericProduct</a> also works for types <tt>T</tt> with deriving
--   <tt>via <a>GenericProduct</a> U</tt>, where <tt>U</tt> is a generic
--   product type coercible to, but distinct from <tt>T</tt>. In
--   particular, <tt>U</tt> may not have an instance of <a>Semigroup</a>,
--   which <a>Generically</a> requires.
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Monoid (Sum(..))
--   
--   &gt;&gt;&gt; data Point a = Point a a deriving Generic
--   
--   &gt;&gt;&gt; :{
--     newtype Vector a = Vector (Point a)
--       deriving (Semigroup, Monoid)
--         via GenericProduct (Point (Sum a))
--   :}
--   </pre>
--   
--   If it were <tt>via <a>Generically</a> (Point (Sum a))</tt> instead,
--   then <tt>Vector</tt>'s <a>mappend</a> (the <a>Monoid</a> method) would
--   be defined as <tt>Point</tt>'s <tt>(<a>&lt;&gt;</a>)</tt> (the
--   <a>Semigroup</a> method), which might not exist, or might not be
--   equivalent to <tt>Vector</tt>'s generic <a>Semigroup</a> instance,
--   which would be unlawful.
newtype GenericProduct a
GenericProduct :: a -> GenericProduct a

-- | Synthetic data type.
--   
--   A wrapper to view a generic <a>Rep</a> as the datatype it's supposed
--   to represent, without needing a declaration.
data Data r p

-- | Conversion between a generic type and the synthetic type made using
--   its representation. Inverse of <a>fromData</a>.
toData :: Generic a => a -> Data (Rep a) p

-- | Inverse of <a>toData</a>.
fromData :: Generic a => Data (Rep a) p -> a

-- | <pre>
--   onData :: _ =&gt; (Data r x -&gt; Data s y) -&gt; (Data r x -&gt; Data s y)  -- possible specialization
--   </pre>
--   
--   Can be used with <tt>generic-lens</tt> for type-changing field updates
--   with <tt>field_</tt> (and possibly other generic optics).
--   
--   A specialization of the identity function to be used to fix types of
--   functions on <a>Data</a>, unifying the "spines" of input and output
--   generic representations (the "spine" is everything except field types,
--   which may thus change).
onData :: (UnifyRep r s, UnifyRep s r) => p (Data r x) (Data s y) -> p (Data r x) (Data s y)

-- | Rename fields using the function <tt>rnm</tt> given as a parameter.
--   
--   <pre>
--   data Foo = Bar { baz :: Zap }
--   
--   -- becomes, renaming "baz" to "bag" --
--   
--   data Foo = Bar { bag :: Zap }
--   </pre>
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>.
data RenameFields (rnm :: Type) :: Type
renameFields :: forall rnm f p. Coercible (GSurgery (RenameFields rnm) f) f => Data f p -> Data (GSurgery (RenameFields rnm) f) p
unrenameFields :: forall rnm f p. Coercible (GSurgery (RenameFields rnm) f) f => Data f p -> Data (GSurgery (RenameFields rnm) f) p

-- | Rename constructors using the function <tt>rnm</tt> given as a
--   parameter.
--   
--   <pre>
--   data Foo = Bar { baz :: Zap }
--   
--   -- becomes, renaming "Bar" to "Car" --
--   
--   data Foo = Car { baz :: Zap }
--   </pre>
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>.
data RenameConstrs (rnm :: Type) :: Type
renameConstrs :: forall rnm f p. Coercible (GSurgery (RenameConstrs rnm) f) f => Data f p -> Data (GSurgery (RenameConstrs rnm) f) p
unrenameConstrs :: forall rnm f p. Coercible (GSurgery (RenameConstrs rnm) f) f => Data f p -> Data (GSurgery (RenameConstrs rnm) f) p

-- | <tt>f @@ s</tt> is the application of a type-level function symbolized
--   by <tt>f</tt> to a <tt>s :: <a>Symbol</a></tt>.
--   
--   A function <tt>FooToBar</tt> can be defined as follows:
--   
--   <pre>
--   data FooToBar
--   type instance FooToBar <a>@@</a> "foo" = "bar"
--   </pre>
type family (f :: Type) @@ (s :: Symbol) :: Symbol

-- | Identity function <tt><a>Symbol</a> -&gt; <a>Symbol</a></tt>.
data SId

-- | Empty function (compile-time error when applied).
data SError

-- | Constant function.
data SConst (s :: Symbol)

-- | Define a function for a fixed set of strings, and fall back to
--   <tt>f</tt> for the others.
data SRename (xs :: [(Symbol, Symbol)]) (f :: Type)

-- | Apply a type constructor <tt>f</tt> to every field type of a generic
--   representation <tt>r</tt>.
--   
--   <pre>
--   data Color = RGB
--     { r :: Int
--     , g :: Int
--     , b :: Int }
--   
--   -- becomes --
--   
--   data Color f = RGB
--     { r :: f Int
--     , g :: f Int
--     , b :: f Int }
--   </pre>
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>.
data OnFields (f :: Type -> Type) :: Type

-- | Apply a type constructor <tt>f</tt> to every field type of a type
--   <tt>a</tt> to make a synthetic type.
type DOnFields (f :: Type -> Type) (a :: Type) = Data (GSurgery (OnFields f) (Rep a)) ()

-- | Apply a type constructor <tt>f</tt> to the field named <tt>s</tt> in a
--   generic record <tt>r</tt>.
--   
--   <pre>
--   data Vec a = Vec
--     { len :: Int
--     , contents :: [a] }
--   
--   -- with (OnField "len" Sum) becomes --
--   
--   data Vec a = Vec
--     { len :: Sum Int
--     , contents :: [a] }
--   </pre>
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>. See also the synonym <tt>(<a>%~</a>)</tt>.
data OnField (s :: Symbol) (f :: Type -> Type) :: Type

-- | Infix name for <a>OnField</a>. To be used with <a>Surgeries</a> or
--   <a>Cat</a>.
--   
--   <h3><b>Examples</b></h3>
--   
--   Transform one <tt>Int</tt> field into <tt><a>Sum</a> Int</tt> for
--   deriving <a>Monoid</a>:
--   
--   <pre>
--   data Vec a = Vec
--     { len :: Int
--     , contents :: [a] }
--     deriving Generic
--     deriving (Eq, Show) via Generically (Vec a)
--     deriving (Semigroup, Monoid) via <a>ProductSurgeries</a> '["len" <a>%~</a> <a>Sum</a>] (Vec a)
--   </pre>
--   
--   Wrap unshowable fields in <a>Opaque</a> for deriving <a>Show</a>:
--   
--   <pre>
--   data Unshowable = Unshowable
--     { fun :: Int -&gt; Int
--     , io :: IO Bool
--     , int :: Int }
--     deriving Generic
--     deriving Show via <a>Surgeries</a> '["fun" <a>%~</a> <a>Opaque</a>, "io" <a>%~</a> <a>Opaque</a>] Unshowable
--   
--   -- show (Unshowable id (pure True) 42) = "Unshowable _ _ 42"
--   </pre>
type (%~) = OnField
infixr 4 %~

-- | Compose surgeries together.
data Cat (ss :: [Type]) :: Type

-- | Make a synthetic type (<a>Data</a>) by chaining multiple surgeries.
type DCat (ss :: [Type]) (a :: Type) = Data (GSurgery (Cat ss) (Rep a)) ()

-- | Change the generic representation to that of another type <tt>a</tt>.
data CopyRep (a :: Type) :: Type
copyRep :: forall a f p. Coercible (GSurgery (CopyRep a) f) f => Data f p -> Data (GSurgery (CopyRep a) f) p
uncopyRep :: forall a f p. Coercible f (GSurgery (CopyRep a) f) => Data (GSurgery (CopyRep a) f) p -> Data f p

-- | Forget that a type is a <tt>newtype</tt>. (The pun is that "aging" a
--   type makes it no longer "new".)
--   
--   <pre>
--   newtype Foo = Bar Baz
--   
--   -- becomes --
--   
--   data Foo = Bar Baz
--   </pre>
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>.
data Typeage :: Type
typeage :: Coercible (GSurgery Typeage f) f => Data f p -> Data (GSurgery Typeage f) p
untypeage :: Coercible f (GSurgery Typeage f) => Data (GSurgery Typeage f) p -> Data f p

-- | Forget that a type was declared using record syntax.
--   
--   <pre>
--   data Foo = Bar { baz :: Zap }
--   
--   -- becomes --
--   
--   data Foo = Bar Zap
--   </pre>
--   
--   Concretely, set the last field of <a>MetaCons</a> to <a>False</a> and
--   forget field names.
--   
--   This is a defunctionalized symbol, applied using <a>GSurgery</a> or
--   <a>Surgery</a>.
data Derecordify :: Type
derecordify :: Coercible (GSurgery Derecordify f) f => Data f p -> Data (GSurgery Derecordify f) p
underecordify :: Coercible f (GSurgery Derecordify f) => Data (GSurgery Derecordify f) p -> Data f p
