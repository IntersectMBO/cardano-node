<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Network.Mux.Timeout</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">network-mux-0.8.0.2: Multiplexing library</span><ul class="links" id="page-menu"><li><a href="src/Network.Mux.Timeout.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.Mux.Timeout</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>An alternative implementation of <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/System-Timeout.html#v:timeout" title="System.Timeout">timeout</a></code> for platforms
 (i.e. Windows) where the standard implementation is too expensive.</p><p>The implementation provided here is for the special case where only one
 timeout is active at once. A concurrent implementation would be possible
 but is not currently needed.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">type</span> <a href="#t:TimeoutFn">TimeoutFn</a> m = <span class="keyword">forall</span> a. <a href="Network-Mux-Time.html#t:DiffTime" title="Network.Mux.Time">DiffTime</a> -&gt; m a -&gt; m (<a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:withTimeoutSerial">withTimeoutSerial</a> :: <span class="keyword">forall</span> m b. (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m)) =&gt; (<a href="Network-Mux-Timeout.html#t:TimeoutFn" title="Network.Mux.Timeout">TimeoutFn</a> m -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:withTimeoutSerialNative">withTimeoutSerialNative</a> :: <span class="keyword">forall</span> m b. (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m)) =&gt; (<a href="Network-Mux-Timeout.html#t:TimeoutFn" title="Network.Mux.Timeout">TimeoutFn</a> m -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:withTimeoutSerialAlternative">withTimeoutSerialAlternative</a> :: <span class="keyword">forall</span> m b. (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m)) =&gt; (<a href="Network-Mux-Timeout.html#t:TimeoutFn" title="Network.Mux.Timeout">TimeoutFn</a> m -&gt; m b) -&gt; m b</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:TimeoutFn" class="def">TimeoutFn</a> m = <span class="keyword">forall</span> a. <a href="Network-Mux-Time.html#t:DiffTime" title="Network.Mux.Time">DiffTime</a> -&gt; m a -&gt; m (<a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Network.Mux.Timeout.html#TimeoutFn" class="link">Source</a> <a href="#t:TimeoutFn" class="selflink">#</a></p><div class="doc"><p>The type of the <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/System-Timeout.html#v:timeout" title="System.Timeout">timeout</a></code> function.</p></div></div><div class="top"><p class="src"><a id="v:withTimeoutSerial" class="def">withTimeoutSerial</a> :: <span class="keyword">forall</span> m b. (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m)) =&gt; (<a href="Network-Mux-Timeout.html#t:TimeoutFn" title="Network.Mux.Timeout">TimeoutFn</a> m -&gt; m b) -&gt; m b <a href="src/Network.Mux.Timeout.html#withTimeoutSerial" class="link">Source</a> <a href="#v:withTimeoutSerial" class="selflink">#</a></p><div class="doc"><p>A <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/System-Timeout.html#v:timeout" title="System.Timeout">timeout</a></code> that is reasonably efficient for all platforms.</p><p>On Unix it uses exactly <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/System-Timeout.html#v:timeout" title="System.Timeout">timeout</a></code> and on Windows it uses
 <code><a href="Network-Mux-Timeout.html#v:withTimeoutSerialAlternative" title="Network.Mux.Timeout">withTimeoutSerialAlternative</a></code>.</p><pre>withTimeoutSerial $ \timeout -&gt;
  -- now use timeout as one would use System.Timeout.timeout
  -- but not concurrently!</pre><p>The implementation has a serial constraint: the body action that calls
 <code>timeout</code> can <em>only do so from one thread at once</em>.</p></div></div><div class="top"><p class="src"><a id="v:withTimeoutSerialNative" class="def">withTimeoutSerialNative</a> :: <span class="keyword">forall</span> m b. (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m)) =&gt; (<a href="Network-Mux-Timeout.html#t:TimeoutFn" title="Network.Mux.Timeout">TimeoutFn</a> m -&gt; m b) -&gt; m b <a href="src/Network.Mux.Timeout.html#withTimeoutSerialNative" class="link">Source</a> <a href="#v:withTimeoutSerialNative" class="selflink">#</a></p><div class="doc"><p>This version simply passes the native platform's <code>timeout</code>.</p><p>A <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/System-Timeout.html#v:timeout" title="System.Timeout">timeout</a></code> that is reasonably efficient for all platforms.</p><p>On Unix it uses exactly <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/System-Timeout.html#v:timeout" title="System.Timeout">timeout</a></code> and on Windows it uses
 <code><a href="Network-Mux-Timeout.html#v:withTimeoutSerialAlternative" title="Network.Mux.Timeout">withTimeoutSerialAlternative</a></code>.</p><pre>withTimeoutSerial $ \timeout -&gt;
  -- now use timeout as one would use System.Timeout.timeout
  -- but not concurrently!</pre><p>The implementation has a serial constraint: the body action that calls
 <code>timeout</code> can <em>only do so from one thread at once</em>.</p></div></div><div class="top"><p class="src"><a id="v:withTimeoutSerialAlternative" class="def">withTimeoutSerialAlternative</a> :: <span class="keyword">forall</span> m b. (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m)) =&gt; (<a href="Network-Mux-Timeout.html#t:TimeoutFn" title="Network.Mux.Timeout">TimeoutFn</a> m -&gt; m b) -&gt; m b <a href="src/Network.Mux.Timeout.html#withTimeoutSerialAlternative" class="link">Source</a> <a href="#v:withTimeoutSerialAlternative" class="selflink">#</a></p><div class="doc"><p>An alternative implementation of <code><a href="file:///nix/store/q976m622jbq42nf9zkhq5axjca5xj9w0-ghc-9.6.6-doc/share/doc/ghc-9.6.6/html/libraries/base-4.18.2.1/System-Timeout.html#v:timeout" title="System.Timeout">timeout</a></code> for platforms
 where the standard implementation is too expensive.</p><pre>withTimeoutSerial $ \timeout -&gt;
  -- now use timeout as one would use System.Timeout.timeout
  -- but not concurrently!</pre><p>This implementation has a serial constraint: the body action that calls
 <code>timeout</code> can <em>only do so from one thread at once</em>.</p><p>Further details for the curious:</p><p>the problem with <code>System.Timeout.timeout</code> is that (as of base 4.12) it has
 two implementations, one for Unix with the threaded RTS, and one for all
 other configurations.</p><p>The Unix threaded RTS implementation is rather clever and very fast. In the
 normal case of no timeout, it only has to allocate a timer entry. Only in
 the case the timeout occurs does it allocate a <code>forkIO</code> thread to do the
 potentially-blocking operation of sending the asynchronous exception to
 interrupt the action under timeout.</p><p>The implementation for all other configurations has to allocate a <code>forkIO</code>
 thread up front, whether or not the timeout fires. This is fine for many
 applications but not for network timers which have to be created and
 altered/cancelled with very high frequency.</p><p>The implementation here only relies upon <code>threadDelay</code> which has an
 efficient implementation on all platforms. It uses a separate monitoring
 thread which will throw an exception to terminate the action if the
 timeout expires. This is why it uses the &quot;with&quot; style: because it keeps
 a monitoring thread over a region of execution that may use many timeouts.
 The cost of allocating this thread is amortised over all the timeouts used.</p><p>This implementation is simplified by the constraint that the timeouts only
 be used serially. In addition, it has the limitation that timeouts may not
 always be detected promptly: e.g. a 10s timeout on an action that finishes
 immediately, followed by a 5s timeout on an action will only actually be
 interrupted after 10s. So it's possible that action with the 5s timeout runs
 for up to 10s. This is ok for many applications provided that the variance
 in timeouts is not too large and the timeouts don't need to be too tight.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>