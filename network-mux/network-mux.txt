-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Multiplexing library
--   
--   Multiplexing library.
@package network-mux
@version 0.8.0.2


-- | This module allows the management of a multiple Async jobs which are
--   grouped by an 'Ord group =&gt; group' type.
module Control.Concurrent.JobPool

-- | JobPool allows to submit asynchronous jobs, wait for their completion
--   or cancel. Jobs are grouped, each group can be cancelled separately.
data JobPool group m a

-- | An asynchronous job which belongs to some group and its exception
--   handler.
data Job group m a
Job :: m a -> (SomeException -> m a) -> group -> String -> Job group m a
withJobPool :: forall group m a b. (MonadAsync m, MonadThrow m, MonadLabelledSTM m) => (JobPool group m a -> m b) -> m b

-- | Fork a <a>Job</a> using <a>async</a>.
forkJob :: forall group m a. (MonadAsync m, MonadMask m, Ord group) => JobPool group m a -> Job group m a -> m ()

-- | Fork a <a>Job</a> using <a>asyncOn</a>.
forkJobOn :: forall group m a. (MonadAsync m, MonadMask m, Ord group) => Int -> JobPool group m a -> Job group m a -> m ()
readSize :: MonadSTM m => JobPool group m a -> STM m Int
readGroupSize :: (MonadSTM m, Eq group) => JobPool group m a -> group -> STM m Int

-- | Wait for next successfully completed job. Unlike <a>wait</a> it will
--   not throw if a job errors.
waitForJob :: MonadSTM m => JobPool group m a -> STM m a

-- | Cancel all threads in a given group. Blocks until all threads
--   terminated.
cancelGroup :: (MonadAsync m, Eq group) => JobPool group m a -> group -> m ()


-- | An extension of <a>Channel</a>, with additional <a>Channel</a>
--   implementations.
module Network.Mux.Channel

-- | A channel which can send and receive values.
--   
--   It is more general than what `network-mux` requires, see
--   <a>ByteChannel</a> instead. However this is useful for testing
--   purposes when one is either using <tt>mux</tt> or connecting two ends
--   directly.
data Channel m a
Channel :: (a -> m ()) -> m (Maybe a) -> Channel m a

-- | Write bytes to the channel.
--   
--   It maybe raise exceptions.
[send] :: Channel m a -> a -> m ()

-- | Read some input from the channel, or <tt>Nothing</tt> to indicate EOF.
--   
--   Note that having received EOF it is still possible to send. The EOF
--   condition is however monotonic.
--   
--   It may raise exceptions (as appropriate for the monad and kind of
--   channel).
[recv] :: Channel m a -> m (Maybe a)

-- | Given an isomorphism between <tt>a</tt> and <tt>b</tt> (in Kleisli
--   category), transform a <tt><a>Channel</a> m a</tt> into
--   <tt><a>Channel</a> m b</tt>.
isoKleisliChannel :: forall a b m. Monad m => (a -> m b) -> (b -> m a) -> Channel m a -> Channel m b
hoistChannel :: (forall x. m x -> n x) -> Channel m a -> Channel n a
channelEffect :: forall m a. Monad m => (a -> m ()) -> (Maybe a -> m ()) -> Channel m a -> Channel m a

-- | Delay a channel on the receiver end.
--   
--   This is intended for testing, as a crude approximation of network
--   delays. More accurate models along these lines are of course possible.
delayChannel :: MonadDelay m => DiffTime -> Channel m a -> Channel m a

-- | Channel which logs sent and received messages.
loggingChannel :: (MonadSay m, Show id, Show a) => id -> Channel m a -> Channel m a

-- | Make a <a>Channel</a> from a pair of <a>TMVar</a>s, one for reading
--   and one for writing.
mvarsAsChannel :: MonadSTM m => StrictTMVar m a -> StrictTMVar m a -> Channel m a

-- | Create a pair of channels that are connected via one-place buffers.
--   
--   This is primarily useful for testing protocols.
createConnectedChannels :: MonadSTM m => m (Channel m a, Channel m a)

-- | Channel using <a>ByteString</a>.
type ByteChannel m = Channel m ByteString

-- | Make a <a>Channel</a> from a pair of IO <tt>Handle</tt>s, one for
--   reading and one for writing.
--   
--   The Handles should be open in the appropriate read or write mode, and
--   in binary mode. Writes are flushed after each write, so it is safe to
--   use a buffering mode.
--   
--   For bidirectional handles it is safe to pass the same handle for both.
handlesAsChannel :: Handle -> Handle -> Channel IO ByteString

-- | Open a pair of Unix FIFOs, and expose that as a <a>Channel</a>.
--   
--   The peer process needs to open the same files but the other way
--   around, for writing and reading.
--   
--   This is primarily for the purpose of demonstrations that use
--   communication between multiple local processes. It is Unix specific.
withFifosAsChannel :: FilePath -> FilePath -> (ByteChannel IO -> IO a) -> IO a

-- | Make a <a>Channel</a> from a <tt>Socket</tt>. The socket must be a
--   stream socket
socketAsChannel :: Socket -> ByteChannel IO

-- | Create a pair of <a>Channel</a>s that are connected internally.
--   
--   This is intended for inter-thread communication, such as between a
--   multiplexing thread and a thread running a peer.
--   
--   It uses lazy <tt>ByteString</tt>s but it ensures that data written to
--   the channel is <i>fully evaluated</i> first. This ensures that any
--   work to serialise the data takes place on the <i>writer side and not
--   the reader side</i>.
createBufferConnectedChannels :: forall m. MonadSTM m => m (ByteChannel m, ByteChannel m)

-- | Create a local pipe, with both ends in this process, and expose that
--   as a pair of <a>Channel</a>s, one for each end.
--   
--   This is primarily for testing purposes since it does not allow actual
--   IPC.
createPipeConnectedChannels :: IO (ByteChannel IO, ByteChannel IO)
createSocketConnectedChannels :: Family -> IO (ByteChannel IO, ByteChannel IO)

module Network.Mux.DeltaQ.TraceTypes
newtype SISec
S :: Float -> SISec
newtype SISec2
S2 :: Float -> SISec2
squareSISec :: SISec -> SISec2
instance GHC.Num.Num Network.Mux.DeltaQ.TraceTypes.SISec
instance GHC.Classes.Ord Network.Mux.DeltaQ.TraceTypes.SISec
instance GHC.Classes.Eq Network.Mux.DeltaQ.TraceTypes.SISec
instance GHC.Num.Num Network.Mux.DeltaQ.TraceTypes.SISec2
instance GHC.Classes.Ord Network.Mux.DeltaQ.TraceTypes.SISec2
instance GHC.Classes.Eq Network.Mux.DeltaQ.TraceTypes.SISec2

module Network.Mux.DeltaQ.TraceStatsSupport
estimateGS :: [(Int, SISec)] -> (Double, Double, Double)

module Network.Mux.TCPInfo
data StructTCPInfo
StructTCPInfo :: CUChar -> CUChar -> CUChar -> CUChar -> CUChar -> CUChar -> CUChar -> CUChar -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> CUInt -> StructTCPInfo
[tcpi_state] :: StructTCPInfo -> CUChar
[tcpi_ca_state] :: StructTCPInfo -> CUChar
[tcpi_retransmits] :: StructTCPInfo -> CUChar
[tcpi_probes] :: StructTCPInfo -> CUChar
[tcpi_backoff] :: StructTCPInfo -> CUChar
[tcpi_options] :: StructTCPInfo -> CUChar
[tcpi_sndrcv_wscale] :: StructTCPInfo -> CUChar
[tcpi_delivery_rate_app_limited_fastopen_client_fail] :: StructTCPInfo -> CUChar
[tcpi_rto] :: StructTCPInfo -> CUInt
[tcpi_ato] :: StructTCPInfo -> CUInt
[tcpi_snd_mss] :: StructTCPInfo -> CUInt
[tcpi_rcv_mss] :: StructTCPInfo -> CUInt
[tcpi_unacked] :: StructTCPInfo -> CUInt
[tcpi_sacked] :: StructTCPInfo -> CUInt
[tcpi_lost] :: StructTCPInfo -> CUInt
[tcpi_retrans] :: StructTCPInfo -> CUInt
[tcpi_fackets] :: StructTCPInfo -> CUInt
[tcpi_last_data_sent] :: StructTCPInfo -> CUInt
[tcpi_last_ack_sent] :: StructTCPInfo -> CUInt
[tcpi_last_data_recv] :: StructTCPInfo -> CUInt
[tcpi_last_ack_recv] :: StructTCPInfo -> CUInt
[tcpi_pmtu] :: StructTCPInfo -> CUInt
[tcpi_rcv_ssthresh] :: StructTCPInfo -> CUInt
[tcpi_rtt] :: StructTCPInfo -> CUInt
[tcpi_rttvar] :: StructTCPInfo -> CUInt
[tcpi_snd_ssthresh] :: StructTCPInfo -> CUInt
[tcpi_snd_cwnd] :: StructTCPInfo -> CUInt
[tcpi_advmss] :: StructTCPInfo -> CUInt
[tcpi_reordering] :: StructTCPInfo -> CUInt
[tcpi_rcv_rtt] :: StructTCPInfo -> CUInt
[tcpi_rcv_space] :: StructTCPInfo -> CUInt
[tcpi_total_retrans] :: StructTCPInfo -> CUInt
data () => SocketOption
pattern TCPInfoSocketOption :: SocketOption

module Network.Mux.Time

-- | This is a length of time, as measured by a clock. Conversion functions
--   such as <a>fromInteger</a> and <a>realToFrac</a> will treat it as
--   seconds. For example, <tt>(0.010 :: DiffTime)</tt> corresponds to 10
--   milliseconds.
--   
--   It has a precision of one picosecond (= 10^-12 s). Enumeration
--   functions will treat it as picoseconds.
data () => DiffTime
diffTimeToMicroseconds :: DiffTime -> Integer
microsecondsToDiffTime :: Integer -> DiffTime

-- | This is a slightly peculiar operation: it returns the number of
--   microseconds since an arbitrary epoch, modulo 2^32. This number of
--   microseconds wraps every ~35 minutes.
--   
--   The purpose is to give a compact timestamp (compact to send over the
--   wire) for measuring time differences on the order of seconds or less.
timestampMicrosecondsLow32Bits :: Time -> Word32


-- | An alternative implementation of <a>timeout</a> for platforms (i.e.
--   Windows) where the standard implementation is too expensive.
--   
--   The implementation provided here is for the special case where only
--   one timeout is active at once. A concurrent implementation would be
--   possible but is not currently needed.
module Network.Mux.Timeout

-- | The type of the <a>timeout</a> function.
type TimeoutFn m = forall a. DiffTime -> m a -> m (Maybe a)

-- | A <a>timeout</a> that is reasonably efficient for all platforms.
--   
--   On Unix it uses exactly <a>timeout</a> and on Windows it uses
--   <a>withTimeoutSerialAlternative</a>.
--   
--   <pre>
--   withTimeoutSerial $ \timeout -&gt;
--     -- now use timeout as one would use System.Timeout.timeout
--     -- but not concurrently!
--   </pre>
--   
--   The implementation has a serial constraint: the body action that calls
--   <tt>timeout</tt> can <i>only do so from one thread at once</i>.
withTimeoutSerial :: forall m b. (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m)) => (TimeoutFn m -> m b) -> m b

-- | This version simply passes the native platform's <a>timeout</a>.
--   
--   A <a>timeout</a> that is reasonably efficient for all platforms.
--   
--   On Unix it uses exactly <a>timeout</a> and on Windows it uses
--   <a>withTimeoutSerialAlternative</a>.
--   
--   <pre>
--   withTimeoutSerial $ \timeout -&gt;
--     -- now use timeout as one would use System.Timeout.timeout
--     -- but not concurrently!
--   </pre>
--   
--   The implementation has a serial constraint: the body action that calls
--   <tt>timeout</tt> can <i>only do so from one thread at once</i>.
withTimeoutSerialNative :: forall m b. (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m)) => (TimeoutFn m -> m b) -> m b

-- | An alternative implementation of <a>timeout</a> for platforms where
--   the standard implementation is too expensive.
--   
--   <pre>
--   withTimeoutSerial $ \timeout -&gt;
--     -- now use timeout as one would use System.Timeout.timeout
--     -- but not concurrently!
--   </pre>
--   
--   This implementation has a serial constraint: the body action that
--   calls <tt>timeout</tt> can <i>only do so from one thread at once</i>.
--   
--   Further details for the curious:
--   
--   the problem with <tt>System.Timeout.timeout</tt> is that (as of base
--   4.12) it has two implementations, one for Unix with the threaded RTS,
--   and one for all other configurations.
--   
--   The Unix threaded RTS implementation is rather clever and very fast.
--   In the normal case of no timeout, it only has to allocate a timer
--   entry. Only in the case the timeout occurs does it allocate a
--   <a>forkIO</a> thread to do the potentially-blocking operation of
--   sending the asynchronous exception to interrupt the action under
--   timeout.
--   
--   The implementation for all other configurations has to allocate a
--   <a>forkIO</a> thread up front, whether or not the timeout fires. This
--   is fine for many applications but not for network timers which have to
--   be created and altered/cancelled with very high frequency.
--   
--   The implementation here only relies upon <tt>threadDelay</tt> which
--   has an efficient implementation on all platforms. It uses a separate
--   monitoring thread which will throw an exception to terminate the
--   action if the timeout expires. This is why it uses the "with" style:
--   because it keeps a monitoring thread over a region of execution that
--   may use many timeouts. The cost of allocating this thread is amortised
--   over all the timeouts used.
--   
--   This implementation is simplified by the constraint that the timeouts
--   only be used serially. In addition, it has the limitation that
--   timeouts may not always be detected promptly: e.g. a 10s timeout on an
--   action that finishes immediately, followed by a 5s timeout on an
--   action will only actually be interrupted after 10s. So it's possible
--   that action with the 5s timeout runs for up to 10s. This is ok for
--   many applications provided that the variance in timeouts is not too
--   large and the timeouts don't need to be too tight.
withTimeoutSerialAlternative :: forall m b. (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m)) => (TimeoutFn m -> m b) -> m b
instance GHC.Show.Show Network.Mux.Timeout.TimeoutException
instance GHC.Show.Show Network.Mux.Timeout.TimeoutAssertion
instance GHC.Exception.Type.Exception Network.Mux.Timeout.TimeoutAssertion
instance GHC.Exception.Type.Exception Network.Mux.Timeout.TimeoutException


-- | Types used by the multiplexer.
module Network.Mux.Types

-- | A static description of a mini-protocol.
data MiniProtocolInfo (mode :: Mode)
MiniProtocolInfo :: !MiniProtocolNum -> !MiniProtocolDirection mode -> !MiniProtocolLimits -> !Maybe Int -> MiniProtocolInfo (mode :: Mode)

-- | Unique mini-protocol number.
[miniProtocolNum] :: MiniProtocolInfo (mode :: Mode) -> !MiniProtocolNum

-- | Mini-protocol direction.
[miniProtocolDir] :: MiniProtocolInfo (mode :: Mode) -> !MiniProtocolDirection mode

-- | ingress queue limits for the protocol
[miniProtocolLimits] :: MiniProtocolInfo (mode :: Mode) -> !MiniProtocolLimits

-- | capability on which the mini-protocol should run
[miniProtocolCapability] :: MiniProtocolInfo (mode :: Mode) -> !Maybe Int

-- | The wire format includes the protocol numbers, and it's vital that
--   these are stable. They are not necessarily dense however, as new ones
--   are added and some old ones retired. So we use a dedicated class for
--   this rather than reusing <a>Enum</a>. This also covers unrecognised
--   protocol numbers on the decoding side.
newtype MiniProtocolNum
MiniProtocolNum :: Word16 -> MiniProtocolNum
data MiniProtocolDirection (mode :: Mode)
[InitiatorDirectionOnly] :: MiniProtocolDirection InitiatorMode
[ResponderDirectionOnly] :: MiniProtocolDirection ResponderMode
[InitiatorDirection] :: MiniProtocolDirection InitiatorResponderMode
[ResponderDirection] :: MiniProtocolDirection InitiatorResponderMode

-- | Per Miniprotocol limits
newtype MiniProtocolLimits
MiniProtocolLimits :: Int -> MiniProtocolLimits

-- | Limit on the maximum number of bytes that can be queued in the
--   miniprotocol's ingress queue.
[maximumIngressQueue] :: MiniProtocolLimits -> Int

-- | Statically configured multiplexer mode.
data Mode

-- | Only execute initiator protocols. In this mode the multiplexer will
--   only run its egress side.
[InitiatorMode] :: Mode

-- | Only execute responder protocols. It this mode the multiplexer will
--   only run its ingress side.
[ResponderMode] :: Mode

-- | Execute initiator and responder protocols. In this mode the
--   multiplexer will run both ingress and egress sides.
[InitiatorResponderMode] :: Mode
type family HasInitiator (mode :: Mode) :: Bool
type family HasResponder (mode :: Mode) :: Bool
data Status

-- | Initial mux state, mux is ready to accept requests. It does not
--   indicate weather mux thread was started or not.
Ready :: Status

-- | Mux failed with <a>SomeException</a>
Failed :: SomeException -> Status

-- | Mux is being stopped; mux will not accept any new mini-protocols to
--   start.
Stopping :: Status

-- | Mux stopped.
Stopped :: Status
type IngressQueue m = StrictTVar m (Pair Int64 Builder)

-- | The index of a protocol in a MuxApplication, used for array indices
data MiniProtocolIx
data MiniProtocolDir
InitiatorDir :: MiniProtocolDir
ResponderDir :: MiniProtocolDir
protocolDirEnum :: MiniProtocolDirection mode -> MiniProtocolDir
data MiniProtocolState mode m
MiniProtocolState :: MiniProtocolInfo mode -> IngressQueue m -> StrictTVar m MiniProtocolStatus -> MiniProtocolState mode m
[miniProtocolInfo] :: MiniProtocolState mode m -> MiniProtocolInfo mode
[miniProtocolIngressQueue] :: MiniProtocolState mode m -> IngressQueue m
[miniProtocolStatusVar] :: MiniProtocolState mode m -> StrictTVar m MiniProtocolStatus
data MiniProtocolStatus
StatusIdle :: MiniProtocolStatus
StatusStartOnDemand :: MiniProtocolStatus
StatusRunning :: MiniProtocolStatus
StatusStartOnDemandAny :: MiniProtocolStatus

-- | Low level access to underlying socket or pipe. There are three smart
--   constructors:
--   
--   <ul>
--   <li><a>socketAsBearer</a></li>
--   <li><a>pipeAsBearer</a></li>
--   <li><pre>Test.Mux.queuesAsBearer</pre></li>
--   </ul>
data Bearer m
Bearer :: (TimeoutFn m -> SDU -> m Time) -> (TimeoutFn m -> [SDU] -> m Time) -> (TimeoutFn m -> m (SDU, Time)) -> SDUSize -> Int -> String -> DiffTime -> Bearer m

-- | Timestamp and send SDU.
[write] :: Bearer m -> TimeoutFn m -> SDU -> m Time

-- | Timestamp and send many SDUs.
[writeMany] :: Bearer m -> TimeoutFn m -> [SDU] -> m Time

-- | Read a SDU
[read] :: Bearer m -> TimeoutFn m -> m (SDU, Time)

-- | Return a suitable SDU payload size.
[sduSize] :: Bearer m -> SDUSize

-- | Return a suitable batch size
[batchSize] :: Bearer m -> Int

-- | Name of the bearer
[name] :: Bearer m -> String

-- | Egress poll interval
[egressInterval] :: Bearer m -> DiffTime

-- | A channel which wraps each message as an <a>SDU</a> using giving
--   <a>MiniProtocolNum</a> and <a>MiniProtocolDir</a>.
bearerAsChannel :: forall m. Functor m => Bearer m -> MiniProtocolNum -> MiniProtocolDir -> ByteChannel m
data SDU
SDU :: !SDUHeader -> !ByteString -> SDU
[msHeader] :: SDU -> !SDUHeader
[msBlob] :: SDU -> !ByteString
data SDUHeader
SDUHeader :: !RemoteClockModel -> !MiniProtocolNum -> !MiniProtocolDir -> !Word16 -> SDUHeader
[mhTimestamp] :: SDUHeader -> !RemoteClockModel
[mhNum] :: SDUHeader -> !MiniProtocolNum
[mhDir] :: SDUHeader -> !MiniProtocolDir
[mhLength] :: SDUHeader -> !Word16
newtype SDUSize
SDUSize :: Word16 -> SDUSize
[getSDUSize] :: SDUSize -> Word16
msTimestamp :: SDU -> RemoteClockModel
setTimestamp :: SDU -> RemoteClockModel -> SDU
msNum :: SDU -> MiniProtocolNum
msDir :: SDU -> MiniProtocolDir
msLength :: SDU -> Word16

-- | Size of a MuxHeader in Bytes
msHeaderLength :: Int64
newtype RemoteClockModel
RemoteClockModel :: Word32 -> RemoteClockModel
[unRemoteClockModel] :: RemoteClockModel -> Word32

-- | The <a>DiffTime</a> represented by a tick in the
--   <a>RemoteClockModel</a>
remoteClockPrecision :: DiffTime
data RuntimeError
ProtocolAlreadyRunning :: !MiniProtocolNum -> !MiniProtocolDir -> !MiniProtocolStatus -> RuntimeError
UnknownProtocolInternalError :: !MiniProtocolNum -> !MiniProtocolDir -> RuntimeError
BlockedOnCompletionVar :: !MiniProtocolNum -> RuntimeError

-- | ReadBuffer for Mux Bearers
--   
--   This is used to read more data than what currently need in one
--   syscall. Any extra data read is cached in rbVar until the next read
--   request.
data ReadBuffer m
ReadBuffer :: StrictTVar m ByteString -> Ptr Word8 -> Int -> ReadBuffer m

-- | Read cache
[rbVar] :: ReadBuffer m -> StrictTVar m ByteString

-- | Buffer, used by the kernel to write the received data into.
[rbBuf] :: ReadBuffer m -> Ptr Word8

-- | Size of <a>rbBuf</a>.
[rbSize] :: ReadBuffer m -> Int
instance GHC.Enum.Bounded Network.Mux.Types.RemoteClockModel
instance GHC.Classes.Eq Network.Mux.Types.RemoteClockModel
instance GHC.Show.Show Network.Mux.Types.MiniProtocolNum
instance GHC.Ix.Ix Network.Mux.Types.MiniProtocolNum
instance GHC.Enum.Enum Network.Mux.Types.MiniProtocolNum
instance GHC.Classes.Ord Network.Mux.Types.MiniProtocolNum
instance GHC.Classes.Eq Network.Mux.Types.MiniProtocolNum
instance GHC.Show.Show Network.Mux.Types.Status
instance GHC.Show.Show Network.Mux.Types.MiniProtocolIx
instance GHC.Ix.Ix Network.Mux.Types.MiniProtocolIx
instance GHC.Enum.Enum Network.Mux.Types.MiniProtocolIx
instance GHC.Num.Num Network.Mux.Types.MiniProtocolIx
instance GHC.Classes.Ord Network.Mux.Types.MiniProtocolIx
instance GHC.Classes.Eq Network.Mux.Types.MiniProtocolIx
instance GHC.Show.Show Network.Mux.Types.MiniProtocolDir
instance GHC.Enum.Bounded Network.Mux.Types.MiniProtocolDir
instance GHC.Enum.Enum Network.Mux.Types.MiniProtocolDir
instance GHC.Ix.Ix Network.Mux.Types.MiniProtocolDir
instance GHC.Classes.Ord Network.Mux.Types.MiniProtocolDir
instance GHC.Classes.Eq Network.Mux.Types.MiniProtocolDir
instance GHC.Show.Show Network.Mux.Types.MiniProtocolStatus
instance GHC.Classes.Eq Network.Mux.Types.MiniProtocolStatus
instance GHC.Real.Integral Network.Mux.Types.SDUSize
instance GHC.Real.Real Network.Mux.Types.SDUSize
instance GHC.Num.Num Network.Mux.Types.SDUSize
instance GHC.Enum.Enum Network.Mux.Types.SDUSize
instance GHC.Classes.Ord Network.Mux.Types.SDUSize
instance GHC.Classes.Eq Network.Mux.Types.SDUSize
instance GHC.Show.Show Network.Mux.Types.SDUSize
instance GHC.Generics.Generic Network.Mux.Types.SDUSize
instance GHC.Show.Show Network.Mux.Types.RuntimeError
instance GHC.Classes.Eq (Network.Mux.Types.MiniProtocolDirection mode)
instance GHC.Classes.Ord (Network.Mux.Types.MiniProtocolDirection mode)
instance GHC.Exception.Type.Exception Network.Mux.Types.RuntimeError

module Network.Mux.Trace

-- | Enumeration of error conditions.
data Error

-- | returned by <tt>decodeSDUHeader</tt>, thrown by <a>Bearer</a>.
UnknownMiniProtocol :: MiniProtocolNum -> Error

-- | thrown by <a>Bearer</a> when received a null byte.
BearerClosed :: String -> Error

-- | thrown by <tt>demux</tt> when violating <a>maximumIngressQueue</a>
--   byte limit.
IngressQueueOverRun :: MiniProtocolNum -> MiniProtocolDir -> Error

-- | thrown when data arrives on a responder channel when the mux was set
--   up as an <tt>InitiatorApp</tt>.
InitiatorOnly :: MiniProtocolNum -> Error

-- | <a>Error</a> thrown by
IOException :: IOException -> String -> Error

-- | return by <tt>decodeSDUHeader</tt>, thrown by <a>Bearer</a>.
SDUDecodeError :: String -> Error

-- | thrown when reading of a single SDU takes too long
SDUReadTimeout :: Error

-- | thrown when writing a single SDU takes too long
SDUWriteTimeout :: Error

-- | Result of runMiniProtocol's completionAction in case of an error or
--   mux being closed while a mini-protocol was still running, this is not
--   a clean exit.
Shutdown :: Maybe SomeException -> Status -> Error

-- | Handler for <a>Error</a>s which wraps them in <a>Error</a>.
--   
--   It is used various <a>Bearer</a> implementations: *
--   <tt>socketAsBearer</tt> * <tt>pipeAsBearer</tt>
handleIOException :: MonadThrow m => String -> IOException -> m a

-- | Enumeration of Mux events that can be traced.
data Trace
TraceRecvHeaderStart :: Trace
TraceRecvHeaderEnd :: SDUHeader -> Trace
TraceRecvDeltaQObservation :: SDUHeader -> Time -> Trace
TraceRecvDeltaQSample :: Double -> Int -> Int -> Double -> Double -> Double -> Double -> String -> Trace
TraceRecvRaw :: Int -> Trace
TraceRecvStart :: Int -> Trace
TraceRecvEnd :: Int -> Trace
TraceSendStart :: SDUHeader -> Trace
TraceSendEnd :: Trace
TraceState :: BearerState -> Trace
TraceCleanExit :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceExceptionExit :: MiniProtocolNum -> MiniProtocolDir -> SomeException -> Trace
TraceChannelRecvStart :: MiniProtocolNum -> Trace
TraceChannelRecvEnd :: MiniProtocolNum -> Int -> Trace
TraceChannelSendStart :: MiniProtocolNum -> Int -> Trace
TraceChannelSendEnd :: MiniProtocolNum -> Trace
TraceHandshakeStart :: Trace
TraceHandshakeClientEnd :: DiffTime -> Trace
TraceHandshakeServerEnd :: Trace
TraceHandshakeClientError :: e -> DiffTime -> Trace
TraceHandshakeServerError :: e -> Trace
TraceSDUReadTimeoutException :: Trace
TraceSDUWriteTimeoutException :: Trace
TraceStartEagerly :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceStartOnDemand :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceStartOnDemandAny :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceStartedOnDemand :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceTerminating :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceStopping :: Trace
TraceStopped :: Trace
TraceTCPInfo :: StructTCPInfo -> Word16 -> Trace
data BearerState

-- | <a>Bearer</a> has successfully completed the handshake.
Mature :: BearerState

-- | <a>Bearer</a> is dead and the underlying bearer has been closed.
Dead :: BearerState

-- | Type used for tracing mux events.
data WithBearer peerid a
WithBearer :: !peerid -> !a -> WithBearer peerid a

-- | A tag that should identify a specific mux bearer.
[wbPeerId] :: WithBearer peerid a -> !peerid
[wbEvent] :: WithBearer peerid a -> !a

-- | A peer label for use in <tt>Tracer</tt>s. This annotates tracer output
--   as being associated with a given peer identifier.
data TraceLabelPeer peerid a
TraceLabelPeer :: peerid -> a -> TraceLabelPeer peerid a
instance GHC.Show.Show Network.Mux.Trace.Error
instance (GHC.Show.Show peerid, GHC.Show.Show a) => GHC.Show.Show (Network.Mux.Trace.TraceLabelPeer peerid a)
instance GHC.Base.Functor (Network.Mux.Trace.TraceLabelPeer peerid)
instance (GHC.Classes.Eq peerid, GHC.Classes.Eq a) => GHC.Classes.Eq (Network.Mux.Trace.TraceLabelPeer peerid a)
instance (GHC.Show.Show peerid, GHC.Show.Show a) => GHC.Show.Show (Network.Mux.Trace.WithBearer peerid a)
instance GHC.Generics.Generic (Network.Mux.Trace.WithBearer peerid a)
instance GHC.Show.Show Network.Mux.Trace.BearerState
instance GHC.Classes.Eq Network.Mux.Trace.BearerState
instance GHC.Show.Show Network.Mux.Trace.Trace
instance Data.Bifunctor.Bifunctor Network.Mux.Trace.TraceLabelPeer
instance GHC.Exception.Type.Exception Network.Mux.Trace.Error

module Network.Mux.Ingress

-- | demux runs as a single separate thread and reads complete <a>SDU</a>s
--   from the underlying Bearer and forwards it to the matching ingress
--   queue.
demuxer :: (MonadAsync m, MonadFork m, MonadMask m, MonadThrow (STM m), MonadTimer m) => [MiniProtocolState mode m] -> Bearer m -> m void

module Network.Mux.Egress

-- | Process the messages from the mini protocols - there is a single
--   shared FIFO that contains the items of work. This is processed so that
--   each active demand gets a <tt>maxSDU</tt>s work of data processed each
--   time it gets to the front of the queue
muxer :: forall m void. (MonadAsync m, MonadDelay m, MonadFork m, MonadMask m, MonadThrow (STM m), MonadTimer m) => EgressQueue m -> Bearer m -> m void
type EgressQueue m = StrictTBQueue m (TranslocationServiceRequest m)

-- | A TranslocationServiceRequest is a demand for the translocation of a
--   single mini-protocol message. This message can be of arbitrary (yet
--   bounded) size. This multiplexing layer is responsible for the
--   segmentation of concrete representation into appropriate SDU's for
--   onward transmission.
data TranslocationServiceRequest m
TLSRDemand :: !MiniProtocolNum -> !MiniProtocolDir -> !Wanton m -> TranslocationServiceRequest m

-- | A Wanton represent the concrete data to be translocated, note that the
--   TVar becoming empty indicates -- that the last fragment of the data
--   has been enqueued on the -- underlying bearer.
newtype Wanton m
Wanton :: StrictTVar m ByteString -> Wanton m
[want] :: Wanton m -> StrictTVar m ByteString

module Network.Mux.DeltaQ.TraceStats
step :: RemoteClockModel -> Time -> Int -> StatsA -> (Maybe OneWayDeltaQSample, StatsA)

-- | One way measurement for interval. Note that the fields are lazy here
--   so that only calculation necessary to satisfy strictness of use
--   occurs.
data OneWayDeltaQSample
OneWaySample :: Double -> Int -> Int -> Double -> Double -> Double -> Double -> String -> OneWayDeltaQSample
[duration] :: OneWayDeltaQSample -> Double
[sumPackets] :: OneWayDeltaQSample -> Int
[sumTotalSDU] :: OneWayDeltaQSample -> Int
[estDeltaQS] :: OneWayDeltaQSample -> Double
[estDeltaQVMean] :: OneWayDeltaQSample -> Double
[estDeltaQVVar] :: OneWayDeltaQSample -> Double
[estR] :: OneWayDeltaQSample -> Double
[sizeDist] :: OneWayDeltaQSample -> String
constructSample :: StatsA -> OneWayDeltaQSample

-- | Statistics accumulator. Strict evaluation used to keep the memory
--   footprint strictly bounded.
data StatsA

-- | Initial StatsA
initialStatsA :: StatsA
instance GHC.Base.Semigroup Network.Mux.DeltaQ.TraceStats.PerSizeRecord

module Network.Mux.DeltaQ.TraceTransformer

-- | Create a trace transformer that will emit
--   <tt>MuxTraceRecvDeltaQSample</tt> no more frequently than every 10
--   seconds (when in use).
initDeltaQTracer :: MonadSTM m => m (Tracer m Trace -> Tracer m Trace)
initDeltaQTracer' :: MonadSTM m => Tracer m Trace -> m (Tracer m Trace)

module Network.Mux.Codec

-- | Encode a <a>SDU</a> as a <tt>ByteString</tt>.
--   
--   <pre>
--   Binary format used by 'encodeSDU' and 'decodeSDUHeader'
--    0                   1                   2                   3
--    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
--   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
--   |              transmission time                                |
--   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
--   |M|    conversation id          |              length           |
--   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
--   </pre>
--   
--   All fields are in big endian byte order.
encodeSDU :: SDU -> ByteString

-- | Decode a <tt>MuSDU</tt> header. A left inverse of <a>encodeSDU</a>.
decodeSDU :: ByteString -> Either Error SDU

module Network.Mux.Bearer.Socket

-- | Create <tt><tt>MuxBearer</tt></tt> from a socket.
--   
--   On Windows <a>Async</a> operations are used to read and write from a
--   socket. This means that the socket must be associated with the I/O
--   completion port with <a>associateWithIOCompletionPort</a>.
--   
--   Note: <tt>IOException</tt>s thrown by <tt>sendAll</tt> and
--   <tt>recv</tt> are wrapped in <tt>MuxError</tt>.
socketAsBearer :: SDUSize -> Int -> Maybe (ReadBuffer IO) -> DiffTime -> DiffTime -> Tracer IO Trace -> Socket -> Bearer IO

module Network.Mux.Bearer.Queues
data QueueChannel m
QueueChannel :: StrictTBQueue m ByteString -> StrictTBQueue m ByteString -> QueueChannel m
[readQueue] :: QueueChannel m -> StrictTBQueue m ByteString
[writeQueue] :: QueueChannel m -> StrictTBQueue m ByteString
queueChannelAsBearer :: forall m. (MonadSTM m, MonadMonotonicTime m, MonadThrow m) => SDUSize -> Tracer m Trace -> QueueChannel m -> Bearer m

module Network.Mux.Bearer.Pipe

-- | Abstraction over various types of handles. We provide two instances:
--   
--   <ul>
--   <li>based on <a>Handle</a>: os independent, but will not work well on
--   Windows,</li>
--   <li>based on <a>HANDLE</a>: Windows specific.</li>
--   </ul>
data PipeChannel
PipeChannel :: (Int -> IO ByteString) -> (ByteString -> IO ()) -> PipeChannel
[readHandle] :: PipeChannel -> Int -> IO ByteString
[writeHandle] :: PipeChannel -> ByteString -> IO ()
pipeChannelFromHandles :: Handle -> Handle -> PipeChannel
pipeAsBearer :: SDUSize -> Tracer IO Trace -> PipeChannel -> Bearer IO

module Network.Mux.Bearer.AttenuatedChannel

-- | An AttenuatedChannel supports:
--   
--   <ul>
--   <li>attenuation applied after reading a message from
--   <a>QueueChannel</a>;</li>
--   <li>two-way close handshake with 120s timeout. Read side is closed as
--   soon as an internal <a>MsgClose</a> is received, write side has to be
--   closed explicitly.</li>
--   </ul>
data AttenuatedChannel m
AttenuatedChannel :: m ByteString -> (ByteString -> m ()) -> m () -> AttenuatedChannel m
[acRead] :: AttenuatedChannel m -> m ByteString
[acWrite] :: AttenuatedChannel m -> ByteString -> m ()
[acClose] :: AttenuatedChannel m -> m ()
type Size = Int64
data SuccessOrFailure
Success :: SuccessOrFailure
Failure :: IOError -> SuccessOrFailure

-- | Attenuation of a channel.
data Attenuation
Attenuation :: (Time -> Size -> (DiffTime, SuccessOrFailure)) -> Maybe Int -> Attenuation
[aReadAttenuation] :: Attenuation -> Time -> Size -> (DiffTime, SuccessOrFailure)
[aWriteAttenuation] :: Attenuation -> Maybe Int

-- | <a>QueueChannel</a> is the low level bearer used by the simulated
--   snocket.
--   
--   Each read / write queues can be closed independently. Read queue is
--   closed once <a>MsgClose</a> is read from the queue; dually, write
--   queue is closed once <a>MsgClose</a> is written.
data QueueChannel m

-- | Make a <a>AttenuatedChannel</a> from a <a>QueueChannel</a>.
newAttenuatedChannel :: forall m. (MonadDelay m, MonadTimer m, MonadThrow m, MonadThrow (STM m)) => Tracer m AttenuatedChannelTrace -> Attenuation -> QueueChannel m -> STM m (AttenuatedChannel m)
echoQueueChannel :: MonadSTM m => STM m (QueueChannel m)

-- | Create a pair of connected <a>AttenuatedChannel</a>s.
newConnectedAttenuatedChannelPair :: forall m. (MonadDelay m, MonadLabelledSTM m, MonadTimer m, MonadThrow m, MonadThrow (STM m)) => Tracer m AttenuatedChannelTrace -> Tracer m AttenuatedChannelTrace -> Attenuation -> Attenuation -> STM m (AttenuatedChannel m, AttenuatedChannel m)
attenuationChannelAsBearer :: forall m. (MonadThrow m, MonadMonotonicTime m) => SDUSize -> DiffTime -> Tracer m Trace -> AttenuatedChannel m -> Bearer m
data AttenuatedChannelTrace
AttChannLocalClose :: Bool -> AttenuatedChannelTrace
AttChannRemoteClose :: AttenuatedChannelTrace
resourceVanishedIOError :: String -> String -> IOError
instance GHC.Classes.Eq Network.Mux.Bearer.AttenuatedChannel.Message
instance GHC.Show.Show Network.Mux.Bearer.AttenuatedChannel.AttenuatedChannelTrace

module Network.Mux.Bearer

-- | Low level access to underlying socket or pipe. There are three smart
--   constructors:
--   
--   <ul>
--   <li><a>socketAsBearer</a></li>
--   <li><a>pipeAsBearer</a></li>
--   <li><pre>Test.Mux.queuesAsBearer</pre></li>
--   </ul>
data Bearer m
Bearer :: (TimeoutFn m -> SDU -> m Time) -> (TimeoutFn m -> [SDU] -> m Time) -> (TimeoutFn m -> m (SDU, Time)) -> SDUSize -> Int -> String -> DiffTime -> Bearer m
newtype MakeBearer m fd
MakeBearer :: (DiffTime -> Tracer m Trace -> fd -> Maybe (ReadBuffer m) -> m (Bearer m)) -> MakeBearer m fd
[getBearer] :: MakeBearer m fd -> DiffTime -> Tracer m Trace -> fd -> Maybe (ReadBuffer m) -> m (Bearer m)
makeSocketBearer :: MakeBearer IO Socket
makeSocketBearer' :: DiffTime -> MakeBearer IO Socket
makePipeChannelBearer :: MakeBearer IO PipeChannel
makeQueueChannelBearer :: (MonadSTM m, MonadMonotonicTime m, MonadThrow m) => MakeBearer m (QueueChannel m)
withReadBufferIO :: (Maybe (ReadBuffer IO) -> IO b) -> IO b


-- | Network multiplexer API.
--   
--   The module should be imported qualified.
module Network.Mux

-- | Create a mux handle in <a>Mode</a> and register mini-protocols.
new :: forall (mode :: Mode) m. MonadLabelledSTM m => [MiniProtocolInfo mode] -> m (Mux mode m)

-- | Mux handle which allows to control the multiplexer, e.g.
--   
--   <ul>
--   <li><a>run</a>: run the multiplexer</li>
--   <li><a>runMiniProtocol</a>: start a mini-protocol (eagerly or
--   lazily)</li>
--   <li><a>stop</a>: stop the multiplexer, causing <a>run</a> to
--   return.</li>
--   </ul>
data Mux (mode :: Mode) m

-- | Statically configured multiplexer mode.
data Mode

-- | Only execute initiator protocols. In this mode the multiplexer will
--   only run its egress side.
[InitiatorMode] :: Mode

-- | Only execute responder protocols. It this mode the multiplexer will
--   only run its ingress side.
[ResponderMode] :: Mode

-- | Execute initiator and responder protocols. In this mode the
--   multiplexer will run both ingress and egress sides.
[InitiatorResponderMode] :: Mode
type family HasInitiator (mode :: Mode) :: Bool
type family HasResponder (mode :: Mode) :: Bool

-- | A static description of a mini-protocol.
data MiniProtocolInfo (mode :: Mode)
MiniProtocolInfo :: !MiniProtocolNum -> !MiniProtocolDirection mode -> !MiniProtocolLimits -> !Maybe Int -> MiniProtocolInfo (mode :: Mode)

-- | Unique mini-protocol number.
[miniProtocolNum] :: MiniProtocolInfo (mode :: Mode) -> !MiniProtocolNum

-- | Mini-protocol direction.
[miniProtocolDir] :: MiniProtocolInfo (mode :: Mode) -> !MiniProtocolDirection mode

-- | ingress queue limits for the protocol
[miniProtocolLimits] :: MiniProtocolInfo (mode :: Mode) -> !MiniProtocolLimits

-- | capability on which the mini-protocol should run
[miniProtocolCapability] :: MiniProtocolInfo (mode :: Mode) -> !Maybe Int

-- | The wire format includes the protocol numbers, and it's vital that
--   these are stable. They are not necessarily dense however, as new ones
--   are added and some old ones retired. So we use a dedicated class for
--   this rather than reusing <a>Enum</a>. This also covers unrecognised
--   protocol numbers on the decoding side.
newtype MiniProtocolNum
MiniProtocolNum :: Word16 -> MiniProtocolNum
data MiniProtocolDirection (mode :: Mode)
[InitiatorDirectionOnly] :: MiniProtocolDirection InitiatorMode
[ResponderDirectionOnly] :: MiniProtocolDirection ResponderMode
[InitiatorDirection] :: MiniProtocolDirection InitiatorResponderMode
[ResponderDirection] :: MiniProtocolDirection InitiatorResponderMode

-- | Per Miniprotocol limits
newtype MiniProtocolLimits
MiniProtocolLimits :: Int -> MiniProtocolLimits

-- | Limit on the maximum number of bytes that can be queued in the
--   miniprotocol's ingress queue.
[maximumIngressQueue] :: MiniProtocolLimits -> Int

-- | run starts a mux bearer for the specified protocols corresponding to
--   one of the provided Versions.
--   
--   <b>Isometric flow control: analysis of head-of-line blocking of the
--   ingress side of the multiplexer</b>
--   
--   For each mini-protocol (enumerated by <tt>ptcl</tt>), mux will create
--   two channels. One for initiator and one for the responder. Each
--   channel will use a single <a>Wanton</a>. When it is filled, it is put
--   in a common queue <tt>tsrQueue</tt>. This means that the queue is
--   bound by <tt>2 * |ptcl|</tt>. Every side of a mini-protocol is served
--   by a single <a>Wanton</a>: when an application sends data, the channel
--   will try to put it into the <a>Wanton</a> (which might block).
--   <a>Wanton</a>s are taken from the <tt>tsrQueue</tt> queue by one of
--   mux threads. This eliminates head of line blocking: each mini-protocol
--   thread can block on putting more bytes into its <a>Wanton</a>, but it
--   cannot block the other mini-protocols or the thread that is reading
--   the <tt>tsrQueue</tt> queue. This is ensured since the
--   <a>muxChannel</a> will put only a non-empty <a>Wanton</a> to the
--   <tt>tsrQueue</tt> queue, and on such wantons the queue is never
--   blocked. This means that the only way the queue can block is when its
--   empty, which means that none of the mini-protocols wanted to send. The
--   egress part will read a <a>Wanton</a>, take a fixed amount of bytes
--   encode them in as an <tt>MuxSDU</tt>; if there are leftovers it will
--   put them back in the <a>Wanton</a> and place it at the end of the
--   queue (reading and writing to it will happen in a single STM
--   transaction which assures that the order of requests from a
--   mini-protocol is preserved.
--   
--   Properties:
--   
--   <ul>
--   <li>at any given time the <tt>tsrQueue</tt> contains at most one
--   <a>TranslocationServiceRequest</a> from a given mini-protocol of the
--   given <a>MiniProtocolDir</a>, thus the queue contains at most <tt>2 *
--   |ptcl|</tt> translocation requests.</li>
--   <li>at any given time each <tt>TranslocationServiceRequest</tt>
--   contains a non-empty <a>Wanton</a></li>
--   </ul>
run :: forall m (mode :: Mode). (MonadAsync m, MonadDelay m, MonadFork m, MonadLabelledSTM m, Alternative (STM m), MonadThrow (STM m), MonadTimer m, MonadMask m) => Tracer m Trace -> Mux mode m -> Bearer m -> m ()

-- | Shut down the mux. This will cause <a>run</a> to return. It does not
--   wait for any protocol threads to finish, so you should do that first
--   if necessary.
stop :: MonadSTM m => Mux mode m -> m ()

-- | Arrange to run a protocol thread (for a particular
--   <a>MiniProtocolNum</a> and <a>MiniProtocolDirection</a>) to interact
--   on this protocol's <a>Channel</a>.
--   
--   The protocol thread can either be started eagerly or on-demand:
--   
--   <ul>
--   <li>With <a>StartEagerly</a>, the thread is started promptly. This is
--   appropriate for mini-protocols where the opening message may be sent
--   by this thread.</li>
--   <li>With <a>StartOnDemand</a>, the thread is not started until the
--   first data is received for this mini-protocol. This is appropriate for
--   mini-protocols where the opening message is sent by the remote
--   peer.</li>
--   </ul>
--   
--   The result is a STM action to block and wait on the protocol
--   completion. It is safe to call this completion action multiple times:
--   it will always return the same result once the protocol thread
--   completes. In case the Mux has stopped, either due to an exception or
--   because of a call to muxStop a `Left Error` will be returned from the
--   STM action.
--   
--   It is an error to start a new protocol thread while one is still
--   running, for the same <a>MiniProtocolNum</a> and
--   <a>MiniProtocolDirection</a>. This can easily be avoided by using the
--   STM completion action to wait for the previous one to finish.
--   
--   It is safe to ask to start a protocol thread before <a>run</a>. In
--   this case the protocol thread will not actually start until <a>run</a>
--   is called, irrespective of the <a>StartOnDemandOrEagerly</a> value.
runMiniProtocol :: forall mode m a. (Alternative (STM m), MonadSTM m, MonadThrow m, MonadThrow (STM m)) => Mux mode m -> MiniProtocolNum -> MiniProtocolDirection mode -> StartOnDemandOrEagerly -> (ByteChannel m -> m (a, Maybe ByteString)) -> m (STM m (Either SomeException a))

-- | Strategy how to start a mini-protocol.
data StartOnDemandOrEagerly

-- | Start a mini-protocol promptly.
StartEagerly :: StartOnDemandOrEagerly

-- | Start a mini-protocol when data is received for the given
--   mini-protocol. Must be used only when initial message is sent by the
--   remote side.
StartOnDemand :: StartOnDemandOrEagerly

-- | Like <a>StartOnDemand</a>, but start a mini-protocol if data is
--   received for any mini-protocol set to <a>StartOnDemand</a>.
StartOnDemandAny :: StartOnDemandOrEagerly

-- | Channel using <a>ByteString</a>.
type ByteChannel m = Channel m ByteString

-- | A channel which can send and receive values.
--   
--   It is more general than what `network-mux` requires, see
--   <a>ByteChannel</a> instead. However this is useful for testing
--   purposes when one is either using <tt>mux</tt> or connecting two ends
--   directly.
data Channel m a
Channel :: (a -> m ()) -> m (Maybe a) -> Channel m a

-- | Write bytes to the channel.
--   
--   It maybe raise exceptions.
[send] :: Channel m a -> a -> m ()

-- | Read some input from the channel, or <tt>Nothing</tt> to indicate EOF.
--   
--   Note that having received EOF it is still possible to send. The EOF
--   condition is however monotonic.
--   
--   It may raise exceptions (as appropriate for the monad and kind of
--   channel).
[recv] :: Channel m a -> m (Maybe a)

-- | Low level access to underlying socket or pipe. There are three smart
--   constructors:
--   
--   <ul>
--   <li><a>socketAsBearer</a></li>
--   <li><a>pipeAsBearer</a></li>
--   <li><pre>Test.Mux.queuesAsBearer</pre></li>
--   </ul>
data Bearer m
newtype MakeBearer m fd
MakeBearer :: (DiffTime -> Tracer m Trace -> fd -> Maybe (ReadBuffer m) -> m (Bearer m)) -> MakeBearer m fd
[getBearer] :: MakeBearer m fd -> DiffTime -> Tracer m Trace -> fd -> Maybe (ReadBuffer m) -> m (Bearer m)
newtype SDUSize
SDUSize :: Word16 -> SDUSize
[getSDUSize] :: SDUSize -> Word16

-- | Get information about all statically registered mini-protocols.
miniProtocolStateMap :: MonadSTM m => Mux mode m -> Map (MiniProtocolNum, MiniProtocolDir) (STM m MiniProtocolStatus)

-- | Await until mux stopped.
stopped :: MonadSTM m => Mux mode m -> STM m (Maybe SomeException)

-- | Enumeration of error conditions.
data Error

-- | returned by <tt>decodeSDUHeader</tt>, thrown by <a>Bearer</a>.
UnknownMiniProtocol :: MiniProtocolNum -> Error

-- | thrown by <a>Bearer</a> when received a null byte.
BearerClosed :: String -> Error

-- | thrown by <tt>demux</tt> when violating <a>maximumIngressQueue</a>
--   byte limit.
IngressQueueOverRun :: MiniProtocolNum -> MiniProtocolDir -> Error

-- | thrown when data arrives on a responder channel when the mux was set
--   up as an <tt>InitiatorApp</tt>.
InitiatorOnly :: MiniProtocolNum -> Error

-- | <a>Error</a> thrown by
IOException :: IOException -> String -> Error

-- | return by <tt>decodeSDUHeader</tt>, thrown by <a>Bearer</a>.
SDUDecodeError :: String -> Error

-- | thrown when reading of a single SDU takes too long
SDUReadTimeout :: Error

-- | thrown when writing a single SDU takes too long
SDUWriteTimeout :: Error

-- | Result of runMiniProtocol's completionAction in case of an error or
--   mux being closed while a mini-protocol was still running, this is not
--   a clean exit.
Shutdown :: Maybe SomeException -> Status -> Error
data RuntimeError
ProtocolAlreadyRunning :: !MiniProtocolNum -> !MiniProtocolDir -> !MiniProtocolStatus -> RuntimeError
UnknownProtocolInternalError :: !MiniProtocolNum -> !MiniProtocolDir -> RuntimeError
BlockedOnCompletionVar :: !MiniProtocolNum -> RuntimeError
traceBearerState :: Tracer m Trace -> BearerState -> m ()
data BearerState

-- | <a>Bearer</a> has successfully completed the handshake.
Mature :: BearerState

-- | <a>Bearer</a> is dead and the underlying bearer has been closed.
Dead :: BearerState

-- | Enumeration of Mux events that can be traced.
data Trace
TraceRecvHeaderStart :: Trace
TraceRecvHeaderEnd :: SDUHeader -> Trace
TraceRecvDeltaQObservation :: SDUHeader -> Time -> Trace
TraceRecvDeltaQSample :: Double -> Int -> Int -> Double -> Double -> Double -> Double -> String -> Trace
TraceRecvRaw :: Int -> Trace
TraceRecvStart :: Int -> Trace
TraceRecvEnd :: Int -> Trace
TraceSendStart :: SDUHeader -> Trace
TraceSendEnd :: Trace
TraceState :: BearerState -> Trace
TraceCleanExit :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceExceptionExit :: MiniProtocolNum -> MiniProtocolDir -> SomeException -> Trace
TraceChannelRecvStart :: MiniProtocolNum -> Trace
TraceChannelRecvEnd :: MiniProtocolNum -> Int -> Trace
TraceChannelSendStart :: MiniProtocolNum -> Int -> Trace
TraceChannelSendEnd :: MiniProtocolNum -> Trace
TraceHandshakeStart :: Trace
TraceHandshakeClientEnd :: DiffTime -> Trace
TraceHandshakeServerEnd :: Trace
TraceHandshakeClientError :: e -> DiffTime -> Trace
TraceHandshakeServerError :: e -> Trace
TraceSDUReadTimeoutException :: Trace
TraceSDUWriteTimeoutException :: Trace
TraceStartEagerly :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceStartOnDemand :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceStartOnDemandAny :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceStartedOnDemand :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceTerminating :: MiniProtocolNum -> MiniProtocolDir -> Trace
TraceStopping :: Trace
TraceStopped :: Trace
TraceTCPInfo :: StructTCPInfo -> Word16 -> Trace

-- | Type used for tracing mux events.
data WithBearer peerid a
WithBearer :: !peerid -> !a -> WithBearer peerid a

-- | A tag that should identify a specific mux bearer.
[wbPeerId] :: WithBearer peerid a -> !peerid
[wbEvent] :: WithBearer peerid a -> !a
instance GHC.Classes.Ord Network.Mux.Group
instance GHC.Classes.Eq Network.Mux.Group
instance GHC.Show.Show Network.Mux.StartOnDemandOrEagerly
instance GHC.Classes.Eq Network.Mux.StartOnDemandOrEagerly
