name: Upload to ghcr.io

on:
  push:
    tags:
      - '**'
  # GITHUB_SHA: Last commit in the tagged release
  # GITHUB_REF: Tag ref of release refs/tags/<tag_name>
  release:
    types:
      - published
  # GITHUB_SHA: Last commit on the GITHUB_REF branch or tag
  # GITHUB_REF: Branch or tag that received dispatch
  workflow_dispatch: {}

permissions:
  contents: read
  packages: write

env:
  # Only to avoid some repetition
  FLAKE_REF: github:${{ github.repository }}/${{ github.ref_name }}
  GH_TOKEN: ${{ github.token }}
  # We need to tell skopeo where to write the authentication token
  REGISTRY_AUTH_FILE: ./skopeo-registry-auth-file.json

jobs:
  wait-for-hydra:
    name: "Wait for hydra check-runs"
    runs-on: ubuntu-latest

    steps:
    - name: Waiting for ci/hydra-build:required to complete
      run: |
        while [[ true ]]; do
          check_name='ci/hydra-build:required'
          conclusion=$(gh api "repos/$GITHUB_REPOSITORY/commits/$GITHUB_SHA/check-runs?check_name=$check_name" --paginate --jq '.check_runs[].conclusion')
          case "$conclusion" in
            success)
              echo "$check_name succeeded"
              exit 0;;
            '')
              echo "$check_name pending. Waiting 30s..."
              sleep 30;;
            *)
              echo "$check_name terminated unsuccessfully"
              exit 1;;
          esac
        done


  prepare:
    needs: [wait-for-hydra]
    name: "Prepare metadata"
    runs-on: ubuntu-latest
    outputs:
      LATEST_TAG: ${{ steps.latest-tag.outputs.LATEST_TAG }}
      LOCKED_URL: ${{ steps.flake-metadata.outputs.LOCKED_URL }}

    steps:
    - name: Install Nix
      uses: input-output-hk/install-nix-action@v20

    - name: Display flake metadata
      id: flake-metadata
      run: |
        nix flake metadata ${{ env.FLAKE_REF }}
        nix flake metadata ${{ env.FLAKE_REF }} --json | jq -r '"LOCKED_URL=\(.url)"' >> "$GITHUB_OUTPUT"

    - name: Obtaining latest release tag
      id: latest-tag
      run: |
        LATEST_TAG=$(gh api repos/$GITHUB_REPOSITORY/releases/latest --paginate --jq '.tag_name')
        echo "LATEST_TAG=$LATEST_TAG" >> "$GITHUB_OUTPUT"
        echo "Latest release tag is: $LATEST_TAG"

  build:
    needs: [prepare]
    name: "Upload to ghcr.io"
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch:
          - name: amd64
            system: x86_64-linux
          - name: arm64
            system: aarch64-linux
        image:
          - name: cardano-node
            nix_key: dockerImage/node
          - name: cardano-submit-api
            nix_key: dockerImage/submit-api
          - name: cardano-tracer
            nix_key: dockerImage/tracer

    steps:
    - name: Install Nix
      uses: input-output-hk/install-nix-action@v20

    - name: Login to GitHub Container Registry
      run: skopeo login --username ${{ github.actor }} --password ${{ secrets.GITHUB_TOKEN }} ghcr.io

    # NOTE We assume that hydra has already built the image, this is
    # reasonable since, before applying the tag, we must have already
    # pushed the tagged commit somewhere, and Hydra will have had the
    # change to build the image.

    - name: Uploading ${{ matrix.image.name }} (${{ matrix.arch.name }})
      run: |
        echo "::group::Downloading from cache"
        nix build \
          --accept-flake-config \
          --print-out-paths \
          --builders "" \
          --max-jobs 0 \
          --out-link ./result-${{ matrix.image.name }}-${{ matrix.arch.name }} \
          ${{ needs.prepare.outputs.LOCKED_URL }}#packages.${{ matrix.arch.system }}.${{ matrix.image.nix_key }}
        echo "::endgroup::"

        echo "::group::Uploading to registry"
        skopeo copy \
          docker-archive:./result-${{ matrix.image.name }}-${{ matrix.arch.name }} \
          docker://ghcr.io/intersectmbo/${{ matrix.image.name }}:$GITHUB_REF_NAME-${{ matrix.arch.name }}
        echo "::endgroup::"


  create-manifest:
     needs: [prepare, build]
     name: "Create Multi-Arch Manifest"
     runs-on: ubuntu-latest

     steps:
       - name: Setup Docker Buildx
         uses: docker/setup-buildx-action@v3

       - name: Login to GitHub Container Registry
         run: docker login ghcr.io --username ${{ github.actor }} --password ${{ secrets.GITHUB_TOKEN }}

       - name: Create Manifests
         run: |
           REPOS=(cardano-node cardano-submit-api cardano-tracer)
           ARCHES=(amd64 arm64)

           for REPO in "${REPOS[@]}"; do
             IMAGE_REPO="ghcr.io/intersectmbo/$REPO"
             IMAGE_REFERENCES=()

             for ARCH in "${ARCHES[@]}"; do
               IMAGE_REFERENCES+=("$IMAGE_REPO:$GITHUB_REF_NAME-$ARCH")
             done

             echo "::group::Creating manifest for $IMAGE_REPO:$GITHUB_REF_NAME"
             docker buildx imagetools create --tag "$IMAGE_REPO:$GITHUB_REF_NAME" "${IMAGE_REFERENCES[@]}"
             echo "::endgroup::"
           done

       - name: Tag Containers as :latest
         # Github releases are checked for latest tag in the first `or` operand of
         # the if statement. However, promoted pre-releases or changed full
         # releases do not count as a `published` event and so won't trigger
         # this workflow.  For those use cases a manual workflow must be run
         # from the matching release tag which the second `or` operand checks
         # for.
         if: |
           (github.event_name == 'release' && github.event.release.tag_name == needs.prepare.outputs.LATEST_TAG) ||
           (github.event_name == 'workflow_dispatch' && github.ref == format('refs/tags/{0}', needs.prepare.outputs.LATEST_TAG))
         run: |
           REPOS=(cardano-node cardano-submit-api cardano-tracer)

           for REPO in "${REPOS[@]}"; do
             IMAGE_REPO="ghcr.io/intersectmbo/$REPO"

             echo "::group::Creating manifest for $IMAGE_REPO:latest"
             docker buildx imagetools create --tag "$IMAGE_REPO:latest" $IMAGE_REPO:$GITHUB_REF_NAME
             echo "::endgroup::"
           done
