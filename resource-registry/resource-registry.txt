-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Track allocated resources
--   
--   When the scope of a <tt>bracket</tt> doesn't enclose all uses of the
--   resource, a <a>ResourceRegistry</a> can be used instead to capture the
--   lifetime of those resources.
@package resource-registry
@version 0.1.0.0


-- | Note on terminology: when thread A forks thread B, we will say that
--   thread A is the "parent" and thread B is the "child". No further
--   relationship between the two threads is implied by this terminology.
--   In particular, note that the child may outlive the parent. We will use
--   "fork" and "spawn" interchangeably.
--   
--   <h1>Motivation</h1>
--   
--   Whenever we allocate resources, we must keep track of them so that we
--   can deallocate them when they are no longer required. The most
--   important tool we have to achieve this is <a>bracket</a>:
--   
--   <pre>
--   bracket allocateResource releaseResource $ \r -&gt;
--     .. use r ..
--   </pre>
--   
--   Often <a>bracket</a> comes in the guise of a with-style combinator
--   
--   <pre>
--   withResource $ \r -&gt;
--     .. use r ..
--   </pre>
--   
--   Where this pattern is applicable, it should be used and there is no
--   need to use the <a>ResourceRegistry</a>. However, <a>bracket</a>
--   introduces strict lexical scoping: the resource is available inside
--   the scope of the bracket, and will be deallocated once we leave that
--   scope. That pattern is sometimes hard to use.
--   
--   For example, suppose we have this interface to an SQL server
--   
--   <pre>
--   query :: Query -&gt; IO QueryHandle
--   close :: QueryHandle -&gt; IO ()
--   next  :: QueryHandle -&gt; IO Row
--   </pre>
--   
--   and suppose furthermore that we are writing a simple webserver that
--   allows a client to send multiple SQL queries, get rows from any open
--   query, and close queries when no longer required:
--   
--   <pre>
--   server :: IO ()
--   server = go Map.empty
--     where
--       go :: Map QueryId QueryHandle -&gt; IO ()
--       go handles = getRequest &gt;&gt;= \case
--           New q -&gt; do
--             h   &lt;- query q                        -- allocate
--             qId &lt;- generateQueryId
--             sendResponse qId
--             go $ Map.insert qId h handles
--           Close qId -&gt; do
--             close (handles ! qId)                 -- release
--             go $ Map.delete qId handles
--           Next qId -&gt; do
--             sendResponse =&lt;&lt; next (handles ! qId)
--             go handles
--   </pre>
--   
--   The server opens and closes query handles in response to client
--   requests. Restructuring this code to use <a>bracket</a> would be
--   awkward, but as it stands this code does not ensure that resources get
--   deallocated; for example, if the server thread is killed
--   (<a>killThread</a>), resources will be leaked.
--   
--   Another, perhaps simpler, example is spawning threads. Threads too
--   should be considered to be resources that we should keep track of and
--   deallocate when they are no longer required, primarily because when we
--   deallocate (terminate) those threads they too will have a chance to
--   deallocate <i>their</i> resources. As for other resources, we have a
--   with-style combinator for this
--   
--   <pre>
--   withAsync $ \thread -&gt; ..
--   </pre>
--   
--   Lexical scoping of threads is often inconvenient, however, more so
--   than for regular resources. The temptation is therefore to simply fork
--   a thread and forget about it, but if we are serious about resource
--   deallocation this is not an acceptable solution.
--   
--   <h1>The resource registry</h1>
--   
--   The resource registry is essentially a piece of state tracking which
--   resources have been allocated. The registry itself is allocated with a
--   with-style combinator <a>withRegistry</a>, and when we leave that
--   scope any resources not yet deallocated will be released at that
--   point. Typically the registry is only used as a fall-back, ensuring
--   that resources will deallocated even in the presence of exceptions.
--   For example, here's how we might rewrite the above server example
--   using a registry:
--   
--   <pre>
--   server' :: IO ()
--   server' =
--       withRegistry $ \registry -&gt; go registry Map.empty
--     where
--       go :: ResourceRegistry IO
--          -&gt; Map QueryId (ResourceKey, QueryHandle)
--          -&gt; IO ()
--       go registry handles = getRequest &gt;&gt;= \case
--           New q -&gt; do
--             (key, h) &lt;- allocate registry (query q) close  -- allocate
--             qId      &lt;- generateQueryId
--             sendResponse qId
--             go registry $ Map.insert qId (key, h) handles
--           Close qId -&gt; do
--             release registry (fst (handles ! qId))         -- release
--             go registry $ Map.delete qId handles
--           Next qId -&gt; do
--             sendResponse =&lt;&lt; next (snd (handles ! qId))
--             go registry handles
--   </pre>
--   
--   We allocate the query with the help of the registry, providing the
--   registry with the means to deallocate the query should that be
--   required. We can /and should/ still manually release resources also:
--   in this particular example, the (lexical) scope of the registry is the
--   entire server thread, so delaying releasing queries until we exit that
--   scope will probably mean we hold on to resources for too long. The
--   registry is only there as a fall-back.
--   
--   <h1>Spawning threads</h1>
--   
--   We already observed in the introduction that insisting on lexical
--   scoping for threads is often inconvenient, and that simply using
--   <a>forkIO</a> is no solution as it means we might leak resources.
--   There is however another problem with <a>forkIO</a>. Consider this
--   snippet:
--   
--   <pre>
--   withRegistry $ \registry -&gt;
--     r &lt;- allocate registry allocateResource releaseResource
--     forkIO $ .. use r ..
--   </pre>
--   
--   It is easy to see that this code is problematic: we allocate a
--   resource <tt>r</tt>, then spawn a thread that uses <tt>r</tt>, and
--   finally leave the scope of <a>withRegistry</a>, thereby deallocating
--   <tt>r</tt> -- leaving the thread to run with a now deallocated
--   resource.
--   
--   It is <i>only</i> safe for threads to use a given registry, and/or its
--   registered resources, if the lifetime of those threads is tied to the
--   lifetime of the registry. There would be no problem with the example
--   above if the thread would be terminated when we exit the scope of
--   <a>withRegistry</a>.
--   
--   The <a>forkThread</a> combinator provided by the registry therefore
--   does two things: it allocates the thread as a resource in the
--   registry, so that it can kill the thread when releasing all resources
--   in the registry. It also records the thread ID in a set of known
--   threads. Whenever the registry is accessed from a thread <i>not</i> in
--   this set, the registry throws a runtime exception, since such a thread
--   might outlive the registry and hence its contents. The intention is
--   that this guards against dangerous patterns like the one above.
--   
--   <h1>Linking</h1>
--   
--   When thread A spawns thread B using <a>withAsync</a>, the lifetime of
--   B is tied to the lifetime of A:
--   
--   <pre>
--   withAsync .. $ \threadB -&gt; ..
--   </pre>
--   
--   After all, when A exits the scope of the <a>withAsync</a>, thread B
--   will be killed. The reverse is however not true: thread B can
--   terminate before thread A. It is often useful for thread A to be able
--   to declare a dependency on thread B: if B somehow fails, that is,
--   terminates with an exception, we want that exception to be rethrown in
--   thread A as well. A can achieve this by <i>linking</i> to B:
--   
--   <pre>
--   withAsync .. $ \threadB -&gt; do
--     link threadB
--     ..
--   </pre>
--   
--   Linking a parent to a child is however of limited value if the
--   lifetime of the child is not limited by the lifetime of the parent.
--   For example, if A does
--   
--   <pre>
--   threadB &lt;- async $ ..
--   link threadB
--   </pre>
--   
--   and A terminates before B does, any exception thrown by B might be
--   send to a thread that no longer exists. This is particularly
--   problematic when we start chaining threads: if A spawns-and-links-to B
--   which spawns-and-links-to C, and C throws an exception, perhaps the
--   intention is that this gets rethrown to B, and then rethrown to A,
--   terminating all three threads; however, if B has terminated before the
--   exception is thrown, C will throw the exception to a non-existent
--   thread and A is never notified.
--   
--   For this reason, the registry's <a>linkToRegistry</a> combinator does
--   not link the specified thread to the thread calling
--   <a>linkToRegistry</a>, but rather to the thread that created the
--   registry. After all, the lifetime of threads spawned with
--   <a>forkThread</a> can certainly exceed the lifetime of their parent
--   threads, but the lifetime of <i>all</i> threads spawned using the
--   registry will be limited by the scope of that registry, and hence the
--   lifetime of the thread that created it. So, when we call
--   <a>linkToRegistry</a>, the exception will be thrown the thread that
--   created the registry, which (if not caught) will cause that that to
--   exit the scope of <a>withRegistry</a>, thereby terminating all threads
--   in that registry.
--   
--   <h1>Combining the registry and with-style allocation</h1>
--   
--   It is perfectly possible (indeed, advisable) to use <a>bracket</a> and
--   bracket-like allocation functions alongside the registry, but note
--   that the usual caveats with <a>bracket</a> and forking threads still
--   applies. In particular, spawning threads inside the <a>bracket</a>
--   that make use of the bracketed resource is problematic; this is of
--   course true whether or not a registry is used.
--   
--   In principle this also includes <a>withAsync</a>; however, since
--   <a>withAsync</a> results in a thread that is not known to the
--   registry, such a thread will not be able to use the registry (the
--   registry would throw an unknown thread exception, as described above).
--   For this purpose we provide <a>withThread</a>; <a>withThread</a> (as
--   opposed to <a>forkThread</a>) should be used when a parent thread
--   wants to handle exceptions in the child thread; see <a>withThread</a>
--   for detailed discussion.
--   
--   It is <i>also</i> fine to includes nested calls to
--   <a>withRegistry</a>. Since the lifetime of such a registry (and all
--   resources within) is tied to the thread calling <a>withRegistry</a>,
--   which itself is tied to the "parent registry" in which it was created,
--   this creates a hierarchy of registries. It is of course essential for
--   compositionality that we should be able to create local registries,
--   but even if we do have easy access to a parent regisry, creating a
--   local one where possibly is useful as it limits the scope of the
--   resources created within, and hence their maximum lifetimes.
module Control.ResourceRegistry

-- | The internal context of a resource registry, recording a
--   <a>PrettyCallStack</a> of its creation and the creator's
--   <a>ThreadId</a>
data Context m

-- | Resource ID
--   
--   This uniquifying data is not exposed by the <a>ResourceRegistry</a>
--   interface.
data ResourceId

-- | Tracks resources during their lifetime.
data ResourceRegistry m

-- | Attempt to allocate a resource in a registry which is closed
--   
--   When calling <a>closeRegistry</a> (typically, leaving the scope of
--   <a>withRegistry</a>), all resources in the registry must be released.
--   If a concurrent thread is still allocating resources, we end up with a
--   race between the thread trying to allocate new resources and the
--   registry trying to free them all. To avoid this, before releasing
--   anything, the registry will record itself as closed. Any attempt by a
--   concurrent thread to allocate a new resource will then result in a
--   <a>RegistryClosedException</a>.
--   
--   It is probably not particularly useful for threads to try and catch
--   this exception (apart from in a generic handler that does local
--   resource cleanup). The thread will anyway soon receive a
--   <a>ThreadKilled</a> exception.
data RegistryClosedException
RegistryClosedException :: !Context m -> !PrettyCallStack -> !Context m -> RegistryClosedException

-- | The context in which the registry was created
[registryClosedRegistryContext] :: RegistryClosedException -> !Context m

-- | Callstack to the call to <a>closeRegistry</a>
--   
--   Note that <a>closeRegistry</a> can only be called from the same thread
--   that created the registry.
[registryClosedCloseCallStack] :: RegistryClosedException -> !PrettyCallStack

-- | Context of the call resulting in the exception
[registryClosedAllocContext] :: RegistryClosedException -> !Context m

-- | Registry used from untracked threads
--   
--   If this exception is raised, it indicates a bug in the caller.
data ResourceRegistryThreadException

-- | Create a new private registry for use by a bracketed resource
--   
--   Use this combinator as a more specific and easier-to-maintain
--   alternative to the following.
--   
--   <pre>
--   'withRegistry' $ \rr -&gt;
--     'bracket' (newFoo rr) closeFoo $ \foo -&gt;
--       (... rr does not occur in this scope ...)
--   </pre>
--   
--   NB The scoped body can use <a>withRegistry</a> if it also needs its
--   own, separate registry.
--   
--   Use this combinator to emphasize that the registry is private to (ie
--   only used by and/or via) the bracketed resource and that it thus has
--   nearly the same lifetime. This combinator ensures the following
--   specific invariants regarding lifetimes and order of releases.
--   
--   o The registry itself is older than the bracketed resource.
--   
--   o The only registered resources older than the bracketed resource were
--   allocated in the registry by the function that allocated the bracketed
--   resource.
--   
--   o Because of the older resources, the bracketed resource is itself
--   also registered in the registry; that's the only way we can be sure to
--   release all resources in the right order.
--   
--   NB Because the registry is private to the resource, the <tt>a</tt>
--   type could save the handle to <tt>registry</tt> and safely close the
--   registry if the scoped body calls <tt>closeA</tt> before the bracket
--   ends. Though we have not used the type system to guarantee that the
--   interface of the <tt>a</tt> type cannot leak the registry to the body,
--   this combinator does its part to keep the registry private to the
--   bracketed resource.
--   
--   See documentation of <a>ResourceRegistry</a> for a more general
--   discussion.
bracketWithPrivateRegistry :: (MonadSTM m, MonadMask m, MonadThread m, HasCallStack) => (ResourceRegistry m -> m a) -> (a -> m ()) -> (a -> m r) -> m r

-- | The thread that created the registry
registryThread :: ResourceRegistry m -> ThreadId m

-- | Create a new registry
--   
--   See documentation of <a>ResourceRegistry</a> for a detailed
--   discussion.
withRegistry :: (MonadSTM m, MonadMask m, MonadThread m, HasCallStack) => (ResourceRegistry m -> m a) -> m a

-- | Resource key
--   
--   Resource keys are tied to a particular registry.
data ResourceKey m

-- | Allocate new resource
--   
--   The allocation function will be run with asynchronous exceptions
--   masked. This means that the resource allocation must either be fast or
--   else interruptible; see "Dealing with Asynchronous Exceptions during
--   Resource Acquisition" <a>http://www.well-typed.com/blog/97/</a> for
--   details.
allocate :: forall m a. (MonadSTM m, MonadMask m, MonadThread m, HasCallStack) => ResourceRegistry m -> (ResourceId -> m a) -> (a -> m ()) -> m (ResourceKey m, a)

-- | Generalization of <a>allocate</a> for allocation functions that may
--   fail
allocateEither :: forall m e a. (MonadSTM m, MonadMask m, MonadThread m, HasCallStack) => ResourceRegistry m -> (ResourceId -> m (Either e a)) -> (a -> m Bool) -> m (Either e (ResourceKey m, a))

-- | Release resource
--   
--   This deallocates the resource and removes it from the registry. It
--   will be the responsibility of the caller to make sure that the
--   resource is no longer used in any thread.
--   
--   The deallocation function is run with exceptions masked, so that we
--   are guaranteed not to remove the resource from the registry without
--   releasing it.
--   
--   Releasing an already released resource is a no-op.
--   
--   When the resource has not been released before, its context is
--   returned.
release :: (MonadMask m, MonadSTM m, MonadThread m, HasCallStack) => ResourceKey m -> m (Maybe (Context m))

-- | Release all resources in the <a>ResourceRegistry</a> without closing.
--   
--   See <a>closeRegistry</a> for more details.
releaseAll :: (MonadMask m, MonadSTM m, MonadThread m, HasCallStack) => ResourceRegistry m -> m ()

-- | Unsafe version of <a>release</a>
--   
--   The only difference between <a>release</a> and <a>unsafeRelease</a> is
--   that the latter does not insist that it is called from a thread that
--   is known to the registry. This is dangerous, because it implies that
--   there is a thread with access to a resource which may be deallocated
--   before that thread is terminated. Of course, we can't detect all such
--   situations (when the thread merely uses a resource but does not
--   allocate or release we can't tell), but normally when we <i>do</i>
--   detect this we throw an exception.
--   
--   This function should only be used if the above situation can be ruled
--   out or handled by other means.
unsafeRelease :: (MonadMask m, MonadSTM m) => ResourceKey m -> m (Maybe (Context m))

-- | This is to <a>releaseAll</a> what <a>unsafeRelease</a> is to
--   <a>release</a>: we do not insist that this funciton is called from a
--   thread that is known to the registry. See <a>unsafeRelease</a> for why
--   this is dangerous.
unsafeReleaseAll :: (MonadMask m, MonadSTM m, MonadThread m, HasCallStack) => ResourceRegistry m -> m ()

-- | Thread
--   
--   The internals of this type are not exported.
data Thread m a

-- | Cancel a thread
--   
--   This is a synchronous operation: the thread will have terminated when
--   this function returns.
--   
--   Uses <a>uninterruptibleCancel</a> because that's what <a>withAsync</a>
--   does.
cancelThread :: MonadAsync m => Thread m a -> m ()

-- | Fork a thread and link to it to the registry.
--   
--   This function is just a convenience.
forkLinkedThread :: (MonadAsync m, MonadFork m, MonadMask m, HasCallStack) => ResourceRegistry m -> String -> m a -> m (Thread m a)

-- | Fork a new thread
forkThread :: forall m a. (MonadMask m, MonadAsync m, HasCallStack) => ResourceRegistry m -> String -> m a -> m (Thread m a)

-- | Link specified <a>Thread</a> to the (thread that created) the registry
linkToRegistry :: (MonadAsync m, MonadFork m, MonadMask m) => Thread m a -> m ()

-- | The underlying <tt>async</tt> thread id
threadId :: Thread m a -> ThreadId m

-- | Lift <a>waitAny</a> to <a>Thread</a>
waitAnyThread :: forall m a. MonadAsync m => [Thread m a] -> m a

-- | Wait for thread to terminate and return its result.
--   
--   If the thread throws an exception, this will rethrow that exception.
--   
--   NOTE: If A waits on B, and B is linked to the registry, and B throws
--   an exception, then A might <i>either</i> receive the exception thrown
--   by B <i>or</i> the <a>ThreadKilled</a> exception thrown by the
--   registry.
waitThread :: MonadAsync m => Thread m a -> m a

-- | Bracketed version of <a>forkThread</a>
--   
--   The analogue of <a>withAsync</a> for the registry.
--   
--   Scoping thread lifetime using <a>withThread</a> is important when a
--   parent thread wants to link to a child thread /and handle any
--   exceptions arising from the link/:
--   
--   <pre>
--   let handleLinkException :: ExceptionInLinkedThread -&gt; m ()
--       handleLinkException = ..
--   in handle handleLinkException $
--        withThread registry codeInChild $ \child -&gt;
--          ..
--   </pre>
--   
--   instead of
--   
--   <pre>
--   handle handleLinkException $ do  -- PROBABLY NOT CORRECT!
--     child &lt;- forkThread registry codeInChild
--     ..
--   </pre>
--   
--   where the parent may exit the scope of the exception handler before
--   the child terminates. If the lifetime of the child cannot be limited
--   to the lifetime of the parent, the child should probably be linked to
--   the registry instead and the thread that spawned the registry should
--   handle any exceptions.
--   
--   Note that in <i>principle</i> there is no problem in using
--   <a>withAsync</a> alongside a registry. After all, in a pattern like
--   
--   <pre>
--   withRegistry $ \registry -&gt;
--     ..
--     withAsync (.. registry ..) $ \async -&gt;
--       ..
--   </pre>
--   
--   the async will be cancelled when leaving the scope of <a>withAsync</a>
--   and so that reference to the registry, or indeed any of the resources
--   inside the registry, is safe. However, the registry implements a
--   sanity check that the registry is only used from known threads. This
--   is useful: when a thread that is not known to the registry (in other
--   words, whose lifetime is not tied to the lifetime of the registry)
--   spawns a resource in that registry, that resource may well be
--   deallocated before the thread terminates, leading to undefined and
--   hard to debug behaviour (indeed, whether or not this results in
--   problems may well depend on precise timing); an exception that is
--   thrown when <i>allocating</i> the resource is (more) deterministic and
--   easier to debug. Unfortunately, it means that the above pattern is not
--   applicable, as the thread spawned by <a>withAsync</a> is not known to
--   the registry, and so if it were to try to use the registry, the
--   registry would throw an error (even though this pattern is actually
--   safe). This situation is not ideal, but for now we merely provide an
--   alternative to <a>withAsync</a> that <i>does</i> register the thread
--   with the registry.
--   
--   NOTE: Threads that are spawned out of the user's control but that must
--   still make use of the registry can use the unsafe API. This should be
--   used with caution, however.
withThread :: (MonadMask m, MonadAsync m) => ResourceRegistry m -> String -> m a -> (Thread m a -> m b) -> m b

-- | When <a>runWithTempRegistry</a> exits successfully while there are
--   still resources remaining in the temporary registry that haven't been
--   transferred to the final state.
data TempRegistryException
TempRegistryRemainingResource :: !Context m -> !Context m -> TempRegistryException

-- | The context in which the temporary registry was created.
[tempRegistryContext] :: TempRegistryException -> !Context m

-- | The context in which the resource was allocated that was not
--   transferred to the final state.
[tempRegistryResource] :: TempRegistryException -> !Context m

-- | An action with a temporary registry in scope, see
--   <a>runWithTempRegistry</a> for more details.
--   
--   The most important function to run in this monad is
--   <a>allocateTemp</a>.
data WithTempRegistry st m a

-- | Allocate a resource in a temporary registry until it has been
--   transferred to the final state <tt>st</tt>. See
--   <a>runWithTempRegistry</a> for more details.
allocateTemp :: (MonadSTM m, MonadMask m, MonadThread m, HasCallStack) => m a -> (a -> m Bool) -> (st -> a -> Bool) -> WithTempRegistry st m a

-- | Higher level API on top of <a>runWithTempRegistry</a>: modify the
--   given <tt>st</tt>, allocating resources in the process that will be
--   transferred to the returned <tt>st</tt>.
modifyWithTempRegistry :: forall m st a. (MonadSTM m, MonadMask m, MonadThread m) => m st -> (st -> ExitCase st -> m ()) -> StateT st (WithTempRegistry st m) a -> m a

-- | Embed a self-contained <a>WithTempRegistry</a> computation into a
--   larger one.
--   
--   The internal <a>WithTempRegistry</a> is effectively passed to
--   <a>runWithTempRegistry</a>. It therefore must have no dangling
--   resources, for example. This is the meaning of <i>self-contained</i>
--   above.
--   
--   The key difference beyond <a>runWithTempRegistry</a> is that the
--   resulting composite resource is also guaranteed to be registered in
--   the outer <a>WithTempRegistry</a> computation's registry once the
--   inner registry is closed. Combined with the following assumption, this
--   establishes the invariant that all resources are (transitively) in a
--   temporary registry.
--   
--   As the resource might require some implementation details to be
--   closed, the function to close it will also be provided by the inner
--   computation.
--   
--   ASSUMPTION: closing <tt>res</tt> closes every resource contained in
--   <tt>innerSt</tt>
--   
--   NOTE: In the current implementation, there will be a brief moment
--   where the inner registry still contains the inner computation's
--   resources and also the outer registry simultaneously contains the new
--   composite resource. If an async exception is received at that time,
--   then the inner resources will be closed and then the composite
--   resource will be closed. This means there's a risk of <i>double
--   freeing</i>, which can be harmless if anticipated.
runInnerWithTempRegistry :: forall innerSt st m res a. (MonadSTM m, MonadMask m, MonadThread m) => WithTempRegistry innerSt m (a, innerSt, res) -> (res -> m Bool) -> (st -> res -> Bool) -> WithTempRegistry st m a

-- | Run an action with a temporary resource registry.
--   
--   When allocating resources that are meant to end up in some final
--   state, e.g., stored in a <a>TVar</a>, after which they are guaranteed
--   to be released correctly, it is possible that an exception is thrown
--   after allocating such a resource, but before it was stored in the
--   final state. In that case, the resource would be leaked.
--   <a>runWithTempRegistry</a> solves that problem.
--   
--   When no exception is thrown before the end of
--   <a>runWithTempRegistry</a>, the user must have transferred all the
--   resources it allocated to their final state. This means that these
--   resources don't have to be released by the temporary registry anymore,
--   the final state is now in charge of releasing them.
--   
--   In case an exception is thrown before the end of
--   <a>runWithTempRegistry</a>, <i>all</i> resources allocated in the
--   temporary registry will be released.
--   
--   Resources must be allocated using <a>allocateTemp</a>.
--   
--   To make sure that the user doesn't forget to transfer a resource to
--   the final state <tt>st</tt>, the user must pass a function to
--   <a>allocateTemp</a> that checks whether a given <tt>st</tt> contains
--   the resource, i.e., whether the resource was successfully transferred
--   to its final destination.
--   
--   When no exception is thrown before the end of
--   <a>runWithTempRegistry</a>, we check whether all allocated resources
--   have been transferred to the final state <tt>st</tt>. If there's a
--   resource that hasn't been transferred to the final state <i>and</i>
--   that hasn't be released or closed before (see the release function
--   passed to <a>allocateTemp</a>), a <a>TempRegistryRemainingResource</a>
--   exception will be thrown.
--   
--   For that reason, <a>WithTempRegistry</a> is parameterised over the
--   final state type <tt>st</tt> and the given <a>WithTempRegistry</a>
--   action must return the final state.
--   
--   NOTE: we explicitly don't let <a>runWithTempRegistry</a> return the
--   final state, because the state <i>must</i> have been stored somewhere
--   safely, transferring the resources, before the temporary registry is
--   closed.
runWithTempRegistry :: (MonadSTM m, MonadMask m, MonadThread m, HasCallStack) => WithTempRegistry st m (a, st) -> m a

-- | Close the registry
--   
--   This can only be called from the same thread that created the
--   registry. This is a no-op if the registry is already closed.
--   
--   This entire function runs with exceptions masked, so that we are not
--   interrupted while we release all resources.
--   
--   Resources will be allocated from young to old, so that resources
--   allocated later can safely refer to resources created earlier.
--   
--   The release functions are run in the scope of an exception handler, so
--   that if releasing one resource throws an exception, we still attempt
--   to release the other resources. Should we catch an exception whilst we
--   close the registry, we will rethrow it after having attempted to
--   release all resources. If there is more than one, we will pick a
--   random one to rethrow, though we will prioritize asynchronous
--   exceptions over other exceptions. This may be important for exception
--   handlers that catch all-except-asynchronous exceptions.
closeRegistry :: (MonadMask m, MonadThread m, MonadSTM m, HasCallStack) => ResourceRegistry m -> m ()

-- | Number of currently allocated resources
--   
--   Primarily for the benefit of testing.
countResources :: MonadSTM m => ResourceRegistry m -> m Int

-- | Create a new registry
--   
--   You are strongly encouraged to use <a>withRegistry</a> instead.
--   Exported primarily for the benefit of tests.
unsafeNewRegistry :: (MonadSTM m, MonadThread m, HasCallStack) => m (ResourceRegistry m)
instance NoThunks.Class.NoThunks Control.ResourceRegistry.Age
instance GHC.Classes.Ord Control.ResourceRegistry.Age
instance GHC.Classes.Eq Control.ResourceRegistry.Age
instance GHC.Show.Show Control.ResourceRegistry.Age
instance NoThunks.Class.NoThunks (Control.ResourceRegistry.KnownThreads m)
instance NoThunks.Class.NoThunks Control.ResourceRegistry.ResourceId
instance GHC.Enum.Enum Control.ResourceRegistry.ResourceId
instance GHC.Classes.Ord Control.ResourceRegistry.ResourceId
instance GHC.Classes.Eq Control.ResourceRegistry.ResourceId
instance GHC.Show.Show Control.ResourceRegistry.ResourceId
instance NoThunks.Class.NoThunks (Control.ResourceRegistry.Release m)
instance NoThunks.Class.NoThunks (Control.ResourceRegistry.TransferredTo st)
instance GHC.Base.Monoid (Control.ResourceRegistry.TransferredTo st)
instance GHC.Base.Semigroup (Control.ResourceRegistry.TransferredTo st)
instance NoThunks.Class.NoThunks Control.ResourceRegistry.PrettyCallStack
instance NoThunks.Class.NoThunks (Control.ResourceRegistry.Resource m)
instance GHC.Generics.Generic (Control.ResourceRegistry.Resource m)
instance NoThunks.Class.NoThunks Control.ResourceRegistry.RegistryStatus
instance GHC.Generics.Generic Control.ResourceRegistry.RegistryStatus
instance NoThunks.Class.NoThunks (Control.ResourceRegistry.RegistryState m)
instance GHC.Generics.Generic (Control.ResourceRegistry.RegistryState m)
instance GHC.Generics.Generic (Control.ResourceRegistry.ResourceRegistry m)
instance NoThunks.Class.NoThunks (Control.ResourceRegistry.Thread m a)
instance Control.Monad.Class.MonadThrow.MonadMask m => Control.Monad.Class.MonadThrow.MonadMask (Control.ResourceRegistry.WithTempRegistry st m)
instance Control.Monad.Class.MonadThrow.MonadCatch m => Control.Monad.Class.MonadThrow.MonadCatch (Control.ResourceRegistry.WithTempRegistry st m)
instance Control.Monad.Class.MonadThrow.MonadThrow m => Control.Monad.Class.MonadThrow.MonadThrow (Control.ResourceRegistry.WithTempRegistry st m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.ResourceRegistry.WithTempRegistry st m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.ResourceRegistry.WithTempRegistry st m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.ResourceRegistry.WithTempRegistry st m)
instance GHC.Generics.Generic (Control.ResourceRegistry.ResourceKey m)
instance (forall a. NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Control.Concurrent.Class.MonadSTM.Strict.TVar.StrictTVar m a)) => NoThunks.Class.NoThunks (Control.ResourceRegistry.ResourceRegistry m)
instance NoThunks.Class.NoThunks (Control.ResourceRegistry.ResourceRegistry m) => NoThunks.Class.NoThunks (Control.ResourceRegistry.ResourceKey m)
instance GHC.Show.Show Control.ResourceRegistry.RegistryClosedException
instance GHC.Show.Show Control.ResourceRegistry.TempRegistryException
instance GHC.Show.Show Control.ResourceRegistry.ResourceRegistryThreadException
instance GHC.Show.Show (Control.ResourceRegistry.Context m)
instance Control.Monad.Trans.Class.MonadTrans (Control.ResourceRegistry.WithTempRegistry st)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.ResourceRegistry.WithTempRegistry st m)
instance Control.Monad.Class.MonadFork.MonadThread m => GHC.Classes.Eq (Control.ResourceRegistry.Thread m a)
instance GHC.Exception.Type.Exception Control.ResourceRegistry.RegistryClosedException
instance GHC.Exception.Type.Exception Control.ResourceRegistry.TempRegistryException
instance GHC.Exception.Type.Exception Control.ResourceRegistry.ResourceRegistryThreadException
instance NoThunks.Class.NoThunks (Control.ResourceRegistry.Context m)
instance GHC.Show.Show Control.ResourceRegistry.PrettyCallStack
instance GHC.Show.Show (Control.ResourceRegistry.Release m)
instance (NoThunks.Class.NoThunks k, NoThunks.Class.NoThunks v) => NoThunks.Class.NoThunks (Data.Bimap.Bimap k v)
