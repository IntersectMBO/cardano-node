-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The GHC API
--   
--   GHC's functionality can be useful for more things than just compiling
--   Haskell programs. Important use cases are programs that analyse (and
--   perhaps transform) Haskell code. Others include loading Haskell code
--   dynamically in a GHCi-like manner. For this reason, a lot of GHC's
--   functionality is made available through this package.
--   
--   See
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler</a>
--   for more information.
@package ghc
@version 9.6.7

module GHC.Data.List.Infinite
data Infinite a
Inf :: a -> Infinite a -> Infinite a
head :: Infinite a -> a
tail :: Infinite a -> Infinite a
filter :: (a -> Bool) -> Infinite a -> Infinite a
(++) :: Foldable f => f a -> Infinite a -> Infinite a
infixr 5 ++
unfoldr :: (b -> (a, b)) -> b -> Infinite a
(!!) :: Infinite a -> Int -> a
groupBy :: (a -> a -> Bool) -> Infinite a -> Infinite (NonEmpty a)
dropList :: [a] -> Infinite b -> Infinite b
iterate :: (a -> a) -> a -> Infinite a
concatMap :: Foldable f => (a -> f b) -> Infinite a -> Infinite b

-- | Compute all lists of the given alphabet. For example:
--   <tt><a>allListsOf</a> "ab" = ["a", "b", "aa", "ba", "ab", "bb", "aaa",
--   "baa", "aba", ...]</tt>
allListsOf :: [a] -> Infinite [a]
toList :: Infinite a -> [a]
repeat :: a -> Infinite a
instance Data.Traversable.Traversable GHC.Data.List.Infinite.Infinite
instance GHC.Base.Functor GHC.Data.List.Infinite.Infinite
instance Data.Foldable.Foldable GHC.Data.List.Infinite.Infinite
instance GHC.Base.Applicative GHC.Data.List.Infinite.Infinite

module GHC.Platform.Constants
data PlatformConstants
PlatformConstants :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !Integer -> !Integer -> !Integer -> !Bool -> PlatformConstants
[pc_CONTROL_GROUP_CONST_291] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_STD_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_PROF_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCK_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCKS_PER_MBLOCK] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TICKY_BIN_COUNT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR7] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR8] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR9] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR10] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rL1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCCCS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentTSO] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentNursery] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpAlloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgEagerBlackholeInfo] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCEnter1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCFun] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_Capability_r] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_start] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_free] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_blocks] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_flags] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_CostCentreStack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ldvw] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSMPThunkHeader] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_registeredp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_link] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_entry_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgUpdateFrame_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_size] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSmallMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgSmallMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgArrBytes_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgArrBytes_bytes] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_alloc_limit] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_cccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_stackobj] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_sp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_stack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgUpdateFrame_updatee] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgFunInfoExtraRev] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_SELECTEE_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_AP_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_PAYLOAD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MUT_ARR_PTRS_CARD_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_C_STACK_BYTES] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_STACK_WORDS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_AP_STACK_SPLIM] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_WORD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CINT_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_LONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BITMAP_BITS_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TAG_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_LDV_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_ILDV_CREATE_MASK] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_CREATE] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_USE] :: PlatformConstants -> !Integer
[pc_USE_INLINE_SRT_FIELD] :: PlatformConstants -> !Bool
parseConstantsHeader :: FilePath -> IO PlatformConstants
instance GHC.Classes.Ord GHC.Platform.Constants.PlatformConstants
instance GHC.Classes.Eq GHC.Platform.Constants.PlatformConstants
instance GHC.Read.Read GHC.Platform.Constants.PlatformConstants
instance GHC.Show.Show GHC.Platform.Constants.PlatformConstants


-- | Custom minimal GHC <a>Prelude</a>
--   
--   This module serves as a replacement for the <a>Prelude</a> module and
--   abstracts over differences between the bootstrapping GHC version, and
--   may also provide a common default vocabulary.
module GHC.Prelude.Basic
data () => Int
data () => Float
data () => Char
data () => IO a
data () => Bool
False :: Bool
True :: Bool
data () => Double
data () => Word
data () => Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data () => Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
class a ~# b => (a :: k) ~ (b :: k)
data () => Integer

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data () => Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
--   
--   In addition, <a>toInteger</a> should be total, and <a>fromInteger</a>
--   should be a left inverse for it, i.e. <tt>fromInteger (toInteger i) =
--   i</tt>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | <a>String</a> is an alias for a list of characters.
--   
--   String constants in Haskell are values of type <a>String</a>. That
--   means if you write a string literal like <tt>"hello world"</tt>, it
--   will have the type <tt>[Char]</tt>, which is the same as
--   <tt>String</tt>.
--   
--   <b>Note:</b> You can ask the compiler to automatically infer different
--   types with the <tt>-XOverloadedStrings</tt> language extension, for
--   example <tt>"hello world" :: Text</tt>. See <a>IsString</a> for more
--   information.
--   
--   Because <tt>String</tt> is just a list of characters, you can use
--   normal list functions to do basic string manipulation. See
--   <a>Data.List</a> for operations on lists.
--   
--   <h3><b>Performance considerations</b></h3>
--   
--   <tt>[Char]</tt> is a relatively memory-inefficient type. It is a
--   linked list of boxed word-size characters, internally it looks
--   something like:
--   
--   <pre>
--   ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭────╮
--   │ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ [] │
--   ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰────╯
--           v               v               v
--          'a'             'b'             'c'
--   </pre>
--   
--   The <tt>String</tt> "abc" will use <tt>5*3+1 = 16</tt> (in general
--   <tt>5n+1</tt>) words of space in memory.
--   
--   Furthermore, operations like <a>(++)</a> (string concatenation) are
--   <tt>O(n)</tt> (in the left argument).
--   
--   For historical reasons, the <tt>base</tt> library uses <tt>String</tt>
--   in a lot of places for the conceptual simplicity, but library code
--   dealing with user-data should use the <a>text</a> package for Unicode
--   text, or the the <a>bytestring</a> package for binary data.
type String = [Char]

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class () => Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class () => Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class () => Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class () => Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]
class () => Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   <li><i><b>Totality of <a>toRational</a></b></i> <a>toRational</a> is
--   total</li>
--   <li><i><b>Coherence with <a>toRational</a></b></i> if the type also
--   implements <a>Real</a>, then <a>fromRational</a> is a left inverse for
--   <a>toRational</a>, i.e. <tt>fromRational (toRational i) = i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   <li><i><b>Coherence with <tt>toInteger</tt></b></i> if the type also
--   implements <a>Integral</a>, then <a>fromInteger</a> is a left inverse
--   for <a>toInteger</a>, i.e. <tt>fromInteger (toInteger i) ==
--   i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class () => Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 -
infixl 6 +
infixl 7 *
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a

-- | Real numbers.
--   
--   The Haskell report defines no laws for <a>Real</a>, however
--   <a>Real</a> instances are customarily expected to adhere to the
--   following law:
--   
--   <ul>
--   <li><i><b>Coherence with <a>fromRational</a></b></i> if the type also
--   implements <a>Fractional</a>, then <a>fromRational</a> is a left
--   inverse for <a>toRational</a>, i.e. <tt>fromRational (toRational i) =
--   i</tt></li>
--   </ul>
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class () => Foldable (t :: Type -> Type)

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <i>O(n)</i> elements
--   long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class () => Semigroup a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
even :: Integral a => a -> Bool

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is representation-polymorphic in its
--   result type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool
--   -&gt; Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching,
--   <a>uncons</a> or <a>listToMaybe</a> instead.
head :: HasCallStack => [a] -> a

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: HasCallStack => [a] -> [a]

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   WARNING: This function takes linear time in the number of elements of
--   the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | General coercion from <a>Integral</a> types.
--   
--   WARNING: This function performs silent truncation if the result type
--   is not at least as big as the argument's type.
fromIntegral :: (Integral a, Num b) => a -> b

-- | General coercion to <a>Fractional</a> types.
--   
--   WARNING: This function goes through the <a>Rational</a> type, which
--   does not have values for <tt>NaN</tt> for example. This means it does
--   not round-trip.
--   
--   For <a>Double</a> it also behaves differently with or without -O0:
--   
--   <pre>
--   Prelude&gt; realToFrac nan -- With -O0
--   -Infinity
--   Prelude&gt; realToFrac nan
--   NaN
--   </pre>
realToFrac :: (Real a, Fractional b) => a -> b

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
(&&) :: Bool -> Bool -> Bool
(||) :: Bool -> Bool -> Bool
not :: Bool -> Bool

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep) (a :: TYPE r). [Char] -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | <tt>const x y</tt> always evaluates to <tt>x</tt>, ignoring its second
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching or
--   <a>uncons</a> instead.
tail :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching, <a>uncons</a> or <a>listToMaybe</a> instead.
last :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching or <a>uncons</a> instead.
init :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>atMay</a> instead.
(!!) :: HasCallStack => [a] -> Int -> a
infixl 9 !!

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS
odd :: Integral a => a -> Bool

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
lines :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
unwords :: [String] -> String

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <tt>fail</tt> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | The <a>FiniteBits</a> class denotes types with a finite, fixed number
--   of bits.
class Bits b => FiniteBits b

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Moreover, <a>finiteBitSize</a> is
--   total, in contrast to the deprecated <a>bitSize</a> function it
--   replaces.
--   
--   <pre>
--   <a>finiteBitSize</a> = <a>bitSize</a>
--   <a>bitSizeMaybe</a> = <a>Just</a> . <a>finiteBitSize</a>
--   </pre>
finiteBitSize :: FiniteBits b => b -> Int

-- | Count number of zero bits preceding the most significant set bit.
--   
--   <pre>
--   <a>countLeadingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   </pre>
--   
--   <a>countLeadingZeros</a> can be used to compute log base 2 via
--   
--   <pre>
--   logBase2 x = <a>finiteBitSize</a> x - 1 - <a>countLeadingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countLeadingZeros :: FiniteBits b => b -> Int

-- | Count number of zero bits following the least significant set bit.
--   
--   <pre>
--   <a>countTrailingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   <a>countTrailingZeros</a> . <a>negate</a> = <a>countTrailingZeros</a>
--   </pre>
--   
--   The related <a>find-first-set operation</a> can be expressed in terms
--   of <a>countTrailingZeros</a> as follows
--   
--   <pre>
--   findFirstSet x = 1 + <a>countTrailingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countTrailingZeros :: FiniteBits b => b -> Int

-- | The <a>Bits</a> class defines bitwise operations over integral types.
--   
--   <ul>
--   <li>Bits are numbered from 0 with bit 0 being the least significant
--   bit.</li>
--   </ul>
class Eq a => Bits a

-- | Bitwise "and"
(.&.) :: Bits a => a -> a -> a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a

-- | Reverse all the bits in the argument
complement :: Bits a => a -> a

-- | <tt><a>shift</a> x i</tt> shifts <tt>x</tt> left by <tt>i</tt> bits if
--   <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise. Right
--   shifts perform sign extension on signed number types; i.e. they fill
--   the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this unified <a>shift</a> or
--   <a>shiftL</a> and <a>shiftR</a>, depending on which is more convenient
--   for the type in question.
shift :: Bits a => a -> Int -> a

-- | <tt><a>rotate</a> x i</tt> rotates <tt>x</tt> left by <tt>i</tt> bits
--   if <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise.
--   
--   For unbounded types like <a>Integer</a>, <a>rotate</a> is equivalent
--   to <a>shift</a>.
--   
--   An instance can define either this unified <a>rotate</a> or
--   <a>rotateL</a> and <a>rotateR</a>, depending on which is more
--   convenient for the type in question.
rotate :: Bits a => a -> Int -> a

-- | <a>zeroBits</a> is the value with all bits unset.
--   
--   The following laws ought to hold (for all valid bit indices
--   <tt><i>n</i></tt>):
--   
--   <ul>
--   <li><pre><a>clearBit</a> <a>zeroBits</a> <i>n</i> ==
--   <a>zeroBits</a></pre></li>
--   <li><pre><a>setBit</a> <a>zeroBits</a> <i>n</i> == <a>bit</a>
--   <i>n</i></pre></li>
--   <li><pre><a>testBit</a> <a>zeroBits</a> <i>n</i> == False</pre></li>
--   <li><pre><a>popCount</a> <a>zeroBits</a> == 0</pre></li>
--   </ul>
--   
--   This method uses <tt><a>clearBit</a> (<a>bit</a> 0) 0</tt> as its
--   default implementation (which ought to be equivalent to
--   <a>zeroBits</a> for types which possess a 0th bit).
zeroBits :: Bits a => a

-- | <tt>bit <i>i</i></tt> is a value with the <tt><i>i</i></tt>th bit set
--   and all other bits clear.
--   
--   Can be implemented using <a>bitDefault</a> if <tt>a</tt> is also an
--   instance of <a>Num</a>.
--   
--   See also <a>zeroBits</a>.
bit :: Bits a => Int -> a

-- | <tt>x `setBit` i</tt> is the same as <tt>x .|. bit i</tt>
setBit :: Bits a => a -> Int -> a

-- | <tt>x `clearBit` i</tt> is the same as <tt>x .&amp;. complement (bit
--   i)</tt>
clearBit :: Bits a => a -> Int -> a

-- | <tt>x `complementBit` i</tt> is the same as <tt>x `xor` bit i</tt>
complementBit :: Bits a => a -> Int -> a

-- | <tt>x `testBit` i</tt> is the same as <tt>x .&amp;. bit n /= 0</tt>
--   
--   In other words it returns True if the bit at offset @n is set.
--   
--   Can be implemented using <a>testBitDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
testBit :: Bits a => a -> Int -> Bool

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Returns Nothing for types that do
--   not have a fixed bitsize, like <a>Integer</a>.
bitSizeMaybe :: Bits a => a -> Maybe Int

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. The function <a>bitSize</a> is
--   undefined for types that do not have a fixed bitsize, like
--   <a>Integer</a>.
--   
--   Default implementation based upon <a>bitSizeMaybe</a> provided since
--   4.12.0.0.
bitSize :: Bits a => a -> Int

-- | Return <a>True</a> if the argument is a signed type. The actual value
--   of the argument is ignored
isSigned :: Bits a => a -> Bool

-- | Shift the argument left by the specified number of bits. The result is
--   undefined for negative shift amounts and shift amounts greater or
--   equal to the <a>bitSize</a>.
--   
--   Defaults to <a>shiftL</a> unless defined explicitly by an instance.
unsafeShiftL :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits, which
--   must be non-negative and smaller than the number of bits in the type.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   Defaults to <a>shiftR</a> unless defined explicitly by an instance.
unsafeShiftR :: Bits a => a -> Int -> a

-- | Rotate the argument left by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateR</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateL :: Bits a => a -> Int -> a

-- | Rotate the argument right by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateL</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateR :: Bits a => a -> Int -> a

-- | Return the number of set bits in the argument. This number is known as
--   the population count or the Hamming weight.
--   
--   Can be implemented using <a>popCountDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
popCount :: Bits a => a -> Int
infixl 7 .&.
infixl 5 .|.
infixl 6 `xor`
infixl 8 `shift`
infixl 8 `rotate`
infixl 8 `rotateL`
infixl 8 `rotateR`

-- | Default implementation for <a>bit</a>.
--   
--   Note that: <tt>bitDefault i = 1 <a>shiftL</a> i</tt>
bitDefault :: (Bits a, Num a) => Int -> a

-- | Default implementation for <a>testBit</a>.
--   
--   Note that: <tt>testBitDefault x i = (x .&amp;. bit i) /= 0</tt>
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool

-- | Default implementation for <a>popCount</a>.
--   
--   This implementation is intentionally naive. Instances are expected to
--   provide an optimized implementation for their size.
popCountDefault :: (Bits a, Num a) => a -> Int

-- | Attempt to convert an <a>Integral</a> type <tt>a</tt> to an
--   <a>Integral</a> type <tt>b</tt> using the size of the types as
--   measured by <a>Bits</a> methods.
--   
--   A simpler version of this function is:
--   
--   <pre>
--   toIntegral :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   toIntegral x
--     | toInteger x == toInteger y = Just y
--     | otherwise                  = Nothing
--     where
--       y = fromIntegral x
--   </pre>
--   
--   This version requires going through <a>Integer</a>, which can be
--   inefficient. However, <tt>toIntegralSized</tt> is optimized to allow
--   GHC to statically determine the relative type sizes (as measured by
--   <a>bitSizeMaybe</a> and <a>isSigned</a>) and avoid going through
--   <a>Integer</a> for many types. (The implementation uses
--   <a>fromIntegral</a>, which is itself optimized with rules for
--   <tt>base</tt> types but may go through <a>Integer</a> for some type
--   pairs.)
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b
shiftL :: Bits a => a -> Int -> a
shiftR :: Bits a => a -> Int -> a

module GHC.Data.FastMutInt
data FastMutInt
newFastMutInt :: Int -> IO FastMutInt
readFastMutInt :: FastMutInt -> IO Int
writeFastMutInt :: FastMutInt -> Int -> IO ()
atomicFetchAddFastMut :: FastMutInt -> Int -> IO Int

module GHC.Data.Bool
data OverridingBool
Auto :: OverridingBool
Never :: OverridingBool
Always :: OverridingBool
overrideWith :: Bool -> OverridingBool -> Bool
instance GHC.Enum.Bounded GHC.Data.Bool.OverridingBool
instance GHC.Enum.Enum GHC.Data.Bool.OverridingBool
instance GHC.Classes.Ord GHC.Data.Bool.OverridingBool
instance GHC.Classes.Eq GHC.Data.Bool.OverridingBool
instance GHC.Read.Read GHC.Data.Bool.OverridingBool
instance GHC.Show.Show GHC.Data.Bool.OverridingBool

module GHC.Settings.Config
cBuildPlatformString :: String
cHostPlatformString :: String
cProjectName :: String
cBooterVersion :: String
cStage :: String

module GHC.Utils.Constants
debugIsOn :: Bool
ghciSupported :: Bool
isWindowsHost :: Bool
isDarwinHost :: Bool


module GHC.Utils.Containers.Internal.BitUtil
bitcount :: Int -> Word64 -> Int

-- | Return a word where only the highest bit is set.
highestBitMask :: Word64 -> Word64
shiftLL :: Word64 -> Int -> Word64
shiftRL :: Word64 -> Int -> Word64


-- | A strict pair
module GHC.Utils.Containers.Internal.StrictPair

-- | The same as a regular Haskell pair, but
--   
--   <pre>
--   (x :*: _|_) = (_|_ :*: y) = _|_
--   </pre>
data StrictPair a b
(:*:) :: !a -> !b -> StrictPair a b
infixr 1 :*:

-- | Convert a strict pair to a standard pair.
toPair :: StrictPair a b -> (a, b)


-- | <h1>WARNING</h1>
--   
--   This module is considered <b>internal</b>.
--   
--   The Package Versioning Policy <b>does not apply</b>.
--   
--   The contents of this module may change <b>in any way whatsoever</b>
--   and <b>without any warning</b> between minor versions of this package.
--   
--   Authors importing this module are expected to track development
--   closely.
--   
--   <h1>Description</h1>
--   
--   An efficient implementation of integer sets.
--   
--   These modules are intended to be imported qualified, to avoid name
--   clashes with Prelude functions, e.g.
--   
--   <pre>
--   import Data.Word64Set (Word64Set)
--   import qualified Data.Word64Set as Word64Set
--   </pre>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. However, my benchmarks show that
--   it is also (much) faster on insertions and deletions when compared to
--   a generic size-balanced set implementation (see <a>Data.Set</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
--   
--   Additionally, this implementation places bitmaps in the leaves of the
--   tree. Their size is the natural size of a machine word (32 or 64 bits)
--   and greatly reduce memory footprint and execution times for dense
--   sets, e.g. sets where it is likely that many values lie close to each
--   other. The asymptotics are not affected by this optimization.
--   
--   Many operations have a worst-case complexity of &lt;math&gt;. This
--   means that the operation can become linear in the number of elements
--   with a maximum of &lt;math&gt; -- the number of bits in an <a>Int</a>
--   (32 or 64).
module GHC.Data.Word64Set.Internal

-- | A set of integers.
data Word64Set
Bin :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !Mask -> !Word64Set -> !Word64Set -> Word64Set
Tip :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !BitMap -> Word64Set
Nil :: Word64Set
type Key = Word64
type Prefix = Word64
type Mask = Word64
type BitMap = Word64

-- | &lt;math&gt;. See <a>difference</a>.
(\\) :: Word64Set -> Word64Set -> Word64Set
infixl 9 \\

-- | &lt;math&gt;. Is the set empty?
null :: Word64Set -> Bool

-- | &lt;math&gt;. Cardinality of the set.
size :: Word64Set -> Int

-- | &lt;math&gt;. Is the value a member of the set?
member :: Key -> Word64Set -> Bool

-- | &lt;math&gt;. Is the element not in the set?
notMember :: Key -> Word64Set -> Bool

-- | &lt;math&gt;. Find largest element smaller than the given one.
--   
--   <pre>
--   lookupLT 3 (fromList [3, 5]) == Nothing
--   lookupLT 5 (fromList [3, 5]) == Just 3
--   </pre>
lookupLT :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find smallest element greater than the given one.
--   
--   <pre>
--   lookupGT 4 (fromList [3, 5]) == Just 5
--   lookupGT 5 (fromList [3, 5]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find largest element smaller or equal to the given one.
--   
--   <pre>
--   lookupLE 2 (fromList [3, 5]) == Nothing
--   lookupLE 4 (fromList [3, 5]) == Just 3
--   lookupLE 5 (fromList [3, 5]) == Just 5
--   </pre>
lookupLE :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find smallest element greater or equal to the given one.
--   
--   <pre>
--   lookupGE 3 (fromList [3, 5]) == Just 3
--   lookupGE 4 (fromList [3, 5]) == Just 5
--   lookupGE 6 (fromList [3, 5]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Is this a subset? <tt>(s1 `isSubsetOf` s2)</tt> tells
--   whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. Check whether two sets are disjoint (i.e. their
--   intersection is empty).
--   
--   <pre>
--   disjoint (fromList [2,4,6])   (fromList [1,3])     == True
--   disjoint (fromList [2,4,6,8]) (fromList [2,3,5,7]) == False
--   disjoint (fromList [1,2])     (fromList [1,2,3,4]) == False
--   disjoint (fromList [])        (fromList [])        == True
--   </pre>
disjoint :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. The empty set.
empty :: Word64Set

-- | &lt;math&gt;. A set of one element.
singleton :: Key -> Word64Set

-- | &lt;math&gt;. Add a value to the set. There is no left- or right bias
--   for Word64Sets.
insert :: Key -> Word64Set -> Word64Set

-- | &lt;math&gt;. Delete a value in the set. Returns the original set when
--   the value was not present.
delete :: Key -> Word64Set -> Word64Set

-- | &lt;math&gt;. <tt>(<a>alterF</a> f x s)</tt> can delete or insert
--   <tt>x</tt> in <tt>s</tt> depending on whether it is already present in
--   <tt>s</tt>.
--   
--   In short:
--   
--   <pre>
--   <a>member</a> x &lt;$&gt; <a>alterF</a> f x s = f (<a>member</a> x s)
--   </pre>
--   
--   Note: <a>alterF</a> is a variant of the <tt>at</tt> combinator from
--   <a>Control.Lens.At</a>.
alterF :: Functor f => (Bool -> f Bool) -> Key -> Word64Set -> f Word64Set

-- | &lt;math&gt;. The union of two sets.
union :: Word64Set -> Word64Set -> Word64Set

-- | The union of a list of sets.
unions :: Foldable f => f Word64Set -> Word64Set

-- | &lt;math&gt;. Difference between two sets.
difference :: Word64Set -> Word64Set -> Word64Set

-- | &lt;math&gt;. The intersection of two sets.
intersection :: Word64Set -> Word64Set -> Word64Set

-- | &lt;math&gt;. Filter all elements that satisfy some predicate.
filter :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. partition the set according to some predicate.
partition :: (Key -> Bool) -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. Take while a predicate on the elements holds. The user
--   is responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> p . <a>toList</a>
--   takeWhileAntitone p = <a>filter</a> p
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Drop while a predicate on the elements holds. The user
--   is responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> p . <a>toList</a>
--   dropWhileAntitone p = <a>filter</a> (not . p)
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Divide a set at the point where a predicate on the
--   elements stops holding. The user is responsible for ensuring that for
--   all <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partition</a> p xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the set at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. The expression (<tt><a>split</a> x set</tt>) is a pair
--   <tt>(set1,set2)</tt> where <tt>set1</tt> comprises the elements of
--   <tt>set</tt> less than <tt>x</tt> and <tt>set2</tt> comprises the
--   elements of <tt>set</tt> greater than <tt>x</tt>.
--   
--   <pre>
--   split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])
--   </pre>
split :: Key -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot element was found in the original set.
splitMember :: Key -> Word64Set -> (Word64Set, Bool, Word64Set)

-- | &lt;math&gt;. Decompose a set into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a set in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList [1..120]) == [fromList [1..63],fromList [64..120]]
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   subsets, but you should not depend on this behaviour because it can
--   change in the future without notice. Also, the current version does
--   not continue splitting all the way to individual singleton sets -- it
--   stops at some point.
splitRoot :: Word64Set -> [Word64Set]

-- | &lt;math&gt;. <tt><a>map</a> f s</tt> is the set obtained by applying
--   <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (Key -> Key) -> Word64Set -> Word64Set

-- | &lt;math&gt;. The
--   
--   <tt><a>mapMonotonic</a> f s == <a>map</a> f s</tt>, but works only
--   when <tt>f</tt> is strictly increasing. <i>The precondition is not
--   checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapMonotonic f s == map f s
--       where ls = toList s
--   </pre>
mapMonotonic :: (Key -> Key) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Fold the elements in the set using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toAscList set = foldr (:) [] set
--   </pre>
foldr :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. Fold the elements in the set using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toDescList set = foldl (flip (:)) [] set
--   </pre>
foldl :: (a -> Key -> a) -> a -> Word64Set -> a

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> Key -> a) -> a -> Word64Set -> a

-- | &lt;math&gt;. Fold the elements in the set using the given
--   right-associative binary operator. This function is an equivalent of
--   <a>foldr</a> and is present for compatibility only.
--   
--   <i>Please note that fold will be deprecated in the future and
--   removed.</i>
fold :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. The minimal element of the set.
findMin :: Word64Set -> Key

-- | &lt;math&gt;. The maximal element of a set.
findMax :: Word64Set -> Key

-- | &lt;math&gt;. Delete the minimal element. Returns an empty set if the
--   set is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Set</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Set</a> was already empty.
deleteMin :: Word64Set -> Word64Set

-- | &lt;math&gt;. Delete the maximal element. Returns an empty set if the
--   set is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Set</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Set</a> was already empty.
deleteMax :: Word64Set -> Word64Set

-- | &lt;math&gt;. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin set = (findMin set, deleteMin set)
--   </pre>
deleteFindMin :: Word64Set -> (Key, Word64Set)

-- | &lt;math&gt;. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax set = (findMax set, deleteMax set)
--   </pre>
deleteFindMax :: Word64Set -> (Key, Word64Set)

-- | &lt;math&gt;. Retrieves the maximal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
maxView :: Word64Set -> Maybe (Key, Word64Set)

-- | &lt;math&gt;. Retrieves the minimal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
minView :: Word64Set -> Maybe (Key, Word64Set)

-- | &lt;math&gt;. An alias of <a>toAscList</a>. The elements of a set in
--   ascending order. Subject to list fusion.
elems :: Word64Set -> [Key]

-- | &lt;math&gt;. Convert the set to a list of elements. Subject to list
--   fusion.
toList :: Word64Set -> [Key]

-- | &lt;math&gt;. Create a set from a list of integers.
fromList :: [Key] -> Word64Set

-- | &lt;math&gt;. Convert the set to an ascending list of elements.
--   Subject to list fusion.
toAscList :: Word64Set -> [Key]

-- | &lt;math&gt;. Convert the set to a descending list of elements.
--   Subject to list fusion.
toDescList :: Word64Set -> [Key]

-- | &lt;math&gt;. Build a set from an ascending list of elements. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromAscList :: [Key] -> Word64Set

-- | &lt;math&gt;. Build a set from an ascending list of distinct elements.
--   <i>The precondition (input list is strictly ascending) is not
--   checked.</i>
fromDistinctAscList :: [Key] -> Word64Set

-- | &lt;math&gt;. Show the tree that implements the set. The tree is shown
--   in a compressed, hanging format.
showTree :: Word64Set -> String

-- | &lt;math&gt;. The expression (<tt><a>showTreeWith</a> hang wide
--   map</tt>) shows the tree that implements the set. If <tt>hang</tt> is
--   <a>True</a>, a <i>hanging</i> tree is shown otherwise a rotated tree
--   is shown. If <tt>wide</tt> is <a>True</a>, an extra wide version is
--   shown.
showTreeWith :: Bool -> Bool -> Word64Set -> String
match :: Word64 -> Prefix -> Mask -> Bool
suffixBitMask :: Word64
prefixBitMask :: Word64
bitmapOf :: Word64 -> BitMap
zero :: Word64 -> Mask -> Bool
instance GHC.IsList.IsList GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Base.Monoid GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Base.Semigroup GHC.Data.Word64Set.Internal.Word64Set
instance Data.Data.Data GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Classes.Eq GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Classes.Ord GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Show.Show GHC.Data.Word64Set.Internal.Word64Set
instance GHC.Read.Read GHC.Data.Word64Set.Internal.Word64Set
instance Control.DeepSeq.NFData GHC.Data.Word64Set.Internal.Word64Set


-- | <h1>Finite Int Sets</h1>
--   
--   The <tt><a>Word64Set</a></tt> type represents a set of elements of
--   type <tt>Int</tt>.
--   
--   For a walkthrough of the most commonly used functions see their
--   <a>sets introduction</a>.
--   
--   These modules are intended to be imported qualified, to avoid name
--   clashes with Prelude functions, e.g.
--   
--   <pre>
--   import Data.Word64Set (Word64Set)
--   import qualified Data.Word64Set as Word64Set
--   </pre>
--   
--   <h2>Performance information</h2>
--   
--   Many operations have a worst-case complexity of &lt;math&gt;. This
--   means that the operation can become linear in the number of elements
--   with a maximum of &lt;math&gt; -- the number of bits in an
--   <tt>Int</tt> (32 or 64).
--   
--   <h2>Implementation</h2>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. However, my benchmarks show that
--   it is also (much) faster on insertions and deletions when compared to
--   a generic size-balanced set implementation (see <a>Data.Set</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
--   
--   Additionally, this implementation places bitmaps in the leaves of the
--   tree. Their size is the natural size of a machine word (32 or 64 bits)
--   and greatly reduces the memory footprint and execution times for dense
--   sets, e.g. sets where it is likely that many values lie close to each
--   other. The asymptotics are not affected by this optimization.
module GHC.Data.Word64Set

-- | A set of integers.
data Word64Set
type Key = Word64

-- | &lt;math&gt;. The empty set.
empty :: Word64Set

-- | &lt;math&gt;. A set of one element.
singleton :: Key -> Word64Set

-- | &lt;math&gt;. Create a set from a list of integers.
fromList :: [Key] -> Word64Set

-- | &lt;math&gt;. Build a set from an ascending list of elements. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromAscList :: [Key] -> Word64Set

-- | &lt;math&gt;. Build a set from an ascending list of distinct elements.
--   <i>The precondition (input list is strictly ascending) is not
--   checked.</i>
fromDistinctAscList :: [Key] -> Word64Set

-- | &lt;math&gt;. Add a value to the set. There is no left- or right bias
--   for Word64Sets.
insert :: Key -> Word64Set -> Word64Set

-- | &lt;math&gt;. Delete a value in the set. Returns the original set when
--   the value was not present.
delete :: Key -> Word64Set -> Word64Set

-- | &lt;math&gt;. <tt>(<a>alterF</a> f x s)</tt> can delete or insert
--   <tt>x</tt> in <tt>s</tt> depending on whether it is already present in
--   <tt>s</tt>.
--   
--   In short:
--   
--   <pre>
--   <a>member</a> x &lt;$&gt; <a>alterF</a> f x s = f (<a>member</a> x s)
--   </pre>
--   
--   Note: <a>alterF</a> is a variant of the <tt>at</tt> combinator from
--   <a>Control.Lens.At</a>.
alterF :: Functor f => (Bool -> f Bool) -> Key -> Word64Set -> f Word64Set

-- | &lt;math&gt;. Is the value a member of the set?
member :: Key -> Word64Set -> Bool

-- | &lt;math&gt;. Is the element not in the set?
notMember :: Key -> Word64Set -> Bool

-- | &lt;math&gt;. Find largest element smaller than the given one.
--   
--   <pre>
--   lookupLT 3 (fromList [3, 5]) == Nothing
--   lookupLT 5 (fromList [3, 5]) == Just 3
--   </pre>
lookupLT :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find smallest element greater than the given one.
--   
--   <pre>
--   lookupGT 4 (fromList [3, 5]) == Just 5
--   lookupGT 5 (fromList [3, 5]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find largest element smaller or equal to the given one.
--   
--   <pre>
--   lookupLE 2 (fromList [3, 5]) == Nothing
--   lookupLE 4 (fromList [3, 5]) == Just 3
--   lookupLE 5 (fromList [3, 5]) == Just 5
--   </pre>
lookupLE :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Find smallest element greater or equal to the given one.
--   
--   <pre>
--   lookupGE 3 (fromList [3, 5]) == Just 3
--   lookupGE 4 (fromList [3, 5]) == Just 5
--   lookupGE 6 (fromList [3, 5]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Set -> Maybe Key

-- | &lt;math&gt;. Is the set empty?
null :: Word64Set -> Bool

-- | &lt;math&gt;. Cardinality of the set.
size :: Word64Set -> Int

-- | &lt;math&gt;. Is this a subset? <tt>(s1 `isSubsetOf` s2)</tt> tells
--   whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. Check whether two sets are disjoint (i.e. their
--   intersection is empty).
--   
--   <pre>
--   disjoint (fromList [2,4,6])   (fromList [1,3])     == True
--   disjoint (fromList [2,4,6,8]) (fromList [2,3,5,7]) == False
--   disjoint (fromList [1,2])     (fromList [1,2,3,4]) == False
--   disjoint (fromList [])        (fromList [])        == True
--   </pre>
disjoint :: Word64Set -> Word64Set -> Bool

-- | &lt;math&gt;. The union of two sets.
union :: Word64Set -> Word64Set -> Word64Set

-- | The union of a list of sets.
unions :: Foldable f => f Word64Set -> Word64Set

-- | &lt;math&gt;. Difference between two sets.
difference :: Word64Set -> Word64Set -> Word64Set

-- | &lt;math&gt;. See <a>difference</a>.
(\\) :: Word64Set -> Word64Set -> Word64Set
infixl 9 \\

-- | &lt;math&gt;. The intersection of two sets.
intersection :: Word64Set -> Word64Set -> Word64Set

-- | &lt;math&gt;. Filter all elements that satisfy some predicate.
filter :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. partition the set according to some predicate.
partition :: (Key -> Bool) -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. Take while a predicate on the elements holds. The user
--   is responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> p . <a>toList</a>
--   takeWhileAntitone p = <a>filter</a> p
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Drop while a predicate on the elements holds. The user
--   is responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> p . <a>toList</a>
--   dropWhileAntitone p = <a>filter</a> (not . p)
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Divide a set at the point where a predicate on the
--   elements stops holding. The user is responsible for ensuring that for
--   all <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partition</a> p xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the set at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. The expression (<tt><a>split</a> x set</tt>) is a pair
--   <tt>(set1,set2)</tt> where <tt>set1</tt> comprises the elements of
--   <tt>set</tt> less than <tt>x</tt> and <tt>set2</tt> comprises the
--   elements of <tt>set</tt> greater than <tt>x</tt>.
--   
--   <pre>
--   split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])
--   </pre>
split :: Key -> Word64Set -> (Word64Set, Word64Set)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot element was found in the original set.
splitMember :: Key -> Word64Set -> (Word64Set, Bool, Word64Set)

-- | &lt;math&gt;. Decompose a set into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a set in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList [1..120]) == [fromList [1..63],fromList [64..120]]
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   subsets, but you should not depend on this behaviour because it can
--   change in the future without notice. Also, the current version does
--   not continue splitting all the way to individual singleton sets -- it
--   stops at some point.
splitRoot :: Word64Set -> [Word64Set]

-- | &lt;math&gt;. <tt><a>map</a> f s</tt> is the set obtained by applying
--   <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (Key -> Key) -> Word64Set -> Word64Set

-- | &lt;math&gt;. The
--   
--   <tt><a>mapMonotonic</a> f s == <a>map</a> f s</tt>, but works only
--   when <tt>f</tt> is strictly increasing. <i>The precondition is not
--   checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapMonotonic f s == map f s
--       where ls = toList s
--   </pre>
mapMonotonic :: (Key -> Key) -> Word64Set -> Word64Set

-- | &lt;math&gt;. Fold the elements in the set using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toAscList set = foldr (:) [] set
--   </pre>
foldr :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. Fold the elements in the set using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toDescList set = foldl (flip (:)) [] set
--   </pre>
foldl :: (a -> Key -> a) -> a -> Word64Set -> a

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> Key -> a) -> a -> Word64Set -> a

-- | &lt;math&gt;. Fold the elements in the set using the given
--   right-associative binary operator. This function is an equivalent of
--   <a>foldr</a> and is present for compatibility only.
--   
--   <i>Please note that fold will be deprecated in the future and
--   removed.</i>
fold :: (Key -> b -> b) -> b -> Word64Set -> b

-- | &lt;math&gt;. The minimal element of the set.
findMin :: Word64Set -> Key

-- | &lt;math&gt;. The maximal element of a set.
findMax :: Word64Set -> Key

-- | &lt;math&gt;. Delete the minimal element. Returns an empty set if the
--   set is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Set</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Set</a> was already empty.
deleteMin :: Word64Set -> Word64Set

-- | &lt;math&gt;. Delete the maximal element. Returns an empty set if the
--   set is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Set</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Set</a> was already empty.
deleteMax :: Word64Set -> Word64Set

-- | &lt;math&gt;. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin set = (findMin set, deleteMin set)
--   </pre>
deleteFindMin :: Word64Set -> (Key, Word64Set)

-- | &lt;math&gt;. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax set = (findMax set, deleteMax set)
--   </pre>
deleteFindMax :: Word64Set -> (Key, Word64Set)

-- | &lt;math&gt;. Retrieves the maximal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
maxView :: Word64Set -> Maybe (Key, Word64Set)

-- | &lt;math&gt;. Retrieves the minimal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
minView :: Word64Set -> Maybe (Key, Word64Set)

-- | &lt;math&gt;. An alias of <a>toAscList</a>. The elements of a set in
--   ascending order. Subject to list fusion.
elems :: Word64Set -> [Key]

-- | &lt;math&gt;. Convert the set to a list of elements. Subject to list
--   fusion.
toList :: Word64Set -> [Key]

-- | &lt;math&gt;. Convert the set to an ascending list of elements.
--   Subject to list fusion.
toAscList :: Word64Set -> [Key]

-- | &lt;math&gt;. Convert the set to a descending list of elements.
--   Subject to list fusion.
toDescList :: Word64Set -> [Key]

-- | &lt;math&gt;. Show the tree that implements the set. The tree is shown
--   in a compressed, hanging format.
showTree :: Word64Set -> String

-- | &lt;math&gt;. The expression (<tt><a>showTreeWith</a> hang wide
--   map</tt>) shows the tree that implements the set. If <tt>hang</tt> is
--   <a>True</a>, a <i>hanging</i> tree is shown otherwise a rotated tree
--   is shown. If <tt>wide</tt> is <a>True</a>, an extra wide version is
--   shown.
showTreeWith :: Bool -> Bool -> Word64Set -> String


-- | <h1>WARNING</h1>
--   
--   This module is considered <b>internal</b>.
--   
--   The Package Versioning Policy <b>does not apply</b>.
--   
--   The contents of this module may change <b>in any way whatsoever</b>
--   and <b>without any warning</b> between minor versions of this package.
--   
--   Authors importing this module are expected to track development
--   closely.
--   
--   <h1>Description</h1>
--   
--   This defines the data structures and core (hidden) manipulations on
--   representations.
module GHC.Data.Word64Map.Internal

-- | A map of integers to values <tt>a</tt>.
data Word64Map a
Bin :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !Mask -> !Word64Map a -> !Word64Map a -> Word64Map a
Tip :: {-# UNPACK #-} !Key -> a -> Word64Map a
Nil :: Word64Map a
type Key = Word64

-- | &lt;math&gt;. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
--   fromList [(5,'a'), (3,'b')] ! 5 == 'a'
--   </pre>
(!) :: Word64Map a -> Key -> a

-- | &lt;math&gt;. Find the value at a key. Returns <a>Nothing</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] !? 1 == Nothing
--   fromList [(5,'a'), (3,'b')] !? 5 == Just 'a'
--   </pre>
(!?) :: Word64Map a -> Key -> Maybe a
infixl 9 !?

-- | Same as <a>difference</a>.
(\\) :: Word64Map a -> Word64Map b -> Word64Map a
infixl 9 \\

-- | &lt;math&gt;. Is the map empty?
--   
--   <pre>
--   Data.Word64Map.null (empty)           == True
--   Data.Word64Map.null (singleton 1 'a') == False
--   </pre>
null :: Word64Map a -> Bool

-- | &lt;math&gt;. Number of elements in the map.
--   
--   <pre>
--   size empty                                   == 0
--   size (singleton 1 'a')                       == 1
--   size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3
--   </pre>
size :: Word64Map a -> Int

-- | &lt;math&gt;. Is the key a member of the map?
--   
--   <pre>
--   member 5 (fromList [(5,'a'), (3,'b')]) == True
--   member 1 (fromList [(5,'a'), (3,'b')]) == False
--   </pre>
member :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Is the key not a member of the map?
--   
--   <pre>
--   notMember 5 (fromList [(5,'a'), (3,'b')]) == False
--   notMember 1 (fromList [(5,'a'), (3,'b')]) == True
--   </pre>
notMember :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Lookup the value at a key in the map. See also
--   <a>lookup</a>.
lookup :: Key -> Word64Map a -> Maybe a

-- | &lt;math&gt;. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not an element of the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
--   findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'
--   </pre>
findWithDefault :: a -> Key -> Word64Map a -> a

-- | &lt;math&gt;. Find largest key smaller than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   </pre>
lookupLT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find largest key smaller or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   </pre>
lookupLE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Check whether the key sets of two maps are disjoint
--   (i.e. their <a>intersection</a> is empty).
--   
--   <pre>
--   disjoint (fromList [(2,'a')]) (fromList [(1,()), (3,())])   == True
--   disjoint (fromList [(2,'a')]) (fromList [(1,'a'), (2,'b')]) == False
--   disjoint (fromList [])        (fromList [])                 == True
--   </pre>
--   
--   <pre>
--   disjoint a b == null (intersection a b)
--   </pre>
disjoint :: Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. The empty map.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: Word64Map a

-- | &lt;math&gt;. A map of one element.
--   
--   <pre>
--   singleton 1 'a'        == fromList [(1, 'a')]
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: Key -> a -> Word64Map a

-- | &lt;math&gt;. Insert a new key/value pair in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><a>insertWith</a> <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function. <tt><a>insertWith</a>
--   f key value mp</tt> will insert the pair (key, value) into <tt>mp</tt>
--   if key does not exist in the map. If the key does exist, the function
--   will insert <tt>f new_value old_value</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: (a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function.
--   <tt><a>insertWithKey</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert <tt>f key new_value
--   old_value</tt>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
--   insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>insertLookupWithKey</a> f k x
--   map</tt>) is a pair where the first element is equal to
--   (<tt><a>lookup</a> k map</tt>) and the second element equal to
--   (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
--   insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
--   insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
--   insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])
--   </pre>
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. Delete a key and its value from the map. When the key is
--   not a member of the map, the original map is returned.
--   
--   <pre>
--   delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   delete 5 empty                         == empty
--   </pre>
delete :: Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjust ("new " ++) 7 empty                         == empty
--   </pre>
adjust :: (a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjustWithKey f 7 empty                         == empty
--   </pre>
adjustWithKey :: (Key -> a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
update :: (a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f k
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Lookup and update. The function returns original value,
--   if it is updated. This is different behavior than
--   <a>updateLookupWithKey</a>. Returns the original key value if the map
--   entry is deleted.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:new a")])
--   updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
--   updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")
--   </pre>
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k (<a>alter</a> f k m)
--   = f (<a>lookup</a> k m)</tt>.
alter :: (Maybe a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>alterF</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alterF</a>
--   can be used to inspect, insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k <a>$</a>
--   <a>alterF</a> f k m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; Word64Map String -&gt; IO (Word64Map String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   <a>alterF</a> is the most general operation for working with an
--   individual key that may or may not be in a given map.
--   
--   Note: <a>alterF</a> is a flipped version of the <tt>at</tt> combinator
--   from <tt>Control.Lens.At</tt>.
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> Word64Map a -> f (Word64Map a)

-- | &lt;math&gt;. The (left-biased) union of two maps. It prefers the
--   first map when duplicate keys are encountered, i.e. (<tt><a>union</a>
--   == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]
--   </pre>
unionWith :: (a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]
--   </pre>
unionWithKey :: (Key -> a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | The union of a list of maps.
--   
--   <pre>
--   unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
--       == fromList [(3, "B3"), (5, "A3"), (7, "C")]
--   </pre>
unions :: Foldable f => f (Word64Map a) -> Word64Map a

-- | The union of a list of maps, with a combining operation.
--   
--   <pre>
--   unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]
--   </pre>
unionsWith :: Foldable f => (a -> a -> a) -> f (Word64Map a) -> Word64Map a

-- | &lt;math&gt;. Difference between two maps (based on keys).
--   
--   <pre>
--   difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"
--   </pre>
difference :: Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. Difference with a combining function.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
--       == singleton 3 "b:B"
--   </pre>
differenceWith :: (a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
--       == singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: (Key -> a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The (left-biased) intersection of two maps (based on
--   keys).
--   
--   <pre>
--   intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"
--   </pre>
intersection :: Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"
--   </pre>
intersectionWith :: (a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: (Key -> a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | Relate the keys of one map to the values of the other, by using the
--   values of the former as keys for lookups in the latter.
--   
--   Complexity: &lt;math&gt;, where &lt;math&gt; is the size of the first
--   argument
--   
--   <pre>
--   compose (fromList [('a', "A"), ('b', "B")]) (fromList [(1,'a'),(2,'b'),(3,'z')]) = fromList [(1,"A"),(2,"B")]
--   </pre>
--   
--   <pre>
--   (<a>compose</a> bc ab <a>!?</a>) = (bc <a>!?</a>) &lt;=&lt; (ab <a>!?</a>)
--   </pre>
--   
--   <b>Note:</b> Prior to v0.6.4, <a>Data.Word64Map.Strict</a> exposed a
--   version of <a>compose</a> that forced the values of the output
--   <a>Word64Map</a>. This version does not force these values.
compose :: Word64Map c -> Word64Map Word64 -> Word64Map c

-- | A tactic for dealing with keys present in one map but not the other in
--   <a>merge</a>.
--   
--   A tactic of type <tt>SimpleWhenMissing x z</tt> is an abstract
--   representation of a function of type <tt>Key -&gt; x -&gt; Maybe
--   z</tt>.
type SimpleWhenMissing = WhenMissing Identity

-- | A tactic for dealing with keys present in both maps in <a>merge</a>.
--   
--   A tactic of type <tt>SimpleWhenMatched x y z</tt> is an abstract
--   representation of a function of type <tt>Key -&gt; x -&gt; y -&gt;
--   Maybe z</tt>.
type SimpleWhenMatched = WhenMatched Identity

-- | Along with zipWithMaybeAMatched, witnesses the isomorphism between
--   <tt>WhenMatched f x y z</tt> and <tt>Key -&gt; x -&gt; y -&gt; f
--   (Maybe z)</tt>.
runWhenMatched :: WhenMatched f x y z -> Key -> x -> y -> f (Maybe z)

-- | Along with traverseMaybeMissing, witnesses the isomorphism between
--   <tt>WhenMissing f x y</tt> and <tt>Key -&gt; x -&gt; f (Maybe y)</tt>.
runWhenMissing :: WhenMissing f x y -> Key -> x -> f (Maybe y)

-- | Merge two maps.
--   
--   <a>merge</a> takes two <a>WhenMissing</a> tactics, a
--   <a>WhenMatched</a> tactic and two maps. It uses the tactics to merge
--   the maps. Its behavior is best understood via its fundamental tactics,
--   <a>mapMaybeMissing</a> and <a>zipWithMaybeMatched</a>.
--   
--   Consider
--   
--   <pre>
--   merge (mapMaybeMissing g1)
--                (mapMaybeMissing g2)
--                (zipWithMaybeMatched f)
--                m1 m2
--   </pre>
--   
--   Take, for example,
--   
--   <pre>
--   m1 = [(0, 'a'), (1, 'b'), (3, 'c'), (4, 'd')]
--   m2 = [(1, "one"), (2, "two"), (4, "three")]
--   </pre>
--   
--   <a>merge</a> will first "align" these maps by key:
--   
--   <pre>
--   m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
--   m2 =           [(1, "one"), (2, "two"),           (4, "three")]
--   </pre>
--   
--   It will then pass the individual entries and pairs of entries to
--   <tt>g1</tt>, <tt>g2</tt>, or <tt>f</tt> as appropriate:
--   
--   <pre>
--   maybes = [g1 0 'a', f 1 'b' "one", g2 2 "two", g1 3 'c', f 4 'd' "three"]
--   </pre>
--   
--   This produces a <a>Maybe</a> for each key:
--   
--   <pre>
--   keys =     0        1          2           3        4
--   results = [Nothing, Just True, Just False, Nothing, Just True]
--   </pre>
--   
--   Finally, the <tt>Just</tt> results are collected into a map:
--   
--   <pre>
--   return value = [(1, True), (2, False), (4, True)]
--   </pre>
--   
--   The other tactics below are optimizations or simplifications of
--   <a>mapMaybeMissing</a> for special cases. Most importantly,
--   
--   <ul>
--   <li><a>dropMissing</a> drops all the keys.</li>
--   <li><a>preserveMissing</a> leaves all the entries alone.</li>
--   </ul>
--   
--   When <a>merge</a> is given three arguments, it is inlined at the call
--   site. To prevent excessive inlining, you should typically use
--   <a>merge</a> to define your custom combining functions.
--   
--   Examples:
--   
--   <pre>
--   unionWithKey f = merge preserveMissing preserveMissing (zipWithMatched f)
--   </pre>
--   
--   <pre>
--   intersectionWithKey f = merge dropMissing dropMissing (zipWithMatched f)
--   </pre>
--   
--   <pre>
--   differenceWith f = merge diffPreserve diffDrop f
--   </pre>
--   
--   <pre>
--   symmetricDifference = merge diffPreserve diffPreserve (\ _ _ _ -&gt; Nothing)
--   </pre>
--   
--   <pre>
--   mapEachPiece f g h = merge (diffMapWithKey f) (diffMapWithKey g)
--   </pre>
merge :: SimpleWhenMissing a c -> SimpleWhenMissing b c -> SimpleWhenMatched a b c -> Word64Map a -> Word64Map b -> Word64Map c

-- | When a key is found in both maps, apply a function to the key and
--   values and maybe use the result in the merged map.
--   
--   <pre>
--   zipWithMaybeMatched
--     :: (Key -&gt; x -&gt; y -&gt; Maybe z)
--     -&gt; SimpleWhenMatched x y z
--   </pre>
zipWithMaybeMatched :: Applicative f => (Key -> x -> y -> Maybe z) -> WhenMatched f x y z

-- | When a key is found in both maps, apply a function to the key and
--   values and use the result in the merged map.
--   
--   <pre>
--   zipWithMatched
--     :: (Key -&gt; x -&gt; y -&gt; z)
--     -&gt; SimpleWhenMatched x y z
--   </pre>
zipWithMatched :: Applicative f => (Key -> x -> y -> z) -> WhenMatched f x y z

-- | Map over the entries whose keys are missing from the other map,
--   optionally removing some. This is the most powerful
--   <a>SimpleWhenMissing</a> tactic, but others are usually more
--   efficient.
--   
--   <pre>
--   mapMaybeMissing :: (Key -&gt; x -&gt; Maybe y) -&gt; SimpleWhenMissing x y
--   </pre>
--   
--   <pre>
--   mapMaybeMissing f = traverseMaybeMissing (\k x -&gt; pure (f k x))
--   </pre>
--   
--   but <tt>mapMaybeMissing</tt> uses fewer unnecessary <a>Applicative</a>
--   operations.
mapMaybeMissing :: Applicative f => (Key -> x -> Maybe y) -> WhenMissing f x y

-- | Drop all the entries whose keys are missing from the other map.
--   
--   <pre>
--   dropMissing :: SimpleWhenMissing x y
--   </pre>
--   
--   <pre>
--   dropMissing = mapMaybeMissing (\_ _ -&gt; Nothing)
--   </pre>
--   
--   but <tt>dropMissing</tt> is much faster.
dropMissing :: Applicative f => WhenMissing f x y

-- | Preserve, unchanged, the entries whose keys are missing from the other
--   map.
--   
--   <pre>
--   preserveMissing :: SimpleWhenMissing x x
--   </pre>
--   
--   <pre>
--   preserveMissing = Merge.Lazy.mapMaybeMissing (\_ x -&gt; Just x)
--   </pre>
--   
--   but <tt>preserveMissing</tt> is much faster.
preserveMissing :: Applicative f => WhenMissing f x x

-- | Map over the entries whose keys are missing from the other map.
--   
--   <pre>
--   mapMissing :: (k -&gt; x -&gt; y) -&gt; SimpleWhenMissing x y
--   </pre>
--   
--   <pre>
--   mapMissing f = mapMaybeMissing (\k x -&gt; Just $ f k x)
--   </pre>
--   
--   but <tt>mapMissing</tt> is somewhat faster.
mapMissing :: Applicative f => (Key -> x -> y) -> WhenMissing f x y

-- | Filter the entries whose keys are missing from the other map.
--   
--   <pre>
--   filterMissing :: (k -&gt; x -&gt; Bool) -&gt; SimpleWhenMissing x x
--   </pre>
--   
--   <pre>
--   filterMissing f = Merge.Lazy.mapMaybeMissing $ \k x -&gt; guard (f k x) *&gt; Just x
--   </pre>
--   
--   but this should be a little faster.
filterMissing :: Applicative f => (Key -> x -> Bool) -> WhenMissing f x x

-- | A tactic for dealing with keys present in one map but not the other in
--   <a>merge</a> or <a>mergeA</a>.
--   
--   A tactic of type <tt>WhenMissing f k x z</tt> is an abstract
--   representation of a function of type <tt>Key -&gt; x -&gt; f (Maybe
--   z)</tt>.
data WhenMissing f x y
WhenMissing :: (Word64Map x -> f (Word64Map y)) -> (Key -> x -> f (Maybe y)) -> WhenMissing f x y
[missingSubtree] :: WhenMissing f x y -> Word64Map x -> f (Word64Map y)
[missingKey] :: WhenMissing f x y -> Key -> x -> f (Maybe y)

-- | A tactic for dealing with keys present in both maps in <a>merge</a> or
--   <a>mergeA</a>.
--   
--   A tactic of type <tt>WhenMatched f x y z</tt> is an abstract
--   representation of a function of type <tt>Key -&gt; x -&gt; y -&gt; f
--   (Maybe z)</tt>.
newtype WhenMatched f x y z
WhenMatched :: (Key -> x -> y -> f (Maybe z)) -> WhenMatched f x y z
[matchedKey] :: WhenMatched f x y z -> Key -> x -> y -> f (Maybe z)

-- | An applicative version of <a>merge</a>.
--   
--   <a>mergeA</a> takes two <a>WhenMissing</a> tactics, a
--   <a>WhenMatched</a> tactic and two maps. It uses the tactics to merge
--   the maps. Its behavior is best understood via its fundamental tactics,
--   <a>traverseMaybeMissing</a> and <a>zipWithMaybeAMatched</a>.
--   
--   Consider
--   
--   <pre>
--   mergeA (traverseMaybeMissing g1)
--                 (traverseMaybeMissing g2)
--                 (zipWithMaybeAMatched f)
--                 m1 m2
--   </pre>
--   
--   Take, for example,
--   
--   <pre>
--   m1 = [(0, 'a'), (1, 'b'), (3,'c'), (4, 'd')]
--   m2 = [(1, "one"), (2, "two"), (4, "three")]
--   </pre>
--   
--   <a>mergeA</a> will first "align" these maps by key:
--   
--   <pre>
--   m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
--   m2 =           [(1, "one"), (2, "two"),           (4, "three")]
--   </pre>
--   
--   It will then pass the individual entries and pairs of entries to
--   <tt>g1</tt>, <tt>g2</tt>, or <tt>f</tt> as appropriate:
--   
--   <pre>
--   actions = [g1 0 'a', f 1 'b' "one", g2 2 "two", g1 3 'c', f 4 'd' "three"]
--   </pre>
--   
--   Next, it will perform the actions in the <tt>actions</tt> list in
--   order from left to right.
--   
--   <pre>
--   keys =     0        1          2           3        4
--   results = [Nothing, Just True, Just False, Nothing, Just True]
--   </pre>
--   
--   Finally, the <tt>Just</tt> results are collected into a map:
--   
--   <pre>
--   return value = [(1, True), (2, False), (4, True)]
--   </pre>
--   
--   The other tactics below are optimizations or simplifications of
--   <a>traverseMaybeMissing</a> for special cases. Most importantly,
--   
--   <ul>
--   <li><a>dropMissing</a> drops all the keys.</li>
--   <li><a>preserveMissing</a> leaves all the entries alone.</li>
--   <li><a>mapMaybeMissing</a> does not use the <a>Applicative</a>
--   context.</li>
--   </ul>
--   
--   When <a>mergeA</a> is given three arguments, it is inlined at the call
--   site. To prevent excessive inlining, you should generally only use
--   <a>mergeA</a> to define custom combining functions.
mergeA :: Applicative f => WhenMissing f a c -> WhenMissing f b c -> WhenMatched f a b c -> Word64Map a -> Word64Map b -> f (Word64Map c)

-- | When a key is found in both maps, apply a function to the key and
--   values, perform the resulting action, and maybe use the result in the
--   merged map.
--   
--   This is the fundamental <a>WhenMatched</a> tactic.
zipWithMaybeAMatched :: (Key -> x -> y -> f (Maybe z)) -> WhenMatched f x y z

-- | When a key is found in both maps, apply a function to the key and
--   values to produce an action and use its result in the merged map.
zipWithAMatched :: Applicative f => (Key -> x -> y -> f z) -> WhenMatched f x y z

-- | Traverse over the entries whose keys are missing from the other map,
--   optionally producing values to put in the result. This is the most
--   powerful <a>WhenMissing</a> tactic, but others are usually more
--   efficient.
traverseMaybeMissing :: Applicative f => (Key -> x -> f (Maybe y)) -> WhenMissing f x y

-- | Traverse over the entries whose keys are missing from the other map.
traverseMissing :: Applicative f => (Key -> x -> f y) -> WhenMissing f x y

-- | Filter the entries whose keys are missing from the other map using
--   some <a>Applicative</a> action.
--   
--   <pre>
--   filterAMissing f = Merge.Lazy.traverseMaybeMissing $
--     \k x -&gt; (\b -&gt; guard b *&gt; Just x) &lt;$&gt; f k x
--   </pre>
--   
--   but this should be a little faster.
filterAMissing :: Applicative f => (Key -> x -> f Bool) -> WhenMissing f x x

-- | &lt;math&gt;. A high-performance universal combining function. Using
--   <a>mergeWithKey</a>, all combining functions can be defined without
--   any loss of efficiency (with exception of <a>union</a>,
--   <a>difference</a> and <a>intersection</a>, where sharing of some nodes
--   is lost with <a>mergeWithKey</a>).
--   
--   Please make sure you know what is going on when using
--   <a>mergeWithKey</a>, otherwise you can be surprised by unexpected code
--   growth or even corruption of the data structure.
--   
--   When <a>mergeWithKey</a> is given three arguments, it is inlined to
--   the call site. You should therefore use <a>mergeWithKey</a> only to
--   define your custom combining functions. For example, you could define
--   <a>unionWithKey</a>, <a>differenceWithKey</a> and
--   <a>intersectionWithKey</a> as
--   
--   <pre>
--   myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
--   myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
--   myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2
--   </pre>
--   
--   When calling <tt><a>mergeWithKey</a> combine only1 only2</tt>, a
--   function combining two <a>Word64Map</a>s is created, such that
--   
--   <ul>
--   <li>if a key is present in both maps, it is passed with both
--   corresponding values to the <tt>combine</tt> function. Depending on
--   the result, the key is either present in the result with specified
--   value, or is left out;</li>
--   <li>a nonempty subtree present only in the first map is passed to
--   <tt>only1</tt> and the output is added to the result;</li>
--   <li>a nonempty subtree present only in the second map is passed to
--   <tt>only2</tt> and the output is added to the result.</li>
--   </ul>
--   
--   The <tt>only1</tt> and <tt>only2</tt> methods <i>must return a map
--   with a subset (possibly empty) of the keys of the given map</i>. The
--   values can be modified arbitrarily. Most common variants of
--   <tt>only1</tt> and <tt>only2</tt> are <a>id</a> and <tt><a>const</a>
--   <a>empty</a></tt>, but for example <tt><a>map</a> f</tt> or
--   <tt><a>filterWithKey</a> f</tt> could be used for any <tt>f</tt>.
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (Word64Map a -> Word64Map c) -> (Word64Map b -> Word64Map c) -> Word64Map a -> Word64Map b -> Word64Map c
mergeWithKey' :: (Prefix -> Mask -> Word64Map c -> Word64Map c -> Word64Map c) -> (Word64Map a -> Word64Map b -> Word64Map c) -> (Word64Map a -> Word64Map c) -> (Word64Map b -> Word64Map c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]
--   </pre>
map :: (a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]
--   </pre>
mapWithKey :: (Key -> a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. <tt><a>traverseWithKey</a> f s == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <pre>
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing
--   </pre>
traverseWithKey :: Applicative t => (Key -> a -> t b) -> Word64Map a -> t (Word64Map b)

-- | &lt;math&gt;. Traverse keys/values and collect the <a>Just</a>
--   results.
traverseMaybeWithKey :: Applicative f => (Key -> a -> f (Maybe b)) -> Word64Map a -> f (Word64Map b)

-- | &lt;math&gt;. The function <tt><a>mapAccum</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumWithKey</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumRWithKey</a></tt> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   <pre>
--   mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
--   mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"
--   </pre>
mapKeys :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has slightly better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   </pre>
mapKeysMonotonic :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"
--   </pre>
foldrWithKey :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
--   
--   <pre>
--   let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"
--   </pre>
foldlWithKey :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   monoid, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Monoid m => (Key -> a -> m) -> Word64Map a -> m

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. A strict version of <a>foldrWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldrWithKey' :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldlWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldlWithKey' :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
--   
--   <pre>
--   elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
--   elems empty == []
--   </pre>
elems :: Word64Map a -> [a]

-- | &lt;math&gt;. Return all keys of the map in ascending order. Subject
--   to list fusion.
--   
--   <pre>
--   keys (fromList [(5,"a"), (3,"b")]) == [3,5]
--   keys empty == []
--   </pre>
keys :: Word64Map a -> [Key]

-- | &lt;math&gt;. An alias for <a>toAscList</a>. Returns all key/value
--   pairs in the map in ascending key order. Subject to list fusion.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. The set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [(5,"a"), (3,"b")]) == Data.Word64Set.fromList [3,5]
--   keysSet empty == Data.Word64Set.empty
--   </pre>
keysSet :: Word64Map a -> Word64Set

-- | &lt;math&gt;. Build a map from a set of keys and a function which for
--   each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; replicate k 'a') (Data.Word64Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
--   fromSet undefined Data.Word64Set.empty == empty
--   </pre>
fromSet :: (Key -> a) -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Convert the map to a list of key/value pairs. Subject to
--   list fusion.
--   
--   <pre>
--   toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   toList empty == []
--   </pre>
toList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Create a map from a list of key/value pairs.
--   
--   <pre>
--   fromList [] == empty
--   fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
--   fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]
--   </pre>
fromList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "ab"), (5, "cba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs with a
--   combining function. See also fromAscListWithKey'.
--   
--   <pre>
--   let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   fromListWithKey f [] == empty
--   </pre>
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in ascending order. Subject to list fusion.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in descending order. Subject to list fusion.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   </pre>
fromAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "5:b|a")]
--   </pre>
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order and all distinct. <i>The precondition
--   (input list is strictly ascending) is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   </pre>
fromDistinctAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Filter all values that satisfy some predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
--   filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty
--   </pre>
filter :: (a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Filter all keys/values that satisfy some predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
filterWithKey :: (Key -> a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The restriction of a map to the keys in a set.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`member`</a> s) m
--   </pre>
restrictKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Remove all the keys in a given set from a map.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`notMember`</a> s) m
--   </pre>
withoutKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partition :: (a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partitionWithKey :: (Key -> a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> (p . fst) . <a>toList</a>
--   takeWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> (p . fst) . <a>toList</a>
--   dropWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Divide a map at the point where a predicate on the keys
--   stops holding. The user is responsible for ensuring that for all
--   <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partitionWithKey</a> (\k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (Key -> a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])
--   
--   mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--   </pre>
mapEither :: (a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])
--   </pre>
mapEitherWithKey :: (Key -> a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where all keys in <tt>map1</tt> are lower than
--   <tt>k</tt> and all keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
--   split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
--   split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
--   split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)
--   </pre>
split :: Key -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot key was found in the original map.
--   
--   <pre>
--   splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
--   splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
--   splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
--   splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
--   splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)
--   </pre>
splitLookup :: Key -> Word64Map a -> (Word64Map a, Maybe a, Word64Map a)

-- | &lt;math&gt;. Decompose a map into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList (zip [1..6::Int] ['a'..])) ==
--     [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d'),(5,'e'),(6,'f')]]
--   </pre>
--   
--   <pre>
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: Word64Map a -> [Word64Map a]

-- | &lt;math&gt;. Is this a submap? Defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. The expression (<tt><a>isSubmapOfBy</a> f m1 m2</tt>)
--   returns <a>True</a> if all keys in <tt>m1</tt> are in <tt>m2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   </pre>
isSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a>
--   (==)</tt>).
isProperSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns
--   <a>True</a> when <tt>keys m1</tt> and <tt>keys m2</tt> are not equal,
--   all keys in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt>
--   returns <a>True</a> when applied to their respective values. For
--   example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
--   </pre>
isProperSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. The minimal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMin :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMax :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The minimal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>minViewWithKey</a> if the map may be empty.
findMin :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>maxViewWithKey</a> if the map may be empty.
findMax :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. Delete the minimal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMin :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete the maximal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMax :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete and find the minimal element. This function
--   throws an error if the map is empty. Use <a>minViewWithKey</a> if the
--   map may be empty.
deleteFindMin :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Delete and find the maximal element. This function
--   throws an error if the map is empty. Use <a>maxViewWithKey</a> if the
--   map may be empty.
deleteFindMax :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMinWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMaxWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Retrieves the minimal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
minView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
maxView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the minimal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)

-- | &lt;math&gt;. Show the tree that implements the map. The tree is shown
--   in a compressed, hanging format.
showTree :: Show a => Word64Map a -> String

-- | &lt;math&gt;. The expression (<tt><a>showTreeWith</a> hang wide
--   map</tt>) shows the tree that implements the map. If <tt>hang</tt> is
--   <a>True</a>, a <i>hanging</i> tree is shown otherwise a rotated tree
--   is shown. If <tt>wide</tt> is <a>True</a>, an extra wide version is
--   shown.
showTreeWith :: Show a => Bool -> Bool -> Word64Map a -> String
type Mask = Word64
type Prefix = Word64
type Nat = Word64
natFromInt :: Key -> Nat
intFromNat :: Nat -> Key
link :: Prefix -> Word64Map a -> Prefix -> Word64Map a -> Word64Map a
linkWithMask :: Mask -> Prefix -> Word64Map a -> Word64Map a -> Word64Map a
bin :: Prefix -> Mask -> Word64Map a -> Word64Map a -> Word64Map a
binCheckLeft :: Prefix -> Mask -> Word64Map a -> Word64Map a -> Word64Map a
binCheckRight :: Prefix -> Mask -> Word64Map a -> Word64Map a -> Word64Map a

-- | Should this key follow the left subtree of a <a>Bin</a> with switching
--   bit <tt>m</tt>? N.B., the answer is only valid when <tt>match i p
--   m</tt> is true.
zero :: Key -> Mask -> Bool

-- | Does the key <tt>i</tt> differ from the prefix <tt>p</tt> before
--   getting to the switching bit <tt>m</tt>?
nomatch :: Key -> Prefix -> Mask -> Bool

-- | Does the key <tt>i</tt> match the prefix <tt>p</tt> (up to but not
--   including bit <tt>m</tt>)?
match :: Key -> Prefix -> Mask -> Bool

-- | The prefix of key <tt>i</tt> up to (but not including) the switching
--   bit <tt>m</tt>.
mask :: Key -> Mask -> Prefix

-- | The prefix of key <tt>i</tt> up to (but not including) the switching
--   bit <tt>m</tt>.
maskW :: Nat -> Nat -> Prefix

-- | Does the left switching bit specify a shorter prefix?
shorter :: Mask -> Mask -> Bool

-- | The first switching bit where the two prefixes disagree.
branchMask :: Prefix -> Prefix -> Mask

-- | Return a word where only the highest bit is set.
highestBitMask :: Word64 -> Word64

-- | Map covariantly over a <tt><a>WhenMissing</a> f x</tt>.
mapWhenMissing :: (Applicative f, Monad f) => (a -> b) -> WhenMissing f x a -> WhenMissing f x b

-- | Map covariantly over a <tt><a>WhenMatched</a> f x y</tt>.
mapWhenMatched :: Functor f => (a -> b) -> WhenMatched f x y a -> WhenMatched f x y b

-- | Map contravariantly over a <tt><a>WhenMissing</a> f _ x</tt>.
lmapWhenMissing :: (b -> a) -> WhenMissing f a x -> WhenMissing f b x

-- | Map contravariantly over a <tt><a>WhenMatched</a> f _ y z</tt>.
contramapFirstWhenMatched :: (b -> a) -> WhenMatched f a y z -> WhenMatched f b y z

-- | Map contravariantly over a <tt><a>WhenMatched</a> f x _ z</tt>.
contramapSecondWhenMatched :: (b -> a) -> WhenMatched f x a z -> WhenMatched f x b z

-- | Map covariantly over a <tt><a>WhenMissing</a> f x</tt>, using only a
--   'Functor f' constraint.
mapGentlyWhenMissing :: Functor f => (a -> b) -> WhenMissing f x a -> WhenMissing f x b

-- | Map covariantly over a <tt><a>WhenMatched</a> f k x</tt>, using only a
--   'Functor f' constraint.
mapGentlyWhenMatched :: Functor f => (a -> b) -> WhenMatched f x y a -> WhenMatched f x y b
instance GHC.Base.Functor f => GHC.Base.Functor (GHC.Data.Word64Map.Internal.WhenMatched f x y)
instance (GHC.Base.Monad f, GHC.Base.Applicative f) => Control.Category.Category (GHC.Data.Word64Map.Internal.WhenMatched f x)
instance (GHC.Base.Monad f, GHC.Base.Applicative f) => GHC.Base.Applicative (GHC.Data.Word64Map.Internal.WhenMatched f x y)
instance (GHC.Base.Monad f, GHC.Base.Applicative f) => GHC.Base.Monad (GHC.Data.Word64Map.Internal.WhenMatched f x y)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => GHC.Base.Functor (GHC.Data.Word64Map.Internal.WhenMissing f x)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => Control.Category.Category (GHC.Data.Word64Map.Internal.WhenMissing f)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => GHC.Base.Applicative (GHC.Data.Word64Map.Internal.WhenMissing f x)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => GHC.Base.Monad (GHC.Data.Word64Map.Internal.WhenMissing f x)
instance GHC.Base.Monoid (GHC.Data.Word64Map.Internal.Word64Map a)
instance GHC.Base.Semigroup (GHC.Data.Word64Map.Internal.Word64Map a)
instance Data.Foldable.Foldable GHC.Data.Word64Map.Internal.Word64Map
instance Data.Traversable.Traversable GHC.Data.Word64Map.Internal.Word64Map
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Data.Word64Map.Internal.Word64Map a)
instance Data.Data.Data a => Data.Data.Data (GHC.Data.Word64Map.Internal.Word64Map a)
instance GHC.IsList.IsList (GHC.Data.Word64Map.Internal.Word64Map a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.Word64Map.Internal.Word64Map a)
instance Data.Functor.Classes.Eq1 GHC.Data.Word64Map.Internal.Word64Map
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Data.Word64Map.Internal.Word64Map a)
instance Data.Functor.Classes.Ord1 GHC.Data.Word64Map.Internal.Word64Map
instance GHC.Base.Functor GHC.Data.Word64Map.Internal.Word64Map
instance GHC.Show.Show a => GHC.Show.Show (GHC.Data.Word64Map.Internal.Word64Map a)
instance Data.Functor.Classes.Show1 GHC.Data.Word64Map.Internal.Word64Map
instance GHC.Read.Read e => GHC.Read.Read (GHC.Data.Word64Map.Internal.Word64Map e)
instance Data.Functor.Classes.Read1 GHC.Data.Word64Map.Internal.Word64Map


-- | <h1>Finite Int Maps (strict interface)</h1>
--   
--   The <tt><a>Word64Map</a> v</tt> type represents a finite map
--   (sometimes called a dictionary) from key of type <tt>Int</tt> to
--   values of type <tt>v</tt>.
--   
--   Each function in this module is careful to force values before
--   installing them in an <a>Word64Map</a>. This is usually more efficient
--   when laziness is not necessary. When laziness <i>is</i> required, use
--   the functions in <a>Data.Word64Map.Lazy</a>.
--   
--   In particular, the functions in this module obey the following law:
--   
--   <ul>
--   <li>If all values stored in all maps in the arguments are in WHNF,
--   then all values stored in all maps in the results will be in WHNF once
--   those maps are evaluated.</li>
--   </ul>
--   
--   For a walkthrough of the most commonly used functions see the <a>maps
--   introduction</a>.
--   
--   This module is intended to be imported qualified, to avoid name
--   clashes with Prelude functions:
--   
--   <pre>
--   import Data.Word64Map.Strict (Word64Map)
--   import qualified Data.Word64Map.Strict as Word64Map
--   </pre>
--   
--   Note that the implementation is generally <i>left-biased</i>.
--   Functions that take two maps as arguments and combine them, such as
--   <a>union</a> and <a>intersection</a>, prefer the values in the first
--   argument to those in the second.
--   
--   <h2>Detailed performance information</h2>
--   
--   The amortized running time is given for each operation, with
--   &lt;math&gt; referring to the number of entries in the map and
--   &lt;math&gt; referring to the number of bits in an <a>Int</a> (32 or
--   64).
--   
--   Benchmarks comparing <a>Data.Word64Map.Strict</a> with other
--   dictionary implementations can be found at
--   <a>https://github.com/haskell-perf/dictionaries</a>.
--   
--   <h2>Warning</h2>
--   
--   The <a>Word64Map</a> type is shared between the lazy and strict
--   modules, meaning that the same <a>Word64Map</a> value can be passed to
--   functions in both modules. This means that the <a>Functor</a>,
--   <a>Traversable</a> and <a>Data</a> instances are the same as for the
--   <a>Data.Word64Map.Lazy</a> module, so if they are used the resulting
--   map may contain suspended values (thunks).
--   
--   <h2>Implementation</h2>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. Additionally, benchmarks show
--   that it is also (much) faster on insertions and deletions when
--   compared to a generic size-balanced map implementation (see
--   <a>Data.Map</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
module GHC.Data.Word64Map.Strict.Internal

-- | A map of integers to values <tt>a</tt>.
data Word64Map a
type Key = Word64

-- | &lt;math&gt;. The empty map.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: Word64Map a

-- | &lt;math&gt;. A map of one element.
--   
--   <pre>
--   singleton 1 'a'        == fromList [(1, 'a')]
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: Key -> a -> Word64Map a

-- | &lt;math&gt;. Build a map from a set of keys and a function which for
--   each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; replicate k 'a') (Data.Word64Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
--   fromSet undefined Data.Word64Set.empty == empty
--   </pre>
fromSet :: (Key -> a) -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs.
--   
--   <pre>
--   fromList [] == empty
--   fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
--   fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]
--   </pre>
fromList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs with a
--   combining function. See also fromAscListWithKey'.
--   
--   <pre>
--   let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   fromListWithKey f [] == empty
--   </pre>
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   </pre>
fromAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order and all distinct. <i>The precondition
--   (input list is strictly ascending) is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   </pre>
fromDistinctAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Insert a new key/value pair in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><a>insertWith</a> <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function. <tt><a>insertWith</a>
--   f key value mp</tt> will insert the pair (key, value) into <tt>mp</tt>
--   if key does not exist in the map. If the key does exist, the function
--   will insert <tt>f new_value old_value</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: (a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function.
--   <tt><a>insertWithKey</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert <tt>f key new_value
--   old_value</tt>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
--   insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
--   
--   If the key exists in the map, this function is lazy in <tt>value</tt>
--   but strict in the result of <tt>f</tt>.
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>insertLookupWithKey</a> f k x
--   map</tt>) is a pair where the first element is equal to
--   (<tt><a>lookup</a> k map</tt>) and the second element equal to
--   (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
--   insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
--   insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
--   insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])
--   </pre>
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. Delete a key and its value from the map. When the key is
--   not a member of the map, the original map is returned.
--   
--   <pre>
--   delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   delete 5 empty                         == empty
--   </pre>
delete :: Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjust ("new " ++) 7 empty                         == empty
--   </pre>
adjust :: (a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjustWithKey f 7 empty                         == empty
--   </pre>
adjustWithKey :: (Key -> a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
update :: (a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f k
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Lookup and update. The function returns original value,
--   if it is updated. This is different behavior than
--   <a>updateLookupWithKey</a>. Returns the original key value if the map
--   entry is deleted.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:new a")])
--   updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
--   updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")
--   </pre>
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k (<a>alter</a> f k m)
--   = f (<a>lookup</a> k m)</tt>.
alter :: (Maybe a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>alterF</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alterF</a>
--   can be used to inspect, insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k <a>$</a>
--   <a>alterF</a> f k m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; Word64Map String -&gt; IO (Word64Map String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   <a>alterF</a> is the most general operation for working with an
--   individual key that may or may not be in a given map.
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> Word64Map a -> f (Word64Map a)

-- | &lt;math&gt;. Lookup the value at a key in the map. See also
--   <a>lookup</a>.
lookup :: Key -> Word64Map a -> Maybe a

-- | &lt;math&gt;. Find the value at a key. Returns <a>Nothing</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] !? 1 == Nothing
--   fromList [(5,'a'), (3,'b')] !? 5 == Just 'a'
--   </pre>
(!?) :: Word64Map a -> Key -> Maybe a
infixl 9 !?

-- | &lt;math&gt;. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
--   fromList [(5,'a'), (3,'b')] ! 5 == 'a'
--   </pre>
(!) :: Word64Map a -> Key -> a

-- | &lt;math&gt;. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not an element of the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
--   findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'
--   </pre>
findWithDefault :: a -> Key -> Word64Map a -> a

-- | &lt;math&gt;. Is the key a member of the map?
--   
--   <pre>
--   member 5 (fromList [(5,'a'), (3,'b')]) == True
--   member 1 (fromList [(5,'a'), (3,'b')]) == False
--   </pre>
member :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Is the key not a member of the map?
--   
--   <pre>
--   notMember 5 (fromList [(5,'a'), (3,'b')]) == False
--   notMember 1 (fromList [(5,'a'), (3,'b')]) == True
--   </pre>
notMember :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Find largest key smaller than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   </pre>
lookupLT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find largest key smaller or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   </pre>
lookupLE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Is the map empty?
--   
--   <pre>
--   Data.Word64Map.null (empty)           == True
--   Data.Word64Map.null (singleton 1 'a') == False
--   </pre>
null :: Word64Map a -> Bool

-- | &lt;math&gt;. Number of elements in the map.
--   
--   <pre>
--   size empty                                   == 0
--   size (singleton 1 'a')                       == 1
--   size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3
--   </pre>
size :: Word64Map a -> Int

-- | &lt;math&gt;. The (left-biased) union of two maps. It prefers the
--   first map when duplicate keys are encountered, i.e. (<tt><a>union</a>
--   == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]
--   </pre>
unionWith :: (a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]
--   </pre>
unionWithKey :: (Key -> a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | The union of a list of maps.
--   
--   <pre>
--   unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
--       == fromList [(3, "B3"), (5, "A3"), (7, "C")]
--   </pre>
unions :: Foldable f => f (Word64Map a) -> Word64Map a

-- | The union of a list of maps, with a combining operation.
--   
--   <pre>
--   unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]
--   </pre>
unionsWith :: Foldable f => (a -> a -> a) -> f (Word64Map a) -> Word64Map a

-- | &lt;math&gt;. Difference between two maps (based on keys).
--   
--   <pre>
--   difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"
--   </pre>
difference :: Word64Map a -> Word64Map b -> Word64Map a

-- | Same as <a>difference</a>.
(\\) :: Word64Map a -> Word64Map b -> Word64Map a
infixl 9 \\

-- | &lt;math&gt;. Difference with a combining function.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
--       == singleton 3 "b:B"
--   </pre>
differenceWith :: (a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
--       == singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: (Key -> a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The (left-biased) intersection of two maps (based on
--   keys).
--   
--   <pre>
--   intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"
--   </pre>
intersection :: Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"
--   </pre>
intersectionWith :: (a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: (Key -> a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Check whether the key sets of two maps are disjoint
--   (i.e. their <a>intersection</a> is empty).
--   
--   <pre>
--   disjoint (fromList [(2,'a')]) (fromList [(1,()), (3,())])   == True
--   disjoint (fromList [(2,'a')]) (fromList [(1,'a'), (2,'b')]) == False
--   disjoint (fromList [])        (fromList [])                 == True
--   </pre>
--   
--   <pre>
--   disjoint a b == null (intersection a b)
--   </pre>
disjoint :: Word64Map a -> Word64Map b -> Bool

-- | Relate the keys of one map to the values of the other, by using the
--   values of the former as keys for lookups in the latter.
--   
--   Complexity: &lt;math&gt;, where &lt;math&gt; is the size of the first
--   argument
--   
--   <pre>
--   compose (fromList [('a', "A"), ('b', "B")]) (fromList [(1,'a'),(2,'b'),(3,'z')]) = fromList [(1,"A"),(2,"B")]
--   </pre>
--   
--   <pre>
--   (<a>compose</a> bc ab <a>!?</a>) = (bc <a>!?</a>) &lt;=&lt; (ab <a>!?</a>)
--   </pre>
--   
--   <b>Note:</b> Prior to v0.6.4, <a>Data.Word64Map.Strict</a> exposed a
--   version of <a>compose</a> that forced the values of the output
--   <a>Word64Map</a>. This version does not force these values.
compose :: Word64Map c -> Word64Map Word64 -> Word64Map c

-- | &lt;math&gt;. A high-performance universal combining function. Using
--   <a>mergeWithKey</a>, all combining functions can be defined without
--   any loss of efficiency (with exception of <a>union</a>,
--   <a>difference</a> and <a>intersection</a>, where sharing of some nodes
--   is lost with <a>mergeWithKey</a>).
--   
--   Please make sure you know what is going on when using
--   <a>mergeWithKey</a>, otherwise you can be surprised by unexpected code
--   growth or even corruption of the data structure.
--   
--   When <a>mergeWithKey</a> is given three arguments, it is inlined to
--   the call site. You should therefore use <a>mergeWithKey</a> only to
--   define your custom combining functions. For example, you could define
--   <a>unionWithKey</a>, <a>differenceWithKey</a> and
--   <a>intersectionWithKey</a> as
--   
--   <pre>
--   myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
--   myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
--   myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2
--   </pre>
--   
--   When calling <tt><a>mergeWithKey</a> combine only1 only2</tt>, a
--   function combining two <a>Word64Map</a>s is created, such that
--   
--   <ul>
--   <li>if a key is present in both maps, it is passed with both
--   corresponding values to the <tt>combine</tt> function. Depending on
--   the result, the key is either present in the result with specified
--   value, or is left out;</li>
--   <li>a nonempty subtree present only in the first map is passed to
--   <tt>only1</tt> and the output is added to the result;</li>
--   <li>a nonempty subtree present only in the second map is passed to
--   <tt>only2</tt> and the output is added to the result.</li>
--   </ul>
--   
--   The <tt>only1</tt> and <tt>only2</tt> methods <i>must return a map
--   with a subset (possibly empty) of the keys of the given map</i>. The
--   values can be modified arbitrarily. Most common variants of
--   <tt>only1</tt> and <tt>only2</tt> are <a>id</a> and <tt><a>const</a>
--   <a>empty</a></tt>, but for example <tt><a>map</a> f</tt> or
--   <tt><a>filterWithKey</a> f</tt> could be used for any <tt>f</tt>.
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (Word64Map a -> Word64Map c) -> (Word64Map b -> Word64Map c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]
--   </pre>
map :: (a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]
--   </pre>
mapWithKey :: (Key -> a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. <tt><a>traverseWithKey</a> f s == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <pre>
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing
--   </pre>
traverseWithKey :: Applicative t => (Key -> a -> t b) -> Word64Map a -> t (Word64Map b)

-- | &lt;math&gt;. Traverse keys/values and collect the <a>Just</a>
--   results.
traverseMaybeWithKey :: Applicative f => (Key -> a -> f (Maybe b)) -> Word64Map a -> f (Word64Map b)

-- | &lt;math&gt;. The function <tt><a>mapAccum</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumWithKey</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumRWithKey</a></tt> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   <pre>
--   mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
--   mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"
--   </pre>
mapKeys :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has slightly better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   </pre>
mapKeysMonotonic :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"
--   </pre>
foldrWithKey :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
--   
--   <pre>
--   let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"
--   </pre>
foldlWithKey :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   monoid, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Monoid m => (Key -> a -> m) -> Word64Map a -> m

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. A strict version of <a>foldrWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldrWithKey' :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldlWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldlWithKey' :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
--   
--   <pre>
--   elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
--   elems empty == []
--   </pre>
elems :: Word64Map a -> [a]

-- | &lt;math&gt;. Return all keys of the map in ascending order. Subject
--   to list fusion.
--   
--   <pre>
--   keys (fromList [(5,"a"), (3,"b")]) == [3,5]
--   keys empty == []
--   </pre>
keys :: Word64Map a -> [Key]

-- | &lt;math&gt;. An alias for <a>toAscList</a>. Returns all key/value
--   pairs in the map in ascending key order. Subject to list fusion.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. The set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [(5,"a"), (3,"b")]) == Data.Word64Set.fromList [3,5]
--   keysSet empty == Data.Word64Set.empty
--   </pre>
keysSet :: Word64Map a -> Word64Set

-- | &lt;math&gt;. Convert the map to a list of key/value pairs. Subject to
--   list fusion.
--   
--   <pre>
--   toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   toList empty == []
--   </pre>
toList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in ascending order. Subject to list fusion.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in descending order. Subject to list fusion.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Filter all values that satisfy some predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
--   filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty
--   </pre>
filter :: (a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Filter all keys/values that satisfy some predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
filterWithKey :: (Key -> a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The restriction of a map to the keys in a set.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`member`</a> s) m
--   </pre>
restrictKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Remove all the keys in a given set from a map.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`notMember`</a> s) m
--   </pre>
withoutKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partition :: (a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partitionWithKey :: (Key -> a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> (p . fst) . <a>toList</a>
--   takeWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> (p . fst) . <a>toList</a>
--   dropWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Divide a map at the point where a predicate on the keys
--   stops holding. The user is responsible for ensuring that for all
--   <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partitionWithKey</a> (\k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (Key -> a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])
--   
--   mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--   </pre>
mapEither :: (a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])
--   </pre>
mapEitherWithKey :: (Key -> a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where all keys in <tt>map1</tt> are lower than
--   <tt>k</tt> and all keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
--   split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
--   split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
--   split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)
--   </pre>
split :: Key -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot key was found in the original map.
--   
--   <pre>
--   splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
--   splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
--   splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
--   splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
--   splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)
--   </pre>
splitLookup :: Key -> Word64Map a -> (Word64Map a, Maybe a, Word64Map a)

-- | &lt;math&gt;. Decompose a map into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList (zip [1..6::Int] ['a'..])) ==
--     [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d'),(5,'e'),(6,'f')]]
--   </pre>
--   
--   <pre>
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: Word64Map a -> [Word64Map a]

-- | &lt;math&gt;. Is this a submap? Defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. The expression (<tt><a>isSubmapOfBy</a> f m1 m2</tt>)
--   returns <a>True</a> if all keys in <tt>m1</tt> are in <tt>m2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   </pre>
isSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a>
--   (==)</tt>).
isProperSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns
--   <a>True</a> when <tt>keys m1</tt> and <tt>keys m2</tt> are not equal,
--   all keys in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt>
--   returns <a>True</a> when applied to their respective values. For
--   example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
--   </pre>
isProperSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. The minimal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMin :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMax :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The minimal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>minViewWithKey</a> if the map may be empty.
findMin :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>maxViewWithKey</a> if the map may be empty.
findMax :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. Delete the minimal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMin :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete the maximal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMax :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete and find the minimal element. This function
--   throws an error if the map is empty. Use <a>minViewWithKey</a> if the
--   map may be empty.
deleteFindMin :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Delete and find the maximal element. This function
--   throws an error if the map is empty. Use <a>maxViewWithKey</a> if the
--   map may be empty.
deleteFindMax :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMinWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMaxWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Retrieves the minimal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
minView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
maxView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the minimal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)


-- | <h1>Finite Word64 Maps (strict interface)</h1>
--   
--   The <tt><a>Word64Map</a> v</tt> type represents a finite map
--   (sometimes called a dictionary) from key of type <tt>Word64</tt> to
--   values of type <tt>v</tt>.
--   
--   Each function in this module is careful to force values before
--   installing them in an <a>Word64Map</a>. This is usually more efficient
--   when laziness is not necessary. When laziness <i>is</i> required, use
--   the functions in <a>Data.Word64Map.Lazy</a>.
--   
--   In particular, the functions in this module obey the following law:
--   
--   <ul>
--   <li>If all values stored in all maps in the arguments are in WHNF,
--   then all values stored in all maps in the results will be in WHNF once
--   those maps are evaluated.</li>
--   </ul>
--   
--   For a walkthrough of the most commonly used functions see the <a>maps
--   introduction</a>.
--   
--   This module is intended to be imported qualified, to avoid name
--   clashes with Prelude functions:
--   
--   <pre>
--   import Data.Word64Map.Strict (Word64Map)
--   import qualified Data.Word64Map.Strict as Word64Map
--   </pre>
--   
--   Note that the implementation is generally <i>left-biased</i>.
--   Functions that take two maps as arguments and combine them, such as
--   <a>union</a> and <a>intersection</a>, prefer the values in the first
--   argument to those in the second.
--   
--   <h2>Detailed performance information</h2>
--   
--   The amortized running time is given for each operation, with
--   &lt;math&gt; referring to the number of entries in the map and
--   &lt;math&gt; referring to the number of bits in an <tt>Word64</tt>
--   (64).
--   
--   Benchmarks comparing <a>Data.Word64Map.Strict</a> with other
--   dictionary implementations can be found at
--   <a>https://github.com/haskell-perf/dictionaries</a>.
--   
--   <h2>Warning</h2>
--   
--   The <a>Word64Map</a> type is shared between the lazy and strict
--   modules, meaning that the same <a>Word64Map</a> value can be passed to
--   functions in both modules. This means that the <tt>Functor</tt>,
--   <tt>Traversable</tt> and <a>Data</a> instances are the same as for the
--   <a>Data.Word64Map.Lazy</a> module, so if they are used the resulting
--   map may contain suspended values (thunks).
--   
--   <h2>Implementation</h2>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. Additionally, benchmarks show
--   that it is also (much) faster on insertions and deletions when
--   compared to a generic size-balanced map implementation (see
--   <a>Data.Map</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
module GHC.Data.Word64Map.Strict

-- | A map of integers to values <tt>a</tt>.
data Word64Map a
type Key = Word64

-- | &lt;math&gt;. The empty map.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: Word64Map a

-- | &lt;math&gt;. A map of one element.
--   
--   <pre>
--   singleton 1 'a'        == fromList [(1, 'a')]
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: Key -> a -> Word64Map a

-- | &lt;math&gt;. Build a map from a set of keys and a function which for
--   each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; replicate k 'a') (Data.Word64Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
--   fromSet undefined Data.Word64Set.empty == empty
--   </pre>
fromSet :: (Key -> a) -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs.
--   
--   <pre>
--   fromList [] == empty
--   fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
--   fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]
--   </pre>
fromList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs with a
--   combining function. See also fromAscListWithKey'.
--   
--   <pre>
--   let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   fromListWithKey f [] == empty
--   </pre>
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   </pre>
fromAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order and all distinct. <i>The precondition
--   (input list is strictly ascending) is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   </pre>
fromDistinctAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Insert a new key/value pair in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><a>insertWith</a> <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function. <tt><a>insertWith</a>
--   f key value mp</tt> will insert the pair (key, value) into <tt>mp</tt>
--   if key does not exist in the map. If the key does exist, the function
--   will insert <tt>f new_value old_value</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: (a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function.
--   <tt><a>insertWithKey</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert <tt>f key new_value
--   old_value</tt>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
--   insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
--   
--   If the key exists in the map, this function is lazy in <tt>value</tt>
--   but strict in the result of <tt>f</tt>.
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>insertLookupWithKey</a> f k x
--   map</tt>) is a pair where the first element is equal to
--   (<tt><a>lookup</a> k map</tt>) and the second element equal to
--   (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
--   insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
--   insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
--   insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])
--   </pre>
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. Delete a key and its value from the map. When the key is
--   not a member of the map, the original map is returned.
--   
--   <pre>
--   delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   delete 5 empty                         == empty
--   </pre>
delete :: Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjust ("new " ++) 7 empty                         == empty
--   </pre>
adjust :: (a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjustWithKey f 7 empty                         == empty
--   </pre>
adjustWithKey :: (Key -> a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
update :: (a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f k
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Lookup and update. The function returns original value,
--   if it is updated. This is different behavior than
--   <a>updateLookupWithKey</a>. Returns the original key value if the map
--   entry is deleted.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:new a")])
--   updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
--   updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")
--   </pre>
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k (<a>alter</a> f k m)
--   = f (<a>lookup</a> k m)</tt>.
alter :: (Maybe a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>alterF</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alterF</a>
--   can be used to inspect, insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k <a>$</a>
--   <a>alterF</a> f k m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; Word64Map String -&gt; IO (Word64Map String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   <a>alterF</a> is the most general operation for working with an
--   individual key that may or may not be in a given map.
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> Word64Map a -> f (Word64Map a)

-- | &lt;math&gt;. Lookup the value at a key in the map. See also
--   <a>lookup</a>.
lookup :: Key -> Word64Map a -> Maybe a

-- | &lt;math&gt;. Find the value at a key. Returns <a>Nothing</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] !? 1 == Nothing
--   fromList [(5,'a'), (3,'b')] !? 5 == Just 'a'
--   </pre>
(!?) :: Word64Map a -> Key -> Maybe a
infixl 9 !?

-- | &lt;math&gt;. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
--   fromList [(5,'a'), (3,'b')] ! 5 == 'a'
--   </pre>
(!) :: Word64Map a -> Key -> a

-- | &lt;math&gt;. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not an element of the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
--   findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'
--   </pre>
findWithDefault :: a -> Key -> Word64Map a -> a

-- | &lt;math&gt;. Is the key a member of the map?
--   
--   <pre>
--   member 5 (fromList [(5,'a'), (3,'b')]) == True
--   member 1 (fromList [(5,'a'), (3,'b')]) == False
--   </pre>
member :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Is the key not a member of the map?
--   
--   <pre>
--   notMember 5 (fromList [(5,'a'), (3,'b')]) == False
--   notMember 1 (fromList [(5,'a'), (3,'b')]) == True
--   </pre>
notMember :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Find largest key smaller than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   </pre>
lookupLT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find largest key smaller or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   </pre>
lookupLE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Is the map empty?
--   
--   <pre>
--   Data.Word64Map.null (empty)           == True
--   Data.Word64Map.null (singleton 1 'a') == False
--   </pre>
null :: Word64Map a -> Bool

-- | &lt;math&gt;. Number of elements in the map.
--   
--   <pre>
--   size empty                                   == 0
--   size (singleton 1 'a')                       == 1
--   size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3
--   </pre>
size :: Word64Map a -> Int

-- | &lt;math&gt;. The (left-biased) union of two maps. It prefers the
--   first map when duplicate keys are encountered, i.e. (<tt><a>union</a>
--   == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]
--   </pre>
unionWith :: (a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]
--   </pre>
unionWithKey :: (Key -> a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | The union of a list of maps.
--   
--   <pre>
--   unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
--       == fromList [(3, "B3"), (5, "A3"), (7, "C")]
--   </pre>
unions :: Foldable f => f (Word64Map a) -> Word64Map a

-- | The union of a list of maps, with a combining operation.
--   
--   <pre>
--   unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]
--   </pre>
unionsWith :: Foldable f => (a -> a -> a) -> f (Word64Map a) -> Word64Map a

-- | &lt;math&gt;. Difference between two maps (based on keys).
--   
--   <pre>
--   difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"
--   </pre>
difference :: Word64Map a -> Word64Map b -> Word64Map a

-- | Same as <a>difference</a>.
(\\) :: Word64Map a -> Word64Map b -> Word64Map a
infixl 9 \\

-- | &lt;math&gt;. Difference with a combining function.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
--       == singleton 3 "b:B"
--   </pre>
differenceWith :: (a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
--       == singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: (Key -> a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The (left-biased) intersection of two maps (based on
--   keys).
--   
--   <pre>
--   intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"
--   </pre>
intersection :: Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"
--   </pre>
intersectionWith :: (a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: (Key -> a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Check whether the key sets of two maps are disjoint
--   (i.e. their <a>intersection</a> is empty).
--   
--   <pre>
--   disjoint (fromList [(2,'a')]) (fromList [(1,()), (3,())])   == True
--   disjoint (fromList [(2,'a')]) (fromList [(1,'a'), (2,'b')]) == False
--   disjoint (fromList [])        (fromList [])                 == True
--   </pre>
--   
--   <pre>
--   disjoint a b == null (intersection a b)
--   </pre>
disjoint :: Word64Map a -> Word64Map b -> Bool

-- | Relate the keys of one map to the values of the other, by using the
--   values of the former as keys for lookups in the latter.
--   
--   Complexity: &lt;math&gt;, where &lt;math&gt; is the size of the first
--   argument
--   
--   <pre>
--   compose (fromList [('a', "A"), ('b', "B")]) (fromList [(1,'a'),(2,'b'),(3,'z')]) = fromList [(1,"A"),(2,"B")]
--   </pre>
--   
--   <pre>
--   (<a>compose</a> bc ab <a>!?</a>) = (bc <a>!?</a>) &lt;=&lt; (ab <a>!?</a>)
--   </pre>
--   
--   <b>Note:</b> Prior to v0.6.4, <a>Data.Word64Map.Strict</a> exposed a
--   version of <a>compose</a> that forced the values of the output
--   <a>Word64Map</a>. This version does not force these values.
compose :: Word64Map c -> Word64Map Word64 -> Word64Map c

-- | &lt;math&gt;. A high-performance universal combining function. Using
--   <a>mergeWithKey</a>, all combining functions can be defined without
--   any loss of efficiency (with exception of <a>union</a>,
--   <a>difference</a> and <a>intersection</a>, where sharing of some nodes
--   is lost with <a>mergeWithKey</a>).
--   
--   Please make sure you know what is going on when using
--   <a>mergeWithKey</a>, otherwise you can be surprised by unexpected code
--   growth or even corruption of the data structure.
--   
--   When <a>mergeWithKey</a> is given three arguments, it is inlined to
--   the call site. You should therefore use <a>mergeWithKey</a> only to
--   define your custom combining functions. For example, you could define
--   <a>unionWithKey</a>, <a>differenceWithKey</a> and
--   <a>intersectionWithKey</a> as
--   
--   <pre>
--   myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
--   myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
--   myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2
--   </pre>
--   
--   When calling <tt><a>mergeWithKey</a> combine only1 only2</tt>, a
--   function combining two <a>Word64Map</a>s is created, such that
--   
--   <ul>
--   <li>if a key is present in both maps, it is passed with both
--   corresponding values to the <tt>combine</tt> function. Depending on
--   the result, the key is either present in the result with specified
--   value, or is left out;</li>
--   <li>a nonempty subtree present only in the first map is passed to
--   <tt>only1</tt> and the output is added to the result;</li>
--   <li>a nonempty subtree present only in the second map is passed to
--   <tt>only2</tt> and the output is added to the result.</li>
--   </ul>
--   
--   The <tt>only1</tt> and <tt>only2</tt> methods <i>must return a map
--   with a subset (possibly empty) of the keys of the given map</i>. The
--   values can be modified arbitrarily. Most common variants of
--   <tt>only1</tt> and <tt>only2</tt> are <a>id</a> and <tt><a>const</a>
--   <a>empty</a></tt>, but for example <tt><a>map</a> f</tt> or
--   <tt><a>filterWithKey</a> f</tt> could be used for any <tt>f</tt>.
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (Word64Map a -> Word64Map c) -> (Word64Map b -> Word64Map c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]
--   </pre>
map :: (a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]
--   </pre>
mapWithKey :: (Key -> a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. <tt><a>traverseWithKey</a> f s == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <pre>
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing
--   </pre>
traverseWithKey :: Applicative t => (Key -> a -> t b) -> Word64Map a -> t (Word64Map b)

-- | &lt;math&gt;. Traverse keys/values and collect the <a>Just</a>
--   results.
traverseMaybeWithKey :: Applicative f => (Key -> a -> f (Maybe b)) -> Word64Map a -> f (Word64Map b)

-- | &lt;math&gt;. The function <tt><a>mapAccum</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumWithKey</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumRWithKey</a></tt> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   <pre>
--   mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
--   mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"
--   </pre>
mapKeys :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has slightly better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   </pre>
mapKeysMonotonic :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"
--   </pre>
foldrWithKey :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
--   
--   <pre>
--   let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"
--   </pre>
foldlWithKey :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   monoid, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Monoid m => (Key -> a -> m) -> Word64Map a -> m

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. A strict version of <a>foldrWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldrWithKey' :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldlWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldlWithKey' :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
--   
--   <pre>
--   elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
--   elems empty == []
--   </pre>
elems :: Word64Map a -> [a]

-- | &lt;math&gt;. Return all keys of the map in ascending order. Subject
--   to list fusion.
--   
--   <pre>
--   keys (fromList [(5,"a"), (3,"b")]) == [3,5]
--   keys empty == []
--   </pre>
keys :: Word64Map a -> [Key]

-- | &lt;math&gt;. An alias for <a>toAscList</a>. Returns all key/value
--   pairs in the map in ascending key order. Subject to list fusion.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. The set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [(5,"a"), (3,"b")]) == Data.Word64Set.fromList [3,5]
--   keysSet empty == Data.Word64Set.empty
--   </pre>
keysSet :: Word64Map a -> Word64Set

-- | &lt;math&gt;. Convert the map to a list of key/value pairs. Subject to
--   list fusion.
--   
--   <pre>
--   toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   toList empty == []
--   </pre>
toList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in ascending order. Subject to list fusion.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in descending order. Subject to list fusion.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Filter all values that satisfy some predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
--   filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty
--   </pre>
filter :: (a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Filter all keys/values that satisfy some predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
filterWithKey :: (Key -> a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The restriction of a map to the keys in a set.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`member`</a> s) m
--   </pre>
restrictKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Remove all the keys in a given set from a map.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`notMember`</a> s) m
--   </pre>
withoutKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partition :: (a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partitionWithKey :: (Key -> a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> (p . fst) . <a>toList</a>
--   takeWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> (p . fst) . <a>toList</a>
--   dropWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Divide a map at the point where a predicate on the keys
--   stops holding. The user is responsible for ensuring that for all
--   <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partitionWithKey</a> (\k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (Key -> a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])
--   
--   mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--   </pre>
mapEither :: (a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])
--   </pre>
mapEitherWithKey :: (Key -> a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where all keys in <tt>map1</tt> are lower than
--   <tt>k</tt> and all keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
--   split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
--   split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
--   split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)
--   </pre>
split :: Key -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot key was found in the original map.
--   
--   <pre>
--   splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
--   splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
--   splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
--   splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
--   splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)
--   </pre>
splitLookup :: Key -> Word64Map a -> (Word64Map a, Maybe a, Word64Map a)

-- | &lt;math&gt;. Decompose a map into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList (zip [1..6::Int] ['a'..])) ==
--     [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d'),(5,'e'),(6,'f')]]
--   </pre>
--   
--   <pre>
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: Word64Map a -> [Word64Map a]

-- | &lt;math&gt;. Is this a submap? Defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. The expression (<tt><a>isSubmapOfBy</a> f m1 m2</tt>)
--   returns <a>True</a> if all keys in <tt>m1</tt> are in <tt>m2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   </pre>
isSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a>
--   (==)</tt>).
isProperSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns
--   <a>True</a> when <tt>keys m1</tt> and <tt>keys m2</tt> are not equal,
--   all keys in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt>
--   returns <a>True</a> when applied to their respective values. For
--   example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
--   </pre>
isProperSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. The minimal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMin :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMax :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The minimal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>minViewWithKey</a> if the map may be empty.
findMin :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>maxViewWithKey</a> if the map may be empty.
findMax :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. Delete the minimal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMin :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete the maximal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMax :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete and find the minimal element. This function
--   throws an error if the map is empty. Use <a>minViewWithKey</a> if the
--   map may be empty.
deleteFindMin :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Delete and find the maximal element. This function
--   throws an error if the map is empty. Use <a>maxViewWithKey</a> if the
--   map may be empty.
deleteFindMax :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMinWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMaxWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Retrieves the minimal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
minView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
maxView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the minimal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)


-- | <h1>Finite Word64 Maps (lazy interface)</h1>
--   
--   The <tt><a>Word64Map</a> v</tt> type represents a finite map
--   (sometimes called a dictionary) from keys of type <tt>Word64</tt> to
--   values of type <tt>v</tt>.
--   
--   The functions in <a>Data.Word64Map.Strict</a> are careful to force
--   values before installing them in an <a>Word64Map</a>. This is usually
--   more efficient in cases where laziness is not essential. The functions
--   in this module do not do so.
--   
--   For a walkthrough of the most commonly used functions see the <a>maps
--   introduction</a>.
--   
--   This module is intended to be imported qualified, to avoid name
--   clashes with Prelude functions:
--   
--   <pre>
--   import Data.Word64Map.Lazy (Word64Map)
--   import qualified Data.Word64Map.Lazy as Word64Map
--   </pre>
--   
--   Note that the implementation is generally <i>left-biased</i>.
--   Functions that take two maps as arguments and combine them, such as
--   <a>union</a> and <a>intersection</a>, prefer the values in the first
--   argument to those in the second.
--   
--   <h2>Detailed performance information</h2>
--   
--   The amortized running time is given for each operation, with
--   &lt;math&gt; referring to the number of entries in the map and
--   &lt;math&gt; referring to the number of bits in an <tt>Word64</tt>
--   (64).
--   
--   Benchmarks comparing <a>Data.Word64Map.Lazy</a> with other dictionary
--   implementations can be found at
--   <a>https://github.com/haskell-perf/dictionaries</a>.
--   
--   <h2>Implementation</h2>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. Additionally, benchmarks show
--   that it is also (much) faster on insertions and deletions when
--   compared to a generic size-balanced map implementation (see
--   <a>Data.Map</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
module GHC.Data.Word64Map.Lazy

-- | A map of integers to values <tt>a</tt>.
data Word64Map a
type Key = Word64

-- | &lt;math&gt;. The empty map.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: Word64Map a

-- | &lt;math&gt;. A map of one element.
--   
--   <pre>
--   singleton 1 'a'        == fromList [(1, 'a')]
--   size (singleton 1 'a') == 1
--   </pre>
singleton :: Key -> a -> Word64Map a

-- | &lt;math&gt;. Build a map from a set of keys and a function which for
--   each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; replicate k 'a') (Data.Word64Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
--   fromSet undefined Data.Word64Set.empty == empty
--   </pre>
fromSet :: (Key -> a) -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs.
--   
--   <pre>
--   fromList [] == empty
--   fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
--   fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]
--   </pre>
fromList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Create a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "ab"), (5, "cba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs with a
--   combining function. See also fromAscListWithKey'.
--   
--   <pre>
--   let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value
--   fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]
--   fromListWithKey f [] == empty
--   </pre>
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   </pre>
fromAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order, with a combining function on equal keys.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "5:b|a")]
--   </pre>
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Build a map from a list of key/value pairs where the
--   keys are in ascending order and all distinct. <i>The precondition
--   (input list is strictly ascending) is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   </pre>
fromDistinctAscList :: [(Key, a)] -> Word64Map a

-- | &lt;math&gt;. Insert a new key/value pair in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><a>insertWith</a> <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function. <tt><a>insertWith</a>
--   f key value mp</tt> will insert the pair (key, value) into <tt>mp</tt>
--   if key does not exist in the map. If the key does exist, the function
--   will insert <tt>f new_value old_value</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: (a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Insert with a combining function.
--   <tt><a>insertWithKey</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert <tt>f key new_value
--   old_value</tt>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
--   insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>insertLookupWithKey</a> f k x
--   map</tt>) is a pair where the first element is equal to
--   (<tt><a>lookup</a> k map</tt>) and the second element equal to
--   (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
--   insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
--   insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
--   insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])
--   </pre>
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. Delete a key and its value from the map. When the key is
--   not a member of the map, the original map is returned.
--   
--   <pre>
--   delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   delete 5 empty                         == empty
--   </pre>
delete :: Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjust ("new " ++) 7 empty                         == empty
--   </pre>
adjust :: (a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjustWithKey f 7 empty                         == empty
--   </pre>
adjustWithKey :: (Key -> a -> a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
update :: (a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>update</a> f k map</tt>) updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f k
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Lookup and update. The function returns original value,
--   if it is updated. This is different behavior than
--   <a>updateLookupWithKey</a>. Returns the original key value if the map
--   entry is deleted.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:new a")])
--   updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
--   updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")
--   </pre>
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> Word64Map a -> (Maybe a, Word64Map a)

-- | &lt;math&gt;. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k (<a>alter</a> f k m)
--   = f (<a>lookup</a> k m)</tt>.
alter :: (Maybe a -> Maybe a) -> Key -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The expression (<tt><a>alterF</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alterF</a>
--   can be used to inspect, insert, delete, or update a value in an
--   <a>Word64Map</a>. In short : <tt><a>lookup</a> k <a>$</a>
--   <a>alterF</a> f k m = f (<a>lookup</a> k m)</tt>.
--   
--   Example:
--   
--   <pre>
--   interactiveAlter :: Int -&gt; Word64Map String -&gt; IO (Word64Map String)
--   interactiveAlter k m = alterF f k m where
--     f Nothing = do
--        putStrLn $ show k ++
--            " was not found in the map. Would you like to add it?"
--        getUserResponse1 :: IO (Maybe String)
--     f (Just old) = do
--        putStrLn $ "The key is currently bound to " ++ show old ++
--            ". Would you like to change or delete it?"
--        getUserResponse2 :: IO (Maybe String)
--   </pre>
--   
--   <a>alterF</a> is the most general operation for working with an
--   individual key that may or may not be in a given map.
--   
--   Note: <a>alterF</a> is a flipped version of the <tt>at</tt> combinator
--   from <tt>Control.Lens.At</tt>.
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> Word64Map a -> f (Word64Map a)

-- | &lt;math&gt;. Lookup the value at a key in the map. See also
--   <a>lookup</a>.
lookup :: Key -> Word64Map a -> Maybe a

-- | &lt;math&gt;. Find the value at a key. Returns <a>Nothing</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] !? 1 == Nothing
--   fromList [(5,'a'), (3,'b')] !? 5 == Just 'a'
--   </pre>
(!?) :: Word64Map a -> Key -> Maybe a
infixl 9 !?

-- | &lt;math&gt;. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
--   fromList [(5,'a'), (3,'b')] ! 5 == 'a'
--   </pre>
(!) :: Word64Map a -> Key -> a

-- | &lt;math&gt;. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not an element of the map.
--   
--   <pre>
--   findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
--   findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'
--   </pre>
findWithDefault :: a -> Key -> Word64Map a -> a

-- | &lt;math&gt;. Is the key a member of the map?
--   
--   <pre>
--   member 5 (fromList [(5,'a'), (3,'b')]) == True
--   member 1 (fromList [(5,'a'), (3,'b')]) == False
--   </pre>
member :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Is the key not a member of the map?
--   
--   <pre>
--   notMember 5 (fromList [(5,'a'), (3,'b')]) == False
--   notMember 1 (fromList [(5,'a'), (3,'b')]) == True
--   </pre>
notMember :: Key -> Word64Map a -> Bool

-- | &lt;math&gt;. Find largest key smaller than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   </pre>
lookupLT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGT :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find largest key smaller or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
--   lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   </pre>
lookupLE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Find smallest key greater or equal to the given one and
--   return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
--   lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
--   lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing
--   </pre>
lookupGE :: Key -> Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. Is the map empty?
--   
--   <pre>
--   Data.Word64Map.null (empty)           == True
--   Data.Word64Map.null (singleton 1 'a') == False
--   </pre>
null :: Word64Map a -> Bool

-- | &lt;math&gt;. Number of elements in the map.
--   
--   <pre>
--   size empty                                   == 0
--   size (singleton 1 'a')                       == 1
--   size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3
--   </pre>
size :: Word64Map a -> Int

-- | &lt;math&gt;. The (left-biased) union of two maps. It prefers the
--   first map when duplicate keys are encountered, i.e. (<tt><a>union</a>
--   == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]
--   </pre>
unionWith :: (a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The union with a combining function.
--   
--   <pre>
--   let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
--   unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]
--   </pre>
unionWithKey :: (Key -> a -> a -> a) -> Word64Map a -> Word64Map a -> Word64Map a

-- | The union of a list of maps.
--   
--   <pre>
--   unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "b"), (5, "a"), (7, "C")]
--   unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
--       == fromList [(3, "B3"), (5, "A3"), (7, "C")]
--   </pre>
unions :: Foldable f => f (Word64Map a) -> Word64Map a

-- | The union of a list of maps, with a combining operation.
--   
--   <pre>
--   unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
--       == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]
--   </pre>
unionsWith :: Foldable f => (a -> a -> a) -> f (Word64Map a) -> Word64Map a

-- | &lt;math&gt;. Difference between two maps (based on keys).
--   
--   <pre>
--   difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"
--   </pre>
difference :: Word64Map a -> Word64Map b -> Word64Map a

-- | Same as <a>difference</a>.
(\\) :: Word64Map a -> Word64Map b -> Word64Map a
infixl 9 \\

-- | &lt;math&gt;. Difference with a combining function.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
--       == singleton 3 "b:B"
--   </pre>
differenceWith :: (a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. Difference with a combining function. When two equal
--   keys are encountered, the combining function is applied to the key and
--   both values. If it returns <a>Nothing</a>, the element is discarded
--   (proper set difference). If it returns (<tt><a>Just</a> y</tt>), the
--   element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
--       == singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: (Key -> a -> b -> Maybe a) -> Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The (left-biased) intersection of two maps (based on
--   keys).
--   
--   <pre>
--   intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"
--   </pre>
intersection :: Word64Map a -> Word64Map b -> Word64Map a

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"
--   </pre>
intersectionWith :: (a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. The intersection with a combining function.
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: (Key -> a -> b -> c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Check whether the key sets of two maps are disjoint
--   (i.e. their <a>intersection</a> is empty).
--   
--   <pre>
--   disjoint (fromList [(2,'a')]) (fromList [(1,()), (3,())])   == True
--   disjoint (fromList [(2,'a')]) (fromList [(1,'a'), (2,'b')]) == False
--   disjoint (fromList [])        (fromList [])                 == True
--   </pre>
--   
--   <pre>
--   disjoint a b == null (intersection a b)
--   </pre>
disjoint :: Word64Map a -> Word64Map b -> Bool

-- | Relate the keys of one map to the values of the other, by using the
--   values of the former as keys for lookups in the latter.
--   
--   Complexity: &lt;math&gt;, where &lt;math&gt; is the size of the first
--   argument
--   
--   <pre>
--   compose (fromList [('a', "A"), ('b', "B")]) (fromList [(1,'a'),(2,'b'),(3,'z')]) = fromList [(1,"A"),(2,"B")]
--   </pre>
--   
--   <pre>
--   (<a>compose</a> bc ab <a>!?</a>) = (bc <a>!?</a>) &lt;=&lt; (ab <a>!?</a>)
--   </pre>
--   
--   <b>Note:</b> Prior to v0.6.4, <a>Data.Word64Map.Strict</a> exposed a
--   version of <a>compose</a> that forced the values of the output
--   <a>Word64Map</a>. This version does not force these values.
compose :: Word64Map c -> Word64Map Word64 -> Word64Map c

-- | &lt;math&gt;. A high-performance universal combining function. Using
--   <a>mergeWithKey</a>, all combining functions can be defined without
--   any loss of efficiency (with exception of <a>union</a>,
--   <a>difference</a> and <a>intersection</a>, where sharing of some nodes
--   is lost with <a>mergeWithKey</a>).
--   
--   Please make sure you know what is going on when using
--   <a>mergeWithKey</a>, otherwise you can be surprised by unexpected code
--   growth or even corruption of the data structure.
--   
--   When <a>mergeWithKey</a> is given three arguments, it is inlined to
--   the call site. You should therefore use <a>mergeWithKey</a> only to
--   define your custom combining functions. For example, you could define
--   <a>unionWithKey</a>, <a>differenceWithKey</a> and
--   <a>intersectionWithKey</a> as
--   
--   <pre>
--   myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
--   myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
--   myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2
--   </pre>
--   
--   When calling <tt><a>mergeWithKey</a> combine only1 only2</tt>, a
--   function combining two <a>Word64Map</a>s is created, such that
--   
--   <ul>
--   <li>if a key is present in both maps, it is passed with both
--   corresponding values to the <tt>combine</tt> function. Depending on
--   the result, the key is either present in the result with specified
--   value, or is left out;</li>
--   <li>a nonempty subtree present only in the first map is passed to
--   <tt>only1</tt> and the output is added to the result;</li>
--   <li>a nonempty subtree present only in the second map is passed to
--   <tt>only2</tt> and the output is added to the result.</li>
--   </ul>
--   
--   The <tt>only1</tt> and <tt>only2</tt> methods <i>must return a map
--   with a subset (possibly empty) of the keys of the given map</i>. The
--   values can be modified arbitrarily. Most common variants of
--   <tt>only1</tt> and <tt>only2</tt> are <a>id</a> and <tt><a>const</a>
--   <a>empty</a></tt>, but for example <tt><a>map</a> f</tt> or
--   <tt><a>filterWithKey</a> f</tt> could be used for any <tt>f</tt>.
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (Word64Map a -> Word64Map c) -> (Word64Map b -> Word64Map c) -> Word64Map a -> Word64Map b -> Word64Map c

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]
--   </pre>
map :: (a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]
--   </pre>
mapWithKey :: (Key -> a -> b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. <tt><a>traverseWithKey</a> f s == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt> That is, behaves exactly like a regular
--   <a>traverse</a> except that the traversing function also has access to
--   the key associated with a value.
--   
--   <pre>
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
--   traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing
--   </pre>
traverseWithKey :: Applicative t => (Key -> a -> t b) -> Word64Map a -> t (Word64Map b)

-- | &lt;math&gt;. Traverse keys/values and collect the <a>Just</a>
--   results.
traverseMaybeWithKey :: Applicative f => (Key -> a -> f (Maybe b)) -> Word64Map a -> f (Word64Map b)

-- | &lt;math&gt;. The function <tt><a>mapAccum</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ b, b ++ "X")
--   mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccum :: (a -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumWithKey</a></tt> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
--   mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])
--   </pre>
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. The function <tt><a>mapAccumRWithKey</a></tt> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> Word64Map b -> (a, Word64Map c)

-- | &lt;math&gt;. <tt><a>mapKeys</a> f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   greatest of the original keys is retained.
--   
--   <pre>
--   mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
--   mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"
--   </pre>
mapKeys :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has slightly better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   </pre>
mapKeysMonotonic :: (Key -> Key) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   right-associative binary operator, such that <tt><a>foldrWithKey</a> f
--   z == <a>foldr</a> (<a>uncurry</a> f) z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"
--   </pre>
foldrWithKey :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   left-associative binary operator, such that <tt><a>foldlWithKey</a> f
--   z == <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
--   
--   <pre>
--   let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
--   foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"
--   </pre>
foldlWithKey :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Fold the keys and values in the map using the given
--   monoid, such that
--   
--   <pre>
--   <a>foldMapWithKey</a> f = <a>fold</a> . <a>mapWithKey</a> f
--   </pre>
--   
--   This can be an asymptotically faster than <a>foldrWithKey</a> or
--   <a>foldlWithKey</a> for some monoids.
foldMapWithKey :: Monoid m => (Key -> a -> m) -> Word64Map a -> m

-- | &lt;math&gt;. A strict version of <a>foldr</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldl</a>. Each application of
--   the operator is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. A strict version of <a>foldrWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldrWithKey' :: (Key -> a -> b -> b) -> b -> Word64Map a -> b

-- | &lt;math&gt;. A strict version of <a>foldlWithKey</a>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
foldlWithKey' :: (a -> Key -> b -> a) -> a -> Word64Map b -> a

-- | &lt;math&gt;. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
--   
--   <pre>
--   elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
--   elems empty == []
--   </pre>
elems :: Word64Map a -> [a]

-- | &lt;math&gt;. Return all keys of the map in ascending order. Subject
--   to list fusion.
--   
--   <pre>
--   keys (fromList [(5,"a"), (3,"b")]) == [3,5]
--   keys empty == []
--   </pre>
keys :: Word64Map a -> [Key]

-- | &lt;math&gt;. An alias for <a>toAscList</a>. Returns all key/value
--   pairs in the map in ascending key order. Subject to list fusion.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. The set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [(5,"a"), (3,"b")]) == Data.Word64Set.fromList [3,5]
--   keysSet empty == Data.Word64Set.empty
--   </pre>
keysSet :: Word64Map a -> Word64Set

-- | &lt;math&gt;. Convert the map to a list of key/value pairs. Subject to
--   list fusion.
--   
--   <pre>
--   toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   toList empty == []
--   </pre>
toList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in ascending order. Subject to list fusion.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Convert the map to a list of key/value pairs where the
--   keys are in descending order. Subject to list fusion.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: Word64Map a -> [(Key, a)]

-- | &lt;math&gt;. Filter all values that satisfy some predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
--   filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty
--   </pre>
filter :: (a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Filter all keys/values that satisfy some predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
filterWithKey :: (Key -> a -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. The restriction of a map to the keys in a set.
--   
--   <pre>
--   m `restrictKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`member`</a> s) m
--   </pre>
restrictKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Remove all the keys in a given set from a map.
--   
--   <pre>
--   m `withoutKeys` s = <a>filterWithKey</a> (\k _ -&gt; k <a>`notMember`</a> s) m
--   </pre>
withoutKeys :: Word64Map a -> Word64Set -> Word64Map a

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partition :: (a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Partition the map according to some predicate. The first
--   map contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
--   partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partitionWithKey :: (Key -> a -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Take while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   takeWhileAntitone p = <a>fromDistinctAscList</a> . <a>takeWhile</a> (p . fst) . <a>toList</a>
--   takeWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; p k)
--   </pre>
takeWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Drop while a predicate on the keys holds. The user is
--   responsible for ensuring that for all <tt>Int</tt>s, <tt>j &lt; k
--   ==&gt; p j &gt;= p k</tt>. See note at <a>spanAntitone</a>.
--   
--   <pre>
--   dropWhileAntitone p = <a>fromDistinctAscList</a> . <a>dropWhile</a> (p . fst) . <a>toList</a>
--   dropWhileAntitone p = <a>filterWithKey</a> (\k _ -&gt; not (p k))
--   </pre>
dropWhileAntitone :: (Key -> Bool) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Divide a map at the point where a predicate on the keys
--   stops holding. The user is responsible for ensuring that for all
--   <tt>Int</tt>s, <tt>j &lt; k ==&gt; p j &gt;= p k</tt>.
--   
--   <pre>
--   spanAntitone p xs = (<a>takeWhileAntitone</a> p xs, <a>dropWhileAntitone</a> p xs)
--   spanAntitone p xs = <a>partitionWithKey</a> (\k _ -&gt; p k) xs
--   </pre>
--   
--   Note: if <tt>p</tt> is not actually antitone, then
--   <tt>spanAntitone</tt> will split the map at some <i>unspecified</i>
--   point.
spanAntitone :: (Key -> Bool) -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"
--   </pre>
mapMaybe :: (a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: (Key -> a -> Maybe b) -> Word64Map a -> Word64Map b

-- | &lt;math&gt;. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])
--   
--   mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--   </pre>
mapEither :: (a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])
--   </pre>
mapEitherWithKey :: (Key -> a -> Either b c) -> Word64Map a -> (Word64Map b, Word64Map c)

-- | &lt;math&gt;. The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where all keys in <tt>map1</tt> are lower than
--   <tt>k</tt> and all keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
--   split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
--   split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
--   split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)
--   </pre>
split :: Key -> Word64Map a -> (Word64Map a, Word64Map a)

-- | &lt;math&gt;. Performs a <a>split</a> but also returns whether the
--   pivot key was found in the original map.
--   
--   <pre>
--   splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
--   splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
--   splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
--   splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
--   splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)
--   </pre>
splitLookup :: Key -> Word64Map a -> (Word64Map a, Maybe a, Word64Map a)

-- | &lt;math&gt;. Decompose a map into pieces based on the structure of
--   the underlying tree. This function is useful for consuming a map in
--   parallel.
--   
--   No guarantee is made as to the sizes of the pieces; an internal, but
--   deterministic process determines this. However, it is guaranteed that
--   the pieces returned will be in ascending order (all elements in the
--   first submap less than all elements in the second, and so on).
--   
--   Examples:
--   
--   <pre>
--   splitRoot (fromList (zip [1..6::Int] ['a'..])) ==
--     [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d'),(5,'e'),(6,'f')]]
--   </pre>
--   
--   <pre>
--   splitRoot empty == []
--   </pre>
--   
--   Note that the current implementation does not return more than two
--   submaps, but you should not depend on this behaviour because it can
--   change in the future without notice.
splitRoot :: Word64Map a -> [Word64Map a]

-- | &lt;math&gt;. Is this a submap? Defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. The expression (<tt><a>isSubmapOfBy</a> f m1 m2</tt>)
--   returns <a>True</a> if all keys in <tt>m1</tt> are in <tt>m2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (&lt;) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   </pre>
isSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a>
--   (==)</tt>).
isProperSubmapOf :: Eq a => Word64Map a -> Word64Map a -> Bool

-- | &lt;math&gt;. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns
--   <a>True</a> when <tt>keys m1</tt> and <tt>keys m2</tt> are not equal,
--   all keys in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt>
--   returns <a>True</a> when applied to their respective values. For
--   example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
--   isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
--   isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
--   </pre>
isProperSubmapOfBy :: (a -> b -> Bool) -> Word64Map a -> Word64Map b -> Bool

-- | &lt;math&gt;. The minimal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMin :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Returns <a>Nothing</a> if
--   the map is empty.
lookupMax :: Word64Map a -> Maybe (Key, a)

-- | &lt;math&gt;. The minimal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>minViewWithKey</a> if the map may be empty.
findMin :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. The maximal key of the map. Calls <a>error</a> if the
--   map is empty. Use <a>maxViewWithKey</a> if the map may be empty.
findMax :: Word64Map a -> (Key, a)

-- | &lt;math&gt;. Delete the minimal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMin :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete the maximal key. Returns an empty map if the map
--   is empty.
--   
--   Note that this is a change of behaviour for consistency with
--   <a>Map</a> – versions prior to 0.5 threw an error if the
--   <a>Word64Map</a> was already empty.
deleteMax :: Word64Map a -> Word64Map a

-- | &lt;math&gt;. Delete and find the minimal element. This function
--   throws an error if the map is empty. Use <a>minViewWithKey</a> if the
--   map may be empty.
deleteFindMin :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Delete and find the maximal element. This function
--   throws an error if the map is empty. Use <a>maxViewWithKey</a> if the
--   map may be empty.
deleteFindMax :: Word64Map a -> ((Key, a), Word64Map a)

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMin :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMax :: (a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMinWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMaxWithKey :: (Key -> a -> Maybe a) -> Word64Map a -> Word64Map a

-- | &lt;math&gt;. Retrieves the minimal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
minView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal key of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
maxView :: Word64Map a -> Maybe (a, Word64Map a)

-- | &lt;math&gt;. Retrieves the minimal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)

-- | &lt;math&gt;. Retrieves the maximal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: Word64Map a -> Maybe ((Key, a), Word64Map a)


-- | An efficient implementation of maps from integer keys to values
--   (dictionaries).
--   
--   This module re-exports the value lazy <a>Data.Word64Map.Lazy</a> API,
--   plus several deprecated value strict functions. Please note that these
--   functions have different strictness properties than those in
--   <a>Data.Word64Map.Strict</a>: they only evaluate the result of the
--   combining function. For example, the default value to
--   <tt>insertWith'</tt> is only evaluated if the combining function is
--   called and uses it.
--   
--   These modules are intended to be imported qualified, to avoid name
--   clashes with Prelude functions, e.g.
--   
--   <pre>
--   import Data.Word64Map (Word64Map)
--   import qualified Data.Word64Map as Word64Map
--   </pre>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. However, my benchmarks show that
--   it is also (much) faster on insertions and deletions when compared to
--   a generic size-balanced map implementation (see <a>Data.Map</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452</a></li>
--   <li>D.R. Morrison, "<i>PATRICIA -- Practical Algorithm To Retrieve
--   Information Coded In Alphanumeric</i>", Journal of the ACM, 15(4),
--   October 1968, pages 514-534.</li>
--   </ul>
--   
--   Operation comments contain the operation time complexity in the Big-O
--   notation <a>http://en.wikipedia.org/wiki/Big_O_notation</a>. Many
--   operations have a worst-case complexity of &lt;math&gt;. This means
--   that the operation can become linear in the number of elements with a
--   maximum of &lt;math&gt;
module GHC.Data.Word64Map

module GHC.Utils.Exception

-- | <a>assert</a> was applied to <a>False</a>.
newtype () => AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data () => IOException

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data () => BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar

-- | An expression that didn't typecheck during compile time was called.
--   This is only possible with -fdefer-type-errors. The <tt>String</tt>
--   gives details about the failed type check.
newtype () => TypeError
TypeError :: String -> TypeError

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data () => SomeException
SomeException :: e -> SomeException

-- | Arithmetic exceptions.
data () => ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException

-- | This is thrown when the user calls <a>error</a>. The first
--   <tt>String</tt> is the argument given to <a>error</a>, second
--   <tt>String</tt> is the location.
data () => ErrorCall
ErrorCallWithLocation :: String -> String -> ErrorCall
pattern ErrorCall :: String -> ErrorCall

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data () => MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Exceptions generated by array operations
data () => ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | Asynchronous exceptions.
data () => AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception. GHC
--   currently throws this to the same thread that receives
--   <a>UserInterrupt</a>, but this may change in the future.</li>
--   <li>The GHC RTS currently can only recover from heap overflow if it
--   detects that an explicit memory limit (set via RTS flags). has been
--   exceeded. Currently, failure to allocate memory from the operating
--   system results in immediate termination of the program.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException

-- | Superclass for asynchronous exceptions.
data () => SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Compaction found an object that cannot be compacted. Functions cannot
--   be compacted, nor can mutable objects or pinned objects. See
--   <a>compact</a>.
newtype () => CompactionFailed
CompactionFailed :: String -> CompactionFailed

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data () => AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data () => Deadlock
Deadlock :: Deadlock

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data () => BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM

-- | Thrown when the program attempts to call <tt>atomically</tt>, from the
--   <tt>stm</tt> package, inside another call to <tt>atomically</tt>.
data () => NestedAtomically
NestedAtomically :: NestedAtomically

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
data () => NonTermination
NonTermination :: NonTermination

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called. The
--   <tt>String</tt> gives information about which method it was.
newtype () => NoMethodError
NoMethodError :: String -> NoMethodError

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record update.
newtype () => RecUpdError
RecUpdError :: String -> RecUpdError

-- | An uninitialised record field was used. The <tt>String</tt> gives
--   information about the source location where the record was
--   constructed.
newtype () => RecConError
RecConError :: String -> RecConError

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record selector.
newtype () => RecSelError
RecSelError :: String -> RecSelError

-- | A pattern match failed. The <tt>String</tt> gives information about
--   the source location of the pattern.
newtype () => PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail

-- | You need this when using <a>catches</a>.
data () => Handler a
Handler :: (e -> IO a) -> Handler a

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall (r :: RuntimeRep) (a :: TYPE r) e. Exception e => e -> a

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
--   
--   Bracket wraps the release action with <a>mask</a>, which is sufficient
--   to ensure that the release action executes to completion when it does
--   not invoke any interruptible actions, even in the presence of
--   asynchronous exceptions. For example, <tt>hClose</tt> is
--   uninterruptible when it is not racing other uses of the handle.
--   Similarly, closing a socket (from "network" package) is also
--   uninterruptible under similar conditions. An example of an
--   interruptible action is <a>killThread</a>. Completion of interruptible
--   release actions can be ensured by wrapping them in in
--   <a>uninterruptibleMask_</a>, but this risks making the program
--   non-responsive to <tt>Control-C</tt>, or timeouts. Another option is
--   to run the release action asynchronously in its own thread:
--   
--   <pre>
--   void $ uninterruptibleMask_ $ forkIO $ do { ... }
--   </pre>
--   
--   The resource will be released as soon as possible, but the thread that
--   invoked bracket will not block in an uninterruptible state.
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a new thread in an unmasked state use
--   <a>forkIOWithUnmask</a>.
mask :: ((forall a. () => IO a -> IO a) -> IO b) -> IO b

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` ()  ===&gt; throw e
--   throwIO e `seq` ()  ===&gt; ()
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other operations, whereas
--   <a>throw</a> does not. We say that <a>throwIO</a> throws *precise*
--   exceptions and <a>throw</a>, <a>error</a>, etc. all throw *imprecise*
--   exceptions. For example
--   
--   <pre>
--   throw e + error "boom" ===&gt; error "boom"
--   throw e + error "boom" ===&gt; throw e
--   </pre>
--   
--   are both valid reductions and the compiler may pick any (loop, even),
--   whereas
--   
--   <pre>
--   throwIO e &gt;&gt; error "boom" ===&gt; throwIO e
--   </pre>
--   
--   will always throw <tt>e</tt> when executed.
--   
--   See also the <a>GHC wiki page on precise exceptions</a> for a more
--   technical introduction to how GHC optimises around precise vs.
--   imprecise exceptions.
throwIO :: Exception e => e -> IO a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised then it will be propagated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propagated further up. If
--   you call it again, you might get the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | Allow asynchronous exceptions to be raised even inside <a>mask</a>,
--   making the operation interruptible (see the discussion of
--   "Interruptible operations" in <a>Exception</a>).
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
interruptible :: IO a -> IO a

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the computation.
onException :: IO a -> IO b -> IO a

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. () => IO a -> IO a) -> IO b) -> IO b

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: IO a -> IO b -> IO a

-- | Evaluate the argument to weak head normal form.
--   
--   <a>evaluate</a> is typically used to uncover any exceptions that a
--   lazy value may contain, and possibly handle them.
--   
--   <a>evaluate</a> only evaluates to <i>weak head normal form</i>. If
--   deeper evaluation is needed, the <tt>force</tt> function from
--   <tt>Control.DeepSeq</tt> may be handy:
--   
--   <pre>
--   evaluate $ force x
--   </pre>
--   
--   There is a subtle difference between <tt><a>evaluate</a> x</tt> and
--   <tt><a>return</a> <a>$!</a> x</tt>, analogous to the difference
--   between <a>throwIO</a> and <a>throw</a>. If the lazy value <tt>x</tt>
--   throws an exception, <tt><a>return</a> <a>$!</a> x</tt> will fail to
--   return an <a>IO</a> action and will throw an exception instead.
--   <tt><a>evaluate</a> x</tt>, on the other hand, always produces an
--   <a>IO</a> action; that action will throw an exception upon
--   <i>execution</i> iff <tt>x</tt> throws an exception upon
--   <i>evaluation</i>.
--   
--   The practical implication of this difference is that due to the
--   <i>imprecise exceptions</i> semantics,
--   
--   <pre>
--   (return $! error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   may throw either <tt>"foo"</tt> or <tt>"bar"</tt>, depending on the
--   optimizations performed by the compiler. On the other hand,
--   
--   <pre>
--   evaluate (error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   is guaranteed to throw <tt>"foo"</tt>.
--   
--   The rule of thumb is to use <a>evaluate</a> to force or handle
--   exceptions in lazy values. If, on the other hand, you are forcing a
--   lazy value for efficiency reasons only and do not care about
--   exceptions, you may use <tt><a>return</a> <a>$!</a> x</tt>.
evaluate :: a -> IO a

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | The function <a>catchJust</a> is like <a>catch</a>, but it takes an
--   extra argument which is an <i>exception predicate</i>, a function
--   which selects which type of exceptions we're interested in.
--   
--   <pre>
--   catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
--             (readFile f)
--             (\_ -&gt; do hPutStrLn stderr ("No such file: " ++ show f)
--                       return "")
--   </pre>
--   
--   Any other exceptions which are not matched by the predicate are
--   re-raised, and may be caught by an enclosing <a>catch</a>,
--   <a>catchJust</a>, etc.
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: Exception e => (e -> IO a) -> IO a -> IO a

-- | A version of <a>catchJust</a> with the arguments swapped around (see
--   <a>handle</a>).
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught (c.f. <a>catchJust</a>). If the exception
--   does not match the predicate, it is re-thrown.
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: IO a -> IO b -> IO c -> IO c

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | Sometimes you want to catch two different sorts of exception. You
--   could do something like
--   
--   <pre>
--   f = expr `catch` \ (ex :: ArithException) -&gt; handleArith ex
--            `catch` \ (ex :: IOException)    -&gt; handleIO    ex
--   </pre>
--   
--   However, there are a couple of problems with this approach. The first
--   is that having two exception handlers is inefficient. However, the
--   more serious issue is that the second exception handler will catch
--   exceptions in the first, e.g. in the example above, if
--   <tt>handleArith</tt> throws an <tt>IOException</tt> then the second
--   exception handler will catch it.
--   
--   Instead, we provide a function <a>catches</a>, which would be used
--   thus:
--   
--   <pre>
--   f = expr `catches` [Handler (\ (ex :: ArithException) -&gt; handleArith ex),
--                       Handler (\ (ex :: IOException)    -&gt; handleIO    ex)]
--   </pre>
catches :: IO a -> [Handler a] -> IO a

-- | When invoked inside <a>mask</a>, this function allows a masked
--   asynchronous exception to be raised, if one exists. It is equivalent
--   to performing an interruptible operation (see #interruptible), but
--   does not involve any actual blocking.
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
allowInterrupt :: IO ()
type ExceptionMonad m = (MonadCatch m, MonadThrow m, MonadMask m, MonadIO m)
catchIO :: IO a -> (IOException -> IO a) -> IO a
handleIO :: (IOException -> IO a) -> IO a -> IO a
tryIO :: IO a -> IO (Either IOException a)

module GHC.Utils.Fingerprint
readHexFingerprint :: String -> Fingerprint
fingerprintByteString :: ByteString -> Fingerprint
data () => Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
fingerprint0 :: Fingerprint
fingerprintFingerprints :: [Fingerprint] -> Fingerprint
fingerprintData :: Ptr Word8 -> Int -> IO Fingerprint
fingerprintString :: String -> Fingerprint

-- | Computes the hash of a given file. This function loops over the
--   handle, running in constant memory.
getFileHash :: FilePath -> IO Fingerprint


-- | Do not use global variables!
--   
--   Global variables are a hack. Do not use them if you can help it.
module GHC.Utils.GlobalVars
v_unsafeHasPprDebug :: IORef Bool
v_unsafeHasNoDebugOutput :: IORef Bool
v_unsafeHasNoStateHack :: IORef Bool
unsafeHasPprDebug :: Bool
unsafeHasNoDebugOutput :: Bool
unsafeHasNoStateHack :: Bool
global :: a -> IORef a
consIORef :: IORef [a] -> a -> IO ()
globalM :: IO a -> IORef a
sharedGlobal :: a -> (Ptr (IORef a) -> IO (Ptr (IORef a))) -> IORef a
sharedGlobalM :: IO a -> (Ptr (IORef a) -> IO (Ptr (IORef a))) -> IORef a

module GHC.Utils.IO.Unsafe
inlinePerformIO :: IO a -> a


-- | Defines a simple exception type and utilities to throw it. The
--   <a>PlainGhcException</a> type is a subset of the <a>GhcException</a>
--   type. It omits the exception constructors that involve pretty-printing
--   via <a>SDoc</a>.
--   
--   There are two reasons for this:
--   
--   <ol>
--   <li>To avoid import cycles / use of boot files.
--   <a>GHC.Utils.Outputable</a> has many transitive dependencies. To throw
--   exceptions from these modules, the functions here can be used without
--   introducing import cycles.</li>
--   <li>To reduce the number of modules that need to be compiled to object
--   code when loading GHC into GHCi. See #13101</li>
--   </ol>
module GHC.Utils.Panic.Plain

-- | This type is very similar to <a>GhcException</a>, but it omits the
--   constructors that involve pretty-printing via <a>SDoc</a>. Due to the
--   implementation of <a>fromException</a> for <a>GhcException</a>, this
--   type can be caught as a <a>GhcException</a>.
--   
--   Note that this should only be used for throwing exceptions, not for
--   catching, as <a>GhcException</a> will not be converted to this type
--   when catching.
data PlainGhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
PlainSignal :: Int -> PlainGhcException

-- | Prints the short usage msg after the error
PlainUsageError :: String -> PlainGhcException

-- | A problem with the command line arguments, but don't print usage.
PlainCmdLineError :: String -> PlainGhcException

-- | The <tt>impossible</tt> happened.
PlainPanic :: String -> PlainGhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
PlainSorry :: String -> PlainGhcException

-- | An installation problem.
PlainInstallationError :: String -> PlainGhcException

-- | An error in the user's code, probably.
PlainProgramError :: String -> PlainGhcException

-- | Append a description of the given exception to this string.
showPlainGhcException :: PlainGhcException -> ShowS

-- | Panics and asserts.
panic :: HasCallStack => String -> a

-- | Panics and asserts.
sorry :: HasCallStack => String -> a

-- | Panics and asserts.
pgmError :: HasCallStack => String -> a
cmdLineError :: String -> a
cmdLineErrorIO :: String -> IO a

-- | Throw a failed assertion exception for a given filename and line
--   number.
assertPanic :: String -> Int -> a
assert :: HasCallStack => Bool -> a -> a
assertM :: (HasCallStack, Monad m) => m Bool -> m ()
massert :: (HasCallStack, Applicative m) => Bool -> m ()
instance GHC.Exception.Type.Exception GHC.Utils.Panic.Plain.PlainGhcException
instance GHC.Show.Show GHC.Utils.Panic.Plain.PlainGhcException


-- | Highly random utility functions
module GHC.Utils.Misc

-- | Apply a function iff some condition is met.
applyWhen :: Bool -> (a -> a) -> a -> a

-- | Apply a function <tt>n</tt> times to a given value.
nTimes :: Int -> (a -> a) -> a -> a
const2 :: a -> b -> c -> a
zipEqual :: HasDebugCallStack => String -> [a] -> [b] -> [(a, b)]
zipWithEqual :: HasDebugCallStack => String -> (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3Equal :: HasDebugCallStack => String -> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
zipWith4Equal :: HasDebugCallStack => String -> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | <tt>stretchZipWith p z f xs ys</tt> stretches <tt>ys</tt> by inserting
--   <tt>z</tt> in the places where <tt>p</tt> returns <tt>True</tt>
stretchZipWith :: (a -> Bool) -> b -> (a -> b -> c) -> [a] -> [b] -> [c]
zipWithAndUnzip :: (a -> b -> (c, d)) -> [a] -> [b] -> ([c], [d])

-- | This has the effect of making the two lists have equal length by
--   dropping the tail of the longer one.
zipAndUnzip :: [a] -> [b] -> ([a], [b])

-- | <a>filterByList</a> takes a list of Bools and a list of some elements
--   and filters out these elements for which the corresponding value in
--   the list of Bools is False. This function does not check whether the
--   lists have equal length.
filterByList :: [Bool] -> [a] -> [a]

-- | <a>filterByLists</a> takes a list of Bools and two lists as input, and
--   outputs a new list consisting of elements from the last two input
--   lists. For each Bool in the list, if it is <a>True</a>, then it takes
--   an element from the former list. If it is <a>False</a>, it takes an
--   element from the latter list. The elements taken correspond to the
--   index of the Bool in its list. For example:
--   
--   <pre>
--   filterByLists [True, False, True, False] "abcd" "wxyz" = "axcz"
--   </pre>
--   
--   This function does not check whether the lists have equal length.
filterByLists :: [Bool] -> [a] -> [a] -> [a]

-- | <a>partitionByList</a> takes a list of Bools and a list of some
--   elements and partitions the list according to the list of Bools.
--   Elements corresponding to <a>True</a> go to the left; elements
--   corresponding to <a>False</a> go to the right. For example,
--   <tt>partitionByList [True, False, True] [1,2,3] == ([1,3], [2])</tt>
--   This function does not check whether the lists have equal length; when
--   one list runs out, the function stops.
partitionByList :: [Bool] -> [a] -> ([a], [a])
unzipWith :: (a -> b -> c) -> [(a, b)] -> [c]
mapFst :: Functor f => (a -> c) -> f (a, b) -> f (c, b)
mapSnd :: Functor f => (b -> c) -> f (a, b) -> f (a, c)
chkAppend :: [a] -> [a] -> [a]
mapAndUnzip :: (a -> (b, c)) -> [a] -> ([b], [c])
mapAndUnzip3 :: (a -> (b, c, d)) -> [a] -> ([b], [c], [d])

-- | Like filter, only it reverses the sense of the test
filterOut :: (a -> Bool) -> [a] -> [a]

-- | Uses a function to determine which of two output lists an input
--   element should join
partitionWith :: (a -> Either b c) -> [a] -> ([b], [c])
dropWhileEndLE :: (a -> Bool) -> [a] -> [a]

-- | <tt>spanEnd p l == reverse (span p (reverse l))</tt>. The first list
--   returns actually comes after the second list (when you look at the
--   input list).
spanEnd :: (a -> Bool) -> [a] -> ([a], [a])

-- | Get the last two elements in a list.
last2 :: [a] -> Maybe (a, a)
lastMaybe :: [a] -> Maybe a

-- | <tt>onJust x m f</tt> applies f to the value inside the Just or
--   returns the default.
onJust :: b -> Maybe a -> (a -> b) -> b

-- | A strict version of <a>foldl1</a>.
foldl1' :: HasCallStack => (a -> a -> a) -> [a] -> a
foldl2 :: (acc -> a -> b -> acc) -> acc -> [a] -> [b] -> acc
count :: (a -> Bool) -> [a] -> Int
countWhile :: (a -> Bool) -> [a] -> Int
all2 :: (a -> b -> Bool) -> [a] -> [b] -> Bool

-- | <pre>
--   (lengthExceeds xs n) = (length xs &gt; n)
--   </pre>
lengthExceeds :: [a] -> Int -> Bool

-- | <pre>
--   (lengthIs xs n) = (length xs == n)
--   </pre>
lengthIs :: [a] -> Int -> Bool

-- | <pre>
--   (lengthIsNot xs n) = (length xs /= n)
--   </pre>
lengthIsNot :: [a] -> Int -> Bool

-- | <pre>
--   (lengthAtLeast xs n) = (length xs &gt;= n)
--   </pre>
lengthAtLeast :: [a] -> Int -> Bool

-- | <pre>
--   (lengthAtMost xs n) = (length xs &lt;= n)
--   </pre>
lengthAtMost :: [a] -> Int -> Bool

-- | <pre>
--   (lengthLessThan xs n) == (length xs &lt; n)
--   </pre>
lengthLessThan :: [a] -> Int -> Bool
listLengthCmp :: [a] -> Int -> Ordering

-- | <tt>atLength atLen atEnd ls n</tt> unravels list <tt>ls</tt> to
--   position <tt>n</tt>. Precisely:
--   
--   <pre>
--   atLength atLenPred atEndPred ls n
--    | n &lt; 0         = atLenPred ls
--    | length ls &lt; n = atEndPred (n - length ls)
--    | otherwise     = atLenPred (drop n ls)
--   </pre>
atLength :: ([a] -> b) -> b -> [a] -> Int -> b

-- | True if length xs == length ys
equalLength :: [a] -> [b] -> Bool
compareLength :: [a] -> [b] -> Ordering

-- | True if length xs &lt;= length ys
leLength :: [a] -> [b] -> Bool

-- | True if length xs &lt; length ys
ltLength :: [a] -> [b] -> Bool
isSingleton :: [a] -> Bool

-- | Utility function to go from a singleton list to it's element.
--   
--   Wether or not the argument is a singleton list is only checked in
--   debug builds.
only :: [a] -> a

-- | Extract the single element of a list and panic with the given message
--   if there are more elements or the list was empty. Like
--   <tt>expectJust</tt>, but for lists.
expectOnly :: HasCallStack => String -> [a] -> a
singleton :: a -> [a]
notNull :: Foldable f => f a -> Bool

-- | Split a list into its last element and the initial part of the list.
--   <tt>snocView xs = Just (init xs, last xs)</tt> for non-empty lists.
--   <tt>snocView xs = Nothing</tt> otherwise. Unless both parts of the
--   result are guaranteed to be used prefer separate calls to
--   <tt>last</tt> + <tt>init</tt>. If you are guaranteed to use both, this
--   will be more efficient.
snocView :: [a] -> Maybe ([a], a)

-- | Split a list into chunks of <i>n</i> elements
chunkList :: Int -> [a] -> [[a]]

-- | Compute all the ways of removing a single element from a list.
--   
--   <pre>
--   holes [1,2,3] = [(1, [2,3]), (2, [1,3]), (3, [1,2])]
--   </pre>
holes :: [a] -> [(a, [a])]

-- | Replace the last element of a list with another element.
changeLast :: [a] -> a -> [a]

-- | Apply an effectful function to the last list element.
mapLastM :: Functor f => (a -> f a) -> NonEmpty a -> f (NonEmpty a)
whenNonEmpty :: Applicative m => [a] -> (NonEmpty a -> m ()) -> m ()

-- | Merge an unsorted list of sorted lists, for example:
--   
--   <pre>
--   mergeListsBy compare [ [2,5,15], [1,10,100] ] = [1,2,5,10,15,100]
--   </pre>
--   
--   &lt;math&gt;
mergeListsBy :: forall a. (a -> a -> Ordering) -> [[a]] -> [a]
isSortedBy :: (a -> a -> Ordering) -> [a] -> Bool
mapMaybe' :: Foldable f => (a -> Maybe b) -> f a -> [b]
fstOf3 :: (a, b, c) -> a
sndOf3 :: (a, b, c) -> b
thdOf3 :: (a, b, c) -> c
fst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
snd3 :: (b -> d) -> (a, b, c) -> (a, d, c)
third3 :: (c -> d) -> (a, b, c) -> (a, b, d)
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
takeList :: [b] -> [a] -> [a]
dropList :: [b] -> [a] -> [a]

-- | Given two lists xs and ys, return `splitAt (length xs) ys`.
splitAtList :: [b] -> [a] -> ([a], [a])
split :: Char -> String -> [String]

-- | drop from the end of a list
dropTail :: Int -> [a] -> [a]

-- | Convert a word to title case by capitalising the first letter
capitalise :: String -> String

-- | The <a>sortWith</a> function sorts a list of elements using the user
--   supplied function to project something out of each element
--   
--   In general if the user supplied function is expensive to compute then
--   you should probably be using <a>sortOn</a>, as it only needs to
--   compute it once for each element. <a>sortWith</a>, on the other hand
--   must compute the mapping function for every comparison that it
--   performs.
sortWith :: Ord b => (a -> b) -> [a] -> [a]
minWith :: Ord b => (a -> b) -> [a] -> a
nubSort :: Ord a => [a] -> [a]

-- | Remove duplicates but keep elements in order. O(n * log n)
ordNub :: Ord a => [a] -> [a]

-- | Remove duplicates but keep elements in order. O(n * log n)
ordNubOn :: Ord b => (a -> b) -> [a] -> [a]
isEqual :: Ordering -> Bool
removeSpaces :: String -> String
(<&&>) :: Applicative f => f Bool -> f Bool -> f Bool
infixr 3 <&&>
(<||>) :: Applicative f => f Bool -> f Bool -> f Bool
infixr 2 <||>
fuzzyMatch :: String -> [String] -> [String]

-- | Search for possible matches to the users input in the given list,
--   returning a small number of ranked results
fuzzyLookup :: String -> [(String, a)] -> [a]
transitiveClosure :: (a -> [a]) -> (a -> a -> Bool) -> [a] -> [a]
seqList :: [a] -> b -> b
strictMap :: (a -> b) -> [a] -> [b]
strictZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
strictZipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
looksLikeModuleName :: String -> Bool
looksLikePackageName :: String -> Bool

-- | Determine the $log_2$ of exact powers of 2
exactLog2 :: Integer -> Maybe Integer
readRational :: String -> Rational

-- | Parse a string into a significand and exponent. A trivial example
--   might be: ghci&gt; readSignificandExponentPair "1E2" (1,2) In a more
--   complex case we might return a exponent different than that which the
--   user wrote. This is needed in order to use a Integer significand.
--   ghci&gt; readSignificandExponentPair "-1.11E5" (-111,3)
readSignificandExponentPair :: String -> (Integer, Integer)
readHexRational :: String -> Rational

-- | Parse a string into a significand and exponent according to the
--   "Hexadecimal Floats in Haskell" proposal. A trivial example might be:
--   ghci&gt; readHexSignificandExponentPair "0x1p+1" (1,1) Behaves similar
--   to readSignificandExponentPair but the base is 16 and numbers are
--   given in hexadecimal: ghci&gt; readHexSignificandExponentPair "0xAp-4"
--   (10,-4) ghci&gt; readHexSignificandExponentPair "0x1.2p3" (18,-1)
readHexSignificandExponentPair :: String -> (Integer, Integer)
doesDirNameExist :: FilePath -> IO Bool
getModificationUTCTime :: FilePath -> IO UTCTime
modificationTimeIfExists :: FilePath -> IO (Maybe UTCTime)
fileHashIfExists :: FilePath -> IO (Maybe Fingerprint)
withAtomicRename :: MonadIO m => FilePath -> (FilePath -> m a) -> m a
type Suffix = String
splitLongestPrefix :: String -> (Char -> Bool) -> (String, String)
escapeSpaces :: String -> String
data Direction
Forwards :: Direction
Backwards :: Direction
reslash :: Direction -> FilePath -> FilePath
makeRelativeTo :: FilePath -> FilePath -> FilePath
abstractConstr :: String -> Constr
abstractDataType :: String -> DataType

-- | Constructs a non-representation for a non-representable type
mkNoRepType :: String -> DataType
charToC :: Word8 -> String

-- | A sample hash function for Strings. We keep multiplying by the golden
--   ratio and adding. The implementation is:
--   
--   <pre>
--   hashString = foldl' f golden
--     where f m c = fromIntegral (ord c) * magic + hashInt32 m
--           magic = 0xdeadbeef
--   </pre>
--   
--   Where hashInt32 works just as hashInt shown above.
--   
--   Knuth argues that repeated multiplication by the golden ratio will
--   minimize gaps in the hash space, and thus it's a good choice for
--   combining together multiple keys to form one.
--   
--   Here we know that individual characters c are often small, and this
--   produces frequent collisions if we use ord c alone. A particular
--   problem are the shorter low ASCII and ISO-8859-1 character strings. We
--   pre-multiply by a magic twiddle factor to obtain a good distribution.
--   In fact, given the following test:
--   
--   <pre>
--   testp :: Int32 -&gt; Int
--   testp k = (n - ) . length . group . sort . map hs . take n $ ls
--     where ls = [] : [c : l | l &lt;- ls, c &lt;- ['\0'..'\xff']]
--           hs = foldl' f golden
--           f m c = fromIntegral (ord c) * k + hashInt32 m
--           n = 100000
--   </pre>
--   
--   We discover that testp magic = 0.
hashString :: String -> Int32

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | A call stack constraint, but only when <tt>isDebugOn</tt>.
type HasDebugCallStack = (() :: Constraint)


-- | There are two principal string types used internally by GHC:
--   
--   <ul>
--   <li><i><a>FastString</a></i></li>
--   </ul>
--   
--   <ul>
--   <li>A compact, hash-consed, representation of character strings.</li>
--   <li>Generated by <a>fsLit</a>.</li>
--   <li>You can get a <a>Unique</a> from them.</li>
--   <li>Equality test is O(1) (it uses the Unique).</li>
--   <li>Comparison is O(1) or O(n):</li>
--   <li>O(n) but deterministic with lexical comparison
--   (<a>lexicalCompareFS</a>)</li>
--   <li>O(1) but non-deterministic with Unique comparison
--   (<a>uniqCompareFS</a>)</li>
--   <li>Turn into <a>SDoc</a> with <a>ftext</a>.</li>
--   </ul>
--   
--   <ul>
--   <li><i><a>PtrString</a></i></li>
--   </ul>
--   
--   <ul>
--   <li>Pointer and size of a Latin-1 encoded string.</li>
--   <li>Practically no operations.</li>
--   <li>Outputting them is fast.</li>
--   <li>Generated by <a>mkPtrString#</a>.</li>
--   <li>Length of string literals (mkPtrString# "abc"#) is computed
--   statically</li>
--   <li>Turn into <a>SDoc</a> with <a>ptext</a></li>
--   <li>Requires manual memory management. Improper use may lead to memory
--   leaks or dangling pointers.</li>
--   <li>It assumes Latin-1 as the encoding, therefore it cannot represent
--   arbitrary Unicode strings.</li>
--   </ul>
--   
--   Use <a>PtrString</a> unless you want the facilities of
--   <a>FastString</a>.
module GHC.Data.FastString

-- | Gives the Modified UTF-8 encoded bytes corresponding to a
--   <a>FastString</a>
bytesFS :: FastString -> ByteString

-- | Gives the Modified UTF-8 encoded bytes corresponding to a
--   <a>FastString</a>

-- | <i>Deprecated: Use <a>bytesFS</a> instead</i>
fastStringToByteString :: FastString -> ByteString

-- | Create a <a>FastString</a> by copying an existing <a>ByteString</a>
mkFastStringByteString :: ByteString -> FastString
fastZStringToByteString :: FastZString -> ByteString
unsafeMkByteString :: String -> ByteString
fastStringToShortByteString :: FastString -> ShortByteString

-- | Create a <a>FastString</a> from an existing <a>ShortByteString</a>
--   without copying.
mkFastStringShortByteString :: ShortByteString -> FastString
data FastZString
hPutFZS :: Handle -> FastZString -> IO ()
zString :: FastZString -> String

-- | <tt>zStringTakeN n = <a>take</a> n . <a>zString</a></tt> but is
--   performed in &lt;math&gt; rather than &lt;math&gt;, where &lt;math&gt;
--   is the length of the <a>FastZString</a>.
zStringTakeN :: Int -> FastZString -> String
lengthFZS :: FastZString -> Int

-- | A <a>FastString</a> is a UTF-8 encoded string together with a unique
--   ID. All <a>FastString</a>s are stored in a global hashtable to support
--   fast O(1) comparison.
--   
--   It is also associated with a lazy reference to the Z-encoding of this
--   string which is used by the compiler internally.
data FastString
FastString :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !ShortByteString -> FastZString -> FastString
[uniq] :: FastString -> {-# UNPACK #-} !Int
[n_chars] :: FastString -> {-# UNPACK #-} !Int
[fs_sbs] :: FastString -> {-# UNPACK #-} !ShortByteString

-- | Lazily computed Z-encoding of this string. See Note [Z-Encoding] in
--   GHC.Utils.Encoding.
--   
--   Since <a>FastString</a>s are globally memoized this is computed at
--   most once for any given string.
[fs_zenc] :: FastString -> FastZString

-- | Non-deterministic FastString
--   
--   This is a simple FastString wrapper with an Ord instance using
--   <a>uniqCompareFS</a> (i.e. which compares FastStrings on their
--   Uniques). Hence it is not deterministic from one run to the other.
newtype NonDetFastString
NonDetFastString :: FastString -> NonDetFastString

-- | Lexical FastString
--   
--   This is a simple FastString wrapper with an Ord instance using
--   <a>lexicalCompareFS</a> (i.e. which compares FastStrings on their
--   String representation). Hence it is deterministic from one run to the
--   other.
newtype LexicalFastString
LexicalFastString :: FastString -> LexicalFastString
fsLit :: String -> FastString

-- | Creates a UTF-8 encoded <a>FastString</a> from a <a>String</a>
mkFastString :: String -> FastString
mkFastStringBytes :: Ptr Word8 -> Int -> FastString

-- | Creates a <a>FastString</a> from a UTF-8 encoded <tt>[Word8]</tt>
mkFastStringByteList :: [Word8] -> FastString
mkFastString# :: Addr# -> FastString

-- | Lazily unpacks and decodes the FastString
unpackFS :: FastString -> String
unconsFS :: FastString -> Maybe (Char, FastString)

-- | Returns a Z-encoded version of a <a>FastString</a>. This might be the
--   original, if it was already Z-encoded. The first time this function is
--   applied to a particular <a>FastString</a>, the results are memoized.
zEncodeFS :: FastString -> FastZString
uniqueOfFS :: FastString -> Int

-- | Returns the length of the <a>FastString</a> in characters
lengthFS :: FastString -> Int

-- | Returns <tt>True</tt> if the <a>FastString</a> is empty
nullFS :: FastString -> Bool
appendFS :: FastString -> FastString -> FastString
concatFS :: [FastString] -> FastString
consFS :: Char -> FastString -> FastString
nilFS :: FastString

-- | Compare FastString lexically
--   
--   If you don't care about the lexical ordering, use <a>uniqCompareFS</a>
--   instead.
lexicalCompareFS :: FastString -> FastString -> Ordering

-- | Compare FastString by their Unique (not lexically).
--   
--   Much cheaper than <a>lexicalCompareFS</a> but non-deterministic!
uniqCompareFS :: FastString -> FastString -> Ordering

-- | Outputs a <a>FastString</a> with <i>no decoding at all</i>, that is,
--   you get the actual bytes in the <a>FastString</a> written to the
--   <a>Handle</a>.
hPutFS :: Handle -> FastString -> IO ()
getFastStringTable :: IO [[[FastString]]]
getFastStringZEncCounter :: IO Int

-- | A <a>PtrString</a> is a pointer to some array of Latin-1 encoded
--   chars.
data PtrString
PtrString :: !Ptr Word8 -> !Int -> PtrString

-- | Wrap an unboxed address into a <a>PtrString</a>.
mkPtrString# :: Addr# -> PtrString

-- | Decode a <a>PtrString</a> back into a <a>String</a> using Latin-1
--   encoding. This does not free the memory associated with
--   <a>PtrString</a>.
unpackPtrString :: PtrString -> String

-- | <tt>unpackPtrStringTakeN n = <a>take</a> n .
--   <a>unpackPtrString</a></tt> but is performed in &lt;math&gt; rather
--   than &lt;math&gt;, where &lt;math&gt; is the length of the
--   <a>PtrString</a>.
unpackPtrStringTakeN :: Int -> PtrString -> String

-- | Return the length of a <a>PtrString</a>
lengthPS :: PtrString -> Int
instance Control.DeepSeq.NFData GHC.Data.FastString.FastZString
instance Data.Data.Data GHC.Data.FastString.NonDetFastString
instance GHC.Show.Show GHC.Data.FastString.NonDetFastString
instance GHC.Classes.Eq GHC.Data.FastString.NonDetFastString
instance Data.Data.Data GHC.Data.FastString.LexicalFastString
instance GHC.Show.Show GHC.Data.FastString.LexicalFastString
instance GHC.Classes.Eq GHC.Data.FastString.LexicalFastString
instance GHC.Classes.Ord GHC.Data.FastString.LexicalFastString
instance GHC.Classes.Ord GHC.Data.FastString.NonDetFastString
instance GHC.Classes.Eq GHC.Data.FastString.FastString
instance Data.String.IsString GHC.Data.FastString.FastString
instance GHC.Base.Semigroup GHC.Data.FastString.FastString
instance GHC.Base.Monoid GHC.Data.FastString.FastString
instance GHC.Show.Show GHC.Data.FastString.FastString
instance Data.Data.Data GHC.Data.FastString.FastString
instance Control.DeepSeq.NFData GHC.Data.FastString.FastString

module GHC.Utils.BufHandle
data BufHandle
BufHandle :: {-# UNPACK #-} !Ptr Word8 -> {-# UNPACK #-} !FastMutInt -> Handle -> BufHandle
newBufHandle :: Handle -> IO BufHandle
bPutChar :: BufHandle -> Char -> IO ()
bPutStr :: BufHandle -> String -> IO ()
bPutFS :: BufHandle -> FastString -> IO ()
bPutFZS :: BufHandle -> FastZString -> IO ()
bPutPtrString :: BufHandle -> PtrString -> IO ()

-- | Replicate an 8-bit character
bPutReplicate :: BufHandle -> Int -> Char -> IO ()
bFlush :: BufHandle -> IO ()


-- | John Hughes's and Simon Peyton Jones's Pretty Printer Combinators
--   
--   Based on <i>The Design of a Pretty-printing Library</i> in Advanced
--   Functional Programming, Johan Jeuring and Erik Meijer (eds), LNCS 925
--   <a>http://www.cse.chalmers.se/~rjmh/Papers/pretty.ps</a>
module GHC.Utils.Ppr

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails
PStr :: FastString -> TextDetails
ZStr :: FastZString -> TextDetails
LStr :: {-# UNPACK #-} !PtrString -> TextDetails
RStr :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Char -> TextDetails

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc
ftext :: FastString -> Doc
ptext :: PtrString -> Doc
ztext :: FastZString -> Doc

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc

-- | Empty text (one line high but no width). (<tt>emptyText = text
--   ""</tt>)
emptyText :: Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
hex :: Integer -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
squotes :: Doc -> Doc
quote :: Doc -> Doc
doubleQuotes :: Doc -> Doc

-- | Apply <a>parens</a> to <a>Doc</a> if boolean is true.
maybeParens :: Bool -> Doc -> Doc

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc
infixl 6 <>

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc
infixl 6 <+>

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc] -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc
infixl 5 $$

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc -> Doc -> Doc
infixl 5 $+$

-- | List version of <a>$$</a>.
vcat :: [Doc] -> Doc

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc] -> Doc

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc] -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | Apply <a>hang</a> to the arguments if the first <a>Doc</a> is not
--   empty.
hangNotEmpty :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | Get the first character of a document. We also return a new document,
--   equivalent to the original one but faster to render. Use it to avoid
--   work duplication.
docHead :: Doc -> (Maybe Char, Doc)

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
[mode] :: Style -> Mode

-- | Length of line, in chars
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode False, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc -> String

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Bool -> Mode
[asciiSpace] :: Mode -> Bool

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a

-- | Default TextDetails printer
txtPrinter :: TextDetails -> String -> String
printDoc :: Mode -> Int -> Handle -> Doc -> IO ()
printDoc_ :: Mode -> Int -> Handle -> Doc -> IO ()
bufLeftRender :: BufHandle -> Doc -> IO ()
printLeftRender :: Handle -> Doc -> IO ()
instance GHC.Show.Show GHC.Utils.Ppr.Doc

module GHC.Utils.Ppr.Colour

-- | A colour/style for use with <tt>coloured</tt>.
newtype PprColour
PprColour :: String -> PprColour
[renderColour] :: PprColour -> String
renderColourAfresh :: PprColour -> String
colCustom :: String -> PprColour
colReset :: PprColour
colBold :: PprColour
colBlackFg :: PprColour
colRedFg :: PprColour
colGreenFg :: PprColour
colYellowFg :: PprColour
colBlueFg :: PprColour
colMagentaFg :: PprColour
colCyanFg :: PprColour
colWhiteFg :: PprColour
data Scheme
Scheme :: PprColour -> PprColour -> PprColour -> PprColour -> PprColour -> PprColour -> Scheme
[sHeader] :: Scheme -> PprColour
[sMessage] :: Scheme -> PprColour
[sWarning] :: Scheme -> PprColour
[sError] :: Scheme -> PprColour
[sFatal] :: Scheme -> PprColour
[sMargin] :: Scheme -> PprColour
defaultScheme :: Scheme

-- | Parse the colour scheme from a string (presumably from the
--   <tt>GHC_COLORS</tt> environment variable).
parseScheme :: String -> (OverridingBool, Scheme) -> (OverridingBool, Scheme)
instance GHC.Base.Semigroup GHC.Utils.Ppr.Colour.PprColour
instance GHC.Base.Monoid GHC.Utils.Ppr.Colour.PprColour

module Language.Haskell.Syntax.Basic
data Boxity
Boxed :: Boxity
Unboxed :: Boxity
isBoxed :: Boxity -> Bool

-- | The width of an unboxed sum
type SumWidth = Int

-- | A *one-index* constructor tag
--   
--   Type of the tags associated with each constructor possibility or
--   superclass selector
type ConTag = Int

-- | Field labels are just represented as strings; they are not necessarily
--   unique (even within a module)
newtype FieldLabelString
FieldLabelString :: FastString -> FieldLabelString
[field_label] :: FieldLabelString -> FastString

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness
instance Data.Data.Data Language.Haskell.Syntax.Basic.Boxity
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.Boxity
instance Control.DeepSeq.NFData Language.Haskell.Syntax.Basic.FieldLabelString
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.FieldLabelString
instance Data.Data.Data Language.Haskell.Syntax.Basic.FieldLabelString
instance Data.Data.Data Language.Haskell.Syntax.Basic.Role
instance GHC.Classes.Ord Language.Haskell.Syntax.Basic.Role
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.Role
instance Data.Data.Data Language.Haskell.Syntax.Basic.SrcStrictness
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.SrcStrictness
instance Data.Data.Data Language.Haskell.Syntax.Basic.SrcUnpackedness
instance GHC.Classes.Eq Language.Haskell.Syntax.Basic.SrcUnpackedness

module Language.Haskell.Syntax.Extension

-- | A placeholder type for TTG extension points that are not currently
--   unused to represent any particular value.
--   
--   This should not be confused with <a>DataConCantHappen</a>, which are
--   found in unused extension <i>constructors</i> and therefore should
--   never be inhabited. In contrast, <a>NoExtField</a> is used in
--   extension <i>points</i> (e.g., as the field of some constructor), so
--   it must have an inhabitant to construct AST passes that manipulate
--   fields with that extension point as their type.
data NoExtField
NoExtField :: NoExtField

-- | Used when constructing a term with an unused extension point.
noExtField :: NoExtField
data DataConCantHappen

-- | Eliminate a <a>DataConCantHappen</a>. See Note [Constructor cannot
--   occur].
dataConCantHappen :: DataConCantHappen -> a

-- | GHC's L prefixed variants wrap their vanilla variant in this type
--   family, to add <tt>SrcLoc</tt> info via <tt>Located</tt>. Other passes
--   than <tt>GhcPass</tt> not interested in location information can
--   define this as <tt>type instance XRec NoLocated a = a</tt>. See Note
--   [XRec and SrcSpans in the AST]
type family XRec p a = r | r -> a
type family Anno a = b

-- | We can strip off the XRec to access the underlying data. See Note
--   [XRec and SrcSpans in the AST]
class UnXRec p
unXRec :: UnXRec p => XRec p a -> a

-- | We can map over the underlying type contained in an <tt>XRec</tt>
--   while preserving the annotation as is.
class MapXRec p
mapXRec :: (MapXRec p, Anno a ~ Anno b) => (a -> b) -> XRec p a -> XRec p b

-- | The trivial wrapper that carries no additional information See Note
--   [XRec and SrcSpans in the AST]
class WrapXRec p a
wrapXRec :: WrapXRec p a => a -> XRec p a

-- | Maps the "normal" id type for a given pass
type family IdP p
type LIdP p = XRec p (IdP p)
type family XHsValBinds x x'
type family XHsIPBinds x x'
type family XEmptyLocalBinds x x'
type family XXHsLocalBindsLR x x'
type family XValBinds x x'
type family XXValBindsLR x x'
type family XFunBind x x'
type family XPatBind x x'
type family XVarBind x x'
type family XPatSynBind x x'
type family XXHsBindsLR x x'
type family XPSB x x'
type family XXPatSynBind x x'
type family XIPBinds x
type family XXHsIPBinds x
type family XCIPBind x
type family XXIPBind x
type family XTypeSig x
type family XPatSynSig x
type family XClassOpSig x
type family XIdSig x
type family XFixSig x
type family XInlineSig x
type family XSpecSig x
type family XSpecInstSig x
type family XMinimalSig x
type family XSCCFunSig x
type family XCompleteMatchSig x
type family XXSig x
type family XFixitySig x
type family XXFixitySig x
type family XStandaloneKindSig x
type family XXStandaloneKindSig x
type family XTyClD x
type family XInstD x
type family XDerivD x
type family XValD x
type family XSigD x
type family XKindSigD x
type family XDefD x
type family XForD x
type family XWarningD x
type family XAnnD x
type family XRuleD x
type family XSpliceD x
type family XDocD x
type family XRoleAnnotD x
type family XXHsDecl x
type family XCHsGroup x
type family XXHsGroup x
type family XSpliceDecl x
type family XXSpliceDecl x
type family XFamDecl x
type family XSynDecl x
type family XDataDecl x
type family XClassDecl x
type family XXTyClDecl x
type family XCFunDep x
type family XXFunDep x
type family XCTyClGroup x
type family XXTyClGroup x
type family XNoSig x
type family XCKindSig x
type family XTyVarSig x
type family XXFamilyResultSig x
type family XCFamilyDecl x
type family XXFamilyDecl x
type family XCHsDataDefn x
type family XXHsDataDefn x
type family XCHsDerivingClause x
type family XXHsDerivingClause x
type family XDctSingle x
type family XDctMulti x
type family XXDerivClauseTys x
type family XConDeclGADT x
type family XConDeclH98 x
type family XXConDecl x
type family XCFamEqn x r
type family XXFamEqn x r
type family XCTyFamInstDecl x
type family XXTyFamInstDecl x
type family XCClsInstDecl x
type family XXClsInstDecl x
type family XClsInstD x
type family XDataFamInstD x
type family XTyFamInstD x
type family XXInstDecl x
type family XCDerivDecl x
type family XXDerivDecl x
type family XStockStrategy x
type family XAnyClassStrategy x
type family XNewtypeStrategy x
type family XViaStrategy x
type family XCDefaultDecl x
type family XXDefaultDecl x
type family XForeignImport x
type family XForeignExport x
type family XXForeignDecl x
type family XCImport x
type family XXForeignImport x
type family XCExport x
type family XXForeignExport x
type family XCRuleDecls x
type family XXRuleDecls x
type family XHsRule x
type family XXRuleDecl x
type family XCRuleBndr x
type family XRuleBndrSig x
type family XXRuleBndr x
type family XWarnings x
type family XXWarnDecls x
type family XWarning x
type family XXWarnDecl x
type family XHsAnnotation x
type family XXAnnDecl x
type family XCRoleAnnotDecl x
type family XXRoleAnnotDecl x
type family XCInjectivityAnn x
type family XXInjectivityAnn x
type family XCModule x
type family XXModule x
type family XVar x
type family XUnboundVar x
type family XRecSel x
type family XOverLabel x
type family XIPVar x
type family XOverLitE x
type family XLitE x
type family XLam x
type family XLamCase x
type family XApp x
type family XAppTypeE x
type family XOpApp x
type family XNegApp x
type family XPar x
type family XSectionL x
type family XSectionR x
type family XExplicitTuple x
type family XExplicitSum x
type family XCase x
type family XIf x
type family XMultiIf x
type family XLet x
type family XDo x
type family XExplicitList x
type family XRecordCon x
type family XRecordUpd x
type family XGetField x
type family XProjection x
type family XExprWithTySig x
type family XArithSeq x
type family XTypedBracket x
type family XUntypedBracket x
type family XTypedSplice x
type family XUntypedSplice x
type family XProc x
type family XStatic x
type family XTick x
type family XBinTick x
type family XPragE x
type family XXExpr x
type family XCDotFieldOcc x
type family XXDotFieldOcc x
type family XSCC x
type family XXPragE x
type family XUnambiguous x
type family XAmbiguous x
type family XXAmbiguousFieldOcc x
type family XPresent x
type family XMissing x
type family XXTupArg x
type family XUntypedSpliceExpr x
type family XQuasiQuote x
type family XXUntypedSplice x
type family XExpBr x
type family XPatBr x
type family XDecBrL x
type family XDecBrG x
type family XTypBr x
type family XVarBr x
type family XXQuote x
type family XCmdTop x
type family XXCmdTop x
type family XMG x b
type family XXMatchGroup x b
type family XCMatch x b
type family XXMatch x b
type family XCGRHSs x b
type family XXGRHSs x b
type family XCGRHS x b
type family XXGRHS x b
type family XLastStmt x x' b
type family XBindStmt x x' b
type family XApplicativeStmt x x' b
type family XBodyStmt x x' b
type family XLetStmt x x' b
type family XParStmt x x' b
type family XTransStmt x x' b
type family XRecStmt x x' b
type family XXStmtLR x x' b
type family XCmdArrApp x
type family XCmdArrForm x
type family XCmdApp x
type family XCmdLam x
type family XCmdPar x
type family XCmdCase x
type family XCmdLamCase x
type family XCmdIf x
type family XCmdLet x
type family XCmdDo x
type family XCmdWrap x
type family XXCmd x
type family XParStmtBlock x x'
type family XXParStmtBlock x x'
type family XApplicativeArgOne x
type family XApplicativeArgMany x
type family XXApplicativeArg x
type family XHsChar x
type family XHsCharPrim x
type family XHsString x
type family XHsStringPrim x
type family XHsInt x
type family XHsIntPrim x
type family XHsWordPrim x
type family XHsInt64Prim x
type family XHsWord64Prim x
type family XHsInteger x
type family XHsRat x
type family XHsFloatPrim x
type family XHsDoublePrim x
type family XXLit x
type family XOverLit x
type family XXOverLit x
type family XWildPat x
type family XVarPat x
type family XLazyPat x
type family XAsPat x
type family XParPat x
type family XBangPat x
type family XListPat x
type family XTuplePat x
type family XSumPat x
type family XConPat x
type family XViewPat x
type family XSplicePat x
type family XLitPat x
type family XNPat x
type family XNPlusKPat x
type family XSigPat x
type family XCoPat x
type family XXPat x
type family XHsFieldBind x
type family XHsQTvs x
type family XXLHsQTyVars x
type family XHsOuterImplicit x
type family XHsOuterExplicit x flag
type family XXHsOuterTyVarBndrs x
type family XHsSig x
type family XXHsSigType x
type family XHsWC x b
type family XXHsWildCardBndrs x b
type family XHsPS x
type family XXHsPatSigType x
type family XForAllTy x
type family XQualTy x
type family XTyVar x
type family XAppTy x
type family XAppKindTy x
type family XFunTy x
type family XListTy x
type family XTupleTy x
type family XSumTy x
type family XOpTy x
type family XParTy x
type family XIParamTy x
type family XStarTy x
type family XKindSig x
type family XSpliceTy x
type family XDocTy x
type family XBangTy x
type family XRecTy x
type family XExplicitListTy x
type family XExplicitTupleTy x
type family XTyLit x
type family XWildCardTy x
type family XXType x
type family XNumTy x
type family XStrTy x
type family XCharTy x
type family XXTyLit x
type family XHsForAllVis x
type family XHsForAllInvis x
type family XXHsForAllTelescope x
type family XUserTyVar x
type family XKindedTyVar x
type family XXTyVarBndr x
type family XConDeclField x
type family XXConDeclField x
type family XCFieldOcc x
type family XXFieldOcc x
type family XCImportDecl x
type family XXImportDecl x
type family ImportDeclPkgQual x
type family XIEVar x
type family XIEThingAbs x
type family XIEThingAll x
type family XIEThingWith x
type family XIEModuleContents x
type family XIEGroup x
type family XIEDoc x
type family XIEDocNamed x
type family XXIE x
type family XIEName p
type family XIEPattern p
type family XIEType p
type family XXIEWrappedName p

-- | See Note [NoGhcTc] in GHC.Hs.Extension. It has to be in this module
--   because it is used like an extension point (in the data definitions of
--   types that should be parameter-agnostic.
type family NoGhcTc (p :: Type)
instance GHC.Classes.Ord Language.Haskell.Syntax.Extension.NoExtField
instance GHC.Classes.Eq Language.Haskell.Syntax.Extension.NoExtField
instance Data.Data.Data Language.Haskell.Syntax.Extension.NoExtField
instance GHC.Classes.Ord Language.Haskell.Syntax.Extension.DataConCantHappen
instance GHC.Classes.Eq Language.Haskell.Syntax.Extension.DataConCantHappen
instance Data.Data.Data Language.Haskell.Syntax.Extension.DataConCantHappen

module Language.Haskell.Syntax.Module.Name

-- | A ModuleName is essentially a simple string, e.g. <tt>Data.List</tt>.
newtype ModuleName
ModuleName :: FastString -> ModuleName

-- | Compares module names lexically, rather than by their <tt>Unique</tt>s
stableModuleNameCmp :: ModuleName -> ModuleName -> Ordering
moduleNameFS :: ModuleName -> FastString
moduleNameString :: ModuleName -> String
mkModuleName :: String -> ModuleName
mkModuleNameFS :: FastString -> ModuleName

-- | Returns the string version of the module name, with dots replaced by
--   slashes.
moduleNameSlashes :: ModuleName -> String

-- | Returns the string version of the module name, with dots replaced by
--   colons.
moduleNameColons :: ModuleName -> String
parseModuleName :: ReadP ModuleName
instance GHC.Classes.Eq Language.Haskell.Syntax.Module.Name.ModuleName
instance GHC.Show.Show Language.Haskell.Syntax.Module.Name.ModuleName
instance GHC.Classes.Ord Language.Haskell.Syntax.Module.Name.ModuleName
instance Data.Data.Data Language.Haskell.Syntax.Module.Name.ModuleName
instance Control.DeepSeq.NFData Language.Haskell.Syntax.Module.Name.ModuleName


-- | This module defines classes and functions for pretty-printing. It also
--   exports a number of helpful debugging and other utilities such as
--   <tt>trace</tt> and <tt>panic</tt>.
--   
--   The interface to this module is very similar to the standard Hughes-PJ
--   pretty printing module, except that it exports a number of additional
--   functions that are rarely used, and works over the <a>SDoc</a> type.
module GHC.Utils.Outputable

-- | Class designating that some type has an <a>SDoc</a> representation
class Outputable a
ppr :: Outputable a => a -> SDoc

-- | When we print a binder, we often want to print its type too. The
--   <tt>OutputableBndr</tt> class encapsulates this idea.
class Outputable a => OutputableBndr a
pprBndr :: OutputableBndr a => BindingSite -> a -> SDoc
pprPrefixOcc :: OutputableBndr a => a -> SDoc
pprInfixOcc :: OutputableBndr a => a -> SDoc
bndrIsJoin_maybe :: OutputableBndr a => a -> Maybe Int

-- | Outputable class with an additional environment value
--   
--   See Note [The OutputableP class]
class OutputableP env a
pdoc :: OutputableP env a => env -> a -> SDoc

-- | A superclass for <a>IsLine</a> and <a>IsDoc</a> that provides an
--   identity, <a>empty</a>, as well as access to the shared
--   <a>SDocContext</a>.
--   
--   See Note [The outputable class hierarchy] for more details.
class IsOutput doc
empty :: IsOutput doc => doc
docWithContext :: IsOutput doc => (SDocContext -> doc) -> doc

-- | A class of types that represent a single logical line of text, with
--   support for horizontal composition.
--   
--   See Note [HLine versus HDoc] and Note [The outputable class hierarchy]
--   for more details.
class IsOutput doc => IsLine doc
char :: IsLine doc => Char -> doc
text :: IsLine doc => String -> doc
ftext :: IsLine doc => FastString -> doc
ztext :: IsLine doc => FastZString -> doc

-- | Join two <tt>doc</tt>s together horizontally without a gap.
(<>) :: IsLine doc => doc -> doc -> doc

-- | Join two <tt>doc</tt>s together horizontally with a gap between them.
(<+>) :: IsLine doc => doc -> doc -> doc

-- | Separate: is either like <a>hsep</a> or like <a>vcat</a>, depending on
--   what fits.
sep :: IsLine doc => [doc] -> doc

-- | A paragraph-fill combinator. It's much like <a>sep</a>, only it keeps
--   fitting things on one line until it can't fit any more.
fsep :: IsLine doc => [doc] -> doc

-- | Concatenate <tt>doc</tt>s horizontally without gaps.
hcat :: IsLine doc => [doc] -> doc

-- | Concatenate <tt>doc</tt>s horizontally with a space between each one.
hsep :: IsLine doc => [doc] -> doc

-- | Prints as either the given <a>SDoc</a> or the given <a>HLine</a>,
--   depending on which type the result is instantiated to. This should
--   generally be avoided; see Note [dualLine and dualDoc] for details.
dualLine :: IsLine doc => SDoc -> HLine -> doc

-- | A class of types that represent a multiline document, with support for
--   vertical composition.
--   
--   See Note [HLine versus HDoc] and Note [The outputable class hierarchy]
--   for more details.
class (IsOutput doc, IsLine (Line doc)) => IsDoc doc where {
    type Line doc = r | r -> doc;
}
line :: IsDoc doc => Line doc -> doc

-- | Join two <tt>doc</tt>s together vertically. If there is no vertical
--   overlap it "dovetails" the two onto one line.
($$) :: IsDoc doc => doc -> doc -> doc
lines_ :: IsDoc doc => [Line doc] -> doc

-- | Concatenate <tt>doc</tt>s vertically with dovetailing.
vcat :: IsDoc doc => [doc] -> doc

-- | Prints as either the given <a>SDoc</a> or the given <a>HDoc</a>,
--   depending on which type the result is instantiated to. This should
--   generally be avoided; see Note [dualLine and dualDoc] for details.
dualDoc :: IsDoc doc => SDoc -> HDoc -> doc

-- | Represents a single line of output that can be efficiently printed
--   directly to a <a>Handle</a> (actually a <a>BufHandle</a>). See Note
--   [SDoc versus HDoc] and Note [HLine versus HDoc] for more details.
data HLine

-- | Represents a (possibly empty) sequence of lines that can be
--   efficiently printed directly to a <a>Handle</a> (actually a
--   <a>BufHandle</a>). See Note [SDoc versus HDoc] and Note [HLine versus
--   HDoc] for more details.
data HDoc

-- | Represents a pretty-printable document.
--   
--   To display an <a>SDoc</a>, use <a>printSDoc</a>, <a>printSDocLn</a>,
--   <a>bufLeftRenderSDoc</a>, or <a>renderWithContext</a>. Avoid calling
--   <a>runSDoc</a> directly as it breaks the abstraction layer.
data SDoc
runSDoc :: SDoc -> SDocContext -> Doc

-- | Wrapper for types having a Outputable instance when an OutputableP
--   instance is required.
newtype PDoc a
PDoc :: a -> PDoc a
docToSDoc :: Doc -> SDoc

-- | Returns the separated concatenation of the pretty printed things.
interppSP :: Outputable a => [a] -> SDoc

-- | Returns the comma-separated concatenation of the pretty printed
--   things.
interpp'SP :: Outputable a => [a] -> SDoc
interpp'SP' :: (a -> SDoc) -> [a] -> SDoc

-- | Returns the comma-separated concatenation of the quoted pretty printed
--   things.
--   
--   <pre>
--   [x,y,z]  ==&gt;  `x', `y', `z'
--   </pre>
pprQuotedList :: Outputable a => [a] -> SDoc
pprWithCommas :: (a -> SDoc) -> [a] -> SDoc
quotedListWithOr :: [SDoc] -> SDoc
quotedListWithNor :: [SDoc] -> SDoc
pprWithBars :: (a -> SDoc) -> [a] -> SDoc
spaceIfSingleQuote :: SDoc -> SDoc
isEmpty :: SDocContext -> SDoc -> Bool

-- | Indent <a>SDoc</a> some specified amount
nest :: Int -> SDoc -> SDoc
ptext :: PtrString -> SDoc
int :: IsLine doc => Int -> doc
intWithCommas :: Integral a => a -> SDoc
integer :: IsLine doc => Integer -> doc
word64 :: IsLine doc => Word64 -> doc
word :: Integer -> SDoc
float :: IsLine doc => Float -> doc
double :: IsLine doc => Double -> doc
rational :: Rational -> SDoc

-- | <tt>doublePrec p n</tt> shows a floating point number <tt>n</tt> with
--   <tt>p</tt> digits of precision after the decimal point.
doublePrec :: Int -> Double -> SDoc
parens :: IsLine doc => doc -> doc
cparen :: Bool -> SDoc -> SDoc
brackets :: IsLine doc => doc -> doc
braces :: IsLine doc => doc -> doc
quotes :: SDoc -> SDoc
quote :: SDoc -> SDoc
doubleQuotes :: IsLine doc => doc -> doc
angleBrackets :: IsLine doc => doc -> doc
semi :: IsLine doc => doc
comma :: IsLine doc => doc
colon :: IsLine doc => doc
dcolon :: SDoc
space :: IsLine doc => doc
equals :: IsLine doc => doc
dot :: IsLine doc => doc
vbar :: IsLine doc => doc
arrow :: SDoc
lollipop :: SDoc
larrow :: SDoc
darrow :: SDoc
arrowt :: SDoc
larrowt :: SDoc
arrowtt :: SDoc
larrowtt :: SDoc
lambda :: SDoc
lparen :: IsLine doc => doc
rparen :: IsLine doc => doc
lbrack :: IsLine doc => doc
rbrack :: IsLine doc => doc
lbrace :: IsLine doc => doc
rbrace :: IsLine doc => doc
underscore :: IsLine doc => doc
blankLine :: SDoc
forAllLit :: SDoc
bullet :: SDoc

-- | Join two <a>SDoc</a> together vertically
($+$) :: SDoc -> SDoc -> SDoc

-- | A paragraph-fill combinator. It's much like sep, only it keeps fitting
--   things on one line until it can't fit any more.
cat :: [SDoc] -> SDoc

-- | This behaves like <a>fsep</a>, but it uses <a>&lt;&gt;</a> for
--   horizontal composition rather than <a>&lt;+&gt;</a>
fcat :: [SDoc] -> SDoc
hang :: SDoc -> Int -> SDoc -> SDoc

-- | This behaves like <a>hang</a>, but does not indent the second document
--   when the header is empty.
hangNotEmpty :: SDoc -> Int -> SDoc -> SDoc
punctuate :: IsLine doc => doc -> [doc] -> [doc]
ppWhen :: IsOutput doc => Bool -> doc -> doc
ppUnless :: IsOutput doc => Bool -> doc -> doc
ppWhenOption :: (SDocContext -> Bool) -> SDoc -> SDoc
ppUnlessOption :: IsLine doc => (SDocContext -> Bool) -> doc -> doc

-- | Converts an integer to a verbal index:
--   
--   <pre>
--   speakNth 1 = text "first"
--   speakNth 5 = text "fifth"
--   speakNth 21 = text "21st"
--   </pre>
speakNth :: Int -> SDoc

-- | Converts an integer to a verbal multiplicity:
--   
--   <pre>
--   speakN 0 = text "none"
--   speakN 5 = text "five"
--   speakN 10 = text "10"
--   </pre>
speakN :: Int -> SDoc

-- | Converts an integer and object description to a statement about the
--   multiplicity of those objects:
--   
--   <pre>
--   speakNOf 0 (text "melon") = text "no melons"
--   speakNOf 1 (text "melon") = text "one melon"
--   speakNOf 3 (text "melon") = text "three melons"
--   </pre>
speakNOf :: Int -> SDoc -> SDoc

-- | Determines the pluralisation suffix appropriate for the length of a
--   list:
--   
--   <pre>
--   plural [] = char 's'
--   plural ["Hello"] = empty
--   plural ["Hello", "World"] = char 's'
--   </pre>
plural :: [a] -> SDoc

-- | Determines the singular verb suffix appropriate for the length of a
--   list:
--   
--   <pre>
--   singular [] = empty
--   singular["Hello"] = char 's'
--   singular ["Hello", "World"] = empty
--   </pre>
singular :: [a] -> SDoc

-- | Determines the form of to be appropriate for the length of a list:
--   
--   <pre>
--   isOrAre [] = text "are"
--   isOrAre ["Hello"] = text "is"
--   isOrAre ["Hello", "World"] = text "are"
--   </pre>
isOrAre :: [a] -> SDoc

-- | Determines the form of to do appropriate for the length of a list:
--   
--   <pre>
--   doOrDoes [] = text "do"
--   doOrDoes ["Hello"] = text "does"
--   doOrDoes ["Hello", "World"] = text "do"
--   </pre>
doOrDoes :: [a] -> SDoc

-- | Determines the form of possessive appropriate for the length of a
--   list:
--   
--   <pre>
--   itsOrTheir [x]   = text "its"
--   itsOrTheir [x,y] = text "their"
--   itsOrTheir []    = text "their"  -- probably avoid this
--   </pre>
itsOrTheir :: [a] -> SDoc

-- | Determines the form of subject appropriate for the length of a list:
--   
--   <pre>
--   thisOrThese [x]   = text "This"
--   thisOrThese [x,y] = text "These"
--   thisOrThese []    = text "These"  -- probably avoid this
--   </pre>
thisOrThese :: [a] -> SDoc

-- | <tt>"has"</tt> or <tt>"have"</tt> depending on the length of a list.
hasOrHave :: [a] -> SDoc
unicodeSyntax :: SDoc -> SDoc -> SDoc

-- | Apply the given colour/style for the argument.
--   
--   Only takes effect if colours are enabled.
coloured :: PprColour -> SDoc -> SDoc
keyword :: SDoc -> SDoc

-- | The analog of <a>printDoc_</a> for <a>SDoc</a>, which tries to make
--   sure the terminal doesn't get screwed up by the ANSI color codes if an
--   exception is thrown during pretty-printing.
printSDoc :: SDocContext -> Mode -> Handle -> SDoc -> IO ()

-- | Like <a>printSDoc</a> but appends an extra newline.
printSDocLn :: SDocContext -> Mode -> Handle -> SDoc -> IO ()

-- | An efficient variant of <a>printSDoc</a> specialized for
--   <a>LeftMode</a> that outputs to a <a>BufHandle</a>.
bufLeftRenderSDoc :: SDocContext -> BufHandle -> SDoc -> IO ()
pprCode :: SDoc -> SDoc
showSDocOneLine :: SDocContext -> SDoc -> String
showSDocUnsafe :: SDoc -> String
showPprUnsafe :: Outputable a => a -> String
renderWithContext :: SDocContext -> SDoc -> String
pprDebugAndThen :: SDocContext -> (String -> a) -> SDoc -> SDoc -> a
pprInfixVar :: Bool -> SDoc -> SDoc
pprPrefixVar :: Bool -> SDoc -> SDoc

-- | Special combinator for showing character literals.
pprHsChar :: Char -> SDoc

-- | Special combinator for showing string literals.
pprHsString :: FastString -> SDoc

-- | Special combinator for showing bytestring literals.
pprHsBytes :: ByteString -> SDoc
primFloatSuffix :: SDoc
primCharSuffix :: SDoc
primDoubleSuffix :: SDoc
primInt8Suffix :: SDoc
primWord8Suffix :: SDoc
primInt16Suffix :: SDoc
primWord16Suffix :: SDoc
primInt32Suffix :: SDoc
primWord32Suffix :: SDoc
primInt64Suffix :: SDoc
primWord64Suffix :: SDoc
primIntSuffix :: SDoc
primWordSuffix :: SDoc

-- | Special combinator for showing unboxed literals.
pprPrimChar :: Char -> SDoc
pprPrimInt :: Integer -> SDoc
pprPrimWord :: Integer -> SDoc
pprPrimInt8 :: Integer -> SDoc
pprPrimWord8 :: Integer -> SDoc
pprPrimInt16 :: Integer -> SDoc
pprPrimWord16 :: Integer -> SDoc
pprPrimInt32 :: Integer -> SDoc
pprPrimWord32 :: Integer -> SDoc
pprPrimInt64 :: Integer -> SDoc
pprPrimWord64 :: Integer -> SDoc
pprFastFilePath :: FastString -> SDoc

-- | Normalise, escape and render a string representing a path
--   
--   e.g. "c:\whatever"
pprFilePathString :: IsLine doc => FilePath -> doc
pprModuleName :: IsLine doc => ModuleName -> doc

-- | <a>BindingSite</a> is used to tell the thing that prints binder what
--   language construct is binding the identifier. This can be used to
--   decide how much info to print. Also see Note [Binding-site specific
--   printing] in <a>GHC.Core.Ppr</a>
data BindingSite

-- | The x in (x. e)
LambdaBind :: BindingSite

-- | The x in case scrut of x { (y,z) -&gt; ... }
CaseBind :: BindingSite

-- | The y,z in case scrut of x { (y,z) -&gt; ... }
CasePatBind :: BindingSite

-- | The x in (let x = rhs in e)
LetBind :: BindingSite
data PprStyle
PprUser :: NamePprCtx -> Depth -> Coloured -> PprStyle
PprDump :: NamePprCtx -> PprStyle

-- | Print code; either C or assembler
PprCode :: PprStyle

-- | When printing code that contains original names, we need to map the
--   original names back to something the user understands. This is the
--   purpose of the triple of functions that gets passed around when
--   rendering <a>SDoc</a>.
data NamePprCtx
QueryQualify :: QueryQualifyName -> QueryQualifyModule -> QueryQualifyPackage -> QueryPromotionTick -> NamePprCtx
[queryQualifyName] :: NamePprCtx -> QueryQualifyName
[queryQualifyModule] :: NamePprCtx -> QueryQualifyModule
[queryQualifyPackage] :: NamePprCtx -> QueryQualifyPackage
[queryPromotionTick] :: NamePprCtx -> QueryPromotionTick

-- | Given a <tt>Name</tt>'s <a>Module</a> and <a>OccName</a>, decide
--   whether and how to qualify it.
type QueryQualifyName = Module -> OccName -> QualifyName

-- | For a given module, we need to know whether to print it with a package
--   name to disambiguate it.
type QueryQualifyModule = Module -> Bool

-- | For a given package, we need to know whether to print it with the
--   component id to disambiguate it.
type QueryQualifyPackage = Unit -> Bool

-- | Given a promoted data constructor, decide whether to print a tick to
--   disambiguate the namespace.
type QueryPromotionTick = PromotedItem -> Bool
data PromotedItem
PromotedItemListSyntax :: IsEmptyOrSingleton -> PromotedItem
PromotedItemTupleSyntax :: PromotedItem
PromotedItemDataCon :: OccName -> PromotedItem
newtype IsEmptyOrSingleton
IsEmptyOrSingleton :: Bool -> IsEmptyOrSingleton
isListEmptyOrSingleton :: [a] -> IsEmptyOrSingleton

-- | Flags that affect whether a promotion tick is printed.
data PromotionTickContext
PromTickCtx :: !Bool -> !Bool -> PromotionTickContext
[ptcListTuplePuns] :: PromotionTickContext -> !Bool
[ptcPrintRedundantPromTicks] :: PromotionTickContext -> !Bool
reallyAlwaysQualify :: NamePprCtx
reallyAlwaysQualifyNames :: QueryQualifyName
alwaysQualify :: NamePprCtx

-- | NB: This won't ever show package IDs
alwaysQualifyNames :: QueryQualifyName
alwaysQualifyModules :: QueryQualifyModule
neverQualify :: NamePprCtx
neverQualifyNames :: QueryQualifyName
neverQualifyModules :: QueryQualifyModule
alwaysQualifyPackages :: QueryQualifyPackage
neverQualifyPackages :: QueryQualifyPackage
alwaysPrintPromTick :: QueryPromotionTick
data QualifyName
NameUnqual :: QualifyName
NameQual :: ModuleName -> QualifyName
NameNotInScope1 :: QualifyName
NameNotInScope2 :: QualifyName
queryQual :: PprStyle -> NamePprCtx
sdocOption :: (SDocContext -> a) -> (a -> SDoc) -> SDoc
updSDocContext :: (SDocContext -> SDocContext) -> SDoc -> SDoc
data SDocContext
SDC :: !PprStyle -> !Scheme -> !PprColour -> !Bool -> !Int -> !Int -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !FastString -> SDoc -> SDocContext
[sdocStyle] :: SDocContext -> !PprStyle
[sdocColScheme] :: SDocContext -> !Scheme

-- | The most recently used colour. This allows nesting colours.
[sdocLastColour] :: SDocContext -> !PprColour
[sdocShouldUseColor] :: SDocContext -> !Bool
[sdocDefaultDepth] :: SDocContext -> !Int
[sdocLineLength] :: SDocContext -> !Int

-- | True if Unicode encoding is supported and not disabled by
--   GHC_NO_UNICODE environment variable
[sdocCanUseUnicode] :: SDocContext -> !Bool
[sdocHexWordLiterals] :: SDocContext -> !Bool
[sdocPprDebug] :: SDocContext -> !Bool
[sdocPrintUnicodeSyntax] :: SDocContext -> !Bool
[sdocPrintCaseAsLet] :: SDocContext -> !Bool
[sdocPrintTypecheckerElaboration] :: SDocContext -> !Bool
[sdocPrintAxiomIncomps] :: SDocContext -> !Bool
[sdocPrintExplicitKinds] :: SDocContext -> !Bool
[sdocPrintExplicitCoercions] :: SDocContext -> !Bool
[sdocPrintExplicitRuntimeReps] :: SDocContext -> !Bool
[sdocPrintExplicitForalls] :: SDocContext -> !Bool
[sdocPrintPotentialInstances] :: SDocContext -> !Bool
[sdocPrintEqualityRelations] :: SDocContext -> !Bool
[sdocSuppressTicks] :: SDocContext -> !Bool
[sdocSuppressTypeSignatures] :: SDocContext -> !Bool
[sdocSuppressTypeApplications] :: SDocContext -> !Bool
[sdocSuppressIdInfo] :: SDocContext -> !Bool
[sdocSuppressCoercions] :: SDocContext -> !Bool
[sdocSuppressCoercionTypes] :: SDocContext -> !Bool
[sdocSuppressUnfoldings] :: SDocContext -> !Bool
[sdocSuppressVarKinds] :: SDocContext -> !Bool
[sdocSuppressUniques] :: SDocContext -> !Bool
[sdocSuppressModulePrefixes] :: SDocContext -> !Bool
[sdocSuppressStgExts] :: SDocContext -> !Bool
[sdocSuppressStgReps] :: SDocContext -> !Bool
[sdocErrorSpans] :: SDocContext -> !Bool
[sdocStarIsType] :: SDocContext -> !Bool
[sdocLinearTypes] :: SDocContext -> !Bool
[sdocListTuplePuns] :: SDocContext -> !Bool
[sdocPrintTypeAbbreviations] :: SDocContext -> !Bool

-- | Used to map UnitIds to more friendly "package-version:component"
--   strings while pretty-printing.
--   
--   Use <a>pprWithUnitState</a> to set it. Users should never have to set
--   it to pretty-print SDocs emitted by GHC, otherwise it's a bug. It's an
--   internal field used to thread the UnitState so that the Outputable
--   instance of UnitId can use it.
--   
--   See Note [Pretty-printing UnitId] in <a>GHC.Unit</a> for more details.
--   
--   Note that we use <a>FastString</a> instead of <tt>UnitId</tt> to avoid
--   boring module inter-dependency issues.
[sdocUnitIdForUser] :: SDocContext -> !FastString -> SDoc
sdocWithContext :: (SDocContext -> SDoc) -> SDoc

-- | Default pretty-printing options
defaultSDocContext :: SDocContext
traceSDocContext :: SDocContext
getPprStyle :: (PprStyle -> SDoc) -> SDoc
withPprStyle :: PprStyle -> SDoc -> SDoc
setStyleColoured :: Bool -> PprStyle -> PprStyle
pprDeeper :: SDoc -> SDoc

-- | Truncate a list that is longer than the current depth.
pprDeeperList :: ([SDoc] -> SDoc) -> [SDoc] -> SDoc
pprSetDepth :: Depth -> SDoc -> SDoc
codeStyle :: PprStyle -> Bool
userStyle :: PprStyle -> Bool
dumpStyle :: PprStyle -> Bool
qualName :: PprStyle -> QueryQualifyName
qualModule :: PprStyle -> QueryQualifyModule
qualPackage :: PprStyle -> QueryQualifyPackage
promTick :: PprStyle -> QueryPromotionTick

-- | Style for printing error messages
mkErrStyle :: NamePprCtx -> PprStyle

-- | Default style for error messages, when we don't know NamePprCtx It's a
--   bit of a hack because it doesn't take into account what's in scope
--   Only used for desugarer warnings, and typechecker errors in interface
--   sigs
defaultErrStyle :: PprStyle
defaultDumpStyle :: PprStyle
mkDumpStyle :: NamePprCtx -> PprStyle
defaultUserStyle :: PprStyle
mkUserStyle :: NamePprCtx -> Depth -> PprStyle
cmdlineParserStyle :: PprStyle
data Depth
AllTheWay :: Depth

-- | 0 =&gt; stop
PartWay :: Int -> Depth

-- | Use <a>sdocDefaultDepth</a> field as depth
DefaultDepth :: Depth
withUserStyle :: NamePprCtx -> Depth -> SDoc -> SDoc
withErrStyle :: NamePprCtx -> SDoc -> SDoc

-- | Says what to do with and without -dppr-debug
ifPprDebug :: IsOutput doc => doc -> doc -> doc

-- | Says what to do with -dppr-debug; without, return empty
whenPprDebug :: IsOutput doc => doc -> doc

-- | Indicate if -dppr-debug mode is enabled
getPprDebug :: IsOutput doc => (Bool -> doc) -> doc
bPutHDoc :: BufHandle -> SDocContext -> HDoc -> IO ()
instance GHC.Classes.Eq GHC.Utils.Outputable.BindingSite
instance GHC.Utils.Outputable.Outputable GHC.Data.FastString.NonDetFastString
instance GHC.Utils.Outputable.Outputable GHC.Data.FastString.LexicalFastString
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (Data.Graph.SCC a)
instance GHC.Utils.Outputable.IsDoc GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.IsDoc GHC.Utils.Outputable.HDoc
instance GHC.Utils.Outputable.Outputable GHC.Utils.Outputable.QualifyName
instance GHC.Utils.Outputable.Outputable GHC.Utils.Outputable.PprStyle
instance Data.String.IsString GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.Outputable GHC.Types.Bool
instance GHC.Utils.Outputable.Outputable GHC.Types.Ordering
instance GHC.Utils.Outputable.Outputable ()
instance GHC.Utils.Outputable.Outputable Data.Time.Clock.Internal.UTCTime.UTCTime
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (a, b)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Maybe.Maybe a)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (Data.Either.Either a b)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c) => GHC.Utils.Outputable.Outputable (a, b, c)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d) => GHC.Utils.Outputable.Outputable (a, b, c, d)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d, GHC.Utils.Outputable.Outputable e) => GHC.Utils.Outputable.Outputable (a, b, c, d, e)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d, GHC.Utils.Outputable.Outputable e, GHC.Utils.Outputable.Outputable f) => GHC.Utils.Outputable.Outputable (a, b, c, d, e, f)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b, GHC.Utils.Outputable.Outputable c, GHC.Utils.Outputable.Outputable d, GHC.Utils.Outputable.Outputable e, GHC.Utils.Outputable.Outputable f, GHC.Utils.Outputable.Outputable g) => GHC.Utils.Outputable.Outputable (a, b, c, d, e, f, g)
instance GHC.Utils.Outputable.Outputable GHC.Data.FastString.FastString
instance GHC.Utils.Outputable.Outputable GHC.Fingerprint.Type.Fingerprint
instance GHC.Utils.Outputable.Outputable GHC.Serialized.Serialized
instance GHC.Utils.Outputable.Outputable GHC.LanguageExtensions.Type.Extension
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (Data.Set.Internal.Set a)
instance GHC.Utils.Outputable.IsLine GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.IsLine GHC.Utils.Outputable.HLine
instance GHC.Utils.Outputable.IsOutput GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.IsOutput GHC.Utils.Outputable.HLine
instance GHC.Utils.Outputable.IsOutput GHC.Utils.Outputable.HDoc
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.OutputableP env (GHC.Utils.Outputable.PDoc a)
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env [a]
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (GHC.Maybe.Maybe a)
instance (GHC.Utils.Outputable.OutputableP env a, GHC.Utils.Outputable.OutputableP env b) => GHC.Utils.Outputable.OutputableP env (a, b)
instance (GHC.Utils.Outputable.OutputableP env a, GHC.Utils.Outputable.OutputableP env b, GHC.Utils.Outputable.OutputableP env c) => GHC.Utils.Outputable.OutputableP env (a, b, c)
instance (GHC.Utils.Outputable.OutputableP env key, GHC.Utils.Outputable.OutputableP env elt) => GHC.Utils.Outputable.OutputableP env (Data.Map.Internal.Map key elt)
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (Data.Graph.SCC a)
instance GHC.Utils.Outputable.OutputableP env GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.OutputableP env GHC.Base.Void
instance GHC.Utils.Outputable.Outputable GHC.Utils.Outputable.SDoc
instance GHC.Utils.Outputable.Outputable GHC.Int.Int8
instance GHC.Utils.Outputable.Outputable GHC.Int.Int16
instance GHC.Utils.Outputable.Outputable GHC.Int.Int32
instance GHC.Utils.Outputable.Outputable GHC.Int.Int64
instance GHC.Utils.Outputable.Outputable GHC.Types.Int
instance GHC.Utils.Outputable.Outputable GHC.Num.Integer.Integer
instance GHC.Utils.Outputable.Outputable GHC.Word.Word8
instance GHC.Utils.Outputable.Outputable GHC.Word.Word16
instance GHC.Utils.Outputable.Outputable GHC.Word.Word32
instance GHC.Utils.Outputable.Outputable GHC.Word.Word64
instance GHC.Utils.Outputable.Outputable GHC.Types.Word
instance GHC.Utils.Outputable.Outputable GHC.Types.Float
instance GHC.Utils.Outputable.Outputable GHC.Types.Double
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable [a]
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Base.NonEmpty a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (Data.Set.Internal.Set a)
instance GHC.Utils.Outputable.Outputable GHC.Data.Word64Set.Internal.Word64Set
instance (GHC.Utils.Outputable.Outputable key, GHC.Utils.Outputable.Outputable elt) => GHC.Utils.Outputable.Outputable (Data.Map.Internal.Map key elt)
instance GHC.Utils.Outputable.Outputable elt => GHC.Utils.Outputable.Outputable (Data.IntMap.Internal.IntMap elt)
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Module.Name.ModuleName


-- | Defines basic functions for printing error messages.
--   
--   It's hard to put these functions anywhere else without causing some
--   unnecessary loops in the module dependency graph.
module GHC.Utils.Panic

-- | GHC's own exception type error messages all take the form:
--   
--   <pre>
--   &lt;location&gt;: &lt;error&gt;
--   
--   </pre>
--   
--   If the location is on the command line, or in GHC itself, then
--   &lt;location&gt;="ghc". All of the error types below correspond to a
--   &lt;location&gt; of "ghc", except for ProgramError (where the string
--   is assumed to contain a location already, so we don't print one).
data GhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
Signal :: Int -> GhcException

-- | Prints the short usage msg after the error
UsageError :: String -> GhcException

-- | A problem with the command line arguments, but don't print usage.
CmdLineError :: String -> GhcException

-- | The <tt>impossible</tt> happened.
Panic :: String -> GhcException
PprPanic :: String -> SDoc -> GhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
Sorry :: String -> GhcException
PprSorry :: String -> SDoc -> GhcException

-- | An installation problem.
InstallationError :: String -> GhcException

-- | An error in the user's code, probably.
ProgramError :: String -> GhcException
PprProgramError :: String -> SDoc -> GhcException

-- | Append a description of the given exception to this string.
showGhcException :: SDocContext -> GhcException -> ShowS

-- | Append a description of the given exception to this string.
--   
--   Note that this uses <a>defaultSDocContext</a>, which doesn't use the
--   options set by the user via DynFlags.
showGhcExceptionUnsafe :: GhcException -> ShowS
throwGhcException :: GhcException -> a
throwGhcExceptionIO :: GhcException -> IO a
handleGhcException :: ExceptionMonad m => (GhcException -> m a) -> m a -> m a

-- | Panics and asserts.
pgmError :: HasCallStack => String -> a

-- | Panics and asserts.
panic :: HasCallStack => String -> a

-- | Throw an exception saying "bug in GHC" with a callstack
pprPanic :: HasCallStack => String -> SDoc -> a

-- | Panics and asserts.
sorry :: HasCallStack => String -> a

-- | Throw an exception saying "bug in GHC"
panicDoc :: String -> SDoc -> a

-- | Throw an exception saying "this isn't finished yet"
sorryDoc :: String -> SDoc -> a

-- | Throw an exception saying "bug in pgm being compiled" (used for
--   unusual program errors)
pgmErrorDoc :: String -> SDoc -> a
cmdLineError :: String -> a
cmdLineErrorIO :: String -> IO a

-- | Throw a failed assertion exception for a given filename and line
--   number.
assertPanic :: String -> Int -> a

-- | Panic with an assertion failure, recording the given file and line
--   number. Should typically be accessed with the ASSERT family of macros
assertPprPanic :: HasCallStack => SDoc -> a
assertPpr :: HasCallStack => Bool -> SDoc -> a -> a
assertPprMaybe :: HasCallStack => Maybe SDoc -> a -> a
assertPprM :: (HasCallStack, Monad m) => m Bool -> SDoc -> m ()
massertPpr :: (HasCallStack, Applicative m) => Bool -> SDoc -> m ()
callStackDoc :: HasCallStack => SDoc
prettyCallStackDoc :: CallStack -> SDoc

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | Show an exception as a string.
showException :: Exception e => e -> String

-- | Show an exception which can possibly throw other exceptions. Used when
--   displaying exception thrown within TH code.
safeShowException :: Exception e => e -> IO String

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised then it will be propagated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | Like try, but pass through UserInterrupt and Panic exceptions. Used
--   when we want soft failures when reading interface files, for example.
--   TODO: I'm not entirely sure if this is catching what we really want to
--   catch
tryMost :: IO a -> IO (Either SomeException a)

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | Temporarily install standard signal handlers for catching ^C, which
--   just throw an exception in the current thread.
withSignalHandlers :: ExceptionMonad m => m a -> m a
instance GHC.Exception.Type.Exception GHC.Utils.Panic.GhcException
instance GHC.Show.Show GHC.Utils.Panic.GhcException


-- | Tracing utilities
module GHC.Utils.Trace

-- | If debug output is on, show some <a>SDoc</a> on the screen
pprTrace :: String -> SDoc -> a -> a
pprTraceM :: Applicative f => String -> SDoc -> f ()
pprTraceDebug :: String -> SDoc -> a -> a

-- | <tt>pprTraceIt desc x</tt> is equivalent to <tt>pprTrace desc (ppr x)
--   x</tt>
pprTraceIt :: Outputable a => String -> a -> a

-- | <tt>pprTraceWith desc f x</tt> is equivalent to <tt>pprTrace desc (f
--   x) x</tt>. This allows you to print details from the returned value as
--   well as from ambient variables.
pprTraceWith :: String -> (a -> SDoc) -> a -> a

-- | If debug output is on, show some <a>SDoc</a> on the screen along with
--   a call stack when available.
pprSTrace :: HasCallStack => SDoc -> a -> a

-- | <tt>pprTraceException desc x action</tt> runs action, printing a
--   message if it throws an exception.
pprTraceException :: ExceptionMonad m => String -> SDoc -> m a -> m a

-- | Just warn about an assertion failure, recording the given file and
--   line number.
warnPprTrace :: HasCallStack => Bool -> String -> SDoc -> a -> a

-- | For when we want to show the user a non-fatal WARNING so that they can
--   report a GHC bug, but don't want to panic.
pprTraceUserWarning :: HasCallStack => SDoc -> a -> a

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> and outputs the
--   message to stderr. Depending on your terminal (settings), they may or
--   may not be mixed.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   calling f with x = 123
--   "123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a


-- | Custom GHC <a>Prelude</a>
--   
--   This module serves as a replacement for the <a>Prelude</a> module and
--   abstracts over differences between the bootstrapping GHC version, and
--   may also provide a common default vocabulary.
module GHC.Prelude

-- | If debug output is on, show some <a>SDoc</a> on the screen
pprTrace :: String -> SDoc -> a -> a
pprTraceM :: Applicative f => String -> SDoc -> f ()
pprTraceDebug :: String -> SDoc -> a -> a

-- | <tt>pprTraceIt desc x</tt> is equivalent to <tt>pprTrace desc (ppr x)
--   x</tt>
pprTraceIt :: Outputable a => String -> a -> a

-- | <tt>pprTraceWith desc f x</tt> is equivalent to <tt>pprTrace desc (f
--   x) x</tt>. This allows you to print details from the returned value as
--   well as from ambient variables.
pprTraceWith :: String -> (a -> SDoc) -> a -> a

-- | If debug output is on, show some <a>SDoc</a> on the screen along with
--   a call stack when available.
pprSTrace :: HasCallStack => SDoc -> a -> a

-- | <tt>pprTraceException desc x action</tt> runs action, printing a
--   message if it throws an exception.
pprTraceException :: ExceptionMonad m => String -> SDoc -> m a -> m a

-- | Just warn about an assertion failure, recording the given file and
--   line number.
warnPprTrace :: HasCallStack => Bool -> String -> SDoc -> a -> a

-- | For when we want to show the user a non-fatal WARNING so that they can
--   report a GHC bug, but don't want to panic.
pprTraceUserWarning :: HasCallStack => SDoc -> a -> a


-- | Bits of concrete syntax (tokens, layout).
module Language.Haskell.Syntax.Concrete
type LHsToken tok p = XRec p (HsToken tok)
type LHsUniToken tok utok p = XRec p (HsUniToken tok utok)

-- | A token stored in the syntax tree. For example, when parsing a
--   let-expression, we store <tt>HsToken "let"</tt> and <tt>HsToken
--   "in"</tt>. The locations of those tokens can be used to faithfully
--   reproduce (exactprint) the original program text.
data HsToken (tok :: Symbol)
HsTok :: HsToken (tok :: Symbol)

-- | With <tt>UnicodeSyntax</tt>, there might be multiple ways to write the
--   same token. For example an arrow could be either <tt>-&gt;</tt> or
--   <tt>→</tt>. This choice must be recorded in order to exactprint such
--   tokens, so instead of <tt>HsToken "-&gt;"</tt> we introduce
--   <tt>HsUniToken "-&gt;" "→"</tt>.
--   
--   See also <tt>IsUnicodeSyntax</tt> in <tt>GHC.Parser.Annotation</tt>;
--   we do not use here to avoid a dependency.
data HsUniToken (tok :: Symbol) (utok :: Symbol)
HsNormalTok :: HsUniToken (tok :: Symbol) (utok :: Symbol)
HsUnicodeTok :: HsUniToken (tok :: Symbol) (utok :: Symbol)

-- | Layout information for declarations.
data LayoutInfo pass

-- | Explicit braces written by the user.
--   
--   <pre>
--   class C a where { foo :: a; bar :: a }
--   </pre>
ExplicitBraces :: !LHsToken "{" pass -> !LHsToken "}" pass -> LayoutInfo pass

-- | Virtual braces inserted by the layout algorithm.
--   
--   <pre>
--   class C a where
--     foo :: a
--     bar :: a
--   </pre>
VirtualBraces :: !Int -> LayoutInfo pass

-- | Empty or compiler-generated blocks do not have layout information
--   associated with them.
NoLayoutInfo :: LayoutInfo pass
instance GHC.TypeLits.KnownSymbol tok => Data.Data.Data (Language.Haskell.Syntax.Concrete.HsToken tok)
instance (GHC.TypeLits.KnownSymbol tok, GHC.TypeLits.KnownSymbol utok) => Data.Data.Data (Language.Haskell.Syntax.Concrete.HsUniToken tok utok)

module GHC.Utils.Word64
intToWord64 :: HasCallStack => Int -> Word64
word64ToInt :: HasCallStack => Word64 -> Int
truncateWord64ToWord32 :: Word64 -> Word32


-- | A state monad which is strict in its state.
module GHC.Utils.Monad.State.Strict

-- | A state monad which is strict in the state <tt>s</tt>, but lazy in the
--   value <tt>a</tt>.
--   
--   See Note [Strict State monad] for the particular notion of strictness
--   and implementation details.
data State s a
pattern State :: (s -> (# a, s #)) -> State s a
state :: (s -> (a, s)) -> State s a
evalState :: State s a -> s -> a
execState :: State s a -> s -> s
runState :: State s a -> s -> (a, s)
get :: State s s
gets :: (s -> a) -> State s a
put :: s -> State s ()
modify :: (s -> s) -> State s ()
instance GHC.Base.Functor (GHC.Utils.Monad.State.Strict.State s)
instance GHC.Base.Applicative (GHC.Utils.Monad.State.Strict.State s)
instance GHC.Base.Monad (GHC.Utils.Monad.State.Strict.State s)


-- | Utilities related to Monad and Applicative classes Mostly for
--   backwards compatibility.
module GHC.Utils.Monad

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Monads having fixed points with a 'knot-tying' semantics. Instances of
--   <a>MonadFix</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i>Purity</i> <tt><a>mfix</a> (<a>return</a> . h) = <a>return</a>
--   (<a>fix</a> h)</tt></li>
--   <li><i>Left shrinking (or Tightening)</i> <tt><a>mfix</a> (\x -&gt; a
--   &gt;&gt;= \y -&gt; f x y) = a &gt;&gt;= \y -&gt; <a>mfix</a> (\x -&gt;
--   f x y)</tt></li>
--   <li><i>Sliding</i> <tt><a>mfix</a> (<a>liftM</a> h . f) = <a>liftM</a>
--   h (<a>mfix</a> (f . h))</tt>, for strict <tt>h</tt>.</li>
--   <li><i>Nesting</i> <tt><a>mfix</a> (\x -&gt; <a>mfix</a> (\y -&gt; f x
--   y)) = <a>mfix</a> (\x -&gt; f x x)</tt></li>
--   </ul>
--   
--   This class is used in the translation of the recursive <tt>do</tt>
--   notation supported by GHC and Hugs.
class Monad m => MonadFix (m :: Type -> Type)

-- | The fixed point of a monadic computation. <tt><a>mfix</a> f</tt>
--   executes the action <tt>f</tt> only once, with the eventual output fed
--   back as the input. Hence <tt>f</tt> should not be strict, for then
--   <tt><a>mfix</a> f</tt> would diverge.
mfix :: MonadFix m => (a -> m a) -> m a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
zipWith3M :: Monad m => (a -> b -> c -> m d) -> [a] -> [b] -> [c] -> m [d]
zipWith3M_ :: Monad m => (a -> b -> c -> m d) -> [a] -> [b] -> [c] -> m ()
zipWith4M :: Monad m => (a -> b -> c -> d -> m e) -> [a] -> [b] -> [c] -> [d] -> m [e]
zipWithAndUnzipM :: Monad m => (a -> b -> m (c, d)) -> [a] -> [b] -> m ([c], [d])

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | mapAndUnzipM for triples
mapAndUnzip3M :: Monad m => (a -> m (b, c, d)) -> [a] -> m ([b], [c], [d])
mapAndUnzip4M :: Monad m => (a -> m (b, c, d, e)) -> [a] -> m ([b], [c], [d], [e])
mapAndUnzip5M :: Monad m => (a -> m (b, c, d, e, f)) -> [a] -> m ([b], [c], [d], [e], [f])

-- | Monadic version of mapAccumL
mapAccumLM :: (Monad m, Traversable t) => (acc -> x -> m (acc, y)) -> acc -> t x -> m (acc, t y)

-- | Monadic version of mapSnd
mapSndM :: (Applicative m, Traversable f) => (b -> m c) -> f (a, b) -> m (f (a, c))

-- | Monadic version of concatMap
concatMapM :: (Monad m, Traversable f) => (a -> m [b]) -> f a -> m [b]

-- | Applicative version of mapMaybe
mapMaybeM :: Applicative m => (a -> m (Maybe b)) -> [a] -> m [b]

-- | Monadic version of <a>any</a>, aborts the computation at the first
--   <tt>True</tt> value
anyM :: (Monad m, Foldable f) => (a -> m Bool) -> f a -> m Bool

-- | Monad version of <a>all</a>, aborts the computation at the first
--   <tt>False</tt> value
allM :: (Monad m, Foldable f) => (a -> m Bool) -> f a -> m Bool

-- | Monadic version of or
orM :: Monad m => m Bool -> m Bool -> m Bool

-- | Left-to-right monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, ..., w, x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldlM f z t = do
--       aa &lt;- f z a
--       bb &lt;- f aa b
--       ...
--       xx &lt;- f ww x
--       yy &lt;- f xx y
--       return yy -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldlM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldlM f z t =
--       flip f a &gt;=&gt; flip f b &gt;=&gt; ... &gt;=&gt; flip f x &gt;=&gt; flip f y $ z
--   </pre>
--   
--   The monadic effects of <tt>foldlM</tt> are sequenced from left to
--   right.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from an initial segment of the element
--   sequence. If you want to evaluate the monadic effects in right-to-left
--   order, or perhaps be able to short-circuit after processing a tail of
--   the sequence of elements, you'll need to use <a>foldrM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the rightmost element <tt>y</tt>, so that,
--   ignoring effects, the result looks like a left fold:
--   
--   <pre>
--   ((((z `f` a) `f` b) ... `f` w) `f` x) `f` y
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f a e = do { print e ; return $ e : a }
--   
--   &gt;&gt;&gt; foldlM f [] [0..3]
--   0
--   1
--   2
--   3
--   [3,2,1,0]
--   </pre>
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Monadic version of foldl that discards its result
foldlM_ :: (Monad m, Foldable t) => (a -> b -> m a) -> a -> t b -> m ()

-- | Right-to-left monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, c, ..., x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldrM f z t = do
--       yy &lt;- f y z
--       xx &lt;- f x yy
--       ...
--       bb &lt;- f b cc
--       aa &lt;- f a bb
--       return aa -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldrM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldrM f z t = f y &gt;=&gt; f x &gt;=&gt; ... &gt;=&gt; f b &gt;=&gt; f a $ z
--   </pre>
--   
--   The monadic effects of <tt>foldrM</tt> are sequenced from right to
--   left, and e.g. folds of infinite lists will diverge.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from a tail of the element sequence. If
--   you want to evaluate the monadic effects in left-to-right order, or
--   perhaps be able to short-circuit after an initial sequence of
--   elements, you'll need to use <a>foldlM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the leftmost element <tt>a</tt>, so that, ignoring
--   effects, the result looks like a right fold:
--   
--   <pre>
--   a `f` (b `f` (c `f` (... (x `f` (y `f` z))))).
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f i acc = do { print i ; return $ i : acc }
--   
--   &gt;&gt;&gt; foldrM f [] [0..3]
--   3
--   2
--   1
--   0
--   [0,1,2,3]
--   </pre>
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Monadic version of <tt>when</tt>, taking the condition in the monad
whenM :: Monad m => m Bool -> m () -> m ()

-- | Monadic version of <tt>unless</tt>, taking the condition in the monad
unlessM :: Monad m => m Bool -> m () -> m ()

-- | Like <a>filterM</a>, only it reverses the sense of the test.
filterOutM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | Monadic version of <tt>partition</tt>
partitionM :: Monad m => (a -> m Bool) -> [a] -> m ([a], [a])

module GHC.Utils.Lexeme
isLexCon :: FastString -> Bool
isLexVar :: FastString -> Bool
isLexId :: FastString -> Bool
isLexSym :: FastString -> Bool
isLexConId :: FastString -> Bool
isLexConSym :: FastString -> Bool
isLexVarId :: FastString -> Bool
isLexVarSym :: FastString -> Bool
startsVarSym :: Char -> Bool
startsVarId :: Char -> Bool
startsConSym :: Char -> Bool
startsConId :: Char -> Bool

-- | Is this an acceptable variable name?
okVarOcc :: String -> Bool

-- | Is this an acceptable constructor name?
okConOcc :: String -> Bool

-- | Is this an acceptable type name?
okTcOcc :: String -> Bool

-- | Is this an acceptable alphanumeric variable name, assuming it starts
--   with an acceptable letter?
okVarIdOcc :: String -> Bool

-- | Is this an acceptable symbolic variable name, assuming it starts with
--   an acceptable character?
okVarSymOcc :: String -> Bool

-- | Is this an acceptable alphanumeric constructor name, assuming it
--   starts with an acceptable letter?
okConIdOcc :: String -> Bool

-- | Is this an acceptable symbolic constructor name, assuming it starts
--   with an acceptable character?
okConSymOcc :: String -> Bool

module GHC.Utils.CliOption

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option
showOpt :: Option -> String
instance GHC.Classes.Eq GHC.Utils.CliOption.Option

module GHC.Types.ProfAuto

-- | What kind of {-# SCC #-} to add automatically
data ProfAuto

-- | no SCC annotations added
NoProfAuto :: ProfAuto

-- | top-level and nested functions are annotated
ProfAutoAll :: ProfAuto

-- | top-level functions annotated only
ProfAutoTop :: ProfAuto

-- | exported functions annotated only
ProfAutoExports :: ProfAuto

-- | annotate call-sites
ProfAutoCalls :: ProfAuto
instance GHC.Enum.Enum GHC.Types.ProfAuto.ProfAuto
instance GHC.Classes.Eq GHC.Types.ProfAuto.ProfAuto


-- | Haskell Program Coverage (HPC) support
module GHC.Types.HpcInfo

-- | Information about a modules use of Haskell Program Coverage
data HpcInfo
HpcInfo :: Int -> Int -> HpcInfo
[hpcInfoTickCount] :: HpcInfo -> Int
[hpcInfoHash] :: HpcInfo -> Int
NoHpcInfo :: AnyHpcUsage -> HpcInfo

-- | Is hpc used anywhere on the module *tree*?
[hpcUsed] :: HpcInfo -> AnyHpcUsage

-- | This is used to signal if one of my imports used HPC instrumentation
--   even if there is no module-local HPC usage
type AnyHpcUsage = Bool
emptyHpcInfo :: AnyHpcUsage -> HpcInfo

-- | Find out if HPC is used by this module or any of the modules it
--   depends upon
isHpcUsed :: HpcInfo -> AnyHpcUsage

module GHC.SysTools.Terminal

-- | Does the controlling terminal support ANSI color sequences? This
--   memoized to avoid thread-safety issues in ncurses (see #17922).
stderrSupportsAnsiColors :: Bool

module GHC.SysTools.Ar
data ArchiveEntry
ArchiveEntry :: String -> Int -> Int -> Int -> Int -> Int -> ByteString -> ArchiveEntry

-- | File name.
[filename] :: ArchiveEntry -> String

-- | File modification time.
[filetime] :: ArchiveEntry -> Int

-- | File owner.
[fileown] :: ArchiveEntry -> Int

-- | File group.
[filegrp] :: ArchiveEntry -> Int

-- | File mode.
[filemode] :: ArchiveEntry -> Int

-- | File size.
[filesize] :: ArchiveEntry -> Int

-- | File bytes.
[filedata] :: ArchiveEntry -> ByteString
newtype Archive
Archive :: [ArchiveEntry] -> Archive
afilter :: (ArchiveEntry -> Bool) -> Archive -> Archive
parseAr :: ByteString -> Archive
loadAr :: FilePath -> IO Archive
loadObj :: FilePath -> IO ArchiveEntry
writeBSDAr :: FilePath -> Archive -> IO ()
writeGNUAr :: FilePath -> Archive -> IO ()
isBSDSymdef :: ArchiveEntry -> Bool
isGNUSymdef :: ArchiveEntry -> Bool
instance GHC.Show.Show GHC.SysTools.Ar.ArchiveEntry
instance GHC.Classes.Eq GHC.SysTools.Ar.ArchiveEntry
instance GHC.Base.Monoid GHC.SysTools.Ar.Archive
instance GHC.Base.Semigroup GHC.SysTools.Ar.Archive
instance GHC.Show.Show GHC.SysTools.Ar.Archive
instance GHC.Classes.Eq GHC.SysTools.Ar.Archive


-- | Compile-time settings
module GHC.Settings.Constants
hiVersion :: Integer
mAX_TUPLE_SIZE :: Int
mAX_CTUPLE_SIZE :: Int
mAX_SUM_SIZE :: Int

-- | Default maximum depth for both class instance search and type family
--   reduction. See also #5395.
mAX_REDUCTION_DEPTH :: Int

-- | Default maximum constraint-solver iterations Typically there should be
--   very few
mAX_SOLVER_ITERATIONS :: Int
wORD64_SIZE :: Int
fLOAT_SIZE :: Int
dOUBLE_SIZE :: Int
tARGET_MAX_CHAR :: Int


-- | Linker configuration
module GHC.Linker.Config
data FrameworkOpts
FrameworkOpts :: [String] -> [String] -> FrameworkOpts
[foFrameworkPaths] :: FrameworkOpts -> [String]
[foCmdlineFrameworks] :: FrameworkOpts -> [String]

module GHC.Linker


-- | External plugins
--   
--   GHC supports two kinds of "static" plugins: 1. internal: setup with
--   GHC-API 2. external: setup as explained below and loaded from shared
--   libraries
--   
--   The intended use case for external static plugins is with cross
--   compilers: at the time of writing, GHC is mono-target and a GHC
--   cross-compiler (i.e. when host /= target) can't build nor load plugins
--   for the host using the "non-static" plugin approach. Fixing this is
--   tracked in #14335. If you're not using a cross-compiler, you'd better
--   use non-static plugins which are easier to build and and safer to use
--   (see below).
--   
--   External static plugins can be configured via the command-line with
--   the -fplugin-library flag. Syntax is:
--   
--   <ul>
--   <li>fplugin-library=⟨file-path⟩;⟨unit-id⟩;⟨module⟩;⟨args⟩</li>
--   </ul>
--   
--   Example:
--   -fplugin-library=path<i>to</i>plugin;package-123;Plugin.Module;[<a>Argument</a>,<a>List</a>]
--   
--   Building the plugin library: 1. link with the libraries used to build
--   the compiler you target. If you target a cross-compiler (stage2), you
--   can't directly use it to build the plugin library. Use the stage1
--   compiler instead.
--   
--   <ol>
--   <li>if you use cabal to build the library, its unit-id will be set by
--   cabal and will contain a hash (e.g.
--   "my-plugin-unit-1345656546ABCDEF"). To force the unit id, use GHC's
--   `-this-unit-id` command line flag: e.g. -this-unit-id my-plugin-unit
--   You can set this in the .cabal file of your library with the following
--   stanza: `ghc-options: -this-unit-id my-plugin-unit`</li>
--   <li>To make your plugin easier to distribute, you may want to link it
--   statically with all its dependencies. You would need to use `-shared`
--   without `-dynamic` when building your library.</li>
--   </ol>
--   
--   However, all the static dependencies have to be built with `-fPIC` and
--   it's not done by default. See
--   <a>https://www.hobson.space/posts/haskell-foreign-library/</a> for a
--   way to modify the compiler to do it.
--   
--   In any case, don't link your plugin library statically with the RTS
--   (e.g. use `-fno-link-rts`) as there are some global variables in the
--   RTS that must be shared between the plugin and the compiler.
--   
--   With external static plugins we don't check the type of the
--   <tt>plugin</tt> closure we look up. If it's not a valid
--   <tt>Plugin</tt> value, it will probably crash badly.
module GHC.Driver.Plugins.External

-- | External plugin spec
data ExternalPluginSpec
ExternalPluginSpec :: !FilePath -> !String -> !String -> ![String] -> ExternalPluginSpec
[esp_lib] :: ExternalPluginSpec -> !FilePath
[esp_unit_id] :: ExternalPluginSpec -> !String
[esp_module] :: ExternalPluginSpec -> !String
[esp_args] :: ExternalPluginSpec -> ![String]

-- | Parser external static plugin specification from command-line flag
parseExternalPluginSpec :: String -> Maybe ExternalPluginSpec


-- | In versions of GHC up through 9.2, a <tt>Backend</tt> was represented
--   only by its name. This module is meant to aid clients written against
--   the GHC API, versions 9.2 and older. The module provides an
--   alternative way to name any back end found in GHC 9.2. /Code within
--   the GHC source tree should not import this module./ (#20927).
--   
--   Only back ends found in version 9.2 have names.
module GHC.Driver.Backend.Internal
data BackendName

-- | Names the native code generator backend.
NCG :: BackendName

-- | Names the LLVM backend.
LLVM :: BackendName

-- | Names the Via-C backend.
ViaC :: BackendName

-- | Names the JS backend.
JavaScript :: BackendName

-- | Names the ByteCode interpreter.
Interpreter :: BackendName

-- | Names the `-fno-code` backend.
NoBackend :: BackendName
instance GHC.Show.Show GHC.Driver.Backend.Internal.BackendName
instance GHC.Classes.Eq GHC.Driver.Backend.Internal.BackendName

module GHC.Data.UnionFind

-- | A variable which can be unified; alternately, this can be thought of
--   as an equivalence class with a distinguished representative.
newtype Point s a
Point :: STRef s (Link s a) -> Point s a

-- | Mutable write to a <a>Point</a>
writePoint :: Point s a -> Link s a -> ST s ()

-- | Read the current value of <a>Point</a>.
readPoint :: Point s a -> ST s (Link s a)

-- | The internal data structure for a <a>Point</a>, which either records
--   the representative element of an equivalence class, or a link to the
--   <a>Point</a> that actually stores the representative type.
data Link s a
Info :: {-# UNPACK #-} !STRef s Int -> {-# UNPACK #-} !STRef s a -> Link s a
Link :: {-# UNPACK #-} !Point s a -> Link s a

-- | Create a fresh equivalence class with one element.
fresh :: a -> ST s (Point s a)

-- | Flatten any chains of links, returning a <a>Point</a> which points
--   directly to the canonical representation.
repr :: Point s a -> ST s (Point s a)

-- | Return the canonical element of an equivalence class <a>Point</a>.
find :: Point s a -> ST s a

-- | Unify two equivalence classes, so that they share a canonical element.
--   Keeps the descriptor of point2.
union :: Point s a -> Point s a -> ST s ()

-- | Test if two points are in the same equivalence class.
equivalent :: Point s a -> Point s a -> ST s Bool
instance GHC.Classes.Eq (GHC.Data.UnionFind.Point s a)

module GHC.Data.Unboxed

-- | Like Maybe, but using unboxed sums.
--   
--   Use with care. Using a unboxed maybe is not always a win in execution
--   *time* even when allocations go down. So make sure to benchmark for
--   execution time as well. If the difference in *runtime* for the
--   compiler is too small to measure it's likely better to use a regular
--   Maybe instead.
--   
--   This is since it causes more function arguments to be passed, and
--   potentially more variables to be captured by closures increasing
--   closure size.
data MaybeUB a
pattern JustUB :: a -> MaybeUB a
pattern NothingUB :: MaybeUB a
fmapMaybeUB :: (a -> b) -> MaybeUB a -> MaybeUB b
fromMaybeUB :: a -> MaybeUB a -> a
apMaybeUB :: MaybeUB (a -> b) -> MaybeUB a -> MaybeUB b
maybeUB :: b -> (a -> b) -> MaybeUB a -> b

module GHC.Data.StringBuffer

-- | A StringBuffer is an internal pointer to a sized chunk of bytes. The
--   bytes are intended to be *immutable*. There are pure operations to
--   read the contents of a StringBuffer.
--   
--   A StringBuffer may have a finalizer, depending on how it was obtained.
data StringBuffer
StringBuffer :: {-# UNPACK #-} !ForeignPtr Word8 -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> StringBuffer
[buf] :: StringBuffer -> {-# UNPACK #-} !ForeignPtr Word8
[len] :: StringBuffer -> {-# UNPACK #-} !Int
[cur] :: StringBuffer -> {-# UNPACK #-} !Int

-- | Read a file into a <a>StringBuffer</a>. The resulting buffer is
--   automatically managed by the garbage collector.
hGetStringBuffer :: FilePath -> IO StringBuffer
hGetStringBufferBlock :: Handle -> Int -> IO StringBuffer
hPutStringBuffer :: Handle -> StringBuffer -> IO ()
appendStringBuffers :: StringBuffer -> StringBuffer -> IO StringBuffer

-- | Encode a <a>String</a> into a <a>StringBuffer</a> as UTF-8. The
--   resulting buffer is automatically managed by the garbage collector.
stringToStringBuffer :: String -> StringBuffer

-- | Convert a UTF-8 encoded <a>ByteString</a> into a 'StringBuffer. This
--   really relies on the internals of both <a>ByteString</a> and
--   <a>StringBuffer</a>.
--   
--   <i>O(n)</i> (but optimized into a <tt>memcpy</tt> by
--   <tt>bytestring</tt> under the hood)
stringBufferFromByteString :: ByteString -> StringBuffer

-- | Return the first UTF-8 character of a nonempty <a>StringBuffer</a> and
--   as well the remaining portion (analogous to <a>uncons</a>).
--   <b>Warning:</b> The behavior is undefined if the <a>StringBuffer</a>
--   is empty. The result shares the same buffer as the original. Similar
--   to <tt>utf8DecodeChar</tt>, if the character cannot be decoded as
--   UTF-8, <tt>'\0'</tt> is returned.
nextChar :: StringBuffer -> (Char, StringBuffer)

-- | Return the first UTF-8 character of a nonempty <a>StringBuffer</a>
--   (analogous to <a>head</a>). <b>Warning:</b> The behavior is undefined
--   if the <a>StringBuffer</a> is empty. Similar to
--   <tt>utf8DecodeChar</tt>, if the character cannot be decoded as UTF-8,
--   <tt>'\0'</tt> is returned.
currentChar :: StringBuffer -> Char
prevChar :: StringBuffer -> Char -> Char

-- | Check whether a <a>StringBuffer</a> is empty (analogous to
--   <a>null</a>).
atEnd :: StringBuffer -> Bool

-- | Computes a hash of the contents of a <a>StringBuffer</a>.
fingerprintStringBuffer :: StringBuffer -> Fingerprint

-- | Return a <a>StringBuffer</a> with the first UTF-8 character removed
--   (analogous to <a>tail</a>). <b>Warning:</b> The behavior is undefined
--   if the <a>StringBuffer</a> is empty. The result shares the same buffer
--   as the original.
stepOn :: StringBuffer -> StringBuffer

-- | Return a <a>StringBuffer</a> with the first <tt>n</tt> bytes removed.
--   <b>Warning:</b> If there aren't enough characters, the returned
--   <a>StringBuffer</a> will be invalid and any use of it may lead to
--   undefined behavior. The result shares the same buffer as the original.
offsetBytes :: Int -> StringBuffer -> StringBuffer

-- | Compute the difference in offset between two <a>StringBuffer</a>s that
--   share the same buffer. <b>Warning:</b> The behavior is undefined if
--   the <a>StringBuffer</a>s use separate buffers.
byteDiff :: StringBuffer -> StringBuffer -> Int

-- | Computes a <a>StringBuffer</a> which points to the first character of
--   the wanted line. Lines begin at 1.
atLine :: Int -> StringBuffer -> Maybe StringBuffer

-- | Decode the first <tt>n</tt> bytes of a <a>StringBuffer</a> as UTF-8
--   into a <a>String</a>. Similar to <tt>utf8DecodeChar</tt>, if the
--   character cannot be decoded as UTF-8, they will be replaced with
--   <tt>'\0'</tt>.
lexemeToString :: StringBuffer -> Int -> String
lexemeToFastString :: StringBuffer -> Int -> FastString

-- | Return the previous <tt>n</tt> characters (or fewer if we are less
--   than <tt>n</tt> characters into the buffer.
decodePrevNChars :: Int -> StringBuffer -> String
parseUnsignedInteger :: StringBuffer -> Int -> Integer -> (Char -> Int) -> Integer

-- | Returns true if the buffer contains Unicode bi-directional formatting
--   characters.
--   
--   
--   <a>https://www.unicode.org/reports/tr9/#Bidirectional_Character_Types</a>
--   
--   Bidirectional format characters are one of 'x202a' : "U+202A
--   LEFT-TO-RIGHT EMBEDDING (LRE)" 'x202b' : "U+202B RIGHT-TO-LEFT
--   EMBEDDING (RLE)" 'x202c' : "U+202C POP DIRECTIONAL FORMATTING (PDF)"
--   'x202d' : "U+202D LEFT-TO-RIGHT OVERRIDE (LRO)" 'x202e' : "U+202E
--   RIGHT-TO-LEFT OVERRIDE (RLO)" 'x2066' : "U+2066 LEFT-TO-RIGHT ISOLATE
--   (LRI)" 'x2067' : "U+2067 RIGHT-TO-LEFT ISOLATE (RLI)" 'x2068' :
--   "U+2068 FIRST STRONG ISOLATE (FSI)" 'x2069' : "U+2069 POP DIRECTIONAL
--   ISOLATE (PDI)"
--   
--   This list is encoded in <a>bidirectionalFormatChars</a>
containsBidirectionalFormatChar :: StringBuffer -> Bool
bidirectionalFormatChars :: [(Char, String)]
instance GHC.Show.Show GHC.Data.StringBuffer.StringBuffer

module GHC.Data.Strict
data Maybe a
Nothing :: Maybe a
Just :: !a -> Maybe a
fromMaybe :: a -> Maybe a -> a
data Pair a b
And :: !a -> !b -> Pair a b
instance Data.Data.Data a => Data.Data.Data (GHC.Data.Strict.Maybe a)
instance Data.Traversable.Traversable GHC.Data.Strict.Maybe
instance Data.Foldable.Foldable GHC.Data.Strict.Maybe
instance GHC.Base.Functor GHC.Data.Strict.Maybe
instance GHC.Show.Show a => GHC.Show.Show (GHC.Data.Strict.Maybe a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Data.Strict.Maybe a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.Strict.Maybe a)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (GHC.Data.Strict.Pair a b)
instance Data.Traversable.Traversable (GHC.Data.Strict.Pair a)
instance Data.Foldable.Foldable (GHC.Data.Strict.Pair a)
instance GHC.Base.Functor (GHC.Data.Strict.Pair a)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (GHC.Data.Strict.Pair a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (GHC.Data.Strict.Pair a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (GHC.Data.Strict.Pair a b)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Data.Strict.Maybe a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (GHC.Data.Strict.Maybe a)
instance GHC.Base.Applicative GHC.Data.Strict.Maybe
instance GHC.Base.Alternative GHC.Data.Strict.Maybe


-- | Monadic streams
module GHC.Data.Stream

-- | <tt>Stream m a b</tt> is a computation in some Monad <tt>m</tt> that
--   delivers a sequence of elements of type <tt>a</tt> followed by a
--   result of type <tt>b</tt>.
--   
--   More concretely, a value of type <tt>Stream m a b</tt> can be run
--   using <tt>runStreamInternal</tt> in the Monad <tt>m</tt>, and it
--   delivers either
--   
--   <ul>
--   <li>the final result: <tt>Done b</tt>, or</li>
--   <li><tt>Yield a str</tt> where <tt>a</tt> is the next element in the
--   stream, and <tt>str</tt> is the rest of the stream</li>
--   <li><tt>Effect mstr</tt> where <tt>mstr</tt> is some action running in
--   <tt>m</tt> which generates the rest of the stream.</li>
--   </ul>
--   
--   Stream is itself a Monad, and provides an operation <a>yield</a> that
--   produces a new element of the stream. This makes it convenient to turn
--   existing monadic computations into streams.
--   
--   The idea is that Stream is useful for making a monadic computation
--   that produces values from time to time. This can be used for knitting
--   together two complex monadic operations, so that the producer does not
--   have to produce all its values before the consumer starts consuming
--   them. We make the producer into a Stream, and the consumer pulls on
--   the stream each time it wants a new value.
--   
--   <a>Stream</a> is implemented in the "yoneda" style for efficiency. By
--   representing a stream in this manner <a>fmap</a> and <a>&gt;&gt;=</a>
--   operations are accumulated in the function parameters before being
--   applied once when the stream is destroyed. In the old implementation
--   each usage of <a>mapM</a> and <a>&gt;&gt;=</a> would traverse the
--   entire stream in order to apply the substitution at the leaves.
--   
--   The &gt;&gt;= operation for <a>Stream</a> was a hot-spot in the ticky
--   profile for the <a>ManyConstructors</a> test which called the
--   <tt>cg</tt> function many times in <tt>StgToCmm.hs</tt>
newtype Stream m a b
Stream :: (forall r' r. (a -> m r') -> (b -> StreamS m r' r) -> StreamS m r' r) -> Stream m a b
[runStreamInternal] :: Stream m a b -> forall r' r. (a -> m r') -> (b -> StreamS m r' r) -> StreamS m r' r
data StreamS m a b
Yield :: a -> StreamS m a b -> StreamS m a b
Done :: b -> StreamS m a b
Effect :: m (StreamS m a b) -> StreamS m a b
runStream :: Applicative m => Stream m r' r -> StreamS m r' r
yield :: Monad m => a -> Stream m a ()

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a

-- | Turn a Stream into an ordinary list, by demanding all the elements.
collect :: Monad m => Stream m a () -> m [a]
consume :: (Monad m, Monad n) => Stream m a b -> (forall a. m a -> n a) -> (a -> n ()) -> n b

-- | Turn a list into a <a>Stream</a>, by yielding each element in turn.
fromList :: Monad m => [a] -> Stream m a ()

-- | Apply a function to each element of a <a>Stream</a>, lazily
map :: Monad m => (a -> b) -> Stream m a x -> Stream m b x

-- | Apply a monadic operation to each element of a <a>Stream</a>, lazily
mapM :: Monad m => (a -> m b) -> Stream m a x -> Stream m b x

-- | Note this is not very efficient because it traverses the whole stream
--   before rebuilding it, avoid using it if you can. mapAccumL used to
--   implemented but it wasn't used anywhere in the compiler and has
--   similar efficiency problems.
mapAccumL_ :: forall m a b c r. Monad m => (c -> a -> m (c, b)) -> c -> Stream m a r -> Stream m b (c, r)
instance GHC.Base.Functor m => GHC.Base.Functor (GHC.Data.Stream.StreamS m a)
instance GHC.Base.Functor (GHC.Data.Stream.Stream f a)
instance GHC.Base.Applicative (GHC.Data.Stream.Stream m a)
instance GHC.Base.Monad (GHC.Data.Stream.Stream m a)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (GHC.Data.Stream.Stream m b)
instance GHC.Base.Monad m => GHC.Base.Applicative (GHC.Data.Stream.StreamS m a)
instance GHC.Base.Monad m => GHC.Base.Monad (GHC.Data.Stream.StreamS m a)


-- | Small-array
module GHC.Data.SmallArray
data SmallMutableArray s a
SmallMutableArray :: SmallMutableArray# s a -> SmallMutableArray s a
data SmallArray a
SmallArray :: SmallArray# a -> SmallArray a
newSmallArray :: Int -> a -> State# s -> (# State# s, SmallMutableArray s a #)
writeSmallArray :: SmallMutableArray s a -> Int -> a -> State# s -> State# s

-- | Copy and freeze a slice of a mutable array.
freezeSmallArray :: SmallMutableArray s a -> Int -> Int -> State# s -> (# State# s, SmallArray a #)

-- | Freeze a mutable array (no copy!)
unsafeFreezeSmallArray :: SmallMutableArray s a -> State# s -> (# State# s, SmallArray a #)

-- | Index a small-array (no bounds checking!)
indexSmallArray :: SmallArray a -> Int -> a

-- | Convert a list into an array.
listToArray :: Int -> (e -> Int) -> (e -> a) -> [e] -> SmallArray a

module GHC.Data.Maybe
data MaybeErr err val
Succeeded :: val -> MaybeErr err val
Failed :: err -> MaybeErr err val
failME :: err -> MaybeErr err val
isSuccess :: MaybeErr err val -> Bool

-- | Flipped version of <tt>fromMaybe</tt>, useful for chaining.
orElse :: Maybe a -> a -> a
infixr 4 `orElse`
firstJust :: Maybe a -> Maybe a -> Maybe a

-- | Takes a list of <tt>Maybes</tt> and returns the first <tt>Just</tt> if
--   there is one, or <tt>Nothing</tt> otherwise.
firstJusts :: Foldable f => f (Maybe a) -> Maybe a

-- | Takes computations returnings <tt>Maybes</tt>; tries each one in
--   order. The first one to return a <tt>Just</tt> wins. Returns
--   <tt>Nothing</tt> if all computations return <tt>Nothing</tt>.
firstJustsM :: (Monad m, Foldable f) => f (m (Maybe a)) -> m (Maybe a)
whenIsJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
expectJust :: HasCallStack => String -> Maybe a -> a
rightToMaybe :: Either a b -> Maybe b

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype () => MaybeT (m :: Type -> Type) a
MaybeT :: m (Maybe a) -> MaybeT (m :: Type -> Type) a
[runMaybeT] :: MaybeT (m :: Type -> Type) a -> m (Maybe a)
liftMaybeT :: Monad m => m a -> MaybeT m a

-- | Try performing an <a>IO</a> action, failing on error.
tryMaybeT :: IO a -> MaybeT IO a
instance GHC.Base.Functor (GHC.Data.Maybe.MaybeErr err)
instance GHC.Base.Applicative (GHC.Data.Maybe.MaybeErr err)
instance GHC.Base.Monad (GHC.Data.Maybe.MaybeErr err)

module GHC.Data.FiniteMap
insertList :: Ord key => [(key, elt)] -> Map key elt -> Map key elt
insertListWith :: Ord key => (elt -> elt -> elt) -> [(key, elt)] -> Map key elt -> Map key elt
deleteList :: Ord key => [key] -> Map key elt -> Map key elt
foldRight :: (elt -> a -> a) -> a -> Map key elt -> a
foldRightWithKey :: (key -> elt -> a -> a) -> a -> Map key elt -> a

module GHC.CmmToAsm.X86.Cond
data Cond
ALWAYS :: Cond
EQQ :: Cond
GE :: Cond
GEU :: Cond
GTT :: Cond
GU :: Cond
LE :: Cond
LEU :: Cond
LTT :: Cond
LU :: Cond
NE :: Cond
NEG :: Cond
POS :: Cond
CARRY :: Cond
OFLO :: Cond
PARITY :: Cond
NOTPARITY :: Cond
condToUnsigned :: Cond -> Cond

-- | <tt>maybeFlipCond c</tt> returns <tt>Just c'</tt> if it is possible to
--   flip the arguments to the conditional <tt>c</tt>, and the new
--   condition should be <tt>c'</tt>.
maybeFlipCond :: Cond -> Maybe Cond

-- | If we apply <tt>maybeInvertCond</tt> to the condition of a jump we
--   turn jumps taken into jumps not taken and vice versa.
--   
--   Careful! If the used comparison and the conditional jump don't match
--   the above behaviour will NOT hold. When used for FP comparisons this
--   does not consider unordered numbers. Also inverting twice might return
--   a synonym for the original condition.
maybeInvertCond :: Cond -> Maybe Cond
instance GHC.Classes.Eq GHC.CmmToAsm.X86.Cond.Cond


-- | The Lengauer-Tarjan graph dominators algorithm.
--   
--   &lt;math&gt; Lengauer, Tarjan, <i>A Fast Algorithm for Finding
--   Dominators in a Flowgraph</i>, 1979.
--   
--   &lt;math&gt; Muchnick, <i>Advanced Compiler Design and
--   Implementation</i>, 1997.
--   
--   &lt;math&gt; Brisk, Sarrafzadeh, <i>Interference CGraphs for
--   Procedures in Static Single</i> <i>Information Form are Interval
--   CGraphs</i>, 2007.
--   
--   <ul>
--   <li>Strictness</li>
--   </ul>
--   
--   Unless stated otherwise all exposed functions might fully evaluate
--   their input but are not guaranteed to do so.
module GHC.CmmToAsm.CFG.Dominators
type Node = Word64
type Path = [Node]
type Edge = (Node, Node)
type Graph = Word64Map Word64Set
type Rooted = (Node, Graph)

-- | <i>Immediate dominators</i>. <i>O(|E|*alpha(|E|,|V|))</i>, where
--   <i>alpha(m,n)</i> is "a functional inverse of Ackermann's function".
--   
--   This Complexity bound assumes <i>O(1)</i> indexing. Since we're using
--   <tt>IntMap</tt>, it has an additional <i>lg |V|</i> factor somewhere
--   in there. I'm not sure where.
idom :: Rooted -> [(Node, Node)]

-- | <i>Immediate post-dominators</i>. Complexity as for <tt>idom</tt>.
ipdom :: Rooted -> [(Node, Node)]

-- | <i>Dominator tree</i>. Complexity as for <tt>idom</tt>.
domTree :: Rooted -> Tree Node

-- | <i>Post-dominator tree</i>. Complexity as for <tt>idom</tt>.
pdomTree :: Rooted -> Tree Node

-- | <i>Dominators</i>. Complexity as for <tt>idom</tt>
dom :: Rooted -> [(Node, Path)]

-- | <i>Post-dominators</i>. Complexity as for <tt>idom</tt>.
pdom :: Rooted -> [(Node, Path)]

-- | <i>Post-dominated depth-first search</i>.
pddfs :: Rooted -> [Node]

-- | <i>Reverse post-dominated depth-first search</i>.
rpddfs :: Rooted -> [Node]
fromAdj :: [(Node, [Node])] -> Graph
fromEdges :: [Edge] -> Graph
toAdj :: Graph -> [(Node, [Node])]
toEdges :: Graph -> [Edge]
asTree :: Rooted -> Tree Node
asCGraph :: Tree Node -> Rooted
parents :: Tree a -> [(a, a)]
ancestors :: Tree a -> [(a, [a])]
instance GHC.Base.Functor (GHC.CmmToAsm.CFG.Dominators.S z s)
instance GHC.Base.Monad (GHC.CmmToAsm.CFG.Dominators.S z s)
instance GHC.Base.Applicative (GHC.CmmToAsm.CFG.Dominators.S z s)

module GHC.CmmToAsm.AArch64.Cond
data Cond
ALWAYS :: Cond
EQ :: Cond
NE :: Cond
SLT :: Cond
SLE :: Cond
SGE :: Cond
SGT :: Cond
ULT :: Cond
ULE :: Cond
UGE :: Cond
UGT :: Cond
OLT :: Cond
OLE :: Cond
OGE :: Cond
OGT :: Cond
UOLT :: Cond
UOLE :: Cond
UOGE :: Cond
UOGT :: Cond
VS :: Cond
VC :: Cond
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Cond.Cond

module GHC.Cmm.Dataflow.Collections
class IsSet set where {
    type ElemOf set;
}
setNull :: IsSet set => set -> Bool
setSize :: IsSet set => set -> Int
setMember :: IsSet set => ElemOf set -> set -> Bool
setEmpty :: IsSet set => set
setSingleton :: IsSet set => ElemOf set -> set
setInsert :: IsSet set => ElemOf set -> set -> set
setDelete :: IsSet set => ElemOf set -> set -> set
setUnion :: IsSet set => set -> set -> set
setDifference :: IsSet set => set -> set -> set
setIntersection :: IsSet set => set -> set -> set
setIsSubsetOf :: IsSet set => set -> set -> Bool
setFilter :: IsSet set => (ElemOf set -> Bool) -> set -> set
setFoldl :: IsSet set => (b -> ElemOf set -> b) -> b -> set -> b
setFoldr :: IsSet set => (ElemOf set -> b -> b) -> b -> set -> b
setElems :: IsSet set => set -> [ElemOf set]
setFromList :: IsSet set => [ElemOf set] -> set
setInsertList :: IsSet set => [ElemOf set] -> set -> set
setDeleteList :: IsSet set => [ElemOf set] -> set -> set
setUnions :: IsSet set => [set] -> set
class IsMap map where {
    type KeyOf map;
}
mapNull :: IsMap map => map a -> Bool
mapSize :: IsMap map => map a -> Int
mapMember :: IsMap map => KeyOf map -> map a -> Bool
mapLookup :: IsMap map => KeyOf map -> map a -> Maybe a
mapFindWithDefault :: IsMap map => a -> KeyOf map -> map a -> a
mapEmpty :: IsMap map => map a
mapSingleton :: IsMap map => KeyOf map -> a -> map a
mapInsert :: IsMap map => KeyOf map -> a -> map a -> map a
mapInsertWith :: IsMap map => (a -> a -> a) -> KeyOf map -> a -> map a -> map a
mapDelete :: IsMap map => KeyOf map -> map a -> map a
mapAlter :: IsMap map => (Maybe a -> Maybe a) -> KeyOf map -> map a -> map a
mapAdjust :: IsMap map => (a -> a) -> KeyOf map -> map a -> map a
mapUnion :: IsMap map => map a -> map a -> map a
mapUnionWithKey :: IsMap map => (KeyOf map -> a -> a -> a) -> map a -> map a -> map a
mapDifference :: IsMap map => map a -> map a -> map a
mapIntersection :: IsMap map => map a -> map a -> map a
mapIsSubmapOf :: (IsMap map, Eq a) => map a -> map a -> Bool
mapMap :: IsMap map => (a -> b) -> map a -> map b
mapMapWithKey :: IsMap map => (KeyOf map -> a -> b) -> map a -> map b
mapFoldl :: IsMap map => (b -> a -> b) -> b -> map a -> b
mapFoldr :: IsMap map => (a -> b -> b) -> b -> map a -> b
mapFoldlWithKey :: IsMap map => (b -> KeyOf map -> a -> b) -> b -> map a -> b
mapFoldMapWithKey :: (IsMap map, Monoid m) => (KeyOf map -> a -> m) -> map a -> m
mapFilter :: IsMap map => (a -> Bool) -> map a -> map a
mapFilterWithKey :: IsMap map => (KeyOf map -> a -> Bool) -> map a -> map a
mapElems :: IsMap map => map a -> [a]
mapKeys :: IsMap map => map a -> [KeyOf map]
mapToList :: IsMap map => map a -> [(KeyOf map, a)]
mapFromList :: IsMap map => [(KeyOf map, a)] -> map a
mapFromListWith :: IsMap map => (a -> a -> a) -> [(KeyOf map, a)] -> map a
mapInsertList :: IsMap map => [(KeyOf map, a)] -> map a -> map a
mapDeleteList :: IsMap map => [KeyOf map] -> map a -> map a
mapUnions :: IsMap map => [map a] -> map a
data UniqueMap v
data UniqueSet
instance GHC.Base.Monoid GHC.Cmm.Dataflow.Collections.UniqueSet
instance GHC.Base.Semigroup GHC.Cmm.Dataflow.Collections.UniqueSet
instance GHC.Show.Show GHC.Cmm.Dataflow.Collections.UniqueSet
instance GHC.Classes.Ord GHC.Cmm.Dataflow.Collections.UniqueSet
instance GHC.Classes.Eq GHC.Cmm.Dataflow.Collections.UniqueSet
instance Data.Traversable.Traversable GHC.Cmm.Dataflow.Collections.UniqueMap
instance Data.Foldable.Foldable GHC.Cmm.Dataflow.Collections.UniqueMap
instance GHC.Base.Functor GHC.Cmm.Dataflow.Collections.UniqueMap
instance GHC.Show.Show v => GHC.Show.Show (GHC.Cmm.Dataflow.Collections.UniqueMap v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (GHC.Cmm.Dataflow.Collections.UniqueMap v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (GHC.Cmm.Dataflow.Collections.UniqueMap v)
instance GHC.Cmm.Dataflow.Collections.IsMap GHC.Cmm.Dataflow.Collections.UniqueMap
instance GHC.Cmm.Dataflow.Collections.IsSet GHC.Cmm.Dataflow.Collections.UniqueSet

module GHC.Cmm.Dataflow.Block

-- | Used at the type level to indicate "open" vs "closed" structure.
data Extensibility

-- | An "open" structure with a unique, unnamed control-flow edge flowing
--   in or out. "Fallthrough" and concatenation are permitted at an open
--   point.
Open :: Extensibility

-- | A "closed" structure which supports control transfer only through the
--   use of named labels---no "fallthrough" is permitted. The number of
--   control-flow edges is unconstrained.
Closed :: Extensibility
type O = 'Open
type C = 'Closed

-- | Maybe type indexed by open/closed
data MaybeO ex t
[JustO] :: t -> MaybeO O t
[NothingO] :: MaybeO C t

-- | Either type indexed by closed/open using type families
type family IndexedCO (ex :: Extensibility) (a :: k) (b :: k) :: k

-- | A sequence of nodes. May be any of four shapes (O<i>O, O</i>C, C<i>O,
--   C</i>C). Open at the entry means single entry, mutatis mutandis for
--   exit. A closed<i>closed block is a </i>basic/ block and can't be
--   extended further. Clients should avoid manipulating blocks and should
--   stick to either nodes or graphs.
data Block n e x
[BlockCO] :: n C O -> Block n O O -> Block n C O
[BlockCC] :: n C O -> Block n O O -> n O C -> Block n C C
[BlockOC] :: Block n O O -> n O C -> Block n O C
[BNil] :: Block n O O
[BMiddle] :: n O O -> Block n O O
[BCat] :: Block n O O -> Block n O O -> Block n O O
[BSnoc] :: Block n O O -> n O O -> Block n O O
[BCons] :: n O O -> Block n O O -> Block n O O
blockAppend :: Block n e O -> Block n O x -> Block n e x
blockConcat :: [Block n O O] -> Block n O O
blockCons :: n O O -> Block n O x -> Block n O x
blockFromList :: [n O O] -> Block n O O
blockJoin :: n C O -> Block n O O -> n O C -> Block n C C
blockJoinHead :: n C O -> Block n O x -> Block n C x
blockJoinTail :: Block n e O -> n O C -> Block n e C
blockSnoc :: Block n e O -> n O O -> Block n e O

-- | Split a closed block into its entry node, open middle block, and exit
--   node.
blockSplit :: Block n C C -> (n C O, Block n O O, n O C)
blockSplitHead :: Block n C x -> (n C O, Block n O x)
blockSplitTail :: Block n e C -> (Block n e O, n O C)
blockToList :: Block n O O -> [n O O]
emptyBlock :: Block n O O
firstNode :: Block n C x -> n C O
foldBlockNodesB :: forall n a. (forall e x. n e x -> a -> a) -> forall e x. Block n e x -> IndexedCO x a a -> IndexedCO e a a
foldBlockNodesB3 :: forall n a b c. (n C O -> b -> c, n O O -> b -> b, n O C -> a -> b) -> forall e x. Block n e x -> IndexedCO x a b -> IndexedCO e c b
foldBlockNodesF :: forall n a. (forall e x. n e x -> a -> a) -> forall e x. Block n e x -> IndexedCO e a a -> IndexedCO x a a
isEmptyBlock :: Block n e x -> Bool
lastNode :: Block n x C -> n O C

-- | map a function over the nodes of a <a>Block</a>
mapBlock :: (forall e x. n e x -> n' e x) -> Block n e x -> Block n' e x

-- | A strict <a>mapBlock</a>
mapBlock' :: (forall e x. n e x -> n' e x) -> Block n e x -> Block n' e x

-- | map over a block, with different functions to apply to first nodes,
--   middle nodes and last nodes respectively. The map is strict.
mapBlock3' :: forall n n' e x. (n C O -> n' C O, n O O -> n' O O, n O C -> n' O C) -> Block n e x -> Block n' e x
replaceFirstNode :: Block n C x -> n C O -> Block n C x
replaceLastNode :: Block n x C -> n O C -> Block n x C
instance GHC.Base.Functor (GHC.Cmm.Dataflow.Block.MaybeO ex)

module GHC.SysTools.BaseDir

-- | Expand occurrences of the <tt>$topdir</tt> interpolation in a string.
expandTopDir :: FilePath -> String -> String

-- | Expand occurrences of the <tt>$tooldir</tt> interpolation in a string
--   on Windows, leave the string untouched otherwise.
expandToolDir :: Bool -> Maybe FilePath -> String -> String

-- | Returns a Unix-format path pointing to TopDir.
findTopDir :: Maybe String -> IO String
findToolDir :: Bool -> FilePath -> IO (Maybe FilePath)
tryFindTopDir :: Maybe String -> IO (Maybe String)

module GHC.Parser.CharClass
is_ident :: Char -> Bool
is_symbol :: Char -> Bool
is_any :: Char -> Bool
is_space :: Char -> Bool
is_lower :: Char -> Bool
is_upper :: Char -> Bool
is_digit :: Char -> Bool
is_alphanum :: Char -> Bool
is_decdigit :: Char -> Bool
is_hexdigit :: Char -> Bool
is_octdigit :: Char -> Bool
is_bindigit :: Char -> Bool
hexDigit :: Char -> Int
octDecDigit :: Char -> Int


-- | Static and Dynamic Inductive Graphs
--   
--   Code is from Hackage <tt>fgl</tt> package version 5.7.0.3
module GHC.Data.Graph.Inductive.Graph

-- | Unlabeled node
type Node = Int

-- | Labeled node
type LNode a = (Node, a)

-- | Quasi-unlabeled node
type UNode = LNode ()

-- | Unlabeled edge
type Edge = (Node, Node)

-- | Labeled edge
type LEdge b = (Node, Node, b)

-- | Quasi-unlabeled edge
type UEdge = LEdge ()

-- | Labeled links to or from a <a>Node</a>.
type Adj b = [(b, Node)]

-- | Links to the <a>Node</a>, the <a>Node</a> itself, a label, links from
--   the <a>Node</a>.
--   
--   In other words, this captures all information regarding the specified
--   <a>Node</a> within a graph.
type Context a b = (Adj b, Node, a, Adj b)
type MContext a b = Maybe (Context a b)

-- | <a>Graph</a> decomposition - the context removed from a <a>Graph</a>,
--   and the rest of the <a>Graph</a>.
type Decomp g a b = (MContext a b, g a b)

-- | The same as <a>Decomp</a>, only more sure of itself.
type GDecomp g a b = (Context a b, g a b)

-- | Unlabeled context.
type UContext = ([Node], Node, [Node])

-- | Unlabeled decomposition.
type UDecomp g = (Maybe UContext, g)

-- | Unlabeled path
type Path = [Node]

-- | Labeled path
newtype LPath a
LP :: [LNode a] -> LPath a
[unLPath] :: LPath a -> [LNode a]

-- | Quasi-unlabeled path
type UPath = [UNode]

-- | Minimum implementation: <a>empty</a>, <a>isEmpty</a>, <a>match</a>,
--   <a>mkGraph</a>, <a>labNodes</a>
class Graph gr

-- | An empty <a>Graph</a>.
empty :: Graph gr => gr a b

-- | True if the given <a>Graph</a> is empty.
isEmpty :: Graph gr => gr a b -> Bool

-- | Decompose a <a>Graph</a> into the <a>MContext</a> found for the given
--   node and the remaining <a>Graph</a>.
match :: Graph gr => Node -> gr a b -> Decomp gr a b

-- | Create a <a>Graph</a> from the list of <a>LNode</a>s and
--   <a>LEdge</a>s.
--   
--   For graphs that are also instances of <a>DynGraph</a>, <tt>mkGraph ns
--   es</tt> should be equivalent to <tt>(<a>insEdges</a> es .
--   <a>insNodes</a> ns) <a>empty</a></tt>.
mkGraph :: Graph gr => [LNode a] -> [LEdge b] -> gr a b

-- | A list of all <a>LNode</a>s in the <a>Graph</a>.
labNodes :: Graph gr => gr a b -> [LNode a]

-- | Decompose a graph into the <a>Context</a> for an arbitrarily-chosen
--   <a>Node</a> and the remaining <a>Graph</a>.
matchAny :: Graph gr => gr a b -> GDecomp gr a b

-- | The number of <a>Node</a>s in a <a>Graph</a>.
noNodes :: Graph gr => gr a b -> Int

-- | The minimum and maximum <a>Node</a> in a <a>Graph</a>.
nodeRange :: Graph gr => gr a b -> (Node, Node)

-- | A list of all <a>LEdge</a>s in the <a>Graph</a>.
labEdges :: Graph gr => gr a b -> [LEdge b]
class (Graph gr) => DynGraph gr

-- | Merge the <a>Context</a> into the <a>DynGraph</a>.
--   
--   Context adjacencies should only refer to either a Node already in a
--   graph or the node in the Context itself (for loops).
--   
--   Behaviour is undefined if the specified <a>Node</a> already exists in
--   the graph.
(&) :: DynGraph gr => Context a b -> gr a b -> gr a b

-- | The number of nodes in the graph. An alias for <a>noNodes</a>.
order :: Graph gr => gr a b -> Int

-- | The number of edges in the graph.
--   
--   Note that this counts every edge found, so if you are representing an
--   unordered graph by having each edge mirrored this will be incorrect.
--   
--   If you created an unordered graph by either mirroring every edge
--   (including loops!) or using the <tt>undir</tt> function in
--   <a>Data.Graph.Inductive.Basic</a> then you can safely halve the value
--   returned by this.
size :: Graph gr => gr a b -> Int

-- | Fold a function over the graph by recursively calling <a>match</a>.
ufold :: Graph gr => (Context a b -> c -> c) -> c -> gr a b -> c

-- | Map a function over the graph by recursively calling <a>match</a>.
gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d

-- | Map a function over the <a>Node</a> labels in a graph.
nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b

-- | Map a function over the <a>Edge</a> labels in a graph.
emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c

-- | Map functions over both the <a>Node</a> and <a>Edge</a> labels in a
--   graph.
nemap :: DynGraph gr => (a -> c) -> (b -> d) -> gr a b -> gr c d

-- | List all <a>Node</a>s in the <a>Graph</a>.
nodes :: Graph gr => gr a b -> [Node]

-- | List all <a>Edge</a>s in the <a>Graph</a>.
edges :: Graph gr => gr a b -> [Edge]

-- | Drop the label component of an edge.
toEdge :: LEdge b -> Edge

-- | The label in an edge.
edgeLabel :: LEdge b -> b

-- | Add a label to an edge.
toLEdge :: Edge -> b -> LEdge b

-- | List N available <a>Node</a>s, i.e. <a>Node</a>s that are not used in
--   the <a>Graph</a>.
newNodes :: Graph gr => Int -> gr a b -> [Node]

-- | <a>True</a> if the <a>Node</a> is present in the <a>Graph</a>.
gelem :: Graph gr => Node -> gr a b -> Bool

-- | Insert a <a>LNode</a> into the <a>Graph</a>.
insNode :: DynGraph gr => LNode a -> gr a b -> gr a b

-- | Insert a <a>LEdge</a> into the <a>Graph</a>.
insEdge :: DynGraph gr => LEdge b -> gr a b -> gr a b

-- | Remove a <a>Node</a> from the <a>Graph</a>.
delNode :: Graph gr => Node -> gr a b -> gr a b

-- | Remove an <a>Edge</a> from the <a>Graph</a>.
--   
--   NOTE: in the case of multiple edges, this will delete <i>all</i> such
--   edges from the graph as there is no way to distinguish between them.
--   If you need to delete only a single such edge, please use
--   <a>delLEdge</a>.
delEdge :: DynGraph gr => Edge -> gr a b -> gr a b

-- | Remove an <a>LEdge</a> from the <a>Graph</a>.
--   
--   NOTE: in the case of multiple edges with the same label, this will
--   only delete the <i>first</i> such edge. To delete all such edges,
--   please use <tt>delAllLedge</tt>.
delLEdge :: (DynGraph gr, Eq b) => LEdge b -> gr a b -> gr a b

-- | Remove all edges equal to the one specified.
delAllLEdge :: (DynGraph gr, Eq b) => LEdge b -> gr a b -> gr a b

-- | Insert multiple <a>LNode</a>s into the <a>Graph</a>.
insNodes :: DynGraph gr => [LNode a] -> gr a b -> gr a b

-- | Insert multiple <a>LEdge</a>s into the <a>Graph</a>.
insEdges :: DynGraph gr => [LEdge b] -> gr a b -> gr a b

-- | Remove multiple <a>Node</a>s from the <a>Graph</a>.
delNodes :: Graph gr => [Node] -> gr a b -> gr a b

-- | Remove multiple <a>Edge</a>s from the <a>Graph</a>.
delEdges :: DynGraph gr => [Edge] -> gr a b -> gr a b

-- | Build a <a>Graph</a> from a list of <a>Context</a>s.
--   
--   The list should be in the order such that earlier <a>Context</a>s
--   depend upon later ones (i.e. as produced by <tt><a>ufold</a> (:)
--   []</tt>).
buildGr :: DynGraph gr => [Context a b] -> gr a b

-- | Build a quasi-unlabeled <a>Graph</a>.
mkUGraph :: Graph gr => [Node] -> [Edge] -> gr () ()

-- | Build a graph out of the contexts for which the predicate is satisfied
--   by recursively calling <a>match</a>.
gfiltermap :: DynGraph gr => (Context a b -> MContext c d) -> gr a b -> gr c d

-- | Returns the subgraph only containing the nodes which satisfy the given
--   predicate.
nfilter :: DynGraph gr => (Node -> Bool) -> gr a b -> gr a b

-- | Returns the subgraph only containing the labelled nodes which satisfy
--   the given predicate.
labnfilter :: Graph gr => (LNode a -> Bool) -> gr a b -> gr a b

-- | Returns the subgraph only containing the nodes whose labels satisfy
--   the given predicate.
labfilter :: DynGraph gr => (a -> Bool) -> gr a b -> gr a b

-- | Returns the subgraph induced by the supplied nodes.
subgraph :: DynGraph gr => [Node] -> gr a b -> gr a b

-- | Find the context for the given <a>Node</a>. Causes an error if the
--   <a>Node</a> is not present in the <a>Graph</a>.
context :: Graph gr => gr a b -> Node -> Context a b

-- | Find the label for a <a>Node</a>.
lab :: Graph gr => gr a b -> Node -> Maybe a

-- | Find the neighbors for a <a>Node</a>.
neighbors :: Graph gr => gr a b -> Node -> [Node]

-- | Find the labelled links coming into or going from a <a>Context</a>.
lneighbors :: Graph gr => gr a b -> Node -> Adj b

-- | Find all <a>Node</a>s that have a link from the given <a>Node</a>.
suc :: Graph gr => gr a b -> Node -> [Node]

-- | Find all <a>Node</a>s that link to to the given <a>Node</a>.
pre :: Graph gr => gr a b -> Node -> [Node]

-- | Find all <a>Node</a>s that are linked from the given <a>Node</a> and
--   the label of each link.
lsuc :: Graph gr => gr a b -> Node -> [(Node, b)]

-- | Find all <a>Node</a>s that link to the given <a>Node</a> and the label
--   of each link.
lpre :: Graph gr => gr a b -> Node -> [(Node, b)]

-- | Find all outward-bound <a>LEdge</a>s for the given <a>Node</a>.
out :: Graph gr => gr a b -> Node -> [LEdge b]

-- | Find all inward-bound <a>LEdge</a>s for the given <a>Node</a>.
inn :: Graph gr => gr a b -> Node -> [LEdge b]

-- | The outward-bound degree of the <a>Node</a>.
outdeg :: Graph gr => gr a b -> Node -> Int

-- | The inward-bound degree of the <a>Node</a>.
indeg :: Graph gr => gr a b -> Node -> Int

-- | The degree of the <a>Node</a>.
deg :: Graph gr => gr a b -> Node -> Int

-- | Checks if there is a directed edge between two nodes.
hasEdge :: Graph gr => gr a b -> Edge -> Bool

-- | Checks if there is an undirected edge between two nodes.
hasNeighbor :: Graph gr => gr a b -> Node -> Node -> Bool

-- | Checks if there is a labelled edge between two nodes.
hasLEdge :: (Graph gr, Eq b) => gr a b -> LEdge b -> Bool

-- | Checks if there is an undirected labelled edge between two nodes.
hasNeighborAdj :: (Graph gr, Eq b) => gr a b -> Node -> (b, Node) -> Bool
equal :: (Eq a, Eq b, Graph gr) => gr a b -> gr a b -> Bool

-- | The <a>Node</a> in a <a>Context</a>.
node' :: Context a b -> Node

-- | The label in a <a>Context</a>.
lab' :: Context a b -> a

-- | The <a>LNode</a> from a <a>Context</a>.
labNode' :: Context a b -> LNode a

-- | All <a>Node</a>s linked to or from in a <a>Context</a>.
neighbors' :: Context a b -> [Node]

-- | All labelled links coming into or going from a <a>Context</a>.
lneighbors' :: Context a b -> Adj b

-- | All <a>Node</a>s linked to in a <a>Context</a>.
suc' :: Context a b -> [Node]

-- | All <a>Node</a>s linked from in a <a>Context</a>.
pre' :: Context a b -> [Node]

-- | All <a>Node</a>s linked from in a <a>Context</a>, and the label of the
--   links.
lpre' :: Context a b -> [(Node, b)]

-- | All <a>Node</a>s linked from in a <a>Context</a>, and the label of the
--   links.
lsuc' :: Context a b -> [(Node, b)]

-- | All outward-directed <a>LEdge</a>s in a <a>Context</a>.
out' :: Context a b -> [LEdge b]

-- | All inward-directed <a>LEdge</a>s in a <a>Context</a>.
inn' :: Context a b -> [LEdge b]

-- | The outward degree of a <a>Context</a>.
outdeg' :: Context a b -> Int

-- | The inward degree of a <a>Context</a>.
indeg' :: Context a b -> Int

-- | The degree of a <a>Context</a>.
deg' :: Context a b -> Int

-- | Pretty-print the graph. Note that this loses a lot of information,
--   such as edge inverses, etc.
prettify :: (DynGraph gr, Show a, Show b) => gr a b -> String

-- | Pretty-print the graph to stdout.
prettyPrint :: (DynGraph gr, Show a, Show b) => gr a b -> IO ()

-- | OrdGr comes equipped with an Ord instance, so that graphs can be used
--   as e.g. Map keys.
newtype OrdGr gr a b
OrdGr :: gr a b -> OrdGr gr a b
[unOrdGr] :: OrdGr gr a b -> gr a b
instance GHC.Read.Read b => GHC.Read.Read (GHC.Data.Graph.Inductive.Graph.GroupEdges b)
instance GHC.Show.Show b => GHC.Show.Show (GHC.Data.Graph.Inductive.Graph.GroupEdges b)
instance GHC.Show.Show (gr a b) => GHC.Show.Show (GHC.Data.Graph.Inductive.Graph.OrdGr gr a b)
instance GHC.Read.Read (gr a b) => GHC.Read.Read (GHC.Data.Graph.Inductive.Graph.OrdGr gr a b)
instance (GHC.Data.Graph.Inductive.Graph.Graph gr, GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Eq (GHC.Data.Graph.Inductive.Graph.OrdGr gr a b)
instance (GHC.Data.Graph.Inductive.Graph.Graph gr, GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (GHC.Data.Graph.Inductive.Graph.OrdGr gr a b)
instance GHC.Classes.Eq b => GHC.Classes.Eq (GHC.Data.Graph.Inductive.Graph.GroupEdges b)
instance GHC.Show.Show a => GHC.Show.Show (GHC.Data.Graph.Inductive.Graph.LPath a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.Graph.Inductive.Graph.LPath a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Data.Graph.Inductive.Graph.LPath a)


-- | An efficient implementation of <a>Graph</a> using big-endian patricia
--   tree (i.e. <a>Data.IntMap</a>).
--   
--   This module provides the following specialised functions to gain more
--   performance, using GHC's RULES pragma:
--   
--   <ul>
--   <li><a>insNode</a></li>
--   <li><a>insEdge</a></li>
--   <li><a>gmap</a></li>
--   <li><a>nmap</a></li>
--   <li><a>emap</a></li>
--   </ul>
--   
--   Code is from Hackage <tt>fgl</tt> package version 5.7.0.3
module GHC.Data.Graph.Inductive.PatriciaTree
data Gr a b
type UGr = Gr () ()
instance GHC.Generics.Generic (GHC.Data.Graph.Inductive.PatriciaTree.Gr a b)
instance GHC.Read.Read a => GHC.Read.Read (GHC.Data.Graph.Inductive.PatriciaTree.FromListCounting a)
instance GHC.Show.Show a => GHC.Show.Show (GHC.Data.Graph.Inductive.PatriciaTree.FromListCounting a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.Graph.Inductive.PatriciaTree.FromListCounting a)
instance (GHC.Classes.Eq a, GHC.Classes.Ord b) => GHC.Classes.Eq (GHC.Data.Graph.Inductive.PatriciaTree.Gr a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (GHC.Data.Graph.Inductive.PatriciaTree.Gr a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (GHC.Data.Graph.Inductive.PatriciaTree.Gr a b)
instance GHC.Data.Graph.Inductive.Graph.Graph GHC.Data.Graph.Inductive.PatriciaTree.Gr
instance GHC.Data.Graph.Inductive.Graph.DynGraph GHC.Data.Graph.Inductive.PatriciaTree.Gr
instance GHC.Base.Functor (GHC.Data.Graph.Inductive.PatriciaTree.Gr a)
instance Data.Bifunctor.Bifunctor GHC.Data.Graph.Inductive.PatriciaTree.Gr

module GHC.CmmToAsm.PPC.Cond
data Cond
ALWAYS :: Cond
EQQ :: Cond
GE :: Cond
GEU :: Cond
GTT :: Cond
GU :: Cond
LE :: Cond
LEU :: Cond
LTT :: Cond
LU :: Cond
NE :: Cond
condNegate :: Cond -> Cond
condUnsigned :: Cond -> Bool
instance GHC.Classes.Eq GHC.CmmToAsm.PPC.Cond.Cond

module GHC.CmmToAsm.CFG.Weight

-- | Edge weights to use when generating a CFG from CMM
data Weights
Weights :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Weights
[uncondWeight] :: Weights -> Int
[condBranchWeight] :: Weights -> Int
[switchWeight] :: Weights -> Int
[callWeight] :: Weights -> Int
[likelyCondWeight] :: Weights -> Int
[unlikelyCondWeight] :: Weights -> Int
[infoTablePenalty] :: Weights -> Int
[backEdgeBonus] :: Weights -> Int

-- | Default edge weights
defaultWeights :: Weights
parseWeights :: String -> Weights -> Weights

module GHC.Utils.Json

-- | Simple data type to represent JSON documents.
data JsonDoc
[JSNull] :: JsonDoc
[JSBool] :: Bool -> JsonDoc
[JSInt] :: Int -> JsonDoc
[JSString] :: String -> JsonDoc
[JSArray] :: [JsonDoc] -> JsonDoc
[JSObject] :: [(String, JsonDoc)] -> JsonDoc
renderJSON :: JsonDoc -> SDoc
escapeJsonString :: String -> String
class ToJson a
json :: ToJson a => a -> JsonDoc
instance GHC.Utils.Json.ToJson GHC.Base.String
instance GHC.Utils.Json.ToJson GHC.Types.Int


-- | Unit identifier pretty-printing
module GHC.Unit.Ppr

-- | Subset of UnitInfo: just enough to pretty-print a unit-id
--   
--   Instead of printing the unit-id which may contain a hash, we print:
--   package-version:componentname
data UnitPprInfo
UnitPprInfo :: FastString -> String -> Version -> Maybe String -> UnitPprInfo

-- | Identifier
[unitPprId] :: UnitPprInfo -> FastString

-- | Source package name
[unitPprPackageName] :: UnitPprInfo -> String

-- | Source package version
[unitPprPackageVersion] :: UnitPprInfo -> Version

-- | Component name
[unitPprComponentName] :: UnitPprInfo -> Maybe String
instance GHC.Utils.Outputable.Outputable GHC.Unit.Ppr.UnitPprInfo


-- | This module contains types that relate to the positions of things in
--   source files, and allow tagging of those things with locations
module GHC.Types.SrcLoc

-- | Real Source Location
--   
--   Represents a single point within a file
data RealSrcLoc

-- | Source Location
data SrcLoc
RealSrcLoc :: !RealSrcLoc -> !Maybe BufPos -> SrcLoc
UnhelpfulLoc :: !FastString -> SrcLoc
mkSrcLoc :: FastString -> Int -> Int -> SrcLoc
mkRealSrcLoc :: FastString -> Int -> Int -> RealSrcLoc

-- | Creates a "bad" <a>RealSrcLoc</a> that has no detailed information
--   about its location
mkGeneralSrcLoc :: FastString -> SrcLoc

-- | Indentation level is 1-indexed, so the leftmost column is 1.
leftmostColumn :: Int

-- | Built-in "bad" <a>RealSrcLoc</a> values for particular locations
noSrcLoc :: SrcLoc

-- | Built-in "bad" <a>RealSrcLoc</a> values for particular locations
generatedSrcLoc :: SrcLoc

-- | Built-in "bad" <a>RealSrcLoc</a> values for particular locations
interactiveSrcLoc :: SrcLoc

-- | Move the <a>RealSrcLoc</a> down by one line if the character is a
--   newline, to the next 8-char tabstop if it is a tab, and across by one
--   character in any other case
advanceSrcLoc :: RealSrcLoc -> Char -> RealSrcLoc
advanceBufPos :: BufPos -> BufPos

-- | Gives the filename of the <a>RealSrcLoc</a>
srcLocFile :: RealSrcLoc -> FastString

-- | Raises an error when used on a "bad" <a>RealSrcLoc</a>
srcLocLine :: RealSrcLoc -> Int

-- | Raises an error when used on a "bad" <a>RealSrcLoc</a>
srcLocCol :: RealSrcLoc -> Int

-- | A <a>RealSrcSpan</a> delimits a portion of a text file. It could be
--   represented by a pair of (line,column) coordinates, but in fact we
--   optimise slightly by using more compact representations for
--   single-line and zero-length spans, both of which are quite common.
--   
--   The end position is defined to be the column <i>after</i> the end of
--   the span. That is, a span of (1,1)-(1,2) is one character long, and a
--   span of (1,1)-(1,1) is zero characters long.
--   
--   Real Source Span
data RealSrcSpan

-- | Source Span
--   
--   A <a>SrcSpan</a> identifies either a specific portion of a text file
--   or a human-readable description of a location.
data SrcSpan
RealSrcSpan :: !RealSrcSpan -> !Maybe BufSpan -> SrcSpan
UnhelpfulSpan :: !UnhelpfulSpanReason -> SrcSpan
data UnhelpfulSpanReason
UnhelpfulNoLocationInfo :: UnhelpfulSpanReason
UnhelpfulWiredIn :: UnhelpfulSpanReason
UnhelpfulInteractive :: UnhelpfulSpanReason
UnhelpfulGenerated :: UnhelpfulSpanReason
UnhelpfulOther :: !FastString -> UnhelpfulSpanReason

-- | Create a "bad" <a>SrcSpan</a> that has not location information
mkGeneralSrcSpan :: FastString -> SrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkSrcSpan :: SrcLoc -> SrcLoc -> SrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkRealSrcSpan :: RealSrcLoc -> RealSrcLoc -> RealSrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
noSrcSpan :: SrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
generatedSrcSpan :: SrcSpan
isGeneratedSrcSpan :: SrcSpan -> Bool

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
wiredInSrcSpan :: SrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
interactiveSrcSpan :: SrcSpan

-- | Create a <a>SrcSpan</a> corresponding to a single point
srcLocSpan :: SrcLoc -> SrcSpan
realSrcLocSpan :: RealSrcLoc -> RealSrcSpan

-- | Combines two <a>SrcSpan</a> into one that spans at least all the
--   characters within both spans. Returns UnhelpfulSpan if the files
--   differ.
combineSrcSpans :: SrcSpan -> SrcSpan -> SrcSpan

-- | Convert a SrcSpan into one that represents only its first character
srcSpanFirstCharacter :: SrcSpan -> SrcSpan

-- | Returns the location at the start of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanStart :: SrcSpan -> SrcLoc

-- | Returns the location at the end of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanEnd :: SrcSpan -> SrcLoc
realSrcSpanStart :: RealSrcSpan -> RealSrcLoc
realSrcSpanEnd :: RealSrcSpan -> RealSrcLoc

-- | Obtains the filename for a <a>SrcSpan</a> if it is "good"
srcSpanFileName_maybe :: SrcSpan -> Maybe FastString
pprUserRealSpan :: Bool -> RealSrcSpan -> SDoc
pprUnhelpfulSpanReason :: UnhelpfulSpanReason -> SDoc
pprUserSpan :: Bool -> SrcSpan -> SDoc
unhelpfulSpanFS :: UnhelpfulSpanReason -> FastString
srcSpanToRealSrcSpan :: SrcSpan -> Maybe RealSrcSpan
srcSpanFile :: RealSrcSpan -> FastString
srcSpanStartLine :: RealSrcSpan -> Int
srcSpanEndLine :: RealSrcSpan -> Int
srcSpanStartCol :: RealSrcSpan -> Int
srcSpanEndCol :: RealSrcSpan -> Int

-- | Test if a <a>SrcSpan</a> is "good", i.e. has precise location
--   information
isGoodSrcSpan :: SrcSpan -> Bool

-- | True if the span is known to straddle only one line. For "bad"
--   <a>SrcSpan</a>, it returns False
isOneLineSpan :: SrcSpan -> Bool

-- | True if the span has a width of zero, as returned for "virtual"
--   semicolons in the lexer. For "bad" <a>SrcSpan</a>, it returns False
isZeroWidthSpan :: SrcSpan -> Bool

-- | Tests whether the first span "contains" the other span, meaning that
--   it covers at least as much source code. True where spans are equal.
containsSpan :: RealSrcSpan -> RealSrcSpan -> Bool
isNoSrcSpan :: SrcSpan -> Bool

-- | 0-based offset identifying the raw location in the
--   <tt>StringBuffer</tt>.
--   
--   The lexer increments the <a>BufPos</a> every time a character (UTF-8
--   code point) is read from the input buffer. As UTF-8 is a
--   variable-length encoding and <tt>StringBuffer</tt> needs a byte offset
--   for indexing, a <a>BufPos</a> cannot be used for indexing.
--   
--   The parser guarantees that <a>BufPos</a> are monotonic. See #17632.
--   This means that syntactic constructs that appear later in the
--   <tt>StringBuffer</tt> are guaranteed to have a higher <a>BufPos</a>.
--   Contrast that with <a>RealSrcLoc</a>, which does *not* make the
--   analogous guarantee about higher line/column numbers.
--   
--   This is due to #line and {-# LINE ... #-} pragmas that can arbitrarily
--   modify <a>RealSrcLoc</a>. Notice how <tt>setSrcLoc</tt> and
--   <tt>resetAlrLastLoc</tt> in <a>GHC.Parser.Lexer</a> update
--   <a>PsLoc</a>, modifying <a>RealSrcLoc</a> but preserving
--   <a>BufPos</a>.
--   
--   Monotonicity makes <a>BufPos</a> useful to determine the order in
--   which syntactic elements appear in the source. Consider this example
--   (haddockA041 in the test suite):
--   
--   haddockA041.hs {-# LANGUAGE CPP #-} -- | Module header documentation
--   module Comments_and_CPP_include where #include "IncludeMe.hs"
--   
--   IncludeMe.hs: -- | Comment on T data T = MkT -- ^ Comment on MkT
--   
--   After the C preprocessor runs, the <tt>StringBuffer</tt> will contain
--   a program that looks like this (unimportant lines at the beginning
--   removed):
--   
--   # 1 "haddockA041.hs" {-# LANGUAGE CPP #-} -- | Module header
--   documentation module Comments_and_CPP_include where # 1 "IncludeMe.hs"
--   1 -- | Comment on T data T = MkT -- ^ Comment on MkT # 7
--   "haddockA041.hs" 2
--   
--   The line pragmas inserted by CPP make the error messages more
--   informative. The downside is that we can't use RealSrcLoc to determine
--   the ordering of syntactic elements.
--   
--   With RealSrcLoc, we have the following location information recorded
--   in the AST: * The module name is located at haddockA041.hs:3:8-31 *
--   The Haddock comment "Comment on T" is located at IncludeMe:1:1-17 *
--   The data declaration is located at IncludeMe.hs:2:1-32
--   
--   Is the Haddock comment located between the module name and the data
--   declaration? This is impossible to tell because the locations are not
--   comparable; they even refer to different files.
--   
--   On the other hand, with <a>BufPos</a>, we have the following location
--   information: * The module name is located at 846-870 * The Haddock
--   comment "Comment on T" is located at 898-915 * The data declaration is
--   located at 916-928
--   
--   Aside: if you're wondering why the numbers are so high, try running
--   <tt>ghc -E haddockA041.hs</tt> and see the extra fluff that CPP
--   inserts at the start of the file.
--   
--   For error messages, <a>BufPos</a> is not useful at all. On the other
--   hand, this is exactly what we need to determine the order of syntactic
--   elements: 870 &lt; 898, therefore the Haddock comment appears *after*
--   the module name. 915 &lt; 916, therefore the Haddock comment appears
--   *before* the data declaration.
--   
--   We use <a>BufPos</a> in in GHC.Parser.PostProcess.Haddock to associate
--   Haddock comments with parts of the AST using location information
--   (#17544).
newtype BufPos
BufPos :: Int -> BufPos
[bufPos] :: BufPos -> Int
getBufPos :: SrcLoc -> Maybe BufPos

-- | StringBuffer Source Span
data BufSpan
BufSpan :: {-# UNPACK #-} !BufPos -> BufSpan
[bufSpanStart, bufSpanEnd] :: BufSpan -> {-# UNPACK #-} !BufPos
getBufSpan :: SrcSpan -> Maybe BufSpan
removeBufSpan :: SrcSpan -> SrcSpan
combineBufSpans :: BufSpan -> BufSpan -> BufSpan
type Located = GenLocated SrcSpan
type RealLocated = GenLocated RealSrcSpan

-- | We attach SrcSpans to lots of things, so let's have a datatype for it.
data GenLocated l e
L :: l -> e -> GenLocated l e
noLoc :: e -> Located e
mkGeneralLocated :: String -> e -> Located e
getLoc :: GenLocated l e -> l
unLoc :: GenLocated l e -> e
unRealSrcSpan :: RealLocated a -> a
getRealSrcSpan :: RealLocated a -> RealSrcSpan
pprLocated :: (Outputable l, Outputable e) => GenLocated l e -> SDoc

-- | Always prints the location, even without -dppr-debug
pprLocatedAlways :: (Outputable l, Outputable e) => GenLocated l e -> SDoc

-- | Tests whether the two located things are equal
eqLocated :: Eq a => GenLocated l a -> GenLocated l a -> Bool

-- | Tests the ordering of the two located things
cmpLocated :: Ord a => GenLocated l a -> GenLocated l a -> Ordering

-- | Compare the <a>BufSpan</a> of two located things.
--   
--   Precondition: both operands have an associated <a>BufSpan</a>.
cmpBufSpan :: HasDebugCallStack => Located a -> Located a -> Ordering
combineLocs :: Located a -> Located b -> SrcSpan

-- | Combine locations from two <a>Located</a> things and add them to a
--   third thing
addCLoc :: Located a -> Located b -> c -> Located c

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_largest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
rightmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Determines whether a span encloses a given line and column index
spans :: SrcSpan -> (Int, Int) -> Bool

-- | Determines whether a span is enclosed by another one
isSubspanOf :: SrcSpan -> SrcSpan -> Bool

-- | Determines whether a span is enclosed by another one
isRealSubspanOf :: RealSrcSpan -> RealSrcSpan -> Bool
sortLocated :: [Located a] -> [Located a]
sortRealLocated :: [RealLocated a] -> [RealLocated a]
lookupSrcLoc :: SrcLoc -> Map RealSrcLoc a -> Maybe a
lookupSrcSpan :: SrcSpan -> Map RealSrcSpan a -> Maybe a

-- | A location as produced by the parser. Consists of two components:
--   
--   <ul>
--   <li>The location in the file, adjusted for #line and {-# LINE ... #-}
--   pragmas (RealSrcLoc)</li>
--   <li>The location in the string buffer (BufPos) with monotonicity
--   guarantees (see #17632)</li>
--   </ul>
data PsLoc
PsLoc :: !RealSrcLoc -> !BufPos -> PsLoc
[psRealLoc] :: PsLoc -> !RealSrcLoc
[psBufPos] :: PsLoc -> !BufPos
data PsSpan
PsSpan :: !RealSrcSpan -> !BufSpan -> PsSpan
[psRealSpan] :: PsSpan -> !RealSrcSpan
[psBufSpan] :: PsSpan -> !BufSpan
type PsLocated = GenLocated PsSpan
advancePsLoc :: PsLoc -> Char -> PsLoc
mkPsSpan :: PsLoc -> PsLoc -> PsSpan
psSpanStart :: PsSpan -> PsLoc
psSpanEnd :: PsSpan -> PsLoc
mkSrcSpanPs :: PsSpan -> SrcSpan

-- | Combines two <a>SrcSpan</a> into one that spans at least all the
--   characters within both spans. Assumes the "file" part is the same in
--   both inputs
combineRealSrcSpans :: RealSrcSpan -> RealSrcSpan -> RealSrcSpan
psLocatedToLocated :: PsLocated a -> Located a
instance GHC.Classes.Ord GHC.Types.SrcLoc.RealSrcLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.RealSrcLoc
instance Data.Data.Data GHC.Types.SrcLoc.BufPos
instance GHC.Show.Show GHC.Types.SrcLoc.BufPos
instance GHC.Classes.Ord GHC.Types.SrcLoc.BufPos
instance GHC.Classes.Eq GHC.Types.SrcLoc.BufPos
instance GHC.Show.Show GHC.Types.SrcLoc.SrcLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.SrcLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.RealSrcSpan
instance Data.Data.Data GHC.Types.SrcLoc.BufSpan
instance GHC.Show.Show GHC.Types.SrcLoc.BufSpan
instance GHC.Classes.Ord GHC.Types.SrcLoc.BufSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.BufSpan
instance GHC.Show.Show GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Classes.Eq GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Show.Show GHC.Types.SrcLoc.SrcSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.SrcSpan
instance Data.Traversable.Traversable (GHC.Types.SrcLoc.GenLocated l)
instance Data.Foldable.Foldable (GHC.Types.SrcLoc.GenLocated l)
instance GHC.Base.Functor (GHC.Types.SrcLoc.GenLocated l)
instance (Data.Data.Data l, Data.Data.Data e) => Data.Data.Data (GHC.Types.SrcLoc.GenLocated l e)
instance (GHC.Show.Show l, GHC.Show.Show e) => GHC.Show.Show (GHC.Types.SrcLoc.GenLocated l e)
instance (GHC.Classes.Ord l, GHC.Classes.Ord e) => GHC.Classes.Ord (GHC.Types.SrcLoc.GenLocated l e)
instance (GHC.Classes.Eq l, GHC.Classes.Eq e) => GHC.Classes.Eq (GHC.Types.SrcLoc.GenLocated l e)
instance GHC.Show.Show GHC.Types.SrcLoc.PsLoc
instance GHC.Classes.Ord GHC.Types.SrcLoc.PsLoc
instance GHC.Classes.Eq GHC.Types.SrcLoc.PsLoc
instance Data.Data.Data GHC.Types.SrcLoc.PsSpan
instance GHC.Show.Show GHC.Types.SrcLoc.PsSpan
instance GHC.Classes.Ord GHC.Types.SrcLoc.PsSpan
instance GHC.Classes.Eq GHC.Types.SrcLoc.PsSpan
instance GHC.Utils.Outputable.Outputable e => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.Located e)
instance (Control.DeepSeq.NFData l, Control.DeepSeq.NFData e) => Control.DeepSeq.NFData (GHC.Types.SrcLoc.GenLocated l e)
instance GHC.Utils.Outputable.Outputable e => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated GHC.Types.SrcLoc.RealSrcSpan e)
instance Data.Data.Data GHC.Types.SrcLoc.SrcSpan
instance GHC.Utils.Json.ToJson GHC.Types.SrcLoc.SrcSpan
instance Control.DeepSeq.NFData GHC.Types.SrcLoc.SrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.SrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Base.Semigroup GHC.Types.SrcLoc.BufSpan
instance Data.Data.Data GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Utils.Json.ToJson GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Classes.Ord GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Show.Show GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.RealSrcSpan
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.SrcLoc
instance GHC.Utils.Outputable.Outputable GHC.Types.SrcLoc.RealSrcLoc
instance GHC.Show.Show GHC.Types.SrcLoc.RealSrcLoc

module GHC.Tc.Types.Rank
data Rank
ArbitraryRank :: Rank
LimitedRank :: Bool -> Rank -> Rank
MonoTypeRankZero :: Rank
MonoTypeTyConArg :: Rank
MonoTypeSynArg :: Rank
MonoTypeConstraint :: Rank
MustBeMonoType :: Rank
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Rank.Rank

module GHC.Parser.Errors.Basic

-- | The operator symbol in the
--   <tt>PsOperatorWhitespaceExtConflictMessage</tt> diagnostic.
data OperatorWhitespaceSymbol
OperatorWhitespaceSymbol_PrefixPercent :: OperatorWhitespaceSymbol
OperatorWhitespaceSymbol_PrefixDollar :: OperatorWhitespaceSymbol
OperatorWhitespaceSymbol_PrefixDollarDollar :: OperatorWhitespaceSymbol
pprOperatorWhitespaceSymbol :: OperatorWhitespaceSymbol -> SDoc

-- | The operator occurrence type in the
--   <tt>PsOperatorWhitespaceMessage</tt> diagnostic.
data OperatorWhitespaceOccurrence
OperatorWhitespaceOccurrence_Prefix :: OperatorWhitespaceOccurrence
OperatorWhitespaceOccurrence_Suffix :: OperatorWhitespaceOccurrence
OperatorWhitespaceOccurrence_TightInfix :: OperatorWhitespaceOccurrence

module GHC.Data.Pair
data Pair a
Pair :: a -> a -> Pair a
[pFst] :: Pair a -> a
[pSnd] :: Pair a -> a
unPair :: Pair a -> (a, a)
toPair :: (a, a) -> Pair a
swap :: Pair a -> Pair a
pLiftFst :: (a -> a) -> Pair a -> Pair a
pLiftSnd :: (a -> a) -> Pair a -> Pair a
instance Data.Traversable.Traversable GHC.Data.Pair.Pair
instance GHC.Base.Functor GHC.Data.Pair.Pair
instance Data.Foldable.Foldable GHC.Data.Pair.Pair
instance GHC.Base.Applicative GHC.Data.Pair.Pair
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Data.Pair.Pair a)
instance (GHC.Base.Semigroup a, GHC.Base.Monoid a) => GHC.Base.Monoid (GHC.Data.Pair.Pair a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Data.Pair.Pair a)


-- | Provide trees (of instructions), so that lists of instructions can be
--   appended in linear time.
module GHC.Data.OrdList
data OrdList a
pattern NilOL :: OrdList a
pattern ConsOL :: a -> OrdList a -> OrdList a
pattern SnocOL :: OrdList a -> a -> OrdList a
nilOL :: OrdList a
isNilOL :: OrdList a -> Bool
unitOL :: a -> OrdList a
appOL :: OrdList a -> OrdList a -> OrdList a
infixl 5 `appOL`
consOL :: a -> OrdList a -> OrdList a
infixr 5 `consOL`
snocOL :: OrdList a -> a -> OrdList a
infixl 5 `snocOL`
concatOL :: [OrdList a] -> OrdList a
lastOL :: OrdList a -> a
headOL :: OrdList a -> a
mapOL :: (a -> b) -> OrdList a -> OrdList b
mapOL' :: (a -> b) -> OrdList a -> OrdList b
fromOL :: OrdList a -> [a]
toOL :: [a] -> OrdList a
foldrOL :: (a -> b -> b) -> b -> OrdList a -> b

-- | Strict left fold.
foldlOL :: (b -> a -> b) -> b -> OrdList a -> b
reverseOL :: OrdList a -> OrdList a
fromOLReverse :: OrdList a -> [a]

-- | Compare not only the values but also the structure of two lists
strictlyEqOL :: Eq a => OrdList a -> OrdList a -> Bool

-- | Compare not only the values but also the structure of two lists
strictlyOrdOL :: Ord a => OrdList a -> OrdList a -> Ordering
instance GHC.Base.Functor GHC.Data.OrdList.OrdList
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Data.OrdList.OrdList a)
instance GHC.Base.Semigroup (GHC.Data.OrdList.OrdList a)
instance GHC.Base.Monoid (GHC.Data.OrdList.OrdList a)
instance Data.Foldable.Foldable GHC.Data.OrdList.OrdList
instance Data.Traversable.Traversable GHC.Data.OrdList.OrdList


-- | Set-like operations on lists
--   
--   Avoid using them as much as possible
module GHC.Data.List.SetOps

-- | Assumes that the arguments contain no duplicates
unionLists :: (HasDebugCallStack, Outputable a, Eq a) => [a] -> [a] -> [a]

-- | Combines the two lists while keeping their order, placing the first
--   argument first in the result.
--   
--   Uses a set internally to record duplicates. This makes it slightly
--   slower for very small lists but avoids quadratic behaviour for large
--   lists.
unionListsOrd :: (HasDebugCallStack, Outputable a, Ord a) => [a] -> [a] -> [a]

-- | Calculate the set difference of two lists. This is <i>O((m + n) log
--   n)</i>, where we subtract a list of <i>n</i> elements from a list of
--   <i>m</i> elements.
--   
--   Extremely short cases are handled specially: When <i>m</i> or <i>n</i>
--   is 0, this takes <i>O(1)</i> time. When <i>m</i> is 1, it takes
--   <i>O(n)</i> time.
minusList :: Ord a => [a] -> [a] -> [a]

-- | A finite mapping based on equality and association lists.
type Assoc a b = [(a, b)]
assoc :: Eq a => String -> Assoc a b -> a -> b

-- | Lookup key, fail gracefully using Nothing if not found.
assocMaybe :: Eq a => Assoc a b -> a -> Maybe b
assocUsing :: (a -> a -> Bool) -> String -> Assoc a b -> a -> b
assocDefault :: Eq a => b -> Assoc a b -> a -> b
assocDefaultUsing :: (a -> a -> Bool) -> b -> Assoc a b -> a -> b
hasNoDups :: Eq a => [a] -> Bool

-- | Remove the duplicates from a list using the provided comparison
--   function. Might change the order of elements.
--   
--   Returns the list without duplicates, and accumulates all the
--   duplicates in the second component of its result.
removeDups :: (a -> a -> Ordering) -> [a] -> ([a], [NonEmpty a])

-- | Remove the duplicates from a list using the provided comparison
--   function.
nubOrdBy :: (a -> a -> Ordering) -> [a] -> [a]
findDupsEq :: (a -> a -> Bool) -> [a] -> [NonEmpty a]
equivClasses :: (a -> a -> Ordering) -> [a] -> [NonEmpty a]
getNth :: Outputable a => [a] -> Int -> a
isIn :: Eq a => String -> a -> [a] -> Bool
isn'tIn :: Eq a => String -> a -> [a] -> Bool

module GHC.Data.Bag
data Bag a
emptyBag :: Bag a
unitBag :: a -> Bag a
unionBags :: Bag a -> Bag a -> Bag a
unionManyBags :: [Bag a] -> Bag a
mapBag :: (a -> b) -> Bag a -> Bag b
elemBag :: Eq a => a -> Bag a -> Bool
lengthBag :: Bag a -> Int
filterBag :: (a -> Bool) -> Bag a -> Bag a
partitionBag :: (a -> Bool) -> Bag a -> (Bag a, Bag a)
partitionBagWith :: (a -> Either b c) -> Bag a -> (Bag b, Bag c)
concatBag :: Bag (Bag a) -> Bag a
catBagMaybes :: Bag (Maybe a) -> Bag a
foldBag :: (r -> r -> r) -> (a -> r) -> r -> Bag a -> r
isEmptyBag :: Bag a -> Bool
isSingletonBag :: Bag a -> Bool
consBag :: a -> Bag a -> Bag a
infixr 3 `consBag`
snocBag :: Bag a -> a -> Bag a
infixl 3 `snocBag`
anyBag :: (a -> Bool) -> Bag a -> Bool
allBag :: (a -> Bool) -> Bag a -> Bool
listToBag :: [a] -> Bag a
nonEmptyToBag :: NonEmpty a -> Bag a
bagToList :: Bag a -> [a]
headMaybe :: Bag a -> Maybe a
mapAccumBagL :: (acc -> x -> (acc, y)) -> acc -> Bag x -> (acc, Bag y)
concatMapBag :: (a -> Bag b) -> Bag a -> Bag b
concatMapBagPair :: (a -> (Bag b, Bag c)) -> Bag a -> (Bag b, Bag c)
mapMaybeBag :: (a -> Maybe b) -> Bag a -> Bag b
unzipBag :: Bag (a, b) -> (Bag a, Bag b)
mapBagM :: Monad m => (a -> m b) -> Bag a -> m (Bag b)
mapBagM_ :: Monad m => (a -> m b) -> Bag a -> m ()
flatMapBagM :: Monad m => (a -> m (Bag b)) -> Bag a -> m (Bag b)
flatMapBagPairM :: Monad m => (a -> m (Bag b, Bag c)) -> Bag a -> m (Bag b, Bag c)
mapAndUnzipBagM :: Monad m => (a -> m (b, c)) -> Bag a -> m (Bag b, Bag c)
mapAccumBagLM :: Monad m => (acc -> x -> m (acc, y)) -> acc -> Bag x -> m (acc, Bag y)
anyBagM :: Monad m => (a -> m Bool) -> Bag a -> m Bool
filterBagM :: Monad m => (a -> m Bool) -> Bag a -> m (Bag a)
instance Data.Traversable.Traversable GHC.Data.Bag.Bag
instance GHC.Base.Functor GHC.Data.Bag.Bag
instance Data.Foldable.Foldable GHC.Data.Bag.Bag
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Data.Bag.Bag a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Data.Bag.Bag a)
instance Data.Data.Data a => Data.Data.Data (GHC.Data.Bag.Bag a)
instance GHC.IsList.IsList (GHC.Data.Bag.Bag a)
instance GHC.Base.Semigroup (GHC.Data.Bag.Bag a)
instance GHC.Base.Monoid (GHC.Data.Bag.Bag a)

module GHC.Types.Unique

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique
uNIQUE_BITS :: Int
hasKey :: Uniquable a => a -> Unique -> Bool
pprUniqueAlways :: IsLine doc => Unique -> doc

-- | Put the character in the highest bits of the Word64. This may truncate
--   the character to 8. This function is used in
--   <tt><tt>mkSplitUniqSupply</tt></tt> so that it can precompute and
--   share the tag part of the uniques it generates.
mkTag :: Char -> Word64
mkUniqueGrimily :: Word64 -> Unique
mkUniqueIntGrimily :: Int -> Unique
getKey :: Unique -> Word64
mkUnique :: Char -> Word64 -> Unique
unpkUnique :: Unique -> (Char, Word64)
mkUniqueInt :: Char -> Int -> Unique
eqUnique :: Unique -> Unique -> Bool
ltUnique :: Unique -> Unique -> Bool
incrUnique :: Unique -> Unique
stepUnique :: Unique -> Word64 -> Unique
newTagUnique :: Unique -> Char -> Unique
nonDetCmpUnique :: Unique -> Unique -> Ordering

-- | The interface file symbol-table encoding assumes that known-key
--   uniques fit in 30-bits; verify this.
--   
--   See Note [Symbol table representation of names] in
--   <a>GHC.Iface.Binary</a> for details.
isValidKnownKeyUnique :: Unique -> Bool
mkLocalUnique :: Word64 -> Unique
minLocalUnique :: Unique
maxLocalUnique :: Unique
instance GHC.Types.Unique.Uniquable GHC.Data.FastString.FastString
instance GHC.Types.Unique.Uniquable GHC.Types.Int
instance GHC.Types.Unique.Uniquable Language.Haskell.Syntax.Module.Name.ModuleName
instance GHC.Types.Unique.Uniquable GHC.Types.Unique.Unique
instance GHC.Classes.Eq GHC.Types.Unique.Unique
instance GHC.Utils.Outputable.Outputable GHC.Types.Unique.Unique
instance GHC.Show.Show GHC.Types.Unique.Unique

module GHC.Utils.Unique
sameUnique :: Uniquable a => a -> a -> Bool
anyOfUnique :: Uniquable a => a -> [Unique] -> Bool

module GHC.Types.Unique.Supply

-- | Unique Supply
--   
--   A value of type <a>UniqSupply</a> is unique, and it can supply
--   <i>one</i> distinct <a>Unique</a>. Also, from the supply, one can also
--   manufacture an arbitrary number of further <tt>UniqueSupply</tt>
--   values, which will be distinct from the first and from all others.
data UniqSupply

-- | Obtain the <a>Unique</a> from this particular <a>UniqSupply</a>
uniqFromSupply :: UniqSupply -> Unique

-- | Obtain an infinite list of <a>Unique</a> that can be generated by
--   constant splitting of the supply
uniqsFromSupply :: UniqSupply -> [Unique]

-- | Obtain the <a>Unique</a> from this particular <a>UniqSupply</a>, and a
--   new supply
takeUniqFromSupply :: UniqSupply -> (Unique, UniqSupply)
uniqFromTag :: Char -> IO Unique

-- | Create a unique supply out of thin air. The "tag" (Char) supplied is
--   purely cosmetic, making it easier to figure out where a Unique was
--   born. See Note [Uniques and tags].
--   
--   The payload part of the Uniques allocated from this UniqSupply are
--   guaranteed distinct wrt all other supplies, regardless of their "tag".
--   This is achieved by allocating the payload part from a single source
--   of Uniques, namely <a>genSym</a>, shared across all UniqSupply's.
mkSplitUniqSupply :: Char -> IO UniqSupply

-- | Build two <a>UniqSupply</a> from a single one, each of which can
--   supply its own <a>Unique</a>.
splitUniqSupply :: UniqSupply -> (UniqSupply, UniqSupply)

-- | Create an infinite list of <a>UniqSupply</a> from a single one
listSplitUniqSupply :: UniqSupply -> [UniqSupply]

-- | A monad which just gives the ability to obtain <a>Unique</a>s
data UniqSM result

-- | A monad for generating unique identifiers
class Monad m => MonadUnique m

-- | Get a new UniqueSupply
getUniqueSupplyM :: MonadUnique m => m UniqSupply

-- | Get a new unique identifier
getUniqueM :: MonadUnique m => m Unique

-- | Get an infinite list of new unique identifiers
getUniquesM :: MonadUnique m => m [Unique]

-- | Run the <a>UniqSM</a> action, returning the final <a>UniqSupply</a>
initUs :: UniqSupply -> UniqSM a -> (a, UniqSupply)

-- | Run the <a>UniqSM</a> action, discarding the final <a>UniqSupply</a>
initUs_ :: UniqSupply -> UniqSM a -> a
initUniqSupply :: Word64 -> Int -> IO ()
instance GHC.Types.Unique.Supply.MonadUnique GHC.Types.Unique.Supply.UniqSM
instance GHC.Base.Functor GHC.Types.Unique.Supply.UniqSM
instance GHC.Base.Monad GHC.Types.Unique.Supply.UniqSM
instance GHC.Base.Applicative GHC.Types.Unique.Supply.UniqSM
instance Control.Monad.Fail.MonadFail GHC.Types.Unique.Supply.UniqSM
instance Control.Monad.Fix.MonadFix GHC.Types.Unique.Supply.UniqSM

module GHC.Types.Unique.FM

-- | A finite map from <tt>uniques</tt> of one type to elements in another
--   type.
--   
--   The key is just here to keep us honest. It's always safe to use a
--   single type as key. If two types don't overlap in their uniques it's
--   also safe to index the same map at multiple key types. But this is
--   very much discouraged.
data UniqFM key ele

-- | A wrapper around <a>UniqFM</a> with the sole purpose of informing call
--   sites that the provided <a>Foldable</a> and <a>Traversable</a>
--   instances are nondeterministic. If you use this please provide a
--   justification why it doesn't introduce nondeterminism. See Note
--   [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> to learn about
--   determinism.
newtype NonDetUniqFM key ele
NonDetUniqFM :: UniqFM key ele -> NonDetUniqFM key ele
[getNonDet] :: NonDetUniqFM key ele -> UniqFM key ele
emptyUFM :: UniqFM key elt
unitUFM :: Uniquable key => key -> elt -> UniqFM key elt
unitDirectlyUFM :: Unique -> elt -> UniqFM key elt
zipToUFM :: Uniquable key => [key] -> [elt] -> UniqFM key elt
listToUFM :: Uniquable key => [(key, elt)] -> UniqFM key elt
listToUFM_Directly :: [(Unique, elt)] -> UniqFM key elt
listToUFM_C :: Uniquable key => (elt -> elt -> elt) -> [(key, elt)] -> UniqFM key elt
listToIdentityUFM :: Uniquable key => [key] -> UniqFM key key
addToUFM :: Uniquable key => UniqFM key elt -> key -> elt -> UniqFM key elt
addToUFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqFM key elt -> key -> elt -> UniqFM key elt
addToUFM_Acc :: Uniquable key => (elt -> elts -> elts) -> (elt -> elts) -> UniqFM key elts -> key -> elt -> UniqFM key elts

-- | Add an element, returns previous lookup result and new map. If old
--   element doesn't exist, add the passed element directly, otherwise
--   compute the element to add using the passed function.
addToUFM_L :: Uniquable key => (key -> elt -> elt -> elt) -> key -> elt -> UniqFM key elt -> (Maybe elt, UniqFM key elt)
addListToUFM :: Uniquable key => UniqFM key elt -> [(key, elt)] -> UniqFM key elt

-- | Add elements to the map, combining existing values with inserted ones
--   using the given function.
addListToUFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqFM key elt -> [(key, elt)] -> UniqFM key elt
addToUFM_Directly :: UniqFM key elt -> Unique -> elt -> UniqFM key elt
addListToUFM_Directly :: UniqFM key elt -> [(Unique, elt)] -> UniqFM key elt
adjustUFM :: Uniquable key => (elt -> elt) -> UniqFM key elt -> key -> UniqFM key elt
alterUFM :: Uniquable key => (Maybe elt -> Maybe elt) -> UniqFM key elt -> key -> UniqFM key elt
adjustUFM_Directly :: (elt -> elt) -> UniqFM key elt -> Unique -> UniqFM key elt
delFromUFM :: Uniquable key => UniqFM key elt -> key -> UniqFM key elt
delFromUFM_Directly :: UniqFM key elt -> Unique -> UniqFM key elt
delListFromUFM :: Uniquable key => UniqFM key elt -> [key] -> UniqFM key elt
delListFromUFM_Directly :: UniqFM key elt -> [Unique] -> UniqFM key elt
plusUFM :: UniqFM key elt -> UniqFM key elt -> UniqFM key elt
plusUFM_C :: (elt -> elt -> elt) -> UniqFM key elt -> UniqFM key elt -> UniqFM key elt

-- | `plusUFM_CD f m1 d1 m2 d2` merges the maps using <tt>f</tt> as the
--   combinding function and <tt>d1</tt> resp. <tt>d2</tt> as the default
--   value if there is no entry in <tt>m1</tt> reps. <tt>m2</tt>. The
--   domain is the union of the domains of <tt>m1</tt> and <tt>m2</tt>.
--   
--   IMPORTANT NOTE: This function strictly applies the modification
--   function and forces the result unlike most the other functions in this
--   module.
--   
--   Representative example:
--   
--   <pre>
--   plusUFM_CD f {A: 1, B: 2} 23 {B: 3, C: 4} 42
--      == {A: f 1 42, B: f 2 3, C: f 23 4 }
--   </pre>
plusUFM_CD :: (elta -> eltb -> eltc) -> UniqFM key elta -> elta -> UniqFM key eltb -> eltb -> UniqFM key eltc

-- | `plusUFM_CD2 f m1 m2` merges the maps using <tt>f</tt> as the
--   combining function. Unlike <a>plusUFM_CD</a>, a missing value is not
--   defaulted: it is instead passed as <a>Nothing</a> to <tt>f</tt>.
--   <tt>f</tt> can never have both its arguments be <a>Nothing</a>.
--   
--   IMPORTANT NOTE: This function strictly applies the modification
--   function and forces the result.
--   
--   `plusUFM_CD2 f m1 m2` is the same as `plusUFM_CD f (mapUFM Just m1)
--   Nothing (mapUFM Just m2) Nothing`.
plusUFM_CD2 :: (Maybe elta -> Maybe eltb -> eltc) -> UniqFM key elta -> UniqFM key eltb -> UniqFM key eltc
mergeUFM :: (elta -> eltb -> Maybe eltc) -> (UniqFM key elta -> UniqFM key eltc) -> (UniqFM key eltb -> UniqFM key eltc) -> UniqFM key elta -> UniqFM key eltb -> UniqFM key eltc
plusMaybeUFM_C :: (elt -> elt -> Maybe elt) -> UniqFM key elt -> UniqFM key elt -> UniqFM key elt
plusUFMList :: [UniqFM key elt] -> UniqFM key elt
sequenceUFMList :: forall key elt. [UniqFM key elt] -> UniqFM key [elt]
minusUFM :: UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt1

-- | <tt>minusUFC_C f map1 map2</tt> returns <tt>map1</tt>, except that
--   every mapping <tt>key |-&gt; value1</tt> in <tt>map1</tt> that shares
--   a key with a mapping <tt>key |-&gt; value2</tt> in <tt>map2</tt> is
--   altered by <tt>f</tt>: <tt>value1</tt> is replaced by <tt>f value1
--   value2</tt>, where <a>Just</a> means that the new value is used and
--   <a>Nothing</a> means that the mapping is deleted.
minusUFM_C :: (elt1 -> elt2 -> Maybe elt1) -> UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt1
intersectUFM :: UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt1
intersectUFM_C :: (elt1 -> elt2 -> elt3) -> UniqFM key elt1 -> UniqFM key elt2 -> UniqFM key elt3
disjointUFM :: UniqFM key elt1 -> UniqFM key elt2 -> Bool
equalKeysUFM :: UniqFM key a -> UniqFM key b -> Bool
nonDetStrictFoldUFM :: (elt -> a -> a) -> a -> UniqFM key elt -> a
foldUFM :: (elt -> a -> a) -> a -> UniqFM key elt -> a

-- | In essence foldM See Note [Deterministic UniqFM] to learn about
--   nondeterminism. If you use this please provide a justification why it
--   doesn't introduce nondeterminism.
nonDetStrictFoldUFM_DirectlyM :: Monad m => (Unique -> b -> elt -> m b) -> b -> UniqFM key elt -> m b
nonDetStrictFoldUFM_Directly :: (Unique -> elt -> a -> a) -> a -> UniqFM key elt -> a
anyUFM :: (elt -> Bool) -> UniqFM key elt -> Bool
allUFM :: (elt -> Bool) -> UniqFM key elt -> Bool
seqEltsUFM :: (elt -> ()) -> UniqFM key elt -> ()
mapUFM :: (elt1 -> elt2) -> UniqFM key elt1 -> UniqFM key elt2
mapUFM_Directly :: (Unique -> elt1 -> elt2) -> UniqFM key elt1 -> UniqFM key elt2
mapMaybeUFM :: (elt1 -> Maybe elt2) -> UniqFM key elt1 -> UniqFM key elt2
elemUFM :: Uniquable key => key -> UniqFM key elt -> Bool
elemUFM_Directly :: Unique -> UniqFM key elt -> Bool
filterUFM :: (elt -> Bool) -> UniqFM key elt -> UniqFM key elt
filterUFM_Directly :: (Unique -> elt -> Bool) -> UniqFM key elt -> UniqFM key elt
partitionUFM :: (elt -> Bool) -> UniqFM key elt -> (UniqFM key elt, UniqFM key elt)
sizeUFM :: UniqFM key elt -> Int
isNullUFM :: UniqFM key elt -> Bool
lookupUFM :: Uniquable key => UniqFM key elt -> key -> Maybe elt
lookupUFM_Directly :: UniqFM key elt -> Unique -> Maybe elt
lookupWithDefaultUFM :: Uniquable key => UniqFM key elt -> elt -> key -> elt
lookupWithDefaultUFM_Directly :: UniqFM key elt -> elt -> Unique -> elt
nonDetEltsUFM :: UniqFM key elt -> [elt]
nonDetKeysUFM :: UniqFM key elt -> [Unique]
ufmToSet_Directly :: UniqFM key elt -> Word64Set
nonDetUFMToList :: UniqFM key elt -> [(Unique, elt)]
ufmToIntMap :: UniqFM key elt -> Word64Map elt
unsafeIntMapToUFM :: Word64Map elt -> UniqFM key elt

-- | Cast the key domain of a UniqFM.
--   
--   As long as the domains don't overlap in their uniques this is safe.
unsafeCastUFMKey :: UniqFM key1 elt -> UniqFM key2 elt
pprUniqFM :: (a -> SDoc) -> UniqFM key a -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetEltsUFM.
pprUFM :: UniqFM key a -> ([a] -> SDoc) -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetUFMToList.
pprUFMWithKeys :: UniqFM key a -> ([(Unique, a)] -> SDoc) -> SDoc

-- | Determines the pluralisation suffix appropriate for the length of a
--   set in the same way that plural from Outputable does for lists.
pluralUFM :: UniqFM key a -> SDoc
instance GHC.Base.Functor (GHC.Types.Unique.FM.UniqFM key)
instance GHC.Classes.Eq ele => GHC.Classes.Eq (GHC.Types.Unique.FM.UniqFM key ele)
instance (Data.Data.Data key, Data.Data.Data ele) => Data.Data.Data (GHC.Types.Unique.FM.UniqFM key ele)
instance GHC.Base.Functor (GHC.Types.Unique.FM.NonDetUniqFM key)
instance Data.Foldable.Foldable (GHC.Types.Unique.FM.NonDetUniqFM key)
instance Data.Traversable.Traversable (GHC.Types.Unique.FM.NonDetUniqFM key)
instance GHC.Base.Semigroup (GHC.Types.Unique.FM.UniqFM key a)
instance GHC.Base.Monoid (GHC.Types.Unique.FM.UniqFM key a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.FM.UniqFM key a)

module GHC.Types.Unique.MemoFun
memoiseUniqueFun :: Uniquable k => (k -> a) -> k -> a

module GHC.Types.Unique.Map

-- | Maps indexed by <a>Uniquable</a> keys
newtype UniqMap k a
UniqMap :: UniqFM k (k, a) -> UniqMap k a
[getUniqMap] :: UniqMap k a -> UniqFM k (k, a)
emptyUniqMap :: UniqMap k a
isNullUniqMap :: UniqMap k a -> Bool
unitUniqMap :: Uniquable k => k -> a -> UniqMap k a
listToUniqMap :: Uniquable k => [(k, a)] -> UniqMap k a
listToUniqMap_C :: Uniquable k => (a -> a -> a) -> [(k, a)] -> UniqMap k a
addToUniqMap :: Uniquable k => UniqMap k a -> k -> a -> UniqMap k a
addListToUniqMap :: Uniquable k => UniqMap k a -> [(k, a)] -> UniqMap k a
addToUniqMap_C :: Uniquable k => (a -> a -> a) -> UniqMap k a -> k -> a -> UniqMap k a
addToUniqMap_Acc :: Uniquable k => (b -> a -> a) -> (b -> a) -> UniqMap k a -> k -> b -> UniqMap k a

-- | Add an element, returns previous lookup result and new map. If old
--   element doesn't exist, add the passed element directly, otherwise
--   compute the element to add using the passed function.
addToUniqMap_L :: Uniquable k => (k -> a -> a -> a) -> k -> a -> UniqMap k a -> (Maybe a, UniqMap k a)
alterUniqMap :: Uniquable k => (Maybe a -> Maybe a) -> UniqMap k a -> k -> UniqMap k a
addListToUniqMap_C :: Uniquable k => (a -> a -> a) -> UniqMap k a -> [(k, a)] -> UniqMap k a
adjustUniqMap :: Uniquable k => (a -> a) -> UniqMap k a -> k -> UniqMap k a
delFromUniqMap :: Uniquable k => UniqMap k a -> k -> UniqMap k a
delListFromUniqMap :: Uniquable k => UniqMap k a -> [k] -> UniqMap k a
plusUniqMap :: UniqMap k a -> UniqMap k a -> UniqMap k a
plusUniqMap_C :: (a -> a -> a) -> UniqMap k a -> UniqMap k a -> UniqMap k a
plusMaybeUniqMap_C :: (a -> a -> Maybe a) -> UniqMap k a -> UniqMap k a -> UniqMap k a
plusUniqMapList :: [UniqMap k a] -> UniqMap k a
minusUniqMap :: UniqMap k a -> UniqMap k b -> UniqMap k a
intersectUniqMap :: UniqMap k a -> UniqMap k b -> UniqMap k a

-- | Intersection with a combining function.
intersectUniqMap_C :: (a -> b -> c) -> UniqMap k a -> UniqMap k b -> UniqMap k c
disjointUniqMap :: UniqMap k a -> UniqMap k b -> Bool
mapUniqMap :: (a -> b) -> UniqMap k a -> UniqMap k b
filterUniqMap :: (a -> Bool) -> UniqMap k a -> UniqMap k a
partitionUniqMap :: (a -> Bool) -> UniqMap k a -> (UniqMap k a, UniqMap k a)
sizeUniqMap :: UniqMap k a -> Int
elemUniqMap :: Uniquable k => k -> UniqMap k a -> Bool
lookupUniqMap :: Uniquable k => UniqMap k a -> k -> Maybe a
lookupWithDefaultUniqMap :: Uniquable k => UniqMap k a -> a -> k -> a
anyUniqMap :: (a -> Bool) -> UniqMap k a -> Bool
allUniqMap :: (a -> Bool) -> UniqMap k a -> Bool
nonDetEltsUniqMap :: UniqMap k a -> [(k, a)]
nonDetFoldUniqMap :: ((k, a) -> b -> b) -> b -> UniqMap k a -> b
instance GHC.Base.Functor (GHC.Types.Unique.Map.UniqMap k)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (GHC.Types.Unique.Map.UniqMap k a)
instance (Data.Data.Data k, Data.Data.Data a) => Data.Data.Data (GHC.Types.Unique.Map.UniqMap k a)
instance GHC.Base.Semigroup (GHC.Types.Unique.Map.UniqMap k a)
instance GHC.Base.Monoid (GHC.Types.Unique.Map.UniqMap k a)
instance (GHC.Utils.Outputable.Outputable k, GHC.Utils.Outputable.Outputable a) => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.Map.UniqMap k a)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (GHC.Types.Unique.Map.UniqMap k a)

module GHC.Types.Unique.DFM

-- | Type of unique deterministic finite maps
--   
--   The key is just here to keep us honest. It's always safe to use a
--   single type as key. If two types don't overlap in their uniques it's
--   also safe to index the same map at multiple key types. But this is
--   very much discouraged.
data UniqDFM key ele
emptyUDFM :: UniqDFM key elt
unitUDFM :: Uniquable key => key -> elt -> UniqDFM key elt
addToUDFM :: Uniquable key => UniqDFM key elt -> key -> elt -> UniqDFM key elt
addToUDFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqDFM key elt -> key -> elt -> UniqDFM key elt
addToUDFM_C_Directly :: (elt -> elt -> elt) -> UniqDFM key elt -> Unique -> elt -> UniqDFM key elt
addToUDFM_Directly :: UniqDFM key elt -> Unique -> elt -> UniqDFM key elt
addListToUDFM :: Uniquable key => UniqDFM key elt -> [(key, elt)] -> UniqDFM key elt
delFromUDFM :: Uniquable key => UniqDFM key elt -> key -> UniqDFM key elt

-- | Delete a list of elements from a UniqDFM
delListFromUDFM :: Uniquable key => UniqDFM key elt -> [key] -> UniqDFM key elt

-- | Apply a function to a particular element
adjustUDFM :: Uniquable key => (elt -> elt) -> UniqDFM key elt -> key -> UniqDFM key elt

-- | Apply a function to a particular element
adjustUDFM_Directly :: (elt -> elt) -> UniqDFM key elt -> Unique -> UniqDFM key elt

-- | The expression (alterUDFM f k map) alters value x at k, or absence
--   thereof. alterUDFM can be used to insert, delete, or update a value in
--   UniqDFM. Use addToUDFM, delFromUDFM or adjustUDFM when possible, they
--   are more efficient.
alterUDFM :: Uniquable key => (Maybe elt -> Maybe elt) -> UniqDFM key elt -> key -> UniqDFM key elt

-- | Map a function over every value in a UniqDFM
mapUDFM :: (elt1 -> elt2) -> UniqDFM key elt1 -> UniqDFM key elt2
mapMaybeUDFM :: forall elt1 elt2 key. (elt1 -> Maybe elt2) -> UniqDFM key elt1 -> UniqDFM key elt2
plusUDFM :: UniqDFM key elt -> UniqDFM key elt -> UniqDFM key elt
plusUDFM_C :: (elt -> elt -> elt) -> UniqDFM key elt -> UniqDFM key elt -> UniqDFM key elt
lookupUDFM :: Uniquable key => UniqDFM key elt -> key -> Maybe elt
lookupUDFM_Directly :: UniqDFM key elt -> Unique -> Maybe elt
elemUDFM :: Uniquable key => key -> UniqDFM key elt -> Bool

-- | Performs a deterministic fold over the UniqDFM. It's O(n log n) while
--   the corresponding function on <a>UniqFM</a> is O(n).
foldUDFM :: (elt -> a -> a) -> a -> UniqDFM key elt -> a
eltsUDFM :: UniqDFM key elt -> [elt]
filterUDFM :: (elt -> Bool) -> UniqDFM key elt -> UniqDFM key elt
filterUDFM_Directly :: (Unique -> elt -> Bool) -> UniqDFM key elt -> UniqDFM key elt
isNullUDFM :: UniqDFM key elt -> Bool
sizeUDFM :: UniqDFM key elt -> Int
intersectUDFM :: UniqDFM key elt -> UniqDFM key elt -> UniqDFM key elt
udfmIntersectUFM :: UniqDFM key elt1 -> UniqFM key elt2 -> UniqDFM key elt1
disjointUDFM :: UniqDFM key elt -> UniqDFM key elt -> Bool
disjointUdfmUfm :: UniqDFM key elt -> UniqFM key elt2 -> Bool
equalKeysUDFM :: UniqDFM key a -> UniqDFM key b -> Bool
minusUDFM :: UniqDFM key elt1 -> UniqDFM key elt2 -> UniqDFM key elt1
listToUDFM :: Uniquable key => [(key, elt)] -> UniqDFM key elt
listToUDFM_Directly :: [(Unique, elt)] -> UniqDFM key elt
udfmMinusUFM :: UniqDFM key elt1 -> UniqFM key elt2 -> UniqDFM key elt1
ufmMinusUDFM :: UniqFM key elt1 -> UniqDFM key elt2 -> UniqFM key elt1

-- | Partition UniqDFM into two UniqDFMs according to the predicate
partitionUDFM :: (elt -> Bool) -> UniqDFM key elt -> (UniqDFM key elt, UniqDFM key elt)
udfmRestrictKeys :: UniqDFM key elt -> UniqDFM key elt2 -> UniqDFM key elt
udfmRestrictKeysSet :: UniqDFM key elt -> Word64Set -> UniqDFM key elt
anyUDFM :: (elt -> Bool) -> UniqDFM key elt -> Bool
allUDFM :: (elt -> Bool) -> UniqDFM key elt -> Bool
pprUniqDFM :: (a -> SDoc) -> UniqDFM key a -> SDoc
pprUDFM :: UniqDFM key a -> ([a] -> SDoc) -> SDoc

-- | Converts <a>UniqDFM</a> to a list, with elements in deterministic
--   order. It's O(n log n) while the corresponding function on
--   <a>UniqFM</a> is O(n).
udfmToList :: UniqDFM key elt -> [(Unique, elt)]

-- | This allows for lossy conversion from UniqDFM to UniqFM
udfmToUfm :: UniqDFM key elt -> UniqFM key elt

-- | Performs a nondeterministic strict fold over the UniqDFM. It's O(n),
--   same as the corresponding function on <a>UniqFM</a>. If you use this
--   please provide a justification why it doesn't introduce
--   nondeterminism.
nonDetStrictFoldUDFM :: (elt -> a -> a) -> a -> UniqDFM key elt -> a

-- | Cast the key domain of a UniqFM.
--   
--   As long as the domains don't overlap in their uniques this is safe.
unsafeCastUDFMKey :: UniqDFM key1 elt -> UniqDFM key2 elt
alwaysUnsafeUfmToUdfm :: UniqFM key elt -> UniqDFM key elt
instance Data.Traversable.Traversable GHC.Types.Unique.DFM.TaggedVal
instance Data.Foldable.Foldable GHC.Types.Unique.DFM.TaggedVal
instance GHC.Base.Functor GHC.Types.Unique.DFM.TaggedVal
instance Data.Data.Data val => Data.Data.Data (GHC.Types.Unique.DFM.TaggedVal val)
instance GHC.Base.Functor (GHC.Types.Unique.DFM.UniqDFM key)
instance (Data.Data.Data key, Data.Data.Data ele) => Data.Data.Data (GHC.Types.Unique.DFM.UniqDFM key ele)
instance Data.Foldable.Foldable (GHC.Types.Unique.DFM.UniqDFM key)
instance Data.Traversable.Traversable (GHC.Types.Unique.DFM.UniqDFM key)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.DFM.UniqDFM key a)
instance GHC.Classes.Eq val => GHC.Classes.Eq (GHC.Types.Unique.DFM.TaggedVal val)

module GHC.Types.Unique.Set
data UniqSet a
getUniqSet :: UniqSet a -> UniqFM a a
pprUniqSet :: (a -> SDoc) -> UniqSet a -> SDoc
emptyUniqSet :: UniqSet a
unitUniqSet :: Uniquable a => a -> UniqSet a
mkUniqSet :: Uniquable a => [a] -> UniqSet a
addOneToUniqSet :: Uniquable a => UniqSet a -> a -> UniqSet a
addListToUniqSet :: Uniquable a => UniqSet a -> [a] -> UniqSet a
delOneFromUniqSet :: Uniquable a => UniqSet a -> a -> UniqSet a
delOneFromUniqSet_Directly :: UniqSet a -> Unique -> UniqSet a
delListFromUniqSet :: Uniquable a => UniqSet a -> [a] -> UniqSet a
delListFromUniqSet_Directly :: UniqSet a -> [Unique] -> UniqSet a
unionUniqSets :: UniqSet a -> UniqSet a -> UniqSet a
unionManyUniqSets :: [UniqSet a] -> UniqSet a
minusUniqSet :: UniqSet a -> UniqSet a -> UniqSet a
uniqSetMinusUFM :: UniqSet key -> UniqFM key b -> UniqSet key
uniqSetMinusUDFM :: UniqSet key -> UniqDFM key b -> UniqSet key
intersectUniqSets :: UniqSet a -> UniqSet a -> UniqSet a
disjointUniqSets :: UniqSet a -> UniqSet a -> Bool
restrictUniqSetToUFM :: UniqSet key -> UniqFM key b -> UniqSet key
uniqSetAny :: (a -> Bool) -> UniqSet a -> Bool
uniqSetAll :: (a -> Bool) -> UniqSet a -> Bool
elementOfUniqSet :: Uniquable a => a -> UniqSet a -> Bool
elemUniqSet_Directly :: Unique -> UniqSet a -> Bool
filterUniqSet :: (a -> Bool) -> UniqSet a -> UniqSet a
filterUniqSet_Directly :: (Unique -> elt -> Bool) -> UniqSet elt -> UniqSet elt
sizeUniqSet :: UniqSet a -> Int
isEmptyUniqSet :: UniqSet a -> Bool

-- | What's the point you might ask? We might have changed an object
--   without it's key changing. In which case this lookup makes sense.
lookupUniqSet :: Uniquable key => UniqSet key -> key -> Maybe key
lookupUniqSet_Directly :: UniqSet a -> Unique -> Maybe a
partitionUniqSet :: (a -> Bool) -> UniqSet a -> (UniqSet a, UniqSet a)
mapUniqSet :: Uniquable b => (a -> b) -> UniqSet a -> UniqSet b

-- | <a>unsafeUFMToUniqSet</a> converts a <tt><a>UniqFM</a> a</tt> into a
--   <tt><a>UniqSet</a> a</tt> assuming, without checking, that it maps
--   each <a>Unique</a> to a value that has that <a>Unique</a>. See Note
--   [UniqSet invariant].
unsafeUFMToUniqSet :: UniqFM a a -> UniqSet a
nonDetEltsUniqSet :: UniqSet elt -> [elt]
nonDetKeysUniqSet :: UniqSet elt -> [Unique]
nonDetStrictFoldUniqSet :: (elt -> a -> a) -> a -> UniqSet elt -> a
instance GHC.Base.Monoid (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Base.Semigroup (GHC.Types.Unique.Set.UniqSet a)
instance Data.Data.Data a => Data.Data.Data (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Classes.Eq (GHC.Types.Unique.Set.UniqSet a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.Set.UniqSet a)


-- | Types for the general graph colorer.
module GHC.Data.Graph.Base

-- | A fn to check if a node is trivially colorable For graphs who's color
--   classes are disjoint then a node is 'trivially colorable' when it has
--   less neighbors and exclusions than available colors for that node.
--   
--   For graph's who's color classes overlap, ie some colors alias other
--   colors, then this can be a bit more tricky. There is a general way to
--   calculate this, but it's likely be too slow for use in the code. The
--   coloring algorithm takes a canned function which can be optimised by
--   the user to be specific to the specific graph being colored.
--   
--   for details, see "A Generalised Algorithm for Graph-Coloring Register
--   Allocation" Smith, Ramsey, Holloway - PLDI 2004.
type Triv k cls color = cls -> UniqSet k -> UniqSet color -> Bool

-- | The Interference graph. There used to be more fields, but they were
--   turfed out in a previous revision. maybe we'll want more later..
newtype Graph k cls color
Graph :: UniqFM k (Node k cls color) -> Graph k cls color

-- | All active nodes in the graph.
[graphMap] :: Graph k cls color -> UniqFM k (Node k cls color)

-- | An empty graph.
initGraph :: Graph k cls color

-- | Modify the finite map holding the nodes in the graph.
graphMapModify :: (UniqFM k (Node k cls color) -> UniqFM k (Node k cls color)) -> Graph k cls color -> Graph k cls color

-- | Graph nodes. Represents a thing that can conflict with another thing.
--   For the register allocater the nodes represent registers.
data Node k cls color
Node :: k -> cls -> Maybe color -> UniqSet k -> UniqSet color -> [color] -> UniqSet k -> Node k cls color

-- | A unique identifier for this node.
[nodeId] :: Node k cls color -> k

-- | The class of this node, determines the set of colors that can be used.
[nodeClass] :: Node k cls color -> cls

-- | The color of this node, if any.
[nodeColor] :: Node k cls color -> Maybe color

-- | Neighbors which must be colored differently to this node.
[nodeConflicts] :: Node k cls color -> UniqSet k

-- | Colors that cannot be used by this node.
[nodeExclusions] :: Node k cls color -> UniqSet color

-- | Colors that this node would prefer to be, in descending order.
[nodePreference] :: Node k cls color -> [color]

-- | Neighbors that this node would like to be colored the same as.
[nodeCoalesce] :: Node k cls color -> UniqSet k

-- | An empty node.
newNode :: k -> cls -> Node k cls color


-- | Like a <a>UniqDFM</a>, but maintains equivalence classes of keys
--   sharing the same entry. See <a>UniqSDFM</a>.
module GHC.Types.Unique.SDFM

-- | A <a>UniqDFM</a> whose domain is <i>sets</i> of <a>Unique</a>s, each
--   of which share a common value of type <tt>ele</tt>. Every such set
--   ("equivalence class") has a distinct representative <a>Unique</a>.
--   Supports merging the entries of multiple such sets in a union-find
--   like fashion.
--   
--   An accurate model is that of <tt>[(Set key, Maybe ele)]</tt>: A finite
--   mapping from sets of <tt>key</tt>s to possibly absent entries
--   <tt>ele</tt>, where the sets don't overlap. Example: <tt> m =
--   [({u1,u3}, Just ele1), ({u2}, Just ele2), ({u4,u7}, Nothing)] </tt> On
--   this model we support the following main operations:
--   
--   <ul>
--   <li><tt><a>lookupUSDFM</a> m u3 == Just ele1</tt>,
--   <tt><a>lookupUSDFM</a> m u4 == Nothing</tt>, <tt><a>lookupUSDFM</a> m
--   u5 == Nothing</tt>.</li>
--   <li><tt><a>equateUSDFM</a> m u1 u3</tt> is a no-op, but
--   <tt><a>equateUSDFM</a> m u1 u2</tt> merges <tt>{u1,u3}</tt> and
--   <tt>{u2}</tt> to point to <tt>Just ele2</tt> and returns the old entry
--   of <tt>{u1,u3}</tt>, <tt>Just ele1</tt>.</li>
--   <li><tt><a>addToUSDFM</a> m u3 ele4</tt> sets the entry of
--   <tt>{u1,u3}</tt> to <tt>Just ele4</tt>.</li>
--   </ul>
--   
--   As well as a few means for traversal/conversion to list.
data UniqSDFM key ele
emptyUSDFM :: UniqSDFM key ele

-- | <tt>lookupSUDFM env x</tt> looks up an entry for <tt>x</tt>, looking
--   through all <a>Indirect</a>s until it finds a shared <a>Entry</a>.
--   
--   Examples in terms of the model (see <a>UniqSDFM</a>): &gt;&gt;&gt;
--   lookupUSDFM [({u1,u3}, Just ele1), ({u2}, Just ele2)] u3 == Just ele1
--   &gt;&gt;&gt; lookupUSDFM [({u1,u3}, Just ele1), ({u2}, Just ele2)] u4
--   == Nothing &gt;&gt;&gt; lookupUSDFM [({u1,u3}, Just ele1), ({u2},
--   Nothing)] u2 == Nothing
lookupUSDFM :: Uniquable key => UniqSDFM key ele -> key -> Maybe ele

-- | <tt>equateUSDFM env x y</tt> makes <tt>x</tt> and <tt>y</tt> point to
--   the same entry, thereby merging <tt>x</tt>'s class with <tt>y</tt>'s.
--   If both <tt>x</tt> and <tt>y</tt> are in the domain of the map, then
--   <tt>y</tt>'s entry will be chosen as the new entry and <tt>x</tt>'s
--   old entry will be returned.
--   
--   Examples in terms of the model (see <a>UniqSDFM</a>): &gt;&gt;&gt;
--   equateUSDFM [] u1 u2 == (Nothing, [({u1,u2}, Nothing)]) &gt;&gt;&gt;
--   equateUSDFM [({u1,u3}, Just ele1)] u3 u4 == (Nothing, [({u1,u3,u4},
--   Just ele1)]) &gt;&gt;&gt; equateUSDFM [({u1,u3}, Just ele1)] u4 u3 ==
--   (Nothing, [({u1,u3,u4}, Just ele1)]) &gt;&gt;&gt; equateUSDFM
--   [({u1,u3}, Just ele1), ({u2}, Just ele2)] u3 u2 == (Just ele1,
--   [({u2,u1,u3}, Just ele2)])
equateUSDFM :: Uniquable key => UniqSDFM key ele -> key -> key -> (Maybe ele, UniqSDFM key ele)

-- | <tt>addToUSDFM env x a</tt> sets the entry <tt>x</tt> is associated
--   with to <tt>a</tt>, thereby modifying its whole equivalence class.
--   
--   Examples in terms of the model (see <a>UniqSDFM</a>): &gt;&gt;&gt;
--   addToUSDFM [] u1 ele1 == [({u1}, Just ele1)] &gt;&gt;&gt; addToUSDFM
--   [({u1,u3}, Just ele1)] u3 ele2 == [({u1,u3}, Just ele2)]
addToUSDFM :: Uniquable key => UniqSDFM key ele -> key -> ele -> UniqSDFM key ele
traverseUSDFM :: forall key a b f. Applicative f => (a -> f b) -> UniqSDFM key a -> f (UniqSDFM key b)
instance (GHC.Utils.Outputable.Outputable key, GHC.Utils.Outputable.Outputable ele) => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.SDFM.UniqSDFM key ele)
instance (GHC.Utils.Outputable.Outputable key, GHC.Utils.Outputable.Outputable ele) => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.SDFM.Shared key ele)


-- | Specialised deterministic sets, for things with <tt>Uniques</tt>
--   
--   Based on <a>UniqDFM</a>s (as you would expect). See Note
--   [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation
--   why we need it.
--   
--   Basically, the things need to be in class <a>Uniquable</a>.
module GHC.Types.Unique.DSet
data UniqDSet a
getUniqDSet :: UniqDSet a -> UniqDFM a a
pprUniqDSet :: (a -> SDoc) -> UniqDSet a -> SDoc
delOneFromUniqDSet :: Uniquable a => UniqDSet a -> a -> UniqDSet a
delListFromUniqDSet :: Uniquable a => UniqDSet a -> [a] -> UniqDSet a
emptyUniqDSet :: UniqDSet a
unitUniqDSet :: Uniquable a => a -> UniqDSet a
mkUniqDSet :: Uniquable a => [a] -> UniqDSet a
addOneToUniqDSet :: Uniquable a => UniqDSet a -> a -> UniqDSet a
addListToUniqDSet :: Uniquable a => UniqDSet a -> [a] -> UniqDSet a
unionUniqDSets :: UniqDSet a -> UniqDSet a -> UniqDSet a
unionManyUniqDSets :: [UniqDSet a] -> UniqDSet a
minusUniqDSet :: UniqDSet a -> UniqDSet a -> UniqDSet a
uniqDSetMinusUniqSet :: UniqDSet a -> UniqSet a -> UniqDSet a
intersectUniqDSets :: UniqDSet a -> UniqDSet a -> UniqDSet a
uniqDSetIntersectUniqSet :: UniqDSet a -> UniqSet a -> UniqDSet a
nonDetStrictFoldUniqDSet :: (a -> b -> b) -> b -> UniqDSet a -> b
elementOfUniqDSet :: Uniquable a => a -> UniqDSet a -> Bool
filterUniqDSet :: (a -> Bool) -> UniqDSet a -> UniqDSet a
sizeUniqDSet :: UniqDSet a -> Int
isEmptyUniqDSet :: UniqDSet a -> Bool
lookupUniqDSet :: Uniquable a => UniqDSet a -> a -> Maybe a
uniqDSetToList :: UniqDSet a -> [a]
partitionUniqDSet :: (a -> Bool) -> UniqDSet a -> (UniqDSet a, UniqDSet a)
mapUniqDSet :: Uniquable b => (a -> b) -> UniqDSet a -> UniqDSet b
instance Data.Data.Data a => Data.Data.Data (GHC.Types.Unique.DSet.UniqDSet a)
instance GHC.Classes.Eq (GHC.Types.Unique.DSet.UniqDSet a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Unique.DSet.UniqDSet a)


module GHC.Data.FastString.Env

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
emptyFsEnv :: FastStringEnv a
unitFsEnv :: FastString -> a -> FastStringEnv a
extendFsEnv_C :: (a -> a -> a) -> FastStringEnv a -> FastString -> a -> FastStringEnv a
extendFsEnv_Acc :: (a -> b -> b) -> (a -> b) -> FastStringEnv b -> FastString -> a -> FastStringEnv b
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
extendFsEnvList :: FastStringEnv a -> [(FastString, a)] -> FastStringEnv a
extendFsEnvList_C :: (a -> a -> a) -> FastStringEnv a -> [(FastString, a)] -> FastStringEnv a
filterFsEnv :: (elt -> Bool) -> FastStringEnv elt -> FastStringEnv elt
plusFsEnv :: FastStringEnv a -> FastStringEnv a -> FastStringEnv a
plusFsEnv_C :: (a -> a -> a) -> FastStringEnv a -> FastStringEnv a -> FastStringEnv a
alterFsEnv :: (Maybe a -> Maybe a) -> FastStringEnv a -> FastString -> FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
lookupFsEnv_NF :: FastStringEnv a -> FastString -> a
delFromFsEnv :: FastStringEnv a -> FastString -> FastStringEnv a
delListFromFsEnv :: FastStringEnv a -> [FastString] -> FastStringEnv a
elemFsEnv :: FastString -> FastStringEnv a -> Bool
mapFsEnv :: (elt1 -> elt2) -> FastStringEnv elt1 -> FastStringEnv elt2
type DFastStringEnv a = UniqDFM FastString a
mkDFsEnv :: [(FastString, a)] -> DFastStringEnv a
emptyDFsEnv :: DFastStringEnv a
dFsEnvElts :: DFastStringEnv a -> [a]
lookupDFsEnv :: DFastStringEnv a -> FastString -> Maybe a

module GHC.Utils.Binary
data Bin a

-- | Do not rely on instance sizes for general types, we use variable
--   length encoding for many of them.
class Binary a
put_ :: Binary a => BinHandle -> a -> IO ()
put :: Binary a => BinHandle -> a -> IO (Bin a)
get :: Binary a => BinHandle -> IO a
data BinHandle
type SymbolTable = Array Int Name
type Dictionary = Array Int FastString
data BinData
BinData :: Int -> BinArray -> BinData
dataHandle :: BinData -> IO BinHandle
handleData :: BinHandle -> IO BinData
unsafeUnpackBinBuffer :: ByteString -> IO BinHandle
openBinMem :: Int -> IO BinHandle
seekBin :: BinHandle -> Bin a -> IO ()
tellBin :: BinHandle -> IO (Bin a)
castBin :: Bin a -> Bin b

-- | Get access to the underlying buffer.
withBinBuffer :: BinHandle -> (ByteString -> IO a) -> IO a
foldGet :: Binary a => Word -> BinHandle -> b -> (Word -> a -> b -> IO b) -> IO b
writeBinMem :: BinHandle -> FilePath -> IO ()
readBinMem :: FilePath -> IO BinHandle
readBinMemN :: Int -> FilePath -> IO (Maybe BinHandle)
putAt :: Binary a => BinHandle -> Bin a -> a -> IO ()
getAt :: Binary a => BinHandle -> Bin a -> IO a

-- | "forwardPut put_A put_B" outputs A after B but allows A to be read
--   before B by using a forward reference
forwardPut :: BinHandle -> (b -> IO a) -> IO b -> IO (a, b)
forwardPut_ :: BinHandle -> (b -> IO a) -> IO b -> IO ()

-- | Read a value stored using a forward reference
forwardGet :: BinHandle -> IO a -> IO a
putByte :: BinHandle -> Word8 -> IO ()
getByte :: BinHandle -> IO Word8
putULEB128 :: forall a. (Integral a, FiniteBits a) => BinHandle -> a -> IO ()
getULEB128 :: forall a. (Integral a, FiniteBits a) => BinHandle -> IO a
putSLEB128 :: forall a. (Integral a, Bits a) => BinHandle -> a -> IO ()
getSLEB128 :: forall a. (Show a, Integral a, FiniteBits a) => BinHandle -> IO a

-- | Encode the argument in it's full length. This is different from many
--   default binary instances which make no guarantee about the actual
--   encoding and might do things use variable length encoding.
newtype FixedLengthEncoding a
FixedLengthEncoding :: a -> FixedLengthEncoding a
[unFixedLength] :: FixedLengthEncoding a -> a
lazyGet :: Binary a => BinHandle -> IO a
lazyPut :: Binary a => BinHandle -> a -> IO ()

-- | Deserialize a value serialized by <a>lazyPutMaybe</a>.
lazyGetMaybe :: Binary a => BinHandle -> IO (Maybe a)

-- | Serialize the constructor strictly but lazily serialize a value inside
--   a <a>Just</a>.
--   
--   This way we can check for the presence of a value without
--   deserializing the value itself.
lazyPutMaybe :: Binary a => BinHandle -> Maybe a -> IO ()

-- | Information we keep around during interface file
--   serialization/deserialization. Namely we keep the functions for
--   serializing and deserializing <a>Name</a>s and <a>FastString</a>s. We
--   do this because we actually use serialization in two distinct
--   settings,
--   
--   <ul>
--   <li>When serializing interface files themselves</li>
--   <li>When computing the fingerprint of an IfaceDecl (which we computing
--   by hashing its Binary serialization)</li>
--   </ul>
--   
--   These two settings have different needs while serializing Names:
--   
--   <ul>
--   <li>Names in interface files are serialized via a symbol table (see
--   Note [Symbol table representation of names] in
--   <a>GHC.Iface.Binary</a>).</li>
--   <li>During fingerprinting a binding Name is serialized as the OccName
--   and a non-binding Name is serialized as the fingerprint of the thing
--   they represent. See Note [Fingerprinting IfaceDecls] for further
--   discussion.</li>
--   </ul>
data UserData
UserData :: (BinHandle -> IO Name) -> (BinHandle -> IO FastString) -> (BinHandle -> Name -> IO ()) -> (BinHandle -> Name -> IO ()) -> (BinHandle -> FastString -> IO ()) -> UserData
[ud_get_name] :: UserData -> BinHandle -> IO Name
[ud_get_fs] :: UserData -> BinHandle -> IO FastString

-- | serialize a non-binding <a>Name</a> (e.g. a reference to another
--   binding).
[ud_put_nonbinding_name] :: UserData -> BinHandle -> Name -> IO ()

-- | serialize a binding <a>Name</a> (e.g. the name of an IfaceDecl)
[ud_put_binding_name] :: UserData -> BinHandle -> Name -> IO ()
[ud_put_fs] :: UserData -> BinHandle -> FastString -> IO ()
getUserData :: BinHandle -> UserData
setUserData :: BinHandle -> UserData -> BinHandle
newReadState :: (BinHandle -> IO Name) -> (BinHandle -> IO FastString) -> UserData
newWriteState :: (BinHandle -> Name -> IO ()) -> (BinHandle -> Name -> IO ()) -> (BinHandle -> FastString -> IO ()) -> UserData
noUserData :: UserData
putDictionary :: BinHandle -> Int -> UniqFM FastString (Int, FastString) -> IO ()
getDictionary :: BinHandle -> IO Dictionary
putFS :: BinHandle -> FastString -> IO ()
data FSTable
initFSTable :: BinHandle -> IO (BinHandle, FSTable, IO Int)
getDictFastString :: Dictionary -> BinHandle -> IO FastString
putDictFastString :: FSTable -> BinHandle -> FastString -> IO ()
newtype BinSpan
BinSpan :: RealSrcSpan -> BinSpan
[unBinSpan] :: BinSpan -> RealSrcSpan
newtype BinSrcSpan
BinSrcSpan :: SrcSpan -> BinSrcSpan
[unBinSrcSpan] :: BinSrcSpan -> SrcSpan
newtype BinLocated a
BinLocated :: Located a -> BinLocated a
[unBinLocated] :: BinLocated a -> Located a
instance forall k (a :: k). GHC.Enum.Bounded (GHC.Utils.Binary.Bin a)
instance forall k (a :: k). GHC.Show.Show (GHC.Utils.Binary.Bin a)
instance forall k (a :: k). GHC.Classes.Ord (GHC.Utils.Binary.Bin a)
instance forall k (a :: k). GHC.Classes.Eq (GHC.Utils.Binary.Bin a)
instance GHC.Show.Show a => GHC.Show.Show (GHC.Utils.Binary.FixedLengthEncoding a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Utils.Binary.FixedLengthEncoding a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Utils.Binary.FixedLengthEncoding a)
instance GHC.Utils.Binary.Binary GHC.Data.FastString.NonDetFastString
instance GHC.Utils.Binary.Binary GHC.Data.FastString.LexicalFastString
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Utils.Binary.BinLocated a)
instance GHC.Utils.Binary.Binary GHC.Utils.Binary.BinSrcSpan
instance GHC.Utils.Binary.Binary GHC.Utils.Binary.BinSpan
instance GHC.Utils.Binary.Binary GHC.Utils.Binary.BinData
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Word.Word8)
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Word.Word16)
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Word.Word32)
instance GHC.Utils.Binary.Binary (GHC.Utils.Binary.FixedLengthEncoding GHC.Word.Word64)
instance GHC.Utils.Binary.Binary GHC.Word.Word8
instance GHC.Utils.Binary.Binary GHC.Word.Word16
instance GHC.Utils.Binary.Binary GHC.Word.Word32
instance GHC.Utils.Binary.Binary GHC.Word.Word64
instance GHC.Utils.Binary.Binary GHC.Int.Int8
instance GHC.Utils.Binary.Binary GHC.Int.Int16
instance GHC.Utils.Binary.Binary GHC.Int.Int32
instance GHC.Utils.Binary.Binary GHC.Int.Int64
instance GHC.Utils.Binary.Binary ()
instance GHC.Utils.Binary.Binary GHC.Types.Bool
instance GHC.Utils.Binary.Binary GHC.Types.Char
instance GHC.Utils.Binary.Binary GHC.Types.Int
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary [a]
instance (GHC.Utils.Binary.Binary a, GHC.Classes.Ord a) => GHC.Utils.Binary.Binary (Data.Set.Internal.Set a)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Base.NonEmpty a)
instance (GHC.Ix.Ix a, GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (GHC.Arr.Array a b)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (a, b)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c) => GHC.Utils.Binary.Binary (a, b, c)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d) => GHC.Utils.Binary.Binary (a, b, c, d)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d, GHC.Utils.Binary.Binary e) => GHC.Utils.Binary.Binary (a, b, c, d, e)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d, GHC.Utils.Binary.Binary e, GHC.Utils.Binary.Binary f) => GHC.Utils.Binary.Binary (a, b, c, d, e, f)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b, GHC.Utils.Binary.Binary c, GHC.Utils.Binary.Binary d, GHC.Utils.Binary.Binary e, GHC.Utils.Binary.Binary f, GHC.Utils.Binary.Binary g) => GHC.Utils.Binary.Binary (a, b, c, d, e, f, g)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Maybe.Maybe a)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Data.Strict.Maybe a)
instance (GHC.Utils.Binary.Binary a, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (Data.Either.Either a b)
instance GHC.Utils.Binary.Binary Data.Time.Clock.Internal.UTCTime.UTCTime
instance GHC.Utils.Binary.Binary Data.Time.Calendar.Days.Day
instance GHC.Utils.Binary.Binary Data.Time.Clock.Internal.DiffTime.DiffTime
instance GHC.Utils.Binary.Binary GHC.Num.Integer.Integer
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Real.Ratio a)
instance forall k (a :: k). GHC.Utils.Binary.Binary (GHC.Utils.Binary.Bin a)
instance GHC.Utils.Binary.Binary Data.ByteString.Internal.Type.ByteString
instance GHC.Utils.Binary.Binary GHC.Data.FastString.FastString
instance GHC.Utils.Binary.Binary GHC.Fingerprint.Type.Fingerprint
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Module.Name.ModuleName
instance GHC.Utils.Binary.Binary GHC.Types.SrcLoc.UnhelpfulSpanReason
instance GHC.Utils.Binary.Binary v => GHC.Utils.Binary.Binary (Data.IntMap.Internal.IntMap v)
instance Control.DeepSeq.NFData GHC.Utils.Binary.BinData


-- | Orphan Binary instances for Data.Typeable stuff
module GHC.Utils.Binary.Typeable
getSomeTypeRep :: BinHandle -> IO SomeTypeRep
instance GHC.Utils.Binary.Binary GHC.Types.TyCon
instance GHC.Utils.Binary.Binary Data.Typeable.Internal.SomeTypeRep
instance forall k (a :: k). Data.Typeable.Internal.Typeable a => GHC.Utils.Binary.Binary (Data.Typeable.Internal.TypeRep a)
instance GHC.Utils.Binary.Binary GHC.Types.VecCount
instance GHC.Utils.Binary.Binary GHC.Types.VecElem
instance GHC.Utils.Binary.Binary GHC.Types.RuntimeRep
instance GHC.Utils.Binary.Binary GHC.Types.KindRep
instance GHC.Utils.Binary.Binary GHC.Types.TypeLitSort
instance GHC.Utils.Binary.Binary GHC.Serialized.Serialized


-- | Unit &amp; Module types
--   
--   This module is used to resolve the loops between Unit and Module types
--   (Module references a Unit and vice-versa).
module GHC.Unit.Types

-- | A generic module is a pair of a unit identifier and a
--   <a>ModuleName</a>.
data GenModule unit
Module :: !unit -> !ModuleName -> GenModule unit

-- | Unit the module belongs to
[moduleUnit] :: GenModule unit -> !unit

-- | Module name (e.g. A.B.C)
[moduleName] :: GenModule unit -> !ModuleName

-- | A Module is a pair of a <a>Unit</a> and a <a>ModuleName</a>.
type Module = GenModule Unit

-- | A <a>InstalledModule</a> is a <a>GenModule</a> whose unit is
--   identified with an <a>UnitId</a>.
type InstalledModule = GenModule UnitId

-- | A <a>HomeUnitModule</a> is like an <a>InstalledModule</a> but we
--   expect to find it in one of the home units rather than the package
--   database.
type HomeUnitModule = GenModule UnitId

-- | An <a>InstantiatedModule</a> is a <a>GenModule</a> whose unit is
--   identified with an <a>GenInstantiatedUnit</a>.
type InstantiatedModule = GenModule InstantiatedUnit
mkModule :: u -> ModuleName -> GenModule u
moduleUnitId :: Module -> UnitId
pprModule :: IsLine doc => Module -> doc
pprInstantiatedModule :: InstantiatedModule -> SDoc

-- | Calculate the free holes of a <a>GenModule</a>. If this set is
--   non-empty, this module was defined in an indefinite library that had
--   required signatures.
--   
--   If a module has free holes, that means that substitutions can operate
--   on it; if it has no free holes, substituting over a module has no
--   effect.
moduleFreeHoles :: GenModule (GenUnit u) -> UniqDSet ModuleName

-- | Class for types that are used as unit identifiers (UnitKey, UnitId,
--   Unit)
--   
--   We need this class because we create new unit ids for virtual units
--   (see VirtUnit) and they have to to be made from units with different
--   kinds of identifiers.
class IsUnitId u

-- | A unit identifier identifies a (possibly partially) instantiated
--   library. It is primarily used as part of <a>GenModule</a>, which in
--   turn is used in <tt>Name</tt>, which is used to give names to entities
--   when typechecking.
--   
--   There are two possible forms for a <a>Unit</a>:
--   
--   1) It can be a <a>RealUnit</a>, in which case we just have a
--   <a>DefUnitId</a> that uniquely identifies some fully compiled,
--   installed library we have on disk.
--   
--   2) It can be an <a>VirtUnit</a>. When we are typechecking a library
--   with missing holes, we may need to instantiate a library on the fly
--   (in which case we don't have any on-disk representation.) In that
--   case, you have an <a>GenInstantiatedUnit</a>, which explicitly records
--   the instantiation, so that we can substitute over it.
data GenUnit uid

-- | Installed definite unit (either a fully instantiated unit or a closed
--   unit)
RealUnit :: !Definite uid -> GenUnit uid

-- | Virtual unit instantiated on-the-fly. It may be definite if all the
--   holes are instantiated but we don't have code objects for it.
VirtUnit :: {-# UNPACK #-} !GenInstantiatedUnit uid -> GenUnit uid

-- | Fake hole unit
HoleUnit :: GenUnit uid
type Unit = GenUnit UnitId

-- | A UnitId identifies a built library in a database and is used to
--   generate unique symbols, etc. It's usually of the form:
--   
--   pkgname-1.2:libname+hash
--   
--   These UnitId are provided to us via the <tt>-this-unit-id</tt> flag.
--   
--   The library in question may be definite or indefinite; if it is
--   indefinite, none of the holes have been filled (we never install
--   partially instantiated libraries as we can cheaply instantiate them
--   on-the-fly, cf VirtUnit). Put another way, an installed unit id is
--   either fully instantiated, or not instantiated at all.
newtype UnitId
UnitId :: FastString -> UnitId

-- | The full hashed unit identifier, including the component id and the
--   hash.
[unitIdFS] :: UnitId -> FastString

-- | A unit key in the database
newtype UnitKey
UnitKey :: FastString -> UnitKey

-- | An instantiated unit.
--   
--   It identifies an indefinite library (with holes) that has been
--   instantiated.
--   
--   This unit may be indefinite or not (i.e. with remaining holes or not).
--   If it is definite, we don't know if it has already been compiled and
--   installed in a database. Nevertheless, we have a mechanism called
--   "improvement" to try to match a fully instantiated unit with existing
--   compiled and installed units: see Note [VirtUnit to RealUnit
--   improvement].
--   
--   An indefinite unit identifier pretty-prints to something like
--   <tt>p[H=<a>H</a>,A=aimpl:A&gt;]</tt> (<tt>p</tt> is the <a>UnitId</a>,
--   and the brackets enclose the module substitution).
data GenInstantiatedUnit unit
InstantiatedUnit :: !FastString -> !Unique -> !unit -> !GenInstantiations unit -> UniqDSet ModuleName -> GenInstantiatedUnit unit

-- | A private, uniquely identifying representation of an InstantiatedUnit.
--   This string is completely private to GHC and is just used to get a
--   unique.
[instUnitFS] :: GenInstantiatedUnit unit -> !FastString

-- | Cached unique of <a>unitFS</a>.
[instUnitKey] :: GenInstantiatedUnit unit -> !Unique

-- | The (indefinite) unit being instantiated.
[instUnitInstanceOf] :: GenInstantiatedUnit unit -> !unit

-- | The sorted (by <a>ModuleName</a>) instantiations of this unit.
[instUnitInsts] :: GenInstantiatedUnit unit -> !GenInstantiations unit

-- | A cache of the free module holes of <a>instUnitInsts</a>. This lets us
--   efficiently tell if a <a>GenInstantiatedUnit</a> has been fully
--   instantiated (empty set of free module holes) and whether or not a
--   substitution can have any effect.
[instUnitHoles] :: GenInstantiatedUnit unit -> UniqDSet ModuleName
type InstantiatedUnit = GenInstantiatedUnit UnitId

-- | A <a>DefUnitId</a> is an <a>UnitId</a> with the invariant that it only
--   refers to a definite library; i.e., one we have generated code for.
type DefUnitId = Definite UnitId
type Instantiations = GenInstantiations UnitId
type GenInstantiations unit = [(ModuleName, GenModule (GenUnit unit))]

-- | Create a new <a>GenInstantiatedUnit</a> given an explicit module
--   substitution.
mkInstantiatedUnit :: IsUnitId u => u -> GenInstantiations u -> GenInstantiatedUnit u

-- | Generate a uniquely identifying hash (internal unit-id) for an
--   instantiated unit.
--   
--   This is a one-way function. If the indefinite unit has not been
--   instantiated at all, we return its unit-id.
--   
--   This hash is completely internal to GHC and is not used for symbol
--   names or file paths. It is different from the hash Cabal would produce
--   for the same instantiated unit.
mkInstantiatedUnitHash :: IsUnitId u => u -> [(ModuleName, GenModule (GenUnit u))] -> FastString

-- | Smart constructor for instantiated GenUnit
mkVirtUnit :: IsUnitId u => u -> [(ModuleName, GenModule (GenUnit u))] -> GenUnit u

-- | Map over the unit type of a <a>GenUnit</a>
mapGenUnit :: IsUnitId v => (u -> v) -> GenUnit u -> GenUnit v

-- | Map over the unit identifier of unit instantiations.
mapInstantiations :: IsUnitId v => (u -> v) -> GenInstantiations u -> GenInstantiations v

-- | Retrieve the set of free module holes of a <a>Unit</a>.
unitFreeModuleHoles :: GenUnit u -> UniqDSet ModuleName

-- | Create a new simple unit identifier from a <a>FastString</a>.
--   Internally, this is primarily used to specify wired-in unit
--   identifiers.
fsToUnit :: FastString -> Unit
unitFS :: IsUnitId u => u -> FastString
unitString :: IsUnitId u => u -> String

-- | Return the UnitId of the Unit. For on-the-fly instantiated units,
--   return the UnitId of the indefinite unit this unit is an instance of.
toUnitId :: Unit -> UnitId

-- | Return the virtual UnitId of an on-the-fly instantiated unit.
virtualUnitId :: InstantiatedUnit -> UnitId
stringToUnit :: String -> Unit

-- | Compares unit ids lexically, rather than by their <a>Unique</a>s
stableUnitCmp :: Unit -> Unit -> Ordering

-- | A <a>Unit</a> is definite if it has no free holes.
unitIsDefinite :: Unit -> Bool
isHoleUnit :: GenUnit u -> Bool
pprUnit :: IsLine doc => Unit -> doc
unitIdString :: UnitId -> String
stringToUnitId :: String -> UnitId

-- | A definite unit (i.e. without any free module hole)
newtype Definite unit
Definite :: unit -> Definite unit
[unDefinite] :: Definite unit -> unit
primUnitId :: UnitId
bignumUnitId :: UnitId
baseUnitId :: UnitId
rtsUnitId :: UnitId
thUnitId :: UnitId

-- | This is the package Id for the current program. It is the default
--   package Id if you don't specify a package name. We don't add this
--   prefix to symbol names, since there can be only one main package per
--   program.
mainUnitId :: UnitId
thisGhcUnitId :: UnitId
interactiveUnitId :: UnitId
primUnit :: Unit
bignumUnit :: Unit
baseUnit :: Unit
rtsUnit :: Unit
thUnit :: Unit
mainUnit :: Unit
thisGhcUnit :: Unit
interactiveUnit :: Unit
isInteractiveModule :: Module -> Bool
wiredInUnitIds :: [UnitId]
data () => IsBootInterface
NotBoot :: IsBootInterface
IsBoot :: IsBootInterface

-- | This data type just pairs a value <a>mod</a> with an IsBootInterface
--   flag. In practice, <a>mod</a> is usually a <tt>Module</tt> or
--   <tt>ModuleName</tt>'.
data GenWithIsBoot mod
GWIB :: mod -> IsBootInterface -> GenWithIsBoot mod
[gwib_mod] :: GenWithIsBoot mod -> mod
[gwib_isBoot] :: GenWithIsBoot mod -> IsBootInterface
type ModuleNameWithIsBoot = GenWithIsBoot ModuleName
type ModuleWithIsBoot = GenWithIsBoot Module
instance GHC.Base.Functor GHC.Unit.Types.GenModule
instance Data.Data.Data unit => Data.Data.Data (GHC.Unit.Types.GenModule unit)
instance GHC.Classes.Ord unit => GHC.Classes.Ord (GHC.Unit.Types.GenModule unit)
instance GHC.Classes.Eq unit => GHC.Classes.Eq (GHC.Unit.Types.GenModule unit)
instance Data.Data.Data GHC.Unit.Types.UnitId
instance GHC.Unit.Types.IsUnitId unit => GHC.Unit.Types.IsUnitId (GHC.Unit.Types.Definite unit)
instance GHC.Types.Unique.Uniquable unit => GHC.Types.Unique.Uniquable (GHC.Unit.Types.Definite unit)
instance GHC.Utils.Binary.Binary unit => GHC.Utils.Binary.Binary (GHC.Unit.Types.Definite unit)
instance GHC.Utils.Outputable.Outputable unit => GHC.Utils.Outputable.Outputable (GHC.Unit.Types.Definite unit)
instance GHC.Classes.Ord unit => GHC.Classes.Ord (GHC.Unit.Types.Definite unit)
instance GHC.Classes.Eq unit => GHC.Classes.Eq (GHC.Unit.Types.Definite unit)
instance GHC.Base.Functor GHC.Unit.Types.Definite
instance Data.Traversable.Traversable GHC.Unit.Types.GenWithIsBoot
instance Data.Foldable.Foldable GHC.Unit.Types.GenWithIsBoot
instance GHC.Base.Functor GHC.Unit.Types.GenWithIsBoot
instance GHC.Show.Show mod => GHC.Show.Show (GHC.Unit.Types.GenWithIsBoot mod)
instance GHC.Classes.Ord mod => GHC.Classes.Ord (GHC.Unit.Types.GenWithIsBoot mod)
instance GHC.Classes.Eq mod => GHC.Classes.Eq (GHC.Unit.Types.GenWithIsBoot mod)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Unit.Types.GenWithIsBoot a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Unit.Types.GenWithIsBoot a)
instance GHC.Types.Unique.Uniquable GHC.Unit.Types.Module
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.Module
instance GHC.Classes.Ord GHC.Unit.Types.Unit
instance Data.Data.Data GHC.Unit.Types.Unit
instance Control.DeepSeq.NFData GHC.Unit.Types.Unit
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.Unit
instance GHC.Show.Show GHC.Unit.Types.Unit
instance GHC.Utils.Binary.Binary GHC.Unit.Types.Unit
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.InstantiatedModule
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.InstantiatedUnit
instance GHC.Utils.Binary.Binary GHC.Unit.Types.InstantiatedUnit
instance GHC.Unit.Types.IsUnitId u => GHC.Unit.Types.IsUnitId (GHC.Unit.Types.GenUnit u)
instance GHC.Classes.Eq (GHC.Unit.Types.GenInstantiatedUnit unit)
instance GHC.Classes.Ord (GHC.Unit.Types.GenInstantiatedUnit unit)
instance GHC.Unit.Types.IsUnitId u => GHC.Classes.Eq (GHC.Unit.Types.GenUnit u)
instance GHC.Unit.Types.IsUnitId u => GHC.Types.Unique.Uniquable (GHC.Unit.Types.GenUnit u)
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.InstalledModule
instance GHC.Unit.Types.IsUnitId GHC.Unit.Types.UnitId
instance GHC.Utils.Binary.Binary GHC.Unit.Types.UnitId
instance GHC.Classes.Eq GHC.Unit.Types.UnitId
instance GHC.Classes.Ord GHC.Unit.Types.UnitId
instance GHC.Types.Unique.Uniquable GHC.Unit.Types.UnitId
instance GHC.Utils.Outputable.Outputable GHC.Unit.Types.UnitId
instance GHC.Unit.Types.IsUnitId GHC.Unit.Types.UnitKey
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Unit.Types.GenModule a)
instance Control.DeepSeq.NFData (GHC.Unit.Types.GenModule a)
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.ImpExp.IsBootInterface


-- | Parsers for unit/module identifiers
module GHC.Unit.Parser
parseUnit :: ReadP Unit
parseUnitId :: ReadP UnitId
parseHoleyModule :: ReadP Module
parseModSubst :: ReadP [(ModuleName, Module)]


-- | Module location
module GHC.Unit.Module.Location

-- | Module Location
--   
--   Where a module lives on the file system: the actual locations of the
--   .hs, .hi, .dyn_hi, .o, .dyn_o and .hie files, if we have them.
--   
--   For a module in another unit, the ml_hs_file and ml_obj_file
--   components of ModLocation are undefined.
--   
--   The locations specified by a ModLocation may or may not correspond to
--   actual files yet: for example, even if the object file doesn't exist,
--   the ModLocation still contains the path to where the object file will
--   reside if/when it is created.
--   
--   The paths of anything which can affect recompilation should be placed
--   inside ModLocation.
--   
--   When a ModLocation is created none of the filepaths will have -boot
--   suffixes. This is because in --make mode the ModLocation is put in the
--   finder cache which is indexed by ModuleName, when a ModLocation is
--   retrieved from the FinderCache the boot suffixes are appended. The
--   other case is in -c mode, there the ModLocation immediately gets given
--   the boot suffixes in mkOneShotModLocation.
data ModLocation
ModLocation :: Maybe FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> ModLocation

-- | The source file, if we have one. Package modules probably don't have
--   source files.
[ml_hs_file] :: ModLocation -> Maybe FilePath

-- | Where the .hi file is, whether or not it exists yet. Always of form
--   foo.hi, even if there is an hi-boot file (we add the -boot suffix
--   later)
[ml_hi_file] :: ModLocation -> FilePath

-- | Where the .dyn_hi file is, whether or not it exists yet.
[ml_dyn_hi_file] :: ModLocation -> FilePath

-- | Where the .o file is, whether or not it exists yet. (might not exist
--   either because the module hasn't been compiled yet, or because it is
--   part of a unit with a .a file)
[ml_obj_file] :: ModLocation -> FilePath

-- | Where the .dy file is, whether or not it exists yet.
[ml_dyn_obj_file] :: ModLocation -> FilePath

-- | Where the .hie file is, whether or not it exists yet.
[ml_hie_file] :: ModLocation -> FilePath

-- | Add the <tt>-boot</tt> suffix to .hs, .hi and .o files
addBootSuffix :: FilePath -> FilePath

-- | Add the <tt>-boot</tt> suffix if the <tt>Bool</tt> argument is
--   <tt>True</tt>
addBootSuffix_maybe :: IsBootInterface -> FilePath -> FilePath
addBootSuffixLocn_maybe :: IsBootInterface -> ModLocation -> ModLocation

-- | Add the <tt>-boot</tt> suffix to all file paths associated with the
--   module
addBootSuffixLocn :: ModLocation -> ModLocation

-- | Add the <tt>-boot</tt> suffix to all output file paths associated with
--   the module, not including the input file itself
addBootSuffixLocnOut :: ModLocation -> ModLocation

-- | Remove the <tt>-boot</tt> suffix to .hs, .hi and .o files
removeBootSuffix :: FilePath -> FilePath
instance GHC.Show.Show GHC.Unit.Module.Location.ModLocation
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Location.ModLocation


-- | Module environment
module GHC.Unit.Module.Env

-- | A map keyed off of <a>GenModule</a>s
data ModuleEnv elt
elemModuleEnv :: Module -> ModuleEnv a -> Bool
extendModuleEnv :: ModuleEnv a -> Module -> a -> ModuleEnv a
extendModuleEnvList :: ModuleEnv a -> [(Module, a)] -> ModuleEnv a
extendModuleEnvList_C :: (a -> a -> a) -> ModuleEnv a -> [(Module, a)] -> ModuleEnv a
plusModuleEnv_C :: (a -> a -> a) -> ModuleEnv a -> ModuleEnv a -> ModuleEnv a
delModuleEnvList :: ModuleEnv a -> [Module] -> ModuleEnv a
delModuleEnv :: ModuleEnv a -> Module -> ModuleEnv a
plusModuleEnv :: ModuleEnv a -> ModuleEnv a -> ModuleEnv a
lookupModuleEnv :: ModuleEnv a -> Module -> Maybe a
lookupWithDefaultModuleEnv :: ModuleEnv a -> a -> Module -> a
mapModuleEnv :: (a -> b) -> ModuleEnv a -> ModuleEnv b
mkModuleEnv :: [(Module, a)] -> ModuleEnv a
emptyModuleEnv :: ModuleEnv a
partitionModuleEnv :: (a -> Bool) -> ModuleEnv a -> (ModuleEnv a, ModuleEnv a)
moduleEnvKeys :: ModuleEnv a -> [Module]
moduleEnvElts :: ModuleEnv a -> [a]
moduleEnvToList :: ModuleEnv a -> [(Module, a)]
unitModuleEnv :: Module -> a -> ModuleEnv a
isEmptyModuleEnv :: ModuleEnv a -> Bool
extendModuleEnvWith :: (a -> a -> a) -> ModuleEnv a -> Module -> a -> ModuleEnv a
filterModuleEnv :: (Module -> a -> Bool) -> ModuleEnv a -> ModuleEnv a
mapMaybeModuleEnv :: (Module -> a -> Maybe b) -> ModuleEnv a -> ModuleEnv b

-- | A map keyed off of <a>ModuleName</a>s (actually, their <a>Unique</a>s)
type ModuleNameEnv elt = UniqFM ModuleName elt

-- | A map keyed off of <a>ModuleName</a>s (actually, their <a>Unique</a>s)
--   Has deterministic folds and can be deterministically converted to a
--   list
type DModuleNameEnv elt = UniqDFM ModuleName elt

-- | A set of <a>GenModule</a>s
type ModuleSet = Set NDModule
emptyModuleSet :: ModuleSet
mkModuleSet :: [Module] -> ModuleSet
moduleSetElts :: ModuleSet -> [Module]
extendModuleSet :: ModuleSet -> Module -> ModuleSet
extendModuleSetList :: ModuleSet -> [Module] -> ModuleSet
delModuleSet :: ModuleSet -> Module -> ModuleSet
elemModuleSet :: Module -> ModuleSet -> Bool
intersectModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
minusModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
unionModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
unitModuleSet :: Module -> ModuleSet
isEmptyModuleSet :: ModuleSet -> Bool
unionManyModuleSets :: [ModuleSet] -> ModuleSet

-- | A map keyed off of <a>InstalledModule</a>
data InstalledModuleEnv elt
emptyInstalledModuleEnv :: InstalledModuleEnv a
lookupInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> Maybe a
extendInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> a -> InstalledModuleEnv a
filterInstalledModuleEnv :: (InstalledModule -> a -> Bool) -> InstalledModuleEnv a -> InstalledModuleEnv a
delInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> InstalledModuleEnv a
mergeInstalledModuleEnv :: (elta -> eltb -> Maybe eltc) -> (InstalledModuleEnv elta -> InstalledModuleEnv eltc) -> (InstalledModuleEnv eltb -> InstalledModuleEnv eltc) -> InstalledModuleEnv elta -> InstalledModuleEnv eltb -> InstalledModuleEnv eltc
plusInstalledModuleEnv :: (elt -> elt -> elt) -> InstalledModuleEnv elt -> InstalledModuleEnv elt -> InstalledModuleEnv elt
installedModuleEnvElts :: InstalledModuleEnv a -> [(InstalledModule, a)]
instance GHC.Classes.Eq GHC.Unit.Module.Env.NDModule
instance GHC.Utils.Outputable.Outputable elt => GHC.Utils.Outputable.Outputable (GHC.Unit.Module.Env.InstalledModuleEnv elt)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Unit.Module.Env.ModuleEnv a)
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Env.NDModule
instance GHC.Classes.Ord GHC.Unit.Module.Env.NDModule

module GHC.Unit.Module

-- | Given a possibly on-the-fly instantiated module, split it into a
--   <a>GenModule</a> that we definitely can find on-disk, as well as an
--   instantiation if we need to instantiate it on the fly. If the
--   instantiation is <tt>Nothing</tt> no on-the-fly renaming is needed.
getModuleInstantiation :: Module -> (InstalledModule, Maybe InstantiatedModule)

-- | Return the unit-id this unit is an instance of and the module
--   instantiations (if any).
getUnitInstantiations :: Unit -> (UnitId, Maybe InstantiatedUnit)

-- | Remove instantiations of the given instantiated unit
uninstantiateInstantiatedUnit :: InstantiatedUnit -> InstantiatedUnit

-- | Remove instantiations of the given module instantiated unit
uninstantiateInstantiatedModule :: InstantiatedModule -> InstantiatedModule

-- | Create a hole Module
mkHoleModule :: ModuleName -> GenModule (GenUnit u)

-- | Test if a Module is not instantiated
isHoleModule :: GenModule (GenUnit u) -> Bool

-- | This gives a stable ordering, as opposed to the Ord instance which
--   gives an ordering based on the <tt>Unique</tt>s of the components,
--   which may not be stable from run to run of the compiler.
stableModuleCmp :: Module -> Module -> Ordering

-- | Get a string representation of a <a>GenModule</a> that's unique and
--   stable across recompilations. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal"
moduleStableString :: Module -> String

-- | A <a>GenModule</a> is definite if it has no free holes.
moduleIsDefinite :: Module -> Bool
class HasModule m
getModule :: HasModule m => m Module
class ContainsModule t
extractModule :: ContainsModule t => t -> Module

-- | Test if a <a>GenModule</a> corresponds to a given
--   <a>InstalledModule</a>, modulo instantiation.
installedModuleEq :: InstalledModule -> Module -> Bool


-- | A module for the BreakInfo type. Used by both the GHC.Runtime.Eval and
--   GHC.Runtime.Interpreter hierarchy, so put here to have a less deep
--   module dependency tree
module GHC.Types.BreakInfo
data BreakInfo
BreakInfo :: Module -> Int -> BreakInfo
[breakInfo_module] :: BreakInfo -> Module
[breakInfo_number] :: BreakInfo -> Int


-- | JS symbol generation
module GHC.StgToJS.Symbols

-- | the global linkable unit of a module exports this symbol, depend on it
--   to include that unit (used for cost centres)
moduleGlobalSymbol :: Module -> FastString
moduleExportsSymbol :: Module -> FastString

-- | Make JS symbol corresponding to the given Haskell symbol in the given
--   module
mkJsSymbol :: Bool -> Module -> FastString -> FastString

-- | Make JS symbol corresponding to the given Haskell symbol in the given
--   module
mkJsSymbolBS :: Bool -> Module -> FastString -> ByteString

-- | Make JS symbol for given module and unique.
mkFreshJsSymbol :: Module -> Int -> FastString

-- | Make symbol "h$XYZ" or "h$$XYZ"
mkRawSymbol :: Bool -> FastString -> FastString

-- | Hexadecimal representation of an int
--   
--   Used for the sub indices.
intBS :: Int -> ByteString

-- | Hexadecimal representation of a 64-bit word
--   
--   Used for uniques. We could use base-62 as GHC usually does but this is
--   likely faster.
word64BS :: Word64 -> ByteString


-- | The home unit is the unit (i.e. compiled package) that contains the
--   module we are compiling/typechecking.
module GHC.Unit.Home

-- | Information about the home unit (i.e., the until that will contain the
--   modules we are compiling)
--   
--   The unit identifier of the instantiating units is left open to allow
--   switching from UnitKey (what is provided by the user) to UnitId
--   (internal unit identifier) with <a>homeUnitMap</a>.
--   
--   TODO: this isn't implemented yet. UnitKeys are still converted too
--   early into UnitIds in GHC.Unit.State.readUnitDataBase
data GenHomeUnit u

-- | Definite home unit (i.e. that we can compile).
--   
--   Nothing: not an instantiated unit Just (i,insts): made definite by
--   instantiating "i" with "insts"
DefiniteHomeUnit :: UnitId -> Maybe (u, GenInstantiations u) -> GenHomeUnit u

-- | Indefinite home unit (i.e. that we can only typecheck)
--   
--   All the holes are instantiated with fake modules from the Hole unit.
--   See Note [Representation of module/name variables] in <a>GHC.Unit</a>
IndefiniteHomeUnit :: UnitId -> GenInstantiations u -> GenHomeUnit u
type HomeUnit = GenHomeUnit UnitId

-- | Return home unit id
homeUnitId :: GenHomeUnit u -> UnitId

-- | Return home unit instantiations
homeUnitInstantiations :: GenHomeUnit u -> GenInstantiations u

-- | Return the unit id of the unit that is instantiated by the home unit.
--   
--   E.g. if home unit = q[A=p:B,...] we return q.
--   
--   If the home unit is not an instance of another unit, we return its own
--   unit id (it is an instance of itself if you will).
homeUnitInstanceOf :: HomeUnit -> UnitId

-- | Return the unit id of the unit that is instantiated by the home unit.
--   
--   E.g. if home unit = q[A=p:B,...] we return (Just q).
--   
--   If the home unit is not an instance of another unit, we return
--   Nothing.
homeUnitInstanceOfMaybe :: GenHomeUnit u -> Maybe u

-- | Return the home unit as a normal unit.
--   
--   We infer from the home unit itself the kind of unit we create: 1. If
--   the home unit is definite, we must be compiling so we return a real
--   unit. The definite home unit may be the result of a unit
--   instantiation, say `p = q[A=r:X]`. In this case we could have returned
--   a virtual unit `q[A=r:X]` but it's not what the clients of this
--   function expect, especially because <tt>p</tt> is lost when we do
--   this. The unit id of a virtual unit is made up internally so
--   `unitId(q[A=r:X])` is not equal to <tt>p</tt>.
--   
--   <ol>
--   <li>If the home unit is indefinite we can only create a virtual unit
--   from it. It's ok because we must be only typechecking the home unit so
--   we won't produce any code object that rely on the unit id of this
--   virtual unit.</li>
--   </ol>
homeUnitAsUnit :: HomeUnit -> Unit

-- | Map over the unit identifier for instantiating units
homeUnitMap :: IsUnitId v => (u -> v) -> GenHomeUnit u -> GenHomeUnit v

-- | Test if we are type-checking an indefinite unit
--   
--   (if it is not, we should never use on-the-fly renaming)
isHomeUnitIndefinite :: GenHomeUnit u -> Bool

-- | Test if we are compiling a definite unit
--   
--   (if it is, we should never use on-the-fly renaming)
isHomeUnitDefinite :: GenHomeUnit u -> Bool

-- | Test if we are compiling by instantiating a definite unit
isHomeUnitInstantiating :: GenHomeUnit u -> Bool

-- | Test if the unit is the home unit
isHomeUnit :: HomeUnit -> Unit -> Bool

-- | Test if the unit-id is the home unit-id
isHomeUnitId :: GenHomeUnit u -> UnitId -> Bool

-- | Test if the home unit is an instance of the given unit-id
isHomeUnitInstanceOf :: HomeUnit -> UnitId -> Bool

-- | Test if the module comes from the home unit
isHomeModule :: HomeUnit -> Module -> Bool

-- | Test if the module comes from the home unit
isHomeInstalledModule :: GenHomeUnit u -> InstalledModule -> Bool

-- | Test if the unit-id is not the home unit-id
notHomeUnitId :: Maybe (GenHomeUnit u) -> UnitId -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeModule :: HomeUnit -> Module -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeModuleMaybe :: Maybe HomeUnit -> Module -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeInstalledModule :: GenHomeUnit u -> InstalledModule -> Bool

-- | Test if a module doesn't come from the given home unit
notHomeInstalledModuleMaybe :: Maybe (GenHomeUnit u) -> InstalledModule -> Bool

-- | Make a module in home unit
mkHomeModule :: HomeUnit -> ModuleName -> Module

-- | Make a module in home unit
mkHomeInstalledModule :: GenHomeUnit u -> ModuleName -> InstalledModule

-- | Return the module that is used to instantiate the given home module.
--   
--   If the given module isn't a module hole, return the actual home
--   module.
--   
--   E.g., the instantiating module of <tt>p:A</tt> in <tt>p[A=q[]:B]</tt>
--   is <tt>q[]:B</tt>. the instantiating module of <tt>r:A</tt> in
--   <tt>p[A=q[]:B]</tt> is <tt>r:A</tt>. the instantiating module of
--   <tt>p:A</tt> in <tt>p</tt> is <tt>p:A</tt>. the instantiating module
--   of <tt>r:A</tt> in <tt>p</tt> is <tt>r:A</tt>.
homeModuleInstantiation :: Maybe HomeUnit -> Module -> Module

-- | Return the module that is used to instantiate the given home module
--   name. If the ModuleName doesn't refer to a signature, return the
--   actual home module.
--   
--   E.g., the instantiating module of <tt>A</tt> in <tt>p[A=q[]:B]</tt> is
--   <tt>q[]:B</tt>. the instantiating module of <tt>A</tt> in <tt>p</tt>
--   is <tt>p:A</tt>.
homeModuleNameInstantiation :: HomeUnit -> ModuleName -> Module


-- | This data structure holds an updateable environment which is used when
--   compiling module loops.
module GHC.Driver.Env.KnotVars
data KnotVars a
KnotVars :: [Module] -> (Module -> Maybe a) -> KnotVars a
[kv_domain] :: KnotVars a -> [Module]
[kv_lookup] :: KnotVars a -> Module -> Maybe a
NoKnotVars :: KnotVars a
emptyKnotVars :: KnotVars a
knotVarsFromModuleEnv :: ModuleEnv a -> KnotVars a
knotVarElems :: KnotVars a -> [a]
lookupKnotVars :: KnotVars a -> Module -> Maybe a
knotVarsWithout :: Module -> KnotVars a -> KnotVars a
instance GHC.Base.Functor GHC.Driver.Env.KnotVars.KnotVars
instance GHC.Utils.Outputable.Outputable (GHC.Driver.Env.KnotVars.KnotVars a)


-- | Source text
--   
--   Keeping Source Text for source to source conversions
module GHC.Types.SourceText
data SourceText
SourceText :: String -> SourceText

-- | For when code is generated, e.g. TH, deriving. The pretty printer will
--   then make its own representation of the item.
NoSourceText :: SourceText

-- | Special combinator for showing string literals.
pprWithSourceText :: SourceText -> SDoc -> SDoc

-- | Integral Literal
--   
--   Used (instead of Integer) to represent negative zegative zero which is
--   required for NegativeLiterals extension to correctly parse
--   `-0::Double` as negative zero. See also #13211.
data IntegralLit
IL :: SourceText -> Bool -> Integer -> IntegralLit
[il_text] :: IntegralLit -> SourceText
[il_neg] :: IntegralLit -> Bool
[il_value] :: IntegralLit -> Integer

-- | Fractional Literal
--   
--   Used (instead of Rational) to represent exactly the floating point
--   literal that we encountered in the user's source program. This allows
--   us to pretty-print exactly what the user wrote, which is important
--   e.g. for floating point numbers that can't represented as Doubles (we
--   used to via Double for pretty-printing). See also #2245. Note
--   [FractionalLit representation] in GHC.HsToCore.Match.Literal The
--   actual value then is: sign * fl_signi * (fl_exp_base^fl_exp) where
--   sign = if fl_neg then (-1) else 1
--   
--   For example FL { fl_neg = True, fl_signi = 5.3, fl_exp = 4,
--   fl_exp_base = Base10 } denotes -5300
data FractionalLit
FL :: SourceText -> Bool -> Rational -> Integer -> FractionalExponentBase -> FractionalLit

-- | How the value was written in the source
[fl_text] :: FractionalLit -> SourceText
[fl_neg] :: FractionalLit -> Bool
[fl_signi] :: FractionalLit -> Rational
[fl_exp] :: FractionalLit -> Integer
[fl_exp_base] :: FractionalLit -> FractionalExponentBase

-- | A String Literal in the source, including its original raw format for
--   use by source to source manipulation tools.
data StringLiteral
StringLiteral :: SourceText -> FastString -> Maybe RealSrcSpan -> StringLiteral
[sl_st] :: StringLiteral -> SourceText
[sl_fs] :: StringLiteral -> FastString
[sl_tc] :: StringLiteral -> Maybe RealSrcSpan
negateIntegralLit :: IntegralLit -> IntegralLit
negateFractionalLit :: FractionalLit -> FractionalLit
mkIntegralLit :: Integral a => a -> IntegralLit
mkTHFractionalLit :: Rational -> FractionalLit
rationalFromFractionalLit :: FractionalLit -> Rational

-- | The integer should already be negated if it's negative.
integralFractionalLit :: Bool -> Integer -> FractionalLit

-- | The arguments should already be negated if they are negative.
mkSourceFractionalLit :: String -> Bool -> Integer -> Integer -> FractionalExponentBase -> FractionalLit
data FractionalExponentBase
Base2 :: FractionalExponentBase
Base10 :: FractionalExponentBase
fractionalLitFromRational :: Rational -> FractionalLit
mkFractionalLit :: SourceText -> Bool -> Rational -> Integer -> FractionalExponentBase -> FractionalLit
instance GHC.Classes.Eq GHC.Types.SourceText.SourceText
instance GHC.Show.Show GHC.Types.SourceText.SourceText
instance Data.Data.Data GHC.Types.SourceText.SourceText
instance GHC.Show.Show GHC.Types.SourceText.IntegralLit
instance Data.Data.Data GHC.Types.SourceText.IntegralLit
instance GHC.Show.Show GHC.Types.SourceText.FractionalExponentBase
instance Data.Data.Data GHC.Types.SourceText.FractionalExponentBase
instance GHC.Classes.Ord GHC.Types.SourceText.FractionalExponentBase
instance GHC.Classes.Eq GHC.Types.SourceText.FractionalExponentBase
instance GHC.Show.Show GHC.Types.SourceText.FractionalLit
instance Data.Data.Data GHC.Types.SourceText.FractionalLit
instance Data.Data.Data GHC.Types.SourceText.StringLiteral
instance GHC.Classes.Eq GHC.Types.SourceText.StringLiteral
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.StringLiteral
instance GHC.Utils.Binary.Binary GHC.Types.SourceText.StringLiteral
instance GHC.Classes.Eq GHC.Types.SourceText.FractionalLit
instance GHC.Classes.Ord GHC.Types.SourceText.FractionalLit
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.FractionalLit
instance GHC.Classes.Eq GHC.Types.SourceText.IntegralLit
instance GHC.Classes.Ord GHC.Types.SourceText.IntegralLit
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.IntegralLit
instance GHC.Utils.Outputable.Outputable GHC.Types.SourceText.SourceText
instance GHC.Utils.Binary.Binary GHC.Types.SourceText.SourceText

module GHC.Types.PkgQual

-- | Package-qualifier as it was parsed
data RawPkgQual

-- | No package qualifier
NoRawPkgQual :: RawPkgQual

-- | Raw package qualifier string.
RawPkgQual :: StringLiteral -> RawPkgQual

-- | Package-qualifier after renaming
--   
--   Renaming detects if "this" or the unit-id of the home-unit was used as
--   a package qualifier.
data PkgQual

-- | No package qualifier
NoPkgQual :: PkgQual

-- | Import from home-unit
ThisPkg :: UnitId -> PkgQual

-- | Import from another unit
OtherPkg :: UnitId -> PkgQual
instance Data.Data.Data GHC.Types.PkgQual.RawPkgQual
instance GHC.Classes.Eq GHC.Types.PkgQual.PkgQual
instance GHC.Classes.Ord GHC.Types.PkgQual.PkgQual
instance Data.Data.Data GHC.Types.PkgQual.PkgQual
instance GHC.Utils.Outputable.Outputable GHC.Types.PkgQual.PkgQual
instance GHC.Utils.Outputable.Outputable GHC.Types.PkgQual.RawPkgQual

module GHC.Types.SourceFile
data HscSource

-- | .hs file
HsSrcFile :: HscSource

-- | .hs-boot file
HsBootFile :: HscSource

-- | .hsig file
HsigFile :: HscSource

-- | Tests if an <a>HscSource</a> is a boot file, primarily for
--   constructing elements of <tt>BuildModule</tt>. We conflate signatures
--   and modules because they are bound in the same namespace; only boot
--   interfaces can be disambiguated with `import {-# SOURCE #-}`.
hscSourceToIsBoot :: HscSource -> IsBootInterface
isHsBootOrSig :: HscSource -> Bool
isHsigFile :: HscSource -> Bool
hscSourceString :: HscSource -> String
instance GHC.Show.Show GHC.Types.SourceFile.HscSource
instance GHC.Classes.Ord GHC.Types.SourceFile.HscSource
instance GHC.Classes.Eq GHC.Types.SourceFile.HscSource
instance GHC.Utils.Binary.Binary GHC.Types.SourceFile.HscSource


-- | This stuff here is related to supporting the Safe Haskell extension,
--   primarily about storing under what trust type a module has been
--   compiled.
module GHC.Types.SafeHaskell

-- | Is an import a safe import?
type IsSafeImport = Bool

-- | The various Safe Haskell modes
data SafeHaskellMode

-- | inferred unsafe
Sf_None :: SafeHaskellMode

-- | declared and checked
Sf_Unsafe :: SafeHaskellMode

-- | declared and checked
Sf_Trustworthy :: SafeHaskellMode

-- | declared and checked
Sf_Safe :: SafeHaskellMode

-- | inferred as safe
Sf_SafeInferred :: SafeHaskellMode

-- | <tt>-fno-safe-haskell</tt> state
Sf_Ignore :: SafeHaskellMode

-- | Safe Haskell information for <tt>ModIface</tt> Simply a wrapper around
--   SafeHaskellMode to separate iface and flags
data IfaceTrustInfo
getSafeMode :: IfaceTrustInfo -> SafeHaskellMode
setSafeMode :: SafeHaskellMode -> IfaceTrustInfo
noIfaceTrustInfo :: IfaceTrustInfo
instance GHC.Classes.Eq GHC.Types.SafeHaskell.SafeHaskellMode
instance GHC.Utils.Outputable.Outputable GHC.Types.SafeHaskell.IfaceTrustInfo
instance GHC.Utils.Binary.Binary GHC.Types.SafeHaskell.IfaceTrustInfo
instance GHC.Show.Show GHC.Types.SafeHaskell.SafeHaskellMode
instance GHC.Utils.Outputable.Outputable GHC.Types.SafeHaskell.SafeHaskellMode

module GHC.Types.ForeignCall
newtype ForeignCall
CCall :: CCallSpec -> ForeignCall
isSafeForeignCall :: ForeignCall -> Bool
data Safety

-- | Might invoke Haskell GC, or do a call back, or switch threads, etc. So
--   make sure things are tidy before the call. Additionally, in the
--   threaded RTS we arrange for the external call to be executed by a
--   separate OS thread, i.e., _concurrently_ to the execution of other
--   Haskell threads.
PlaySafe :: Safety

-- | Like PlaySafe, but additionally the worker thread running this foreign
--   call may be unceremoniously killed, so it must be scheduled on an
--   unbound thread.
PlayInterruptible :: Safety

-- | None of the above can happen; the call will return without interacting
--   with the runtime system at all. Specifically:
--   
--   <ul>
--   <li>No GC</li>
--   <li>No call backs</li>
--   <li>No blocking</li>
--   <li>No precise exceptions</li>
--   </ul>
PlayRisky :: Safety
playSafe :: Safety -> Bool
playInterruptible :: Safety -> Bool
data CExportSpec
CExportStatic :: SourceText -> CLabelString -> CCallConv -> CExportSpec
type CLabelString = FastString
isCLabelString :: CLabelString -> Bool
pprCLabelString :: CLabelString -> SDoc
data CCallSpec
CCallSpec :: CCallTarget -> CCallConv -> Safety -> CCallSpec

-- | How to call a particular function in C-land.
data CCallTarget
StaticTarget :: SourceText -> CLabelString -> Maybe Unit -> Bool -> CCallTarget
DynamicTarget :: CCallTarget
isDynamicTarget :: CCallTarget -> Bool
data CCallConv
CCallConv :: CCallConv
CApiConv :: CCallConv
StdCallConv :: CCallConv
PrimCallConv :: CCallConv
JavaScriptCallConv :: CCallConv
defaultCCallConv :: CCallConv
ccallConvToInt :: CCallConv -> Int
ccallConvAttribute :: CCallConv -> SDoc
data Header
Header :: SourceText -> FastString -> Header

-- | A C type, used in CAPI FFI calls
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# CTYPE'</tt>,
--   <a>AnnHeader</a>,<a>AnnVal</a>, <a>AnnClose</a> <tt>'#-}'</tt>,</li>
--   </ul>
data CType
CType :: SourceText -> Maybe Header -> (SourceText, FastString) -> CType
instance GHC.Enum.Enum GHC.Types.ForeignCall.Safety
instance Data.Data.Data GHC.Types.ForeignCall.Safety
instance GHC.Show.Show GHC.Types.ForeignCall.Safety
instance GHC.Classes.Eq GHC.Types.ForeignCall.Safety
instance GHC.Enum.Enum GHC.Types.ForeignCall.CCallConv
instance Data.Data.Data GHC.Types.ForeignCall.CCallConv
instance GHC.Classes.Eq GHC.Types.ForeignCall.CCallConv
instance Data.Data.Data GHC.Types.ForeignCall.CCallTarget
instance GHC.Classes.Eq GHC.Types.ForeignCall.CCallTarget
instance GHC.Classes.Eq GHC.Types.ForeignCall.CCallSpec
instance GHC.Classes.Eq GHC.Types.ForeignCall.ForeignCall
instance Data.Data.Data GHC.Types.ForeignCall.CExportSpec
instance Data.Data.Data GHC.Types.ForeignCall.Header
instance GHC.Classes.Eq GHC.Types.ForeignCall.Header
instance Data.Data.Data GHC.Types.ForeignCall.CType
instance GHC.Classes.Eq GHC.Types.ForeignCall.CType
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CType
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CType
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.Header
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.Header
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CExportSpec
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CExportSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.ForeignCall
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.ForeignCall
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CCallSpec
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CCallSpec
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CCallTarget
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.CCallConv
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.CCallConv
instance GHC.Utils.Outputable.Outputable GHC.Types.ForeignCall.Safety
instance GHC.Utils.Binary.Binary GHC.Types.ForeignCall.Safety


-- | Fixity
module GHC.Types.Fixity
data Fixity
Fixity :: SourceText -> Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | Captures the fixity of declarations as they are parsed. This is not
--   necessarily the same as the fixity declaration, as the normal fixity
--   may be overridden using parens or backticks.
data LexicalFixity
Prefix :: LexicalFixity
Infix :: LexicalFixity
maxPrecedence :: Int
minPrecedence :: Int
defaultFixity :: Fixity
negateFixity :: Fixity
funTyFixity :: Fixity
compareFixity :: Fixity -> Fixity -> (Bool, Bool)
instance Data.Data.Data GHC.Types.Fixity.FixityDirection
instance GHC.Classes.Eq GHC.Types.Fixity.FixityDirection
instance Data.Data.Data GHC.Types.Fixity.Fixity
instance GHC.Classes.Eq GHC.Types.Fixity.LexicalFixity
instance Data.Data.Data GHC.Types.Fixity.LexicalFixity
instance GHC.Utils.Outputable.Outputable GHC.Types.Fixity.LexicalFixity
instance GHC.Utils.Outputable.Outputable GHC.Types.Fixity.Fixity
instance GHC.Classes.Eq GHC.Types.Fixity.Fixity
instance GHC.Utils.Binary.Binary GHC.Types.Fixity.Fixity
instance GHC.Utils.Outputable.Outputable GHC.Types.Fixity.FixityDirection
instance GHC.Utils.Binary.Binary GHC.Types.Fixity.FixityDirection

module GHC.Types.CostCentre.State

-- | Per-module state for tracking cost centre indices.
--   
--   See documentation of <a>cc_flavour</a> for more details.
data CostCentreState

-- | Initialize cost centre state.
newCostCentreState :: CostCentreState

-- | An index into a given cost centre module,name,flavour set
data CostCentreIndex
unCostCentreIndex :: CostCentreIndex -> Int

-- | Get a new index for a given cost centre name.
getCCIndex :: FastString -> CostCentreState -> (CostCentreIndex, CostCentreState)
instance GHC.Utils.Binary.Binary GHC.Types.CostCentre.State.CostCentreIndex
instance Data.Data.Data GHC.Types.CostCentre.State.CostCentreIndex
instance GHC.Classes.Ord GHC.Types.CostCentre.State.CostCentreIndex
instance GHC.Classes.Eq GHC.Types.CostCentre.State.CostCentreIndex

module GHC.Iface.Ext.Fields
newtype ExtensibleFields
ExtensibleFields :: Map FieldName BinData -> ExtensibleFields
[getExtensibleFields] :: ExtensibleFields -> Map FieldName BinData
type FieldName = String
emptyExtensibleFields :: ExtensibleFields

-- | Reading
readField :: Binary a => FieldName -> ExtensibleFields -> IO (Maybe a)
readFieldWith :: FieldName -> (BinHandle -> IO a) -> ExtensibleFields -> IO (Maybe a)

-- | Writing
writeField :: Binary a => FieldName -> a -> ExtensibleFields -> IO ExtensibleFields
writeFieldWith :: FieldName -> (BinHandle -> IO ()) -> ExtensibleFields -> IO ExtensibleFields
deleteField :: FieldName -> ExtensibleFields -> ExtensibleFields
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Fields.ExtensibleFields
instance Control.DeepSeq.NFData GHC.Iface.Ext.Fields.ExtensibleFields


-- | An exactprintable structure for docstrings
module GHC.Hs.DocString
type LHsDocString = Located HsDocString

-- | Haskell Documentation String
--   
--   Rich structure to support exact printing The location around each
--   chunk doesn't include the decorators
data HsDocString

-- | The first chunk is preceded by "-- <a>decorator</a>" and each
--   following chunk is preceded by "--" Example: -- | This is a docstring
--   for <tt>foo</tt>. It is the line with the decorator '|' and is always
--   included -- This continues that docstring and is the second element in
--   the NonEmpty list foo :: a -&gt; a
MultiLineDocString :: !HsDocStringDecorator -> !NonEmpty LHsDocStringChunk -> HsDocString

-- | The docstring is preceded by "{-<a>decorator</a>" and followed by "-}"
--   The chunk contains balanced pairs of '{-' and '-}'
NestedDocString :: !HsDocStringDecorator -> LHsDocStringChunk -> HsDocString

-- | A docstring generated either internally or via TH Pretty printed with
--   the '-- |' decorator This is because it may contain unbalanced pairs
--   of '{-' and '-}' and not form a valid <a>NestedDocString</a>
GeneratedDocString :: HsDocStringChunk -> HsDocString
data HsDocStringDecorator

-- | '|' is the decorator
HsDocStringNext :: HsDocStringDecorator

-- | <a>^</a> is the decorator
HsDocStringPrevious :: HsDocStringDecorator

-- | '$<a>string</a>' is the decorator
HsDocStringNamed :: !String -> HsDocStringDecorator

-- | The decorator is the given number of <a>*</a>s
HsDocStringGroup :: !Int -> HsDocStringDecorator

-- | A contiguous chunk of documentation
newtype HsDocStringChunk
HsDocStringChunk :: ByteString -> HsDocStringChunk
type LHsDocStringChunk = Located HsDocStringChunk
isEmptyDocString :: HsDocString -> Bool
unpackHDSC :: HsDocStringChunk -> String
mkHsDocStringChunk :: String -> HsDocStringChunk

-- | Create a <a>HsDocString</a> from a UTF8-encoded <a>ByteString</a>.
mkHsDocStringChunkUtf8ByteString :: ByteString -> HsDocStringChunk

-- | Pretty print with decorators, exactly as the user wrote it
pprHsDocString :: HsDocString -> SDoc
pprHsDocStrings :: [HsDocString] -> SDoc
mkGeneratedHsDocString :: String -> HsDocString
docStringChunks :: HsDocString -> [LHsDocStringChunk]

-- | Just get the docstring, without any decorators
renderHsDocString :: HsDocString -> String

-- | Just get the docstring, without any decorators Separates docstrings
--   using "nn", which is how haddock likes to render them
renderHsDocStrings :: [HsDocString] -> String

-- | Pretty print with decorators, exactly as the user wrote it
exactPrintHsDocString :: HsDocString -> String

-- | Annotate a pretty printed thing with its doc The docstring comes after
--   if is <a>HsDocStringPrevious</a> Otherwise it comes before. Note - we
--   convert MultiLineDocString HsDocStringPrevious to HsDocStringNext
--   because we can't control if something else will be pretty printed on
--   the same line
pprWithDocString :: HsDocString -> SDoc -> SDoc
instance Data.Data.Data GHC.Hs.DocString.HsDocStringDecorator
instance GHC.Show.Show GHC.Hs.DocString.HsDocStringDecorator
instance GHC.Classes.Ord GHC.Hs.DocString.HsDocStringDecorator
instance GHC.Classes.Eq GHC.Hs.DocString.HsDocStringDecorator
instance Control.DeepSeq.NFData GHC.Hs.DocString.HsDocStringChunk
instance GHC.Show.Show GHC.Hs.DocString.HsDocStringChunk
instance Data.Data.Data GHC.Hs.DocString.HsDocStringChunk
instance GHC.Classes.Ord GHC.Hs.DocString.HsDocStringChunk
instance GHC.Classes.Eq GHC.Hs.DocString.HsDocStringChunk
instance GHC.Show.Show GHC.Hs.DocString.HsDocString
instance Data.Data.Data GHC.Hs.DocString.HsDocString
instance GHC.Classes.Eq GHC.Hs.DocString.HsDocString
instance GHC.Utils.Outputable.Outputable GHC.Hs.DocString.HsDocString
instance Control.DeepSeq.NFData GHC.Hs.DocString.HsDocString
instance GHC.Utils.Binary.Binary GHC.Hs.DocString.HsDocString
instance GHC.Utils.Binary.Binary GHC.Hs.DocString.HsDocStringChunk
instance GHC.Utils.Outputable.Outputable GHC.Hs.DocString.HsDocStringChunk
instance GHC.Utils.Outputable.Outputable GHC.Hs.DocString.HsDocStringDecorator
instance Control.DeepSeq.NFData GHC.Hs.DocString.HsDocStringDecorator
instance GHC.Utils.Binary.Binary GHC.Hs.DocString.HsDocStringDecorator


-- | A tiny wrapper around <a>IntSet</a> for representing sets of
--   <a>Enum</a> things.
module GHC.Data.EnumSet
data EnumSet a
member :: Enum a => a -> EnumSet a -> Bool
insert :: Enum a => a -> EnumSet a -> EnumSet a
delete :: Enum a => a -> EnumSet a -> EnumSet a
toList :: Enum a => EnumSet a -> [a]
fromList :: Enum a => [a] -> EnumSet a
empty :: EnumSet a
difference :: EnumSet a -> EnumSet a -> EnumSet a
instance Control.DeepSeq.NFData (GHC.Data.EnumSet.EnumSet a)
instance GHC.Base.Monoid (GHC.Data.EnumSet.EnumSet a)
instance GHC.Base.Semigroup (GHC.Data.EnumSet.EnumSet a)
instance GHC.Utils.Binary.Binary (GHC.Data.EnumSet.EnumSet a)

module GHC.Driver.Flags

-- | Debugging flags
data DumpFlag
Opt_D_dump_cmm :: DumpFlag
Opt_D_dump_cmm_from_stg :: DumpFlag
Opt_D_dump_cmm_raw :: DumpFlag
Opt_D_dump_cmm_verbose_by_proc :: DumpFlag
Opt_D_dump_cmm_verbose :: DumpFlag
Opt_D_dump_cmm_cfg :: DumpFlag
Opt_D_dump_cmm_cbe :: DumpFlag
Opt_D_dump_cmm_switch :: DumpFlag
Opt_D_dump_cmm_proc :: DumpFlag
Opt_D_dump_cmm_sp :: DumpFlag
Opt_D_dump_cmm_sink :: DumpFlag
Opt_D_dump_cmm_caf :: DumpFlag
Opt_D_dump_cmm_procmap :: DumpFlag
Opt_D_dump_cmm_split :: DumpFlag
Opt_D_dump_cmm_info :: DumpFlag
Opt_D_dump_cmm_cps :: DumpFlag
Opt_D_dump_cmm_thread_sanitizer :: DumpFlag

-- | Dump the cfg used for block layout.
Opt_D_dump_cfg_weights :: DumpFlag
Opt_D_dump_asm :: DumpFlag
Opt_D_dump_asm_native :: DumpFlag
Opt_D_dump_asm_liveness :: DumpFlag
Opt_D_dump_asm_regalloc :: DumpFlag
Opt_D_dump_asm_regalloc_stages :: DumpFlag
Opt_D_dump_asm_conflicts :: DumpFlag
Opt_D_dump_asm_stats :: DumpFlag
Opt_D_dump_c_backend :: DumpFlag
Opt_D_dump_llvm :: DumpFlag
Opt_D_dump_js :: DumpFlag
Opt_D_dump_core_stats :: DumpFlag
Opt_D_dump_deriv :: DumpFlag
Opt_D_dump_ds :: DumpFlag
Opt_D_dump_ds_preopt :: DumpFlag
Opt_D_dump_foreign :: DumpFlag
Opt_D_dump_inlinings :: DumpFlag
Opt_D_dump_verbose_inlinings :: DumpFlag
Opt_D_dump_rule_firings :: DumpFlag
Opt_D_dump_rule_rewrites :: DumpFlag
Opt_D_dump_simpl_trace :: DumpFlag
Opt_D_dump_occur_anal :: DumpFlag
Opt_D_dump_parsed :: DumpFlag
Opt_D_dump_parsed_ast :: DumpFlag
Opt_D_dump_rn :: DumpFlag
Opt_D_dump_rn_ast :: DumpFlag
Opt_D_dump_simpl :: DumpFlag
Opt_D_dump_simpl_iterations :: DumpFlag
Opt_D_dump_spec :: DumpFlag
Opt_D_dump_prep :: DumpFlag
Opt_D_dump_late_cc :: DumpFlag

-- | Initial STG (CoreToStg output)
Opt_D_dump_stg_from_core :: DumpFlag

-- | STG after unarise
Opt_D_dump_stg_unarised :: DumpFlag

-- | STG (after stg2stg)
Opt_D_dump_stg_cg :: DumpFlag

-- | Result of tag inference analysis.
Opt_D_dump_stg_tags :: DumpFlag

-- | Final STG (before cmm gen)
Opt_D_dump_stg_final :: DumpFlag
Opt_D_dump_call_arity :: DumpFlag
Opt_D_dump_exitify :: DumpFlag
Opt_D_dump_stranal :: DumpFlag
Opt_D_dump_str_signatures :: DumpFlag
Opt_D_dump_cpranal :: DumpFlag
Opt_D_dump_cpr_signatures :: DumpFlag
Opt_D_dump_tc :: DumpFlag
Opt_D_dump_tc_ast :: DumpFlag
Opt_D_dump_hie :: DumpFlag
Opt_D_dump_types :: DumpFlag
Opt_D_dump_rules :: DumpFlag
Opt_D_dump_cse :: DumpFlag
Opt_D_dump_worker_wrapper :: DumpFlag
Opt_D_dump_rn_trace :: DumpFlag
Opt_D_dump_rn_stats :: DumpFlag
Opt_D_dump_opt_cmm :: DumpFlag
Opt_D_dump_simpl_stats :: DumpFlag
Opt_D_dump_cs_trace :: DumpFlag
Opt_D_dump_tc_trace :: DumpFlag
Opt_D_dump_ec_trace :: DumpFlag
Opt_D_dump_if_trace :: DumpFlag
Opt_D_dump_splices :: DumpFlag
Opt_D_th_dec_file :: DumpFlag
Opt_D_dump_BCOs :: DumpFlag
Opt_D_dump_ticked :: DumpFlag
Opt_D_dump_rtti :: DumpFlag
Opt_D_source_stats :: DumpFlag
Opt_D_verbose_stg2stg :: DumpFlag
Opt_D_dump_hi :: DumpFlag
Opt_D_dump_hi_diffs :: DumpFlag
Opt_D_dump_mod_cycles :: DumpFlag
Opt_D_dump_mod_map :: DumpFlag
Opt_D_dump_timings :: DumpFlag
Opt_D_dump_view_pattern_commoning :: DumpFlag
Opt_D_verbose_core2core :: DumpFlag
Opt_D_dump_debug :: DumpFlag
Opt_D_dump_json :: DumpFlag
Opt_D_ppr_debug :: DumpFlag
Opt_D_no_debug_output :: DumpFlag
Opt_D_dump_faststrings :: DumpFlag
Opt_D_faststring_stats :: DumpFlag
Opt_D_ipe_stats :: DumpFlag

-- | Helper function to query whether a given <a>DumpFlag</a> is enabled or
--   not.
getDumpFlagFrom :: (a -> Int) -> (a -> EnumSet DumpFlag) -> DumpFlag -> a -> Bool

-- | Is the flag implicitly enabled when the verbosity is high enough?
enabledIfVerbose :: DumpFlag -> Bool

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag

-- | Use foo.ways.<a>dumpFlag</a> instead of foo.<a>dumpFlag</a>
Opt_DumpWithWays :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoLinearCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_DoBoundsChecking :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_NoTypeableBinds :: GeneralFlag
Opt_DistinctConstructorTables :: GeneralFlag
Opt_InfoTableMap :: GeneralFlag
Opt_InfoTableMapWithFallback :: GeneralFlag
Opt_InfoTableMapWithStack :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintAxiomIncomps :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintRedundantPromotionTicks :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag

-- | Enable floating out of let-bindings in the simplifier
Opt_LocalFloatOut :: GeneralFlag

-- | Enable floating out of let-bindings at the top level in the simplifier
--   N.B. See Note [RHS Floating]
Opt_LocalFloatOutTopLevel :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_PolymorphicSpecialisation :: GeneralFlag
Opt_InlineGenerics :: GeneralFlag
Opt_InlineGenericsAggressively :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_EnableThSpliceWarnings :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmTBAA :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmStaticPred :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_CmmControlFlow :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag

-- | deprecated, no effect and behaviour is now default. Allowed switching
--   of a special demand transformer for dictionary selectors
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag

-- | Do W/W split for unlifting even if we won't unbox anything.
Opt_WorkerWrapperUnlift :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchNonexhaustiveCases :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_CoreConstantFolding :: GeneralFlag
Opt_FastPAPCalls :: GeneralFlag
Opt_SpecEval :: GeneralFlag
Opt_SpecEvalDictFun :: GeneralFlag
Opt_DoTagInferenceChecks :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_ProfLateInlineCcs :: GeneralFlag
Opt_ProfLateCcs :: GeneralFlag

-- | Ignore manual SCC annotations
Opt_ProfManualCcs :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_Ticky_Tag :: GeneralFlag

-- | Use regular thunks even when we could use std ap thunks in order to
--   get entry counts
Opt_Ticky_AP :: GeneralFlag
Opt_CmmThreadSanitizer :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag

-- | <pre>
--   -fcompact-unwind
--   </pre>
Opt_CompactUnwind :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FamAppCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_ExposeInternalSymbols :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_KeepGoing :: GeneralFlag
Opt_ByteCode :: GeneralFlag
Opt_ByteCodeAndObjectCode :: GeneralFlag
Opt_LinkRts :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DeferDiagnostics :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressCoercionTypes :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressStgReps :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag

-- | Suppress per binding Core size stats in dumps
Opt_SuppressCoreSizes :: GeneralFlag
Opt_ShowErrorContext :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_WriteIfSimplifiedCore :: GeneralFlag
Opt_UseBytecodeRatherThanObjects :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_PluginTrustworthy :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag
data Language
Haskell98 :: Language
Haskell2010 :: Language
GHC2021 :: Language

-- | The set of flags which affect optimisation for the purposes of
--   recompilation avoidance. Specifically, these include flags which
--   affect code generation but not the semantics of the program.
--   
--   See Note [Ignoring some flag changes] in GHC.Iface.Recomp.Flags)
optimisationFlags :: EnumSet GeneralFlag

-- | The set of flags which affect code generation and can change a
--   program's runtime behavior (other than performance). These include
--   flags which affect:
--   
--   <ul>
--   <li>user visible debugging information (e.g. info table
--   provenance)</li>
--   <li>the ability to catch runtime errors (e.g. -fignore-asserts)</li>
--   <li>the runtime result of the program (e.g. -fomit-yields)</li>
--   <li>which code or interface file declarations are emitted</li>
--   </ul>
--   
--   We also considered placing flags which affect asympototic space
--   behavior (e.g. -ffull-laziness) however this would mean that changing
--   optimisation levels would trigger recompilation even with
--   -fignore-optim-changes, regressing #13604.
--   
--   Also, arguably Opt_IgnoreAsserts should be here as well; however, we
--   place it instead in <a>optimisationFlags</a> since it is implied by
--   <tt>-O[12]</tt> and therefore would also break #13604.
--   
--   See #23369.
codeGenFlags :: EnumSet GeneralFlag
data WarningFlag
Opt_WarnDuplicateExports :: WarningFlag
Opt_WarnDuplicateConstraints :: WarningFlag
Opt_WarnRedundantConstraints :: WarningFlag
Opt_WarnHiShadows :: WarningFlag
Opt_WarnImplicitPrelude :: WarningFlag
Opt_WarnIncompletePatterns :: WarningFlag
Opt_WarnIncompleteUniPatterns :: WarningFlag
Opt_WarnIncompletePatternsRecUpd :: WarningFlag
Opt_WarnOverflowedLiterals :: WarningFlag
Opt_WarnEmptyEnumerations :: WarningFlag
Opt_WarnMissingFields :: WarningFlag
Opt_WarnMissingImportList :: WarningFlag
Opt_WarnMissingMethods :: WarningFlag
Opt_WarnMissingSignatures :: WarningFlag
Opt_WarnMissingLocalSignatures :: WarningFlag
Opt_WarnNameShadowing :: WarningFlag
Opt_WarnOverlappingPatterns :: WarningFlag
Opt_WarnTypeDefaults :: WarningFlag
Opt_WarnMonomorphism :: WarningFlag
Opt_WarnUnusedTopBinds :: WarningFlag
Opt_WarnUnusedLocalBinds :: WarningFlag
Opt_WarnUnusedPatternBinds :: WarningFlag
Opt_WarnUnusedImports :: WarningFlag
Opt_WarnUnusedMatches :: WarningFlag
Opt_WarnUnusedTypePatterns :: WarningFlag
Opt_WarnUnusedForalls :: WarningFlag
Opt_WarnUnusedRecordWildcards :: WarningFlag
Opt_WarnRedundantBangPatterns :: WarningFlag
Opt_WarnRedundantRecordWildcards :: WarningFlag
Opt_WarnWarningsDeprecations :: WarningFlag
Opt_WarnDeprecatedFlags :: WarningFlag
Opt_WarnMissingMonadFailInstances :: WarningFlag
Opt_WarnSemigroup :: WarningFlag
Opt_WarnDodgyExports :: WarningFlag
Opt_WarnDodgyImports :: WarningFlag
Opt_WarnOrphans :: WarningFlag
Opt_WarnAutoOrphans :: WarningFlag
Opt_WarnIdentities :: WarningFlag
Opt_WarnTabs :: WarningFlag
Opt_WarnUnrecognisedPragmas :: WarningFlag
Opt_WarnMisplacedPragmas :: WarningFlag
Opt_WarnDodgyForeignImports :: WarningFlag
Opt_WarnUnusedDoBind :: WarningFlag
Opt_WarnWrongDoBind :: WarningFlag
Opt_WarnAlternativeLayoutRuleTransitional :: WarningFlag
Opt_WarnUnsafe :: WarningFlag
Opt_WarnSafe :: WarningFlag
Opt_WarnTrustworthySafe :: WarningFlag
Opt_WarnMissedSpecs :: WarningFlag
Opt_WarnAllMissedSpecs :: WarningFlag
Opt_WarnUnsupportedCallingConventions :: WarningFlag
Opt_WarnUnsupportedLlvmVersion :: WarningFlag
Opt_WarnMissedExtraSharedLib :: WarningFlag
Opt_WarnInlineRuleShadowing :: WarningFlag
Opt_WarnTypedHoles :: WarningFlag
Opt_WarnPartialTypeSignatures :: WarningFlag
Opt_WarnMissingExportedSignatures :: WarningFlag
Opt_WarnUntickedPromotedConstructors :: WarningFlag
Opt_WarnDerivingTypeable :: WarningFlag
Opt_WarnDeferredTypeErrors :: WarningFlag
Opt_WarnDeferredOutOfScopeVariables :: WarningFlag
Opt_WarnNonCanonicalMonadInstances :: WarningFlag
Opt_WarnNonCanonicalMonadFailInstances :: WarningFlag
Opt_WarnNonCanonicalMonoidInstances :: WarningFlag
Opt_WarnMissingPatternSynonymSignatures :: WarningFlag
Opt_WarnUnrecognisedWarningFlags :: WarningFlag
Opt_WarnSimplifiableClassConstraints :: WarningFlag
Opt_WarnCPPUndef :: WarningFlag
Opt_WarnUnbangedStrictPatterns :: WarningFlag
Opt_WarnMissingHomeModules :: WarningFlag
Opt_WarnPartialFields :: WarningFlag
Opt_WarnMissingExportList :: WarningFlag
Opt_WarnInaccessibleCode :: WarningFlag
Opt_WarnStarIsType :: WarningFlag
Opt_WarnStarBinder :: WarningFlag
Opt_WarnImplicitKindVars :: WarningFlag
Opt_WarnSpaceAfterBang :: WarningFlag
Opt_WarnMissingDerivingStrategies :: WarningFlag
Opt_WarnPrepositiveQualifiedModule :: WarningFlag
Opt_WarnUnusedPackages :: WarningFlag
Opt_WarnInferredSafeImports :: WarningFlag
Opt_WarnMissingSafeHaskellMode :: WarningFlag
Opt_WarnCompatUnqualifiedImports :: WarningFlag
Opt_WarnDerivingDefaults :: WarningFlag
Opt_WarnInvalidHaddock :: WarningFlag
Opt_WarnOperatorWhitespaceExtConflict :: WarningFlag
Opt_WarnOperatorWhitespace :: WarningFlag
Opt_WarnAmbiguousFields :: WarningFlag
Opt_WarnImplicitLift :: WarningFlag
Opt_WarnMissingKindSignatures :: WarningFlag
Opt_WarnMissingExportedPatternSynonymSignatures :: WarningFlag
Opt_WarnRedundantStrictnessFlags :: WarningFlag
Opt_WarnForallIdentifier :: WarningFlag
Opt_WarnUnicodeBidirectionalFormatCharacters :: WarningFlag
Opt_WarnGADTMonoLocalBinds :: WarningFlag
Opt_WarnTypeEqualityOutOfScope :: WarningFlag
Opt_WarnTypeEqualityRequiresOperators :: WarningFlag
Opt_WarnLoopySuperclassSolve :: WarningFlag

-- | Return the names of a WarningFlag
--   
--   One flag may have several names because of US/UK spelling. The first
--   one is the "preferred one" that will be displayed in warning messages.
warnFlagNames :: WarningFlag -> NonEmpty String

-- | Warning groups.
--   
--   As all warnings are in the Weverything set, it is ignored when
--   displaying to the user which group a warning is in.
warningGroups :: [(String, [WarningFlag])]

-- | Warning group hierarchies, where there is an explicit inclusion
--   relation.
--   
--   Each inner list is a hierarchy of warning groups, ordered from
--   smallest to largest, where each group is a superset of the one before
--   it.
--   
--   Separating this from <a>warningGroups</a> allows for multiple
--   hierarchies with no inherent relation to be defined.
--   
--   The special-case Weverything group is not included.
warningHierarchies :: [[String]]

-- | Find the smallest group in every hierarchy which a warning belongs to,
--   excluding Weverything.
smallestWarningGroups :: WarningFlag -> [String]

-- | Warnings enabled unless specified otherwise
standardWarnings :: [WarningFlag]

-- | Things you get with -W
minusWOpts :: [WarningFlag]

-- | Things you get with -Wall
minusWallOpts :: [WarningFlag]

-- | Things you get with -Weverything, i.e. *all* known warnings flags
minusWeverythingOpts :: [WarningFlag]

-- | Things you get with -Wcompat.
--   
--   This is intended to group together warnings that will be enabled by
--   default at some point in the future, so that library authors eager to
--   make their code future compatible to fix issues before they even
--   generate warnings.
minusWcompatOpts :: [WarningFlag]

-- | Things you get with -Wunused-binds
unusedBindsFlags :: [WarningFlag]
instance GHC.Enum.Bounded GHC.Driver.Flags.Language
instance GHC.Show.Show GHC.Driver.Flags.Language
instance GHC.Enum.Enum GHC.Driver.Flags.Language
instance GHC.Classes.Eq GHC.Driver.Flags.Language
instance GHC.Enum.Enum GHC.Driver.Flags.DumpFlag
instance GHC.Show.Show GHC.Driver.Flags.DumpFlag
instance GHC.Classes.Eq GHC.Driver.Flags.DumpFlag
instance GHC.Enum.Enum GHC.Driver.Flags.GeneralFlag
instance GHC.Show.Show GHC.Driver.Flags.GeneralFlag
instance GHC.Classes.Eq GHC.Driver.Flags.GeneralFlag
instance GHC.Enum.Bounded GHC.Driver.Flags.WarningFlag
instance GHC.Enum.Enum GHC.Driver.Flags.WarningFlag
instance GHC.Show.Show GHC.Driver.Flags.WarningFlag
instance GHC.Classes.Ord GHC.Driver.Flags.WarningFlag
instance GHC.Classes.Eq GHC.Driver.Flags.WarningFlag
instance GHC.Utils.Outputable.Outputable GHC.Driver.Flags.Language
instance GHC.Utils.Binary.Binary GHC.Driver.Flags.Language
instance Control.DeepSeq.NFData GHC.Driver.Flags.Language

module GHC.Types.FieldLabel

-- | A map from labels to all the auxiliary information
type FieldLabelEnv = DFastStringEnv FieldLabel

-- | Fields in an algebraic record type; see Note [FieldLabel].
data FieldLabel
FieldLabel :: FieldLabelString -> DuplicateRecordFields -> FieldSelectors -> Name -> FieldLabel

-- | User-visible label of the field
[flLabel] :: FieldLabel -> FieldLabelString

-- | Was <tt>DuplicateRecordFields</tt> on in the defining module for this
--   datatype?
[flHasDuplicateRecordFields] :: FieldLabel -> DuplicateRecordFields

-- | Was <tt>FieldSelectors</tt> enabled in the defining module for this
--   datatype? See Note [NoFieldSelectors] in GHC.Rename.Env
[flHasFieldSelector] :: FieldLabel -> FieldSelectors

-- | Record selector function
[flSelector] :: FieldLabel -> Name

-- | Record selector OccNames are built from the underlying field name and
--   the name of the first data constructor of the type, to support
--   duplicate record field names. See Note [Why selector names include
--   data constructors].
fieldSelectorOccName :: FieldLabelString -> OccName -> DuplicateRecordFields -> FieldSelectors -> OccName

-- | Undo the name mangling described in Note [FieldLabel] to produce a
--   Name that has the user-visible OccName (but the selector's unique).
--   This should be used only when generating output, when we want to show
--   the label, but may need to qualify it with a module prefix.
fieldLabelPrintableName :: FieldLabel -> Name

-- | Flag to indicate whether the DuplicateRecordFields extension is
--   enabled.
data DuplicateRecordFields

-- | Fields may be duplicated in a single module
DuplicateRecordFields :: DuplicateRecordFields

-- | Fields must be unique within a module (the default)
NoDuplicateRecordFields :: DuplicateRecordFields

-- | Flag to indicate whether the FieldSelectors extension is enabled.
data FieldSelectors

-- | Selector functions are available (the default)
FieldSelectors :: FieldSelectors

-- | Selector functions are not available
NoFieldSelectors :: FieldSelectors
flIsOverloaded :: FieldLabel -> Bool
instance Data.Data.Data GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Classes.Eq GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Show.Show GHC.Types.FieldLabel.DuplicateRecordFields
instance Data.Data.Data GHC.Types.FieldLabel.FieldSelectors
instance GHC.Classes.Eq GHC.Types.FieldLabel.FieldSelectors
instance GHC.Show.Show GHC.Types.FieldLabel.FieldSelectors
instance GHC.Classes.Eq GHC.Types.FieldLabel.FieldLabel
instance Data.Data.Data GHC.Types.FieldLabel.FieldLabel
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.FieldLabel.FieldLabel
instance GHC.Utils.Outputable.Outputable GHC.Types.FieldLabel.FieldLabel
instance Control.DeepSeq.NFData GHC.Types.FieldLabel.FieldLabel
instance GHC.Utils.Binary.Binary GHC.Types.Name.Name => GHC.Utils.Binary.Binary GHC.Types.FieldLabel.FieldLabel
instance GHC.Utils.Binary.Binary GHC.Types.FieldLabel.FieldSelectors
instance GHC.Utils.Outputable.Outputable GHC.Types.FieldLabel.FieldSelectors
instance Control.DeepSeq.NFData GHC.Types.FieldLabel.FieldSelectors
instance GHC.Utils.Binary.Binary GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Utils.Outputable.Outputable GHC.Types.FieldLabel.DuplicateRecordFields
instance Control.DeepSeq.NFData GHC.Types.FieldLabel.DuplicateRecordFields
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.FieldLabelString
instance GHC.Types.Unique.Uniquable Language.Haskell.Syntax.Basic.FieldLabelString


-- | <ul>
--   <li>Domain and PurposeGHC.JS.Syntax defines the Syntax for the JS
--   backend in GHC. It comports with the <a>ECMA-262</a> although not
--   every production rule of the standard is represented. Code in this
--   module is a fork of <a>JMacro</a> (BSD 3 Clause) by Gershom Bazerman,
--   heavily modified to accomodate GHC's constraints.</li>
--   <li>StrategyNothing fancy in this module, this is a classic deeply
--   embeded AST for JS. We define numerous ADTs and pattern synonyms to
--   make pattern matching and constructing ASTs easier.</li>
--   <li>ConsumersThe entire JS backend consumes this module, e.g., the
--   modules in GHC.StgToJS.*. Please see <a>Make</a> for a module which
--   provides helper functions that use the deeply embedded DSL defined in
--   this module to provide some of the benefits of a shallow
--   embedding.</li>
--   </ul>
module GHC.JS.Syntax

-- | JavaScript statements, see the <a>ECMA262 Reference</a> for details
data JStat

-- | Variable declarations: var foo [= e]
DeclStat :: !Ident -> !Maybe JExpr -> JStat

-- | Return
ReturnStat :: JExpr -> JStat

-- | If
IfStat :: JExpr -> JStat -> JStat -> JStat

-- | While, bool is "do" when True
WhileStat :: Bool -> JExpr -> JStat -> JStat

-- | For-in, bool is "each' when True
ForInStat :: Bool -> Ident -> JExpr -> JStat -> JStat

-- | Switch
SwitchStat :: JExpr -> [(JExpr, JStat)] -> JStat -> JStat

-- | Try
TryStat :: JStat -> Ident -> JStat -> JStat -> JStat

-- | Blocks
BlockStat :: [JStat] -> JStat

-- | Application
ApplStat :: JExpr -> [JExpr] -> JStat

-- | Unary operators
UOpStat :: JUOp -> JExpr -> JStat

-- | Binding form: <tt>foo = bar</tt>
AssignStat :: JExpr -> JExpr -> JStat

-- | <i>Unsaturated</i> blocks see <a>pseudoSaturate</a>
UnsatBlock :: IdentSupply JStat -> JStat

-- | Statement Labels, makes me nostalgic for qbasic
LabelStat :: JsLabel -> JStat -> JStat

-- | Break
BreakStat :: Maybe JsLabel -> JStat

-- | Continue
ContinueStat :: Maybe JsLabel -> JStat

-- | JavaScript Expressions
data JExpr

-- | All values are trivially expressions
ValExpr :: JVal -> JExpr

-- | Selection: Obj.foo, see <a>.^</a>
SelExpr :: JExpr -> Ident -> JExpr

-- | Indexing: Obj[foo], see <a>.!</a>
IdxExpr :: JExpr -> JExpr -> JExpr

-- | Infix Expressions, see <a>JExpr</a> pattern synonyms
InfixExpr :: JOp -> JExpr -> JExpr -> JExpr

-- | Unary Expressions
UOpExpr :: JUOp -> JExpr -> JExpr

-- | If-expression
IfExpr :: JExpr -> JExpr -> JExpr -> JExpr

-- | Application
ApplExpr :: JExpr -> [JExpr] -> JExpr

-- | An <i>Unsaturated</i> expression. See <a>pseudoSaturate</a>
UnsatExpr :: IdentSupply JExpr -> JExpr

-- | JavaScript values
data JVal

-- | A variable reference
JVar :: Ident -> JVal

-- | A JavaScript list, or what JS calls an Array
JList :: [JExpr] -> JVal

-- | A Double
JDouble :: SaneDouble -> JVal

-- | A BigInt
JInt :: Integer -> JVal

-- | A String
JStr :: FastString -> JVal

-- | A Regex
JRegEx :: FastString -> JVal

-- | A JS HashMap: <tt>{"foo": 0}</tt>
JHash :: UniqMap FastString JExpr -> JVal

-- | A function
JFunc :: [Ident] -> JStat -> JVal

-- | An <i>Unsaturated</i> value, see <a>pseudoSaturate</a>
UnsatVal :: IdentSupply JVal -> JVal

-- | JS Binary Operators. We do not deeply embed the comma operator and the
--   assignment operators
data JOp

-- | Equality: <a>==</a>
EqOp :: JOp

-- | Strict Equality: <tt>===</tt>
StrictEqOp :: JOp

-- | InEquality: <tt>!=</tt>
NeqOp :: JOp

-- | Strict InEquality <tt>!==</tt>
StrictNeqOp :: JOp

-- | Greater Than: <a>&gt;</a>
GtOp :: JOp

-- | Greater Than or Equal: <a>&gt;=</a>
GeOp :: JOp

-- | Less Than: &lt;
LtOp :: JOp

-- | Less Than or Equal: &lt;=
LeOp :: JOp

-- | Addition: +
AddOp :: JOp

-- | Subtraction: -
SubOp :: JOp

-- | Multiplication *
MulOp :: JOp

-- | Division: /
DivOp :: JOp

-- | Remainder: %
ModOp :: JOp

-- | Left Shift: &lt;&lt;
LeftShiftOp :: JOp

-- | Right Shift: &gt;&gt;
RightShiftOp :: JOp

-- | Unsigned RightShift: &gt;&gt;&gt;
ZRightShiftOp :: JOp

-- | Bitwise And: &amp;
BAndOp :: JOp

-- | Bitwise Or: |
BOrOp :: JOp

-- | Bitwise XOr: ^
BXorOp :: JOp

-- | Logical And: &amp;&amp;
LAndOp :: JOp

-- | Logical Or: ||
LOrOp :: JOp

-- | <pre>
--   instanceof
--   </pre>
InstanceofOp :: JOp

-- | <pre>
--   in
--   </pre>
InOp :: JOp

-- | JS Unary Operators
data JUOp

-- | Logical Not: <tt>!</tt>
NotOp :: JUOp

-- | Bitwise Not: <tt>~</tt>
BNotOp :: JUOp

-- | Negation: <tt>-</tt>
NegOp :: JUOp

-- | Unary Plus: <tt>+x</tt>
PlusOp :: JUOp

-- | new x
NewOp :: JUOp

-- | typeof x
TypeofOp :: JUOp

-- | delete x
DeleteOp :: JUOp

-- | yield x
YieldOp :: JUOp

-- | void x
VoidOp :: JUOp

-- | Prefix Increment: <tt>++x</tt>
PreIncOp :: JUOp

-- | Postfix Increment: <tt>x++</tt>
PostIncOp :: JUOp

-- | Prefix Decrement: <tt>--x</tt>
PreDecOp :: JUOp

-- | Postfix Decrement: <tt>x--</tt>
PostDecOp :: JUOp

-- | A newtype wrapper around <a>FastString</a> for JS identifiers.
newtype Ident
TxtI :: FastString -> Ident
[itxt] :: Ident -> FastString
identFS :: Ident -> FastString

-- | A Label used for <a>JStat</a>, specifically <a>BreakStat</a>,
--   <a>ContinueStat</a> and of course <a>LabelStat</a>
type JsLabel = LexicalFastString

-- | pattern synonym for a unary operator new
pattern New :: JExpr -> JExpr

-- | pattern synonym for logical not <tt>!</tt>
pattern Not :: JExpr -> JExpr

-- | pattern synonym for unary negation <tt>-</tt>
pattern Negate :: JExpr -> JExpr

-- | pattern synonym for addition <tt>+</tt>
pattern Add :: JExpr -> JExpr -> JExpr

-- | pattern synonym for subtraction <tt>-</tt>
pattern Sub :: JExpr -> JExpr -> JExpr

-- | pattern synonym for multiplication <tt>*</tt>
pattern Mul :: JExpr -> JExpr -> JExpr

-- | pattern synonym for division <tt>*</tt>
pattern Div :: JExpr -> JExpr -> JExpr

-- | pattern synonym for remainder <tt>%</tt>
pattern Mod :: JExpr -> JExpr -> JExpr

-- | pattern synonym for Bitwise Or <tt>|</tt>
pattern BOr :: JExpr -> JExpr -> JExpr

-- | pattern synonym for Bitwise And <tt>&amp;</tt>
pattern BAnd :: JExpr -> JExpr -> JExpr

-- | pattern synonym for Bitwise XOr <tt>^</tt>
pattern BXor :: JExpr -> JExpr -> JExpr

-- | pattern synonym for Bitwise Not <tt>~</tt>
pattern BNot :: JExpr -> JExpr

-- | pattern synonym for logical Or <tt>||</tt>
pattern LOr :: JExpr -> JExpr -> JExpr

-- | pattern synonym for logical And <tt>&amp;&amp;</tt>
pattern LAnd :: JExpr -> JExpr -> JExpr

-- | pattern synonym to create integer values
pattern Int :: Integer -> JExpr

-- | pattern synonym to create string values
pattern String :: FastString -> JExpr

-- | pattern synonym for prefix increment <tt>++x</tt>
pattern PreInc :: JExpr -> JExpr

-- | pattern synonym for postfix increment <tt>x++</tt>
pattern PostInc :: JExpr -> JExpr

-- | pattern synonym for prefix decrement <tt>--x</tt>
pattern PreDec :: JExpr -> JExpr

-- | pattern synonym for postfix decrement <tt>--x</tt>
pattern PostDec :: JExpr -> JExpr

-- | A supply of identifiers, possibly empty
newtype IdentSupply a
IS :: State [Ident] a -> IdentSupply a
[runIdentSupply] :: IdentSupply a -> State [Ident] a
newIdentSupply :: Maybe FastString -> [Ident]

-- | Given a Pseudo-saturate a value with garbage <tt> </tt> identifiers.
pseudoSaturate :: IdentSupply a -> a

-- | A newtype wrapper around <a>Double</a> to ensure we never generate a
--   <a>Double</a> that becomes a <tt>NaN</tt>, see 'Eq SaneDouble', 'Ord
--   SaneDouble' for details on Sane-ness
newtype SaneDouble
SaneDouble :: Double -> SaneDouble
[unSaneDouble] :: SaneDouble -> Double
instance GHC.Generics.Generic GHC.JS.Syntax.JOp
instance Data.Data.Data GHC.JS.Syntax.JOp
instance GHC.Enum.Enum GHC.JS.Syntax.JOp
instance GHC.Classes.Ord GHC.JS.Syntax.JOp
instance GHC.Classes.Eq GHC.JS.Syntax.JOp
instance GHC.Show.Show GHC.JS.Syntax.JOp
instance GHC.Generics.Generic GHC.JS.Syntax.JUOp
instance Data.Data.Data GHC.JS.Syntax.JUOp
instance GHC.Enum.Enum GHC.JS.Syntax.JUOp
instance GHC.Classes.Ord GHC.JS.Syntax.JUOp
instance GHC.Classes.Eq GHC.JS.Syntax.JUOp
instance GHC.Show.Show GHC.JS.Syntax.JUOp
instance Control.DeepSeq.NFData GHC.JS.Syntax.SaneDouble
instance GHC.Generics.Generic GHC.JS.Syntax.SaneDouble
instance GHC.Num.Num GHC.JS.Syntax.SaneDouble
instance GHC.Real.Fractional GHC.JS.Syntax.SaneDouble
instance Data.Data.Data GHC.JS.Syntax.SaneDouble
instance GHC.Types.Unique.Uniquable GHC.JS.Syntax.Ident
instance GHC.Classes.Eq GHC.JS.Syntax.Ident
instance GHC.Show.Show GHC.JS.Syntax.Ident
instance GHC.Generics.Generic GHC.JS.Syntax.JVal
instance GHC.Classes.Eq GHC.JS.Syntax.JVal
instance GHC.Generics.Generic GHC.JS.Syntax.JExpr
instance GHC.Classes.Eq GHC.JS.Syntax.JExpr
instance GHC.Generics.Generic GHC.JS.Syntax.JStat
instance GHC.Classes.Eq GHC.JS.Syntax.JStat
instance GHC.Base.Semigroup GHC.JS.Syntax.JStat
instance GHC.Base.Monoid GHC.JS.Syntax.JStat
instance Control.DeepSeq.NFData (GHC.JS.Syntax.IdentSupply a)
instance GHC.Base.Functor GHC.JS.Syntax.IdentSupply
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.JS.Syntax.IdentSupply a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.JS.Syntax.IdentSupply a)
instance GHC.Show.Show a => GHC.Show.Show (GHC.JS.Syntax.IdentSupply a)
instance GHC.Classes.Eq GHC.JS.Syntax.SaneDouble
instance GHC.Classes.Ord GHC.JS.Syntax.SaneDouble
instance GHC.Show.Show GHC.JS.Syntax.SaneDouble
instance Control.DeepSeq.NFData GHC.JS.Syntax.JUOp
instance Control.DeepSeq.NFData GHC.JS.Syntax.JOp

module GHC.JS.Transform

-- | Map on every variable ident
mapIdent :: (Ident -> JExpr) -> (JExpr -> JExpr, JStat -> JStat)
mapStatIdent :: (Ident -> JExpr) -> JStat -> JStat
mapExprIdent :: (Ident -> JExpr) -> JExpr -> JExpr
identsS :: JStat -> [Ident]
identsV :: JVal -> [Ident]
identsE :: JExpr -> [Ident]

-- | Given an optional prefix, fills in all free variable names with a
--   supply of names generated by the prefix.
jsSaturate :: JMacro a => Maybe FastString -> a -> a

-- | Compos and ops for generic traversal as defined over the JMacro ADT.
--   
--   Utility class to coerce the ADT into a regular structure.
class JMacro a
jtoGADT :: JMacro a => a -> JMGadt a
jfromGADT :: JMacro a => JMGadt a -> a

-- | Union type to allow regular traversal by compos.
data JMGadt a
[JMGId] :: Ident -> JMGadt Ident
[JMGStat] :: JStat -> JMGadt JStat
[JMGExpr] :: JExpr -> JMGadt JExpr
[JMGVal] :: JVal -> JMGadt JVal
class Compos t
compos :: Compos t => (forall a. a -> m a) -> (forall a b. m (a -> b) -> m a -> m b) -> (forall a. t a -> m (t a)) -> t c -> m (t c)
composOp :: Compos t => (forall a. t a -> t a) -> t b -> t b
composOpM :: (Compos t, Monad m) => (forall a. t a -> m (t a)) -> t b -> m (t b)
composOpM_ :: (Compos t, Monad m) => (forall a. t a -> m ()) -> t b -> m ()
composOpFold :: Compos t => b -> (b -> b -> b) -> (forall a. t a -> b) -> t c -> b
instance GHC.JS.Transform.Compos GHC.JS.Transform.JMGadt
instance GHC.JS.Transform.JMacro GHC.JS.Syntax.Ident
instance GHC.JS.Transform.JMacro GHC.JS.Syntax.JStat
instance GHC.JS.Transform.JMacro GHC.JS.Syntax.JExpr
instance GHC.JS.Transform.JMacro GHC.JS.Syntax.JVal


-- | Pretty-printing JavaScript
module GHC.JS.Ppr

-- | Render a syntax tree as a pretty-printable document (simply showing
--   the resultant doc produces a nice, well formatted String).
renderJs :: (JsToDoc a, JMacro a) => a -> Doc
renderJs' :: (JsToDoc a, JMacro a) => RenderJs -> a -> Doc

-- | Render a syntax tree as a pretty-printable document, using a given
--   prefix to all generated names. Use this with distinct prefixes to
--   ensure distinct generated names between independent calls to
--   render(Prefix)Js.
renderPrefixJs :: (JsToDoc a, JMacro a) => FastString -> a -> Doc
renderPrefixJs' :: (JsToDoc a, JMacro a) => RenderJs -> FastString -> a -> Doc
class JsToDoc a
jsToDocR :: JsToDoc a => RenderJs -> a -> Doc
defaultRenderJs :: RenderJs
data RenderJs
RenderJs :: !RenderJs -> JStat -> Doc -> !RenderJs -> JExpr -> Doc -> !RenderJs -> JVal -> Doc -> !RenderJs -> Ident -> Doc -> RenderJs
[renderJsS] :: RenderJs -> !RenderJs -> JStat -> Doc
[renderJsE] :: RenderJs -> !RenderJs -> JExpr -> Doc
[renderJsV] :: RenderJs -> !RenderJs -> JVal -> Doc
[renderJsI] :: RenderJs -> !RenderJs -> Ident -> Doc
jsToDoc :: JsToDoc a => a -> Doc
pprStringLit :: FastString -> Doc
flattenBlocks :: [JStat] -> [JStat]
braceNest :: Doc -> Doc

-- | Hang with braces:
--   
--   hdr { body }
hangBrace :: Doc -> Doc -> Doc
instance GHC.JS.Ppr.JsToDoc GHC.JS.Syntax.JStat
instance GHC.JS.Ppr.JsToDoc GHC.JS.Syntax.JExpr
instance GHC.JS.Ppr.JsToDoc GHC.JS.Syntax.JVal
instance GHC.JS.Ppr.JsToDoc GHC.JS.Syntax.Ident
instance GHC.JS.Ppr.JsToDoc [GHC.JS.Syntax.JExpr]
instance GHC.JS.Ppr.JsToDoc [GHC.JS.Syntax.JStat]
instance GHC.Utils.Outputable.Outputable GHC.JS.Syntax.JExpr
instance GHC.Utils.Outputable.Outputable GHC.JS.Syntax.JVal


-- | Custom prettyprinter for JS AST uses the JS PPr module for most of the
--   work
module GHC.StgToJS.Printer
pretty :: JStat -> Doc
ghcjsRenderJs :: RenderJs
prettyBlock :: RenderJs -> [JStat] -> Doc


-- | <ul>
--   <li>Domain and PurposeGHC.JS.Make defines helper functions to ease the
--   creation of JavaScript ASTs as defined in <a>Syntax</a>. Its purpose
--   is twofold: make the EDSL more ergonomic to program in, and make
--   errors in the EDSL <i>look</i> obvious because the EDSL is untyped. It
--   is primarily concerned with injecting terms into the domain of the
--   EDSL to construct JS programs in Haskell.</li>
--   <li>StrategyThe strategy for this module comes straight from gentzen;
--   where we have two types of helper functions. Functions which inject
--   terms into the EDSL, and combinator functions which operate on terms
--   in the EDSL to construct new terms in the EDSL. Crucially, missing
--   from this module are corresponding <i>elimination</i> or
--   <i>destructing</i> functions which would project information from the
--   EDSL back to Haskell. See <a>UnitUtils</a> and <a>CoreUtils</a> for
--   such functions.<ul><li><i>Introduction</i> functionsWe define various
--   primitive helpers which <i>introduce</i> terms in the EDSL, for
--   example <a>jVar</a>, <a>jLam</a>, and <a>var</a> and <a>jString</a>.
--   Notice that the type of each of these functions have the domain
--   <tt>isSat a =&gt; a -&gt; ...</tt>; indicating that they each take
--   something that <i>can</i> be injected into the EDSL domain, and the
--   range <a>JExpr</a> or <a>JStat</a>; indicating the corresponding value
--   in the EDSL domain. Similarly this module exports two typeclasses
--   <tt>ToExpr</tt> and <a>ToSat</a>, <tt>ToExpr</tt> injects values as a
--   JS expression into the EDSL. <a>ToSat</a> ensures that terms
--   introduced into the EDSL carry identifier information so terms in the
--   EDSL must have meaning.</li><li><i>Combinator</i> functionsThe rest of
--   the module defines combinators which create terms in the EDSL from
--   terms in the EDSL. Notable examples are <a>|=</a> and <a>||=</a>,
--   <a>|=</a> is sugar for <a>AssignStat</a>, it is a binding form that
--   declares <tt>foo = bar</tt> <i>assuming</i> foo has been already
--   declared. <a>||=</a> is more sugar on top of <a>|=</a>, it is also a
--   binding form that declares the LHS of <a>|=</a> before calling
--   <a>|=</a> to bind a value, bar, to a variable foo. Other common
--   examples are the <a>if_</a> and <a>math_</a> helpers such as
--   <a>math_cos</a>.</li></ul></li>
--   <li>ConsumersThe entire JS backend consumes this module, e.g., the
--   modules in GHC.StgToJS.*.</li>
--   <li>NotationIn this module we use <tt>==&gt;</tt> in docstrings to
--   show the translation from the JS EDSL domain to JS code. For example,
--   <tt>foo ||= bar ==&gt; var foo; foo = bar;</tt> should be read as
--   <tt>foo ||= bar</tt> is in the EDSL domain and results in the JS code
--   <tt>var foo; foo = bar;</tt> when compiled.</li>
--   </ul>
module GHC.JS.Make

-- | Things that can be marshalled into javascript values. Instantiate for
--   any necessary data structures.
class ToJExpr a
toJExpr :: ToJExpr a => a -> JExpr
toJExprFromList :: ToJExpr a => [a] -> JExpr

-- | The <a>ToStat</a> class handles injection of of things into the EDSL
--   as a JS statement. This ends up being polymorphic sugar for JS blocks,
--   see helper function <a>expr2stat</a>. Instantiate for any necessary
--   data structures.
class ToStat a
toStat :: ToStat a => a -> JStat

-- | construct a JS variable reference
var :: FastString -> JExpr

-- | Convert a ShortText to a Javascript String
jString :: FastString -> JExpr

-- | Create a new anonymous function. The result is a <a>JExpr</a>
--   expression. Usage:
--   
--   <pre>
--   jLam $ \x -&gt; jVar x + one_
--   jLam $ \f -&gt; (jLam $ \x -&gt; (f `app` (x `app` x))) `app` (jLam $ \x -&gt; (f `app` (x `app` x)))
--   </pre>
jLam :: ToSat a => a -> JExpr

-- | Introduce a new variable into scope for the duration of the enclosed
--   expression. The result is a block statement. Usage:
--   
--   <pre>
--   jVar $ x y -&gt; mconcat [jVar x ||= one_, jVar y ||= two_, jVar x + jVar y]
--   </pre>
jVar :: ToSat a => a -> JStat

-- | Create a <tt>for</tt> statement
jFor :: (ToJExpr a, ToStat b) => JStat -> a -> JStat -> b -> JStat

-- | Create a 'for in' statement. Usage:
--   
--   <pre>
--   jForIn {expression} $ x -&gt; {block involving x}
--   </pre>
jForIn :: ToSat a => JExpr -> (JExpr -> a) -> JStat

-- | As with "jForIn" but creating a "for each in" statement.
jForEachIn :: ToSat a => JExpr -> (JExpr -> a) -> JStat

-- | As with "jForIn" but creating a "for each in" statement.
jTryCatchFinally :: ToSat a => JStat -> a -> JStat -> JStat

-- | Declare a variable and then Assign the variable to an expression
--   
--   <pre>
--   foo |= expr ==&gt; var foo; foo = expr;
--   </pre>
(||=) :: Ident -> JExpr -> JStat
infixl 2 ||=

-- | Assign a variable to an expression
--   
--   <pre>
--   foo |= expr ==&gt; var foo = expr;
--   </pre>
(|=) :: JExpr -> JExpr -> JStat
infixl 2 |=

-- | JS infix Equality operators
(.==.) :: JExpr -> JExpr -> JExpr
infixl 6 .==.

-- | JS infix Equality operators
(.===.) :: JExpr -> JExpr -> JExpr
infixl 6 .===.

-- | JS infix Equality operators
(.!=.) :: JExpr -> JExpr -> JExpr
infixl 6 .!=.

-- | JS infix Equality operators
(.!==.) :: JExpr -> JExpr -> JExpr
infixl 6 .!==.

-- | return the expression at idx of obj
--   
--   <pre>
--   obj .! idx ==&gt; obj[idx]
--   </pre>
(.!) :: JExpr -> JExpr -> JExpr
infixl 8 .!

-- | JS infix Ord operators
(.>.) :: JExpr -> JExpr -> JExpr
infixl 7 .>.

-- | JS infix Ord operators
(.>=.) :: JExpr -> JExpr -> JExpr
infixl 7 .>=.

-- | JS infix Ord operators
(.<.) :: JExpr -> JExpr -> JExpr
infixl 7 .<.

-- | JS infix Ord operators
(.<=.) :: JExpr -> JExpr -> JExpr
infixl 7 .<=.

-- | JS infix bit shift operators
(.<<.) :: JExpr -> JExpr -> JExpr
infixl 9 .<<.

-- | JS infix bit shift operators
(.>>.) :: JExpr -> JExpr -> JExpr
infixl 9 .>>.

-- | JS infix bit shift operators
(.>>>.) :: JExpr -> JExpr -> JExpr
infixl 9 .>>>.

-- | JS infix bit operators
(.|.) :: JExpr -> JExpr -> JExpr

-- | JS infix bit operators
(.||.) :: JExpr -> JExpr -> JExpr
infixl 8 .||.

-- | JS infix bit operators
(.&&.) :: JExpr -> JExpr -> JExpr
infixl 8 .&&.

-- | JS if-expression
--   
--   <pre>
--   if_ e1 e2 e3 ==&gt; e1 ? e2 : e3
--   </pre>
if_ :: JExpr -> JExpr -> JExpr -> JExpr

-- | if-expression that returns 1 if condition <a>=</a> true, 0 otherwise
--   
--   <pre>
--   if10 e ==&gt; e ? 1 : 0
--   </pre>
if10 :: JExpr -> JExpr

-- | if-expression that returns 0 if condition <a>=</a> true, 1 otherwise
--   
--   <pre>
--   if01 e ==&gt; e ? 0 : 1
--   </pre>
if01 :: JExpr -> JExpr

-- | If-expression which returns statements, see related <a>ifBlockS</a>
--   
--   <pre>
--   if e s1 s2 ==&gt; if(e) { s1 } else { s2 }
--   </pre>
ifS :: JExpr -> JStat -> JStat -> JStat

-- | If-expression which returns blocks
--   
--   <pre>
--   ifBlockS e s1 s2 ==&gt; if(e) { s1 } else { s2 }
--   </pre>
ifBlockS :: JExpr -> [JStat] -> [JStat] -> JStat

-- | A when-statement as syntactic sugar via <a>ifS</a>
--   
--   <pre>
--   jwhenS cond block ==&gt; if(cond) { block } else {  }
--   </pre>
jwhenS :: JExpr -> JStat -> JStat

-- | an expression application, see related <a>appS</a>
--   
--   <pre>
--   app f xs ==&gt; f(xs)
--   </pre>
app :: FastString -> [JExpr] -> JExpr

-- | A statement application, see the expression form <a>app</a>
appS :: FastString -> [JExpr] -> JStat

-- | Return a <a>JExpr</a>
returnS :: JExpr -> JStat

-- | "for" loop with increment at end of body
loop :: JExpr -> (JExpr -> JExpr) -> (JExpr -> JStat) -> JStat

-- | "for" loop with increment at end of body
loopBlockS :: JExpr -> (JExpr -> JExpr) -> (JExpr -> [JStat]) -> JStat

-- | Prefix-increment a <a>JExpr</a>
preIncrS :: JExpr -> JStat

-- | Postfix-increment a <a>JExpr</a>
postIncrS :: JExpr -> JStat

-- | Prefix-decrement a <a>JExpr</a>
preDecrS :: JExpr -> JStat

-- | Postfix-decrement a <a>JExpr</a>
postDecrS :: JExpr -> JStat

-- | Byte indexing of o with a 8-bit offset
off8 :: JExpr -> JExpr -> JExpr

-- | Byte indexing of o with a 16-bit offset
off16 :: JExpr -> JExpr -> JExpr

-- | Byte indexing of o with a 32-bit offset
off32 :: JExpr -> JExpr -> JExpr

-- | Byte indexing of o with a 64-bit offset
off64 :: JExpr -> JExpr -> JExpr

-- | a bit mask to retrieve the lower 8-bits
mask8 :: JExpr -> JExpr

-- | a bit mask to retrieve the lower 16-bits
mask16 :: JExpr -> JExpr

-- | Sign-extend/narrow a 8-bit value
signExtend8 :: JExpr -> JExpr

-- | Sign-extend/narrow a 16-bit value
signExtend16 :: JExpr -> JExpr

-- | Given a <a>JExpr</a>, return the its type.
typeof :: JExpr -> JExpr
returnStack :: JStat
assignAllEqual :: HasDebugCallStack => [JExpr] -> [JExpr] -> JStat
assignAll :: [JExpr] -> [JExpr] -> JStat
assignAllReverseOrder :: [JExpr] -> [JExpr] -> JStat
declAssignAll :: [Ident] -> [JExpr] -> JStat

-- | The empty JS statement
nullStat :: JStat

-- | Select a property <tt>prop</tt>, from and object <tt>obj</tt>
--   
--   <pre>
--   obj .^ prop ==&gt; obj.prop
--   </pre>
(.^) :: JExpr -> FastString -> JExpr
infixl 8 .^
trace :: ToJExpr a => a -> JStat

-- | The empty JS HashMap
jhEmpty :: Map k JExpr

-- | A singleton JS HashMap
jhSingle :: (Ord k, ToJExpr a) => k -> a -> Map k JExpr

-- | insert a key-value pair into a JS HashMap
jhAdd :: (Ord k, ToJExpr a) => k -> a -> Map k JExpr -> Map k JExpr

-- | Construct a JS HashMap from a list of key-value pairs
jhFromList :: [(FastString, JExpr)] -> JVal

-- | The JS literal <a>null</a>
null_ :: JExpr

-- | The JS literal <a>undefined</a>
undefined_ :: JExpr

-- | The JS literal <tt>false</tt>
false_ :: JExpr

-- | The JS literal <tt>true</tt>
true_ :: JExpr

-- | The JS literal 0
zero_ :: JExpr

-- | The JS literal 1
one_ :: JExpr

-- | The JS literal 2
two_ :: JExpr

-- | The JS literal 3
three_ :: JExpr
math_log :: [JExpr] -> JExpr
math_sin :: [JExpr] -> JExpr
math_cos :: [JExpr] -> JExpr
math_tan :: [JExpr] -> JExpr
math_exp :: [JExpr] -> JExpr
math_acos :: [JExpr] -> JExpr
math_asin :: [JExpr] -> JExpr
math_atan :: [JExpr] -> JExpr
math_abs :: [JExpr] -> JExpr
math_pow :: [JExpr] -> JExpr
math_sqrt :: [JExpr] -> JExpr
math_asinh :: [JExpr] -> JExpr
math_acosh :: [JExpr] -> JExpr
math_atanh :: [JExpr] -> JExpr
math_cosh :: [JExpr] -> JExpr
math_sinh :: [JExpr] -> JExpr
math_tanh :: [JExpr] -> JExpr
math_expm1 :: [JExpr] -> JExpr
math_log1p :: [JExpr] -> JExpr
math_fround :: [JExpr] -> JExpr

-- | construct a js declaration with the given identifier
decl :: Ident -> JStat
allocData :: Int -> JExpr
allocClsA :: Int -> JExpr
dataFieldName :: Int -> FastString
dataFieldNames :: [FastString]
instance GHC.JS.Make.ToSat [GHC.JS.Syntax.JStat]
instance GHC.JS.Make.ToSat GHC.JS.Syntax.JStat
instance GHC.JS.Make.ToSat GHC.JS.Syntax.JExpr
instance GHC.JS.Make.ToSat [GHC.JS.Syntax.JExpr]
instance (GHC.JS.Make.ToSat a, b GHC.Types.~ GHC.JS.Syntax.JExpr) => GHC.JS.Make.ToSat (b -> a)
instance GHC.JS.Make.ToStat GHC.JS.Syntax.JStat
instance GHC.JS.Make.ToStat [GHC.JS.Syntax.JStat]
instance GHC.JS.Make.ToStat GHC.JS.Syntax.JExpr
instance GHC.JS.Make.ToStat [GHC.JS.Syntax.JExpr]
instance GHC.JS.Make.ToJExpr a => GHC.JS.Make.ToJExpr [a]
instance GHC.JS.Make.ToJExpr GHC.JS.Syntax.JExpr
instance GHC.JS.Make.ToJExpr ()
instance GHC.JS.Make.ToJExpr GHC.Types.Bool
instance GHC.JS.Make.ToJExpr GHC.JS.Syntax.JVal
instance GHC.JS.Make.ToJExpr a => GHC.JS.Make.ToJExpr (GHC.Types.Unique.Map.UniqMap GHC.Data.FastString.FastString a)
instance GHC.JS.Make.ToJExpr a => GHC.JS.Make.ToJExpr (Data.Map.Internal.Map GHC.Base.String a)
instance GHC.JS.Make.ToJExpr GHC.Types.Double
instance GHC.JS.Make.ToJExpr GHC.Types.Int
instance GHC.JS.Make.ToJExpr GHC.Num.Integer.Integer
instance GHC.JS.Make.ToJExpr GHC.Types.Char
instance GHC.JS.Make.ToJExpr GHC.JS.Syntax.Ident
instance GHC.JS.Make.ToJExpr GHC.Data.FastString.FastString
instance (GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b) => GHC.JS.Make.ToJExpr (a, b)
instance (GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b, GHC.JS.Make.ToJExpr c) => GHC.JS.Make.ToJExpr (a, b, c)
instance (GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b, GHC.JS.Make.ToJExpr c, GHC.JS.Make.ToJExpr d) => GHC.JS.Make.ToJExpr (a, b, c, d)
instance (GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b, GHC.JS.Make.ToJExpr c, GHC.JS.Make.ToJExpr d, GHC.JS.Make.ToJExpr e) => GHC.JS.Make.ToJExpr (a, b, c, d, e)
instance (GHC.JS.Make.ToJExpr a, GHC.JS.Make.ToJExpr b, GHC.JS.Make.ToJExpr c, GHC.JS.Make.ToJExpr d, GHC.JS.Make.ToJExpr e, GHC.JS.Make.ToJExpr f) => GHC.JS.Make.ToJExpr (a, b, c, d, e, f)
instance GHC.Num.Num GHC.JS.Syntax.JExpr
instance GHC.Real.Fractional GHC.JS.Syntax.JExpr

module GHC.StgToJS.Regs

-- | General purpose "registers"
--   
--   The JS backend arbitrarily supports 128 registers
data StgReg
R1 :: StgReg
R2 :: StgReg
R3 :: StgReg
R4 :: StgReg
R5 :: StgReg
R6 :: StgReg
R7 :: StgReg
R8 :: StgReg
R9 :: StgReg
R10 :: StgReg
R11 :: StgReg
R12 :: StgReg
R13 :: StgReg
R14 :: StgReg
R15 :: StgReg
R16 :: StgReg
R17 :: StgReg
R18 :: StgReg
R19 :: StgReg
R20 :: StgReg
R21 :: StgReg
R22 :: StgReg
R23 :: StgReg
R24 :: StgReg
R25 :: StgReg
R26 :: StgReg
R27 :: StgReg
R28 :: StgReg
R29 :: StgReg
R30 :: StgReg
R31 :: StgReg
R32 :: StgReg
R33 :: StgReg
R34 :: StgReg
R35 :: StgReg
R36 :: StgReg
R37 :: StgReg
R38 :: StgReg
R39 :: StgReg
R40 :: StgReg
R41 :: StgReg
R42 :: StgReg
R43 :: StgReg
R44 :: StgReg
R45 :: StgReg
R46 :: StgReg
R47 :: StgReg
R48 :: StgReg
R49 :: StgReg
R50 :: StgReg
R51 :: StgReg
R52 :: StgReg
R53 :: StgReg
R54 :: StgReg
R55 :: StgReg
R56 :: StgReg
R57 :: StgReg
R58 :: StgReg
R59 :: StgReg
R60 :: StgReg
R61 :: StgReg
R62 :: StgReg
R63 :: StgReg
R64 :: StgReg
R65 :: StgReg
R66 :: StgReg
R67 :: StgReg
R68 :: StgReg
R69 :: StgReg
R70 :: StgReg
R71 :: StgReg
R72 :: StgReg
R73 :: StgReg
R74 :: StgReg
R75 :: StgReg
R76 :: StgReg
R77 :: StgReg
R78 :: StgReg
R79 :: StgReg
R80 :: StgReg
R81 :: StgReg
R82 :: StgReg
R83 :: StgReg
R84 :: StgReg
R85 :: StgReg
R86 :: StgReg
R87 :: StgReg
R88 :: StgReg
R89 :: StgReg
R90 :: StgReg
R91 :: StgReg
R92 :: StgReg
R93 :: StgReg
R94 :: StgReg
R95 :: StgReg
R96 :: StgReg
R97 :: StgReg
R98 :: StgReg
R99 :: StgReg
R100 :: StgReg
R101 :: StgReg
R102 :: StgReg
R103 :: StgReg
R104 :: StgReg
R105 :: StgReg
R106 :: StgReg
R107 :: StgReg
R108 :: StgReg
R109 :: StgReg
R110 :: StgReg
R111 :: StgReg
R112 :: StgReg
R113 :: StgReg
R114 :: StgReg
R115 :: StgReg
R116 :: StgReg
R117 :: StgReg
R118 :: StgReg
R119 :: StgReg
R120 :: StgReg
R121 :: StgReg
R122 :: StgReg
R123 :: StgReg
R124 :: StgReg
R125 :: StgReg
R126 :: StgReg
R127 :: StgReg
R128 :: StgReg

-- | Stack registers
data Special
Stack :: Special
Sp :: Special
sp :: JExpr
stack :: JExpr
r1 :: JExpr
r2 :: JExpr
r3 :: JExpr
r4 :: JExpr

-- | List of registers, starting from R1
regsFromR1 :: [StgReg]

-- | List of registers, starting from R2
regsFromR2 :: [StgReg]

-- | List of registers, starting from R1 as JExpr
jsRegsFromR1 :: [JExpr]

-- | List of registers, starting from R2 as JExpr
jsRegsFromR2 :: [JExpr]

-- | Return registers
--   
--   Extra results from foreign calls can be stored here (while first
--   result is directly returned)
data StgRet
Ret1 :: StgRet
Ret2 :: StgRet
Ret3 :: StgRet
Ret4 :: StgRet
Ret5 :: StgRet
Ret6 :: StgRet
Ret7 :: StgRet
Ret8 :: StgRet
Ret9 :: StgRet
Ret10 :: StgRet
jsRegToInt :: StgReg -> Int
intToJSReg :: Int -> StgReg
jsReg :: Int -> JExpr
maxReg :: Int
minReg :: Int
instance GHC.Ix.Ix GHC.StgToJS.Regs.StgReg
instance GHC.Enum.Bounded GHC.StgToJS.Regs.StgReg
instance GHC.Enum.Enum GHC.StgToJS.Regs.StgReg
instance GHC.Show.Show GHC.StgToJS.Regs.StgReg
instance GHC.Classes.Ord GHC.StgToJS.Regs.StgReg
instance GHC.Classes.Eq GHC.StgToJS.Regs.StgReg
instance GHC.Classes.Eq GHC.StgToJS.Regs.Special
instance GHC.Show.Show GHC.StgToJS.Regs.Special
instance GHC.Ix.Ix GHC.StgToJS.Regs.StgRet
instance GHC.Enum.Bounded GHC.StgToJS.Regs.StgRet
instance GHC.Enum.Enum GHC.StgToJS.Regs.StgRet
instance GHC.Show.Show GHC.StgToJS.Regs.StgRet
instance GHC.Classes.Ord GHC.StgToJS.Regs.StgRet
instance GHC.Classes.Eq GHC.StgToJS.Regs.StgRet
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Regs.StgRet
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Regs.Special
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Regs.StgReg


-- | Pretty printing of graphs.
module GHC.Data.Graph.Ppr

-- | Pretty print a graph in a somewhat human readable format.
dumpGraph :: (Outputable k, Outputable color) => Graph k cls color -> SDoc

-- | Pretty print a graph in graphviz .dot format. Conflicts get solid
--   edges. Coalescences get dashed edges.
dotGraph :: (Uniquable k, Outputable k, Outputable cls, Outputable color) => (color -> SDoc) -> Triv k cls color -> Graph k cls color -> SDoc


-- | Basic operations on graphs.
module GHC.Data.Graph.Ops

-- | Add a node to the graph, linking up its edges
addNode :: Uniquable k => k -> Node k cls color -> Graph k cls color -> Graph k cls color

-- | Delete a node and all its edges from the graph.
delNode :: Uniquable k => k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Get a node from the graph, throwing an error if it's not there
getNode :: Uniquable k => Graph k cls color -> k -> Node k cls color

-- | Lookup a node from the graph.
lookupNode :: Uniquable k => Graph k cls color -> k -> Maybe (Node k cls color)

-- | Modify a node in the graph. returns Nothing if the node isn't present.
modNode :: Uniquable k => (Node k cls color -> Node k cls color) -> k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Get the size of the graph, O(n)
size :: Graph k cls color -> Int

-- | Union two graphs together.
union :: Graph k cls color -> Graph k cls color -> Graph k cls color

-- | Add a conflict between nodes to the graph, creating the nodes
--   required. Conflicts are virtual regs which need to be colored
--   differently.
addConflict :: Uniquable k => (k, cls) -> (k, cls) -> Graph k cls color -> Graph k cls color

-- | Delete a conflict edge. k1 -&gt; k2 returns Nothing if the node isn't
--   in the graph
delConflict :: Uniquable k => k -> k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Add some conflicts to the graph, creating nodes if required. All the
--   nodes in the set are taken to conflict with each other.
addConflicts :: Uniquable k => UniqSet k -> (k -> cls) -> Graph k cls color -> Graph k cls color

-- | Add a coalescence edge to the graph, creating nodes if required. It is
--   considered advantageous to assign the same color to nodes in a
--   coalescence.
addCoalesce :: Uniquable k => (k, cls) -> (k, cls) -> Graph k cls color -> Graph k cls color

-- | Delete a coalescence edge (k1 -&gt; k2) from the graph.
delCoalesce :: Uniquable k => k -> k -> Graph k cls color -> Maybe (Graph k cls color)

-- | Add an exclusion to the graph, creating nodes if required. These are
--   extra colors that the node cannot use.
addExclusion :: (Uniquable k, Uniquable color) => k -> (k -> cls) -> color -> Graph k cls color -> Graph k cls color
addExclusions :: (Uniquable k, Uniquable color) => k -> (k -> cls) -> [color] -> Graph k cls color -> Graph k cls color

-- | Add a color preference to the graph, creating nodes if required. The
--   most recently added preference is the most preferred. The algorithm
--   tries to assign a node it's preferred color if possible.
addPreference :: Uniquable k => (k, cls) -> color -> Graph k cls color -> Graph k cls color

-- | Coalesce this pair of nodes unconditionally / aggressively. The
--   resulting node is the one with the least key.
--   
--   returns: Just the pair of keys if the nodes were coalesced the second
--   element of the pair being the least one
--   
--   Nothing if either of the nodes weren't in the graph
coalesceNodes :: (Uniquable k, Ord k, Eq cls) => Bool -> Triv k cls color -> Graph k cls color -> (k, k) -> (Graph k cls color, Maybe (k, k))

-- | Do aggressive coalescing on this graph. returns the new graph and the
--   list of pairs of nodes that got coalesced together. for each pair, the
--   resulting node will have the least key and be second in the pair.
coalesceGraph :: (Uniquable k, Ord k, Eq cls, Outputable k) => Bool -> Triv k cls color -> Graph k cls color -> (Graph k cls color, [(k, k)])

-- | Freeze a node This is for the iterative coalescer. By freezing a node
--   we give up on ever coalescing it. Move all its coalesce edges into the
--   frozen set - and update back edges from other nodes.
freezeNode :: Uniquable k => k -> Graph k cls color -> Graph k cls color

-- | Freeze one node in the graph This if for the iterative coalescer. Look
--   for a move related node of low degree and freeze it.
--   
--   We probably don't need to scan the whole graph looking for the node of
--   absolute lowest degree. Just sample the first few and choose the one
--   with the lowest degree out of those. Also, we don't make any
--   distinction between conflicts of different classes.. this is just a
--   heuristic, after all.
--   
--   IDEA: freezing a node might free it up for Simplify.. would be good to
--   check for triv right here, and add it to a worklist if known
--   triv/non-move nodes.
freezeOneInGraph :: Uniquable k => Graph k cls color -> (Graph k cls color, Bool)

-- | Freeze all the nodes in the graph for debugging the iterative
--   allocator.
freezeAllInGraph :: Uniquable k => Graph k cls color -> Graph k cls color

-- | Find all the nodes in the graph that meet some criteria
scanGraph :: (Node k cls color -> Bool) -> Graph k cls color -> [Node k cls color]

-- | Set the color of a certain node
setColor :: Uniquable k => k -> color -> Graph k cls color -> Graph k cls color

-- | validate the internal structure of a graph all its edges should point
--   to valid nodes If they don't then throw an error
validateGraph :: (Uniquable k, Outputable k, Eq color) => SDoc -> Bool -> Graph k cls color -> Graph k cls color

-- | Slurp out a map of how many nodes had a certain number of conflict
--   neighbours
slurpNodeConflictCount :: Graph k cls color -> UniqFM Int (Int, Int)

module GHC.Data.Graph.Directed
data Graph node
graphFromEdgedVerticesOrd :: Ord key => [Node key payload] -> Graph (Node key payload)
graphFromEdgedVerticesUniq :: Uniquable key => [Node key payload] -> Graph (Node key payload)
graphFromVerticesAndAdjacency :: Ord key => [Node key payload] -> [(key, key)] -> Graph (Node key payload)

-- | Strongly connected component.
data () => SCC vertex

-- | A single vertex that is not in any cycle.
AcyclicSCC :: vertex -> SCC vertex

-- | A maximal set of mutually reachable vertices.
CyclicSCC :: [vertex] -> SCC vertex

-- | Representation for nodes of the Graph.
--   
--   <ul>
--   <li>The <tt>payload</tt> is user data, just carried around in this
--   module</li>
--   <li>The <tt>key</tt> is the node identifier. Key has an Ord instance
--   for performance reasons.</li>
--   <li>The <tt>[key]</tt> are the dependencies of the node; it's ok to
--   have extra keys in the dependencies that are not the key of any Node
--   in the graph</li>
--   </ul>
data Node key payload
DigraphNode :: payload -> key -> [key] -> Node key payload

-- | User data
[node_payload] :: Node key payload -> payload

-- | User defined node id
[node_key] :: Node key payload -> key

-- | Dependencies/successors of the node
[node_dependencies] :: Node key payload -> [key]

-- | The vertices of a strongly connected component.
flattenSCC :: SCC vertex -> [vertex]

-- | The vertices of a list of strongly connected components.
flattenSCCs :: [SCC a] -> [a]
stronglyConnCompG :: Graph node -> [SCC node]
topologicalSortG :: Graph node -> [node]
verticesG :: Graph node -> [node]
edgesG :: Graph node -> [Edge node]
hasVertexG :: Graph node -> node -> Bool
reachableG :: Graph node -> node -> [node]

-- | Given a list of roots return all reachable nodes.
reachablesG :: Graph node -> [node] -> [node]
transposeG :: Graph node -> Graph node

-- | Efficiently construct a map which maps each key to it's set of
--   transitive dependencies. Only works on acyclic input.
allReachable :: Ord key => Graph node -> (node -> key) -> Map key (Set key)

-- | Efficiently construct a map which maps each key to it's set of
--   transitive dependencies. Less efficient than <tt>allReachable</tt>,
--   but works on cyclic input as well.
allReachableCyclic :: Ord key => Graph node -> (node -> key) -> Map key (Set key)
outgoingG :: Graph node -> node -> [node]
emptyG :: Graph node -> Bool

-- | Find a reasonably short cycle a-&gt;b-&gt;c-&gt;a, in a graph The
--   graph might not necessarily be strongly connected.
findCycle :: forall payload key. Ord key => [Node key payload] -> Maybe [payload]
stronglyConnCompFromEdgedVerticesOrd :: Ord key => [Node key payload] -> [SCC payload]
stronglyConnCompFromEdgedVerticesOrdR :: Ord key => [Node key payload] -> [SCC (Node key payload)]
stronglyConnCompFromEdgedVerticesUniq :: Uniquable key => [Node key payload] -> [SCC payload]
stronglyConnCompFromEdgedVerticesUniqR :: Uniquable key => [Node key payload] -> [SCC (Node key payload)]

-- | Edge direction based on DFS Classification
data EdgeType
Forward :: EdgeType
Cross :: EdgeType

-- | Loop back towards the root node. Eg backjumps in loops
Backward :: EdgeType

-- | v -&gt; v
SelfLoop :: EdgeType

-- | Given a start vertex, a way to get successors from a node and a list
--   of (directed) edges classify the types of edges.
classifyEdges :: forall key. Uniquable key => key -> (key -> [key]) -> [(key, key)] -> [((key, key), EdgeType)]
instance GHC.Classes.Ord GHC.Data.Graph.Directed.EdgeType
instance GHC.Classes.Eq GHC.Data.Graph.Directed.EdgeType
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.Directed.Time
instance GHC.Num.Num GHC.Data.Graph.Directed.Time
instance GHC.Classes.Ord GHC.Data.Graph.Directed.Time
instance GHC.Classes.Eq GHC.Data.Graph.Directed.Time
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.Directed.EdgeType
instance GHC.Utils.Outputable.Outputable node => GHC.Utils.Outputable.Outputable (GHC.Data.Graph.Directed.Graph node)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Data.Graph.Directed.Node a b)
instance GHC.Utils.Outputable.Outputable node => GHC.Utils.Outputable.Outputable (GHC.Data.Graph.Directed.Edge node)


-- | Graph Coloring. This is a generic graph coloring library, abstracted
--   over the type of the node keys, nodes and colors.
module GHC.Data.Graph.Color

-- | Try to color a graph with this set of colors. Uses Chaitin's algorithm
--   to color the graph. The graph is scanned for nodes which are deamed
--   'trivially colorable'. These nodes are pushed onto a stack and removed
--   from the graph. Once this process is complete the graph can be colored
--   by removing nodes from the stack (ie in reverse order) and assigning
--   them colors different to their neighbors.
colorGraph :: forall k cls color. (Uniquable k, Uniquable cls, Uniquable color, Eq cls, Ord k, Outputable k, Outputable cls, Outputable color) => Bool -> Int -> UniqFM cls (UniqSet color) -> Triv k cls color -> (Graph k cls color -> k) -> Graph k cls color -> (Graph k cls color, UniqSet k, UniqFM k k)


-- | The assignment of virtual registers to stack slots
module GHC.CmmToAsm.Reg.Linear.StackMap

-- | Identifier for a stack slot.
type StackSlot = Int
data StackMap
StackMap :: !Int -> UniqFM Unique StackSlot -> StackMap

-- | The slots that are still available to be allocated.
[stackMapNextFreeSlot] :: StackMap -> !Int

-- | Assignment of vregs to stack slots.
[stackMapAssignment] :: StackMap -> UniqFM Unique StackSlot

-- | An empty stack map, with all slots available.
emptyStackMap :: StackMap

-- | If this vreg unique already has a stack assignment then return the
--   slot number, otherwise allocate a new slot, and update the map.
getStackSlotFor :: StackMap -> Unique -> (StackMap, Int)

-- | Return the number of stack slots that were allocated
getStackUse :: StackMap -> Int

module GHC.Types.Basic
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight
pickLR :: LeftOrRight -> (a, a) -> a

-- | A *one-index* constructor tag
--   
--   Type of the tags associated with each constructor possibility or
--   superclass selector
type ConTag = Int

-- | A *zero-indexed* constructor tag
type ConTagZ = Int

-- | Tags are allocated from here for real constructors or for superclass
--   selectors
fIRST_TAG :: ConTag

-- | The number of value arguments that can be applied to a value before it
--   does "real work". So: fib 100 has arity 0 x -&gt; fib x has arity 1
--   See also Note [Definition of arity] in <a>GHC.Core.Opt.Arity</a>
type Arity = Int

-- | Representation Arity
--   
--   The number of represented arguments that can be applied to a value
--   before it does "real work". So: fib 100 has representation arity 0 x
--   -&gt; fib x has representation arity 1 (# x, y #) -&gt; fib (x + y)
--   has representation arity 2
type RepArity = Int

-- | The number of arguments that a join point takes. Unlike the arity of a
--   function, this is a purely syntactic property and is fixed when the
--   join point is created (or converted from a value). Both type and value
--   arguments are counted.
type JoinArity = Int

-- | FullArgCount is the number of type or value arguments in an
--   application, or the number of type or value binders in a lambda. Note:
--   it includes both type and value arguments!
type FullArgCount = Int

-- | A power-of-two alignment
data Alignment
mkAlignment :: Int -> Alignment
alignmentOf :: Int -> Alignment
alignmentBytes :: Alignment -> Int
data () => PromotionFlag
NotPromoted :: PromotionFlag
IsPromoted :: PromotionFlag
isPromoted :: PromotionFlag -> Bool
data FunctionOrData
IsFunction :: FunctionOrData
IsData :: FunctionOrData

-- | Recursivity Flag
data RecFlag
Recursive :: RecFlag
NonRecursive :: RecFlag
isRec :: RecFlag -> Bool
isNonRec :: RecFlag -> Bool
boolToRecFlag :: Bool -> RecFlag
data Origin
FromSource :: Origin
Generated :: Origin
isGenerated :: Origin -> Bool
type RuleName = FastString
pprRuleName :: RuleName -> SDoc
data TopLevelFlag
TopLevel :: TopLevelFlag
NotTopLevel :: TopLevelFlag
isTopLevel :: TopLevelFlag -> Bool
isNotTopLevel :: TopLevelFlag -> Bool

-- | The semantics allowed for overlapping instances for a particular
--   instance. See Note [Safe Haskell isSafeOverlap] in GHC.Core.InstEnv
--   for a explanation of the <a>isSafeOverlap</a> field.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# OVERLAPPABLE'</tt>
--   or <tt>'{-# OVERLAPPING'</tt> or <tt>'{-# OVERLAPS'</tt> or <tt>'{-#
--   INCOHERENT'</tt>, <a>AnnClose</a> <tt>`#-}`</tt>,</li>
--   </ul>
data OverlapFlag
OverlapFlag :: OverlapMode -> Bool -> OverlapFlag
[overlapMode] :: OverlapFlag -> OverlapMode
[isSafeOverlap] :: OverlapFlag -> Bool
data OverlapMode

-- | This instance must not overlap another <a>NoOverlap</a> instance.
--   However, it may be overlapped by <a>Overlapping</a> instances, and it
--   may overlap <a>Overlappable</a> instances.
NoOverlap :: SourceText -> OverlapMode

-- | Silently ignore this instance if you find a more specific one that
--   matches the constraint you are trying to resolve
--   
--   Example: constraint (Foo [Int]) instance Foo [Int] instance {-#
--   OVERLAPPABLE #-} Foo [a]
--   
--   Since the second instance has the Overlappable flag, the first
--   instance will be chosen (otherwise its ambiguous which to choose)
Overlappable :: SourceText -> OverlapMode

-- | Silently ignore any more general instances that may be used to solve
--   the constraint.
--   
--   Example: constraint (Foo [Int]) instance {-# OVERLAPPING #-} Foo [Int]
--   instance Foo [a]
--   
--   Since the first instance has the Overlapping flag, the second---more
--   general---instance will be ignored (otherwise it is ambiguous which to
--   choose)
Overlapping :: SourceText -> OverlapMode

-- | Equivalent to having both <a>Overlapping</a> and <a>Overlappable</a>
--   flags.
Overlaps :: SourceText -> OverlapMode

-- | Behave like Overlappable and Overlapping, and in addition pick an
--   arbitrary one if there are multiple matching candidates, and don't
--   worry about later instantiation
--   
--   Example: constraint (Foo [b]) instance {-# INCOHERENT -} Foo [Int]
--   instance Foo [a] Without the Incoherent flag, we'd complain that
--   instantiating <tt>b</tt> would change which instance was chosen. See
--   also Note [Incoherent instances] in <a>GHC.Core.InstEnv</a>
Incoherent :: SourceText -> OverlapMode
setOverlapModeMaybe :: OverlapFlag -> Maybe OverlapMode -> OverlapFlag
hasOverlappingFlag :: OverlapMode -> Bool
hasOverlappableFlag :: OverlapMode -> Bool
hasIncoherentFlag :: OverlapMode -> Bool
data Boxity
Boxed :: Boxity
Unboxed :: Boxity
isBoxed :: Boxity -> Bool

-- | Should an argument be passed evaluated *and* tagged.
data CbvMark
MarkedCbv :: CbvMark
NotMarkedCbv :: CbvMark
isMarkedCbv :: CbvMark -> Bool

-- | A general-purpose pretty-printing precedence type.
newtype PprPrec
PprPrec :: Int -> PprPrec
topPrec :: PprPrec
sigPrec :: PprPrec
opPrec :: PprPrec
funPrec :: PprPrec
starPrec :: PprPrec
appPrec :: PprPrec
maxPrec :: PprPrec
maybeParen :: PprPrec -> PprPrec -> SDoc -> SDoc
data TupleSort
BoxedTuple :: TupleSort
UnboxedTuple :: TupleSort
ConstraintTuple :: TupleSort
tupleSortBoxity :: TupleSort -> Boxity
boxityTupleSort :: Boxity -> TupleSort
tupleParens :: TupleSort -> SDoc -> SDoc

-- | Are we dealing with an unboxed tuple or an unboxed sum?
--   
--   Used when validity checking, see <tt>check_ubx_tuple_or_sum</tt>.
data UnboxedTupleOrSum
UnboxedTupleType :: UnboxedTupleOrSum
UnboxedSumType :: UnboxedTupleOrSum
unboxedTupleOrSumExtension :: UnboxedTupleOrSum -> Extension
sumParens :: SDoc -> SDoc

-- | Pretty print an alternative in an unboxed sum e.g. "| a | |".
pprAlternative :: (a -> SDoc) -> a -> ConTag -> Arity -> SDoc

-- | If the <tt>Id</tt> is a lambda-bound variable then it may have
--   lambda-bound variable info. Sometimes we know whether the lambda
--   binding this variable is a "one-shot" lambda; that is, whether it is
--   applied at most once.
--   
--   This information may be useful in optimisation, as computations may
--   safely be floated inside such a lambda without risk of duplicating
--   work.
--   
--   See also Note [OneShotInfo overview] above.
data OneShotInfo

-- | No information
NoOneShotInfo :: OneShotInfo

-- | The lambda is applied at most once.
OneShotLam :: OneShotInfo

-- | It is always safe to assume that an <tt>Id</tt> has no lambda-bound
--   variable information
noOneShotInfo :: OneShotInfo
hasNoOneShotInfo :: OneShotInfo -> Bool
isOneShotInfo :: OneShotInfo -> Bool
bestOneShot :: OneShotInfo -> OneShotInfo -> OneShotInfo
worstOneShot :: OneShotInfo -> OneShotInfo -> OneShotInfo

-- | identifier Occurrence Information
data OccInfo

-- | There are many occurrences, or unknown occurrences
ManyOccs :: !TailCallInfo -> OccInfo
[occ_tail] :: OccInfo -> !TailCallInfo

-- | Marks unused variables. Sometimes useful for lambda and case-bound
--   variables.
IAmDead :: OccInfo

-- | Occurs exactly once (per branch), not inside a rule
OneOcc :: !InsideLam -> {-# UNPACK #-} !BranchCount -> !InterestingCxt -> !TailCallInfo -> OccInfo
[occ_in_lam] :: OccInfo -> !InsideLam
[occ_n_br] :: OccInfo -> {-# UNPACK #-} !BranchCount
[occ_int_cxt] :: OccInfo -> !InterestingCxt
[occ_tail] :: OccInfo -> !TailCallInfo

-- | This identifier breaks a loop of mutually recursive functions. The
--   field marks whether it is only a loop breaker due to a reference in a
--   rule
IAmALoopBreaker :: !RulesOnly -> !TailCallInfo -> OccInfo
[occ_rules_only] :: OccInfo -> !RulesOnly
[occ_tail] :: OccInfo -> !TailCallInfo
noOccInfo :: OccInfo
seqOccInfo :: OccInfo -> ()
zapFragileOcc :: OccInfo -> OccInfo
isOneOcc :: OccInfo -> Bool
isDeadOcc :: OccInfo -> Bool
isStrongLoopBreaker :: OccInfo -> Bool
isWeakLoopBreaker :: OccInfo -> Bool
isManyOccs :: OccInfo -> Bool
isNoOccInfo :: OccInfo -> Bool
strongLoopBreaker :: OccInfo
weakLoopBreaker :: OccInfo

-- | Inside Lambda
data InsideLam

-- | Occurs inside a non-linear lambda Substituting a redex for this
--   occurrence is dangerous because it might duplicate work.
IsInsideLam :: InsideLam
NotInsideLam :: InsideLam
type BranchCount = Int
oneBranch :: BranchCount

-- | Interesting Context
data InterestingCxt

-- | Function: is applied Data value: scrutinised by a case with at least
--   one non-DEFAULT branch
IsInteresting :: InterestingCxt
NotInteresting :: InterestingCxt
data TailCallInfo
AlwaysTailCalled :: JoinArity -> TailCallInfo
NoTailCallInfo :: TailCallInfo
tailCallInfo :: OccInfo -> TailCallInfo
zapOccTailCallInfo :: OccInfo -> OccInfo
isAlwaysTailCalled :: OccInfo -> Bool

-- | Embedding Projection pair
data EP a
EP :: a -> a -> EP a
[fromEP] :: EP a -> a
[toEP] :: EP a -> a

-- | Default Method Specification
data DefMethSpec ty
VanillaDM :: DefMethSpec ty
GenericDM :: ty -> DefMethSpec ty
data SwapFlag
NotSwapped :: SwapFlag
IsSwapped :: SwapFlag
flipSwap :: SwapFlag -> SwapFlag
unSwap :: SwapFlag -> (a -> a -> b) -> a -> a -> b
isSwapped :: SwapFlag -> Bool
data CompilerPhase
InitialPhase :: CompilerPhase
Phase :: PhaseNum -> CompilerPhase
FinalPhase :: CompilerPhase

-- | Phase Number
type PhaseNum = Int
beginPhase :: Activation -> CompilerPhase
nextPhase :: CompilerPhase -> CompilerPhase
laterPhase :: CompilerPhase -> CompilerPhase -> CompilerPhase
data Activation
AlwaysActive :: Activation
ActiveBefore :: SourceText -> PhaseNum -> Activation
ActiveAfter :: SourceText -> PhaseNum -> Activation
FinalActive :: Activation
NeverActive :: Activation
isActive :: CompilerPhase -> Activation -> Bool
competesWith :: Activation -> Activation -> Bool
isNeverActive :: Activation -> Bool
isAlwaysActive :: Activation -> Bool
activeInFinalPhase :: Activation -> Bool
activateAfterInitial :: Activation
activateDuringFinal :: Activation
activeAfter :: CompilerPhase -> Activation

-- | Rule Match Information
data RuleMatchInfo
ConLike :: RuleMatchInfo
FunLike :: RuleMatchInfo
isConLike :: RuleMatchInfo -> Bool
isFunLike :: RuleMatchInfo -> Bool

-- | Inline Specification
data InlineSpec
Inline :: SourceText -> InlineSpec
Inlinable :: SourceText -> InlineSpec
NoInline :: SourceText -> InlineSpec
Opaque :: SourceText -> InlineSpec
NoUserInlinePrag :: InlineSpec
noUserInlineSpec :: InlineSpec -> Bool
data InlinePragma
InlinePragma :: SourceText -> InlineSpec -> Maybe Arity -> Activation -> RuleMatchInfo -> InlinePragma
[inl_src] :: InlinePragma -> SourceText
[inl_inline] :: InlinePragma -> InlineSpec
[inl_sat] :: InlinePragma -> Maybe Arity
[inl_act] :: InlinePragma -> Activation
[inl_rule] :: InlinePragma -> RuleMatchInfo
defaultInlinePragma :: InlinePragma
alwaysInlinePragma :: InlinePragma
neverInlinePragma :: InlinePragma
dfunInlinePragma :: InlinePragma
isDefaultInlinePragma :: InlinePragma -> Bool
isInlinePragma :: InlinePragma -> Bool
isInlinablePragma :: InlinePragma -> Bool
isNoInlinePragma :: InlinePragma -> Bool
isOpaquePragma :: InlinePragma -> Bool
isAnyInlinePragma :: InlinePragma -> Bool
alwaysInlineConLikePragma :: InlinePragma
inlinePragmaSource :: InlinePragma -> SourceText

-- | Outputs string for pragma name for any of
--   INLINE<i>INLINABLE</i>NOINLINE. This differs from the Outputable
--   instance for the InlineSpec type where the pragma name string as well
--   as the accompanying SourceText (if any) is printed.
inlinePragmaName :: InlineSpec -> SDoc
inlineSpecSource :: InlineSpec -> SourceText
inlinePragmaSpec :: InlinePragma -> InlineSpec
inlinePragmaSat :: InlinePragma -> Maybe Arity
inlinePragmaActivation :: InlinePragma -> Activation
inlinePragmaRuleMatchInfo :: InlinePragma -> RuleMatchInfo
setInlinePragmaActivation :: InlinePragma -> Activation -> InlinePragma
setInlinePragmaRuleMatchInfo :: InlinePragma -> RuleMatchInfo -> InlinePragma

-- | Pretty-print without displaying the user-specified <a>InlineSpec</a>.
pprInline :: InlinePragma -> SDoc

-- | Pretty-print including the user-specified <a>InlineSpec</a>.
pprInlineDebug :: InlinePragma -> SDoc
data UnfoldingSource
VanillaSrc :: UnfoldingSource
StableUserSrc :: UnfoldingSource
StableSystemSrc :: UnfoldingSource
CompulsorySrc :: UnfoldingSource
isStableSource :: UnfoldingSource -> Bool
isStableUserSource :: UnfoldingSource -> Bool
isStableSystemSource :: UnfoldingSource -> Bool
isCompulsorySource :: UnfoldingSource -> Bool
data SuccessFlag
Succeeded :: SuccessFlag
Failed :: SuccessFlag
succeeded :: SuccessFlag -> Bool
failed :: SuccessFlag -> Bool
successIf :: Bool -> SuccessFlag

-- | An integer or infinity
data IntWithInf

-- | A representation of infinity
infinity :: IntWithInf

-- | Turn a positive number into an <a>IntWithInf</a>, where 0 represents
--   infinity
treatZeroAsInf :: Int -> IntWithInf

-- | Subtract an <a>IntWithInf</a> from an <a>IntWithInf</a>
subWithInf :: IntWithInf -> Int -> IntWithInf

-- | Inject any integer into an <a>IntWithInf</a>
mkIntWithInf :: Int -> IntWithInf
intGtLimit :: Int -> IntWithInf -> Bool

-- | Flag to see whether we're type-checking terms or kind-checking types
data TypeOrKind
TypeLevel :: TypeOrKind
KindLevel :: TypeOrKind
isTypeLevel :: TypeOrKind -> Bool
isKindLevel :: TypeOrKind -> Bool
data Levity
Lifted :: Levity
Unlifted :: Levity
mightBeLifted :: Maybe Levity -> Bool
mightBeUnlifted :: Maybe Levity -> Bool
data TypeOrConstraint
TypeLike :: TypeOrConstraint
ConstraintLike :: TypeOrConstraint

-- | Specify whether to default type variables of kind
--   <tt>RuntimeRep</tt><i><a>Levity</a></i><tt>Multiplicity</tt>.
data NonStandardDefaultingStrategy

-- | Default type variables of the given kinds:
--   
--   <ul>
--   <li>default <tt>RuntimeRep</tt> variables to <tt>LiftedRep</tt></li>
--   <li>default <a>Levity</a> variables to <a>Lifted</a></li>
--   <li>default <tt>Multiplicity</tt> variables to <tt>Many</tt></li>
--   </ul>
DefaultNonStandardTyVars :: NonStandardDefaultingStrategy

-- | Try not to default type variables of the kinds
--   <tt>RuntimeRep</tt><i><a>Levity</a></i><tt>Multiplicity</tt>.
--   
--   Note that these might get defaulted anyway, if they are kind variables
--   and `-XNoPolyKinds` is enabled.
TryNotToDefaultNonStandardTyVars :: NonStandardDefaultingStrategy

-- | Specify whether to default kind variables, and type variables of kind
--   <tt>RuntimeRep</tt><i><a>Levity</a></i><tt>Multiplicity</tt>.
data DefaultingStrategy

-- | Default kind variables:
--   
--   <ul>
--   <li>default kind variables of kind <tt>Type</tt> to
--   <tt>Type</tt>,</li>
--   <li>default
--   <tt>RuntimeRep</tt><i><a>Levity</a></i><tt>Multiplicity</tt> kind
--   variables to <tt>LiftedRep</tt><i><a>Lifted</a></i><tt>Many</tt>,
--   respectively.</li>
--   </ul>
--   
--   When this strategy is used, it means that we have determined that the
--   variables we are considering defaulting are all kind variables.
--   
--   Usually, we pass this option when -XNoPolyKinds is enabled.
DefaultKindVars :: DefaultingStrategy

-- | Default (or don't default) non-standard variables, of kinds
--   <tt>RuntimeRep</tt>, <a>Levity</a> and <tt>Multiplicity</tt>.
NonStandardDefaulting :: NonStandardDefaultingStrategy -> DefaultingStrategy
defaultNonStandardTyVars :: DefaultingStrategy -> Bool
data () => ForeignSrcLang
LangC :: ForeignSrcLang
LangCxx :: ForeignSrcLang
LangObjc :: ForeignSrcLang
LangObjcxx :: ForeignSrcLang
LangAsm :: ForeignSrcLang
LangJs :: ForeignSrcLang
RawObject :: ForeignSrcLang
instance Data.Data.Data GHC.Types.Basic.LeftOrRight
instance GHC.Classes.Eq GHC.Types.Basic.LeftOrRight
instance GHC.Classes.Ord GHC.Types.Basic.Alignment
instance GHC.Classes.Eq GHC.Types.Basic.Alignment
instance GHC.Classes.Eq GHC.Types.Basic.OneShotInfo
instance Data.Data.Data GHC.Types.Basic.FunctionOrData
instance GHC.Classes.Ord GHC.Types.Basic.FunctionOrData
instance GHC.Classes.Eq GHC.Types.Basic.FunctionOrData
instance Data.Data.Data GHC.Types.Basic.TopLevelFlag
instance GHC.Classes.Eq GHC.Types.Basic.CbvMark
instance Data.Data.Data GHC.Types.Basic.RecFlag
instance GHC.Classes.Eq GHC.Types.Basic.RecFlag
instance Data.Data.Data GHC.Types.Basic.Origin
instance GHC.Classes.Eq GHC.Types.Basic.Origin
instance Data.Data.Data GHC.Types.Basic.OverlapMode
instance GHC.Classes.Eq GHC.Types.Basic.OverlapMode
instance Data.Data.Data GHC.Types.Basic.OverlapFlag
instance GHC.Classes.Eq GHC.Types.Basic.OverlapFlag
instance GHC.Show.Show GHC.Types.Basic.PprPrec
instance GHC.Classes.Ord GHC.Types.Basic.PprPrec
instance GHC.Classes.Eq GHC.Types.Basic.PprPrec
instance Data.Data.Data GHC.Types.Basic.TupleSort
instance GHC.Classes.Eq GHC.Types.Basic.TupleSort
instance GHC.Classes.Eq GHC.Types.Basic.UnboxedTupleOrSum
instance GHC.Classes.Eq GHC.Types.Basic.InterestingCxt
instance GHC.Classes.Eq GHC.Types.Basic.InsideLam
instance GHC.Classes.Eq GHC.Types.Basic.TailCallInfo
instance GHC.Classes.Eq GHC.Types.Basic.OccInfo
instance GHC.Classes.Eq GHC.Types.Basic.CompilerPhase
instance Data.Data.Data GHC.Types.Basic.Activation
instance GHC.Classes.Eq GHC.Types.Basic.Activation
instance GHC.Show.Show GHC.Types.Basic.RuleMatchInfo
instance Data.Data.Data GHC.Types.Basic.RuleMatchInfo
instance GHC.Classes.Eq GHC.Types.Basic.RuleMatchInfo
instance GHC.Show.Show GHC.Types.Basic.InlineSpec
instance Data.Data.Data GHC.Types.Basic.InlineSpec
instance GHC.Classes.Eq GHC.Types.Basic.InlineSpec
instance Data.Data.Data GHC.Types.Basic.InlinePragma
instance GHC.Classes.Eq GHC.Types.Basic.InlinePragma
instance GHC.Classes.Eq GHC.Types.Basic.IntWithInf
instance GHC.Classes.Eq GHC.Types.Basic.TypeOrKind
instance GHC.Classes.Eq GHC.Types.Basic.Levity
instance Data.Data.Data GHC.Types.Basic.TypeOrConstraint
instance GHC.Classes.Ord GHC.Types.Basic.TypeOrConstraint
instance GHC.Classes.Eq GHC.Types.Basic.TypeOrConstraint
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.DefaultingStrategy
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.NonStandardDefaultingStrategy
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Levity
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TypeOrKind
instance GHC.Classes.Ord GHC.Types.Basic.IntWithInf
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.IntWithInf
instance GHC.Num.Num GHC.Types.Basic.IntWithInf
instance GHC.Utils.Binary.Binary GHC.Types.Basic.UnfoldingSource
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.UnfoldingSource
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.InlinePragma
instance GHC.Utils.Binary.Binary GHC.Types.Basic.InlinePragma
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.InlineSpec
instance GHC.Utils.Binary.Binary GHC.Types.Basic.InlineSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.RuleMatchInfo
instance GHC.Utils.Binary.Binary GHC.Types.Basic.RuleMatchInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Activation
instance GHC.Utils.Binary.Binary GHC.Types.Basic.Activation
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.CompilerPhase
instance GHC.Base.Semigroup GHC.Types.Basic.SuccessFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.SuccessFlag
instance GHC.Utils.Outputable.Outputable (GHC.Types.Basic.DefMethSpec ty)
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OccInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TailCallInfo
instance GHC.Base.Semigroup GHC.Types.Basic.InsideLam
instance GHC.Base.Monoid GHC.Types.Basic.InsideLam
instance GHC.Base.Semigroup GHC.Types.Basic.InterestingCxt
instance GHC.Base.Monoid GHC.Types.Basic.InterestingCxt
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.UnboxedTupleOrSum
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TupleSort
instance GHC.Utils.Binary.Binary GHC.Types.Basic.TupleSort
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OverlapFlag
instance GHC.Utils.Binary.Binary GHC.Types.Basic.OverlapFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OverlapMode
instance GHC.Utils.Binary.Binary GHC.Types.Basic.OverlapMode
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Origin
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.RecFlag
instance GHC.Utils.Binary.Binary GHC.Types.Basic.RecFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.CbvMark
instance GHC.Utils.Binary.Binary GHC.Types.Basic.CbvMark
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.TopLevelFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.FunctionOrData
instance GHC.Utils.Binary.Binary GHC.Types.Basic.FunctionOrData
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.SwapFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.OneShotInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.Alignment
instance GHC.Utils.Outputable.OutputableP env GHC.Types.Basic.Alignment
instance GHC.Utils.Outputable.Outputable GHC.Types.Basic.LeftOrRight
instance GHC.Utils.Binary.Binary GHC.Types.Basic.LeftOrRight
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Type.PromotionFlag
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Type.PromotionFlag
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.Boxity
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Basic.Boxity


-- | Platform description
module GHC.Platform

-- | Platform description
--   
--   This is used to describe platforms so that we can generate code for
--   them.
data Platform
Platform :: !ArchOS -> !PlatformWordSize -> !ByteOrder -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Maybe PlatformConstants -> Platform

-- | Architecture and OS
[platformArchOS] :: Platform -> !ArchOS

-- | Word size
[platformWordSize] :: Platform -> !PlatformWordSize

-- | Byte order (endianness)
[platformByteOrder] :: Platform -> !ByteOrder
[platformUnregisterised] :: Platform -> !Bool
[platformHasGnuNonexecStack] :: Platform -> !Bool
[platformHasIdentDirective] :: Platform -> !Bool
[platformHasSubsectionsViaSymbols] :: Platform -> !Bool
[platformIsCrossCompiling] :: Platform -> !Bool

-- | Symbols need underscore prefix
[platformLeadingUnderscore] :: Platform -> !Bool

-- | Determines whether we will be compiling info tables that reside just
--   before the entry code, or with an indirection to the entry code. See
--   TABLES_NEXT_TO_CODE in rts<i>include</i>rts<i>storage</i>InfoTables.h.
[platformTablesNextToCode] :: Platform -> !Bool

-- | Some platforms require that we explicitly link against <tt>libm</tt>
--   if any math-y things are used (which we assume to include all
--   programs). See #14022.
[platformHasLibm] :: Platform -> !Bool

-- | Constants such as structure offsets, type sizes, etc.
[platform_constants] :: Platform -> !Maybe PlatformConstants
data PlatformWordSize

-- | A 32-bit platform
PW4 :: PlatformWordSize

-- | A 64-bit platform
PW8 :: PlatformWordSize

-- | Platform architecture
platformArch :: Platform -> Arch

-- | Platform OS
platformOS :: Platform -> OS

-- | Platform architecture and OS.
data () => ArchOS
ArchOS :: Arch -> OS -> ArchOS
[archOS_arch] :: ArchOS -> Arch
[archOS_OS] :: ArchOS -> OS

-- | Architectures
--   
--   TODO: It might be nice to extend these constructors with information
--   about what instruction set extensions an architecture might support.
data () => Arch
ArchUnknown :: Arch
ArchX86 :: Arch
ArchX86_64 :: Arch
ArchPPC :: Arch
ArchPPC_64 :: PPC_64ABI -> Arch
ArchS390X :: Arch
ArchARM :: ArmISA -> [ArmISAExt] -> ArmABI -> Arch
ArchAArch64 :: Arch
ArchAlpha :: Arch
ArchMipseb :: Arch
ArchMipsel :: Arch
ArchRISCV64 :: Arch
ArchLoongArch64 :: Arch
ArchJavaScript :: Arch
ArchWasm32 :: Arch

-- | Operating systems.
--   
--   Using OSUnknown to generate code should produce a sensible default,
--   but no promises.
data () => OS
OSUnknown :: OS
OSLinux :: OS
OSDarwin :: OS
OSSolaris2 :: OS
OSMinGW32 :: OS
OSFreeBSD :: OS
OSDragonFly :: OS
OSOpenBSD :: OS
OSNetBSD :: OS
OSKFreeBSD :: OS
OSHaiku :: OS
OSQNXNTO :: OS
OSAIX :: OS
OSHurd :: OS
OSWasi :: OS
OSGhcjs :: OS

-- | ARM Instruction Set Architecture
data () => ArmISA
ARMv5 :: ArmISA
ARMv6 :: ArmISA
ARMv7 :: ArmISA

-- | ARM extensions
data () => ArmISAExt
VFPv2 :: ArmISAExt
VFPv3 :: ArmISAExt
VFPv3D16 :: ArmISAExt
NEON :: ArmISAExt
IWMMX2 :: ArmISAExt

-- | ARM ABI
data () => ArmABI
SOFT :: ArmABI
SOFTFP :: ArmABI
HARD :: ArmABI

-- | PowerPC 64-bit ABI
data () => PPC_64ABI

-- | PowerPC64
ELF_V1 :: PPC_64ABI

-- | PowerPC64 LE
ELF_V2 :: PPC_64ABI

-- | Byte ordering.
data () => ByteOrder

-- | most-significant-byte occurs in lowest address.
BigEndian :: ByteOrder

-- | least-significant-byte occurs in lowest address.
LittleEndian :: ByteOrder

-- | This predicate tells us whether the platform is 32-bit.
target32Bit :: Platform -> Bool
isARM :: Arch -> Bool

-- | This predicate tells us whether the OS supports ELF-like shared
--   libraries.
osElfTarget :: OS -> Bool

-- | This predicate tells us whether the OS support Mach-O shared
--   libraries.
osMachOTarget :: OS -> Bool
osSubsectionsViaSymbols :: OS -> Bool
platformUsesFrameworks :: Platform -> Bool
platformWordSizeInBytes :: Platform -> Int
platformWordSizeInBits :: Platform -> Int

-- | Minimum representable Int value for the given platform
platformMinInt :: Platform -> Integer

-- | Maximum representable Int value for the given platform
platformMaxInt :: Platform -> Integer

-- | Maximum representable Word value for the given platform
platformMaxWord :: Platform -> Integer

-- | Test if the given Integer is representable with a platform Int
platformInIntRange :: Platform -> Integer -> Bool

-- | Test if the given Integer is representable with a platform Word
platformInWordRange :: Platform -> Integer -> Bool

-- | For some architectures the C calling convention is that any integer
--   shorter than 64 bits is replaced by its 64 bits representation using
--   sign or zero extension.
platformCConvNeedsExtension :: Platform -> Bool

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> Bool -> Bool -> String -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String

-- | x86 SSE instructions
data SseVersion
SSE1 :: SseVersion
SSE2 :: SseVersion
SSE3 :: SseVersion
SSE4 :: SseVersion
SSE42 :: SseVersion

-- | x86 BMI (bit manipulation) instructions
data BmiVersion
BMI1 :: BmiVersion
BMI2 :: BmiVersion
wordAlignment :: Platform -> Alignment
isSseEnabled :: Platform -> Bool
isSse2Enabled :: Platform -> Bool
data PlatformConstants
PlatformConstants :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !Integer -> !Integer -> !Integer -> !Bool -> PlatformConstants
[pc_CONTROL_GROUP_CONST_291] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_STD_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_PROF_HDR_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCK_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BLOCKS_PER_MBLOCK] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TICKY_BIN_COUNT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR7] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR8] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR9] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rR10] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rF6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rD6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rXMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rYMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM2] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM3] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM4] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM5] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rZMM6] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rL1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rSpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpLim] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCCCS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentTSO] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rCurrentNursery] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgRegTable_rHpAlloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgEagerBlackholeInfo] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCEnter1] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_stgGCFun] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_Capability_r] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_start] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_free] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_blocks] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_bdescr_flags] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_CostCentreStack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_mem_alloc] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_CostCentreStack_scc_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgHeader_ldvw] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSMPThunkHeader] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgEntCounter_allocd] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_registeredp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_link] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgEntCounter_entry_count] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgUpdateFrame_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgMutArrPtrs_size] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgSmallMutArrPtrs_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgSmallMutArrPtrs_ptrs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgArrBytes_NoHdr] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgArrBytes_bytes] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_alloc_limit] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_cccs] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgTSO_stackobj] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_sp] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgStack_stack] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgUpdateFrame_updatee] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraFwd_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_SIZEOF_StgFunInfoExtraRev] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_OFFSET_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_REP_StgFunInfoExtraRev_arity] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_SELECTEE_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_SPEC_AP_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_PAYLOAD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_INTLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MIN_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_CHARLIKE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MUT_ARR_PTRS_CARD_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Vanilla_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Float_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Double_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_XMM_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_MAX_Real_Long_REG] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_C_STACK_BYTES] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_RESERVED_STACK_WORDS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_AP_STACK_SPLIM] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_WORD_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CINT_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_CLONG_LONG_SIZE] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_BITMAP_BITS_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_TAG_BITS] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_LDV_SHIFT] :: PlatformConstants -> {-# UNPACK #-} !Int
[pc_ILDV_CREATE_MASK] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_CREATE] :: PlatformConstants -> !Integer
[pc_ILDV_STATE_USE] :: PlatformConstants -> !Integer
[pc_USE_INLINE_SRT_FIELD] :: PlatformConstants -> !Bool

-- | Try to locate "DerivedConstants.h" file in the given dirs and to parse
--   the PlatformConstants from it.
--   
--   See Note [Platform constants]
lookupPlatformConstants :: [FilePath] -> IO (Maybe PlatformConstants)
platformConstants :: Platform -> PlatformConstants
platformSOName :: Platform -> FilePath -> FilePath
platformHsSOName :: Platform -> FilePath -> FilePath
platformSOExt :: Platform -> FilePath
genericPlatform :: Platform
instance GHC.Classes.Ord GHC.Platform.PlatformWordSize
instance GHC.Classes.Eq GHC.Platform.PlatformWordSize
instance GHC.Classes.Ord GHC.Platform.Platform
instance GHC.Classes.Eq GHC.Platform.Platform
instance GHC.Show.Show GHC.Platform.Platform
instance GHC.Read.Read GHC.Platform.Platform
instance GHC.Classes.Ord GHC.Platform.SseVersion
instance GHC.Classes.Eq GHC.Platform.SseVersion
instance GHC.Classes.Ord GHC.Platform.BmiVersion
instance GHC.Classes.Eq GHC.Platform.BmiVersion
instance GHC.Show.Show GHC.Platform.PlatformWordSize
instance GHC.Read.Read GHC.Platform.PlatformWordSize


-- | Various utilities used in generating assembler.
--   
--   These are used not only by the native code generator, but also by the
--   <a>GHC.Driver.Pipeline</a>
module GHC.Utils.Asm

-- | Generate a section type (e.g. <tt>@progbits</tt>). See #13937.
sectionType :: IsLine doc => Platform -> String -> doc


-- | Run-time settings
module GHC.Settings
data Settings
Settings :: {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> Settings
[sGhcNameVersion] :: Settings -> {-# UNPACK #-} !GhcNameVersion
[sFileSettings] :: Settings -> {-# UNPACK #-} !FileSettings
[sTargetPlatform] :: Settings -> Platform
[sToolSettings] :: Settings -> {-# UNPACK #-} !ToolSettings
[sPlatformMisc] :: Settings -> {-# UNPACK #-} !PlatformMisc
[sRawSettings] :: Settings -> [(String, String)]

-- | Settings for other executables GHC calls.
--   
--   Probably should further split down by phase, or split between
--   platform-specific and platform-agnostic.
data ToolSettings
ToolSettings :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> String -> (String, [Option]) -> String -> String -> String -> (String, [Option]) -> (String, [Option]) -> Maybe (String, [Option]) -> (String, [Option]) -> String -> String -> String -> String -> String -> String -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> String -> [String] -> [String] -> Fingerprint -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> ToolSettings
[toolSettings_ldSupportsCompactUnwind] :: ToolSettings -> Bool
[toolSettings_ldSupportsFilelist] :: ToolSettings -> Bool
[toolSettings_ldSupportsSingleModule] :: ToolSettings -> Bool
[toolSettings_ldIsGnuLd] :: ToolSettings -> Bool
[toolSettings_ccSupportsNoPie] :: ToolSettings -> Bool
[toolSettings_useInplaceMinGW] :: ToolSettings -> Bool
[toolSettings_arSupportsDashL] :: ToolSettings -> Bool
[toolSettings_pgm_L] :: ToolSettings -> String
[toolSettings_pgm_P] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_F] :: ToolSettings -> String
[toolSettings_pgm_c] :: ToolSettings -> String
[toolSettings_pgm_cxx] :: ToolSettings -> String
[toolSettings_pgm_a] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_l] :: ToolSettings -> (String, [Option])

-- | N.B. On Windows we don't have a linker which supports object merging,
--   hence the <a>Maybe</a>. See Note [Object merging] in
--   <a>GHC.Driver.Pipeline.Execute</a> for details.
[toolSettings_pgm_lm] :: ToolSettings -> Maybe (String, [Option])
[toolSettings_pgm_dll] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_T] :: ToolSettings -> String
[toolSettings_pgm_windres] :: ToolSettings -> String
[toolSettings_pgm_ar] :: ToolSettings -> String
[toolSettings_pgm_otool] :: ToolSettings -> String
[toolSettings_pgm_install_name_tool] :: ToolSettings -> String
[toolSettings_pgm_ranlib] :: ToolSettings -> String

-- | LLVM: opt llvm optimiser
[toolSettings_pgm_lo] :: ToolSettings -> (String, [Option])

-- | LLVM: llc static compiler
[toolSettings_pgm_lc] :: ToolSettings -> (String, [Option])

-- | LLVM: c compiler
[toolSettings_pgm_lcc] :: ToolSettings -> (String, [Option])
[toolSettings_pgm_i] :: ToolSettings -> String
[toolSettings_opt_L] :: ToolSettings -> [String]
[toolSettings_opt_P] :: ToolSettings -> [String]

-- | cached Fingerprint of sOpt_P See Note [Repeated -optP hashing]
[toolSettings_opt_P_fingerprint] :: ToolSettings -> Fingerprint
[toolSettings_opt_F] :: ToolSettings -> [String]
[toolSettings_opt_c] :: ToolSettings -> [String]
[toolSettings_opt_cxx] :: ToolSettings -> [String]
[toolSettings_opt_a] :: ToolSettings -> [String]
[toolSettings_opt_l] :: ToolSettings -> [String]
[toolSettings_opt_lm] :: ToolSettings -> [String]
[toolSettings_opt_windres] :: ToolSettings -> [String]

-- | LLVM: llvm optimiser
[toolSettings_opt_lo] :: ToolSettings -> [String]

-- | LLVM: llc static compiler
[toolSettings_opt_lc] :: ToolSettings -> [String]

-- | LLVM: c compiler
[toolSettings_opt_lcc] :: ToolSettings -> [String]

-- | iserv options
[toolSettings_opt_i] :: ToolSettings -> [String]
[toolSettings_extraGccViaCFlags] :: ToolSettings -> [String]

-- | Paths to various files and directories used by GHC, including those
--   that provide more settings.
data FileSettings
FileSettings :: FilePath -> FilePath -> Maybe FilePath -> FilePath -> FilePath -> FileSettings
[fileSettings_ghcUsagePath] :: FileSettings -> FilePath
[fileSettings_ghciUsagePath] :: FileSettings -> FilePath
[fileSettings_toolDir] :: FileSettings -> Maybe FilePath
[fileSettings_topDir] :: FileSettings -> FilePath
[fileSettings_globalPackageDatabase] :: FileSettings -> FilePath

-- | Settings for what GHC this is.
data GhcNameVersion
GhcNameVersion :: String -> String -> GhcNameVersion
[ghcNameVersion_programName] :: GhcNameVersion -> String
[ghcNameVersion_projectVersion] :: GhcNameVersion -> String

-- | Platform description
--   
--   This is used to describe platforms so that we can generate code for
--   them.
data Platform
Platform :: !ArchOS -> !PlatformWordSize -> !ByteOrder -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Maybe PlatformConstants -> Platform

-- | Architecture and OS
[platformArchOS] :: Platform -> !ArchOS

-- | Word size
[platformWordSize] :: Platform -> !PlatformWordSize

-- | Byte order (endianness)
[platformByteOrder] :: Platform -> !ByteOrder
[platformUnregisterised] :: Platform -> !Bool
[platformHasGnuNonexecStack] :: Platform -> !Bool
[platformHasIdentDirective] :: Platform -> !Bool
[platformHasSubsectionsViaSymbols] :: Platform -> !Bool
[platformIsCrossCompiling] :: Platform -> !Bool

-- | Symbols need underscore prefix
[platformLeadingUnderscore] :: Platform -> !Bool

-- | Determines whether we will be compiling info tables that reside just
--   before the entry code, or with an indirection to the entry code. See
--   TABLES_NEXT_TO_CODE in rts<i>include</i>rts<i>storage</i>InfoTables.h.
[platformTablesNextToCode] :: Platform -> !Bool

-- | Some platforms require that we explicitly link against <tt>libm</tt>
--   if any math-y things are used (which we assume to include all
--   programs). See #14022.
[platformHasLibm] :: Platform -> !Bool

-- | Constants such as structure offsets, type sizes, etc.
[platform_constants] :: Platform -> !Maybe PlatformConstants

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> Bool -> Bool -> String -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String

-- | Dynamic library suffix
dynLibSuffix :: GhcNameVersion -> String
sProgramName :: Settings -> String
sProjectVersion :: Settings -> String
sGhcUsagePath :: Settings -> FilePath
sGhciUsagePath :: Settings -> FilePath
sToolDir :: Settings -> Maybe FilePath
sTopDir :: Settings -> FilePath
sGlobalPackageDatabasePath :: Settings -> FilePath
sLdSupportsCompactUnwind :: Settings -> Bool
sLdSupportsFilelist :: Settings -> Bool
sLdIsGnuLd :: Settings -> Bool
sGccSupportsNoPie :: Settings -> Bool
sUseInplaceMinGW :: Settings -> Bool
sArSupportsDashL :: Settings -> Bool
sPgm_L :: Settings -> String
sPgm_P :: Settings -> (String, [Option])
sPgm_F :: Settings -> String
sPgm_c :: Settings -> String
sPgm_cxx :: Settings -> String
sPgm_a :: Settings -> (String, [Option])
sPgm_l :: Settings -> (String, [Option])
sPgm_lm :: Settings -> Maybe (String, [Option])
sPgm_dll :: Settings -> (String, [Option])
sPgm_T :: Settings -> String
sPgm_windres :: Settings -> String
sPgm_ar :: Settings -> String
sPgm_otool :: Settings -> String
sPgm_install_name_tool :: Settings -> String
sPgm_ranlib :: Settings -> String
sPgm_lo :: Settings -> (String, [Option])
sPgm_lc :: Settings -> (String, [Option])
sPgm_lcc :: Settings -> (String, [Option])
sPgm_i :: Settings -> String
sOpt_L :: Settings -> [String]
sOpt_P :: Settings -> [String]
sOpt_P_fingerprint :: Settings -> Fingerprint
sOpt_F :: Settings -> [String]
sOpt_c :: Settings -> [String]
sOpt_cxx :: Settings -> [String]
sOpt_a :: Settings -> [String]
sOpt_l :: Settings -> [String]
sOpt_lm :: Settings -> [String]
sOpt_windres :: Settings -> [String]
sOpt_lo :: Settings -> [String]
sOpt_lc :: Settings -> [String]
sOpt_lcc :: Settings -> [String]
sOpt_i :: Settings -> [String]
sExtraGccViaCFlags :: Settings -> [String]
sTargetPlatformString :: Settings -> String
sGhcWithInterpreter :: Settings -> Bool
sLibFFI :: Settings -> Bool

module GHC.Settings.IO
data SettingsError
SettingsError_MissingData :: String -> SettingsError
SettingsError_BadData :: String -> SettingsError
initSettings :: forall m. MonadIO m => String -> ExceptT SettingsError m Settings


-- | Ways
--   
--   The central concept of a "way" is that all objects in a given program
--   must be compiled in the same "way". Certain options change parameters
--   of the virtual machine, eg. profiling adds an extra word to the object
--   header, so profiling objects cannot be linked with non-profiling
--   objects.
--   
--   After parsing the command-line options, we determine which "way" we
--   are building - this might be a combination way, eg.
--   profiling+threaded.
--   
--   There are two kinds of ways: - RTS only: only affect the runtime
--   system (RTS) and don't affect code generation (e.g. threaded, debug) -
--   Full ways: affect code generation and the RTS (e.g. profiling, dynamic
--   linking)
--   
--   We then find the "build-tag" associated with this way, and this
--   becomes the suffix used to find .hi files and libraries used in this
--   compilation.
module GHC.Platform.Ways

-- | A way
--   
--   Don't change the constructor order as it is used by <a>waysTag</a> to
--   create a unique tag (e.g. thr_debug_p) which is expected by other
--   tools (e.g. Cabal).
data Way

-- | for GHC API clients building custom variants
WayCustom :: String -> Way

-- | (RTS only) Multithreaded runtime system
WayThreaded :: Way

-- | Debugging, enable trace messages and extra checks
WayDebug :: Way

-- | Profiling, enable cost-centre stacks and profiling reports
WayProf :: Way

-- | Dynamic linking
WayDyn :: Way
type Ways = Set Way

-- | Test if a way is enabled
hasWay :: Ways -> Way -> Bool

-- | Test if a way is not enabled
hasNotWay :: Ways -> Way -> Bool

-- | Add a way
addWay :: Way -> Ways -> Ways

-- | Remove a way
removeWay :: Way -> Ways -> Ways

-- | Check if a combination of ways is allowed
allowed_combination :: Ways -> Bool

-- | Turn these flags on when enabling this way
wayGeneralFlags :: Platform -> Way -> [GeneralFlag]

-- | Turn these flags off when enabling this way
wayUnsetGeneralFlags :: Platform -> Way -> [GeneralFlag]

-- | Pass these options to the C compiler when enabling this way
wayOptc :: Platform -> Way -> [String]

-- | Pass these options to linker when enabling this way
wayOptl :: Platform -> Way -> [String]

-- | Pass these options to the preprocessor when enabling this way
wayOptP :: Platform -> Way -> [String]
wayDesc :: Way -> String

-- | Return true for ways that only impact the RTS, not the generated code
wayRTSOnly :: Way -> Bool

-- | Unique build-tag associated to a way
wayTag :: Way -> String

-- | Unique tag associated to a list of ways
waysTag :: Ways -> String

-- | Unique build-tag associated to a list of ways
--   
--   RTS only ways are filtered out because they have no impact on the
--   build.
waysBuildTag :: Ways -> String

-- | Filter ways that have an impact on compilation
fullWays :: Ways -> Ways

-- | Filter RTS-only ways (ways that don't have an impact on compilation)
rtsWays :: Ways -> Ways

-- | Host ways.
hostWays :: Ways

-- | Host "full" ways (i.e. ways that have an impact on the compilation,
--   not RTS only ways).
--   
--   These ways must be used when compiling codes targeting the internal
--   interpreter.
hostFullWays :: Ways

-- | Consult the RTS to find whether it has been built with profiling
--   enabled.
hostIsProfiled :: Bool

-- | Consult the RTS to find whether GHC itself has been built with dynamic
--   linking. This can't be statically known at compile-time, because we
--   build both the static and dynamic versions together with -dynamic-too.
hostIsDynamic :: Bool

-- | Consult the RTS to find whether it is threaded.
hostIsThreaded :: Bool

-- | Consult the RTS to find whether it is debugged.
hostIsDebugged :: Bool

-- | Consult the RTS to find whether it is tracing.
hostIsTracing :: Bool
instance GHC.Read.Read GHC.Platform.Ways.Way
instance GHC.Show.Show GHC.Platform.Ways.Way
instance GHC.Classes.Ord GHC.Platform.Ways.Way
instance GHC.Classes.Eq GHC.Platform.Ways.Way


-- | Info about installed units (compiled libraries)
module GHC.Unit.Info

-- | Information about an unit (a unit is an installed module library).
--   
--   This is a subset of Cabal's <tt>InstalledPackageInfo</tt>, with just
--   the bits that GHC is interested in.
--   
--   Some types are left as parameters to be instantiated differently in
--   ghc-pkg and in ghc itself.
data () => GenericUnitInfo srcpkgid srcpkgname uid modulename mod
GenericUnitInfo :: uid -> uid -> [(modulename, mod)] -> srcpkgid -> srcpkgname -> Version -> Maybe srcpkgname -> ShortText -> [uid] -> [(uid, ShortText)] -> [FilePathST] -> [ShortText] -> [ShortText] -> [ShortText] -> [FilePathST] -> [FilePathST] -> [ShortText] -> [FilePathST] -> [ShortText] -> [ShortText] -> [ShortText] -> [FilePathST] -> [FilePathST] -> [FilePathST] -> [(modulename, Maybe mod)] -> [modulename] -> Bool -> Bool -> Bool -> GenericUnitInfo srcpkgid srcpkgname uid modulename mod

-- | Unique unit identifier that is used during compilation (e.g. to
--   generate symbols).
[unitId] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> uid

-- | Identifier of an indefinite unit (i.e. with module holes) that this
--   unit is an instance of.
--   
--   For non instantiated units, unitInstanceOf=unitId
[unitInstanceOf] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> uid

-- | How this unit instantiates some of its module holes. Map hole module
--   names to actual module
[unitInstantiations] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [(modulename, mod)]

-- | Source package identifier.
--   
--   Cabal instantiates this with Distribution.Types.PackageId.PackageId
--   type which only contains the source package name and version. Notice
--   that it doesn't contain the Hackage revision, nor any kind of hash.
[unitPackageId] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> srcpkgid

-- | Source package name
[unitPackageName] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> srcpkgname

-- | Source package version
[unitPackageVersion] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> Version

-- | Name of the component.
--   
--   Cabal supports more than one components (libraries, executables,
--   testsuites) in the same package. Each component has a name except the
--   default one (that can only be a library component) for which we use
--   <a>Nothing</a>.
--   
--   GHC only deals with "library" components as they are the only kind of
--   components that can be registered in a database and used by other
--   modules.
[unitComponentName] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> Maybe srcpkgname

-- | ABI hash used to avoid mixing up units compiled with different
--   dependencies, compiler, options, etc.
[unitAbiHash] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> ShortText

-- | Identifiers of the units this one depends on
[unitDepends] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [uid]

-- | Like <a>unitDepends</a>, but each dependency is annotated with the ABI
--   hash we expect the dependency to respect.
[unitAbiDepends] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [(uid, ShortText)]

-- | Directories containing module interfaces
[unitImportDirs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Names of the Haskell libraries provided by this unit
[unitLibraries] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Names of the external system libraries that this unit depends on. See
--   also <a>unitExtDepLibsGhc</a> field.
[unitExtDepLibsSys] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Because of slight differences between the GHC dynamic linker (in
--   GHC.Runtime.Linker) and the native system linker, some packages have
--   to link with a different list of libraries when using GHC's. Examples
--   include: libs that are actually gnu ld scripts, and the possibility
--   that the .a libs do not exactly match the .so/.dll equivalents.
--   
--   If this field is set, then we use that instead of the
--   <a>unitExtDepLibsSys</a> field.
[unitExtDepLibsGhc] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Directories containing libraries provided by this unit. See also
--   <a>unitLibraryDynDirs</a>.
--   
--   It seems to be used to store paths to external library dependencies
--   too.
[unitLibraryDirs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Directories containing the dynamic libraries provided by this unit.
--   See also <a>unitLibraryDirs</a>.
--   
--   It seems to be used to store paths to external dynamic library
--   dependencies too.
[unitLibraryDynDirs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Names of the external MacOS frameworks that this unit depends on.
[unitExtDepFrameworks] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Directories containing MacOS frameworks that this unit depends on.
[unitExtDepFrameworkDirs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Linker (e.g. ld) command line options
[unitLinkerOptions] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | C compiler options that needs to be passed to the C compiler when we
--   compile some C code against this unit.
[unitCcOptions] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | C header files that are required by this unit (provided by this unit
--   or external)
[unitIncludes] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [ShortText]

-- | Directories containing C header files that this unit depends on.
[unitIncludeDirs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Paths to Haddock interface files for this unit
[unitHaddockInterfaces] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Paths to Haddock directories containing HTML files
[unitHaddockHTMLs] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [FilePathST]

-- | Modules exposed by the unit.
--   
--   A module can be re-exported from another package. In this case, we
--   indicate the module origin in the second parameter.
[unitExposedModules] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [(modulename, Maybe mod)]

-- | Hidden modules.
--   
--   These are useful for error reporting (e.g. if a hidden module is
--   imported)
[unitHiddenModules] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> [modulename]

-- | True if this unit has some module holes that need to be instantiated
--   with real modules to make the unit usable (a.k.a. Backpack).
[unitIsIndefinite] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> Bool

-- | True if the unit is exposed. A unit could be installed in a database
--   by "disabled" by not being exposed.
[unitIsExposed] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> Bool

-- | True if the unit is trusted (cf Safe Haskell)
[unitIsTrusted] :: GenericUnitInfo srcpkgid srcpkgname uid modulename mod -> Bool

-- | Information about an installed unit
--   
--   We parameterize on the unit identifier: * UnitKey: identifier used in
--   the database (cf <a>UnitKeyInfo</a>) * UnitId: identifier used to
--   generate code (cf <a>UnitInfo</a>)
--   
--   These two identifiers are different for wired-in packages. See Note
--   [About units] in <a>GHC.Unit</a>
type GenUnitInfo unit = GenericUnitInfo PackageId PackageName unit ModuleName (GenModule (GenUnit unit))

-- | Information about an installed unit (units are identified by their
--   internal UnitId)
type UnitInfo = GenUnitInfo UnitId

-- | A unit key in the database
newtype UnitKey
UnitKey :: FastString -> UnitKey

-- | Information about an installed unit (units are identified by their
--   database UnitKey)
type UnitKeyInfo = GenUnitInfo UnitKey

-- | Convert a DbUnitInfo (read from a package database) into
--   <a>UnitKeyInfo</a>
mkUnitKeyInfo :: DbUnitInfo -> UnitKeyInfo

-- | Map over the unit parameter
mapUnitInfo :: IsUnitId v => (u -> v) -> GenUnitInfo u -> GenUnitInfo v

-- | Create a UnitPprInfo from a UnitInfo
mkUnitPprInfo :: (u -> FastString) -> GenUnitInfo u -> UnitPprInfo

-- | Make a <a>Unit</a> from a <a>UnitInfo</a>
--   
--   If the unit is definite, make a <a>RealUnit</a> from <a>unitId</a>
--   field.
--   
--   If the unit is indefinite, make a <a>VirtUnit</a> from
--   <a>unitInstanceOf</a> and <a>unitInstantiations</a> fields. Note that
--   in this case we don't keep track of <a>unitId</a>. It can be retrieved
--   later with "improvement", i.e. matching on
--   `unitInstanceOf/unitInstantiations` fields (see Note [About units] in
--   GHC.Unit).
mkUnit :: UnitInfo -> Unit
newtype PackageId
PackageId :: FastString -> PackageId
newtype PackageName
PackageName :: FastString -> PackageName
[unPackageName] :: PackageName -> FastString

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data () => Version
Version :: [Int] -> [String] -> Version

-- | The numeric branch for this version. This reflects the fact that most
--   software versions are tree-structured; there is a main trunk which is
--   tagged with versions at various points (1,2,3...), and the first
--   branch off the trunk after version 3 is 3.1, the second branch off the
--   trunk after version 3 is 3.2, and so on. The tree can be branched
--   arbitrarily, just by adding more digits.
--   
--   We represent the branch as a list of <a>Int</a>, so version 3.2.1
--   becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of
--   <a>Ord</a> for <tt>[Int]</tt>) gives the natural ordering of branches.
[versionBranch] :: Version -> [Int]

-- | A version can be tagged with an arbitrary list of strings. The
--   interpretation of the list of tags is entirely dependent on the entity
--   that this version applies to.
[versionTags] :: Version -> [String]
unitPackageNameString :: GenUnitInfo u -> String
unitPackageIdString :: GenUnitInfo u -> String
pprUnitInfo :: UnitInfo -> SDoc

-- | Find all the include directories in the given units
collectIncludeDirs :: [UnitInfo] -> [FilePath]

-- | Find all the C-compiler options in the given units
collectExtraCcOpts :: [UnitInfo] -> [String]

-- | Find all the library directories in the given units for the given ways
collectLibraryDirs :: Ways -> [UnitInfo] -> [FilePath]

-- | Find all the frameworks in the given units
collectFrameworks :: [UnitInfo] -> [String]

-- | Find all the package framework paths in these and the preload packages
collectFrameworksDirs :: [UnitInfo] -> [String]
unitHsLibs :: GhcNameVersion -> Ways -> UnitInfo -> [String]
instance GHC.Classes.Eq GHC.Unit.Info.PackageId
instance GHC.Classes.Eq GHC.Unit.Info.PackageName
instance GHC.Types.Unique.Uniquable GHC.Unit.Info.PackageName
instance GHC.Utils.Outputable.Outputable GHC.Unit.Info.PackageName
instance GHC.Types.Unique.Uniquable GHC.Unit.Info.PackageId
instance GHC.Utils.Outputable.Outputable GHC.Unit.Info.PackageId


-- | Platform profiles
module GHC.Platform.Profile

-- | A platform profile fully describes the kind of objects that are
--   generated for a platform.
--   
--   <a>Platform</a> doesn't fully describe the ABI of an object. Compiler
--   ways (profiling, debug, dynamic) also modify the ABI.
data Profile
Profile :: !Platform -> !Ways -> Profile

-- | Platform
[profilePlatform] :: Profile -> !Platform

-- | Ways
[profileWays] :: Profile -> !Ways

-- | Unique build tag for the profile
profileBuildTag :: Profile -> String

-- | Get platform constants
profileConstants :: Profile -> PlatformConstants

-- | Is profiling enabled
profileIsProfiling :: Profile -> Bool

-- | Word size in bytes
profileWordSizeInBytes :: Profile -> Int
instance GHC.Read.Read GHC.Platform.Profile.Profile
instance GHC.Show.Show GHC.Platform.Profile.Profile
instance GHC.Classes.Ord GHC.Platform.Profile.Profile
instance GHC.Classes.Eq GHC.Platform.Profile.Profile


-- | Configuration options for Lift the lambda lifter.
module GHC.Stg.Lift.Config
data StgLiftConfig
StgLiftConfig :: !Profile -> !Maybe Int -> !Maybe Int -> !Bool -> StgLiftConfig
[c_targetProfile] :: StgLiftConfig -> !Profile

-- | Maximum number of arguments after lambda lifting a recursive function.
[c_liftLamsRecArgs] :: StgLiftConfig -> !Maybe Int

-- | Maximum number of arguments after lambda lifting non-recursive
--   function.
[c_liftLamsNonRecArgs] :: StgLiftConfig -> !Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[c_liftLamsKnown] :: StgLiftConfig -> !Bool
instance GHC.Classes.Ord GHC.Stg.Lift.Config.StgLiftConfig
instance GHC.Classes.Eq GHC.Stg.Lift.Config.StgLiftConfig
instance GHC.Read.Read GHC.Stg.Lift.Config.StgLiftConfig
instance GHC.Show.Show GHC.Stg.Lift.Config.StgLiftConfig

module GHC.Runtime.Heap.Layout

-- | Word offset, or word count
type WordOff = Int

-- | Byte offset, or byte count
type ByteOff = Int

-- | Convert the given number of words to a number of bytes.
--   
--   This function morally has type <tt>WordOff -&gt; ByteOff</tt>, but
--   uses <tt>Num a</tt> to allow for overloading.
wordsToBytes :: Num a => Platform -> a -> a

-- | First round the given byte count up to a multiple of the machine's
--   word size and then convert the result to words.
bytesToWordsRoundUp :: Platform -> ByteOff -> WordOff

-- | Round up the given byte count to the next byte count that's a multiple
--   of the machine's word size.
roundUpToWords :: Platform -> ByteOff -> ByteOff

-- | Round up <tt>base</tt> to a multiple of <tt>size</tt>.
roundUpTo :: ByteOff -> ByteOff -> ByteOff
data StgWord
fromStgWord :: StgWord -> Integer
toStgWord :: Platform -> Integer -> StgWord
data StgHalfWord
fromStgHalfWord :: StgHalfWord -> Integer
toStgHalfWord :: Platform -> Integer -> StgHalfWord

-- | Half word size in bytes
halfWordSize :: Platform -> ByteOff
halfWordSizeInBits :: Platform -> Int

-- | A description of the layout of a closure. Corresponds directly to the
--   closure types in includes/rts/storage/ClosureTypes.h.
data SMRep
HeapRep :: IsStatic -> !WordOff -> !WordOff -> ClosureTypeInfo -> SMRep
ArrayPtrsRep :: !WordOff -> !WordOff -> SMRep
SmallArrayPtrsRep :: !WordOff -> SMRep
ArrayWordsRep :: !WordOff -> SMRep
StackRep :: Liveness -> SMRep
RTSRep :: Int -> SMRep -> SMRep

-- | True &lt;=&gt; This is a static closure. Affects how we
--   garbage-collect it. Static closure have an extra static link field at
--   the end. Constructors do not have a static variant; see Note [static
--   constructors]
type IsStatic = Bool
data ClosureTypeInfo
Constr :: ConTagZ -> ConstrDescription -> ClosureTypeInfo
Fun :: FunArity -> ArgDescr -> ClosureTypeInfo
Thunk :: ClosureTypeInfo
ThunkSelector :: SelectorOffset -> ClosureTypeInfo
BlackHole :: ClosureTypeInfo
IndStatic :: ClosureTypeInfo

-- | An ArgDescr describes the argument pattern of a function
data ArgDescr
ArgSpec :: !Int -> ArgDescr
ArgGen :: Liveness -> ArgDescr
ArgUnknown :: ArgDescr

-- | We represent liveness bitmaps as a Bitmap (whose internal
--   representation really is a bitmap). These are pinned onto case return
--   vectors to indicate the state of the stack for the garbage collector.
--   
--   In the compiled program, liveness bitmaps that fit inside a single
--   word (StgWord) are stored as a single word, while larger bitmaps are
--   stored as a pointer to an array of words.
type Liveness = [Bool]
type ConstrDescription = ByteString
mkHeapRep :: Profile -> IsStatic -> WordOff -> WordOff -> ClosureTypeInfo -> SMRep
blackHoleRep :: SMRep
indStaticRep :: SMRep
mkStackRep :: [Bool] -> SMRep
mkRTSRep :: Int -> SMRep -> SMRep
arrPtrsRep :: Platform -> WordOff -> SMRep
smallArrPtrsRep :: WordOff -> SMRep
arrWordsRep :: Platform -> ByteOff -> SMRep
isStaticRep :: SMRep -> IsStatic
isConRep :: SMRep -> Bool
isThunkRep :: SMRep -> Bool
isFunRep :: SMRep -> Bool
isStaticNoCafCon :: SMRep -> Bool
isStackRep :: SMRep -> Bool

-- | The total size of the closure, in words.
heapClosureSizeW :: Profile -> SMRep -> WordOff

-- | Size of a closure header (StgHeader in
--   includes/rts/storage/Closures.h)
fixedHdrSizeW :: Profile -> WordOff
arrWordsHdrSize :: Profile -> ByteOff
arrWordsHdrSizeW :: Profile -> WordOff
arrPtrsHdrSize :: Profile -> ByteOff
arrPtrsHdrSizeW :: Profile -> WordOff

-- | Size of the profiling part of a closure header (StgProfHeader in
--   includes/rts/storage/Closures.h)
profHdrSize :: Profile -> WordOff
thunkHdrSize :: Profile -> WordOff
nonHdrSize :: Platform -> SMRep -> ByteOff
nonHdrSizeW :: SMRep -> WordOff
smallArrPtrsHdrSize :: Profile -> ByteOff
smallArrPtrsHdrSizeW :: Profile -> WordOff
hdrSize :: Profile -> SMRep -> ByteOff
hdrSizeW :: Profile -> SMRep -> WordOff
fixedHdrSize :: Profile -> ByteOff

-- | Derives the RTS closure type from an <a>SMRep</a>
rtsClosureType :: SMRep -> Int
rET_SMALL :: Int
rET_BIG :: Int
aRG_GEN :: Int
aRG_GEN_BIG :: Int

-- | The byte offset into the card table of the card for a given element
card :: Platform -> Int -> Int

-- | Convert a number of elements to a number of cards, rounding up
cardRoundUp :: Platform -> Int -> Int

-- | The size of a card table, in bytes
cardTableSizeB :: Platform -> Int -> ByteOff

-- | The size of a card table, in words
cardTableSizeW :: Platform -> Int -> WordOff
instance GHC.Bits.Bits GHC.Runtime.Heap.Layout.StgWord
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.StgWord
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.StgHalfWord
instance GHC.Classes.Ord GHC.Runtime.Heap.Layout.ArgDescr
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.ArgDescr
instance GHC.Classes.Ord GHC.Runtime.Heap.Layout.ClosureTypeInfo
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.ClosureTypeInfo
instance GHC.Classes.Ord GHC.Runtime.Heap.Layout.SMRep
instance GHC.Classes.Eq GHC.Runtime.Heap.Layout.SMRep
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.SMRep
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.ClosureTypeInfo
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.ArgDescr
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.StgHalfWord
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Layout.StgWord

module GHC.Linker.Static.Utils

-- | Compute the output file name of a program.
--   
--   StaticLink boolean is used to indicate if the program is actually a
--   static library (e.g., on iOS).
--   
--   Use the provided filename (if any), otherwise use "main.exe"
--   (Windows), "a.out (otherwise without StaticLink set), "liba.a". In
--   every case, add the extension if it is missing.
exeFileName :: ArchOS -> Bool -> Maybe FilePath -> FilePath

module GHC.Driver.Phases

-- | Untyped Phase description
data Phase
Unlit :: HscSource -> Phase
Cpp :: HscSource -> Phase
HsPp :: HscSource -> Phase
Hsc :: HscSource -> Phase
Ccxx :: Phase
Cc :: Phase
Cobjc :: Phase
Cobjcxx :: Phase
HCc :: Phase
As :: Bool -> Phase
LlvmOpt :: Phase
LlvmLlc :: Phase
LlvmMangle :: Phase
CmmCpp :: Phase
Cmm :: Phase
MergeForeign :: Phase
Js :: Phase
StopLn :: Phase
happensBefore :: Platform -> Phase -> Phase -> Bool
eqPhase :: Phase -> Phase -> Bool
isStopLn :: Phase -> Bool
startPhase :: String -> Phase
phaseInputExt :: Phase -> String
data StopPhase

-- | <pre>
--   -E
--   </pre>
StopPreprocess :: StopPhase

-- | <pre>
--   -C
--   </pre>
StopC :: StopPhase

-- | <pre>
--   -S
--   </pre>
StopAs :: StopPhase

-- | <pre>
--   -c
--   </pre>
NoStop :: StopPhase
stopPhaseToPhase :: StopPhase -> Phase
isHaskellishSuffix :: String -> Bool
isHaskellSrcSuffix :: String -> Bool
isBackpackishSuffix :: String -> Bool
isObjectSuffix :: Platform -> String -> Bool
isCishSuffix :: String -> Bool
isDynLibSuffix :: Platform -> String -> Bool
isHaskellUserSrcSuffix :: String -> Bool
isHaskellSigSuffix :: String -> Bool
isSourceSuffix :: String -> Bool

-- | When we are given files (modified by -x arguments) we need to
--   determine if they are Haskellish or not to figure out how we should
--   try to compile it. The rules are:
--   
--   <ol>
--   <li>If no -x flag was specified, we check to see if the file looks
--   like a module name, has no extension, or has a Haskell source
--   extension.</li>
--   <li>If an -x flag was specified, we just make sure the specified
--   suffix is a Haskell one.</li>
--   </ol>
isHaskellishTarget :: (String, Maybe Phase) -> Bool
isHaskellishFilename :: FilePath -> Bool
isHaskellSrcFilename :: FilePath -> Bool
isHaskellSigFilename :: FilePath -> Bool
isObjectFilename :: Platform -> FilePath -> Bool
isCishFilename :: FilePath -> Bool
isDynLibFilename :: Platform -> FilePath -> Bool
isHaskellUserSrcFilename :: FilePath -> Bool
isSourceFilename :: FilePath -> Bool

-- | Foreign language of the phase if the phase deals with a foreign code
phaseForeignLanguage :: Phase -> Maybe ForeignSrcLang
instance GHC.Show.Show GHC.Driver.Phases.Phase
instance GHC.Classes.Eq GHC.Driver.Phases.Phase
instance GHC.Utils.Outputable.Outputable GHC.Driver.Phases.Phase

module GHC.Data.Bitmap

-- | A bitmap represented by a sequence of <a>StgWord</a>s on the
--   <i>target</i> architecture. These are used for bitmaps in info tables
--   and other generated code which need to be emitted as sequences of
--   StgWords.
type Bitmap = [StgWord]

-- | Make a bitmap from a sequence of bits
mkBitmap :: Platform -> [Bool] -> Bitmap

-- | Make a bitmap where the slots specified are the <i>zeros</i> in the
--   bitmap. eg. <tt>[0,1,3], size 4 ==&gt; 0x4</tt> (we leave any bits
--   outside the size as zero, just to make the bitmap easier to read).
--   
--   The list of <tt>Int</tt>s <i>must</i> be already sorted and
--   duplicate-free.
intsToReverseBitmap :: Platform -> Int -> [Int] -> Bitmap

-- | Magic number, must agree with <tt>BITMAP_BITS_SHIFT</tt> in
--   InfoTables.h. Some kinds of bitmap pack a size/bitmap into a single
--   word if possible, or fall back to an external pointer when the bitmap
--   is too large. This value represents the largest size of bitmap that
--   can be packed into a single word.
mAX_SMALL_BITMAP_SIZE :: Platform -> Int

module GHC.Core.Rules.Config

-- | Rule options
data RuleOpts
RuleOpts :: !Platform -> !Bool -> !Bool -> !Bool -> RuleOpts

-- | Target platform
[roPlatform] :: RuleOpts -> !Platform

-- | Enable more advanced numeric constant folding
[roNumConstantFolding] :: RuleOpts -> !Bool

-- | Cut down precision of Rational values to that of Float/Double if
--   disabled
[roExcessRationalPrecision] :: RuleOpts -> !Bool

-- | Enable rules for bignums
[roBignumRules] :: RuleOpts -> !Bool


-- | GHC LLVM Mangler
--   
--   This script processes the assembly produced by LLVM, rewriting all
--   symbols of type <tt>function to </tt>object. This keeps them from
--   going through the PLT, which would be bad due to tables-next-to-code.
--   On x86_64, it also rewrites AVX instructions that require alignment to
--   their unaligned counterparts, since the stack is only 16-byte aligned
--   but these instructions require 32-byte alignment.
module GHC.CmmToLlvm.Mangler

-- | Read in assembly file and process
llvmFixupAsm :: Platform -> FilePath -> FilePath -> IO ()


-- | Llvm code generator configuration
module GHC.CmmToLlvm.Config
data LlvmCgConfig
LlvmCgConfig :: !Platform -> !SDocContext -> !Bool -> !Bool -> Maybe BmiVersion -> Maybe LlvmVersion -> !Bool -> !String -> !LlvmConfig -> LlvmCgConfig

-- | Target platform
[llvmCgPlatform] :: LlvmCgConfig -> !Platform

-- | Context for LLVM code generation
[llvmCgContext] :: LlvmCgConfig -> !SDocContext

-- | Fill undefined literals with garbage values
[llvmCgFillUndefWithGarbage] :: LlvmCgConfig -> !Bool

-- | Split sections
[llvmCgSplitSection] :: LlvmCgConfig -> !Bool

-- | (x86) BMI instructions
[llvmCgBmiVersion] :: LlvmCgConfig -> Maybe BmiVersion

-- | version of Llvm we're using
[llvmCgLlvmVersion] :: LlvmCgConfig -> Maybe LlvmVersion

-- | True ==&gt; warn unsupported Llvm version
[llvmCgDoWarn] :: LlvmCgConfig -> !Bool

-- | target triple passed to LLVM
[llvmCgLlvmTarget] :: LlvmCgConfig -> !String

-- | Supported LLVM configurations. see Note [LLVM configuration]
[llvmCgLlvmConfig] :: LlvmCgConfig -> !LlvmConfig
data LlvmConfig
LlvmConfig :: [(String, LlvmTarget)] -> [(Int, String)] -> LlvmConfig
[llvmTargets] :: LlvmConfig -> [(String, LlvmTarget)]
[llvmPasses] :: LlvmConfig -> [(Int, String)]
data LlvmTarget
LlvmTarget :: String -> String -> [String] -> LlvmTarget
[lDataLayout] :: LlvmTarget -> String
[lCPU] :: LlvmTarget -> String
[lAttributes] :: LlvmTarget -> [String]
initLlvmConfig :: FilePath -> IO LlvmConfig
newtype LlvmVersion
LlvmVersion :: NonEmpty Int -> LlvmVersion
[llvmVersionNE] :: LlvmVersion -> NonEmpty Int

-- | The (inclusive) lower bound on the LLVM Version that is currently
--   supported.
supportedLlvmVersionLowerBound :: LlvmVersion

-- | The (not-inclusive) upper bound bound on the LLVM Version that is
--   currently supported.
supportedLlvmVersionUpperBound :: LlvmVersion
parseLlvmVersion :: String -> Maybe LlvmVersion
llvmVersionSupported :: LlvmVersion -> Bool
llvmVersionStr :: LlvmVersion -> String
llvmVersionList :: LlvmVersion -> [Int]
instance GHC.Classes.Ord GHC.CmmToLlvm.Config.LlvmVersion
instance GHC.Classes.Eq GHC.CmmToLlvm.Config.LlvmVersion


-- | LLVM config cache
module GHC.Driver.LlvmConfigCache

-- | Cache LLVM configuration read from files in top_dir
--   
--   See Note [LLVM configuration] in GHC.CmmToLlvm.Config
--   
--   Currently implemented with unsafe lazy IO. But it could be implemented
--   with an IORef as the exposed interface is in IO.
data LlvmConfigCache
initLlvmConfigCache :: FilePath -> IO LlvmConfigCache
readLlvmConfigCache :: LlvmConfigCache -> IO LlvmConfig

module GHC.Cmm.Type
data CmmType
b8 :: CmmType
b16 :: CmmType
b32 :: CmmType
b64 :: CmmType
b128 :: CmmType
b256 :: CmmType
b512 :: CmmType
f32 :: CmmType
f64 :: CmmType
bWord :: Platform -> CmmType
bHalfWord :: Platform -> CmmType
gcWord :: Platform -> CmmType
cInt :: Platform -> CmmType
cmmBits :: Width -> CmmType
cmmFloat :: Width -> CmmType
typeWidth :: CmmType -> Width
cmmEqType :: CmmType -> CmmType -> Bool
cmmEqType_ignoring_ptrhood :: CmmType -> CmmType -> Bool
isFloatType :: CmmType -> Bool
isGcPtrType :: CmmType -> Bool
isBitsType :: CmmType -> Bool
isWordAny :: CmmType -> Bool
isWord32 :: CmmType -> Bool
isWord64 :: CmmType -> Bool
isFloat64 :: CmmType -> Bool
isFloat32 :: CmmType -> Bool
data Width
W8 :: Width
W16 :: Width
W32 :: Width
W64 :: Width
W128 :: Width
W256 :: Width
W512 :: Width

-- | A width in bits.
widthInBits :: Width -> Int

-- | A width in bytes.
--   
--   <pre>
--   widthFromBytes (widthInBytes w) === w
--   </pre>
widthInBytes :: Width -> Int

-- | log_2 of the width in bytes, useful for generating shifts.
widthInLog :: Width -> Int

-- | <ul>
--   <li>Partial* A width from the number of bytes.</li>
--   </ul>
widthFromBytes :: Int -> Width

-- | The width of the current platform's word size.
wordWidth :: Platform -> Width

-- | The width of the current platform's half-word size.
halfWordWidth :: Platform -> Width
cIntWidth :: Platform -> Width

-- | A bit-mask for the lower half-word of current platform.
halfWordMask :: Platform -> Integer

-- | Narrow a signed or unsigned value to the given width. The result will
--   reside in <tt>[0, +2^width)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; narrowU W8 256    == 256
--   
--   &gt;&gt;&gt; narrowU W8 255    == 255
--   
--   &gt;&gt;&gt; narrowU W8 128    == 128
--   
--   &gt;&gt;&gt; narrowU W8 127    == 127
--   
--   &gt;&gt;&gt; narrowU W8 0      == 0
--   
--   &gt;&gt;&gt; narrowU W8 (-127) == 129
--   
--   &gt;&gt;&gt; narrowU W8 (-128) == 128
--   
--   &gt;&gt;&gt; narrowU W8 (-129) == 127
--   
--   &gt;&gt;&gt; narrowU W8 (-255) == 1
--   
--   &gt;&gt;&gt; narrowU W8 (-256) == 0
--   </pre>
narrowU :: Width -> Integer -> Integer

-- | Narrow a signed value to the given width. The result will reside in
--   <tt>[-2^(width-1), +2^(width-1))</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; narrowS W8 256    == 0
--   
--   &gt;&gt;&gt; narrowS W8 255    == -1
--   
--   &gt;&gt;&gt; narrowS W8 128    == -128
--   
--   &gt;&gt;&gt; narrowS W8 127    == 127
--   
--   &gt;&gt;&gt; narrowS W8 0      == 0
--   
--   &gt;&gt;&gt; narrowS W8 (-127) == -127
--   
--   &gt;&gt;&gt; narrowS W8 (-128) == -128
--   
--   &gt;&gt;&gt; narrowS W8 (-129) == 127
--   
--   &gt;&gt;&gt; narrowS W8 (-255) == 1
--   
--   &gt;&gt;&gt; narrowS W8 (-256) == 0
--   </pre>
narrowS :: Width -> Integer -> Integer
rEP_CostCentreStack_mem_alloc :: Platform -> CmmType
rEP_CostCentreStack_scc_count :: Platform -> CmmType
rEP_StgEntCounter_allocs :: Platform -> CmmType
rEP_StgEntCounter_allocd :: Platform -> CmmType
data ForeignHint
NoHint :: ForeignHint
AddrHint :: ForeignHint
SignedHint :: ForeignHint
type Length = Int
vec :: Length -> CmmType -> CmmType
vec2 :: CmmType -> CmmType
vec4 :: CmmType -> CmmType
vec8 :: CmmType -> CmmType
vec16 :: CmmType -> CmmType
vec2f64 :: CmmType
vec2b64 :: CmmType
vec4f32 :: CmmType
vec4b32 :: CmmType
vec8b16 :: CmmType
vec16b8 :: CmmType
cmmVec :: Int -> CmmType -> CmmType
vecLength :: CmmType -> Length
vecElemType :: CmmType -> CmmType
isVecType :: CmmType -> Bool

-- | is <tt>-falignment-sanitisation</tt> enabled?
type DoAlignSanitisation = Bool
instance GHC.Show.Show GHC.Cmm.Type.Width
instance GHC.Classes.Ord GHC.Cmm.Type.Width
instance GHC.Classes.Eq GHC.Cmm.Type.Width
instance GHC.Show.Show GHC.Cmm.Type.CmmCat
instance GHC.Classes.Eq GHC.Cmm.Type.CmmCat
instance GHC.Show.Show GHC.Cmm.Type.CmmType
instance GHC.Classes.Eq GHC.Cmm.Type.ForeignHint
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.ForeignHint
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.CmmType
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.CmmCat
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Type.Width


-- | Native code generator configuration
module GHC.CmmToAsm.Config

-- | Native code generator configuration
data NCGConfig
NCGConfig :: !Platform -> !SDocContext -> !Module -> !Maybe Int -> !Bool -> !Bool -> !Word -> !Word -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> Maybe SseVersion -> Maybe BmiVersion -> !Bool -> !Bool -> !Bool -> !Weights -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> NCGConfig

-- | Target platform
[ncgPlatform] :: NCGConfig -> !Platform

-- | Context for ASM code generation
[ncgAsmContext] :: NCGConfig -> !SDocContext

-- | The name of the module we are currently compiling
[ncgThisModule] :: NCGConfig -> !Module

-- | Mandatory proc alignment
[ncgProcAlignment] :: NCGConfig -> !Maybe Int

-- | Generate code to link against dynamic libraries
[ncgExternalDynamicRefs] :: NCGConfig -> !Bool

-- | Enable Position-Independent Code
[ncgPIC] :: NCGConfig -> !Bool

-- | If inlining <tt>memcpy</tt> produces less than this threshold (in
--   pseudo-instruction unit), do it
[ncgInlineThresholdMemcpy] :: NCGConfig -> !Word

-- | Ditto for <tt>memset</tt>
[ncgInlineThresholdMemset] :: NCGConfig -> !Word

-- | Split sections
[ncgSplitSections] :: NCGConfig -> !Bool
[ncgRegsIterative] :: NCGConfig -> !Bool
[ncgRegsGraph] :: NCGConfig -> !Bool

-- | Perform ASM linting pass
[ncgAsmLinting] :: NCGConfig -> !Bool

-- | Perform CMM constant folding
[ncgDoConstantFolding] :: NCGConfig -> !Bool

-- | (x86) SSE instructions
[ncgSseVersion] :: NCGConfig -> Maybe SseVersion

-- | (x86) BMI instructions
[ncgBmiVersion] :: NCGConfig -> Maybe BmiVersion
[ncgDumpRegAllocStages] :: NCGConfig -> !Bool
[ncgDumpAsmStats] :: NCGConfig -> !Bool
[ncgDumpAsmConflicts] :: NCGConfig -> !Bool

-- | CFG edge weights
[ncgCfgWeights] :: NCGConfig -> !Weights

-- | Use CFG based block layout algorithm
[ncgCfgBlockLayout] :: NCGConfig -> !Bool

-- | Layout based on last instruction per block.
[ncgCfgWeightlessLayout] :: NCGConfig -> !Bool

-- | Enable Dwarf generation
[ncgDwarfEnabled] :: NCGConfig -> !Bool

-- | Enable unwindings
[ncgDwarfUnwindings] :: NCGConfig -> !Bool

-- | Strip out block information from generated Dwarf
[ncgDwarfStripBlockInfo] :: NCGConfig -> !Bool

-- | Expose symbol table entries for internal symbols
[ncgExposeInternalSymbols] :: NCGConfig -> !Bool

-- | Enable GHC-specific source note DIEs
[ncgDwarfSourceNotes] :: NCGConfig -> !Bool

-- | Enable static control-flow prediction
[ncgCmmStaticPred] :: NCGConfig -> !Bool

-- | Enable shortcutting (don't jump to blocks only containing a jump)
[ncgEnableShortcutting] :: NCGConfig -> !Bool

-- | Compute block unwinding tables
[ncgComputeUnwinding] :: NCGConfig -> !Bool

-- | Whether to enable the dead-code elimination
[ncgEnableDeadCodeElimination] :: NCGConfig -> !Bool

-- | Return Word size
ncgWordWidth :: NCGConfig -> Width

-- | Size in bytes of the pre-allocated spill space on the C stack
ncgSpillPreallocSize :: NCGConfig -> Int

-- | Return Word size
platformWordWidth :: Platform -> Width

module GHC.Cmm.Reg
data CmmReg
CmmLocal :: {-# UNPACK #-} !LocalReg -> CmmReg
CmmGlobal :: GlobalReg -> CmmReg
cmmRegType :: Platform -> CmmReg -> CmmType
cmmRegWidth :: Platform -> CmmReg -> Width
data LocalReg

-- | Parameters: 1. Identifier 2. Type
LocalReg :: {-# UNPACK #-} !Unique -> !CmmType -> LocalReg
localRegType :: LocalReg -> CmmType
data GlobalReg
VanillaReg :: {-# UNPACK #-} !Int -> VGcPtr -> GlobalReg
FloatReg :: {-# UNPACK #-} !Int -> GlobalReg
DoubleReg :: {-# UNPACK #-} !Int -> GlobalReg
LongReg :: {-# UNPACK #-} !Int -> GlobalReg
XmmReg :: {-# UNPACK #-} !Int -> GlobalReg
YmmReg :: {-# UNPACK #-} !Int -> GlobalReg
ZmmReg :: {-# UNPACK #-} !Int -> GlobalReg
Sp :: GlobalReg
SpLim :: GlobalReg
Hp :: GlobalReg
HpLim :: GlobalReg
CCCS :: GlobalReg
CurrentTSO :: GlobalReg
CurrentNursery :: GlobalReg
HpAlloc :: GlobalReg
EagerBlackholeInfo :: GlobalReg
GCEnter1 :: GlobalReg
GCFun :: GlobalReg
BaseReg :: GlobalReg
MachSp :: GlobalReg
UnwindReturnReg :: GlobalReg
PicBaseReg :: GlobalReg
isArgReg :: GlobalReg -> Bool
globalRegType :: Platform -> GlobalReg -> CmmType
pprGlobalReg :: IsLine doc => GlobalReg -> doc
spReg :: CmmReg
hpReg :: CmmReg
spLimReg :: CmmReg
hpLimReg :: CmmReg
nodeReg :: CmmReg
currentTSOReg :: CmmReg
currentNurseryReg :: CmmReg
hpAllocReg :: CmmReg
cccsReg :: CmmReg
node :: GlobalReg
baseReg :: CmmReg
data VGcPtr
VGcPtr :: VGcPtr
VNonGcPtr :: VGcPtr
instance GHC.Show.Show GHC.Cmm.Reg.LocalReg
instance GHC.Show.Show GHC.Cmm.Reg.VGcPtr
instance GHC.Classes.Eq GHC.Cmm.Reg.VGcPtr
instance GHC.Show.Show GHC.Cmm.Reg.GlobalReg
instance GHC.Show.Show GHC.Cmm.Reg.CmmReg
instance GHC.Classes.Ord GHC.Cmm.Reg.CmmReg
instance GHC.Classes.Eq GHC.Cmm.Reg.CmmReg
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Reg.CmmReg
instance GHC.Classes.Eq GHC.Cmm.Reg.GlobalReg
instance GHC.Classes.Ord GHC.Cmm.Reg.GlobalReg
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Reg.GlobalReg
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.Reg.GlobalReg
instance GHC.Classes.Eq GHC.Cmm.Reg.LocalReg
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Reg.LocalReg
instance GHC.Classes.Ord GHC.Cmm.Reg.LocalReg
instance GHC.Types.Unique.Uniquable GHC.Cmm.Reg.LocalReg

module GHC.Cmm.MachOp

-- | Machine-level primops; ones which we can reasonably delegate to the
--   native code generators to handle.
--   
--   Most operations are parameterised by the <a>Width</a> that they
--   operate on. Some operations have separate signed and unsigned
--   versions, and float and integer versions.
--   
--   Note that there are variety of places in the native code generator
--   where we assume that the code produced for a MachOp does not introduce
--   new blocks.
data MachOp
MO_Add :: Width -> MachOp
MO_Sub :: Width -> MachOp
MO_Eq :: Width -> MachOp
MO_Ne :: Width -> MachOp
MO_Mul :: Width -> MachOp
MO_S_MulMayOflo :: Width -> MachOp
MO_S_Quot :: Width -> MachOp
MO_S_Rem :: Width -> MachOp
MO_S_Neg :: Width -> MachOp
MO_U_Quot :: Width -> MachOp
MO_U_Rem :: Width -> MachOp
MO_S_Ge :: Width -> MachOp
MO_S_Le :: Width -> MachOp
MO_S_Gt :: Width -> MachOp
MO_S_Lt :: Width -> MachOp
MO_U_Ge :: Width -> MachOp
MO_U_Le :: Width -> MachOp
MO_U_Gt :: Width -> MachOp
MO_U_Lt :: Width -> MachOp
MO_F_Add :: Width -> MachOp
MO_F_Sub :: Width -> MachOp
MO_F_Neg :: Width -> MachOp
MO_F_Mul :: Width -> MachOp
MO_F_Quot :: Width -> MachOp
MO_F_Eq :: Width -> MachOp
MO_F_Ne :: Width -> MachOp
MO_F_Ge :: Width -> MachOp
MO_F_Le :: Width -> MachOp
MO_F_Gt :: Width -> MachOp
MO_F_Lt :: Width -> MachOp
MO_And :: Width -> MachOp
MO_Or :: Width -> MachOp
MO_Xor :: Width -> MachOp
MO_Not :: Width -> MachOp
MO_Shl :: Width -> MachOp
MO_U_Shr :: Width -> MachOp
MO_S_Shr :: Width -> MachOp
MO_SF_Conv :: Width -> Width -> MachOp
MO_FS_Conv :: Width -> Width -> MachOp
MO_SS_Conv :: Width -> Width -> MachOp
MO_UU_Conv :: Width -> Width -> MachOp
MO_XX_Conv :: Width -> Width -> MachOp
MO_FF_Conv :: Width -> Width -> MachOp
MO_V_Insert :: Length -> Width -> MachOp
MO_V_Extract :: Length -> Width -> MachOp
MO_V_Add :: Length -> Width -> MachOp
MO_V_Sub :: Length -> Width -> MachOp
MO_V_Mul :: Length -> Width -> MachOp
MO_VS_Quot :: Length -> Width -> MachOp
MO_VS_Rem :: Length -> Width -> MachOp
MO_VS_Neg :: Length -> Width -> MachOp
MO_VU_Quot :: Length -> Width -> MachOp
MO_VU_Rem :: Length -> Width -> MachOp
MO_VF_Insert :: Length -> Width -> MachOp
MO_VF_Extract :: Length -> Width -> MachOp
MO_VF_Add :: Length -> Width -> MachOp
MO_VF_Sub :: Length -> Width -> MachOp
MO_VF_Neg :: Length -> Width -> MachOp
MO_VF_Mul :: Length -> Width -> MachOp
MO_VF_Quot :: Length -> Width -> MachOp
MO_AlignmentCheck :: Int -> Width -> MachOp
pprMachOp :: MachOp -> SDoc

-- | Returns <a>True</a> if the MachOp has commutable arguments. This is
--   used in the platform-independent Cmm optimisations.
--   
--   If in doubt, return <a>False</a>. This generates worse code on the
--   native routes, but is otherwise harmless.
isCommutableMachOp :: MachOp -> Bool

-- | Returns <a>True</a> if the MachOp is associative (i.e. <tt>(x+y)+z ==
--   x+(y+z)</tt>) This is used in the platform-independent Cmm
--   optimisations.
--   
--   If in doubt, return <a>False</a>. This generates worse code on the
--   native routes, but is otherwise harmless.
isAssociativeMachOp :: MachOp -> Bool

-- | Returns <a>True</a> if the MachOp is a comparison.
--   
--   If in doubt, return False. This generates worse code on the native
--   routes, but is otherwise harmless.
isComparisonMachOp :: MachOp -> Bool

-- | Returns <tt>Just w</tt> if the operation is an integer comparison with
--   width <tt>w</tt>, or <tt>Nothing</tt> otherwise.
maybeIntComparison :: MachOp -> Maybe Width

-- | Returns the MachRep of the result of a MachOp.
machOpResultType :: Platform -> MachOp -> [CmmType] -> CmmType

-- | This function is used for debugging only: we can check whether an
--   application of a MachOp is "type-correct" by checking that the
--   MachReps of its arguments are the same as the MachOp expects. This is
--   used when linting a CmmExpr.
machOpArgReps :: Platform -> MachOp -> [Width]
maybeInvertComparison :: MachOp -> Maybe MachOp
isFloatComparison :: MachOp -> Bool
mo_wordAdd :: Platform -> MachOp
mo_wordSub :: Platform -> MachOp
mo_wordEq :: Platform -> MachOp
mo_wordNe :: Platform -> MachOp
mo_wordMul :: Platform -> MachOp
mo_wordSQuot :: Platform -> MachOp
mo_wordSRem :: Platform -> MachOp
mo_wordSNeg :: Platform -> MachOp
mo_wordUQuot :: Platform -> MachOp
mo_wordURem :: Platform -> MachOp
mo_wordSGe :: Platform -> MachOp
mo_wordSLe :: Platform -> MachOp
mo_wordSGt :: Platform -> MachOp
mo_wordSLt :: Platform -> MachOp
mo_wordUGe :: Platform -> MachOp
mo_wordULe :: Platform -> MachOp
mo_wordUGt :: Platform -> MachOp
mo_wordULt :: Platform -> MachOp
mo_wordAnd :: Platform -> MachOp
mo_wordOr :: Platform -> MachOp
mo_wordXor :: Platform -> MachOp
mo_wordNot :: Platform -> MachOp
mo_wordShl :: Platform -> MachOp
mo_wordSShr :: Platform -> MachOp
mo_wordUShr :: Platform -> MachOp
mo_u_8To32 :: MachOp
mo_s_8To32 :: MachOp
mo_u_16To32 :: MachOp
mo_s_16To32 :: MachOp
mo_u_8ToWord :: Platform -> MachOp
mo_s_8ToWord :: Platform -> MachOp
mo_u_16ToWord :: Platform -> MachOp
mo_s_16ToWord :: Platform -> MachOp
mo_u_32ToWord :: Platform -> MachOp
mo_s_32ToWord :: Platform -> MachOp
mo_32To8 :: MachOp
mo_32To16 :: MachOp
mo_WordTo8 :: Platform -> MachOp
mo_WordTo16 :: Platform -> MachOp
mo_WordTo32 :: Platform -> MachOp
mo_WordTo64 :: Platform -> MachOp
data CallishMachOp
MO_F64_Pwr :: CallishMachOp
MO_F64_Sin :: CallishMachOp
MO_F64_Cos :: CallishMachOp
MO_F64_Tan :: CallishMachOp
MO_F64_Sinh :: CallishMachOp
MO_F64_Cosh :: CallishMachOp
MO_F64_Tanh :: CallishMachOp
MO_F64_Asin :: CallishMachOp
MO_F64_Acos :: CallishMachOp
MO_F64_Atan :: CallishMachOp
MO_F64_Asinh :: CallishMachOp
MO_F64_Acosh :: CallishMachOp
MO_F64_Atanh :: CallishMachOp
MO_F64_Log :: CallishMachOp
MO_F64_Log1P :: CallishMachOp
MO_F64_Exp :: CallishMachOp
MO_F64_ExpM1 :: CallishMachOp
MO_F64_Fabs :: CallishMachOp
MO_F64_Sqrt :: CallishMachOp
MO_F32_Pwr :: CallishMachOp
MO_F32_Sin :: CallishMachOp
MO_F32_Cos :: CallishMachOp
MO_F32_Tan :: CallishMachOp
MO_F32_Sinh :: CallishMachOp
MO_F32_Cosh :: CallishMachOp
MO_F32_Tanh :: CallishMachOp
MO_F32_Asin :: CallishMachOp
MO_F32_Acos :: CallishMachOp
MO_F32_Atan :: CallishMachOp
MO_F32_Asinh :: CallishMachOp
MO_F32_Acosh :: CallishMachOp
MO_F32_Atanh :: CallishMachOp
MO_F32_Log :: CallishMachOp
MO_F32_Log1P :: CallishMachOp
MO_F32_Exp :: CallishMachOp
MO_F32_ExpM1 :: CallishMachOp
MO_F32_Fabs :: CallishMachOp
MO_F32_Sqrt :: CallishMachOp
MO_I64_ToI :: CallishMachOp
MO_I64_FromI :: CallishMachOp
MO_W64_ToW :: CallishMachOp
MO_W64_FromW :: CallishMachOp
MO_x64_Neg :: CallishMachOp
MO_x64_Add :: CallishMachOp
MO_x64_Sub :: CallishMachOp
MO_x64_Mul :: CallishMachOp
MO_I64_Quot :: CallishMachOp
MO_I64_Rem :: CallishMachOp
MO_W64_Quot :: CallishMachOp
MO_W64_Rem :: CallishMachOp
MO_x64_And :: CallishMachOp
MO_x64_Or :: CallishMachOp
MO_x64_Xor :: CallishMachOp
MO_x64_Not :: CallishMachOp
MO_x64_Shl :: CallishMachOp
MO_I64_Shr :: CallishMachOp
MO_W64_Shr :: CallishMachOp
MO_x64_Eq :: CallishMachOp
MO_x64_Ne :: CallishMachOp
MO_I64_Ge :: CallishMachOp
MO_I64_Gt :: CallishMachOp
MO_I64_Le :: CallishMachOp
MO_I64_Lt :: CallishMachOp
MO_W64_Ge :: CallishMachOp
MO_W64_Gt :: CallishMachOp
MO_W64_Le :: CallishMachOp
MO_W64_Lt :: CallishMachOp
MO_UF_Conv :: Width -> CallishMachOp
MO_S_Mul2 :: Width -> CallishMachOp
MO_S_QuotRem :: Width -> CallishMachOp
MO_U_QuotRem :: Width -> CallishMachOp
MO_U_QuotRem2 :: Width -> CallishMachOp
MO_Add2 :: Width -> CallishMachOp
MO_AddWordC :: Width -> CallishMachOp
MO_SubWordC :: Width -> CallishMachOp
MO_AddIntC :: Width -> CallishMachOp
MO_SubIntC :: Width -> CallishMachOp
MO_U_Mul2 :: Width -> CallishMachOp
MO_ReadBarrier :: CallishMachOp
MO_WriteBarrier :: CallishMachOp
MO_Touch :: CallishMachOp
MO_Prefetch_Data :: Int -> CallishMachOp
MO_Memcpy :: Int -> CallishMachOp
MO_Memset :: Int -> CallishMachOp
MO_Memmove :: Int -> CallishMachOp
MO_Memcmp :: Int -> CallishMachOp
MO_PopCnt :: Width -> CallishMachOp
MO_Pdep :: Width -> CallishMachOp
MO_Pext :: Width -> CallishMachOp
MO_Clz :: Width -> CallishMachOp
MO_Ctz :: Width -> CallishMachOp
MO_BSwap :: Width -> CallishMachOp
MO_BRev :: Width -> CallishMachOp

-- | Atomic read-modify-write. Arguments are <tt>[dest, n]</tt>.
MO_AtomicRMW :: Width -> AtomicMachOp -> CallishMachOp

-- | Atomic read. Arguments are <tt>[addr]</tt>.
MO_AtomicRead :: Width -> MemoryOrdering -> CallishMachOp

-- | Atomic write. Arguments are <tt>[addr, value]</tt>.
MO_AtomicWrite :: Width -> MemoryOrdering -> CallishMachOp

-- | Atomic compare-and-swap. Arguments are <tt>[dest, expected, new]</tt>.
--   Sequentially consistent. Possible future refactoring: should this be
--   an<a>MO_AtomicRMW</a> variant?
MO_Cmpxchg :: Width -> CallishMachOp

-- | Atomic swap. Arguments are <tt>[dest, new]</tt>
MO_Xchg :: Width -> CallishMachOp
MO_SuspendThread :: CallishMachOp
MO_ResumeThread :: CallishMachOp

-- | Return (results_hints,args_hints)
callishMachOpHints :: CallishMachOp -> ([ForeignHint], [ForeignHint])
pprCallishMachOp :: CallishMachOp -> SDoc

-- | The alignment of a <tt>memcpy</tt>-ish operation.
machOpMemcpyishAlign :: CallishMachOp -> Maybe Int

-- | C11 memory ordering semantics.
data MemoryOrdering

-- | relaxed ordering
MemOrderRelaxed :: MemoryOrdering

-- | acquire ordering
MemOrderAcquire :: MemoryOrdering

-- | release ordering
MemOrderRelease :: MemoryOrdering

-- | sequentially consistent
MemOrderSeqCst :: MemoryOrdering

-- | The operation to perform atomically.
data AtomicMachOp
AMO_Add :: AtomicMachOp
AMO_Sub :: AtomicMachOp
AMO_And :: AtomicMachOp
AMO_Nand :: AtomicMachOp
AMO_Or :: AtomicMachOp
AMO_Xor :: AtomicMachOp
instance GHC.Show.Show GHC.Cmm.MachOp.MachOp
instance GHC.Classes.Eq GHC.Cmm.MachOp.MachOp
instance GHC.Show.Show GHC.Cmm.MachOp.MemoryOrdering
instance GHC.Classes.Ord GHC.Cmm.MachOp.MemoryOrdering
instance GHC.Classes.Eq GHC.Cmm.MachOp.MemoryOrdering
instance GHC.Show.Show GHC.Cmm.MachOp.AtomicMachOp
instance GHC.Classes.Eq GHC.Cmm.MachOp.AtomicMachOp
instance GHC.Show.Show GHC.Cmm.MachOp.CallishMachOp
instance GHC.Classes.Eq GHC.Cmm.MachOp.CallishMachOp


-- | Generating C symbol names emitted by the compiler.
module GHC.CmmToAsm.CPrim
atomicReadLabel :: Width -> FastString
atomicWriteLabel :: Width -> FastString
atomicRMWLabel :: Width -> AtomicMachOp -> FastString
cmpxchgLabel :: Width -> FastString
xchgLabel :: Width -> FastString
popCntLabel :: Width -> FastString
pdepLabel :: Width -> FastString
pextLabel :: Width -> FastString
bSwapLabel :: Width -> FastString
bRevLabel :: Width -> FastString
clzLabel :: Width -> FastString
ctzLabel :: Width -> FastString
word2FloatLabel :: Width -> FastString


-- | Cmm compilation configuration
module GHC.Cmm.Config
data CmmConfig
CmmConfig :: !Profile -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> CmmConfig

-- | Target Profile
[cmmProfile] :: CmmConfig -> !Profile

-- | Optimize Cmm Control Flow or not
[cmmOptControlFlow] :: CmmConfig -> !Bool

-- | Do Cmm Linting Optimization or not
[cmmDoLinting] :: CmmConfig -> !Bool

-- | Eliminate common blocks or not
[cmmOptElimCommonBlks] :: CmmConfig -> !Bool

-- | Perform sink after stack layout or not
[cmmOptSink] :: CmmConfig -> !Bool

-- | Instrument memory accesses for ThreadSanitizer
[cmmOptThreadSanitizer] :: CmmConfig -> !Bool

-- | Generate stack unwinding instructions (for debugging)
[cmmGenStackUnwindInstr] :: CmmConfig -> !Bool

-- | Generate code to link against dynamic libraries
[cmmExternalDynamicRefs] :: CmmConfig -> !Bool

-- | Should the Cmm pass replace Stg switch statements
[cmmDoCmmSwitchPlans] :: CmmConfig -> !Bool

-- | Should Cmm split proc points or not
[cmmSplitProcPoints] :: CmmConfig -> !Bool

-- | retrieve the target Cmm platform
cmmPlatform :: CmmConfig -> Platform


-- | Foreign export stubs
module GHC.Types.ForeignStubs

-- | Foreign export stubs
data ForeignStubs

-- | We don't have any stubs
NoStubs :: ForeignStubs

-- | There are some stubs. Parameters:
--   
--   1) Header file prototypes for "foreign exported" functions
--   
--   2) C stubs to use when calling "foreign exported" functions
ForeignStubs :: CHeader -> CStub -> ForeignStubs
newtype CHeader
CHeader :: SDoc -> CHeader
[getCHeader] :: CHeader -> SDoc
data CStub
CStub :: SDoc -> [CLabel] -> [CLabel] -> CStub
[getCStub] :: CStub -> SDoc

-- | Initializers to be run at startup See Note [Initializers and
--   finalizers in Cmm] in <a>GHC.Cmm.InitFini</a>.
[getInitializers] :: CStub -> [CLabel]

-- | Finalizers to be run at shutdown
[getFinalizers] :: CStub -> [CLabel]

-- | <tt>initializerCStub fn_nm decls body</tt> is a <a>CStub</a>
--   containing C initializer function (e.g. an entry of the
--   <tt>.init_array</tt> section) named <tt>fn_nm</tt> with the given body
--   and the given set of declarations.
initializerCStub :: Platform -> CLabel -> SDoc -> SDoc -> CStub

-- | <tt>finalizerCStub fn_nm decls body</tt> is a <a>CStub</a> containing
--   C finalizer function (e.g. an entry of the <tt>.fini_array</tt>
--   section) named <tt>fn_nm</tt> with the given body and the given set of
--   declarations.
finalizerCStub :: Platform -> CLabel -> SDoc -> SDoc -> CStub
appendStubC :: ForeignStubs -> CStub -> ForeignStubs
instance GHC.Base.Monoid GHC.Types.ForeignStubs.CHeader
instance GHC.Base.Semigroup GHC.Types.ForeignStubs.CHeader
instance GHC.Base.Monoid GHC.Types.ForeignStubs.CStub
instance GHC.Base.Semigroup GHC.Types.ForeignStubs.CStub


-- | This is where we define a mapping from Uniques to their associated
--   known-key Names for things associated with tuples and sums. We use
--   this mapping while deserializing known-key Names in interface file
--   symbol tables, which are encoded as their Unique. See Note [Symbol
--   table representation of names] for details.
module GHC.Builtin.Uniques

-- | Get the <a>Name</a> associated with a known-key <a>Unique</a>.
knownUniqueName :: Unique -> Maybe Name
mkSumTyConUnique :: Arity -> Unique
mkSumDataConUnique :: ConTagZ -> Arity -> Unique
mkTupleTyConUnique :: Boxity -> Arity -> Unique
mkTupleDataConUnique :: Boxity -> Arity -> Unique
mkCTupleTyConUnique :: Arity -> Unique
mkCTupleDataConUnique :: Arity -> Unique
mkCTupleSelIdUnique :: ConTagZ -> Arity -> Unique
mkAlphaTyVarUnique :: Int -> Unique
mkPrimOpIdUnique :: Int -> Unique
mkPrimOpWrapperUnique :: Int -> Unique
mkPreludeMiscIdUnique :: Int -> Unique
mkPreludeDataConUnique :: Int -> Unique
mkPreludeTyConUnique :: Int -> Unique
mkPreludeClassUnique :: Int -> Unique
mkVarOccUnique :: FastString -> Unique
mkDataOccUnique :: FastString -> Unique
mkTvOccUnique :: FastString -> Unique
mkTcOccUnique :: FastString -> Unique
mkRegSingleUnique :: Int -> Unique
mkRegPairUnique :: Int -> Unique
mkRegClassUnique :: Int -> Unique
mkRegSubUnique :: Int -> Unique
mkCostCentreUnique :: Int -> Unique
mkBuiltinUnique :: Int -> Unique
mkPseudoUniqueE :: Int -> Unique
tyConRepNameUnique :: Unique -> Unique
dataConWorkerUnique :: Unique -> Unique
dataConTyRepNameUnique :: Unique -> Unique
initExitJoinUnique :: Unique
mkBoxingTyConUnique :: Int -> Unique
boxingDataConUnique :: Unique -> Unique


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a> represents names as strings with just a little more
--   information: the "namespace" that the name came from, e.g. the
--   namespace of value, type constructors or data constructors</li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
module GHC.Types.Name.Occurrence
data NameSpace
tcName :: NameSpace
clsName :: NameSpace
tcClsName :: NameSpace
dataName :: NameSpace
varName :: NameSpace
tvName :: NameSpace
srcDataName :: NameSpace
pprNameSpace :: NameSpace -> SDoc
pprNonVarNameSpace :: NameSpace -> SDoc
pprNameSpaceBrief :: IsLine doc => NameSpace -> doc

-- | Occurrence Name
--   
--   In this context that means: "classified (i.e. as a type name, value
--   name, etc) but not qualified and not yet resolved"
data OccName
pprOccName :: IsLine doc => OccName -> doc
mkOccName :: NameSpace -> String -> OccName
mkOccNameFS :: NameSpace -> FastString -> OccName
mkVarOcc :: String -> OccName
mkVarOccFS :: FastString -> OccName
mkDataOcc :: String -> OccName
mkDataOccFS :: FastString -> OccName
mkTyVarOcc :: String -> OccName
mkTyVarOccFS :: FastString -> OccName
mkTcOcc :: String -> OccName
mkTcOccFS :: FastString -> OccName
mkClsOcc :: String -> OccName
mkClsOccFS :: FastString -> OccName
mkDFunOcc :: String -> Bool -> OccSet -> OccName
setOccNameSpace :: NameSpace -> OccName -> OccName
demoteOccName :: OccName -> Maybe OccName
promoteOccName :: OccName -> Maybe OccName

-- | Other names in the compiler add additional information to an OccName.
--   This class provides a consistent way to access the underlying OccName.
class HasOccName name
occName :: HasOccName name => name -> OccName

-- | Test for definitions internally generated by GHC. This predicate is
--   used to suppress printing of internal definitions in some debug prints
isDerivedOccName :: OccName -> Bool
mkDataConWrapperOcc :: OccName -> OccName
mkWorkerOcc :: OccName -> OccName
mkMatcherOcc :: OccName -> OccName
mkBuilderOcc :: OccName -> OccName
mkDefaultMethodOcc :: OccName -> OccName
isDefaultMethodOcc :: OccName -> Bool

-- | Is an <a>OccName</a> one of a Typeable <tt>TyCon</tt> or
--   <tt>Module</tt> binding? This is needed as these bindings are renamed
--   differently. See Note [Grand plan for Typeable] in
--   <a>GHC.Tc.Instance.Typeable</a>.
isTypeableBindOcc :: OccName -> Bool
mkNewTyCoOcc :: OccName -> OccName
mkClassOpAuxOcc :: OccName -> OccName
mkCon2TagOcc :: OccName -> OccName
mkTag2ConOcc :: OccName -> OccName
mkMaxTagOcc :: OccName -> OccName
mkClassDataConOcc :: OccName -> OccName
mkDictOcc :: OccName -> OccName
mkIPOcc :: OccName -> OccName
mkSpecOcc :: OccName -> OccName
mkForeignExportOcc :: OccName -> OccName
mkRepEqOcc :: OccName -> OccName
mkGenR :: OccName -> OccName
mkGen1R :: OccName -> OccName
mkDataTOcc :: OccName -> OccName
mkDataCOcc :: OccName -> OccName
mkDataConWorkerOcc :: OccName -> OccName
mkSuperDictSelOcc :: Int -> OccName -> OccName
mkSuperDictAuxOcc :: Int -> OccName -> OccName
mkLocalOcc :: Unique -> OccName -> OccName
mkMethodOcc :: OccName -> OccName

-- | Derive a name for the representation type constructor of a
--   <tt>data</tt>/<tt>newtype</tt> instance.
mkInstTyTcOcc :: String -> OccSet -> OccName
mkInstTyCoOcc :: OccName -> OccName
mkEqPredCoOcc :: OccName -> OccName
mkRecFldSelOcc :: FastString -> OccName
mkTyConRepOcc :: OccName -> OccName
occNameFS :: OccName -> FastString
occNameString :: OccName -> String
occNameSpace :: OccName -> NameSpace
isVarOcc :: OccName -> Bool
isTvOcc :: OccName -> Bool
isTcOcc :: OccName -> Bool
isDataOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is a data constructor that starts with a
--   symbol (e.g. <tt>:</tt>, or <tt>[]</tt>)
isDataSymOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is that for any operator (whether it is a
--   data constructor or variable or whatever)
isSymOcc :: OccName -> Bool

-- | <i>Value</i> <tt>OccNames</tt>s are those that are either in the
--   variable or data constructor namespaces
isValOcc :: OccName -> Bool

-- | Wrap parens around an operator
parenSymOcc :: OccName -> SDoc -> SDoc

-- | Haskell 98 encourages compilers to suppress warnings about unused
--   names in a pattern if they start with <tt>_</tt>: this implements that
--   test
startsWithUnderscore :: OccName -> Bool
isTcClsNameSpace :: NameSpace -> Bool
isTvNameSpace :: NameSpace -> Bool
isDataConNameSpace :: NameSpace -> Bool
isVarNameSpace :: NameSpace -> Bool
isValNameSpace :: NameSpace -> Bool
data OccEnv a
emptyOccEnv :: OccEnv a
unitOccEnv :: OccName -> a -> OccEnv a
extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
mapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b
lookupOccEnv :: OccEnv a -> OccName -> Maybe a
mkOccEnv :: [(OccName, a)] -> OccEnv a
mkOccEnv_C :: (a -> a -> a) -> [(OccName, a)] -> OccEnv a
extendOccEnvList :: OccEnv a -> [(OccName, a)] -> OccEnv a
elemOccEnv :: OccName -> OccEnv a -> Bool
nonDetOccEnvElts :: OccEnv a -> [a]
foldOccEnv :: (a -> b -> b) -> b -> OccEnv a -> b
plusOccEnv :: OccEnv a -> OccEnv a -> OccEnv a
plusOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccEnv a -> OccEnv a
extendOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccName -> a -> OccEnv a
extendOccEnv_Acc :: (a -> b -> b) -> (a -> b) -> OccEnv b -> OccName -> a -> OccEnv b
filterOccEnv :: (elt -> Bool) -> OccEnv elt -> OccEnv elt
delListFromOccEnv :: OccEnv a -> [OccName] -> OccEnv a
delFromOccEnv :: OccEnv a -> OccName -> OccEnv a
alterOccEnv :: (Maybe elt -> Maybe elt) -> OccEnv elt -> OccName -> OccEnv elt
minusOccEnv :: OccEnv a -> OccEnv b -> OccEnv a

-- | Alters (replaces or removes) those elements of the map that are
--   mentioned in the second map
minusOccEnv_C :: (a -> b -> Maybe a) -> OccEnv a -> OccEnv b -> OccEnv a
pprOccEnv :: (a -> SDoc) -> OccEnv a -> SDoc
type OccSet = UniqSet OccName
emptyOccSet :: OccSet
unitOccSet :: OccName -> OccSet
mkOccSet :: [OccName] -> OccSet
extendOccSet :: OccSet -> OccName -> OccSet
extendOccSetList :: OccSet -> [OccName] -> OccSet
unionOccSets :: OccSet -> OccSet -> OccSet
unionManyOccSets :: [OccSet] -> OccSet
minusOccSet :: OccSet -> OccSet -> OccSet
elemOccSet :: OccName -> OccSet -> Bool
isEmptyOccSet :: OccSet -> Bool
intersectOccSet :: OccSet -> OccSet -> OccSet
filterOccSet :: (OccName -> Bool) -> OccSet -> OccSet

-- | Converts an OccSet to an OccEnv (operationally the identity)
occSetToEnv :: OccSet -> OccEnv OccName
type TidyOccEnv = UniqFM FastString Int
emptyTidyOccEnv :: TidyOccEnv
initTidyOccEnv :: [OccName] -> TidyOccEnv
tidyOccName :: TidyOccEnv -> OccName -> (TidyOccEnv, OccName)
avoidClashesOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
delTidyOccEnvList :: TidyOccEnv -> [FastString] -> TidyOccEnv

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a
emptyFsEnv :: FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
instance GHC.Classes.Ord GHC.Types.Name.Occurrence.NameSpace
instance GHC.Classes.Eq GHC.Types.Name.Occurrence.NameSpace
instance Data.Data.Data a => Data.Data.Data (GHC.Types.Name.Occurrence.OccEnv a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.Name.Occurrence.OccEnv a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Types.Name.Occurrence.OccEnv a)
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Occurrence.OccName
instance GHC.Classes.Eq GHC.Types.Name.Occurrence.OccName
instance GHC.Classes.Ord GHC.Types.Name.Occurrence.OccName
instance Data.Data.Data GHC.Types.Name.Occurrence.OccName
instance Control.DeepSeq.NFData GHC.Types.Name.Occurrence.OccName
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Occurrence.OccName
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Name.Occurrence.OccName
instance GHC.Types.Unique.Uniquable GHC.Types.Name.Occurrence.OccName
instance GHC.Utils.Binary.Binary GHC.Types.Name.Occurrence.OccName
instance GHC.Utils.Binary.Binary GHC.Types.Name.Occurrence.NameSpace


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a> is the type of names that have had their scoping and
--   binding resolved. They have an <a>OccName</a> but also a <a>Unique</a>
--   that disambiguates Names that have the same <a>OccName</a> and indeed
--   is used for all <a>Name</a> comparison. Names also contain information
--   about where they originated from, see
--   <a>GHC.Types.Name#name_sorts</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
--   
--   Names are one of:
--   
--   <ul>
--   <li>External, if they name things declared in other modules. Some
--   external Names are wired in, i.e. they name primitives defined in the
--   compiler itself</li>
--   <li>Internal, if they name things in the module being compiled. Some
--   internal Names are system names, if they are names manufactured by the
--   compiler</li>
--   </ul>
module GHC.Types.Name

-- | A unique, unambiguous name for something, containing information about
--   where that thing originated.
data Name

-- | BuiltInSyntax is for things like <tt>(:)</tt>, <tt>[]</tt> and tuples,
--   which have special syntactic forms. They aren't in scope as such.
data BuiltInSyntax
BuiltInSyntax :: BuiltInSyntax
UserSyntax :: BuiltInSyntax

-- | Create a name brought into being by the compiler
mkSystemName :: Unique -> OccName -> Name
mkSystemNameAt :: Unique -> OccName -> SrcSpan -> Name

-- | Create a name which is (for now at least) local to the current module
--   and hence does not need a <a>GenModule</a> to disambiguate it from
--   other <a>Name</a>s
mkInternalName :: Unique -> OccName -> SrcSpan -> Name
mkClonedInternalName :: Unique -> Name -> Name
mkDerivedInternalName :: (OccName -> OccName) -> Unique -> Name -> Name
mkSystemVarName :: Unique -> FastString -> Name
mkSysTvName :: Unique -> FastString -> Name

-- | Make a name for a foreign call
mkFCallName :: Unique -> FastString -> Name

-- | Create a name which definitely originates in the given module
mkExternalName :: Unique -> Module -> OccName -> SrcSpan -> Name

-- | Create a name which is actually defined by the compiler itself
mkWiredInName :: Module -> OccName -> Unique -> TyThing -> BuiltInSyntax -> Name
nameUnique :: Name -> Unique
setNameUnique :: Name -> Unique -> Name
nameOccName :: Name -> OccName
nameNameSpace :: Name -> NameSpace
nameModule :: HasDebugCallStack => Name -> Module
nameModule_maybe :: Name -> Maybe Module
setNameLoc :: Name -> SrcSpan -> Name
tidyNameOcc :: Name -> OccName -> Name

-- | Make the <a>Name</a> into an internal name, regardless of what it was
--   to begin with
localiseName :: Name -> Name
namePun_maybe :: Name -> Maybe FastString
pprName :: forall doc. IsLine doc => Name -> doc
nameSrcLoc :: Name -> SrcLoc
nameSrcSpan :: Name -> SrcSpan
pprNameDefnLoc :: Name -> SDoc
pprDefinedAt :: Name -> SDoc

-- | Print fully qualified name (with unit-id, module and unique)
pprFullName :: Module -> Name -> SDoc

-- | Print a ticky ticky styled name
--   
--   Module argument is the module to use for internal and system names.
--   When printing the name in a ticky profile, the module name is included
--   even for local things. However, ticky uses the format "x (M)" rather
--   than "M.x". Hence, this function provides a separation from normal
--   styling.
pprTickyName :: Module -> Name -> SDoc
isSystemName :: Name -> Bool
isInternalName :: Name -> Bool
isExternalName :: Name -> Bool
isTyVarName :: Name -> Bool
isTyConName :: Name -> Bool
isDataConName :: Name -> Bool
isValName :: Name -> Bool
isVarName :: Name -> Bool

-- | Will the <a>Name</a> come from a dynamically linked package?
isDynLinkName :: Platform -> Module -> Name -> Bool
isWiredInName :: Name -> Bool
isWiredIn :: NamedThing thing => thing -> Bool
isBuiltInSyntax :: Name -> Bool
isHoleName :: Name -> Bool
wiredInNameTyThing_maybe :: Name -> Maybe TyThing

-- | Returns True if the name is (a) Internal (b) External but from the
--   specified module (c) External but from the <tt>interactive</tt>
--   package
--   
--   The key idea is that False means: the entity is defined in some other
--   module you can find the details (type, fixity, instances) in some
--   interface file those details will be stored in the EPT or HPT
--   
--   True means: the entity is defined in this module or earlier in the
--   GHCi session you can find details (type, fixity, instances) in the
--   TcGblEnv or TcLclEnv
--   
--   The isInteractiveModule part is because successive interactions of a
--   GHCi session each give rise to a fresh module (Ghci1, Ghci2, etc), but
--   they all come from the magic <tt>interactive</tt> package; and all the
--   details are kept in the TcLclEnv, TcGblEnv, NOT in the HPT or EPT. See
--   Note [The interactive package] in <a>GHC.Runtime.Context</a>
nameIsLocalOrFrom :: Module -> Name -> Bool

-- | Returns True if the name is external or from the <tt>interactive</tt>
--   package See documentation of <a>nameIsLocalOrFrom</a> function
nameIsExternalOrFrom :: Module -> Name -> Bool
nameIsHomePackage :: Module -> Name -> Bool
nameIsHomePackageImport :: Module -> Name -> Bool

-- | Returns True if the Name comes from some other package: neither this
--   package nor the interactive package.
nameIsFromExternalPackage :: HomeUnit -> Name -> Bool

-- | Compare Names lexicographically This only works for Names that
--   originate in the source code or have been tidied.
stableNameCmp :: Name -> Name -> Ordering

-- | A class allowing convenient access to the <a>Name</a> of various
--   datatypes
class NamedThing a
getOccName :: NamedThing a => a -> OccName
getName :: NamedThing a => a -> Name
getSrcLoc :: NamedThing a => a -> SrcLoc
getSrcSpan :: NamedThing a => a -> SrcSpan
getOccString :: NamedThing a => a -> String
getOccFS :: NamedThing a => a -> FastString
pprInfixName :: (Outputable a, NamedThing a) => a -> SDoc
pprPrefixName :: NamedThing a => a -> SDoc
pprModulePrefix :: IsLine doc => PprStyle -> Module -> OccName -> doc

-- | Print the string of Name unqualifiedly directly.
pprNameUnqualified :: Name -> SDoc

-- | Get a string representation of a <a>Name</a> that's unique and stable
--   across recompilations. Used for deterministic generation of binds for
--   derived instances. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal$String"
nameStableString :: Name -> String
instance GHC.Types.Name.NamedThing GHC.Types.Name.Name
instance GHC.Types.Name.NamedThing e => GHC.Types.Name.NamedThing (GHC.Types.SrcLoc.Located e)
instance Control.DeepSeq.NFData GHC.Types.Name.Name
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Name
instance GHC.Classes.Eq GHC.Types.Name.Name
instance GHC.Classes.Ord GHC.Types.Name.Name
instance GHC.Types.Unique.Uniquable GHC.Types.Name.Name
instance Data.Data.Data GHC.Types.Name.Name
instance GHC.Utils.Binary.Binary GHC.Types.Name.Name
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Name
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Name.Name
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.NameSort
instance Control.DeepSeq.NFData GHC.Types.Name.NameSort


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a> is a synonym for the <a>Id</a> type but it may
--   additionally potentially contain type variables, which have a
--   <a>Kind</a> rather than a <a>Type</a> and only contain some extra
--   details during typechecking.</li>
--   </ul>
--   
--   These <a>Var</a> names may either be global or local, see
--   <a>GHC.Types.Var#globalvslocal</a>
--   
--   Global <a>Var</a>s and <a>Var</a>s are those that are imported or
--   correspond to a data constructor, primitive operation, or record
--   selectors. Local <a>Var</a>s and <a>Var</a>s are those bound within an
--   expression (e.g. by a lambda) or at the top level of the module being
--   compiled.
module GHC.Types.Var

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Coercion Variable
type CoVar = Id

-- | Identifier
type Id = Var

type NcId = Id

-- | Dictionary Identifier
type DictId = EvId

-- | Dictionary Function Identifier
type DFunId = Id

-- | Evidence Variable
type EvVar = EvId

-- | Equality Variable
type EqVar = EvId

-- | Evidence Identifier
type EvId = Id

-- | Implicit parameter Identifier
type IpId = EvId
type JoinId = Id

-- | Type or kind Variable
type TyVar = Var

-- | Type variable that might be a metavariable
type TcTyVar = Var

-- | Type Variable
type TypeVar = Var

-- | Kind Variable
type KindVar = Var

-- | Type or Kind Variable
type TKVar = Var

-- | Type or Coercion Variable
type TyCoVar = Id
type InVar = Var
type InCoVar = CoVar
type InId = Id
type InTyVar = TyVar
type OutVar = Var
type OutCoVar = CoVar
type OutId = Id
type OutTyVar = TyVar
varName :: Var -> Name
varUnique :: Var -> Unique

-- | The type or kind of the <a>Var</a> in question
varType :: Var -> Kind
varMult :: Var -> Mult
varMultMaybe :: Id -> Maybe Mult
setVarName :: Var -> Name -> Var
setVarUnique :: Var -> Unique -> Var
setVarType :: Var -> Type -> Var

-- | Update a <a>Var</a>s type. Does not update the <i>multiplicity</i>
--   stored in an <a>Var</a>, if any. Because of the possibility for abuse,
--   ASSERTs that there is no multiplicity to update.
updateVarType :: (Type -> Type) -> Var -> Var

-- | Update a <a>Var</a>s type monadically. Does not update the
--   <i>multiplicity</i> stored in an <a>Var</a>, if any. Because of the
--   possibility for abuse, ASSERTs that there is no multiplicity to
--   update.
updateVarTypeM :: Monad m => (Type -> m Type) -> Var -> m Var
mkGlobalVar :: IdDetails -> Name -> Type -> IdInfo -> Id
mkLocalVar :: IdDetails -> Name -> Mult -> Type -> IdInfo -> Id

-- | Exported <a>Var</a>s will not be removed as dead code
mkExportedLocalVar :: IdDetails -> Name -> Type -> IdInfo -> Id
mkCoVar :: Name -> Type -> CoVar
idInfo :: HasDebugCallStack => Id -> IdInfo
idDetails :: Id -> IdDetails
lazySetIdInfo :: Id -> IdInfo -> Var
setIdDetails :: Id -> IdDetails -> Id

-- | If it's a local, make it global
globaliseId :: Id -> Id

-- | Exports the given local <a>Var</a>. Can also be called on global
--   <a>Var</a>s, such as data constructors and class operations, which are
--   born as global <a>Var</a>s and automatically exported
setIdExported :: Id -> Id

-- | We can only do this to LocalIds
setIdNotExported :: Id -> Id
setIdMult :: Id -> Mult -> Id
updateIdTypeButNotMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMultM :: Monad m => (Type -> m Type) -> Id -> m Id

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Var</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool

-- | Is this a type-level (i.e., computationally irrelevant, thus erasable)
--   variable? Satisfies <tt>isTyVar = not . isId</tt>.
isTyVar :: Var -> Bool
isTcTyVar :: Var -> Bool

-- | <a>isLocalVar</a> returns <tt>True</tt> for type variables as well as
--   local <a>Var</a>s These are the variables that we need to pay
--   attention to when finding free variables, or doing dependency
--   analysis.
isLocalVar :: Var -> Bool
isLocalId :: Var -> Bool

-- | Is this a coercion variable? Satisfies <tt><a>isId</a> v ==&gt;
--   <a>isCoVar</a> v == not (<a>isNonCoVarId</a> v)</tt>.
isCoVar :: Var -> Bool

-- | Is this a term variable (<a>Var</a>) that is <i>not</i> a coercion
--   variable? Satisfies <tt><a>isId</a> v ==&gt; <a>isCoVar</a> v == not
--   (<a>isNonCoVarId</a> v)</tt>.
isNonCoVarId :: Var -> Bool
isTyCoVar :: Var -> Bool
isGlobalId :: Var -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool

-- | <a>mustHaveLocalBinding</a> returns <tt>True</tt> of <a>Var</a>s and
--   <a>Var</a>s that must have a binding in this module. The converse is
--   not quite right: there are some global <a>Var</a>s that must have
--   bindings, such as record selectors. But that doesn't matter, because
--   it's only used for assertions
mustHaveLocalBinding :: Var -> Bool

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Specified :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag

-- | Whether an <a>Invisible</a> argument may appear in source Haskell.
data Specificity

-- | the argument may not appear in source Haskell, it is only inferred.
InferredSpec :: Specificity

-- | the argument may appear in source Haskell, but isn't required.
SpecifiedSpec :: Specificity

-- | Does this <a>ForAllTyFlag</a> classify an argument that is written in
--   Haskell?
isVisibleForAllTyFlag :: ForAllTyFlag -> Bool

-- | Does this <a>ForAllTyFlag</a> classify an argument that is not written
--   in Haskell?
isInvisibleForAllTyFlag :: ForAllTyFlag -> Bool
isInferredForAllTyFlag :: ForAllTyFlag -> Bool

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag
isVisibleFunArg :: FunTyFlag -> Bool
isInvisibleFunArg :: FunTyFlag -> Bool
isFUNArg :: FunTyFlag -> Bool
mkFunTyFlag :: TypeOrConstraint -> TypeOrConstraint -> FunTyFlag
visArg :: TypeOrConstraint -> FunTyFlag
invisArg :: TypeOrConstraint -> FunTyFlag
visArgTypeLike :: FunTyFlag
visArgConstraintLike :: FunTyFlag
invisArgTypeLike :: FunTyFlag
invisArgConstraintLike :: FunTyFlag
funTyFlagArgTypeOrConstraint :: FunTyFlag -> TypeOrConstraint
funTyFlagResultTypeOrConstraint :: FunTyFlag -> TypeOrConstraint
data TypeOrConstraint
TypeLike :: TypeOrConstraint
ConstraintLike :: TypeOrConstraint

-- | A <a>PiTyBinder</a> represents an argument to a function. PiTyBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [PiTyBinders]
data PiTyBinder
Named :: ForAllTyBinder -> PiTyBinder
Anon :: Scaled Type -> FunTyFlag -> PiTyBinder

-- | <a>PiTyVarBinder</a> is like <a>PiTyBinder</a>, but there can only be
--   <a>Var</a> in the <a>Named</a> field.
type PiTyVarBinder = PiTyBinder

-- | Does this binder bind an invisible argument?
isInvisiblePiTyBinder :: PiTyBinder -> Bool

-- | Does this binder bind a visible argument?
isVisiblePiTyBinder :: PiTyBinder -> Bool

-- | If its a named binder, is the binder a tyvar? Returns True for
--   nondependent binder. This check that we're really returning a
--   *Ty*Binder (as opposed to a coercion binder). That way, if/when we
--   allow coercion quantification in more places, we'll know we missed
--   updating some function.
isTyBinder :: PiTyBinder -> Bool
isNamedPiTyBinder :: PiTyBinder -> Bool

-- | Does this binder bind a variable that is <i>not</i> erased? Returns
--   <a>True</a> for anonymous binders.
isAnonPiTyBinder :: PiTyBinder -> Bool
namedPiTyBinder_maybe :: PiTyBinder -> Maybe TyCoVar

-- | Extract a relevant type, if there is one.
anonPiTyBinderType_maybe :: PiTyBinder -> Maybe Type
piTyBinderType :: PiTyBinder -> Type
data VarBndr var argf
Bndr :: var -> argf -> VarBndr var argf

-- | Variable Binder
--   
--   A <a>ForAllTyBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in
--   <a>GHC.Core.TyCo.Rep</a>, because it's used in
--   GHC.Core.DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type ForAllTyBinder = VarBndr TyCoVar ForAllTyFlag
type TyVarBinder = VarBndr TyVar ForAllTyFlag
type InvisTyBinder = VarBndr TyCoVar Specificity
type InvisTVBinder = VarBndr TyVar Specificity
type ReqTyBinder = VarBndr TyCoVar ()
type ReqTVBinder = VarBndr TyVar ()
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]
binderFlag :: VarBndr tv argf -> argf
binderFlags :: [VarBndr tv argf] -> [argf]
binderType :: VarBndr TyCoVar argf -> Type

-- | Make a named binder
mkForAllTyBinder :: vis -> TyCoVar -> VarBndr TyCoVar vis

-- | Make many named binders
mkForAllTyBinders :: vis -> [TyCoVar] -> [VarBndr TyCoVar vis]

-- | Make a named binder <tt>var</tt> should be a type variable
mkTyVarBinder :: vis -> TyVar -> VarBndr TyVar vis

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: vis -> [TyVar] -> [VarBndr TyVar vis]
isTyVarBinder :: VarBndr TyCoVar vis -> Bool
tyVarSpecToBinder :: VarBndr a Specificity -> VarBndr a ForAllTyFlag
tyVarSpecToBinders :: [VarBndr a Specificity] -> [VarBndr a ForAllTyFlag]
tyVarReqToBinder :: VarBndr a () -> VarBndr a ForAllTyFlag
tyVarReqToBinders :: [VarBndr a ()] -> [VarBndr a ForAllTyFlag]
mapVarBndr :: (var -> var') -> VarBndr var flag -> VarBndr var' flag
mapVarBndrs :: (var -> var') -> [VarBndr var flag] -> [VarBndr var' flag]
mkTyVar :: Name -> Kind -> TyVar
mkTcTyVar :: Name -> Kind -> TcTyVarDetails -> TyVar
tyVarName :: TyVar -> Name
tyVarKind :: TyVar -> Kind
tcTyVarDetails :: TyVar -> TcTyVarDetails
setTcTyVarDetails :: TyVar -> TcTyVarDetails -> TyVar
setTyVarName :: TyVar -> Name -> TyVar
setTyVarUnique :: TyVar -> Unique -> TyVar
setTyVarKind :: TyVar -> Kind -> TyVar
updateTyVarKind :: (Kind -> Kind) -> TyVar -> TyVar
updateTyVarKindM :: Monad m => (Kind -> m Kind) -> TyVar -> m TyVar

-- | Compare Vars by their Uniques. This is what Ord Var does, provided
--   here to make it explicit at the call-site that it can introduce
--   non-determinism. See Note [Unique Determinism]
nonDetCmpVar :: Var -> Var -> Ordering
instance Data.Data.Data GHC.Types.Var.Specificity
instance GHC.Classes.Ord GHC.Types.Var.Specificity
instance GHC.Classes.Eq GHC.Types.Var.Specificity
instance Data.Data.Data GHC.Types.Var.ForAllTyFlag
instance GHC.Classes.Ord GHC.Types.Var.ForAllTyFlag
instance GHC.Classes.Eq GHC.Types.Var.ForAllTyFlag
instance Data.Data.Data GHC.Types.Var.FunTyFlag
instance GHC.Classes.Ord GHC.Types.Var.FunTyFlag
instance GHC.Classes.Eq GHC.Types.Var.FunTyFlag
instance (Data.Data.Data var, Data.Data.Data argf) => Data.Data.Data (GHC.Types.Var.VarBndr var argf)
instance Data.Data.Data GHC.Types.Var.PiTyBinder
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.PiTyBinder
instance GHC.Utils.Outputable.Outputable tv => GHC.Utils.Outputable.Outputable (GHC.Types.Var.VarBndr tv GHC.Types.Var.ForAllTyFlag)
instance GHC.Utils.Outputable.Outputable tv => GHC.Utils.Outputable.Outputable (GHC.Types.Var.VarBndr tv GHC.Types.Var.Specificity)
instance (GHC.Utils.Binary.Binary tv, GHC.Utils.Binary.Binary vis) => GHC.Utils.Binary.Binary (GHC.Types.Var.VarBndr tv vis)
instance GHC.Types.Name.NamedThing tv => GHC.Types.Name.NamedThing (GHC.Types.Var.VarBndr tv flag)
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.FunTyFlag
instance GHC.Utils.Binary.Binary GHC.Types.Var.FunTyFlag
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.ForAllTyFlag
instance GHC.Utils.Binary.Binary GHC.Types.Var.ForAllTyFlag
instance GHC.Utils.Binary.Binary GHC.Types.Var.Specificity
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.Var
instance GHC.Types.Name.NamedThing GHC.Types.Var.Var
instance GHC.Types.Unique.Uniquable GHC.Types.Var.Var
instance GHC.Classes.Eq GHC.Types.Var.Var
instance GHC.Classes.Ord GHC.Types.Var.Var
instance Data.Data.Data GHC.Types.Var.Var
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Var.Var

module GHC.Types.Var.Set

-- | A non-deterministic Variable Set
--   
--   A non-deterministic set of variables. See Note [Deterministic UniqFM]
--   in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DVarSet if the set eventually
--   gets converted into a list or folded over in a way where the order
--   changes the generated code, for example when abstracting variables.
type VarSet = UniqSet Var

-- | Identifier Set
type IdSet = UniqSet Id

-- | Type Variable Set
type TyVarSet = UniqSet TyVar

-- | Coercion Variable Set
type CoVarSet = UniqSet CoVar

-- | Type or Coercion Variable Set
type TyCoVarSet = UniqSet TyCoVar
emptyVarSet :: VarSet
unitVarSet :: Var -> VarSet
mkVarSet :: [Var] -> VarSet
extendVarSet :: VarSet -> Var -> VarSet
extendVarSetList :: VarSet -> [Var] -> VarSet
elemVarSet :: Var -> VarSet -> Bool
subVarSet :: VarSet -> VarSet -> Bool
unionVarSet :: VarSet -> VarSet -> VarSet
unionVarSets :: [VarSet] -> VarSet

-- | map the function over the list, and union the results
mapUnionVarSet :: (a -> VarSet) -> [a] -> VarSet
intersectVarSet :: VarSet -> VarSet -> VarSet
intersectsVarSet :: VarSet -> VarSet -> Bool
disjointVarSet :: VarSet -> VarSet -> Bool
isEmptyVarSet :: VarSet -> Bool
delVarSet :: VarSet -> Var -> VarSet
delVarSetList :: VarSet -> [Var] -> VarSet
delVarSetByKey :: VarSet -> Unique -> VarSet
minusVarSet :: VarSet -> VarSet -> VarSet
filterVarSet :: (Var -> Bool) -> VarSet -> VarSet
mapVarSet :: Uniquable b => (a -> b) -> UniqSet a -> UniqSet b
anyVarSet :: (Var -> Bool) -> VarSet -> Bool
allVarSet :: (Var -> Bool) -> VarSet -> Bool
transCloVarSet :: (VarSet -> VarSet) -> VarSet -> VarSet
fixVarSet :: (VarSet -> VarSet) -> VarSet -> VarSet
lookupVarSet_Directly :: VarSet -> Unique -> Maybe Var
lookupVarSet :: VarSet -> Var -> Maybe Var
lookupVarSetByName :: VarSet -> Name -> Maybe Var
sizeVarSet :: VarSet -> Int
seqVarSet :: VarSet -> ()
elemVarSetByKey :: Unique -> VarSet -> Bool
partitionVarSet :: (Var -> Bool) -> VarSet -> (VarSet, VarSet)

-- | Determines the pluralisation suffix appropriate for the length of a
--   set in the same way that plural from Outputable does for lists.
pluralVarSet :: VarSet -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetEltsUFM. Passing a list to the pretty-printing function allows
--   the caller to decide on the order of Vars (eg. toposort them) without
--   them having to use nonDetEltsUFM at the call site. This prevents from
--   let-binding non-deterministically ordered lists and reusing them where
--   determinism matters.
pprVarSet :: VarSet -> ([Var] -> SDoc) -> SDoc
nonDetStrictFoldVarSet :: (Var -> a -> a) -> a -> VarSet -> a

-- | Deterministic Variable Set
type DVarSet = UniqDSet Var

-- | Deterministic Identifier Set
type DIdSet = UniqDSet Id

-- | Deterministic Type Variable Set
type DTyVarSet = UniqDSet TyVar

-- | Deterministic Type or Coercion Variable Set
type DTyCoVarSet = UniqDSet TyCoVar
emptyDVarSet :: DVarSet
unitDVarSet :: Var -> DVarSet
mkDVarSet :: [Var] -> DVarSet
extendDVarSet :: DVarSet -> Var -> DVarSet

-- | Add a list of variables to DVarSet
extendDVarSetList :: DVarSet -> [Var] -> DVarSet
elemDVarSet :: Var -> DVarSet -> Bool
dVarSetElems :: DVarSet -> [Var]
subDVarSet :: DVarSet -> DVarSet -> Bool
unionDVarSet :: DVarSet -> DVarSet -> DVarSet
unionDVarSets :: [DVarSet] -> DVarSet

-- | Map the function over the list, and union the results
mapUnionDVarSet :: (a -> DVarSet) -> [a] -> DVarSet
intersectDVarSet :: DVarSet -> DVarSet -> DVarSet
dVarSetIntersectVarSet :: DVarSet -> VarSet -> DVarSet

-- | True if non-empty intersection
intersectsDVarSet :: DVarSet -> DVarSet -> Bool

-- | True if empty intersection
disjointDVarSet :: DVarSet -> DVarSet -> Bool
isEmptyDVarSet :: DVarSet -> Bool
delDVarSet :: DVarSet -> Var -> DVarSet

-- | Delete a list of variables from DVarSet
delDVarSetList :: DVarSet -> [Var] -> DVarSet
minusDVarSet :: DVarSet -> DVarSet -> DVarSet
nonDetStrictFoldDVarSet :: (Var -> a -> a) -> a -> DVarSet -> a
filterDVarSet :: (Var -> Bool) -> DVarSet -> DVarSet
mapDVarSet :: Uniquable b => (a -> b) -> UniqDSet a -> UniqDSet b
dVarSetMinusVarSet :: DVarSet -> VarSet -> DVarSet
anyDVarSet :: (Var -> Bool) -> DVarSet -> Bool
allDVarSet :: (Var -> Bool) -> DVarSet -> Bool

-- | transCloVarSet for DVarSet
transCloDVarSet :: (DVarSet -> DVarSet) -> DVarSet -> DVarSet
sizeDVarSet :: DVarSet -> Int
seqDVarSet :: DVarSet -> ()

-- | Partition DVarSet according to the predicate given
partitionDVarSet :: (Var -> Bool) -> DVarSet -> (DVarSet, DVarSet)

-- | Convert a DVarSet to a VarSet by forgetting the order of insertion
dVarSetToVarSet :: DVarSet -> VarSet


-- | Utilities for efficiently and deterministically computing free
--   variables.
module GHC.Utils.FV
type FV = InterestingVarFun -> VarSet -> VarAcc -> VarAcc

-- | Predicate on possible free variables: returns <tt>True</tt> iff the
--   variable is interesting
type InterestingVarFun = Var -> Bool

-- | Run a free variable computation, returning a list of distinct free
--   variables in deterministic order.
fvVarList :: FV -> [Var]

-- | Run a free variable computation, returning a non-deterministic set of
--   free variables. Don't use if the set will be later converted to a list
--   and the order of that list will impact the generated code.
fvVarSet :: FV -> VarSet

-- | Run a free variable computation, returning a deterministic set of free
--   variables. Note that this is just a wrapper around the version that
--   returns a deterministic list. If you need a list you should use
--   <a>fvVarList</a>.
fvDVarSet :: FV -> DVarSet

-- | Add a variable - when free, to the returned free variables. Ignores
--   duplicates and respects the filtering function.
unitFV :: Id -> FV

-- | Return no free variables.
emptyFV :: FV

-- | Add multiple variables - when free, to the returned free variables.
--   Ignores duplicates and respects the filtering function.
mkFVs :: [Var] -> FV

-- | Union two free variable computations.
unionFV :: FV -> FV -> FV

-- | Union many free variable computations.
unionsFV :: [FV] -> FV

-- | Mark the variable as not free by putting it in scope.
delFV :: Var -> FV -> FV

-- | Mark many free variables as not free.
delFVs :: VarSet -> FV -> FV

-- | Filter a free variable computation.
filterFV :: InterestingVarFun -> FV -> FV

-- | Map a free variable computation over a list and union the results.
mapUnionFV :: (a -> FV) -> [a] -> FV

module GHC.Stg.InferTags.TagSig
data TagInfo
TagDunno :: TagInfo
TagTuple :: [TagInfo] -> TagInfo
TagProper :: TagInfo
TagTagged :: TagInfo
newtype TagSig
TagSig :: TagInfo -> TagSig
isTaggedSig :: TagSig -> Bool
seqTagSig :: TagSig -> ()
seqTagInfo :: TagInfo -> ()
instance GHC.Classes.Eq GHC.Stg.InferTags.TagSig.TagInfo
instance GHC.Classes.Eq GHC.Stg.InferTags.TagSig.TagSig
instance GHC.Utils.Outputable.Outputable GHC.Stg.InferTags.TagSig.TagSig
instance GHC.Utils.Outputable.OutputableBndr (GHC.Types.Var.Id, GHC.Stg.InferTags.TagSig.TagSig)
instance GHC.Utils.Binary.Binary GHC.Stg.InferTags.TagSig.TagSig
instance GHC.Utils.Outputable.Outputable GHC.Stg.InferTags.TagSig.TagInfo
instance GHC.Utils.Binary.Binary GHC.Stg.InferTags.TagSig.TagInfo

module GHC.Data.Graph.UnVar
data UnVarSet
emptyUnVarSet :: UnVarSet
mkUnVarSet :: [Var] -> UnVarSet
unionUnVarSet :: UnVarSet -> UnVarSet -> UnVarSet
unionUnVarSets :: [UnVarSet] -> UnVarSet
extendUnVarSet :: Var -> UnVarSet -> UnVarSet
extendUnVarSetList :: [Var] -> UnVarSet -> UnVarSet
delUnVarSet :: UnVarSet -> Var -> UnVarSet
delUnVarSetList :: UnVarSet -> [Var] -> UnVarSet
elemUnVarSet :: Var -> UnVarSet -> Bool
isEmptyUnVarSet :: UnVarSet -> Bool
data UnVarGraph
emptyUnVarGraph :: UnVarGraph
unionUnVarGraph :: UnVarGraph -> UnVarGraph -> UnVarGraph
unionUnVarGraphs :: [UnVarGraph] -> UnVarGraph
completeGraph :: UnVarSet -> UnVarGraph
completeBipartiteGraph :: UnVarSet -> UnVarSet -> UnVarGraph
neighbors :: UnVarGraph -> Var -> UnVarSet
hasLoopAt :: UnVarGraph -> Var -> Bool
delNode :: UnVarGraph -> Var -> UnVarGraph
domUFMUnVarSet :: UniqFM key elt -> UnVarSet
instance GHC.Classes.Eq GHC.Data.Graph.UnVar.UnVarSet
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.UnVar.UnVarGraph
instance GHC.Utils.Outputable.Outputable GHC.Data.Graph.UnVar.UnVarSet

module GHC.Types.Var.Env

-- | Variable Environment
type VarEnv elt = UniqFM Var elt

-- | Identifier Environment
type IdEnv elt = UniqFM Id elt

-- | Type Variable Environment
type TyVarEnv elt = UniqFM Var elt

-- | Coercion Variable Environment
type CoVarEnv elt = UniqFM CoVar elt

-- | Type or Coercion Variable Environment
type TyCoVarEnv elt = UniqFM TyCoVar elt
emptyVarEnv :: VarEnv a
unitVarEnv :: Var -> a -> VarEnv a
mkVarEnv :: [(Var, a)] -> VarEnv a
mkVarEnv_Directly :: [(Unique, a)] -> VarEnv a
elemVarEnv :: Var -> VarEnv a -> Bool
disjointVarEnv :: VarEnv a -> VarEnv a -> Bool
anyVarEnv :: (elt -> Bool) -> UniqFM key elt -> Bool
extendVarEnv :: VarEnv a -> Var -> a -> VarEnv a
extendVarEnv_C :: (a -> a -> a) -> VarEnv a -> Var -> a -> VarEnv a
extendVarEnv_Acc :: (a -> b -> b) -> (a -> b) -> VarEnv b -> Var -> a -> VarEnv b
extendVarEnvList :: VarEnv a -> [(Var, a)] -> VarEnv a
plusVarEnv :: VarEnv a -> VarEnv a -> VarEnv a
plusVarEnv_C :: (a -> a -> a) -> VarEnv a -> VarEnv a -> VarEnv a
plusVarEnv_CD :: (a -> a -> a) -> VarEnv a -> a -> VarEnv a -> a -> VarEnv a
plusMaybeVarEnv_C :: (a -> a -> Maybe a) -> VarEnv a -> VarEnv a -> VarEnv a
plusVarEnvList :: [VarEnv a] -> VarEnv a
alterVarEnv :: (Maybe a -> Maybe a) -> VarEnv a -> Var -> VarEnv a
delVarEnvList :: VarEnv a -> [Var] -> VarEnv a
delVarEnv :: VarEnv a -> Var -> VarEnv a
minusVarEnv :: VarEnv a -> VarEnv b -> VarEnv a
lookupVarEnv :: VarEnv a -> Var -> Maybe a
lookupVarEnv_NF :: VarEnv a -> Var -> a
lookupWithDefaultVarEnv :: VarEnv a -> a -> Var -> a
lookupVarEnv_Directly :: VarEnv a -> Unique -> Maybe a
mapVarEnv :: (a -> b) -> VarEnv a -> VarEnv b
zipVarEnv :: [Var] -> [a] -> VarEnv a
modifyVarEnv :: (a -> a) -> VarEnv a -> Var -> VarEnv a
modifyVarEnv_Directly :: (a -> a) -> UniqFM key a -> Unique -> UniqFM key a
isEmptyVarEnv :: VarEnv a -> Bool
elemVarEnvByKey :: Unique -> VarEnv a -> Bool
filterVarEnv :: (a -> Bool) -> VarEnv a -> VarEnv a

-- | Only keep variables contained in the VarSet
restrictVarEnv :: VarEnv a -> VarSet -> VarEnv a
partitionVarEnv :: (a -> Bool) -> VarEnv a -> (VarEnv a, VarEnv a)
varEnvDomain :: VarEnv elt -> UnVarSet

-- | Deterministic Variable Environment
type DVarEnv elt = UniqDFM Var elt

-- | Deterministic Identifier Environment Sadly not always indexed by Id,
--   but it is in the common case.
type DIdEnv elt = UniqDFM Var elt

-- | Deterministic Type Variable Environment
type DTyVarEnv elt = UniqDFM TyVar elt
emptyDVarEnv :: DVarEnv a
mkDVarEnv :: [(Var, a)] -> DVarEnv a
dVarEnvElts :: DVarEnv a -> [a]
extendDVarEnv :: DVarEnv a -> Var -> a -> DVarEnv a
extendDVarEnv_C :: (a -> a -> a) -> DVarEnv a -> Var -> a -> DVarEnv a
extendDVarEnvList :: DVarEnv a -> [(Var, a)] -> DVarEnv a
lookupDVarEnv :: DVarEnv a -> Var -> Maybe a
elemDVarEnv :: Var -> DVarEnv a -> Bool
isEmptyDVarEnv :: DVarEnv a -> Bool
foldDVarEnv :: (a -> b -> b) -> b -> DVarEnv a -> b
nonDetStrictFoldDVarEnv :: (a -> b -> b) -> b -> DVarEnv a -> b
mapDVarEnv :: (a -> b) -> DVarEnv a -> DVarEnv b
filterDVarEnv :: (a -> Bool) -> DVarEnv a -> DVarEnv a
modifyDVarEnv :: (a -> a) -> DVarEnv a -> Var -> DVarEnv a
alterDVarEnv :: (Maybe a -> Maybe a) -> DVarEnv a -> Var -> DVarEnv a
plusDVarEnv :: DVarEnv a -> DVarEnv a -> DVarEnv a
plusDVarEnv_C :: (a -> a -> a) -> DVarEnv a -> DVarEnv a -> DVarEnv a
unitDVarEnv :: Var -> a -> DVarEnv a
delDVarEnv :: DVarEnv a -> Var -> DVarEnv a
delDVarEnvList :: DVarEnv a -> [Var] -> DVarEnv a
minusDVarEnv :: DVarEnv a -> DVarEnv a' -> DVarEnv a
partitionDVarEnv :: (a -> Bool) -> DVarEnv a -> (DVarEnv a, DVarEnv a)
anyDVarEnv :: (a -> Bool) -> DVarEnv a -> Bool

-- | A set of variables that are in scope at some point.
--   
--   Note that this is a <i>superset</i> of the variables that are
--   currently in scope. See Note [The InScopeSet invariant].
--   
--   "Secrets of the Glasgow Haskell Compiler inliner" Section 3.2 provides
--   the motivation for this abstraction.
newtype InScopeSet
InScope :: VarSet -> InScopeSet
emptyInScopeSet :: InScopeSet
mkInScopeSet :: VarSet -> InScopeSet
mkInScopeSetList :: [Var] -> InScopeSet
delInScopeSet :: InScopeSet -> Var -> InScopeSet
extendInScopeSet :: InScopeSet -> Var -> InScopeSet
extendInScopeSetList :: InScopeSet -> [Var] -> InScopeSet
extendInScopeSetSet :: InScopeSet -> VarSet -> InScopeSet
getInScopeVars :: InScopeSet -> VarSet

-- | Look up a variable the <a>InScopeSet</a>. This lets you map from the
--   variable's identity (unique) to its full value.
lookupInScope :: InScopeSet -> Var -> Maybe Var
lookupInScope_Directly :: InScopeSet -> Unique -> Maybe Var
unionInScope :: InScopeSet -> InScopeSet -> InScopeSet
elemInScopeSet :: Var -> InScopeSet -> Bool

-- | <tt>uniqAway in_scope v</tt> finds a unique that is not used in the
--   in-scope set, and gives that to v. See Note [Local uniques] and Note
--   [The InScopeSet invariant].
uniqAway :: InScopeSet -> Var -> Var
varSetInScope :: VarSet -> InScopeSet -> Bool

-- | <tt>unsafeGetFreshUnique in_scope</tt> finds a unique that is not
--   in-scope in the given <a>InScopeSet</a>. This must be used very
--   carefully since one can very easily introduce non-unique
--   <a>Unique</a>s this way. See Note [Local uniques].
unsafeGetFreshLocalUnique :: InScopeSet -> Unique

-- | Rename Environment 2
--   
--   When we are comparing (or matching) types or terms, we are faced with
--   "going under" corresponding binders. E.g. when comparing:
--   
--   <pre>
--   \x. e1     ~   \y. e2
--   </pre>
--   
--   Basically we want to rename [<tt>x</tt> -&gt; <tt>y</tt>] or
--   [<tt>y</tt> -&gt; <tt>x</tt>], but there are lots of things we must be
--   careful of. In particular, <tt>x</tt> might be free in <tt>e2</tt>, or
--   y in <tt>e1</tt>. So the idea is that we come up with a fresh binder
--   that is free in neither, and rename <tt>x</tt> and <tt>y</tt>
--   respectively. That means we must maintain:
--   
--   <ol>
--   <li>A renaming for the left-hand expression</li>
--   <li>A renaming for the right-hand expressions</li>
--   <li>An in-scope set</li>
--   </ol>
--   
--   Furthermore, when matching, we want to be able to have an 'occurs
--   check', to prevent:
--   
--   <pre>
--   \x. f   ~   \y. y
--   </pre>
--   
--   matching with [<tt>f</tt> -&gt; <tt>y</tt>]. So for each expression we
--   want to know that set of locally-bound variables. That is precisely
--   the domain of the mappings 1. and 2., but we must ensure that we
--   always extend the mappings as we go in.
--   
--   All of this information is bundled up in the <a>RnEnv2</a>
data RnEnv2
mkRnEnv2 :: InScopeSet -> RnEnv2

-- | <tt>rnBndr2 env bL bR</tt> goes under a binder <tt>bL</tt> in the Left
--   term, and binder <tt>bR</tt> in the Right term. It finds a new binder,
--   <tt>new_b</tt>, and returns an environment mapping <tt>bL -&gt;
--   new_b</tt> and <tt>bR -&gt; new_b</tt>
rnBndr2 :: RnEnv2 -> Var -> Var -> RnEnv2

-- | Applies <a>rnBndr2</a> to several variables: the two variable lists
--   must be of equal length
rnBndrs2 :: RnEnv2 -> [Var] -> [Var] -> RnEnv2

-- | Similar to <a>rnBndr2</a> but returns the new variable as well as the
--   new environment
rnBndr2_var :: RnEnv2 -> Var -> Var -> (RnEnv2, Var)

-- | Look up the renaming of an occurrence in the left or right term
rnOccL :: RnEnv2 -> Var -> Var

-- | Look up the renaming of an occurrence in the left or right term
rnOccR :: RnEnv2 -> Var -> Var

-- | Tells whether a variable is locally bound
inRnEnvL :: RnEnv2 -> Var -> Bool

-- | Tells whether a variable is locally bound
inRnEnvR :: RnEnv2 -> Var -> Bool

-- | `anyInRnEnvR env set` == `any (inRnEnvR rn_env) (toList set)` but lazy
--   in the second argument if the right side of the env is empty.
anyInRnEnvR :: RnEnv2 -> VarSet -> Bool

-- | Look up the renaming of an occurrence in the left or right term
rnOccL_maybe :: RnEnv2 -> Var -> Maybe Var

-- | Look up the renaming of an occurrence in the left or right term
rnOccR_maybe :: RnEnv2 -> Var -> Maybe Var

-- | Similar to <a>rnBndr2</a> but used when there's a binder on the left
--   side only.
rnBndrL :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Similar to <a>rnBndr2</a> but used when there's a binder on the right
--   side only.
rnBndrR :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Wipe the left or right side renaming
nukeRnEnvL :: RnEnv2 -> RnEnv2

-- | Wipe the left or right side renaming
nukeRnEnvR :: RnEnv2 -> RnEnv2

-- | swap the meaning of left and right
rnSwap :: RnEnv2 -> RnEnv2
delBndrL :: RnEnv2 -> Var -> RnEnv2
delBndrR :: RnEnv2 -> Var -> RnEnv2
delBndrsL :: RnEnv2 -> [Var] -> RnEnv2
delBndrsR :: RnEnv2 -> [Var] -> RnEnv2
extendRnInScopeSetList :: RnEnv2 -> [Var] -> RnEnv2

-- | Similar to <a>rnBndrL</a> but used for eta expansion See Note [Eta
--   expansion]
rnEtaL :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Similar to <a>rnBndr2</a> but used for eta expansion See Note [Eta
--   expansion]
rnEtaR :: RnEnv2 -> Var -> (RnEnv2, Var)
rnInScope :: Var -> RnEnv2 -> Bool
rnInScopeSet :: RnEnv2 -> InScopeSet
lookupRnInScope :: RnEnv2 -> Var -> Var

-- | Retrieve the left mapping
rnEnvL :: RnEnv2 -> VarEnv Var

-- | Retrieve the right mapping
rnEnvR :: RnEnv2 -> VarEnv Var

-- | Tidy Environment
--   
--   When tidying up print names, we keep a mapping of in-scope occ-names
--   (the <a>TidyOccEnv</a>) and a Var-to-Var of the current renamings
type TidyEnv = (TidyOccEnv, VarEnv Var)
emptyTidyEnv :: TidyEnv
mkEmptyTidyEnv :: TidyOccEnv -> TidyEnv
delTidyEnvList :: TidyEnv -> [Var] -> TidyEnv
instance GHC.Utils.Outputable.Outputable GHC.Types.Var.Env.InScopeSet

module GHC.Types.Name.Set
type NameSet = UniqSet Name
emptyNameSet :: NameSet
unitNameSet :: Name -> NameSet
mkNameSet :: [Name] -> NameSet
unionNameSet :: NameSet -> NameSet -> NameSet
unionNameSets :: [NameSet] -> NameSet
minusNameSet :: NameSet -> NameSet -> NameSet
elemNameSet :: Name -> NameSet -> Bool
extendNameSet :: NameSet -> Name -> NameSet
extendNameSetList :: NameSet -> [Name] -> NameSet
delFromNameSet :: NameSet -> Name -> NameSet
delListFromNameSet :: NameSet -> [Name] -> NameSet
isEmptyNameSet :: NameSet -> Bool
filterNameSet :: (Name -> Bool) -> NameSet -> NameSet
intersectsNameSet :: NameSet -> NameSet -> Bool

-- | True if there is a non-empty intersection. <tt>s1
--   <a>intersectsNameSet</a> s2</tt> doesn't compute <tt>s2</tt> if
--   <tt>s1</tt> is empty
disjointNameSet :: NameSet -> NameSet -> Bool
intersectNameSet :: NameSet -> NameSet -> NameSet
nameSetAny :: (Name -> Bool) -> NameSet -> Bool
nameSetAll :: (Name -> Bool) -> NameSet -> Bool

-- | Get the elements of a NameSet with some stable ordering. This only
--   works for Names that originate in the source code or have been tidied.
--   See Note [Deterministic UniqFM] to learn about nondeterminism
nameSetElemsStable :: NameSet -> [Name]
type FreeVars = NameSet
isEmptyFVs :: NameSet -> Bool
emptyFVs :: FreeVars
plusFVs :: [FreeVars] -> FreeVars
plusFV :: FreeVars -> FreeVars -> FreeVars
mkFVs :: [Name] -> FreeVars
addOneFV :: FreeVars -> Name -> FreeVars
unitFV :: Name -> FreeVars
delFV :: Name -> FreeVars -> FreeVars
delFVs :: [Name] -> FreeVars -> FreeVars
intersectFVs :: FreeVars -> FreeVars -> FreeVars

-- | A set of names that are defined somewhere
type Defs = NameSet

-- | A set of names that are used somewhere
type Uses = NameSet

-- | <tt>(Just ds, us) =&gt;</tt> The use of any member of the <tt>ds</tt>
--   implies that all the <tt>us</tt> are used too. Also, <tt>us</tt> may
--   mention <tt>ds</tt>.
--   
--   <tt>Nothing =&gt;</tt> Nothing is defined in this group, but
--   nevertheless all the uses are essential. Used for instance
--   declarations, for example
type DefUse = (Maybe Defs, Uses)

-- | A number of <a>DefUse</a>s in dependency order: earlier <a>Defs</a>
--   scope over later <a>Uses</a> In a single (def, use) pair, the defs
--   also scope over the uses
type DefUses = OrdList DefUse
emptyDUs :: DefUses
usesOnly :: Uses -> DefUses
mkDUs :: [(Defs, Uses)] -> DefUses
plusDU :: DefUses -> DefUses -> DefUses

-- | Given some <a>DefUses</a> and some <a>Uses</a>, find all the uses,
--   transitively. The result is a superset of the input <a>Uses</a>; and
--   includes things defined in the input <a>DefUses</a> (but only if they
--   are used)
findUses :: DefUses -> Uses -> Uses
duDefs :: DefUses -> Defs

-- | Collect all <a>Uses</a>, regardless of whether the group is itself
--   used, but remove <a>Defs</a> on the way
duUses :: DefUses -> Uses

-- | Just like <a>duUses</a>, but <a>Defs</a> are not eliminated from the
--   <a>Uses</a> returned
allUses :: DefUses -> Uses

-- | <tt>Id</tt>s which have no CAF references. This is a result of
--   analysis of C--. It is always safe to use an empty <a>NonCaffySet</a>.
--   TODO Refer to Note.
newtype NonCaffySet
NonCaffySet :: NameSet -> NonCaffySet
[ncs_nameSet] :: NonCaffySet -> NameSet
instance GHC.Base.Monoid GHC.Types.Name.Set.NonCaffySet
instance GHC.Base.Semigroup GHC.Types.Name.Set.NonCaffySet

module GHC.Types.Name.Env

-- | Name Environment
type NameEnv a = UniqFM Name a
mkNameEnv :: [(Name, a)] -> NameEnv a
mkNameEnvWith :: (a -> Name) -> [a] -> NameEnv a
emptyNameEnv :: NameEnv a
isEmptyNameEnv :: NameEnv a -> Bool
unitNameEnv :: Name -> a -> NameEnv a
nonDetNameEnvElts :: NameEnv a -> [a]
extendNameEnv_C :: (a -> a -> a) -> NameEnv a -> Name -> a -> NameEnv a
extendNameEnv_Acc :: (a -> b -> b) -> (a -> b) -> NameEnv b -> Name -> a -> NameEnv b
extendNameEnv :: NameEnv a -> Name -> a -> NameEnv a
extendNameEnvList :: NameEnv a -> [(Name, a)] -> NameEnv a
extendNameEnvList_C :: (a -> a -> a) -> NameEnv a -> [(Name, a)] -> NameEnv a
filterNameEnv :: (elt -> Bool) -> NameEnv elt -> NameEnv elt
mapMaybeNameEnv :: (a -> Maybe b) -> NameEnv a -> NameEnv b
anyNameEnv :: (elt -> Bool) -> NameEnv elt -> Bool
plusNameEnv :: NameEnv a -> NameEnv a -> NameEnv a
plusNameEnv_C :: (a -> a -> a) -> NameEnv a -> NameEnv a -> NameEnv a
plusNameEnv_CD :: (a -> a -> a) -> NameEnv a -> a -> NameEnv a -> a -> NameEnv a
plusNameEnv_CD2 :: (Maybe a -> Maybe a -> a) -> NameEnv a -> NameEnv a -> NameEnv a
alterNameEnv :: (Maybe a -> Maybe a) -> NameEnv a -> Name -> NameEnv a
lookupNameEnv :: NameEnv a -> Name -> Maybe a
lookupNameEnv_NF :: NameEnv a -> Name -> a
delFromNameEnv :: NameEnv a -> Name -> NameEnv a
delListFromNameEnv :: NameEnv a -> [Name] -> NameEnv a
elemNameEnv :: Name -> NameEnv a -> Bool
mapNameEnv :: (elt1 -> elt2) -> NameEnv elt1 -> NameEnv elt2
disjointNameEnv :: NameEnv a -> NameEnv a -> Bool
seqEltsNameEnv :: (elt -> ()) -> NameEnv elt -> ()

-- | Deterministic Name Environment
--   
--   See Note [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> for
--   explanation why we need DNameEnv.
type DNameEnv a = UniqDFM Name a
emptyDNameEnv :: DNameEnv a
isEmptyDNameEnv :: DNameEnv a -> Bool
lookupDNameEnv :: DNameEnv a -> Name -> Maybe a
delFromDNameEnv :: DNameEnv a -> Name -> DNameEnv a
filterDNameEnv :: (a -> Bool) -> DNameEnv a -> DNameEnv a
mapDNameEnv :: (a -> b) -> DNameEnv a -> DNameEnv b
adjustDNameEnv :: (a -> a) -> DNameEnv a -> Name -> DNameEnv a
alterDNameEnv :: (Maybe a -> Maybe a) -> DNameEnv a -> Name -> DNameEnv a
extendDNameEnv :: DNameEnv a -> Name -> a -> DNameEnv a
eltsDNameEnv :: DNameEnv a -> [a]
extendDNameEnv_C :: (a -> a -> a) -> DNameEnv a -> Name -> a -> DNameEnv a
plusDNameEnv_C :: (elt -> elt -> elt) -> DNameEnv elt -> DNameEnv elt -> DNameEnv elt
foldDNameEnv :: (a -> b -> b) -> b -> DNameEnv a -> b
nonDetStrictFoldDNameEnv :: (a -> b -> b) -> b -> DNameEnv a -> b
depAnal :: forall node. (node -> [Name]) -> (node -> [Name]) -> [node] -> [SCC node]

module GHC.Types.Fixity.Env

-- | Fixity environment mapping names to their fixities
type FixityEnv = NameEnv FixItem

-- | Fixity information for an <a>Name</a>. We keep the OccName in the
--   range so that we can generate an interface from it
data FixItem
FixItem :: OccName -> Fixity -> FixItem
emptyFixityEnv :: FixityEnv
lookupFixity :: FixityEnv -> Name -> Fixity

-- | Creates cached lookup for the <tt>mi_fix_fn</tt> field of
--   <tt>ModIface</tt>
mkIfaceFixCache :: [(OccName, Fixity)] -> OccName -> Maybe Fixity
emptyIfaceFixCache :: OccName -> Maybe Fixity
instance GHC.Utils.Outputable.Outputable GHC.Types.Fixity.Env.FixItem

module GHC.Types.CostCentre

-- | A Cost Centre is a single <tt>{-# SCC #-}</tt> annotation.
data CostCentre
NormalCC :: CCFlavour -> CcName -> Module -> SrcSpan -> CostCentre

-- | Two cost centres may have the same name and module but different
--   SrcSpans, so we need a way to distinguish them easily and give them
--   different object-code labels. So every CostCentre has an associated
--   flavour that indicates how it was generated, and flavours that allow
--   multiple instances of the same name and module have a deterministic
--   0-based index.
[cc_flavour] :: CostCentre -> CCFlavour

-- | Name of the cost centre itself
[cc_name] :: CostCentre -> CcName

-- | Name of module defining this CC.
[cc_mod] :: CostCentre -> Module
[cc_loc] :: CostCentre -> SrcSpan
AllCafsCC :: Module -> SrcSpan -> CostCentre

-- | Name of module defining this CC.
[cc_mod] :: CostCentre -> Module
[cc_loc] :: CostCentre -> SrcSpan
type CcName = FastString

-- | The flavour of a cost centre.
--   
--   Index fields represent 0-based indices giving source-code ordering of
--   centres with the same module, name, and flavour.
data CCFlavour
mkCafFlavour :: CCFlavour
mkExprCCFlavour :: CostCentreIndex -> CCFlavour
mkDeclCCFlavour :: CostCentreIndex -> CCFlavour
mkHpcCCFlavour :: CostCentreIndex -> CCFlavour
mkLateCCFlavour :: CostCentreIndex -> CCFlavour
mkCallerCCFlavour :: CostCentreIndex -> CCFlavour
pprCostCentre :: IsLine doc => CostCentre -> doc

-- | A Cost Centre Stack is something that can be attached to a closure.
--   This is either:
--   
--   <ul>
--   <li>the current cost centre stack (CCCS)</li>
--   <li>a pre-defined cost centre stack (there are several pre-defined
--   CCSs, see below).</li>
--   </ul>
data CostCentreStack
pprCostCentreStack :: IsLine doc => CostCentreStack -> doc
type CollectedCCs = ([CostCentre], [CostCentreStack])
emptyCollectedCCs :: CollectedCCs
collectCC :: CostCentre -> CostCentreStack -> CollectedCCs -> CollectedCCs
currentCCS :: CostCentreStack
dontCareCCS :: CostCentreStack
isCurrentCCS :: CostCentreStack -> Bool
maybeSingletonCCS :: CostCentreStack -> Maybe CostCentre
mkUserCC :: FastString -> Module -> SrcSpan -> CCFlavour -> CostCentre
mkAutoCC :: Id -> Module -> CostCentre
mkAllCafsCC :: Module -> SrcSpan -> CostCentre
mkSingletonCCS :: CostCentre -> CostCentreStack
isCafCCS :: CostCentreStack -> Bool
isCafCC :: CostCentre -> Bool

-- | Is this a cost-centre which records scc counts
isSccCountCC :: CostCentre -> Bool

-- | Is this a cost-centre which can be sccd ?
sccAbleCC :: CostCentre -> Bool
ccFromThisModule :: CostCentre -> Module -> Bool

-- | Print a flavour in Core
pprCostCentreCore :: CostCentre -> SDoc
costCentreUserName :: CostCentre -> String
costCentreUserNameFS :: CostCentre -> FastString
costCentreSrcSpan :: CostCentre -> SrcSpan
cmpCostCentre :: CostCentre -> CostCentre -> Ordering
instance GHC.Enum.Enum GHC.Types.CostCentre.IndexedCCFlavour
instance Data.Data.Data GHC.Types.CostCentre.IndexedCCFlavour
instance GHC.Classes.Ord GHC.Types.CostCentre.IndexedCCFlavour
instance GHC.Classes.Eq GHC.Types.CostCentre.IndexedCCFlavour
instance Data.Data.Data GHC.Types.CostCentre.CCFlavour
instance GHC.Classes.Ord GHC.Types.CostCentre.CCFlavour
instance GHC.Classes.Eq GHC.Types.CostCentre.CCFlavour
instance Data.Data.Data GHC.Types.CostCentre.CostCentre
instance GHC.Classes.Ord GHC.Types.CostCentre.CostCentreStack
instance GHC.Classes.Eq GHC.Types.CostCentre.CostCentreStack
instance GHC.Utils.Outputable.Outputable GHC.Types.CostCentre.CostCentreStack
instance GHC.Classes.Eq GHC.Types.CostCentre.CostCentre
instance GHC.Classes.Ord GHC.Types.CostCentre.CostCentre
instance GHC.Utils.Outputable.Outputable GHC.Types.CostCentre.CostCentre
instance GHC.Utils.Binary.Binary GHC.Types.CostCentre.CostCentre
instance GHC.Utils.Binary.Binary GHC.Types.CostCentre.CCFlavour

module GHC.Types.Avail

-- | A collection of <a>AvailInfo</a> - several things that are "available"
type Avails = [AvailInfo]

-- | Records what things are "available", i.e. in scope
data AvailInfo

-- | An ordinary identifier in scope, or a field label without a parent
--   type (see Note [Representing pattern synonym fields in AvailInfo]).
Avail :: GreName -> AvailInfo

-- | A type or class in scope
--   
--   The <b>AvailTC Invariant</b>: If the type or class is itself to be in
--   scope, it must be <i>first</i> in this list. Thus, typically:
--   
--   <pre>
--   AvailTC Eq [Eq, ==, \/=]
--   </pre>
AvailTC :: Name -> [GreName] -> AvailInfo
avail :: Name -> AvailInfo
availField :: FieldLabel -> AvailInfo
availTC :: Name -> [Name] -> [FieldLabel] -> AvailInfo
availsToNameSet :: [AvailInfo] -> NameSet
availsToNameSetWithSelectors :: [AvailInfo] -> NameSet
availsToNameEnv :: [AvailInfo] -> NameEnv AvailInfo

-- | Does this <a>AvailInfo</a> export the parent decl? This depends on the
--   invariant that the parent is first if it appears at all.
availExportsDecl :: AvailInfo -> Bool

-- | Just the main name made available, i.e. not the available pieces of
--   type or class brought into scope by the <a>AvailInfo</a>
availName :: AvailInfo -> Name
availGreName :: AvailInfo -> GreName

-- | All names made available by the availability information (excluding
--   overloaded selectors)
availNames :: AvailInfo -> [Name]

-- | Names for non-fields made available by the availability information
availNonFldNames :: AvailInfo -> [Name]

-- | All names made available by the availability information (including
--   overloaded selectors)
availNamesWithSelectors :: AvailInfo -> [Name]

-- | Fields made available by the availability information
availFlds :: AvailInfo -> [FieldLabel]

-- | Names and fields made available by the availability information.
availGreNames :: AvailInfo -> [GreName]

-- | Names and fields made available by the availability information, other
--   than the main decl itself.
availSubordinateGreNames :: AvailInfo -> [GreName]

-- | Compare lexicographically
stableAvailCmp :: AvailInfo -> AvailInfo -> Ordering
plusAvail :: AvailInfo -> AvailInfo -> AvailInfo

-- | trims an <a>AvailInfo</a> to keep only a single name
trimAvail :: AvailInfo -> Name -> AvailInfo

-- | filters an <a>AvailInfo</a> by the given predicate
filterAvail :: (Name -> Bool) -> AvailInfo -> [AvailInfo] -> [AvailInfo]

-- | filters <a>AvailInfo</a>s by the given predicate
filterAvails :: (Name -> Bool) -> [AvailInfo] -> [AvailInfo]

-- | Combines <a>AvailInfo</a>s from the same family <tt>avails</tt> may
--   have several items with the same availName E.g import Ix( Ix(..),
--   index ) will give Ix(Ix,index,range) and Ix(index) We want to combine
--   these; addAvail does that
nubAvails :: [AvailInfo] -> [AvailInfo]

-- | Used where we may have an ordinary name or a record field label. See
--   Note [GreNames] in GHC.Types.Name.Reader.
data GreName
NormalGreName :: Name -> GreName
FieldGreName :: FieldLabel -> GreName

-- | A <a>Name</a> for internal use, but not for output to the user. For
--   fields, the <a>OccName</a> will be the selector. See Note [GreNames]
--   in GHC.Types.Name.Reader.
greNameMangledName :: GreName -> Name

-- | A <a>Name</a> suitable for output to the user. For fields, the
--   <a>OccName</a> will be the field label. See Note [GreNames] in
--   GHC.Types.Name.Reader.
greNamePrintableName :: GreName -> Name
greNameSrcSpan :: GreName -> SrcSpan
greNameFieldLabel :: GreName -> Maybe FieldLabel
partitionGreNames :: [GreName] -> ([Name], [FieldLabel])
stableGreNameCmp :: GreName -> GreName -> Ordering
instance GHC.Classes.Eq GHC.Types.Avail.GreName
instance Data.Data.Data GHC.Types.Avail.GreName
instance Data.Data.Data GHC.Types.Avail.AvailInfo
instance GHC.Classes.Eq GHC.Types.Avail.AvailInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Avail.AvailInfo
instance GHC.Utils.Binary.Binary GHC.Types.Avail.AvailInfo
instance Control.DeepSeq.NFData GHC.Types.Avail.AvailInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Avail.GreName
instance Control.DeepSeq.NFData GHC.Types.Avail.GreName
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Avail.GreName
instance GHC.Classes.Ord GHC.Types.Avail.GreName
instance GHC.Utils.Binary.Binary GHC.Types.Avail.GreName


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a> is the type of names that come directly from the
--   parser. They have not yet had their scoping and binding resolved by
--   the renamer and can be thought of to a first approximation as an
--   <a>OccName</a> with an optional module qualifier</li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a>: see <a>GHC.Types.Id#name_types</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
module GHC.Types.Name.Reader

-- | Reader Name
--   
--   Do not use the data constructors of RdrName directly: prefer the
--   family of functions that creates them, such as <a>mkRdrUnqual</a>
--   
--   <ul>
--   <li>Note: A Located RdrName will only have API Annotations if it is a
--   compound one, e.g.</li>
--   </ul>
--   
--   <pre>
--   `bar`
--   ( ~ )
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnOpen</a> <tt>'('</tt>
--   or <tt>'['</tt> or <tt>'[:'</tt>, <a>AnnClose</a> <tt>')'</tt> or
--   <tt>']'</tt> or <tt>':]'</tt>,, <a>AnnBackquote</a> <tt>'`'</tt>,
--   <a>AnnVal</a> <a>AnnTilde</a>,</li>
--   </ul>
data RdrName

-- | Unqualified name
--   
--   Used for ordinary, unqualified occurrences, e.g. <tt>x</tt>,
--   <tt>y</tt> or <tt>Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrUnqual</a>
Unqual :: OccName -> RdrName

-- | Qualified name
--   
--   A qualified name written by the user in <i>source</i> code. The module
--   isn't necessarily the module where the thing is defined; just the one
--   from which it is imported. Examples are <tt>Bar.x</tt>, <tt>Bar.y</tt>
--   or <tt>Bar.Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrQual</a>
Qual :: ModuleName -> OccName -> RdrName

-- | Original name
--   
--   An original name; the module is the <i>defining</i> module. This is
--   used when GHC generates code that will be fed into the renamer (e.g.
--   from deriving clauses), but where we want to say "Use Prelude.map
--   dammit". One of these can be created with <a>mkOrig</a>
Orig :: Module -> OccName -> RdrName

-- | Exact name
--   
--   We know exactly the <a>Name</a>. This is used:
--   
--   <ol>
--   <li>When the parser parses built-in syntax like <tt>[]</tt> and
--   <tt>(,)</tt>, but wants a <a>RdrName</a> from it</li>
--   <li>By Template Haskell, when TH has generated a unique name</li>
--   </ol>
--   
--   Such a <a>RdrName</a> can be created by using <a>getRdrName</a> on a
--   <a>Name</a>
Exact :: Name -> RdrName
mkRdrUnqual :: OccName -> RdrName
mkRdrQual :: ModuleName -> OccName -> RdrName
mkUnqual :: NameSpace -> FastString -> RdrName
mkVarUnqual :: FastString -> RdrName

-- | Make a qualified <a>RdrName</a> in the given namespace and where the
--   <a>ModuleName</a> and the <a>OccName</a> are taken from the first and
--   second elements of the tuple respectively
mkQual :: NameSpace -> (FastString, FastString) -> RdrName
mkOrig :: Module -> OccName -> RdrName
nameRdrName :: Name -> RdrName
getRdrName :: NamedThing thing => thing -> RdrName
rdrNameOcc :: RdrName -> OccName
rdrNameSpace :: RdrName -> NameSpace
demoteRdrName :: RdrName -> Maybe RdrName
promoteRdrName :: RdrName -> Maybe RdrName
isRdrDataCon :: RdrName -> Bool
isRdrTyVar :: RdrName -> Bool
isRdrTc :: RdrName -> Bool
isQual :: RdrName -> Bool
isQual_maybe :: RdrName -> Maybe (ModuleName, OccName)
isUnqual :: RdrName -> Bool
isOrig :: RdrName -> Bool
isOrig_maybe :: RdrName -> Maybe (Module, OccName)
isExact :: RdrName -> Bool
isExact_maybe :: RdrName -> Maybe Name
isSrcRdrName :: RdrName -> Bool

-- | Local Reader Environment See Note [LocalRdrEnv]
data LocalRdrEnv
emptyLocalRdrEnv :: LocalRdrEnv
extendLocalRdrEnv :: LocalRdrEnv -> Name -> LocalRdrEnv
extendLocalRdrEnvList :: LocalRdrEnv -> [Name] -> LocalRdrEnv
lookupLocalRdrEnv :: LocalRdrEnv -> RdrName -> Maybe Name
lookupLocalRdrOcc :: LocalRdrEnv -> OccName -> Maybe Name
elemLocalRdrEnv :: RdrName -> LocalRdrEnv -> Bool
inLocalRdrEnvScope :: Name -> LocalRdrEnv -> Bool
localRdrEnvElts :: LocalRdrEnv -> [Name]
minusLocalRdrEnv :: LocalRdrEnv -> OccEnv a -> LocalRdrEnv

-- | Global Reader Environment
--   
--   Keyed by <a>OccName</a>; when looking up a qualified name we look up
--   the <a>OccName</a> part, and then check the <tt>Provenance</tt> to see
--   if the appropriate qualification is valid. This saves routinely
--   doubling the size of the env by adding both qualified and unqualified
--   names to the domain.
--   
--   The list in the codomain is required because there may be name clashes
--   These only get reported on lookup, not on construction
--   
--   INVARIANT 1: All the members of the list have distinct <a>gre_name</a>
--   fields; that is, no duplicate Names
--   
--   INVARIANT 2: Imported provenance =&gt; Name is an ExternalName However
--   LocalDefs can have an InternalName. This happens only when
--   type-checking a [d| ... |] Template Haskell quotation; see this note
--   in GHC.Rename.Names Note [Top-level Names in Template Haskell decl
--   quotes]
--   
--   INVARIANT 3: If the GlobalRdrEnv maps [occ -&gt; gre], then greOccName
--   gre = occ
--   
--   NB: greOccName gre is usually the same as nameOccName (greMangledName
--   gre), but not always in the case of record selectors; see Note
--   [GreNames]
type GlobalRdrEnv = OccEnv [GlobalRdrElt]
emptyGlobalRdrEnv :: GlobalRdrEnv
mkGlobalRdrEnv :: [GlobalRdrElt] -> GlobalRdrEnv
plusGlobalRdrEnv :: GlobalRdrEnv -> GlobalRdrEnv -> GlobalRdrEnv
lookupGlobalRdrEnv :: GlobalRdrEnv -> OccName -> [GlobalRdrElt]
extendGlobalRdrEnv :: GlobalRdrEnv -> GlobalRdrElt -> GlobalRdrEnv

-- | See Note [GreNames]
greOccName :: GlobalRdrElt -> OccName
shadowNames :: GlobalRdrEnv -> OccEnv a -> GlobalRdrEnv
pprGlobalRdrEnv :: Bool -> GlobalRdrEnv -> SDoc
globalRdrEnvElts :: GlobalRdrEnv -> [GlobalRdrElt]

-- | Look for this <a>RdrName</a> in the global environment. Omits record
--   fields without selector functions (see Note [NoFieldSelectors] in
--   GHC.Rename.Env).
lookupGRE_RdrName :: RdrName -> GlobalRdrEnv -> [GlobalRdrElt]

-- | Look for this <a>RdrName</a> in the global environment. Includes
--   record fields without selector functions (see Note [NoFieldSelectors]
--   in GHC.Rename.Env).
lookupGRE_RdrName' :: RdrName -> GlobalRdrEnv -> [GlobalRdrElt]

-- | Look for precisely this <a>Name</a> in the environment. This tests
--   whether it is in scope, ignoring anything else that might be in scope
--   with the same <a>OccName</a>.
lookupGRE_Name :: GlobalRdrEnv -> Name -> Maybe GlobalRdrElt

-- | Look for precisely this <a>GreName</a> in the environment. This tests
--   whether it is in scope, ignoring anything else that might be in scope
--   with the same <a>OccName</a>.
lookupGRE_GreName :: GlobalRdrEnv -> GreName -> Maybe GlobalRdrElt

-- | Look for a particular record field selector in the environment, where
--   the selector name and field label may be different: the GlobalRdrEnv
--   is keyed on the label. See Note [GreNames] for why this happens.
lookupGRE_FieldLabel :: GlobalRdrEnv -> FieldLabel -> Maybe GlobalRdrElt

-- | Look for precisely this <a>Name</a> in the environment, but with an
--   <a>OccName</a> that might differ from that of the <a>Name</a>. See
--   <a>lookupGRE_FieldLabel</a> and Note [GreNames].
lookupGRE_Name_OccName :: GlobalRdrEnv -> Name -> OccName -> Maybe GlobalRdrElt
getGRE_NameQualifier_maybes :: GlobalRdrEnv -> Name -> [Maybe [ModuleName]]

-- | Apply a transformation function to the GREs for these OccNames
transformGREs :: (GlobalRdrElt -> GlobalRdrElt) -> [OccName] -> GlobalRdrEnv -> GlobalRdrEnv

-- | Takes a list of GREs which have the right OccName <tt>x</tt> Pick
--   those GREs that are in scope * Qualified, as <a>x</a> if want_qual is
--   Qual M _ * Unqualified, as <tt>x</tt> if want_unqual is Unqual _
--   
--   Return each such GRE, with its ImportSpecs filtered, to reflect how it
--   is in scope qualified or unqualified respectively. See Note [GRE
--   filtering]
pickGREs :: RdrName -> [GlobalRdrElt] -> [GlobalRdrElt]

-- | Pick GREs that are in scope *both* qualified *and* unqualified Return
--   each GRE that is, as a pair (qual_gre, unqual_gre) These two GREs are
--   the original GRE with imports filtered to express how it is in scope
--   qualified an unqualified respectively
--   
--   Used only for the 'module M' item in export list; see
--   <a>exports_from_avail</a>
pickGREsModExp :: ModuleName -> [GlobalRdrElt] -> [(GlobalRdrElt, GlobalRdrElt)]

-- | make a <a>GlobalRdrEnv</a> where all the elements point to the same
--   Provenance (useful for "hiding" imports, or imports with no details).
gresFromAvails :: Maybe ImportSpec -> [AvailInfo] -> [GlobalRdrElt]
gresFromAvail :: (Name -> Maybe ImportSpec) -> AvailInfo -> [GlobalRdrElt]
localGREsFromAvail :: AvailInfo -> [GlobalRdrElt]
availFromGRE :: GlobalRdrElt -> AvailInfo
greRdrNames :: GlobalRdrElt -> [RdrName]
greSrcSpan :: GlobalRdrElt -> SrcSpan
greQualModName :: GlobalRdrElt -> ModuleName

-- | Takes a list of distinct GREs and folds them into AvailInfos. This is
--   more efficient than mapping each individual GRE to an AvailInfo and
--   the folding using <a>plusAvail</a> but needs the uniqueness
--   assumption.
gresToAvailInfo :: [GlobalRdrElt] -> [AvailInfo]

-- | The module in which the name pointed to by the GRE is defined.
greDefinitionModule :: GlobalRdrElt -> Maybe Module

-- | The SrcSpan of the name pointed to by the GRE.
greDefinitionSrcSpan :: GlobalRdrElt -> SrcSpan

-- | A <a>Name</a> for the GRE for internal use. Careful: the
--   <a>OccName</a> of this <a>Name</a> is not necessarily the same as the
--   <a>greOccName</a> (see Note [GreNames]).
greMangledName :: GlobalRdrElt -> Name

-- | A <a>Name</a> for the GRE suitable for output to the user. Its
--   <a>OccName</a> will be the <a>greOccName</a> (see Note [GreNames]).
grePrintableName :: GlobalRdrElt -> Name

-- | Returns the field label of this GRE, if it has one
greFieldLabel :: GlobalRdrElt -> Maybe FieldLabel

-- | Global Reader Element
--   
--   An element of the <a>GlobalRdrEnv</a>
data GlobalRdrElt
GRE :: !GreName -> !Parent -> !Bool -> !Bag ImportSpec -> GlobalRdrElt

-- | See Note [GreNames]
[gre_name] :: GlobalRdrElt -> !GreName

-- | See Note [Parents]
[gre_par] :: GlobalRdrElt -> !Parent

-- | True <a>=</a> the thing was defined locally
[gre_lcl] :: GlobalRdrElt -> !Bool

-- | In scope through these imports
[gre_imp] :: GlobalRdrElt -> !Bag ImportSpec
isLocalGRE :: GlobalRdrElt -> Bool
isRecFldGRE :: GlobalRdrElt -> Bool

-- | Is this a record field defined with DuplicateRecordFields? (See Note
--   [GreNames])
isDuplicateRecFldGRE :: GlobalRdrElt -> Bool

-- | Is this a record field defined with NoFieldSelectors? (See Note
--   [NoFieldSelectors] in GHC.Rename.Env)
isNoFieldSelectorGRE :: GlobalRdrElt -> Bool

-- | Is this a record field defined with FieldSelectors? (See Note
--   [NoFieldSelectors] in GHC.Rename.Env)
isFieldSelectorGRE :: GlobalRdrElt -> Bool

-- | Test if an unqualified version of this thing would be in scope
unQualOK :: GlobalRdrElt -> Bool

-- | Is in scope qualified with the given module?
qualSpecOK :: ModuleName -> ImportSpec -> Bool

-- | Is in scope unqualified?
unQualSpecOK :: ImportSpec -> Bool

-- | Print out one place where the name was define/imported (With
--   -dppr-debug, print them all)
pprNameProvenance :: GlobalRdrElt -> SDoc

-- | Used where we may have an ordinary name or a record field label. See
--   Note [GreNames] in GHC.Types.Name.Reader.
data GreName
NormalGreName :: Name -> GreName
FieldGreName :: FieldLabel -> GreName
greNameSrcSpan :: GreName -> SrcSpan

-- | See Note [Parents]
data Parent
NoParent :: Parent
ParentIs :: !Name -> Parent
[par_is] :: Parent -> !Name
greParent_maybe :: GlobalRdrElt -> Maybe Name

-- | Import Specification
--   
--   The <a>ImportSpec</a> of something says how it came to be imported
--   It's quite elaborate so that we can give accurate unused-name
--   warnings.
data ImportSpec
ImpSpec :: !ImpDeclSpec -> !ImpItemSpec -> ImportSpec
[is_decl] :: ImportSpec -> !ImpDeclSpec
[is_item] :: ImportSpec -> !ImpItemSpec

-- | Import Declaration Specification
--   
--   Describes a particular import declaration and is shared among all the
--   <tt>Provenance</tt>s for that decl
data ImpDeclSpec
ImpDeclSpec :: !ModuleName -> !ModuleName -> !Bool -> !SrcSpan -> ImpDeclSpec

-- | Module imported, e.g. <tt>import Muggle</tt> Note the <tt>Muggle</tt>
--   may well not be the defining module for this thing!
[is_mod] :: ImpDeclSpec -> !ModuleName

-- | Import alias, e.g. from <tt>as M</tt> (or <tt>Muggle</tt> if there is
--   no <tt>as</tt> clause)
[is_as] :: ImpDeclSpec -> !ModuleName

-- | Was this import qualified?
[is_qual] :: ImpDeclSpec -> !Bool

-- | The location of the entire import declaration
[is_dloc] :: ImpDeclSpec -> !SrcSpan

-- | Import Item Specification
--   
--   Describes import info a particular Name
data ImpItemSpec

-- | The import had no import list, or had a hiding list
ImpAll :: ImpItemSpec

-- | The import had an import list. The <a>is_explicit</a> field is
--   <tt>True</tt> iff the thing was named <i>explicitly</i> in the import
--   specs rather than being imported as part of a "..." group. Consider:
--   
--   <pre>
--   import C( T(..) )
--   </pre>
--   
--   Here the constructors of <tt>T</tt> are not named explicitly; only
--   <tt>T</tt> is named explicitly.
ImpSome :: !Bool -> !SrcSpan -> ImpItemSpec
[is_explicit] :: ImpItemSpec -> !Bool
[is_iloc] :: ImpItemSpec -> !SrcSpan
importSpecLoc :: ImportSpec -> SrcSpan
importSpecModule :: ImportSpec -> ModuleName
isExplicitItem :: ImpItemSpec -> Bool
bestImport :: [ImportSpec] -> ImportSpec

-- | Indicate if the given name is the "@" operator
opIsAt :: RdrName -> Bool
instance Data.Data.Data GHC.Types.Name.Reader.RdrName
instance Data.Data.Data GHC.Types.Name.Reader.Parent
instance GHC.Classes.Eq GHC.Types.Name.Reader.Parent
instance Data.Data.Data GHC.Types.Name.Reader.ImpDeclSpec
instance GHC.Classes.Eq GHC.Types.Name.Reader.ImpDeclSpec
instance Data.Data.Data GHC.Types.Name.Reader.ImpItemSpec
instance GHC.Classes.Eq GHC.Types.Name.Reader.ImpItemSpec
instance Data.Data.Data GHC.Types.Name.Reader.ImportSpec
instance GHC.Classes.Eq GHC.Types.Name.Reader.ImportSpec
instance Data.Data.Data GHC.Types.Name.Reader.GlobalRdrElt
instance Control.DeepSeq.NFData GHC.Types.Name.Reader.GlobalRdrElt
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Reader.GlobalRdrElt
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.GlobalRdrElt
instance Control.DeepSeq.NFData GHC.Types.Name.Reader.ImportSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.ImportSpec
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.Parent
instance Control.DeepSeq.NFData GHC.Types.Name.Reader.Parent
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.LocalRdrEnv
instance GHC.Types.Name.Occurrence.HasOccName GHC.Types.Name.Reader.RdrName
instance GHC.Utils.Outputable.Outputable GHC.Types.Name.Reader.RdrName
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Name.Reader.RdrName
instance GHC.Classes.Eq GHC.Types.Name.Reader.RdrName
instance GHC.Classes.Ord GHC.Types.Name.Reader.RdrName

module GHC.Unit.Module.Imported

-- | Records the modules directly imported by a module for extracting e.g.
--   usage information, and also to give better error message
type ImportedMods = ModuleEnv [ImportedBy]

-- | If a module was "imported" by the user, we associate it with more
--   detailed usage information <a>ImportedModsVal</a>; a module imported
--   by the system only gets used for usage information.
data ImportedBy
ImportedByUser :: ImportedModsVal -> ImportedBy
ImportedBySystem :: ImportedBy
data ImportedModsVal
ImportedModsVal :: ModuleName -> SrcSpan -> IsSafeImport -> Bool -> !GlobalRdrEnv -> Bool -> ImportedModsVal

-- | The name the module is imported with
[imv_name] :: ImportedModsVal -> ModuleName

-- | the source span of the whole import
[imv_span] :: ImportedModsVal -> SrcSpan

-- | whether this is a safe import
[imv_is_safe] :: ImportedModsVal -> IsSafeImport

-- | whether this is an "hiding" import
[imv_is_hiding] :: ImportedModsVal -> Bool

-- | all the things the module could provide.
--   
--   NB. BangPattern here: otherwise this leaks. (#15111)
[imv_all_exports] :: ImportedModsVal -> !GlobalRdrEnv

-- | whether this is a qualified import
[imv_qualified] :: ImportedModsVal -> Bool
importedByUser :: [ImportedBy] -> [ImportedModsVal]


-- | Support for source code annotation feature of GHC. That is the ANN
--   pragma.
--   
--   (c) The University of Glasgow 2006 (c) The GRASP/AQUA Project, Glasgow
--   University, 1992-1998
module GHC.Types.Annotations

-- | Represents an annotation after it has been sufficiently desugared from
--   it's initial form of <a>AnnDecl</a>
data Annotation
Annotation :: CoreAnnTarget -> AnnPayload -> Annotation

-- | The target of the annotation
[ann_target] :: Annotation -> CoreAnnTarget
[ann_value] :: Annotation -> AnnPayload
type AnnPayload = -- | The "payload" of an annotation --   allows recovery of its value at a given type, --   and can be persisted to an interface file Serialized

-- | An annotation target
data AnnTarget name

-- | We are annotating something with a name: a type or identifier
NamedTarget :: name -> AnnTarget name

-- | We are annotating a particular module
ModuleTarget :: Module -> AnnTarget name

-- | The kind of annotation target found in the middle end of the compiler
type CoreAnnTarget = AnnTarget Name

-- | A collection of annotations
data AnnEnv

-- | Construct a new annotation environment that contains the list of
--   annotations provided.
mkAnnEnv :: [Annotation] -> AnnEnv

-- | Add the given annotation to the environment.
extendAnnEnvList :: AnnEnv -> [Annotation] -> AnnEnv

-- | Union two annotation environments.
plusAnnEnv :: AnnEnv -> AnnEnv -> AnnEnv

-- | An empty annotation environment.
emptyAnnEnv :: AnnEnv

-- | Find the annotations attached to the given target as <a>Typeable</a>
--   values of your choice. If no deserializer is specified, only transient
--   annotations will be returned.
findAnns :: Typeable a => ([Word8] -> a) -> AnnEnv -> CoreAnnTarget -> [a]

-- | Find the annotations attached to the given target as <a>Typeable</a>
--   values of your choice. If no deserializer is specified, only transient
--   annotations will be returned.
findAnnsByTypeRep :: AnnEnv -> CoreAnnTarget -> TypeRep -> [[Word8]]

-- | Deserialize all annotations of a given type. This happens lazily, that
--   is no deserialization will take place until the [a] is actually
--   demanded and the [a] can also be empty (the UniqFM is not filtered).
deserializeAnns :: Typeable a => ([Word8] -> a) -> AnnEnv -> (ModuleEnv [a], NameEnv [a])
instance GHC.Base.Functor GHC.Types.Annotations.AnnTarget
instance GHC.Utils.Outputable.Outputable GHC.Types.Annotations.Annotation
instance GHC.Utils.Outputable.Outputable name => GHC.Utils.Outputable.Outputable (GHC.Types.Annotations.AnnTarget name)
instance GHC.Utils.Binary.Binary name => GHC.Utils.Binary.Binary (GHC.Types.Annotations.AnnTarget name)

module GHC.Parser.Annotation

-- | Exact print annotations exist so that tools can perform source to
--   source conversions of Haskell code. They are used to keep track of the
--   various syntactic keywords that are not otherwise captured in the AST.
--   
--   The wiki page describing this feature is
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/api-annotations</a>
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/implementing-trees-that-grow/in-tree-api-annotations</a>
--   
--   Note: in general the names of these are taken from the corresponding
--   token, unless otherwise noted See Note [exact print annotations] above
--   for details of the usage
data AnnKeywordId
AnnAnyclass :: AnnKeywordId
AnnAs :: AnnKeywordId

-- | <tt>!</tt>
AnnBang :: AnnKeywordId

-- | '`'
AnnBackquote :: AnnKeywordId
AnnBy :: AnnKeywordId

-- | case or lambda case
AnnCase :: AnnKeywordId

-- | lambda cases
AnnCases :: AnnKeywordId
AnnClass :: AnnKeywordId

-- | '#)' or '#-}' etc
AnnClose :: AnnKeywordId

-- | '|)'
AnnCloseB :: AnnKeywordId

-- | '|)', unicode variant
AnnCloseBU :: AnnKeywordId

-- | '}'
AnnCloseC :: AnnKeywordId

-- | '|]'
AnnCloseQ :: AnnKeywordId

-- | '|]', unicode variant
AnnCloseQU :: AnnKeywordId

-- | ')'
AnnCloseP :: AnnKeywordId

-- | '#)'
AnnClosePH :: AnnKeywordId

-- | ']'
AnnCloseS :: AnnKeywordId
AnnColon :: AnnKeywordId

-- | as a list separator
AnnComma :: AnnKeywordId

-- | in a RdrName for a tuple
AnnCommaTuple :: AnnKeywordId

-- | '=&gt;'
AnnDarrow :: AnnKeywordId

-- | '=&gt;', unicode variant
AnnDarrowU :: AnnKeywordId
AnnData :: AnnKeywordId

-- | '::'
AnnDcolon :: AnnKeywordId

-- | '::', unicode variant
AnnDcolonU :: AnnKeywordId
AnnDefault :: AnnKeywordId
AnnDeriving :: AnnKeywordId
AnnDo :: AnnKeywordId

-- | <a>.</a>
AnnDot :: AnnKeywordId

-- | '..'
AnnDotdot :: AnnKeywordId
AnnElse :: AnnKeywordId
AnnEqual :: AnnKeywordId
AnnExport :: AnnKeywordId
AnnFamily :: AnnKeywordId
AnnForall :: AnnKeywordId

-- | Unicode variant
AnnForallU :: AnnKeywordId
AnnForeign :: AnnKeywordId

-- | for function name in matches where there are multiple equations for
--   the function.
AnnFunId :: AnnKeywordId
AnnGroup :: AnnKeywordId

-- | for CType
AnnHeader :: AnnKeywordId
AnnHiding :: AnnKeywordId
AnnIf :: AnnKeywordId
AnnImport :: AnnKeywordId
AnnIn :: AnnKeywordId

-- | 'infix' or 'infixl' or 'infixr'
AnnInfix :: AnnKeywordId
AnnInstance :: AnnKeywordId
AnnLam :: AnnKeywordId

-- | '&lt;-'
AnnLarrow :: AnnKeywordId

-- | '&lt;-', unicode variant
AnnLarrowU :: AnnKeywordId
AnnLet :: AnnKeywordId

-- | The <tt>⊸</tt> unicode arrow
AnnLollyU :: AnnKeywordId
AnnMdo :: AnnKeywordId

-- | <a>-</a>
AnnMinus :: AnnKeywordId
AnnModule :: AnnKeywordId
AnnNewtype :: AnnKeywordId

-- | where a name loses its location in the AST, this carries it
AnnName :: AnnKeywordId
AnnOf :: AnnKeywordId

-- | '{-# DEPRECATED' etc. Opening of pragmas where the capitalisation of
--   the string can be changed by the user. The actual text used is stored
--   in a <tt>SourceText</tt> on the relevant pragma item.
AnnOpen :: AnnKeywordId

-- | '(|'
AnnOpenB :: AnnKeywordId

-- | '(|', unicode variant
AnnOpenBU :: AnnKeywordId

-- | '{'
AnnOpenC :: AnnKeywordId

-- | '[e|' or '[e||'
AnnOpenE :: AnnKeywordId

-- | '[|'
AnnOpenEQ :: AnnKeywordId

-- | '[|', unicode variant
AnnOpenEQU :: AnnKeywordId

-- | '('
AnnOpenP :: AnnKeywordId

-- | '['
AnnOpenS :: AnnKeywordId

-- | '(#'
AnnOpenPH :: AnnKeywordId

-- | prefix <a>$</a> -- TemplateHaskell
AnnDollar :: AnnKeywordId

-- | prefix <a>$$</a> -- TemplateHaskell
AnnDollarDollar :: AnnKeywordId
AnnPackageName :: AnnKeywordId
AnnPattern :: AnnKeywordId

-- | <tt>%</tt> -- for HsExplicitMult
AnnPercent :: AnnKeywordId

-- | '%1' -- for HsLinearArrow
AnnPercentOne :: AnnKeywordId
AnnProc :: AnnKeywordId
AnnQualified :: AnnKeywordId

-- | <tt>-&gt;</tt>
AnnRarrow :: AnnKeywordId

-- | <tt>-&gt;</tt>, unicode variant
AnnRarrowU :: AnnKeywordId
AnnRec :: AnnKeywordId
AnnRole :: AnnKeywordId
AnnSafe :: AnnKeywordId

-- | ';'
AnnSemi :: AnnKeywordId

-- | '''
AnnSimpleQuote :: AnnKeywordId
AnnSignature :: AnnKeywordId

-- | <tt>static</tt>
AnnStatic :: AnnKeywordId
AnnStock :: AnnKeywordId
AnnThen :: AnnKeywordId

-- | double '''
AnnThTyQuote :: AnnKeywordId

-- | <a>~</a>
AnnTilde :: AnnKeywordId
AnnType :: AnnKeywordId

-- | <tt>()</tt> for types
AnnUnit :: AnnKeywordId
AnnUsing :: AnnKeywordId

-- | e.g. INTEGER
AnnVal :: AnnKeywordId

-- | String value, will need quotes when output
AnnValStr :: AnnKeywordId

-- | '|'
AnnVbar :: AnnKeywordId

-- | <tt>via</tt>
AnnVia :: AnnKeywordId
AnnWhere :: AnnKeywordId

-- | <tt>-&lt;</tt>
Annlarrowtail :: AnnKeywordId

-- | <tt>-&lt;</tt>, unicode variant
AnnlarrowtailU :: AnnKeywordId

-- | <tt>-&gt;</tt>
Annrarrowtail :: AnnKeywordId

-- | <tt>-&gt;</tt>, unicode variant
AnnrarrowtailU :: AnnKeywordId

-- | <tt>-&lt;&lt;</tt>
AnnLarrowtail :: AnnKeywordId

-- | <tt>-&lt;&lt;</tt>, unicode variant
AnnLarrowtailU :: AnnKeywordId

-- | <tt>&gt;&gt;-</tt>
AnnRarrowtail :: AnnKeywordId

-- | <tt>&gt;&gt;-</tt>, unicode variant
AnnRarrowtailU :: AnnKeywordId
data EpaComment
EpaComment :: EpaCommentTok -> RealSrcSpan -> EpaComment
[ac_tok] :: EpaComment -> EpaCommentTok

-- | The location of the prior token, used in exact printing. The
--   <a>EpaComment</a> appears as an <a>LEpaComment</a> containing its
--   location. The difference between the end of the prior token and the
--   start of this location is used for the spacing when exact printing the
--   comment.
[ac_prior_tok] :: EpaComment -> RealSrcSpan
data EpaCommentTok

-- | a docstring that can be pretty printed using pprHsDocString
EpaDocComment :: HsDocString -> EpaCommentTok

-- | doc options (prune, ignore-exports, etc)
EpaDocOptions :: String -> EpaCommentTok

-- | comment starting by "--"
EpaLineComment :: String -> EpaCommentTok

-- | comment in {- -}
EpaBlockComment :: String -> EpaCommentTok

-- | empty comment, capturing location of EOF
EpaEofComment :: EpaCommentTok

-- | Certain tokens can have alternate representations when unicode syntax
--   is enabled. This flag is attached to those tokens in the lexer so that
--   the original source representation can be reproduced in the
--   corresponding <tt>EpAnnotation</tt>
data IsUnicodeSyntax
UnicodeSyntax :: IsUnicodeSyntax
NormalSyntax :: IsUnicodeSyntax

-- | Convert a normal annotation into its unicode equivalent one
unicodeAnn :: AnnKeywordId -> AnnKeywordId

-- | Some template haskell tokens have two variants, one with an <tt>e</tt>
--   the other not:
--   
--   <pre>
--   [| or [e|
--   [|| or [e||
--   </pre>
--   
--   This type indicates whether the <tt>e</tt> is present or not.
data HasE
HasE :: HasE
NoE :: HasE

-- | Captures an annotation, storing the <tt><a>AnnKeywordId</a></tt> and
--   its location. The parser only ever inserts <tt><a>EpaLocation</a></tt>
--   fields with a RealSrcSpan being the original location of the
--   annotation in the source file. The <tt><a>EpaLocation</a></tt> can
--   also store a delta position if the AST has been modified and needs to
--   be pretty printed again. The usual way an <a>AddEpAnn</a> is created
--   is using the <tt>mj</tt> ("make jump") function, and then it can be
--   inserted into the appropriate annotation.
data AddEpAnn
AddEpAnn :: AnnKeywordId -> EpaLocation -> AddEpAnn

-- | The anchor for an <tt><a>AnnKeywordId</a></tt>. The Parser inserts the
--   <tt><a>EpaSpan</a></tt> variant, giving the exact location of the
--   original item in the parsed source. This can be replaced by the
--   <tt><a>EpaDelta</a></tt> version, to provide a position for the item
--   relative to the end of the previous item in the source. This is useful
--   when editing an AST prior to exact printing the changed one. The list
--   of comments in the <tt><a>EpaDelta</a></tt> variant captures any
--   comments between the prior output and the thing being marked here,
--   since we cannot otherwise sort the relative order.
data EpaLocation
EpaSpan :: !RealSrcSpan -> !Maybe BufSpan -> EpaLocation
EpaDelta :: !DeltaPos -> ![LEpaComment] -> EpaLocation

-- | Used in the parser only, extract the <a>RealSrcSpan</a> from an
--   <a>EpaLocation</a>. The parser will never insert a <a>DeltaPos</a>, so
--   the partial function is safe.
epaLocationRealSrcSpan :: EpaLocation -> RealSrcSpan
epaLocationFromSrcAnn :: SrcAnn ann -> EpaLocation

-- | Tokens embedded in the AST have an EpaLocation, unless they come from
--   generated code (e.g. by TH).
data TokenLocation
NoTokenLoc :: TokenLocation
TokenLoc :: !EpaLocation -> TokenLocation

-- | Spacing between output items when exact printing. It captures the
--   spacing from the current print position on the page to the position
--   required for the thing about to be printed. This is either on the same
--   line in which case is is simply the number of spaces to emit, or it is
--   some number of lines down, with a given column offset. The exact
--   printing algorithm keeps track of the column offset pertaining to the
--   current anchor position, so the <a>deltaColumn</a> is the additional
--   spaces to add in this case. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/api-annotations</a> for
--   details.
data DeltaPos
SameLine :: !Int -> DeltaPos
[deltaColumn] :: DeltaPos -> !Int
DifferentLine :: !Int -> !Int -> DeltaPos

-- | deltaLine should always be &gt; 0
[deltaLine] :: DeltaPos -> !Int
[deltaColumn] :: DeltaPos -> !Int

-- | Smart constructor for a <a>DeltaPos</a>. It preserves the invariant
--   that for the <a>DifferentLine</a> constructor <a>deltaLine</a> is
--   always &gt; 0.
deltaPos :: Int -> Int -> DeltaPos
getDeltaLine :: DeltaPos -> Int

-- | The exact print annotations (EPAs) are kept in the HsSyn AST for the
--   GhcPs phase. We do not always have EPAs though, only for code that has
--   been parsed as they do not exist for generated code. This type
--   captures that they may be missing.
--   
--   A goal of the annotations is that an AST can be edited, including
--   moving subtrees from one place to another, duplicating them, and so
--   on. This means that each fragment must be self-contained. To this end,
--   each annotated fragment keeps track of the anchor position it was
--   originally captured at, being simply the start span of the topmost
--   element of the ast fragment. This gives us a way to later re-calculate
--   all Located items in this layer of the AST, as well as any annotations
--   captured. The comments associated with the AST fragment are also
--   captured here.
--   
--   The <a>ann</a> type parameter allows this general structure to be
--   specialised to the specific set of locations of original exact print
--   annotation elements. So for <tt>HsLet</tt> we have
--   
--   type instance XLet GhcPs = EpAnn AnnsLet data AnnsLet = AnnsLet {
--   alLet :: EpaLocation, alIn :: EpaLocation } deriving Data
--   
--   The spacing between the items under the scope of a given EpAnn is
--   normally derived from the original <a>Anchor</a>. But if a sub-element
--   is not in its original position, the required spacing can be directly
--   captured in the <a>anchor_op</a> field of the <a>entry</a> Anchor.
--   This allows us to freely move elements around, and stitch together new
--   AST fragments out of old ones, and have them still printed out in a
--   precise way.
data EpAnn ann
EpAnn :: !Anchor -> !ann -> !EpAnnComments -> EpAnn ann

-- | Base location for the start of the syntactic element holding the
--   annotations.
[entry] :: EpAnn ann -> !Anchor

-- | Annotations added by the Parser
[anns] :: EpAnn ann -> !ann

-- | Comments enclosed in the SrcSpan of the element this <a>EpAnn</a> is
--   attached to
[comments] :: EpAnn ann -> !EpAnnComments

-- | No Annotation for generated code, e.g. from TH, deriving, etc.
EpAnnNotUsed :: EpAnn ann

-- | An <a>Anchor</a> records the base location for the start of the
--   syntactic element holding the annotations, and is used as the point of
--   reference for calculating delta positions for contained annotations.
--   It is also normally used as the reference point for the spacing of the
--   element relative to its container. If it is moved, that relationship
--   is tracked in the <a>anchor_op</a> instead.
data Anchor
Anchor :: RealSrcSpan -> AnchorOperation -> Anchor

-- | Base location for the start of the syntactic element holding the
--   annotations.
[anchor] :: Anchor -> RealSrcSpan
[anchor_op] :: Anchor -> AnchorOperation

-- | If tools modify the parsed source, the <a>MovedAnchor</a> variant can
--   directly provide the spacing for this item relative to the previous
--   one when printing. This allows AST fragments with a particular anchor
--   to be freely moved, without worrying about recalculating the
--   appropriate anchor span.
data AnchorOperation
UnchangedAnchor :: AnchorOperation
MovedAnchor :: DeltaPos -> AnchorOperation
spanAsAnchor :: SrcSpan -> Anchor
realSpanAsAnchor :: RealSrcSpan -> Anchor

-- | Short form for <a>EpAnnNotUsed</a>
noAnn :: EpAnn a

-- | When we are parsing we add comments that belong a particular AST
--   element, and print them together with the element, interleaving them
--   into the output stream. But when editing the AST to move fragments
--   around it is useful to be able to first separate the comments into
--   those occurring before the AST element and those following it. The
--   <a>EpaCommentsBalanced</a> constructor is used to do this. The GHC
--   parser will only insert the <a>EpaComments</a> form.
data EpAnnComments
EpaComments :: ![LEpaComment] -> EpAnnComments
[priorComments] :: EpAnnComments -> ![LEpaComment]
EpaCommentsBalanced :: ![LEpaComment] -> ![LEpaComment] -> EpAnnComments
[priorComments] :: EpAnnComments -> ![LEpaComment]
[followingComments] :: EpAnnComments -> ![LEpaComment]
type LEpaComment = GenLocated Anchor EpaComment
emptyComments :: EpAnnComments
getFollowingComments :: EpAnnComments -> [LEpaComment]
setFollowingComments :: EpAnnComments -> [LEpaComment] -> EpAnnComments
setPriorComments :: EpAnnComments -> [LEpaComment] -> EpAnnComments
type EpAnnCO = -- | Api Annotations for comments only EpAnn NoEpAnns
type LocatedA = GenLocated SrcSpanAnnA
type LocatedL = GenLocated SrcSpanAnnL
type LocatedC = GenLocated SrcSpanAnnC
type LocatedN = GenLocated SrcSpanAnnN

-- | General representation of a <a>GenLocated</a> type carrying a
--   parameterised annotation type.
type LocatedAn an = GenLocated (SrcAnn an)
type LocatedP = GenLocated SrcSpanAnnP
type SrcSpanAnnA = SrcAnn AnnListItem
type SrcSpanAnnL = SrcAnn AnnList
type SrcSpanAnnP = SrcAnn AnnPragma
type SrcSpanAnnC = SrcAnn AnnContext
type SrcSpanAnnN = SrcAnn NameAnn

-- | The 'SrcSpanAnn'' type wraps a normal <a>SrcSpan</a>, together with an
--   extra annotation type. This is mapped to a specific <a>GenLocated</a>
--   usage in the AST through the <tt>XRec</tt> and <tt>Anno</tt> type
--   families.
data SrcSpanAnn' a
SrcSpanAnn :: !a -> !SrcSpan -> SrcSpanAnn' a
[ann] :: SrcSpanAnn' a -> !a
[locA] :: SrcSpanAnn' a -> !SrcSpan

-- | We mostly use 'SrcSpanAnn'' with an 'EpAnn''
type SrcAnn ann = SrcSpanAnn' (EpAnn ann)

-- | Annotation for items appearing in a list. They can have one or more
--   trailing punctuations items, such as commas or semicolons.
data AnnListItem
AnnListItem :: [TrailingAnn] -> AnnListItem
[lann_trailing] :: AnnListItem -> [TrailingAnn]

-- | Annotation for the "container" of a list. This captures surrounding
--   items such as braces if present, and introductory keywords such as
--   'where'.
data AnnList
AnnList :: Maybe Anchor -> Maybe AddEpAnn -> Maybe AddEpAnn -> [AddEpAnn] -> [TrailingAnn] -> AnnList

-- | start point of a list having layout
[al_anchor] :: AnnList -> Maybe Anchor
[al_open] :: AnnList -> Maybe AddEpAnn
[al_close] :: AnnList -> Maybe AddEpAnn

-- | context, such as 'where' keyword
[al_rest] :: AnnList -> [AddEpAnn]

-- | items appearing after the list, such as '=&gt;' for a context
[al_trailing] :: AnnList -> [TrailingAnn]

-- | exact print annotation for an item having surrounding "brackets", such
--   as tuples or lists
data AnnParen
AnnParen :: ParenType -> EpaLocation -> EpaLocation -> AnnParen
[ap_adornment] :: AnnParen -> ParenType
[ap_open] :: AnnParen -> EpaLocation
[ap_close] :: AnnParen -> EpaLocation

-- | Detail of the "brackets" used in an <a>AnnParen</a> exact print
--   annotation.
data ParenType

-- | '(', ')'
AnnParens :: ParenType

-- | '(#', '#)'
AnnParensHash :: ParenType

-- | '[', ']'
AnnParensSquare :: ParenType

-- | Maps the <a>ParenType</a> to the related opening and closing
--   AnnKeywordId. Used when actually printing the item.
parenTypeKws :: ParenType -> (AnnKeywordId, AnnKeywordId)

-- | exact print annotation used for capturing the locations of annotations
--   in pragmas.
data AnnPragma
AnnPragma :: AddEpAnn -> AddEpAnn -> [AddEpAnn] -> AnnPragma
[apr_open] :: AnnPragma -> AddEpAnn
[apr_close] :: AnnPragma -> AddEpAnn
[apr_rest] :: AnnPragma -> [AddEpAnn]

-- | Exact print annotation for the <tt>Context</tt> data type.
data AnnContext
AnnContext :: Maybe (IsUnicodeSyntax, EpaLocation) -> [EpaLocation] -> [EpaLocation] -> AnnContext

-- | location and encoding of the '=&gt;', if present.
[ac_darrow] :: AnnContext -> Maybe (IsUnicodeSyntax, EpaLocation)

-- | zero or more opening parentheses.
[ac_open] :: AnnContext -> [EpaLocation]

-- | zero or more closing parentheses.
[ac_close] :: AnnContext -> [EpaLocation]

-- | exact print annotations for a <tt>RdrName</tt>. There are many kinds
--   of adornment that can be attached to a given <tt>RdrName</tt>. This
--   type captures them, as detailed on the individual constructors.
data NameAnn

-- | Used for a name with an adornment, so <tt>`foo`</tt>, <tt>(bar)</tt>
NameAnn :: NameAdornment -> EpaLocation -> EpaLocation -> EpaLocation -> [TrailingAnn] -> NameAnn
[nann_adornment] :: NameAnn -> NameAdornment
[nann_open] :: NameAnn -> EpaLocation
[nann_name] :: NameAnn -> EpaLocation
[nann_close] :: NameAnn -> EpaLocation
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>(,,,)</tt>, or @()#
NameAnnCommas :: NameAdornment -> EpaLocation -> [EpaLocation] -> EpaLocation -> [TrailingAnn] -> NameAnn
[nann_adornment] :: NameAnn -> NameAdornment
[nann_open] :: NameAnn -> EpaLocation
[nann_commas] :: NameAnn -> [EpaLocation]
[nann_close] :: NameAnn -> EpaLocation
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>(# | | #)</tt>
NameAnnBars :: NameAdornment -> EpaLocation -> [EpaLocation] -> EpaLocation -> [TrailingAnn] -> NameAnn
[nann_adornment] :: NameAnn -> NameAdornment
[nann_open] :: NameAnn -> EpaLocation
[nann_bars] :: NameAnn -> [EpaLocation]
[nann_close] :: NameAnn -> EpaLocation
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>()</tt>, <tt>(##)</tt>, <tt>[]</tt>
NameAnnOnly :: NameAdornment -> EpaLocation -> EpaLocation -> [TrailingAnn] -> NameAnn
[nann_adornment] :: NameAnn -> NameAdornment
[nann_open] :: NameAnn -> EpaLocation
[nann_close] :: NameAnn -> EpaLocation
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for <tt>-&gt;</tt>, as an identifier
NameAnnRArrow :: EpaLocation -> [TrailingAnn] -> NameAnn
[nann_name] :: NameAnn -> EpaLocation
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used for an item with a leading <tt>'</tt>. The annotation for
--   unquoted item is stored in <a>nann_quoted</a>.
NameAnnQuote :: EpaLocation -> SrcSpanAnnN -> [TrailingAnn] -> NameAnn
[nann_quote] :: NameAnn -> EpaLocation
[nann_quoted] :: NameAnn -> SrcSpanAnnN
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | Used when adding a <a>TrailingAnn</a> to an existing <a>LocatedN</a>
--   which has no Api Annotation (via the <a>EpAnnNotUsed</a> constructor.
NameAnnTrailing :: [TrailingAnn] -> NameAnn
[nann_trailing] :: NameAnn -> [TrailingAnn]

-- | A <a>NameAnn</a> can capture the locations of surrounding adornments,
--   such as parens or backquotes. This data type identifies what
--   particular pair are being used.
data NameAdornment

-- | '(' ')'
NameParens :: NameAdornment

-- | '(#' '#)'
NameParensHash :: NameAdornment

-- | '`'
NameBackquotes :: NameAdornment

-- | '[' ']'
NameSquare :: NameAdornment
data NoEpAnns
NoEpAnns :: NoEpAnns

-- | Captures the sort order of sub elements. This is needed when the
--   sub-elements have been split (as in a HsLocalBind which holds separate
--   binds and sigs) or for infix patterns where the order has been
--   re-arranged. It is captured explicitly so that after the Delta phase a
--   SrcSpan is used purely as an index into the annotations, allowing
--   transformations of the AST including the introduction of new Located
--   items or re-arranging existing ones.
data AnnSortKey
NoAnnSortKey :: AnnSortKey
AnnSortKey :: [RealSrcSpan] -> AnnSortKey

-- | Captures the location of punctuation occurring between items, normally
--   in a list. It is captured as a trailing annotation.
data TrailingAnn

-- | Trailing ';'
AddSemiAnn :: EpaLocation -> TrailingAnn

-- | Trailing ','
AddCommaAnn :: EpaLocation -> TrailingAnn

-- | Trailing '|'
AddVbarAnn :: EpaLocation -> TrailingAnn

-- | Convert a <a>TrailingAnn</a> to an <a>AddEpAnn</a>
trailingAnnToAddEpAnn :: TrailingAnn -> AddEpAnn

-- | Helper function used in the parser to add a <a>TrailingAnn</a> items
--   to an existing annotation.
addTrailingAnnToA :: SrcSpan -> TrailingAnn -> EpAnnComments -> EpAnn AnnListItem -> EpAnn AnnListItem

-- | Helper function used in the parser to add a <a>TrailingAnn</a> items
--   to an existing annotation.
addTrailingAnnToL :: SrcSpan -> TrailingAnn -> EpAnnComments -> EpAnn AnnList -> EpAnn AnnList

-- | Helper function used in the parser to add a comma location to an
--   existing annotation.
addTrailingCommaToN :: SrcSpan -> EpAnn NameAnn -> EpaLocation -> EpAnn NameAnn

-- | Helper function (temporary) during transition of names Discards any
--   annotations
la2na :: SrcSpanAnn' a -> SrcSpanAnnN

-- | Helper function (temporary) during transition of names Discards any
--   annotations
na2la :: SrcSpanAnn' a -> SrcAnn ann
n2l :: LocatedN a -> LocatedA a

-- | Helper function (temporary) during transition of names Discards any
--   annotations
l2n :: LocatedAn a1 a2 -> LocatedN a2
l2l :: SrcSpanAnn' a -> SrcAnn ann

-- | Helper function (temporary) during transition of names Discards any
--   annotations
la2la :: LocatedAn ann1 a2 -> LocatedAn ann2 a2
reLoc :: LocatedAn a e -> Located e
reLocA :: Located e -> LocatedAn ann e
reLocL :: LocatedN e -> LocatedA e
reLocC :: LocatedN e -> LocatedC e
reLocN :: LocatedN a -> Located a
srcSpan2e :: SrcSpan -> EpaLocation
la2e :: SrcSpanAnn' a -> EpaLocation
realSrcSpan :: SrcSpan -> RealSrcSpan
extraToAnnList :: AnnList -> [AddEpAnn] -> AnnList
reAnn :: [TrailingAnn] -> EpAnnComments -> Located a -> LocatedA a
reAnnL :: ann -> EpAnnComments -> Located e -> GenLocated (SrcAnn ann) e
reAnnC :: AnnContext -> EpAnnComments -> Located a -> LocatedC a
addAnns :: EpAnn [AddEpAnn] -> [AddEpAnn] -> EpAnnComments -> EpAnn [AddEpAnn]
addAnnsA :: SrcSpanAnnA -> [TrailingAnn] -> EpAnnComments -> SrcSpanAnnA

-- | The annotations need to all come after the anchor. Make sure this is
--   the case.
widenSpan :: SrcSpan -> [AddEpAnn] -> SrcSpan
widenAnchor :: Anchor -> [AddEpAnn] -> Anchor
widenAnchorR :: Anchor -> RealSrcSpan -> Anchor
widenLocatedAn :: SrcSpanAnn' an -> [AddEpAnn] -> SrcSpanAnn' an
getLocAnn :: Located a -> SrcSpanAnnA
epAnnAnns :: EpAnn [AddEpAnn] -> [AddEpAnn]
epAnnAnnsL :: EpAnn a -> [a]
annParen2AddEpAnn :: EpAnn AnnParen -> [AddEpAnn]
epAnnComments :: EpAnn an -> EpAnnComments
sortLocatedA :: [GenLocated (SrcSpanAnn' a) e] -> [GenLocated (SrcSpanAnn' a) e]
mapLocA :: (a -> b) -> GenLocated SrcSpan a -> GenLocated (SrcAnn ann) b
combineLocsA :: Semigroup a => GenLocated (SrcAnn a) e1 -> GenLocated (SrcAnn a) e2 -> SrcAnn a
combineSrcSpansA :: Semigroup a => SrcAnn a -> SrcAnn a -> SrcAnn a

-- | Combine locations from two <a>Located</a> things and add them to a
--   third thing
addCLocA :: GenLocated (SrcSpanAnn' a) e1 -> GenLocated SrcSpan e2 -> e3 -> GenLocated (SrcAnn ann) e3
addCLocAA :: GenLocated (SrcSpanAnn' a1) e1 -> GenLocated (SrcSpanAnn' a2) e2 -> e3 -> GenLocated (SrcAnn ann) e3
noLocA :: a -> LocatedAn an a
getLocA :: GenLocated (SrcSpanAnn' a) e -> SrcSpan
noSrcSpanA :: SrcAnn ann
noAnnSrcSpan :: SrcSpan -> SrcAnn ann
noComments :: EpAnnCO
comment :: RealSrcSpan -> EpAnnComments -> EpAnnCO

-- | Add additional comments to a <a>SrcAnn</a>, used for manipulating the
--   AST prior to exact printing the changed one.
addCommentsToSrcAnn :: Monoid ann => SrcAnn ann -> EpAnnComments -> SrcAnn ann

-- | Replace any existing comments on a <a>SrcAnn</a>, used for
--   manipulating the AST prior to exact printing the changed one.
setCommentsSrcAnn :: Monoid ann => SrcAnn ann -> EpAnnComments -> SrcAnn ann

-- | Add additional comments, used for manipulating the AST prior to exact
--   printing the changed one.
addCommentsToEpAnn :: Monoid a => SrcSpan -> EpAnn a -> EpAnnComments -> EpAnn a

-- | Replace any existing comments, used for manipulating the AST prior to
--   exact printing the changed one.
setCommentsEpAnn :: Monoid a => SrcSpan -> EpAnn a -> EpAnnComments -> EpAnn a

-- | Transfer comments and trailing items from the annotations in the first
--   <a>SrcSpanAnnA</a> argument to those in the second.
transferAnnsA :: SrcSpanAnnA -> SrcSpanAnnA -> (SrcSpanAnnA, SrcSpanAnnA)

-- | Remove the exact print annotations payload, leaving only the anchor
--   and comments.
commentsOnlyA :: Monoid ann => SrcAnn ann -> SrcAnn ann

-- | Remove the comments, leaving the exact print annotations payload
removeCommentsA :: SrcAnn ann -> SrcAnn ann
placeholderRealSpan :: RealSrcSpan
instance GHC.Show.Show GHC.Parser.Annotation.AnnKeywordId
instance Data.Data.Data GHC.Parser.Annotation.AnnKeywordId
instance GHC.Classes.Ord GHC.Parser.Annotation.AnnKeywordId
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnKeywordId
instance GHC.Show.Show GHC.Parser.Annotation.IsUnicodeSyntax
instance Data.Data.Data GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Classes.Ord GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Classes.Eq GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Show.Show GHC.Parser.Annotation.HasE
instance Data.Data.Data GHC.Parser.Annotation.HasE
instance GHC.Classes.Ord GHC.Parser.Annotation.HasE
instance GHC.Classes.Eq GHC.Parser.Annotation.HasE
instance GHC.Show.Show GHC.Parser.Annotation.EpaCommentTok
instance Data.Data.Data GHC.Parser.Annotation.EpaCommentTok
instance GHC.Classes.Eq GHC.Parser.Annotation.EpaCommentTok
instance GHC.Show.Show GHC.Parser.Annotation.EpaComment
instance Data.Data.Data GHC.Parser.Annotation.EpaComment
instance GHC.Classes.Eq GHC.Parser.Annotation.EpaComment
instance Data.Data.Data GHC.Parser.Annotation.DeltaPos
instance GHC.Classes.Ord GHC.Parser.Annotation.DeltaPos
instance GHC.Classes.Eq GHC.Parser.Annotation.DeltaPos
instance GHC.Show.Show GHC.Parser.Annotation.DeltaPos
instance GHC.Show.Show GHC.Parser.Annotation.AnchorOperation
instance GHC.Classes.Eq GHC.Parser.Annotation.AnchorOperation
instance Data.Data.Data GHC.Parser.Annotation.AnchorOperation
instance GHC.Show.Show GHC.Parser.Annotation.Anchor
instance GHC.Classes.Eq GHC.Parser.Annotation.Anchor
instance Data.Data.Data GHC.Parser.Annotation.Anchor
instance GHC.Classes.Eq GHC.Parser.Annotation.EpAnnComments
instance Data.Data.Data GHC.Parser.Annotation.EpAnnComments
instance GHC.Base.Functor GHC.Parser.Annotation.EpAnn
instance GHC.Classes.Eq ann => GHC.Classes.Eq (GHC.Parser.Annotation.EpAnn ann)
instance Data.Data.Data ann => Data.Data.Data (GHC.Parser.Annotation.EpAnn ann)
instance GHC.Classes.Eq GHC.Parser.Annotation.EpaLocation
instance Data.Data.Data GHC.Parser.Annotation.EpaLocation
instance GHC.Classes.Eq GHC.Parser.Annotation.TokenLocation
instance Data.Data.Data GHC.Parser.Annotation.TokenLocation
instance GHC.Classes.Eq GHC.Parser.Annotation.AddEpAnn
instance Data.Data.Data GHC.Parser.Annotation.AddEpAnn
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Parser.Annotation.SrcSpanAnn' a)
instance Data.Data.Data a => Data.Data.Data (GHC.Parser.Annotation.SrcSpanAnn' a)
instance GHC.Classes.Eq GHC.Parser.Annotation.TrailingAnn
instance Data.Data.Data GHC.Parser.Annotation.TrailingAnn
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnListItem
instance Data.Data.Data GHC.Parser.Annotation.AnnListItem
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnList
instance Data.Data.Data GHC.Parser.Annotation.AnnList
instance Data.Data.Data GHC.Parser.Annotation.ParenType
instance GHC.Classes.Ord GHC.Parser.Annotation.ParenType
instance GHC.Classes.Eq GHC.Parser.Annotation.ParenType
instance Data.Data.Data GHC.Parser.Annotation.AnnParen
instance Data.Data.Data GHC.Parser.Annotation.AnnContext
instance Data.Data.Data GHC.Parser.Annotation.NameAdornment
instance GHC.Classes.Ord GHC.Parser.Annotation.NameAdornment
instance GHC.Classes.Eq GHC.Parser.Annotation.NameAdornment
instance GHC.Classes.Eq GHC.Parser.Annotation.NameAnn
instance Data.Data.Data GHC.Parser.Annotation.NameAnn
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnPragma
instance Data.Data.Data GHC.Parser.Annotation.AnnPragma
instance GHC.Classes.Eq GHC.Parser.Annotation.AnnSortKey
instance Data.Data.Data GHC.Parser.Annotation.AnnSortKey
instance GHC.Classes.Ord GHC.Parser.Annotation.NoEpAnns
instance GHC.Classes.Eq GHC.Parser.Annotation.NoEpAnns
instance Data.Data.Data GHC.Parser.Annotation.NoEpAnns
instance GHC.Base.Semigroup GHC.Parser.Annotation.NoEpAnns
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.NoEpAnns
instance GHC.Base.Semigroup GHC.Parser.Annotation.AnnSortKey
instance GHC.Base.Monoid GHC.Parser.Annotation.AnnSortKey
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnSortKey
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnPragma
instance GHC.Base.Semigroup GHC.Parser.Annotation.NameAnn
instance GHC.Base.Monoid GHC.Parser.Annotation.NameAnn
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.NameAnn
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.NameAdornment
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnContext
instance GHC.Base.Semigroup GHC.Parser.Annotation.AnnList
instance GHC.Base.Monoid GHC.Parser.Annotation.AnnList
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnList
instance GHC.Base.Semigroup GHC.Parser.Annotation.AnnListItem
instance GHC.Base.Monoid GHC.Parser.Annotation.AnnListItem
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnListItem
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.TrailingAnn
instance GHC.Types.Name.NamedThing (GHC.Types.SrcLoc.Located a) => GHC.Types.Name.NamedThing (GHC.Parser.Annotation.LocatedAn an a)
instance GHC.Base.Semigroup an => GHC.Base.Semigroup (GHC.Parser.Annotation.SrcSpanAnn' an)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Parser.Annotation.SrcSpanAnn' a)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable e) => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated (GHC.Parser.Annotation.SrcSpanAnn' a) e)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.OutputableBndr e) => GHC.Utils.Outputable.OutputableBndr (GHC.Types.SrcLoc.GenLocated (GHC.Parser.Annotation.SrcSpanAnn' a) e)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AddEpAnn
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated GHC.Parser.Annotation.TokenLocation a)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.EpaLocation
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Parser.Annotation.EpAnn a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Parser.Annotation.EpAnn a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Parser.Annotation.EpAnn a)
instance GHC.Base.Semigroup GHC.Parser.Annotation.EpAnnComments
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.EpAnnComments
instance GHC.Classes.Ord GHC.Parser.Annotation.Anchor
instance GHC.Base.Semigroup GHC.Parser.Annotation.Anchor
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.Anchor
instance GHC.Utils.Outputable.Outputable (GHC.Types.SrcLoc.GenLocated GHC.Parser.Annotation.Anchor GHC.Parser.Annotation.EpaComment)
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnchorOperation
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.DeltaPos
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.EpaComment
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.IsUnicodeSyntax
instance GHC.Utils.Outputable.Outputable GHC.Parser.Annotation.AnnKeywordId


-- | Boolean formulas without quantifiers and without negation. Such a
--   formula consists of variables, conjunctions (and), and disjunctions
--   (or).
--   
--   This module is used to represent minimal complete definitions for
--   classes.
module GHC.Data.BooleanFormula
data BooleanFormula a
Var :: a -> BooleanFormula a
And :: [LBooleanFormula a] -> BooleanFormula a
Or :: [LBooleanFormula a] -> BooleanFormula a
Parens :: LBooleanFormula a -> BooleanFormula a
type LBooleanFormula a = LocatedL (BooleanFormula a)
mkFalse :: BooleanFormula a
mkTrue :: BooleanFormula a
mkAnd :: Eq a => [LBooleanFormula a] -> BooleanFormula a
mkOr :: Eq a => [LBooleanFormula a] -> BooleanFormula a
mkVar :: a -> BooleanFormula a
isFalse :: BooleanFormula a -> Bool
isTrue :: BooleanFormula a -> Bool
eval :: (a -> Bool) -> BooleanFormula a -> Bool
simplify :: Eq a => (a -> Maybe Bool) -> BooleanFormula a -> BooleanFormula a
isUnsatisfied :: Eq a => (a -> Bool) -> BooleanFormula a -> Maybe (BooleanFormula a)
implies :: Uniquable a => BooleanFormula a -> BooleanFormula a -> Bool
impliesAtom :: Eq a => BooleanFormula a -> a -> Bool
pprBooleanFormula :: (Rational -> a -> SDoc) -> Rational -> BooleanFormula a -> SDoc
pprBooleanFormulaNice :: Outputable a => BooleanFormula a -> SDoc
instance Data.Traversable.Traversable GHC.Data.BooleanFormula.BooleanFormula
instance Data.Foldable.Foldable GHC.Data.BooleanFormula.BooleanFormula
instance GHC.Base.Functor GHC.Data.BooleanFormula.BooleanFormula
instance Data.Data.Data a => Data.Data.Data (GHC.Data.BooleanFormula.BooleanFormula a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Data.BooleanFormula.BooleanFormula a)
instance GHC.Utils.Outputable.OutputableBndr a => GHC.Utils.Outputable.Outputable (GHC.Data.BooleanFormula.BooleanFormula a)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Data.BooleanFormula.BooleanFormula a)


-- | Computing fingerprints of values serializable with GHC's "Binary"
--   module.
module GHC.Iface.Recomp.Binary
fingerprintBinMem :: BinHandle -> IO Fingerprint
computeFingerprint :: Binary a => (BinHandle -> Name -> IO ()) -> a -> IO Fingerprint

-- | Used when we want to fingerprint a structure without depending on the
--   fingerprints of external Names that it refers to.
putNameLiterally :: BinHandle -> Name -> IO ()

module GHC.Hs.Extension
type IsSrcSpanAnn p a = (Anno (IdGhcP p) ~ SrcSpanAnn' (EpAnn a), IsPass p)

-- | Used as a data type index for the hsSyn AST; also serves as a
--   singleton type for Pass
data GhcPass (c :: Pass)
[GhcPs] :: GhcPass 'Parsed
[GhcRn] :: GhcPass 'Renamed
[GhcTc] :: GhcPass 'Typechecked
data Pass
Parsed :: Pass
Renamed :: Pass
Typechecked :: Pass
type GhcPs = GhcPass 'Parsed
type GhcRn = GhcPass 'Renamed
type GhcTc = GhcPass 'Typechecked

-- | Allows us to check what phase we're in at GHC's runtime. For example,
--   this class allows us to write &gt; f :: forall p. IsPass p =&gt;
--   HsExpr (GhcPass p) -&gt; blah &gt; f e = case ghcPass @p of &gt; GhcPs
--   -&gt; ... in this RHS we have HsExpr GhcPs... &gt; GhcRn -&gt; ... in
--   this RHS we have HsExpr GhcRn... &gt; GhcTc -&gt; ... in this RHS we
--   have HsExpr GhcTc... which is very useful, for example, when
--   pretty-printing. See Note [IsPass].
class (NoGhcTcPass (NoGhcTcPass p) ~ NoGhcTcPass p, IsPass (NoGhcTcPass p)) => IsPass p
ghcPass :: IsPass p => GhcPass p

-- | Maps the "normal" id type for a given GHC pass
type family IdGhcP pass
type family NoGhcTcPass (p :: Pass) :: Pass

-- | Constraint type to bundle up the requirement for <a>OutputableBndr</a>
--   on both the <tt>id</tt> and the <a>NoGhcTc</a> of it. See Note
--   [NoGhcTc].
type OutputableBndrId pass = (OutputableBndr (IdGhcP pass), OutputableBndr (IdGhcP (NoGhcTcPass pass)), Outputable (GenLocated (Anno (IdGhcP pass)) (IdGhcP pass)), Outputable (GenLocated (Anno (IdGhcP (NoGhcTcPass pass))) (IdGhcP (NoGhcTcPass pass))), IsPass pass)
pprIfPs :: forall p. IsPass p => (p ~ 'Parsed => SDoc) -> SDoc
pprIfRn :: forall p. IsPass p => (p ~ 'Renamed => SDoc) -> SDoc
pprIfTc :: forall p. IsPass p => (p ~ 'Typechecked => SDoc) -> SDoc
noHsTok :: GenLocated TokenLocation (HsToken tok)
noHsUniTok :: GenLocated TokenLocation (HsUniToken tok utok)
instance Data.Data.Data GHC.Hs.Extension.Pass
instance Data.Typeable.Internal.Typeable p => Data.Data.Data (Language.Haskell.Syntax.Concrete.LayoutInfo (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.IsPass 'GHC.Hs.Extension.Parsed
instance GHC.Hs.Extension.IsPass 'GHC.Hs.Extension.Renamed
instance GHC.Hs.Extension.IsPass 'GHC.Hs.Extension.Typechecked
instance Language.Haskell.Syntax.Extension.UnXRec (GHC.Hs.Extension.GhcPass p)
instance Language.Haskell.Syntax.Extension.MapXRec (GHC.Hs.Extension.GhcPass p)
instance Data.Typeable.Internal.Typeable p => Data.Data.Data (GHC.Hs.Extension.GhcPass p)
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Extension.NoExtField
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Extension.DataConCantHappen
instance GHC.TypeLits.KnownSymbol tok => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Concrete.HsToken tok)
instance (GHC.TypeLits.KnownSymbol tok, GHC.TypeLits.KnownSymbol utok) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Concrete.HsUniToken tok utok)


-- | Types and functions for raw and lexed docstrings.
module GHC.Hs.Doc

-- | A docstring with the (probable) identifiers found in it.
type HsDoc = WithHsDocIdentifiers HsDocString

-- | Annotate a value with the probable identifiers found in it These will
--   be used by haddock to generate links.
--   
--   The identifiers are bundled along with their location in the source
--   file. This is useful for tooling to know exactly where they originate.
--   
--   This type is currently used in two places - for regular documentation
--   comments, with <tt>a</tt> set to <a>HsDocString</a>, and for adding
--   identifier information to warnings, where <tt>a</tt> is
--   <tt>StringLiteral</tt>
data WithHsDocIdentifiers a pass
WithHsDocIdentifiers :: !a -> ![Located (IdP pass)] -> WithHsDocIdentifiers a pass
[hsDocString] :: WithHsDocIdentifiers a pass -> !a
[hsDocIdentifiers] :: WithHsDocIdentifiers a pass -> ![Located (IdP pass)]

-- | Extract a mapping from the lexed identifiers to the names they may
--   correspond to.
hsDocIds :: WithHsDocIdentifiers a GhcRn -> NameSet
type LHsDoc pass = Located (HsDoc pass)

-- | Print a doc with its identifiers, useful for debugging
pprHsDocDebug :: Outputable (IdP name) => HsDoc name -> SDoc

-- | Pretty print a thing with its doc The docstring will include the
--   comment decorators '-- |', '{-|' etc and will come either before or
--   after depending on how it was written i.e it will come after the thing
--   if it is a '-- ^' or '{-^' and before otherwise.
pprWithDoc :: LHsDoc name -> SDoc -> SDoc

-- | See <tt>pprWithHsDoc</tt>
pprMaybeWithDoc :: Maybe (LHsDoc name) -> SDoc -> SDoc

-- | Maps of docs that were added via Template Haskell's <tt>putDoc</tt>.
data ExtractedTHDocs
ExtractedTHDocs :: Maybe (HsDoc GhcRn) -> UniqMap Name (HsDoc GhcRn) -> UniqMap Name (IntMap (HsDoc GhcRn)) -> UniqMap Name (HsDoc GhcRn) -> ExtractedTHDocs

-- | The added module header documentation, if it exists.
[ethd_mod_header] :: ExtractedTHDocs -> Maybe (HsDoc GhcRn)

-- | The documentation added to declarations.
[ethd_decl_docs] :: ExtractedTHDocs -> UniqMap Name (HsDoc GhcRn)

-- | The documentation added to function arguments.
[ethd_arg_docs] :: ExtractedTHDocs -> UniqMap Name (IntMap (HsDoc GhcRn))

-- | The documentation added to class and family instances.
[ethd_inst_docs] :: ExtractedTHDocs -> UniqMap Name (HsDoc GhcRn)

-- | A simplified version of <a>IE</a>.
data DocStructureItem
DsiSectionHeading :: !Int -> !HsDoc GhcRn -> DocStructureItem
DsiDocChunk :: !HsDoc GhcRn -> DocStructureItem
DsiNamedChunkRef :: !String -> DocStructureItem
DsiExports :: !Avails -> DocStructureItem
DsiModExport :: !NonEmpty ModuleName -> !Avails -> DocStructureItem
type DocStructure = [DocStructureItem]
data Docs
Docs :: Maybe (HsDoc GhcRn) -> UniqMap Name [HsDoc GhcRn] -> UniqMap Name (IntMap (HsDoc GhcRn)) -> DocStructure -> Map String (HsDoc GhcRn) -> Maybe String -> Maybe Language -> EnumSet Extension -> Docs

-- | Module header.
[docs_mod_hdr] :: Docs -> Maybe (HsDoc GhcRn)

-- | Docs for declarations: functions, data types, instances, methods etc.
--   A list because sometimes subsequent haddock comments can be combined
--   into one
[docs_decls] :: Docs -> UniqMap Name [HsDoc GhcRn]

-- | Docs for arguments. E.g. function arguments, method arguments.
[docs_args] :: Docs -> UniqMap Name (IntMap (HsDoc GhcRn))
[docs_structure] :: Docs -> DocStructure

-- | Map from chunk name to content.
--   
--   This map will be empty unless we have an explicit export list from
--   which we can reference the chunks.
[docs_named_chunks] :: Docs -> Map String (HsDoc GhcRn)

-- | Haddock options from <tt>OPTIONS_HADDOCK</tt> or from
--   <tt>-haddock-opts</tt>.
[docs_haddock_opts] :: Docs -> Maybe String

-- | The <a>Language</a> used in the module, for example
--   <a>Haskell2010</a>.
[docs_language] :: Docs -> Maybe Language

-- | The full set of language extensions used in the module.
[docs_extensions] :: Docs -> EnumSet Extension
emptyDocs :: Docs
instance (Data.Data.Data pass, Data.Data.Data (Language.Haskell.Syntax.Extension.IdP pass), Data.Data.Data a) => Data.Data.Data (GHC.Hs.Doc.WithHsDocIdentifiers a pass)
instance (GHC.Classes.Eq (Language.Haskell.Syntax.Extension.IdP pass), GHC.Classes.Eq a) => GHC.Classes.Eq (GHC.Hs.Doc.WithHsDocIdentifiers a pass)
instance Control.DeepSeq.NFData GHC.Hs.Doc.Docs
instance GHC.Utils.Binary.Binary GHC.Hs.Doc.Docs
instance GHC.Utils.Outputable.Outputable GHC.Hs.Doc.Docs
instance GHC.Utils.Binary.Binary GHC.Hs.Doc.DocStructureItem
instance GHC.Utils.Outputable.Outputable GHC.Hs.Doc.DocStructureItem
instance Control.DeepSeq.NFData GHC.Hs.Doc.DocStructureItem
instance (Control.DeepSeq.NFData (Language.Haskell.Syntax.Extension.IdP pass), Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (GHC.Hs.Doc.WithHsDocIdentifiers a pass)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Hs.Doc.WithHsDocIdentifiers a pass)
instance GHC.Utils.Binary.Binary a => GHC.Utils.Binary.Binary (GHC.Hs.Doc.WithHsDocIdentifiers a GHC.Hs.Extension.GhcRn)

module Language.Haskell.Syntax.ImpExp

-- | Located Import Declaration
type LImportDecl pass = -- | When in a list this may have -- --  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' XRec pass (ImportDecl pass)

-- | If/how an import is <tt>qualified</tt>.
data ImportDeclQualifiedStyle

-- | <tt>qualified</tt> appears in prepositive position.
QualifiedPre :: ImportDeclQualifiedStyle

-- | <tt>qualified</tt> appears in postpositive position.
QualifiedPost :: ImportDeclQualifiedStyle

-- | Not qualified.
NotQualified :: ImportDeclQualifiedStyle

-- | Indicates whether a module name is referring to a boot interface
--   (hs-boot file) or regular module (hs file). We need to treat boot
--   modules specially when building compilation graphs, since they break
--   cycles. Regular source files and signature files are treated
--   equivalently.
data IsBootInterface
NotBoot :: IsBootInterface
IsBoot :: IsBootInterface

-- | Import Declaration
--   
--   A single Haskell <tt>import</tt> declaration.
data ImportDecl pass
ImportDecl :: XCImportDecl pass -> XRec pass ModuleName -> ImportDeclPkgQual pass -> IsBootInterface -> Bool -> ImportDeclQualifiedStyle -> Maybe (XRec pass ModuleName) -> Maybe (ImportListInterpretation, XRec pass [LIE pass]) -> ImportDecl pass
[ideclExt] :: ImportDecl pass -> XCImportDecl pass

-- | Module name.
[ideclName] :: ImportDecl pass -> XRec pass ModuleName

-- | Package qualifier.
[ideclPkgQual] :: ImportDecl pass -> ImportDeclPkgQual pass

-- | IsBoot <a>=</a> {-# SOURCE #-} import
[ideclSource] :: ImportDecl pass -> IsBootInterface

-- | True =&gt; safe import
[ideclSafe] :: ImportDecl pass -> Bool

-- | If/how the import is qualified.
[ideclQualified] :: ImportDecl pass -> ImportDeclQualifiedStyle

-- | as Module
[ideclAs] :: ImportDecl pass -> Maybe (XRec pass ModuleName)

-- | Explicit import list (EverythingBut =&gt; hiding, names)
[ideclImportList] :: ImportDecl pass -> Maybe (ImportListInterpretation, XRec pass [LIE pass])

-- | <a>AnnKeywordId</a>s
--   
--   <ul>
--   <li><a>AnnImport</a></li>
--   <li><a>AnnOpen</a>, <a>AnnClose</a> for ideclSource</li>
--   <li><a>AnnSafe</a>,<a>AnnQualified</a>,
--   <a>AnnPackageName</a>,<a>AnnAs</a>, <a>AnnVal</a></li>
--   <li><a>AnnHiding</a>,<a>AnnOpen</a>, <a>AnnClose</a> attached to
--   location in ideclImportList</li>
--   </ul>
XImportDecl :: !XXImportDecl pass -> ImportDecl pass

-- | Whether the import list is exactly what to import, or whether
--   <tt>hiding</tt> was used, and therefore everything but what was listed
--   should be imported
data ImportListInterpretation
Exactly :: ImportListInterpretation
EverythingBut :: ImportListInterpretation

-- | Located Import or Export
type LIE pass = -- | When in a list this may have -- --  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' XRec pass (IE pass)

-- | Imported or exported entity.
data IE pass

-- | Imported or Exported Variable
IEVar :: XIEVar pass -> LIEWrappedName pass -> IE pass

-- | Imported or exported Thing with Absent list
--   
--   The thing is a Class/Type (can't tell) - <a>AnnKeywordId</a>s :
--   <a>AnnPattern</a>, <a>AnnType</a>,<a>AnnVal</a>
IEThingAbs :: XIEThingAbs pass -> LIEWrappedName pass -> IE pass

-- | Imported or exported Thing with All imported or exported
--   
--   The thing is a Class<i>Type and the All refers to
--   methods</i>constructors
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a>,
--   <a>AnnDotdot</a>,<a>AnnClose</a>, <a>AnnType</a></li>
--   </ul>
IEThingAll :: XIEThingAll pass -> LIEWrappedName pass -> IE pass

-- | Imported or exported Thing With given imported or exported
--   
--   The thing is a Class/Type and the imported or exported things are
--   methods/constructors and record fields; see Note [IEThingWith] -
--   <a>AnnKeywordId</a>s : <a>AnnOpen</a>, <a>AnnClose</a>,
--   <a>AnnComma</a>, <a>AnnType</a>
IEThingWith :: XIEThingWith pass -> LIEWrappedName pass -> IEWildcard -> [LIEWrappedName pass] -> IE pass

-- | Imported or exported module contents
--   
--   (Export Only)
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnModule</a></li>
--   </ul>
IEModuleContents :: XIEModuleContents pass -> XRec pass ModuleName -> IE pass

-- | Doc section heading
IEGroup :: XIEGroup pass -> Int -> LHsDoc pass -> IE pass

-- | Some documentation
IEDoc :: XIEDoc pass -> LHsDoc pass -> IE pass

-- | Reference to named doc
IEDocNamed :: XIEDocNamed pass -> String -> IE pass
XIE :: !XXIE pass -> IE pass

-- | Wildcard in an import or export sublist, like the <tt>..</tt> in
--   <tt>import Mod ( T(Mk1, Mk2, ..) )</tt>.
data IEWildcard

-- | no wildcard in this list
NoIEWildcard :: IEWildcard

-- | wildcard after the given # of items in this list The <tt>Int</tt> is
--   in the range [0..n], where n is the length of the list.
IEWildcard :: Int -> IEWildcard

-- | A name in an import or export specification which may have adornments.
--   Used primarily for accurate pretty printing of ParsedSource, and API
--   Annotation placement. The <a>Annotation</a> is the location of the
--   adornment in the original source.
data IEWrappedName p

-- | no extra
IEName :: XIEName p -> LIdP p -> IEWrappedName p

-- | pattern X
IEPattern :: XIEPattern p -> LIdP p -> IEWrappedName p

-- | type (:+:)
IEType :: XIEType p -> LIdP p -> IEWrappedName p
XIEWrappedName :: !XXIEWrappedName p -> IEWrappedName p

-- | Located name with possible adornment - <a>AnnKeywordId</a>s :
--   <a>AnnType</a>, <a>AnnPattern</a>
type LIEWrappedName p = XRec p (IEWrappedName p)
instance Data.Data.Data Language.Haskell.Syntax.ImpExp.ImportDeclQualifiedStyle
instance GHC.Classes.Eq Language.Haskell.Syntax.ImpExp.ImportDeclQualifiedStyle
instance Data.Data.Data Language.Haskell.Syntax.ImpExp.IsBootInterface
instance GHC.Show.Show Language.Haskell.Syntax.ImpExp.IsBootInterface
instance GHC.Classes.Ord Language.Haskell.Syntax.ImpExp.IsBootInterface
instance GHC.Classes.Eq Language.Haskell.Syntax.ImpExp.IsBootInterface
instance Data.Data.Data Language.Haskell.Syntax.ImpExp.ImportListInterpretation
instance GHC.Classes.Eq Language.Haskell.Syntax.ImpExp.ImportListInterpretation
instance Data.Data.Data Language.Haskell.Syntax.ImpExp.IEWildcard
instance GHC.Classes.Eq Language.Haskell.Syntax.ImpExp.IEWildcard

module GHC.Hs.ImpExp
data XImportDeclPass
XImportDeclPass :: EpAnn EpAnnImportDecl -> SourceText -> Bool -> XImportDeclPass
[ideclAnn] :: XImportDeclPass -> EpAnn EpAnnImportDecl
[ideclSourceText] :: XImportDeclPass -> SourceText

-- | GHC generates an <a>ImportDecl</a> to represent the invisible `import
--   Prelude` that appears in any file that omits `import Prelude`, setting
--   this field to indicate that the import doesn't appear in the original
--   source. True =&gt; implicit import (of Prelude)
[ideclImplicit] :: XImportDeclPass -> Bool
data EpAnnImportDecl
EpAnnImportDecl :: EpaLocation -> Maybe (EpaLocation, EpaLocation) -> Maybe EpaLocation -> Maybe EpaLocation -> Maybe EpaLocation -> Maybe EpaLocation -> EpAnnImportDecl
[importDeclAnnImport] :: EpAnnImportDecl -> EpaLocation
[importDeclAnnPragma] :: EpAnnImportDecl -> Maybe (EpaLocation, EpaLocation)
[importDeclAnnSafe] :: EpAnnImportDecl -> Maybe EpaLocation
[importDeclAnnQualified] :: EpAnnImportDecl -> Maybe EpaLocation
[importDeclAnnPackage] :: EpAnnImportDecl -> Maybe EpaLocation
[importDeclAnnAs] :: EpAnnImportDecl -> Maybe EpaLocation

-- | Given two possible located <tt>qualified</tt> tokens, compute a style
--   (in a conforming Haskell program only one of the two can be not
--   <a>Nothing</a>). This is called from <a>GHC.Parser</a>.
importDeclQualifiedStyle :: Maybe EpaLocation -> Maybe EpaLocation -> (Maybe EpaLocation, ImportDeclQualifiedStyle)

-- | Convenience function to answer the question if an import decl. is
--   qualified.
isImportDeclQualified :: ImportDeclQualifiedStyle -> Bool
simpleImportDecl :: ModuleName -> ImportDecl GhcPs
ieName :: IE (GhcPass p) -> IdP (GhcPass p)
ieWrappedName :: IEWrappedName (GhcPass p) -> IdP (GhcPass p)
ieNames :: IE (GhcPass p) -> [IdP (GhcPass p)]
ieWrappedLName :: IEWrappedName (GhcPass p) -> LIdP (GhcPass p)
lieWrappedName :: LIEWrappedName (GhcPass p) -> IdP (GhcPass p)
ieLWrappedName :: LIEWrappedName (GhcPass p) -> LIdP (GhcPass p)
replaceWrappedName :: IEWrappedName GhcPs -> IdP GhcRn -> IEWrappedName GhcRn
replaceLWrappedName :: LIEWrappedName GhcPs -> IdP GhcRn -> LIEWrappedName GhcRn
pprImpExp :: (HasOccName name, OutputableBndr name) => name -> SDoc
instance Data.Data.Data GHC.Hs.ImpExp.EpAnnImportDecl
instance Data.Data.Data GHC.Hs.ImpExp.XImportDeclPass
instance Data.Data.Data (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcTc)
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcPs)
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcRn)
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcTc)
instance (GHC.Hs.Extension.OutputableBndrId p, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.Anno (Language.Haskell.Syntax.ImpExp.IE (GHC.Hs.Extension.GhcPass p))), GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.ImportDeclPkgQual (GHC.Hs.Extension.GhcPass p))) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.ImpExp.ImportDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.ImpExp.IE (GHC.Hs.Extension.GhcPass p))
instance (GHC.Types.Name.Occurrence.HasOccName (Language.Haskell.Syntax.Extension.IdP (GHC.Hs.Extension.GhcPass p)), GHC.Hs.Extension.OutputableBndrId p) => GHC.Types.Name.Occurrence.HasOccName (Language.Haskell.Syntax.ImpExp.IEWrappedName (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.ImpExp.IEWrappedName (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.ImpExp.IEWrappedName (GHC.Hs.Extension.GhcPass p))


-- | Warnings for a module
module GHC.Unit.Module.Warnings

-- | Warning information for a module
data Warnings pass

-- | Nothing deprecated
NoWarnings :: Warnings pass

-- | Whole module deprecated
WarnAll :: WarningTxt pass -> Warnings pass

-- | Some specific things deprecated
WarnSome :: [(OccName, WarningTxt pass)] -> Warnings pass

-- | Warning Text
--   
--   reason/explanation from a WARNING or DEPRECATED pragma
data WarningTxt pass
WarningTxt :: Located SourceText -> [Located (WithHsDocIdentifiers StringLiteral pass)] -> WarningTxt pass
DeprecatedTxt :: Located SourceText -> [Located (WithHsDocIdentifiers StringLiteral pass)] -> WarningTxt pass
pprWarningTxtForMsg :: WarningTxt p -> SDoc

-- | Constructs the cache for the <tt>mi_warn_fn</tt> field of a
--   <tt>ModIface</tt>
mkIfaceWarnCache :: Warnings p -> OccName -> Maybe (WarningTxt p)
emptyIfaceWarnCache :: OccName -> Maybe (WarningTxt p)
plusWarns :: Warnings p -> Warnings p -> Warnings p
instance GHC.Generics.Generic (GHC.Unit.Module.Warnings.WarningTxt pass)
instance GHC.Classes.Eq (Language.Haskell.Syntax.Extension.IdP pass) => GHC.Classes.Eq (GHC.Unit.Module.Warnings.WarningTxt pass)
instance (Data.Data.Data pass, Data.Data.Data (Language.Haskell.Syntax.Extension.IdP pass)) => Data.Data.Data (GHC.Unit.Module.Warnings.WarningTxt pass)
instance GHC.Classes.Eq (Language.Haskell.Syntax.Extension.IdP pass) => GHC.Classes.Eq (GHC.Unit.Module.Warnings.Warnings pass)
instance GHC.Utils.Binary.Binary (GHC.Unit.Module.Warnings.Warnings GHC.Hs.Extension.GhcRn)
instance GHC.Utils.Outputable.Outputable (GHC.Unit.Module.Warnings.WarningTxt pass)
instance GHC.Utils.Binary.Binary (GHC.Unit.Module.Warnings.WarningTxt GHC.Hs.Extension.GhcRn)


-- | Module for coercion axioms, used to represent type family instances
--   and newtypes
module GHC.Core.Coercion.Axiom
data BranchFlag
type Branched = 'Branched
type Unbranched = 'Unbranched
type BranchIndex = Int
newtype Branches (br :: BranchFlag)
MkBranches :: Array BranchIndex CoAxBranch -> Branches (br :: BranchFlag)
[unMkBranches] :: Branches (br :: BranchFlag) -> Array BranchIndex CoAxBranch
manyBranches :: [CoAxBranch] -> Branches Branched
unbranched :: CoAxBranch -> Branches Unbranched
fromBranches :: Branches br -> [CoAxBranch]
numBranches :: Branches br -> Int

-- | The <tt>[CoAxBranch]</tt> passed into the mapping function is a list
--   of all previous branches, reversed
mapAccumBranches :: ([CoAxBranch] -> CoAxBranch -> CoAxBranch) -> Branches br -> Branches br

-- | A <a>CoAxiom</a> is a "coercion constructor", i.e. a named equality
--   axiom.
data CoAxiom br
CoAxiom :: Unique -> Name -> Role -> TyCon -> Branches br -> Bool -> CoAxiom br
[co_ax_unique] :: CoAxiom br -> Unique
[co_ax_name] :: CoAxiom br -> Name
[co_ax_role] :: CoAxiom br -> Role
[co_ax_tc] :: CoAxiom br -> TyCon
[co_ax_branches] :: CoAxiom br -> Branches br
[co_ax_implicit] :: CoAxiom br -> Bool
data CoAxBranch
CoAxBranch :: SrcSpan -> [TyVar] -> [TyVar] -> [CoVar] -> [Role] -> [Type] -> Type -> [CoAxBranch] -> CoAxBranch
[cab_loc] :: CoAxBranch -> SrcSpan
[cab_tvs] :: CoAxBranch -> [TyVar]
[cab_eta_tvs] :: CoAxBranch -> [TyVar]
[cab_cvs] :: CoAxBranch -> [CoVar]
[cab_roles] :: CoAxBranch -> [Role]
[cab_lhs] :: CoAxBranch -> [Type]
[cab_rhs] :: CoAxBranch -> Type
[cab_incomps] :: CoAxBranch -> [CoAxBranch]
toBranchedAxiom :: CoAxiom br -> CoAxiom Branched
toUnbranchedAxiom :: CoAxiom br -> CoAxiom Unbranched
coAxiomName :: CoAxiom br -> Name
coAxiomArity :: CoAxiom br -> BranchIndex -> Arity
coAxiomBranches :: CoAxiom br -> Branches br
coAxiomTyCon :: CoAxiom br -> TyCon
isImplicitCoAxiom :: CoAxiom br -> Bool
coAxiomNumPats :: CoAxiom br -> Int
coAxiomNthBranch :: CoAxiom br -> BranchIndex -> CoAxBranch
coAxiomSingleBranch_maybe :: CoAxiom br -> Maybe CoAxBranch
coAxiomRole :: CoAxiom br -> Role
coAxiomSingleBranch :: CoAxiom Unbranched -> CoAxBranch
coAxBranchTyVars :: CoAxBranch -> [TyVar]
coAxBranchCoVars :: CoAxBranch -> [CoVar]
coAxBranchRoles :: CoAxBranch -> [Role]
coAxBranchLHS :: CoAxBranch -> [Type]
coAxBranchRHS :: CoAxBranch -> Type
coAxBranchSpan :: CoAxBranch -> SrcSpan
coAxBranchIncomps :: CoAxBranch -> [CoAxBranch]
placeHolderIncomps :: [CoAxBranch]

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
fsFromRole :: Role -> FastString

-- | For now, we work only with nominal equality.
data CoAxiomRule
CoAxiomRule :: FastString -> [Role] -> Role -> ([TypeEqn] -> Maybe TypeEqn) -> CoAxiomRule
[coaxrName] :: CoAxiomRule -> FastString
[coaxrAsmpRoles] :: CoAxiomRule -> [Role]
[coaxrRole] :: CoAxiomRule -> Role

-- | coaxrProves returns <tt>Nothing</tt> when it doesn't like the supplied
--   arguments. When this happens in a coercion that means that the
--   coercion is ill-formed, and Core Lint checks for that.
[coaxrProves] :: CoAxiomRule -> [TypeEqn] -> Maybe TypeEqn

-- | A more explicit representation for `t1 ~ t2`.
type TypeEqn = Pair Type
data BuiltInSynFamily
BuiltInSynFamily :: ([Type] -> Maybe (CoAxiomRule, [Type], Type)) -> ([Type] -> Type -> [TypeEqn]) -> ([Type] -> Type -> [Type] -> Type -> [TypeEqn]) -> BuiltInSynFamily
[sfMatchFam] :: BuiltInSynFamily -> [Type] -> Maybe (CoAxiomRule, [Type], Type)
[sfInteractTop] :: BuiltInSynFamily -> [Type] -> Type -> [TypeEqn]
[sfInteractInert] :: BuiltInSynFamily -> [Type] -> Type -> [Type] -> Type -> [TypeEqn]
trivialBuiltInFamily :: BuiltInSynFamily
instance Data.Data.Data GHC.Core.Coercion.Axiom.CoAxBranch
instance Data.Data.Data GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Types.Unique.Uniquable GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Classes.Eq GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Classes.Ord GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Utils.Outputable.Outputable GHC.Core.Coercion.Axiom.CoAxiomRule
instance GHC.Classes.Eq (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Types.Unique.Uniquable (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Types.Name.NamedThing (GHC.Core.Coercion.Axiom.CoAxiom br)
instance Data.Typeable.Internal.Typeable br => Data.Data.Data (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Utils.Outputable.Outputable (GHC.Core.Coercion.Axiom.CoAxiom br)
instance GHC.Utils.Outputable.Outputable GHC.Core.Coercion.Axiom.CoAxBranch
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.Role
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Basic.Role

module GHC.Core.Class
data Class
type ClassOpItem = (Id, DefMethInfo)
data ClassATItem
ATI :: TyCon -> Maybe (Type, ATValidityInfo) -> ClassATItem

-- | Information about an associated type family default implementation.
--   This is used solely for validity checking. See <tt>Note [Type-checking
--   default assoc decls]</tt> in <a>GHC.Tc.TyCl</a>.
data ATValidityInfo
NoATVI :: ATValidityInfo
ATVI :: SrcSpan -> [Type] -> ATValidityInfo
type ClassMinimalDef = BooleanFormula Name
type DefMethInfo = Maybe (Name, DefMethSpec Type)
pprDefMethInfo :: DefMethInfo -> SDoc
type FunDep a = ([a], [a])
pprFundeps :: Outputable a => [FunDep a] -> SDoc
pprFunDep :: Outputable a => FunDep a -> SDoc
mkClass :: Name -> [TyVar] -> [FunDep TyVar] -> [PredType] -> [Id] -> [ClassATItem] -> [ClassOpItem] -> ClassMinimalDef -> TyCon -> Class
mkAbstractClass :: Name -> [TyVar] -> [FunDep TyVar] -> TyCon -> Class
classTyVars :: Class -> [TyVar]
classArity :: Class -> Arity
classKey :: Class -> Unique
className :: Class -> Name
classATs :: Class -> [TyCon]
classATItems :: Class -> [ClassATItem]
classTyCon :: Class -> TyCon
classMethods :: Class -> [Id]
classOpItems :: Class -> [ClassOpItem]
classBigSig :: Class -> ([TyVar], [PredType], [Id], [ClassOpItem])
classExtraBigSig :: Class -> ([TyVar], [FunDep TyVar], [PredType], [Id], [ClassATItem], [ClassOpItem])
classTvsFds :: Class -> ([TyVar], [FunDep TyVar])
classSCTheta :: Class -> [PredType]
classAllSelIds :: Class -> [Id]
classSCSelId :: Class -> Int -> Id
classSCSelIds :: Class -> [Id]
classMinimalDef :: Class -> ClassMinimalDef
classHasFds :: Class -> Bool
isAbstractClass :: Class -> Bool
instance GHC.Classes.Eq GHC.Core.Class.Class
instance GHC.Types.Unique.Uniquable GHC.Core.Class.Class
instance GHC.Types.Name.NamedThing GHC.Core.Class.Class
instance GHC.Utils.Outputable.Outputable GHC.Core.Class.Class
instance Data.Data.Data GHC.Core.Class.Class


-- | An architecture independent description of a register's class.
module GHC.Platform.Reg.Class

-- | The class of a register. Used in the register allocator. We treat all
--   registers in a class as being interchangeable.
data RegClass
RcInteger :: RegClass
RcFloat :: RegClass
RcDouble :: RegClass
instance GHC.Classes.Eq GHC.Platform.Reg.Class.RegClass
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.Class.RegClass
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.Class.RegClass


-- | An architecture independent description of a register. This needs to
--   stay architecture independent because it is used by NCGMonad and the
--   register allocators, which are shared by all architectures.
module GHC.Platform.Reg

-- | An identifier for a primitive real machine register.
type RegNo = Int

-- | A register, either virtual or real
data Reg
RegVirtual :: !VirtualReg -> Reg
RegReal :: !RealReg -> Reg
regSingle :: RegNo -> Reg
realRegSingle :: RegNo -> RealReg
isRealReg :: Reg -> Bool
takeRealReg :: Reg -> Maybe RealReg
isVirtualReg :: Reg -> Bool
takeVirtualReg :: Reg -> Maybe VirtualReg
data VirtualReg
VirtualRegI :: {-# UNPACK #-} !Unique -> VirtualReg
VirtualRegHi :: {-# UNPACK #-} !Unique -> VirtualReg
VirtualRegF :: {-# UNPACK #-} !Unique -> VirtualReg
VirtualRegD :: {-# UNPACK #-} !Unique -> VirtualReg
renameVirtualReg :: Unique -> VirtualReg -> VirtualReg
classOfVirtualReg :: VirtualReg -> RegClass
getHiVirtualRegFromLo :: VirtualReg -> VirtualReg
getHiVRegFromLo :: Reg -> Reg

-- | RealRegs are machine regs which are available for allocation, in the
--   usual way. We know what class they are, because that's part of the
--   processor's architecture.
newtype RealReg
RealRegSingle :: RegNo -> RealReg
regNosOfRealReg :: RealReg -> [RegNo]
realRegsAlias :: RealReg -> RealReg -> Bool

-- | The patch function supplied by the allocator maps VirtualReg to
--   RealReg regs, but sometimes we want to apply it to plain old Reg.
liftPatchFnToRegReg :: (VirtualReg -> RealReg) -> Reg -> Reg
instance GHC.Show.Show GHC.Platform.Reg.VirtualReg
instance GHC.Classes.Eq GHC.Platform.Reg.VirtualReg
instance GHC.Classes.Ord GHC.Platform.Reg.RealReg
instance GHC.Show.Show GHC.Platform.Reg.RealReg
instance GHC.Classes.Eq GHC.Platform.Reg.RealReg
instance GHC.Show.Show GHC.Platform.Reg.Reg
instance GHC.Classes.Ord GHC.Platform.Reg.Reg
instance GHC.Classes.Eq GHC.Platform.Reg.Reg
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.Reg
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.Reg
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.RealReg
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.RealReg
instance GHC.Classes.Ord GHC.Platform.Reg.VirtualReg
instance GHC.Types.Unique.Uniquable GHC.Platform.Reg.VirtualReg
instance GHC.Utils.Outputable.Outputable GHC.Platform.Reg.VirtualReg

module GHC.CmmToAsm.Reg.Utils
toRegMap :: UniqFM VirtualReg elt -> UniqFM Reg elt
toVRegMap :: UniqFM Reg elt -> UniqFM VirtualReg elt

module GHC.CmmToAsm.Reg.Graph.TrivColorable
trivColorable :: Platform -> (RegClass -> VirtualReg -> Int) -> (RegClass -> RealReg -> Int) -> Triv VirtualReg RegClass RealReg


-- | Utils for calculating general worst, bound, squeese and free,
--   functions.
--   
--   as per: "A Generalized Algorithm for Graph-Coloring Register
--   Allocation" Michael Smith, Normal Ramsey, Glenn Holloway. PLDI 2004
--   
--   These general versions are not used in GHC proper because they are too
--   slow. Instead, hand written optimised versions are provided for each
--   architecture in MachRegs*.hs
--   
--   This code is here because we can test the architecture specific code
--   against it.
module GHC.CmmToAsm.Reg.Graph.Base
data RegClass
ClassG32 :: RegClass
ClassG16 :: RegClass
ClassG8 :: RegClass
ClassF64 :: RegClass

-- | A register of some class
data Reg
Reg :: RegClass -> Int -> Reg
RegSub :: RegSub -> Reg -> Reg

-- | A subcomponent of another register
data RegSub
SubL16 :: RegSub
SubL8 :: RegSub
SubL8H :: RegSub

-- | Worst case displacement
--   
--   a node N of classN has some number of neighbors, all of which are from
--   classC.
--   
--   (worst neighbors classN classC) is the maximum number of potential
--   colors for N that can be lost by coloring its neighbors.
--   
--   This should be hand coded/cached for each particular architecture,
--   because the compute time is very long..
worst :: (RegClass -> UniqSet Reg) -> (Reg -> UniqSet Reg) -> Int -> RegClass -> RegClass -> Int

-- | For a node N of classN and neighbors of classesC (bound classN
--   classesC) is the maximum number of potential colors for N that can be
--   lost by coloring its neighbors.
bound :: (RegClass -> UniqSet Reg) -> (Reg -> UniqSet Reg) -> RegClass -> [RegClass] -> Int

-- | The total squeese on a particular node with a list of neighbors.
--   
--   A version of this should be constructed for each particular
--   architecture, possibly including uses of bound, so that aliased
--   registers don't get counted twice, as per the paper.
squeese :: (RegClass -> UniqSet Reg) -> (Reg -> UniqSet Reg) -> RegClass -> [(Int, RegClass)] -> Int
instance GHC.Enum.Enum GHC.CmmToAsm.Reg.Graph.Base.RegClass
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Graph.Base.RegClass
instance GHC.Show.Show GHC.CmmToAsm.Reg.Graph.Base.RegClass
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Classes.Ord GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Enum.Enum GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Show.Show GHC.CmmToAsm.Reg.Graph.Base.RegSub
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Graph.Base.Reg
instance GHC.Show.Show GHC.CmmToAsm.Reg.Graph.Base.Reg
instance GHC.Types.Unique.Uniquable GHC.CmmToAsm.Reg.Graph.Base.Reg


-- | A description of the register set of the X86.
--   
--   This isn't used directly in GHC proper.
--   
--   See RegArchBase.hs for the reference. See MachRegs.hs for the actual
--   trivColorable function used in GHC.
module GHC.CmmToAsm.Reg.Graph.X86

-- | Determine the class of a register
classOfReg :: Reg -> RegClass

-- | Determine all the regs that make up a certain class.
regsOfClass :: RegClass -> UniqSet Reg

-- | Determine the common name of a reg returns Nothing if this reg is not
--   part of the machine.
regName :: Reg -> Maybe String

-- | Which regs alias what other regs.
regAlias :: Reg -> UniqSet Reg

-- | Optimised versions of RegColorBase.{worst, squeese} specific to x86
worst :: Int -> RegClass -> RegClass -> Int
squeese :: RegClass -> [(Int, RegClass)] -> Int

module GHC.Builtin.Names

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique
hasKey :: Uniquable a => a -> Unique -> Bool
allNameStrings :: Infinite String
mk_known_key_name :: NameSpace -> Module -> FastString -> Unique -> Name
gHC_PRIMOPWRAPPERS :: Module
listTyConKey :: Unique
nilDataConKey :: Unique
gHC_TYPELITS :: Module
gHC_TYPELITS_INTERNAL :: Module
gHC_TYPENATS :: Module
gHC_TYPENATS_INTERNAL :: Module
typeNatAddTyFamNameKey :: Unique
typeNatMulTyFamNameKey :: Unique
typeNatExpTyFamNameKey :: Unique
typeNatSubTyFamNameKey :: Unique
typeNatDivTyFamNameKey :: Unique
typeNatModTyFamNameKey :: Unique
typeNatLogTyFamNameKey :: Unique
typeNatCmpTyFamNameKey :: Unique
typeSymbolCmpTyFamNameKey :: Unique
typeSymbolAppendFamNameKey :: Unique
typeCharCmpTyFamNameKey :: Unique
typeConsSymbolTyFamNameKey :: Unique
typeUnconsSymbolTyFamNameKey :: Unique
typeCharToNatTyFamNameKey :: Unique
typeNatToCharTyFamNameKey :: Unique
multMulTyConKey :: Unique
runRWKey :: Unique
specTyConKey :: Unique
tYPETyConKey :: Unique
cONSTRAINTTyConKey :: Unique
makeStaticName :: Name
unsafeEqualityProofIdKey :: Unique
gHC_PRIM :: Module
mAIN_NAME :: ModuleName
considerAccessibleIdKey :: Unique
trueDataConKey :: Unique
rationalTyConName :: Name
unrestrictedFunTyConKey :: Unique
liftedTypeKindTyConKey :: Unique
constraintKindTyConKey :: Unique
ioTyConName :: Name
rOOT_MAIN :: Module
allNameStringList :: [String]
mkUnboundName :: OccName -> Name
applicativeClassName :: Name
pureAName :: Name
thenAName :: Name
monadClassName :: Name
returnMName :: Name
thenMName :: Name
semigroupClassName :: Name
sappendName :: Name
monoidClassName :: Name
mappendName :: Name
isUnboundName :: Name -> Bool
printName :: Name
mkInteractiveModule :: Int -> Module
toDynName :: Name

-- | Should this name be considered in-scope, even though it technically
--   isn't?
--   
--   This ensures that we don't filter out information because, e.g.,
--   Data.Kind.Type isn't imported.
--   
--   See Note [pretendNameIsInScope].
pretendNameIsInScope :: Name -> Bool
pluginTyConName :: Name
frontendPluginTyConName :: Name
unpackCStringName :: Name
unpackCStringUtf8Name :: Name
gHC_ERR :: Module
ipClassName :: Name
wildCardName :: Name
coercibleTyConKey :: Unique
heqTyConKey :: Unique
eqTyConKey :: Unique
ipClassKey :: Unique
lazyIdKey :: Unique
itName :: Unique -> SrcSpan -> Name
unboundKey :: Unique
basicKnownKeyNames :: [Name]
genericTyConNames :: [Name]
eqClassName :: Name
ordClassName :: Name
boundedClassName :: Name
numClassName :: Name
enumClassName :: Name
functorClassName :: Name
realClassName :: Name
integralClassName :: Name
fractionalClassName :: Name
floatingClassName :: Name
realFracClassName :: Name
realFloatClassName :: Name
dataClassName :: Name
isStringClassName :: Name
alternativeClassName :: Name
foldableClassName :: Name
traversableClassName :: Name
memptyName :: Name
mconcatName :: Name
ioDataConName :: Name
runMainIOName :: Name
runRWName :: Name
trModuleTyConName :: Name
trModuleDataConName :: Name
trNameTyConName :: Name
trNameSDataConName :: Name
trNameDDataConName :: Name
trTyConTyConName :: Name
trTyConDataConName :: Name
typeableClassName :: Name
typeRepTyConName :: Name
someTypeRepTyConName :: Name
someTypeRepDataConName :: Name
kindRepTyConName :: Name
kindRepTyConAppDataConName :: Name
kindRepVarDataConName :: Name
kindRepAppDataConName :: Name
kindRepFunDataConName :: Name
kindRepTYPEDataConName :: Name
kindRepTypeLitSDataConName :: Name
kindRepTypeLitDDataConName :: Name
typeLitSortTyConName :: Name
typeLitSymbolDataConName :: Name
typeLitNatDataConName :: Name
typeLitCharDataConName :: Name
typeRepIdName :: Name
mkTrTypeName :: Name
mkTrConName :: Name
mkTrAppName :: Name
mkTrFunName :: Name
typeSymbolTypeRepName :: Name
typeNatTypeRepName :: Name
typeCharTypeRepName :: Name
trGhcPrimModuleName :: Name
starKindRepName :: Name
starArrStarKindRepName :: Name
starArrStarArrStarKindRepName :: Name
constraintKindRepName :: Name
withDictClassName :: Name
negateName :: Name
minusName :: Name
geName :: Name
eqName :: Name
mkRationalBase2Name :: Name
mkRationalBase10Name :: Name
ratioTyConName :: Name
ratioDataConName :: Name
fromRationalName :: Name
fromIntegerName :: Name
toIntegerName :: Name
toRationalName :: Name
fromIntegralName :: Name
realToFracName :: Name
divIntName :: Name
modIntName :: Name
fromStringName :: Name
enumFromName :: Name
enumFromThenName :: Name
enumFromThenToName :: Name
enumFromToName :: Name
apAName :: Name
fmapName :: Name
thenIOName :: Name
bindIOName :: Name
returnIOName :: Name
failIOName :: Name
bindMName :: Name
joinMName :: Name
monadFailClassName :: Name
failMName :: Name
monadFixClassName :: Name
mfixName :: Name
arrAName :: Name
composeAName :: Name
firstAName :: Name
appAName :: Name
choiceAName :: Name
loopAName :: Name
ixClassName :: Name
showClassName :: Name
readClassName :: Name
newStablePtrName :: Name
considerAccessibleName :: Name
unpackCStringAppendName :: Name
unpackCStringAppendUtf8Name :: Name
unpackCStringFoldrName :: Name
unpackCStringFoldrUtf8Name :: Name
cstringLengthName :: Name
isListClassName :: Name
fromListName :: Name
fromListNName :: Name
toListName :: Name
nonEmptyTyConName :: Name
getFieldName :: Name
setFieldName :: Name
concatName :: Name
filterName :: Name
mapName :: Name
zipName :: Name
foldrName :: Name
buildName :: Name
augmentName :: Name
appendName :: Name
stablePtrTyConName :: Name
ptrTyConName :: Name
funPtrTyConName :: Name
constPtrConName :: Name
int8TyConName :: Name
int16TyConName :: Name
int32TyConName :: Name
int64TyConName :: Name
word8TyConName :: Name
word16TyConName :: Name
word32TyConName :: Name
word64TyConName :: Name
otherwiseIdName :: Name
inlineIdName :: Name
eqStringName :: Name
assertName :: Name
assertErrorName :: Name
traceName :: Name
dollarName :: Name
integerFromNaturalName :: Name
integerToNaturalClampName :: Name
integerToNaturalThrowName :: Name
integerToNaturalName :: Name
integerToWordName :: Name
integerToIntName :: Name
integerToWord64Name :: Name
integerToInt64Name :: Name
integerFromWordName :: Name
integerFromWord64Name :: Name
integerFromInt64Name :: Name
integerAddName :: Name
integerMulName :: Name
integerSubName :: Name
integerNegateName :: Name
integerAbsName :: Name
integerPopCountName :: Name
integerQuotName :: Name
integerRemName :: Name
integerDivName :: Name
integerModName :: Name
integerDivModName :: Name
integerQuotRemName :: Name
integerEncodeFloatName :: Name
integerEncodeDoubleName :: Name
integerGcdName :: Name
integerLcmName :: Name
integerAndName :: Name
integerOrName :: Name
integerXorName :: Name
integerComplementName :: Name
integerBitName :: Name
integerTestBitName :: Name
integerShiftLName :: Name
integerShiftRName :: Name
naturalToWordName :: Name
naturalPopCountName :: Name
naturalShiftRName :: Name
naturalShiftLName :: Name
naturalAddName :: Name
naturalSubName :: Name
naturalSubThrowName :: Name
naturalSubUnsafeName :: Name
naturalMulName :: Name
naturalQuotRemName :: Name
naturalQuotName :: Name
naturalRemName :: Name
naturalAndName :: Name
naturalAndNotName :: Name
naturalOrName :: Name
naturalXorName :: Name
naturalTestBitName :: Name
naturalBitName :: Name
naturalGcdName :: Name
naturalLcmName :: Name
naturalLog2Name :: Name
naturalLogBaseWordName :: Name
naturalLogBaseName :: Name
naturalPowModName :: Name
naturalSizeInBaseName :: Name
bignatFromWordListName :: Name
bignatEqName :: Name
integerToFloatName :: Name
integerToDoubleName :: Name
naturalToFloatName :: Name
naturalToDoubleName :: Name
rationalToFloatName :: Name
rationalToDoubleName :: Name
monadPlusClassName :: Name
knownNatClassName :: Name
knownSymbolClassName :: Name
knownCharClassName :: Name
fromLabelClassOpName :: Name
hasFieldClassName :: Name
callStackTyConName :: Name
emptyCallStackName :: Name
pushCallStackName :: Name
srcLocDataConName :: Name
toAnnotationWrapperName :: Name
specTyConName :: Name
eitherTyConName :: Name
leftDataConName :: Name
rightDataConName :: Name
voidTyConName :: Name
genClassName :: Name
gen1ClassName :: Name
datatypeClassName :: Name
constructorClassName :: Name
selectorClassName :: Name
guardMName :: Name
liftMName :: Name
mzipName :: Name
ghciIoClassName :: Name
ghciStepIoMName :: Name
staticPtrTyConName :: Name
staticPtrDataConName :: Name
staticPtrInfoDataConName :: Name
fromStaticPtrName :: Name
fingerprintDataConName :: Name
errorMessageTypeErrorFamName :: Name
typeErrorTextDataConName :: Name
typeErrorAppendDataConName :: Name
typeErrorVAppendDataConName :: Name
typeErrorShowTypeDataConName :: Name
unsafeEqualityProofName :: Name
unsafeEqualityTyConName :: Name
unsafeReflDataConName :: Name
unsafeCoercePrimName :: Name
v1TyConName :: Name
u1TyConName :: Name
par1TyConName :: Name
rec1TyConName :: Name
k1TyConName :: Name
m1TyConName :: Name
sumTyConName :: Name
prodTyConName :: Name
compTyConName :: Name
rTyConName :: Name
dTyConName :: Name
cTyConName :: Name
sTyConName :: Name
rec0TyConName :: Name
d1TyConName :: Name
c1TyConName :: Name
s1TyConName :: Name
repTyConName :: Name
rep1TyConName :: Name
uRecTyConName :: Name
uAddrTyConName :: Name
uCharTyConName :: Name
uDoubleTyConName :: Name
uFloatTyConName :: Name
uIntTyConName :: Name
uWordTyConName :: Name
prefixIDataConName :: Name
infixIDataConName :: Name
leftAssociativeDataConName :: Name
rightAssociativeDataConName :: Name
notAssociativeDataConName :: Name
sourceUnpackDataConName :: Name
sourceNoUnpackDataConName :: Name
noSourceUnpackednessDataConName :: Name
sourceLazyDataConName :: Name
sourceStrictDataConName :: Name
noSourceStrictnessDataConName :: Name
decidedLazyDataConName :: Name
decidedStrictDataConName :: Name
decidedUnpackDataConName :: Name
metaDataDataConName :: Name
metaConsDataConName :: Name
metaSelDataConName :: Name
pRELUDE :: Module
mkBaseModule_ :: ModuleName -> Module
pRELUDE_NAME :: ModuleName
gHC_PRIM_PANIC :: Module
gHC_TYPES :: Module
gHC_GENERICS :: Module
gHC_MAGIC :: Module
gHC_MAGIC_DICT :: Module
gHC_CLASSES :: Module
gHC_BASE :: Module
gHC_ENUM :: Module
gHC_GHCI :: Module
gHC_GHCI_HELPERS :: Module
gHC_CSTRING :: Module
gHC_SHOW :: Module
gHC_READ :: Module
gHC_NUM :: Module
gHC_MAYBE :: Module
gHC_NUM_INTEGER :: Module
gHC_NUM_NATURAL :: Module
gHC_NUM_BIGNAT :: Module
gHC_LIST :: Module
gHC_TUPLE :: Module
gHC_TUPLE_PRIM :: Module
dATA_EITHER :: Module
dATA_LIST :: Module
dATA_STRING :: Module
dATA_FOLDABLE :: Module
dATA_TRAVERSABLE :: Module
gHC_CONC :: Module
gHC_IO :: Module
gHC_IO_Exception :: Module
gHC_ST :: Module
gHC_IX :: Module
gHC_STABLE :: Module
gHC_PTR :: Module
gHC_REAL :: Module
gHC_FLOAT :: Module
gHC_TOP_HANDLER :: Module
sYSTEM_IO :: Module
dYNAMIC :: Module
tYPEABLE :: Module
tYPEABLE_INTERNAL :: Module
gENERICS :: Module
rEAD_PREC :: Module
lEX :: Module
gHC_INT :: Module
gHC_WORD :: Module
mONAD :: Module
mONAD_FIX :: Module
mONAD_ZIP :: Module
mONAD_FAIL :: Module
aRROW :: Module
gHC_DESUGAR :: Module
rANDOM :: Module
gHC_EXTS :: Module
gHC_IS_LIST :: Module
cONTROL_EXCEPTION_BASE :: Module
gHC_TYPEERROR :: Module
dATA_COERCE :: Module
dEBUG_TRACE :: Module
uNSAFE_COERCE :: Module
fOREIGN_C_CONSTPTR :: Module
mkPrimModule :: FastString -> Module
mkBaseModule :: FastString -> Module
mkBignumModule :: FastString -> Module
gHC_SRCLOC :: Module
gHC_STACK :: Module
gHC_STACK_TYPES :: Module
gHC_STATICPTR :: Module
gHC_STATICPTR_INTERNAL :: Module
gHC_FINGERPRINT_TYPE :: Module
gHC_OVER_LABELS :: Module
gHC_RECORDS :: Module
mkMainModule :: FastString -> Module
mkThisGhcModule :: FastString -> Module
mkThisGhcModule_ :: ModuleName -> Module
mkMainModule_ :: ModuleName -> Module
main_RDR_Unqual :: RdrName
eq_RDR :: RdrName
ge_RDR :: RdrName
le_RDR :: RdrName
lt_RDR :: RdrName
gt_RDR :: RdrName
compare_RDR :: RdrName
ltTag_RDR :: RdrName
eqTag_RDR :: RdrName
gtTag_RDR :: RdrName
varQual_RDR :: Module -> FastString -> RdrName
ordLTDataConName :: Name
ordEQDataConName :: Name
ordGTDataConName :: Name
eqClass_RDR :: RdrName
numClass_RDR :: RdrName
ordClass_RDR :: RdrName
enumClass_RDR :: RdrName
monadClass_RDR :: RdrName
map_RDR :: RdrName
append_RDR :: RdrName
foldr_RDR :: RdrName
build_RDR :: RdrName
returnM_RDR :: RdrName
bindM_RDR :: RdrName
failM_RDR :: RdrName
left_RDR :: RdrName
right_RDR :: RdrName
fromEnum_RDR :: RdrName
toEnum_RDR :: RdrName
enumFrom_RDR :: RdrName
enumFromTo_RDR :: RdrName
enumFromThen_RDR :: RdrName
enumFromThenTo_RDR :: RdrName
ratioDataCon_RDR :: RdrName
integerAdd_RDR :: RdrName
integerMul_RDR :: RdrName
ioDataCon_RDR :: RdrName
newStablePtr_RDR :: RdrName
bindIO_RDR :: RdrName
returnIO_RDR :: RdrName
fromInteger_RDR :: RdrName
fromRational_RDR :: RdrName
minus_RDR :: RdrName
times_RDR :: RdrName
plus_RDR :: RdrName
toInteger_RDR :: RdrName
toRational_RDR :: RdrName
fromIntegral_RDR :: RdrName
fromString_RDR :: RdrName
fromList_RDR :: RdrName
fromListN_RDR :: RdrName
toList_RDR :: RdrName
compose_RDR :: RdrName
not_RDR :: RdrName
dataToTag_RDR :: RdrName
succ_RDR :: RdrName
pred_RDR :: RdrName
minBound_RDR :: RdrName
maxBound_RDR :: RdrName
and_RDR :: RdrName
range_RDR :: RdrName
inRange_RDR :: RdrName
index_RDR :: RdrName
unsafeIndex_RDR :: RdrName
unsafeRangeSize_RDR :: RdrName
readList_RDR :: RdrName
readListDefault_RDR :: RdrName
readListPrec_RDR :: RdrName
readListPrecDefault_RDR :: RdrName
readPrec_RDR :: RdrName
parens_RDR :: RdrName
choose_RDR :: RdrName
lexP_RDR :: RdrName
expectP_RDR :: RdrName
readField_RDR :: RdrName
readFieldHash_RDR :: RdrName
readSymField_RDR :: RdrName
punc_RDR :: RdrName
ident_RDR :: RdrName
symbol_RDR :: RdrName
dataQual_RDR :: Module -> FastString -> RdrName
step_RDR :: RdrName
alt_RDR :: RdrName
reset_RDR :: RdrName
prec_RDR :: RdrName
pfail_RDR :: RdrName
showsPrec_RDR :: RdrName
shows_RDR :: RdrName
showString_RDR :: RdrName
showSpace_RDR :: RdrName
showCommaSpace_RDR :: RdrName
showParen_RDR :: RdrName
error_RDR :: RdrName
u1DataCon_RDR :: RdrName
par1DataCon_RDR :: RdrName
rec1DataCon_RDR :: RdrName
k1DataCon_RDR :: RdrName
m1DataCon_RDR :: RdrName
l1DataCon_RDR :: RdrName
r1DataCon_RDR :: RdrName
prodDataCon_RDR :: RdrName
comp1DataCon_RDR :: RdrName
unPar1_RDR :: RdrName
unRec1_RDR :: RdrName
unK1_RDR :: RdrName
unComp1_RDR :: RdrName
from_RDR :: RdrName
from1_RDR :: RdrName
to_RDR :: RdrName
to1_RDR :: RdrName
datatypeName_RDR :: RdrName
moduleName_RDR :: RdrName
packageName_RDR :: RdrName
isNewtypeName_RDR :: RdrName
conName_RDR :: RdrName
conFixity_RDR :: RdrName
conIsRecord_RDR :: RdrName
selName_RDR :: RdrName
prefixDataCon_RDR :: RdrName
infixDataCon_RDR :: RdrName
leftAssocDataCon_RDR :: RdrName
rightAssocDataCon_RDR :: RdrName
notAssocDataCon_RDR :: RdrName
uAddrDataCon_RDR :: RdrName
uCharDataCon_RDR :: RdrName
uDoubleDataCon_RDR :: RdrName
uFloatDataCon_RDR :: RdrName
uIntDataCon_RDR :: RdrName
uWordDataCon_RDR :: RdrName
uAddrHash_RDR :: RdrName
uCharHash_RDR :: RdrName
uDoubleHash_RDR :: RdrName
uFloatHash_RDR :: RdrName
uIntHash_RDR :: RdrName
uWordHash_RDR :: RdrName
fmap_RDR :: RdrName
replace_RDR :: RdrName
pure_RDR :: RdrName
ap_RDR :: RdrName
liftA2_RDR :: RdrName
foldable_foldr_RDR :: RdrName
foldMap_RDR :: RdrName
null_RDR :: RdrName
all_RDR :: RdrName
traverse_RDR :: RdrName
mempty_RDR :: RdrName
mappend_RDR :: RdrName
tcQual_RDR :: Module -> FastString -> RdrName
clsQual_RDR :: Module -> FastString -> RdrName
wildCardKey :: Unique
varQual :: Module -> FastString -> Unique -> Name
runMainKey :: Unique
orderingTyConName :: Name
tcQual :: Module -> FastString -> Unique -> Name
orderingTyConKey :: Unique
dcQual :: Module -> FastString -> Unique -> Name
ordLTDataConKey :: Unique
ordEQDataConKey :: Unique
ordGTDataConKey :: Unique
eitherTyConKey :: Unique
leftDataConKey :: Unique
rightDataConKey :: Unique
voidTyConKey :: Unique
v1TyConKey :: Unique
u1TyConKey :: Unique
par1TyConKey :: Unique
rec1TyConKey :: Unique
k1TyConKey :: Unique
m1TyConKey :: Unique
sumTyConKey :: Unique
prodTyConKey :: Unique
compTyConKey :: Unique
rTyConKey :: Unique
dTyConKey :: Unique
cTyConKey :: Unique
sTyConKey :: Unique
rec0TyConKey :: Unique
d1TyConKey :: Unique
c1TyConKey :: Unique
s1TyConKey :: Unique
repTyConKey :: Unique
rep1TyConKey :: Unique
uRecTyConKey :: Unique
uAddrTyConKey :: Unique
uCharTyConKey :: Unique
uDoubleTyConKey :: Unique
uFloatTyConKey :: Unique
uIntTyConKey :: Unique
uWordTyConKey :: Unique
prefixIDataConKey :: Unique
infixIDataConKey :: Unique
leftAssociativeDataConKey :: Unique
rightAssociativeDataConKey :: Unique
notAssociativeDataConKey :: Unique
sourceUnpackDataConKey :: Unique
sourceNoUnpackDataConKey :: Unique
noSourceUnpackednessDataConKey :: Unique
sourceLazyDataConKey :: Unique
sourceStrictDataConKey :: Unique
noSourceStrictnessDataConKey :: Unique
decidedLazyDataConKey :: Unique
decidedStrictDataConKey :: Unique
decidedUnpackDataConKey :: Unique
metaDataDataConKey :: Unique
metaConsDataConKey :: Unique
metaSelDataConKey :: Unique
divIntIdKey :: Unique
modIntIdKey :: Unique
cstringLengthIdKey :: Unique
eqStringIdKey :: Unique
unpackCStringIdKey :: Unique
unpackCStringAppendIdKey :: Unique
unpackCStringFoldrIdKey :: Unique
unpackCStringUtf8IdKey :: Unique
unpackCStringAppendUtf8IdKey :: Unique
unpackCStringFoldrUtf8IdKey :: Unique
inlineIdKey :: Unique
clsQual :: Module -> FastString -> Unique -> Name
eqClassKey :: Unique
eqClassOpKey :: Unique
ordClassKey :: Unique
geClassOpKey :: Unique
functorClassKey :: Unique
fmapClassOpKey :: Unique
monadClassKey :: Unique
thenMClassOpKey :: Unique
bindMClassOpKey :: Unique
returnMClassOpKey :: Unique
monadFailClassKey :: Unique
failMClassOpKey :: Unique
applicativeClassKey :: Unique
apAClassOpKey :: Unique
pureAClassOpKey :: Unique
thenAClassOpKey :: Unique
foldableClassKey :: Unique
traversableClassKey :: Unique
semigroupClassKey :: Unique
sappendClassOpKey :: Unique
monoidClassKey :: Unique
memptyClassOpKey :: Unique
mappendClassOpKey :: Unique
mconcatClassOpKey :: Unique
joinMIdKey :: Unique
alternativeClassKey :: Unique
dollarIdKey :: Unique
otherwiseIdKey :: Unique
foldrIdKey :: Unique
buildIdKey :: Unique
augmentIdKey :: Unique
mapIdKey :: Unique
appendIdKey :: Unique
assertIdKey :: Unique
fromStringClassOpKey :: Unique
numClassKey :: Unique
fromIntegerClassOpKey :: Unique
minusClassOpKey :: Unique
negateClassOpKey :: Unique
bignatCompareName :: Name
bignatCompareWordName :: Name
bnbVarQual :: String -> Unique -> Name
bnnVarQual :: String -> Unique -> Name
bniVarQual :: String -> Unique -> Name
bignatFromWordListIdKey :: Unique
bignatEqIdKey :: Unique
bignatCompareIdKey :: Unique
bignatCompareWordIdKey :: Unique
naturalToWordIdKey :: Unique
naturalPopCountIdKey :: Unique
naturalShiftRIdKey :: Unique
naturalShiftLIdKey :: Unique
naturalAddIdKey :: Unique
naturalSubIdKey :: Unique
naturalSubThrowIdKey :: Unique
naturalSubUnsafeIdKey :: Unique
naturalMulIdKey :: Unique
naturalQuotRemIdKey :: Unique
naturalQuotIdKey :: Unique
naturalRemIdKey :: Unique
naturalAndIdKey :: Unique
naturalAndNotIdKey :: Unique
naturalOrIdKey :: Unique
naturalXorIdKey :: Unique
naturalTestBitIdKey :: Unique
naturalBitIdKey :: Unique
naturalGcdIdKey :: Unique
naturalLcmIdKey :: Unique
naturalLog2IdKey :: Unique
naturalLogBaseWordIdKey :: Unique
naturalLogBaseIdKey :: Unique
naturalPowModIdKey :: Unique
naturalSizeInBaseIdKey :: Unique
integerFromNaturalIdKey :: Unique
integerToNaturalClampIdKey :: Unique
integerToNaturalThrowIdKey :: Unique
integerToNaturalIdKey :: Unique
integerToWordIdKey :: Unique
integerToIntIdKey :: Unique
integerToWord64IdKey :: Unique
integerToInt64IdKey :: Unique
integerFromWordIdKey :: Unique
integerFromWord64IdKey :: Unique
integerFromInt64IdKey :: Unique
integerAddIdKey :: Unique
integerMulIdKey :: Unique
integerSubIdKey :: Unique
integerNegateIdKey :: Unique
integerAbsIdKey :: Unique
integerPopCountIdKey :: Unique
integerQuotIdKey :: Unique
integerRemIdKey :: Unique
integerDivIdKey :: Unique
integerModIdKey :: Unique
integerDivModIdKey :: Unique
integerQuotRemIdKey :: Unique
integerEncodeFloatIdKey :: Unique
integerEncodeDoubleIdKey :: Unique
integerGcdIdKey :: Unique
integerLcmIdKey :: Unique
integerAndIdKey :: Unique
integerOrIdKey :: Unique
integerXorIdKey :: Unique
integerComplementIdKey :: Unique
integerBitIdKey :: Unique
integerTestBitIdKey :: Unique
integerShiftLIdKey :: Unique
integerShiftRIdKey :: Unique
rationalTyConKey :: Unique
ratioTyConKey :: Unique
ratioDataConKey :: Unique
realClassKey :: Unique
integralClassKey :: Unique
realFracClassKey :: Unique
fractionalClassKey :: Unique
fromRationalClassOpKey :: Unique
toIntegerClassOpKey :: Unique
toRationalClassOpKey :: Unique
fromIntegralIdKey :: Unique
realToFracIdKey :: Unique
mkRationalBase2IdKey :: Unique
mkRationalBase10IdKey :: Unique
floatingClassKey :: Unique
realFloatClassKey :: Unique
integerToFloatIdKey :: Unique
integerToDoubleIdKey :: Unique
naturalToFloatIdKey :: Unique
naturalToDoubleIdKey :: Unique
rationalToFloatIdKey :: Unique
rationalToDoubleIdKey :: Unique
ixClassKey :: Unique
trModuleTyConKey :: Unique
trModuleDataConKey :: Unique
trNameTyConKey :: Unique
trNameSDataConKey :: Unique
trNameDDataConKey :: Unique
trTyConTyConKey :: Unique
trTyConDataConKey :: Unique
kindRepTyConKey :: Unique
kindRepTyConAppDataConKey :: Unique
kindRepVarDataConKey :: Unique
kindRepAppDataConKey :: Unique
kindRepFunDataConKey :: Unique
kindRepTYPEDataConKey :: Unique
kindRepTypeLitSDataConKey :: Unique
kindRepTypeLitDDataConKey :: Unique
typeLitSortTyConKey :: Unique
typeLitSymbolDataConKey :: Unique
typeLitNatDataConKey :: Unique
typeLitCharDataConKey :: Unique
typeableClassKey :: Unique
typeRepTyConKey :: Unique
someTypeRepTyConKey :: Unique
someTypeRepDataConKey :: Unique
typeRepIdKey :: Unique
mkTrTypeKey :: Unique
mkTrConKey :: Unique
mkTrAppKey :: Unique
mkTrFunKey :: Unique
typeNatTypeRepKey :: Unique
typeSymbolTypeRepKey :: Unique
typeCharTypeRepKey :: Unique
trGhcPrimModuleKey :: Unique
starKindRepKey :: Unique
starArrStarKindRepKey :: Unique
starArrStarArrStarKindRepKey :: Unique
constraintKindRepKey :: Unique
withDictClassKey :: Unique
nonEmptyTyConKey :: Unique
errorMessageTypeErrorFamKey :: Unique
typeErrorTextDataConKey :: Unique
typeErrorAppendDataConKey :: Unique
typeErrorVAppendDataConKey :: Unique
typeErrorShowTypeDataConKey :: Unique
unsafeEqualityTyConKey :: Unique
unsafeReflDataConKey :: Unique
unsafeCoercePrimIdKey :: Unique
toDynIdKey :: Unique
dataClassKey :: Unique
assertErrorIdKey :: Unique
traceKey :: Unique
enumClassKey :: Unique
enumFromClassOpKey :: Unique
enumFromToClassOpKey :: Unique
enumFromThenClassOpKey :: Unique
enumFromThenToClassOpKey :: Unique
boundedClassKey :: Unique
concatIdKey :: Unique
filterIdKey :: Unique
zipIdKey :: Unique
isListClassKey :: Unique
fromListClassOpKey :: Unique
fromListNClassOpKey :: Unique
toListClassOpKey :: Unique
getFieldClassOpKey :: Unique
setFieldClassOpKey :: Unique
showClassKey :: Unique
readClassKey :: Unique
genClassKey :: Unique
gen1ClassKey :: Unique
datatypeClassKey :: Unique
constructorClassKey :: Unique
selectorClassKey :: Unique
genericClassNames :: [Name]
ghciIoClassKey :: Unique
ghciStepIoMClassOpKey :: Unique
ioTyConKey :: Unique
ioDataConKey :: Unique
thenIOIdKey :: Unique
bindIOIdKey :: Unique
returnIOIdKey :: Unique
failIOIdKey :: Unique
printIdKey :: Unique
int8TyConKey :: Unique
int16TyConKey :: Unique
int32TyConKey :: Unique
int64TyConKey :: Unique
word8TyConKey :: Unique
word16TyConKey :: Unique
word32TyConKey :: Unique
word64TyConKey :: Unique
ptrTyConKey :: Unique
funPtrTyConKey :: Unique
stablePtrTyConKey :: Unique
newStablePtrIdKey :: Unique
monadFixClassKey :: Unique
mfixIdKey :: Unique
arrAIdKey :: Unique
composeAIdKey :: Unique
firstAIdKey :: Unique
appAIdKey :: Unique
choiceAIdKey :: Unique
loopAIdKey :: Unique
guardMIdKey :: Unique
liftMIdKey :: Unique
mzipIdKey :: Unique
toAnnotationWrapperIdKey :: Unique
monadPlusClassKey :: Unique
isStringClassKey :: Unique
knownNatClassNameKey :: Unique
knownSymbolClassNameKey :: Unique
knownCharClassNameKey :: Unique
fromLabelClassOpKey :: Unique
hasFieldClassNameKey :: Unique
callStackTyConKey :: Unique
emptyCallStackKey :: Unique
pushCallStackKey :: Unique
srcLocDataConKey :: Unique
pLUGINS :: Module
pluginTyConKey :: Unique
frontendPluginTyConKey :: Unique
makeStaticKey :: Unique
staticPtrInfoTyConName :: Name
staticPtrInfoTyConKey :: Unique
staticPtrInfoDataConKey :: Unique
staticPtrTyConKey :: Unique
staticPtrDataConKey :: Unique
fromStaticPtrClassOpKey :: Unique
fingerprintDataConKey :: Unique
constPtrTyConKey :: Unique
randomClassKey :: Unique
randomGenClassKey :: Unique
addrPrimTyConKey :: Unique
arrayPrimTyConKey :: Unique
boolTyConKey :: Unique
byteArrayPrimTyConKey :: Unique
charPrimTyConKey :: Unique
charTyConKey :: Unique
doublePrimTyConKey :: Unique
doubleTyConKey :: Unique
floatPrimTyConKey :: Unique
floatTyConKey :: Unique
fUNTyConKey :: Unique
intPrimTyConKey :: Unique
intTyConKey :: Unique
int8PrimTyConKey :: Unique
int16PrimTyConKey :: Unique
int32PrimTyConKey :: Unique
int64PrimTyConKey :: Unique
integerTyConKey :: Unique
naturalTyConKey :: Unique
foreignObjPrimTyConKey :: Unique
maybeTyConKey :: Unique
weakPrimTyConKey :: Unique
mutableArrayPrimTyConKey :: Unique
mutableByteArrayPrimTyConKey :: Unique
mVarPrimTyConKey :: Unique
realWorldTyConKey :: Unique
stablePtrPrimTyConKey :: Unique
ioPortPrimTyConKey :: Unique
smallArrayPrimTyConKey :: Unique
smallMutableArrayPrimTyConKey :: Unique
stringTyConKey :: Unique
ccArrowTyConKey :: Unique
ctArrowTyConKey :: Unique
tcArrowTyConKey :: Unique
statePrimTyConKey :: Unique
stableNamePrimTyConKey :: Unique
stableNameTyConKey :: Unique
mutVarPrimTyConKey :: Unique
wordPrimTyConKey :: Unique
wordTyConKey :: Unique
word8PrimTyConKey :: Unique
word16PrimTyConKey :: Unique
word32PrimTyConKey :: Unique
word64PrimTyConKey :: Unique
kindConKey :: Unique
boxityConKey :: Unique
typeConKey :: Unique
threadIdPrimTyConKey :: Unique
bcoPrimTyConKey :: Unique
tVarPrimTyConKey :: Unique
eqPrimTyConKey :: Unique
eqReprPrimTyConKey :: Unique
eqPhantPrimTyConKey :: Unique
compactPrimTyConKey :: Unique
stackSnapshotPrimTyConKey :: Unique
promptTagPrimTyConKey :: Unique
dictTyConKey :: Unique
unliftedTypeKindTyConKey :: Unique
liftedRepTyConKey :: Unique
unliftedRepTyConKey :: Unique
levityTyConKey :: Unique
runtimeRepTyConKey :: Unique
vecCountTyConKey :: Unique
vecElemTyConKey :: Unique
zeroBitRepTyConKey :: Unique
zeroBitTypeTyConKey :: Unique
proxyPrimTyConKey :: Unique
anyTyConKey :: Unique
multiplicityTyConKey :: Unique
int8X16PrimTyConKey :: Unique
int16X8PrimTyConKey :: Unique
int32X4PrimTyConKey :: Unique
int64X2PrimTyConKey :: Unique
int8X32PrimTyConKey :: Unique
int16X16PrimTyConKey :: Unique
int32X8PrimTyConKey :: Unique
int64X4PrimTyConKey :: Unique
int8X64PrimTyConKey :: Unique
int16X32PrimTyConKey :: Unique
int32X16PrimTyConKey :: Unique
int64X8PrimTyConKey :: Unique
word8X16PrimTyConKey :: Unique
word16X8PrimTyConKey :: Unique
word32X4PrimTyConKey :: Unique
word64X2PrimTyConKey :: Unique
word8X32PrimTyConKey :: Unique
word16X16PrimTyConKey :: Unique
word32X8PrimTyConKey :: Unique
word64X4PrimTyConKey :: Unique
word8X64PrimTyConKey :: Unique
word16X32PrimTyConKey :: Unique
word32X16PrimTyConKey :: Unique
word64X8PrimTyConKey :: Unique
floatX4PrimTyConKey :: Unique
doubleX2PrimTyConKey :: Unique
floatX8PrimTyConKey :: Unique
doubleX4PrimTyConKey :: Unique
floatX16PrimTyConKey :: Unique
doubleX8PrimTyConKey :: Unique
typeSymbolKindConNameKey :: Unique
typeCharKindConNameKey :: Unique
typeLeqCharTyFamNameKey :: Unique
charDataConKey :: Unique
consDataConKey :: Unique
doubleDataConKey :: Unique
falseDataConKey :: Unique
floatDataConKey :: Unique
intDataConKey :: Unique
stableNameDataConKey :: Unique
wordDataConKey :: Unique
word8DataConKey :: Unique
heqDataConKey :: Unique
eqDataConKey :: Unique
nothingDataConKey :: Unique
justDataConKey :: Unique
crossDataConKey :: Unique
inlDataConKey :: Unique
inrDataConKey :: Unique
genUnitDataConKey :: Unique
mkDictDataConKey :: Unique
coercibleDataConKey :: Unique
vecRepDataConKey :: Unique
sumRepDataConKey :: Unique
tupleRepDataConKey :: Unique
boxedRepDataConKey :: Unique
boxedRepDataConTyConKey :: Unique
tupleRepDataConTyConKey :: Unique
runtimeRepSimpleDataConKeys :: [Unique]
liftedDataConKey :: Unique
unliftedDataConKey :: Unique
vecCountDataConKeys :: [Unique]
vecElemDataConKeys :: [Unique]
oneDataConKey :: Unique
manyDataConKey :: Unique
integerISDataConKey :: Unique
integerINDataConKey :: Unique
integerIPDataConKey :: Unique
naturalNSDataConKey :: Unique
naturalNBDataConKey :: Unique
absentErrorIdKey :: Unique
absentConstraintErrorIdKey :: Unique
recSelErrorIdKey :: Unique
seqIdKey :: Unique
noMethodBindingErrorIdKey :: Unique
nonExhaustiveGuardsErrorIdKey :: Unique
impossibleErrorIdKey :: Unique
impossibleConstraintErrorIdKey :: Unique
patErrorIdKey :: Unique
voidPrimIdKey :: Unique
realWorldPrimIdKey :: Unique
recConErrorIdKey :: Unique
typeErrorIdKey :: Unique
absentSumFieldErrorIdKey :: Unique
nullAddrIdKey :: Unique
voidArgIdKey :: Unique
leftSectionKey :: Unique
rightSectionKey :: Unique
rootMainKey :: Unique
oneShotKey :: Unique
nospecIdKey :: Unique
noinlineIdKey :: Unique
noinlineConstraintIdKey :: Unique
coercionTokenIdKey :: Unique
coerceKey :: Unique
proxyHashKey :: Unique
mkTyConKey :: Unique
trTYPEKey :: Unique
trTYPE'PtrRepLiftedKey :: Unique
trRuntimeRepKey :: Unique
tr'PtrRepLiftedKey :: Unique
trLiftedRepKey :: Unique
bitIntegerIdKey :: Unique
heqSCSelIdKey :: Unique
eqSCSelIdKey :: Unique
coercibleSCSelIdKey :: Unique
numericClassKeys :: [Unique]
fractionalClassKeys :: [Unique]
standardClassKeys :: [Unique]
derivableClassKeys :: [Unique]
interactiveClassNames :: [Name]
interactiveClassKeys :: [Unique]

module GHC.Core.TyCon

-- | TyCons represent type constructors. Type constructors are introduced
--   by things such as:
--   
--   1) Data declarations: <tt>data Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor of kind <tt>*</tt>
--   
--   2) Type synonyms: <tt>type Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor
--   
--   3) Newtypes: <tt>newtype Foo a = MkFoo ...</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>* -&gt; *</tt>
--   
--   4) Class declarations: <tt>class Foo where</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>*</tt>
--   
--   This data type also encodes a number of primitive, built in type
--   constructors such as those for function and tuple types.
--   
--   If you edit this type, you may need to update the GHC formalism See
--   Note [GHC Formalism] in GHC.Core.Lint
data TyCon

-- | Represents right-hand-sides of <a>TyCon</a>s for algebraic types
data AlgTyConRhs

-- | Says that we know nothing about this data type, except that it's
--   represented by a pointer. Used when we export a data type abstractly
--   into an .hi file.
AbstractTyCon :: AlgTyConRhs

-- | Information about those <a>TyCon</a>s derived from a <tt>data</tt>
--   declaration. This includes data types with no constructors at all.
DataTyCon :: [DataCon] -> Int -> Bool -> Bool -> Bool -> AlgTyConRhs

-- | The data type constructors; can be empty if the user declares the type
--   to have no constructors
--   
--   INVARIANT: Kept in order of increasing <a>DataCon</a> tag (see the tag
--   assignment in mkTyConTagMap)
[data_cons] :: AlgTyConRhs -> [DataCon]

-- | Cached value: length data_cons
[data_cons_size] :: AlgTyConRhs -> Int

-- | Cached value: is this an enumeration type? See Note [Enumeration
--   types]
[is_enum] :: AlgTyConRhs -> Bool
[is_type_data] :: AlgTyConRhs -> Bool

-- | <a>True</a> if the data type constructor has a known, fixed levity
--   when fully applied to its arguments, False otherwise.
--   
--   This can only be <a>False</a> with UnliftedDatatypes, e.g.
--   
--   <pre>
--   data A :: TYPE (BoxedRep l) where { MkA :: Int -&gt; A }
--   </pre>
--   
--   This boolean is cached to make it cheaper to check for levity and
--   representation-polymorphism in tcHasFixedRuntimeRep.
[data_fixed_lev] :: AlgTyConRhs -> Bool
TupleTyCon :: DataCon -> TupleSort -> AlgTyConRhs

-- | The unique constructor for the <tt>newtype</tt>. It has no
--   existentials
[data_con] :: AlgTyConRhs -> DataCon

-- | Is this a boxed, unboxed or constraint tuple?
[tup_sort] :: AlgTyConRhs -> TupleSort

-- | An unboxed sum type.
SumTyCon :: [DataCon] -> Int -> AlgTyConRhs

-- | The data type constructors; can be empty if the user declares the type
--   to have no constructors
--   
--   INVARIANT: Kept in order of increasing <a>DataCon</a> tag (see the tag
--   assignment in mkTyConTagMap)
[data_cons] :: AlgTyConRhs -> [DataCon]

-- | Cached value: length data_cons
[data_cons_size] :: AlgTyConRhs -> Int

-- | Information about those <a>TyCon</a>s derived from a <tt>newtype</tt>
--   declaration
NewTyCon :: DataCon -> Type -> ([TyVar], Type) -> CoAxiom Unbranched -> Bool -> AlgTyConRhs

-- | The unique constructor for the <tt>newtype</tt>. It has no
--   existentials
[data_con] :: AlgTyConRhs -> DataCon

-- | Cached value: the argument type of the constructor, which is just the
--   representation type of the <a>TyCon</a> (remember that
--   <tt>newtype</tt>s do not exist at runtime so need a different
--   representation type).
--   
--   The free <a>TyVar</a>s of this type are the <a>tyConTyVars</a> from
--   the corresponding <a>TyCon</a>
[nt_rhs] :: AlgTyConRhs -> Type

-- | Same as the <a>nt_rhs</a>, but this time eta-reduced. Hence the list
--   of <a>TyVar</a>s in this field may be shorter than the declared arity
--   of the <a>TyCon</a>.
[nt_etad_rhs] :: AlgTyConRhs -> ([TyVar], Type)
[nt_co] :: AlgTyConRhs -> CoAxiom Unbranched

-- | <a>True</a> if the newtype has a known, fixed representation when
--   fully applied to its arguments, <a>False</a> otherwise. This can only
--   ever be <a>False</a> with UnliftedNewtypes.
--   
--   Example:
--   
--   <pre>
--   newtype N (a :: TYPE r) = MkN a
--   </pre>
--   
--   Invariant: nt_fixed_rep nt = tcHasFixedRuntimeRep (nt_rhs nt)
--   
--   This boolean is cached to make it cheaper to check if a variable
--   binding is representation-polymorphic in tcHasFixedRuntimeRep.
[nt_fixed_rep] :: AlgTyConRhs -> Bool

-- | Extract those <a>DataCon</a>s that we are able to learn about. Note
--   that visibility in this sense does not correspond to visibility in the
--   context of any particular user program!
visibleDataCons :: AlgTyConRhs -> [DataCon]

-- | Describes the flavour of an algebraic type constructor. For classes
--   and data families, this flavour includes a reference to the parent
--   <a>TyCon</a>.
data AlgTyConFlav

-- | An ordinary algebraic type constructor. This includes unlifted and
--   representation-polymorphic datatypes and newtypes and unboxed tuples,
--   but NOT unboxed sums; see UnboxedSumTyCon.
VanillaAlgTyCon :: TyConRepName -> AlgTyConFlav

-- | An unboxed sum type constructor. This is distinct from VanillaAlgTyCon
--   because we currently don't allow unboxed sums to be Typeable since
--   there are too many of them. See #13276.
UnboxedSumTyCon :: AlgTyConFlav

-- | Type constructors representing a class dictionary. See Note [ATyCon
--   for classes] in <a>GHC.Core.TyCo.Rep</a>
ClassTyCon :: Class -> TyConRepName -> AlgTyConFlav

-- | Type constructors representing an *instance* of a *data* family.
--   Parameters:
--   
--   1) The type family in question
--   
--   2) Instance types; free variables are the <a>tyConTyVars</a> of the
--   current <a>TyCon</a> (not the family one). INVARIANT: the number of
--   types matches the arity of the family <a>TyCon</a>
--   
--   3) A <tt>CoTyCon</tt> identifying the representation type with the
--   type instance family
DataFamInstTyCon :: CoAxiom Unbranched -> TyCon -> [Type] -> AlgTyConFlav
isNoParent :: AlgTyConFlav -> Bool

-- | Information pertaining to the expansion of a type synonym
--   (<tt>type</tt>)
data FamTyConFlav

-- | Represents an open type family without a fixed right hand side.
--   Additional instances can appear at any time.
--   
--   These are introduced by either a top level declaration:
--   
--   <pre>
--   data family T a :: *
--   </pre>
--   
--   Or an associated data type declaration, within a class declaration:
--   
--   <pre>
--   class C a b where
--     data T b :: *
--   </pre>
DataFamilyTyCon :: TyConRepName -> FamTyConFlav

-- | An open type synonym family e.g. <tt>type family F x y :: * -&gt;
--   *</tt>
OpenSynFamilyTyCon :: FamTyConFlav

-- | A closed type synonym family e.g. <tt>type family F x where { F Int =
--   Bool }</tt>
ClosedSynFamilyTyCon :: Maybe (CoAxiom Branched) -> FamTyConFlav

-- | A closed type synonym family declared in an hs-boot file with type
--   family F a where ..
AbstractClosedSynFamilyTyCon :: FamTyConFlav

-- | Built-in type family used by the TypeNats solver
BuiltInSynFamTyCon :: BuiltInSynFamily -> FamTyConFlav

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
data Injectivity
NotInjective :: Injectivity
Injective :: [Bool] -> Injectivity

-- | Some promoted datacons signify extra info relevant to GHC. For
--   example, the <a>IntRep</a> constructor of <a>RuntimeRep</a>
--   corresponds to the <a>IntRep</a> constructor of <a>PrimRep</a>. This
--   data structure allows us to store this information right in the
--   <a>TyCon</a>. The other approach would be to look up things like
--   <a>RuntimeRep</a>'s <a>PrimRep</a> by known-key every time. See also
--   Note [Getting from RuntimeRep to PrimRep] in <a>GHC.Types.RepType</a>
data PromDataConInfo

-- | an ordinary promoted data con
NoPromInfo :: PromDataConInfo

-- | A constructor of <a>RuntimeRep</a>. The argument to the function
--   should be the list of arguments to the promoted datacon.
RuntimeRep :: ([Type] -> [PrimRep]) -> PromDataConInfo

-- | A constructor of <a>VecCount</a>
VecCount :: Int -> PromDataConInfo

-- | A constructor of <a>VecElem</a>
VecElem :: PrimElemRep -> PromDataConInfo

-- | A constructor of <a>PromDataConInfo</a>
Levity :: Levity -> PromDataConInfo

-- | Paints a picture of what a <a>TyCon</a> represents, in broad strokes.
--   This is used towards more informative error messages.
data TyConFlavour
ClassFlavour :: TyConFlavour
TupleFlavour :: Boxity -> TyConFlavour
SumFlavour :: TyConFlavour
DataTypeFlavour :: TyConFlavour
NewtypeFlavour :: TyConFlavour
AbstractTypeFlavour :: TyConFlavour
DataFamilyFlavour :: Maybe TyCon -> TyConFlavour
OpenTypeFamilyFlavour :: Maybe TyCon -> TyConFlavour
ClosedTypeFamilyFlavour :: TyConFlavour
TypeSynonymFlavour :: TyConFlavour

-- | e.g., the <tt>(-&gt;)</tt> <a>TyCon</a>.
BuiltInTypeFlavour :: TyConFlavour
PromotedDataConFlavour :: TyConFlavour
type TyConBinder = VarBndr TyVar TyConBndrVis
data TyConBndrVis
NamedTCB :: ForAllTyFlag -> TyConBndrVis
AnonTCB :: FunTyFlag -> TyConBndrVis
type TyConPiTyBinder = VarBndr TyCoVar TyConBndrVis
mkNamedTyConBinder :: ForAllTyFlag -> TyVar -> TyConBinder
mkNamedTyConBinders :: ForAllTyFlag -> [TyVar] -> [TyConBinder]

-- | Make a Required TyConBinder. It chooses between NamedTCB and AnonTCB
--   based on whether the tv is mentioned in the dependent set
mkRequiredTyConBinder :: TyCoVarSet -> TyVar -> TyConBinder
mkAnonTyConBinder :: TyVar -> TyConBinder
mkAnonTyConBinders :: [TyVar] -> [TyConBinder]
mkInvisAnonTyConBinder :: TyVar -> TyConBinder
tyConBinderForAllTyFlag :: TyConBinder -> ForAllTyFlag
tyConBndrVisForAllTyFlag :: TyConBndrVis -> ForAllTyFlag
isNamedTyConBinder :: TyConBinder -> Bool
isVisibleTyConBinder :: VarBndr tv TyConBndrVis -> Bool
isInvisibleTyConBinder :: VarBndr tv TyConBndrVis -> Bool
isVisibleTcbVis :: TyConBndrVis -> Bool

-- | The labels for the fields of this particular <a>TyCon</a>
tyConFieldLabels :: TyCon -> [FieldLabel]

-- | Look up a field label belonging to this <a>TyCon</a>
lookupTyConFieldLabel :: FieldLabelString -> TyCon -> Maybe FieldLabel

-- | This is the making of an algebraic <a>TyCon</a>.
mkAlgTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> Maybe CType -> [PredType] -> AlgTyConRhs -> AlgTyConFlav -> Bool -> TyCon

-- | Simpler specialization of <a>mkAlgTyCon</a> for classes
mkClassTyCon :: Name -> [TyConBinder] -> [Role] -> AlgTyConRhs -> Class -> Name -> TyCon

-- | Create an primitive <a>TyCon</a>, such as <tt>Int#</tt>, <tt>Type</tt>
--   or <tt>RealWorld#</tt> Primitive TyCons are marshalable iff not
--   lifted. If you'd like to change this, modify marshalablePrimTyCon.
mkPrimTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> TyCon
mkTupleTyCon :: Name -> [TyConBinder] -> Kind -> DataCon -> TupleSort -> AlgTyConFlav -> TyCon
mkSumTyCon :: Name -> [TyConBinder] -> Kind -> [DataCon] -> AlgTyConFlav -> TyCon

-- | Create an <a>AlgTyConRhs</a> from the data constructors.
--   
--   Use <tt>mkLevPolyDataConRhs</tt> if the datatype can be
--   levity-polymorphic or if it comes from a "data type" declaration
mkDataTyConRhs :: [DataCon] -> AlgTyConRhs

-- | Create an <a>AlgTyConRhs</a> from the data constructors, for a
--   potentially levity-polymorphic datatype (with
--   <tt>UnliftedDatatypes</tt>).
mkLevPolyDataTyConRhs :: Bool -> Bool -> [DataCon] -> AlgTyConRhs

-- | Create a type synonym <a>TyCon</a>
mkSynonymTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> Type -> Bool -> Bool -> Bool -> TyCon

-- | Create a type family <a>TyCon</a>
mkFamilyTyCon :: Name -> [TyConBinder] -> Kind -> Maybe Name -> FamTyConFlav -> Maybe Class -> Injectivity -> TyCon

-- | Create a promoted data constructor <a>TyCon</a> Somewhat dodgily, we
--   give it the same Name as the data constructor itself; when we
--   pretty-print the TyCon we add a quote; see the Outputable TyCon
--   instance
mkPromotedDataCon :: DataCon -> Name -> TyConRepName -> [TyConPiTyBinder] -> Kind -> [Role] -> PromDataConInfo -> TyCon

-- | Makes a tycon suitable for use during type-checking. It stores a
--   variety of details about the definition of the TyCon, but no
--   right-hand side. It lives only during the type-checking of a
--   mutually-recursive group of tycons; it is then zonked to a proper
--   TyCon in zonkTcTyCon. See also Note [Kind checking recursive type and
--   class declarations] in <a>GHC.Tc.TyCl</a>.
mkTcTyCon :: Name -> [TyConBinder] -> Kind -> [(Name, TcTyVar)] -> Bool -> TyConFlavour -> TyCon

-- | No scoped type variables (to be used with mkTcTyCon).
noTcTyConScopedTyVars :: [(Name, TcTyVar)]

-- | Returns <tt>True</tt> if the supplied <a>TyCon</a> resulted from
--   either a <tt>data</tt> or <tt>newtype</tt> declaration
isAlgTyCon :: TyCon -> Bool

-- | Returns <tt>True</tt> for vanilla AlgTyCons -- that is, those created
--   with a <tt>data</tt> or <tt>newtype</tt> declaration.
isVanillaAlgTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a class instance?
isClassTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a data family instance?
isFamInstTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent something that cannot be defined in
--   Haskell?
isPrimTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent a tuple?
--   
--   NB: when compiling <tt>Data.Tuple</tt>, the tycons won't reply
--   <tt>True</tt> to <a>isTupleTyCon</a>, because they are built as
--   <tt>AlgTyCons</tt>. However they get spat into the interface file as
--   tuple tycons, so I don't think it matters.
isTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for an unboxed tuple?
isUnboxedTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for a boxed tuple?
isBoxedTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for an unboxed sum?
isUnboxedSumTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for a <i>promoted</i> tuple?
isPromotedTupleTyCon :: TyCon -> Bool
isLiftedAlgTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a> representing a regular H98 type synonym
--   (<tt>type</tt>)?
isTypeSynonymTyCon :: TyCon -> Bool

-- | True iff we can decompose (T a b c) into ((T a b) c) I.e. is it
--   injective and generative w.r.t nominal equality? That is, if (T a b)
--   ~N d e f, is it always the case that (T ~N d), (a ~N e) and (b ~N f)?
--   Specifically NOT true of synonyms (open and otherwise)
--   
--   It'd be unusual to call tyConMustBeSaturated on a regular H98 type
--   synonym, because you should probably have expanded it first But
--   regardless, it's not decomposable
tyConMustBeSaturated :: TyCon -> Bool

-- | Is this a PromotedDataCon?
isPromotedDataCon :: TyCon -> Bool

-- | Retrieves the promoted DataCon if this is a PromotedDataCon;
isPromotedDataCon_maybe :: TyCon -> Maybe DataCon

-- | This function identifies PromotedDataCon's from data constructors in
--   `data T = K1 | K2`, promoted by -XDataKinds. These type constructors
--   are printed with a tick mark 'K1 and 'K2, and similarly have a tick
--   mark added to their OccName's.
--   
--   In contrast, constructors in `type data T = K1 | K2` are printed and
--   represented with their original undecorated names. See Note [Type data
--   declarations] in GHC.Rename.Module
isDataKindsPromotedDataCon :: TyCon -> Bool

-- | Is this tycon really meant for use at the kind level? That is, should
--   it be permitted without -XDataKinds?
isKindTyCon :: TyCon -> Bool
isLiftedTypeKindTyConName :: Name -> Bool
isTauTyCon :: TyCon -> Bool

-- | Is this tycon neither a type family nor a synonym that expands to a
--   type family?
isFamFreeTyCon :: TyCon -> Bool

-- | Is this a forgetful type synonym? If this is a type synonym whose RHS
--   does not mention one (or more) of its bound variables, returns True.
--   Thus, False means that all bound variables appear on the RHS; True may
--   not mean anything, as the test to set this flag is conservative.
isForgetfulSynTyCon :: TyCon -> Bool

-- | Returns <tt>True</tt> for data types that are <i>definitely</i>
--   represented by heap-allocated constructors. These are scrutinised by
--   Core-level <tt>case</tt> expressions, and they get info tables
--   allocated for them.
--   
--   Generally, the function will be true for all <tt>data</tt> types and
--   false for <tt>newtype</tt>s, unboxed tuples, unboxed sums and type
--   family <a>TyCon</a>s. But it is not guaranteed to return <tt>True</tt>
--   in all cases that it could.
--   
--   NB: for a data type family, only the <i>instance</i> <a>TyCon</a>s get
--   an info table. The family declaration <a>TyCon</a> does not
isDataTyCon :: TyCon -> Bool

-- | Was this <a>TyCon</a> declared as "type data"? See Note [Type data
--   declarations] in GHC.Rename.Module.
isTypeDataTyCon :: TyCon -> Bool

-- | Is this an algebraic <a>TyCon</a> which is just an enumeration of
--   values?
isEnumerationTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a <tt>newtype</tt>
isNewTyCon :: TyCon -> Bool

-- | Test if the <a>TyCon</a> is algebraic but abstract (invisible data
--   constructors)
isAbstractTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family?
isFamilyTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family
--   with instances?
isOpenFamilyTyCon :: TyCon -> Bool

-- | Is this a synonym <a>TyCon</a> that can have may have further
--   instances appear?
isTypeFamilyTyCon :: TyCon -> Bool

-- | Is this a synonym <a>TyCon</a> that can have may have further
--   instances appear?
isDataFamilyTyCon :: TyCon -> Bool

-- | Is this an open type family TyCon?
isOpenTypeFamilyTyCon :: TyCon -> Bool

-- | Is this a non-empty closed type family? Returns <a>Nothing</a> for
--   abstract or empty closed families.
isClosedSynFamilyTyConWithAxiom_maybe :: TyCon -> Maybe (CoAxiom Branched)

-- | <tt><a>tyConInjectivityInfo</a> tc</tt> returns <tt><a>Injective</a>
--   is</tt> if <tt>tc</tt> is an injective tycon (where <tt>is</tt> states
--   for which <a>tyConBinders</a> <tt>tc</tt> is injective), or
--   <a>NotInjective</a> otherwise.
tyConInjectivityInfo :: TyCon -> Injectivity
isBuiltInSynFamTyCon_maybe :: TyCon -> Maybe BuiltInSynFamily

-- | Is this an algebraic <a>TyCon</a> declared with the GADT syntax?
isGadtSyntaxTyCon :: TyCon -> Bool

-- | <a>isInjectiveTyCon</a> is true of <a>TyCon</a>s for which this
--   property holds (where r is the role passed in): If (T a1 b1 c1) ~r (T
--   a2 b2 c2), then (a1 ~r1 a2), (b1 ~r2 b2), and (c1 ~r3 c2) (where r1,
--   r2, and r3, are the roles given by tyConRolesX tc r) See also Note
--   [Decomposing TyConApp equalities] in <a>GHC.Tc.Solver.Canonical</a>
isInjectiveTyCon :: TyCon -> Role -> Bool

-- | <a>isGenerativeTyCon</a> is true of <a>TyCon</a>s for which this
--   property holds (where r is the role passed in): If (T tys ~r t), then
--   (t's head ~r T). See also Note [Decomposing TyConApp equalities] in
--   <a>GHC.Tc.Solver.Canonical</a>
isGenerativeTyCon :: TyCon -> Role -> Bool

-- | Is this an <a>AlgTyConRhs</a> of a <a>TyCon</a> that is generative and
--   injective with respect to representational equality?
isGenInjAlgRhs :: AlgTyConRhs -> Bool

-- | Is this TyCon for an associated type?
isTyConAssoc :: TyCon -> Bool

-- | Get the enclosing class TyCon (if there is one) for the given TyCon.
tyConAssoc_maybe :: TyCon -> Maybe TyCon

-- | Get the enclosing class TyCon (if there is one) for the given
--   TyConFlavour
tyConFlavourAssoc_maybe :: TyConFlavour -> Maybe TyCon

-- | Identifies implicit tycons that, in particular, do not go into
--   interface files (because they are implicitly reconstructed when the
--   interface is read).
--   
--   Note that:
--   
--   <ul>
--   <li>Associated families are implicit, as they are re-constructed from
--   the class declaration in which they reside, and</li>
--   <li>Family instances are <i>not</i> implicit as they represent the
--   instance body (similar to a <tt>dfun</tt> does that for a class
--   instance).</li>
--   <li>Tuples are implicit iff they have a wired-in name (namely: boxed
--   and unboxed tuples are wired-in and implicit, but constraint tuples
--   are not)</li>
--   </ul>
isImplicitTyCon :: TyCon -> Bool

-- | Check if the tycon actually refers to a proper `data` or `newtype`
--   with user defined constructors rather than one from a class or other
--   construction.
isTyConWithSrcDataCons :: TyCon -> Bool

-- | Is this a TcTyCon? (That is, one only used during type-checking?)
isTcTyCon :: TyCon -> Bool
setTcTyConKind :: TyCon -> Kind -> TyCon

-- | Does this <a>TyCon</a> have a syntactically fixed RuntimeRep when
--   fully applied, as per Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete?
--   
--   False is safe. True means we're sure. Does only a quick check, based
--   on the TyCon's category.
--   
--   See Note [Representation-polymorphic TyCons]
tcHasFixedRuntimeRep :: TyCon -> Bool

-- | Is this <a>TyCon</a> concrete (i.e. not a synonym/type family)?
--   
--   Used for representation polymorphism checks.
isConcreteTyCon :: TyCon -> Bool

-- | Name of the constructor
tyConName :: TyCon -> Name

-- | Returns whether or not this <a>TyCon</a> is definite, or a hole that
--   may be filled in at some later point. See Note [Skolem abstract data]
tyConSkolem :: TyCon -> Bool

-- | Kind of this TyCon
tyConKind :: TyCon -> Kind

-- | A Unique of this TyCon. Invariant: identical to Unique of Name stored
--   in tyConName field.
tyConUnique :: TyCon -> Unique

-- | TyVar binders
tyConTyVars :: TyCon -> [TyVar]
tyConVisibleTyVars :: TyCon -> [TyVar]
tyConCType_maybe :: TyCon -> Maybe CType

-- | As <a>tyConDataCons_maybe</a>, but returns the empty list of
--   constructors if no constructors could be found
tyConDataCons :: TyCon -> [DataCon]

-- | Determine the <a>DataCon</a>s originating from the given <a>TyCon</a>,
--   if the <a>TyCon</a> is the sort that can have any constructors (note:
--   this does not include abstract algebraic types)
tyConDataCons_maybe :: TyCon -> Maybe [DataCon]

-- | If the given <a>TyCon</a> has a <i>single</i> data constructor, i.e.
--   it is a <tt>data</tt> type with one alternative, a tuple type or a
--   <tt>newtype</tt> then that constructor is returned. If the
--   <a>TyCon</a> has more than one constructor, or represents a primitive
--   or function type constructor then <tt>Nothing</tt> is returned.
tyConSingleDataCon_maybe :: TyCon -> Maybe DataCon

-- | Like <a>tyConSingleDataCon_maybe</a>, but panics if <a>Nothing</a>.
tyConSingleDataCon :: TyCon -> DataCon

-- | Returns <tt>Just dcs</tt> if the given <a>TyCon</a> is a <tt>data</tt>
--   type, a tuple type or a sum type with data constructors dcs. If the
--   <a>TyCon</a> has more than one constructor, or represents a primitive
--   or function type constructor then <tt>Nothing</tt> is returned.
--   
--   Like <a>tyConDataCons_maybe</a>, but returns <a>Nothing</a> for
--   newtypes.
tyConAlgDataCons_maybe :: TyCon -> Maybe [DataCon]

-- | Like <a>tyConSingleDataCon_maybe</a>, but returns <a>Nothing</a> for
--   newtypes.
tyConSingleAlgDataCon_maybe :: TyCon -> Maybe DataCon

-- | Determine the number of value constructors a <a>TyCon</a> has. Panics
--   if the <a>TyCon</a> is not algebraic or a tuple
tyConFamilySize :: TyCon -> Int

-- | Find the "stupid theta" of the <a>TyCon</a>. A "stupid theta" is the
--   context to the left of an algebraic type declaration, e.g. <tt>Eq
--   a</tt> in the declaration <tt>data Eq a =&gt; T a ...</tt>. See
--   <tt>Note [The stupid context]</tt> in <a>GHC.Core.DataCon</a>.
tyConStupidTheta :: TyCon -> [PredType]

-- | Arity
tyConArity :: TyCon -> Arity

-- | A pre-allocated <tt>TyConApp tycon []</tt>
tyConNullaryTy :: TyCon -> Type

-- | (mkTyConTy tc) returns (TyConApp tc []) but arranges to share that
--   TyConApp among all calls See Note [Sharing nullary TyConApps] So it's
--   just an alias for tyConNullaryTy!
mkTyConTy :: TyCon -> Type

-- | The role for each type variable This list has length = tyConArity See
--   also Note [TyCon Role signatures]
tyConRoles :: TyCon -> [Role]
tyConFlavour :: TyCon -> TyConFlavour
tyConTuple_maybe :: TyCon -> Maybe TupleSort

-- | If this <a>TyCon</a> is that for a class instance, return the class it
--   is for. Otherwise returns <tt>Nothing</tt>
tyConClass_maybe :: TyCon -> Maybe Class

-- | Return the associated types of the <a>TyCon</a>, if any
tyConATs :: TyCon -> [TyCon]

-- | If this <a>TyCon</a> is that of a data family instance, return the
--   family in question and the instance types. Otherwise, return
--   <tt>Nothing</tt>
tyConFamInst_maybe :: TyCon -> Maybe (TyCon, [Type])
tyConFamInstSig_maybe :: TyCon -> Maybe (TyCon, [Type], CoAxiom Unbranched)

-- | If this <a>TyCon</a> is that of a data family instance, return a
--   <a>TyCon</a> which represents a coercion identifying the
--   representation type with the type instance family. Otherwise, return
--   <tt>Nothing</tt>
tyConFamilyCoercion_maybe :: TyCon -> Maybe (CoAxiom Unbranched)

-- | Extract type variable naming the result of injective type family
tyConFamilyResVar_maybe :: TyCon -> Maybe Name

-- | Extract the <a>TyVar</a>s bound by a vanilla type synonym and the
--   corresponding (unsubstituted) right hand side.
synTyConDefn_maybe :: TyCon -> Maybe ([TyVar], Type)

-- | Extract the information pertaining to the right hand side of a type
--   synonym (<tt>type</tt>) declaration.
synTyConRhs_maybe :: TyCon -> Maybe Type

-- | Extract the flavour of a type family (with all the extra information
--   that it carries)
famTyConFlav_maybe :: TyCon -> Maybe FamTyConFlav

-- | Extract an <a>AlgTyConRhs</a> with information about data constructors
--   from an algebraic or tuple <a>TyCon</a>. Panics for any other sort of
--   <a>TyCon</a>
algTyConRhs :: TyCon -> AlgTyConRhs

-- | Extract the bound type variables and type expansion of a type synonym
--   <a>TyCon</a>. Panics if the <a>TyCon</a> is not a synonym
newTyConRhs :: TyCon -> ([TyVar], Type)

-- | The number of type parameters that need to be passed to a newtype to
--   resolve it. May be less than in the definition if it can be
--   eta-contracted.
newTyConEtadArity :: TyCon -> Int

-- | Extract the bound type variables and type expansion of an
--   eta-contracted type synonym <a>TyCon</a>. Panics if the <a>TyCon</a>
--   is not a synonym
newTyConEtadRhs :: TyCon -> ([TyVar], Type)

-- | Take a <a>TyCon</a> apart into the <a>TyVar</a>s it scopes over, the
--   <a>Type</a> it expands into, and (possibly) a coercion from the
--   representation type to the <tt>newtype</tt>. Returns <tt>Nothing</tt>
--   if this is not possible.
unwrapNewTyCon_maybe :: TyCon -> Maybe ([TyVar], Type, CoAxiom Unbranched)
unwrapNewTyConEtad_maybe :: TyCon -> Maybe ([TyVar], Type, CoAxiom Unbranched)
newTyConDataCon_maybe :: TyCon -> Maybe DataCon

-- | Maps a label to information about the field
algTcFields :: TyConDetails -> FieldLabelEnv

-- | Extract any <tt>RuntimeRepInfo</tt> from this TyCon
tyConPromDataConInfo :: TyCon -> PromDataConInfo

-- | Full binders
tyConBinders :: TyCon -> [TyConBinder]

-- | Result kind
tyConResKind :: TyCon -> Kind
tyConInvisTVBinders :: [TyConBinder] -> [InvisTVBinder]
tcTyConScopedTyVars :: TyCon -> [(Name, TcTyVar)]
isMonoTcTyCon :: TyCon -> Bool
tyConHasClosedResKind :: TyCon -> Bool
mkTyConTagMap :: TyCon -> NameEnv ConTag
data ExpandSynResult tyco
NoExpansion :: ExpandSynResult tyco
ExpandsSyn :: [(TyVar, tyco)] -> Type -> [tyco] -> ExpandSynResult tyco
expandSynTyCon_maybe :: TyCon -> [tyco] -> ExpandSynResult tyco
newTyConCo :: TyCon -> CoAxiom Unbranched

-- | Extracts the <tt>newtype</tt> coercion from such a <a>TyCon</a>, which
--   can be used to construct something with the <tt>newtype</tt>s type
--   from its representation type (right hand side). If the supplied
--   <a>TyCon</a> is not a <tt>newtype</tt>, returns <tt>Nothing</tt>
newTyConCo_maybe :: TyCon -> Maybe (CoAxiom Unbranched)
pprPromotionQuote :: TyCon -> SDoc
mkTyConKind :: [TyConBinder] -> Kind -> Kind

-- | Is this flavour of <a>TyCon</a> an open type family or a data family?
tcFlavourIsOpen :: TyConFlavour -> Bool
type TyConRepName = Name
tyConRepName_maybe :: TyCon -> Maybe TyConRepName

-- | Make a <a>Name</a> for the <tt>Typeable</tt> representation of the
--   given wired-in type
mkPrelTyConRepName :: Name -> TyConRepName

-- | The name (and defining module) for the Typeable representation (TyCon)
--   of a type constructor.
--   
--   See Note [Grand plan for Typeable] in <a>GHC.Tc.Instance.Typeable</a>.
tyConRepModOcc :: Module -> OccName -> (Module, OccName)

-- | A <a>PrimRep</a> is an abstraction of a type. It contains information
--   that the code generator needs in order to pass arguments, return
--   results, and store values of this type. See also Note [RuntimeRep and
--   PrimRep] in <a>GHC.Types.RepType</a> and Note [VoidRep] in
--   <a>GHC.Types.RepType</a>.
data PrimRep
VoidRep :: PrimRep
LiftedRep :: PrimRep

-- | Unlifted pointer
UnliftedRep :: PrimRep

-- | Signed, 8-bit value
Int8Rep :: PrimRep

-- | Signed, 16-bit value
Int16Rep :: PrimRep

-- | Signed, 32-bit value
Int32Rep :: PrimRep

-- | Signed, 64 bit value
Int64Rep :: PrimRep

-- | Signed, word-sized value
IntRep :: PrimRep

-- | Unsigned, 8 bit value
Word8Rep :: PrimRep

-- | Unsigned, 16 bit value
Word16Rep :: PrimRep

-- | Unsigned, 32 bit value
Word32Rep :: PrimRep

-- | Unsigned, 64 bit value
Word64Rep :: PrimRep

-- | Unsigned, word-sized value
WordRep :: PrimRep

-- | A pointer, but <i>not</i> to a Haskell value (use '(Un)liftedRep')
AddrRep :: PrimRep
FloatRep :: PrimRep
DoubleRep :: PrimRep

-- | A vector
VecRep :: Int -> PrimElemRep -> PrimRep
data PrimElemRep
Int8ElemRep :: PrimElemRep
Int16ElemRep :: PrimElemRep
Int32ElemRep :: PrimElemRep
Int64ElemRep :: PrimElemRep
Word8ElemRep :: PrimElemRep
Word16ElemRep :: PrimElemRep
Word32ElemRep :: PrimElemRep
Word64ElemRep :: PrimElemRep
FloatElemRep :: PrimElemRep
DoubleElemRep :: PrimElemRep
primElemRepToPrimRep :: PrimElemRep -> PrimRep
isVoidRep :: PrimRep -> Bool
isGcPtrRep :: PrimRep -> Bool

-- | The size of a <a>PrimRep</a> in bytes.
--   
--   This applies also when used in a constructor, where we allow packing
--   the fields. For instance, in <tt>data Foo = Foo Float# Float#</tt> the
--   two fields will take only 8 bytes, which for 64-bit arch will be equal
--   to 1 word. See also mkVirtHeapOffsetsWithPadding for details of how
--   data fields are laid out.
primRepSizeB :: Platform -> PrimRep -> Int
primElemRepSizeB :: Platform -> PrimElemRep -> Int

-- | Return if Rep stands for floating type, returns Nothing for vector
--   types.
primRepIsFloat :: PrimRep -> Maybe Bool
primRepsCompatible :: Platform -> [PrimRep] -> [PrimRep] -> Bool
primRepCompatible :: Platform -> PrimRep -> PrimRep -> Bool
primRepIsWord :: PrimRep -> Bool
primRepIsInt :: PrimRep -> Bool
instance GHC.Classes.Eq GHC.Core.TyCon.Injectivity
instance GHC.Enum.Enum GHC.Core.TyCon.PrimElemRep
instance GHC.Show.Show GHC.Core.TyCon.PrimElemRep
instance GHC.Classes.Ord GHC.Core.TyCon.PrimElemRep
instance GHC.Classes.Eq GHC.Core.TyCon.PrimElemRep
instance Data.Data.Data GHC.Core.TyCon.PrimElemRep
instance GHC.Show.Show GHC.Core.TyCon.PrimRep
instance GHC.Classes.Ord GHC.Core.TyCon.PrimRep
instance GHC.Classes.Eq GHC.Core.TyCon.PrimRep
instance Data.Data.Data GHC.Core.TyCon.PrimRep
instance GHC.Classes.Eq GHC.Core.TyCon.TyConFlavour
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.AlgTyConFlav
instance GHC.Classes.Eq GHC.Core.TyCon.TyCon
instance GHC.Types.Unique.Uniquable GHC.Core.TyCon.TyCon
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.TyCon
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.TyConFlavour
instance GHC.Types.Name.NamedThing GHC.Core.TyCon.TyCon
instance Data.Data.Data GHC.Core.TyCon.TyCon
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.PrimRep
instance GHC.Utils.Binary.Binary GHC.Core.TyCon.PrimRep
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.PrimElemRep
instance GHC.Utils.Binary.Binary GHC.Core.TyCon.PrimElemRep
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.FamTyConFlav
instance GHC.Utils.Binary.Binary GHC.Core.TyCon.Injectivity
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.TyConBndrVis
instance GHC.Utils.Outputable.OutputableBndr tv => GHC.Utils.Outputable.Outputable (GHC.Types.Var.VarBndr tv GHC.Core.TyCon.TyConBndrVis)
instance GHC.Utils.Binary.Binary GHC.Core.TyCon.TyConBndrVis

module GHC.Core.TyCon.Set
type TyConSet = UniqSet TyCon
emptyTyConSet :: TyConSet
unitTyConSet :: TyCon -> TyConSet
mkTyConSet :: [TyCon] -> TyConSet
unionTyConSet :: TyConSet -> TyConSet -> TyConSet
unionTyConSets :: [TyConSet] -> TyConSet
minusTyConSet :: TyConSet -> TyConSet -> TyConSet
elemTyConSet :: TyCon -> TyConSet -> Bool
extendTyConSet :: TyConSet -> TyCon -> TyConSet
extendTyConSetList :: TyConSet -> [TyCon] -> TyConSet
delFromTyConSet :: TyConSet -> TyCon -> TyConSet
delListFromTyConSet :: TyConSet -> [TyCon] -> TyConSet
isEmptyTyConSet :: TyConSet -> Bool
filterTyConSet :: (TyCon -> Bool) -> TyConSet -> TyConSet

-- | True if there is a non-empty intersection. <tt>s1
--   <a>intersectsTyConSet</a> s2</tt> doesn't compute <tt>s2</tt> if
--   <tt>s1</tt> is empty
intersectsTyConSet :: TyConSet -> TyConSet -> Bool
disjointTyConSet :: TyConSet -> TyConSet -> Bool
intersectTyConSet :: TyConSet -> TyConSet -> TyConSet
nameSetAny :: (TyCon -> Bool) -> TyConSet -> Bool
nameSetAll :: (TyCon -> Bool) -> TyConSet -> Bool

module GHC.Core.TyCon.Env

-- | TyCon Environment
type TyConEnv a = UniqFM TyCon a
mkTyConEnv :: [(TyCon, a)] -> TyConEnv a
mkTyConEnvWith :: (a -> TyCon) -> [a] -> TyConEnv a
emptyTyConEnv :: TyConEnv a
isEmptyTyConEnv :: TyConEnv a -> Bool
unitTyConEnv :: TyCon -> a -> TyConEnv a
nonDetTyConEnvElts :: TyConEnv a -> [a]
extendTyConEnv_C :: (a -> a -> a) -> TyConEnv a -> TyCon -> a -> TyConEnv a
extendTyConEnv_Acc :: (a -> b -> b) -> (a -> b) -> TyConEnv b -> TyCon -> a -> TyConEnv b
extendTyConEnv :: TyConEnv a -> TyCon -> a -> TyConEnv a
extendTyConEnvList :: TyConEnv a -> [(TyCon, a)] -> TyConEnv a
extendTyConEnvList_C :: (a -> a -> a) -> TyConEnv a -> [(TyCon, a)] -> TyConEnv a
filterTyConEnv :: (elt -> Bool) -> TyConEnv elt -> TyConEnv elt
anyTyConEnv :: (elt -> Bool) -> TyConEnv elt -> Bool
plusTyConEnv :: TyConEnv a -> TyConEnv a -> TyConEnv a
plusTyConEnv_C :: (a -> a -> a) -> TyConEnv a -> TyConEnv a -> TyConEnv a
plusTyConEnv_CD :: (a -> a -> a) -> TyConEnv a -> a -> TyConEnv a -> a -> TyConEnv a
plusTyConEnv_CD2 :: (Maybe a -> Maybe a -> a) -> TyConEnv a -> TyConEnv a -> TyConEnv a
alterTyConEnv :: (Maybe a -> Maybe a) -> TyConEnv a -> TyCon -> TyConEnv a
lookupTyConEnv :: TyConEnv a -> TyCon -> Maybe a
lookupTyConEnv_NF :: TyConEnv a -> TyCon -> a
delFromTyConEnv :: TyConEnv a -> TyCon -> TyConEnv a
delListFromTyConEnv :: TyConEnv a -> [TyCon] -> TyConEnv a
elemTyConEnv :: TyCon -> TyConEnv a -> Bool
mapTyConEnv :: (elt1 -> elt2) -> TyConEnv elt1 -> TyConEnv elt2
disjointTyConEnv :: TyConEnv a -> TyConEnv a -> Bool

-- | Deterministic TyCon Environment
--   
--   See Note [Deterministic UniqFM] in <a>GHC.Types.Unique.DFM</a> for
--   explanation why we need DTyConEnv.
type DTyConEnv a = UniqDFM TyCon a
emptyDTyConEnv :: DTyConEnv a
isEmptyDTyConEnv :: DTyConEnv a -> Bool
lookupDTyConEnv :: DTyConEnv a -> TyCon -> Maybe a
delFromDTyConEnv :: DTyConEnv a -> TyCon -> DTyConEnv a
filterDTyConEnv :: (a -> Bool) -> DTyConEnv a -> DTyConEnv a
mapDTyConEnv :: (a -> b) -> DTyConEnv a -> DTyConEnv b
mapMaybeDTyConEnv :: (a -> Maybe b) -> DTyConEnv a -> DTyConEnv b
adjustDTyConEnv :: (a -> a) -> DTyConEnv a -> TyCon -> DTyConEnv a
alterDTyConEnv :: (Maybe a -> Maybe a) -> DTyConEnv a -> TyCon -> DTyConEnv a
extendDTyConEnv :: DTyConEnv a -> TyCon -> a -> DTyConEnv a
foldDTyConEnv :: (elt -> a -> a) -> a -> DTyConEnv elt -> a

module GHC.Core.TyCon.RecWalk
data RecTcChecker

-- | Initialise a <a>RecTcChecker</a> with <a>defaultRecTcMaxBound</a>.
initRecTc :: RecTcChecker

-- | The default upper bound (100) for the number of times a
--   <a>RecTcChecker</a> is allowed to encounter each <a>TyCon</a>.
defaultRecTcMaxBound :: Int

-- | Change the upper bound for the number of times a <a>RecTcChecker</a>
--   is allowed to encounter each <a>TyCon</a>.
setRecTcMaxBound :: Int -> RecTcChecker -> RecTcChecker
checkRecTc :: RecTcChecker -> TyCon -> Maybe RecTcChecker
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCon.RecWalk.RecTcChecker

module GHC.Core.TyCo.Rep
data Type

-- | Vanilla type or kind variable (*never* a coercion variable)
TyVarTy :: Var -> Type

-- | Type application to something other than a <a>TyCon</a>. Parameters:
--   
--   1) Function: must <i>not</i> be a <a>TyConApp</a> or <a>CastTy</a>,
--   must be another <a>AppTy</a>, or <a>TyVarTy</a> See Note [Respecting
--   definitional equality] (EQ1) about the no <a>CastTy</a> requirement
--   
--   2) Argument type
AppTy :: Type -> Type -> Type

-- | Application of a <a>TyCon</a>, including newtypes <i>and</i> synonyms.
--   Invariant: saturated applications of <tt>FunTyCon</tt> must use
--   <a>FunTy</a> and saturated synonyms must use their own constructors.
--   However, <i>unsaturated</i> <tt>FunTyCon</tt>s do appear as
--   <a>TyConApp</a>s. Parameters:
--   
--   1) Type constructor being applied to.
--   
--   2) Type arguments. Might not have enough type arguments here to
--   saturate the constructor. Even type synonyms are not necessarily
--   saturated; for example unsaturated type synonyms can appear as the
--   right hand side of a type synonym.
TyConApp :: TyCon -> [KindOrType] -> Type

-- | A Π type. Note [When we quantify over a coercion variable] INVARIANT:
--   If the binder is a coercion variable, it must be mentioned in the
--   Type. See Note [Unused coercion variable in ForAllTy]
ForAllTy :: {-# UNPACK #-} !ForAllTyBinder -> Type -> Type

-- | FUN m t1 t2 Very common, so an important special case See Note
--   [Function types]
FunTy :: FunTyFlag -> Mult -> Type -> Type -> Type
[ft_af] :: Type -> FunTyFlag
[ft_mult] :: Type -> Mult
[ft_arg] :: Type -> Type
[ft_res] :: Type -> Type

-- | Type literals are similar to type constructors.
LitTy :: TyLit -> Type

-- | A kind cast. The coercion is always nominal. INVARIANT: The cast is
--   never reflexive (EQ2) INVARIANT: The Type is not a CastTy (use TransCo
--   instead) (EQ3) INVARIANT: The Type is not a ForAllTy over a tyvar
--   (EQ4) See Note [Respecting definitional equality]
CastTy :: Type -> KindCoercion -> Type

-- | Injection of a Coercion into a type This should only ever be used in
--   the RHS of an AppTy, in the list of a TyConApp, when applying a
--   promoted GADT data constructor
CoercionTy :: Coercion -> Type
data TyLit
NumTyLit :: Integer -> TyLit
StrTyLit :: FastString -> TyLit
CharTyLit :: Char -> TyLit

-- | The key representation of types within the compiler
type KindOrType = Type

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | Type synonym used for types of kind RuntimeRep.
type RuntimeRepType = Type

-- | Type synonym used for types of kind Levity.
type LevityType = Type

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied ty = ty

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]
type FRRType = Type

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Specified :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion
Refl :: Type -> Coercion
GRefl :: Role -> Type -> MCoercionN -> Coercion
TyConAppCo :: Role -> TyCon -> [Coercion] -> Coercion
AppCo :: Coercion -> CoercionN -> Coercion
ForAllCo :: TyCoVar -> KindCoercion -> Coercion -> Coercion
FunCo :: Role -> FunTyFlag -> FunTyFlag -> CoercionN -> Coercion -> Coercion
[fco_role] :: Coercion -> Role
[fco_afl] :: Coercion -> FunTyFlag
[fco_afr] :: Coercion -> FunTyFlag
[fco_mult] :: Coercion -> CoercionN
[fco_arg, fco_res] :: Coercion -> Coercion
CoVarCo :: CoVar -> Coercion
AxiomInstCo :: CoAxiom Branched -> BranchIndex -> [Coercion] -> Coercion
AxiomRuleCo :: CoAxiomRule -> [Coercion] -> Coercion
UnivCo :: UnivCoProvenance -> Role -> Type -> Type -> Coercion
SymCo :: Coercion -> Coercion
TransCo :: Coercion -> Coercion -> Coercion
SelCo :: CoSel -> Coercion -> Coercion
LRCo :: LeftOrRight -> CoercionN -> Coercion
InstCo :: Coercion -> CoercionN -> Coercion
KindCo :: Coercion -> Coercion
SubCo :: CoercionN -> Coercion

-- | See Note [Coercion holes] Only present during typechecking
HoleCo :: CoercionHole -> Coercion
data CoSel
SelTyCon :: Int -> Role -> CoSel
SelFun :: FunSel -> CoSel
SelForAll :: CoSel
data FunSel
SelMult :: FunSel
SelArg :: FunSel
SelRes :: FunSel

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance

-- | See Note [Phantom coercions]. Only in Phantom roled coercions
PhantomProv :: KindCoercion -> UnivCoProvenance

-- | From the fact that any two coercions are considered equivalent. See
--   Note [ProofIrrelProv]. Can be used in Nominal or Representational
--   coercions
ProofIrrelProv :: KindCoercion -> UnivCoProvenance

-- | From a plugin, which asserts that this coercion is sound. The string
--   is for the use of the plugin.
PluginProv :: String -> UnivCoProvenance
CorePrepProv :: Bool -> UnivCoProvenance

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
coHoleCoVar :: CoercionHole -> CoVar
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole
type CoercionN = Coercion
type CoercionR = Coercion
type CoercionP = Coercion
type KindCoercion = CoercionN

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionR = MCoercion
type MCoercionN = MCoercion

-- | <a>mkNakedTyConTy</a> creates a nullary <a>TyConApp</a>. In general
--   you should rather use <a>mkTyConTy</a>, which picks the shared nullary
--   TyConApp from inside the TyCon (via tyConNullaryTy. But we have to
--   build the TyConApp tc [] in that TyCon field; that's what
--   <a>mkNakedTyConTy</a> is for.
mkNakedTyConTy :: TyCon -> Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkTyCoVarTy :: TyCoVar -> Type
mkTyCoVarTys :: [TyCoVar] -> [Type]
mkFunTy :: HasDebugCallStack => FunTyFlag -> Mult -> Type -> Type -> Type
infixr 3 `mkFunTy`
mkNakedFunTy :: FunTyFlag -> Kind -> Kind -> Kind
mkVisFunTy :: HasDebugCallStack => Mult -> Type -> Type -> Type
mkScaledFunTys :: HasDebugCallStack => [Scaled Type] -> Type -> Type
mkInvisFunTy :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkInvisFunTy`
mkInvisFunTys :: HasDebugCallStack => [Type] -> Type -> Type
tcMkVisFunTy :: Mult -> Type -> Type -> Type
tcMkInvisFunTy :: TypeOrConstraint -> Type -> Type -> Type
tcMkScaledFunTys :: [Scaled Type] -> Type -> Type

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: ForAllTyBinder -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [ForAllTyBinder] -> Type -> Type

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type
mkPiTy :: PiTyBinder -> Type -> Type
mkPiTys :: [PiTyBinder] -> Type -> Type

-- | Make nested arrow types | Special, common, case: Arrow type with mult
--   Many
mkVisFunTyMany :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
mkVisFunTysMany :: [Type] -> Type -> Type
nonDetCmpTyLit :: TyLit -> TyLit -> Ordering
cmpTyLit :: TyLit -> TyLit -> Ordering
pickLR :: LeftOrRight -> (a, a) -> a
data TyCoFolder env a
TyCoFolder :: (Type -> Maybe Type) -> (env -> TyVar -> a) -> (env -> CoVar -> a) -> (env -> CoercionHole -> a) -> (env -> TyCoVar -> ForAllTyFlag -> env) -> TyCoFolder env a
[tcf_view] :: TyCoFolder env a -> Type -> Maybe Type
[tcf_tyvar] :: TyCoFolder env a -> env -> TyVar -> a
[tcf_covar] :: TyCoFolder env a -> env -> CoVar -> a

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcf_hole] :: TyCoFolder env a -> env -> CoercionHole -> a

-- | The returned env is used in the extended scope
[tcf_tycobinder] :: TyCoFolder env a -> env -> TyCoVar -> ForAllTyFlag -> env
foldTyCo :: Monoid a => TyCoFolder env a -> env -> (Type -> a, [Type] -> a, Coercion -> a, [Coercion] -> a)

-- | A view function that looks through nothing.
noView :: Type -> Maybe Type
typeSize :: Type -> Int
coercionSize :: Coercion -> Int
provSize :: UnivCoProvenance -> Int

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a
Scaled :: !Mult -> a -> Scaled a
scaledMult :: Scaled a -> Mult
scaledThing :: Scaled a -> a

-- | Apply a function to both the Mult and the Type in a 'Scaled Type'
mapScaledType :: (Type -> Type) -> Scaled Type -> Scaled Type

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type
instance Data.Data.Data GHC.Core.TyCo.Rep.TyLit
instance GHC.Classes.Eq GHC.Core.TyCo.Rep.TyLit
instance Data.Data.Data GHC.Core.TyCo.Rep.FunSel
instance GHC.Classes.Eq GHC.Core.TyCo.Rep.FunSel
instance Data.Data.Data GHC.Core.TyCo.Rep.CoSel
instance GHC.Classes.Eq GHC.Core.TyCo.Rep.CoSel
instance Data.Data.Data GHC.Core.TyCo.Rep.MCoercion
instance Data.Data.Data GHC.Core.TyCo.Rep.UnivCoProvenance
instance Data.Data.Data GHC.Core.TyCo.Rep.Coercion
instance Data.Data.Data GHC.Core.TyCo.Rep.Type
instance Data.Data.Data a => Data.Data.Data (GHC.Core.TyCo.Rep.Scaled a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.TyCo.Rep.Scaled a)
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.Type
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.Coercion
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.MCoercion
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.UnivCoProvenance
instance Data.Data.Data GHC.Core.TyCo.Rep.CoercionHole
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.CoercionHole
instance GHC.Types.Unique.Uniquable GHC.Core.TyCo.Rep.CoercionHole
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.CoSel
instance GHC.Utils.Binary.Binary GHC.Core.TyCo.Rep.CoSel
instance Control.DeepSeq.NFData GHC.Core.TyCo.Rep.CoSel
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.FunSel
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Rep.TyLit

module GHC.Builtin.Names.TH
templateHaskellNames :: [Name]
thSyn :: Module
thLib :: Module
qqLib :: Module
mkTHModule :: FastString -> Module
libFun :: FastString -> Unique -> Name
libTc :: FastString -> Unique -> Name
thFun :: FastString -> Unique -> Name
thTc :: FastString -> Unique -> Name
thCls :: FastString -> Unique -> Name
thCon :: FastString -> Unique -> Name
qqFun :: FastString -> Unique -> Name
liftClassName :: Name
quoteClassName :: Name
qTyConName :: Name
nameTyConName :: Name
fieldExpTyConName :: Name
patTyConName :: Name
fieldPatTyConName :: Name
expTyConName :: Name
decTyConName :: Name
typeTyConName :: Name
matchTyConName :: Name
clauseTyConName :: Name
funDepTyConName :: Name
predTyConName :: Name
codeTyConName :: Name
injAnnTyConName :: Name
overlapTyConName :: Name
decsTyConName :: Name
modNameTyConName :: Name
returnQName :: Name
bindQName :: Name
sequenceQName :: Name
newNameName :: Name
liftName :: Name
mkNameName :: Name
mkNameG_vName :: Name
mkNameG_dName :: Name
mkNameG_tcName :: Name
mkNameLName :: Name
mkNameSName :: Name
liftStringName :: Name
unTypeName :: Name
unTypeCodeName :: Name
unsafeCodeCoerceName :: Name
liftTypedName :: Name
mkModNameName :: Name
mkNameQName :: Name
charLName :: Name
stringLName :: Name
integerLName :: Name
intPrimLName :: Name
wordPrimLName :: Name
floatPrimLName :: Name
doublePrimLName :: Name
rationalLName :: Name
stringPrimLName :: Name
charPrimLName :: Name
litPName :: Name
varPName :: Name
tupPName :: Name
unboxedTupPName :: Name
unboxedSumPName :: Name
conPName :: Name
infixPName :: Name
tildePName :: Name
bangPName :: Name
asPName :: Name
wildPName :: Name
recPName :: Name
listPName :: Name
sigPName :: Name
viewPName :: Name
fieldPatName :: Name
matchName :: Name
clauseName :: Name
varEName :: Name
conEName :: Name
litEName :: Name
appEName :: Name
appTypeEName :: Name
infixEName :: Name
infixAppName :: Name
sectionLName :: Name
sectionRName :: Name
lamEName :: Name
lamCaseEName :: Name
lamCasesEName :: Name
tupEName :: Name
unboxedTupEName :: Name
unboxedSumEName :: Name
condEName :: Name
multiIfEName :: Name
letEName :: Name
caseEName :: Name
doEName :: Name
mdoEName :: Name
compEName :: Name
staticEName :: Name
unboundVarEName :: Name
labelEName :: Name
implicitParamVarEName :: Name
getFieldEName :: Name
projectionEName :: Name
fromEName :: Name
fromThenEName :: Name
fromToEName :: Name
fromThenToEName :: Name
listEName :: Name
sigEName :: Name
recConEName :: Name
recUpdEName :: Name
fieldExpName :: Name
guardedBName :: Name
normalBName :: Name
normalGEName :: Name
patGEName :: Name
bindSName :: Name
letSName :: Name
noBindSName :: Name
parSName :: Name
recSName :: Name
funDName :: Name
valDName :: Name
dataDName :: Name
newtypeDName :: Name
typeDataDName :: Name
tySynDName :: Name
classDName :: Name
instanceWithOverlapDName :: Name
sigDName :: Name
kiSigDName :: Name
forImpDName :: Name
pragInlDName :: Name
pragSpecDName :: Name
pragSpecInlDName :: Name
pragSpecInstDName :: Name
pragRuleDName :: Name
pragAnnDName :: Name
standaloneDerivWithStrategyDName :: Name
defaultSigDName :: Name
defaultDName :: Name
dataInstDName :: Name
newtypeInstDName :: Name
tySynInstDName :: Name
dataFamilyDName :: Name
openTypeFamilyDName :: Name
closedTypeFamilyDName :: Name
infixLDName :: Name
infixRDName :: Name
infixNDName :: Name
roleAnnotDName :: Name
patSynDName :: Name
patSynSigDName :: Name
pragCompleteDName :: Name
implicitParamBindDName :: Name
pragOpaqueDName :: Name
cxtName :: Name
noSourceUnpackednessName :: Name
sourceNoUnpackName :: Name
sourceUnpackName :: Name
noSourceStrictnessName :: Name
sourceLazyName :: Name
sourceStrictName :: Name
normalCName :: Name
recCName :: Name
infixCName :: Name
forallCName :: Name
gadtCName :: Name
recGadtCName :: Name
bangName :: Name
bangTypeName :: Name
varBangTypeName :: Name
unidirPatSynName :: Name
implBidirPatSynName :: Name
explBidirPatSynName :: Name
prefixPatSynName :: Name
infixPatSynName :: Name
recordPatSynName :: Name
forallTName :: Name
forallVisTName :: Name
varTName :: Name
conTName :: Name
infixTName :: Name
tupleTName :: Name
unboxedTupleTName :: Name
unboxedSumTName :: Name
arrowTName :: Name
mulArrowTName :: Name
listTName :: Name
appTName :: Name
appKindTName :: Name
sigTName :: Name
equalityTName :: Name
litTName :: Name
promotedTName :: Name
promotedTupleTName :: Name
promotedNilTName :: Name
promotedConsTName :: Name
wildCardTName :: Name
implicitParamTName :: Name
numTyLitName :: Name
strTyLitName :: Name
charTyLitName :: Name
plainTVName :: Name
kindedTVName :: Name
plainInvisTVName :: Name
kindedInvisTVName :: Name
specifiedSpecName :: Name
inferredSpecName :: Name
nominalRName :: Name
representationalRName :: Name
phantomRName :: Name
inferRName :: Name
starKName :: Name
constraintKName :: Name
noSigName :: Name
kindSigName :: Name
tyVarSigName :: Name
injectivityAnnName :: Name
cCallName :: Name
stdCallName :: Name
cApiCallName :: Name
primCallName :: Name
javaScriptCallName :: Name
unsafeName :: Name
safeName :: Name
interruptibleName :: Name
ruleVarName :: Name
typedRuleVarName :: Name
funDepName :: Name
tySynEqnName :: Name
valueAnnotationName :: Name
typeAnnotationName :: Name
moduleAnnotationName :: Name
derivClauseName :: Name
stockStrategyName :: Name
anyclassStrategyName :: Name
newtypeStrategyName :: Name
viaStrategyName :: Name
patQTyConName :: Name
expQTyConName :: Name
stmtTyConName :: Name
conTyConName :: Name
bangTypeTyConName :: Name
varBangTypeTyConName :: Name
typeQTyConName :: Name
decsQTyConName :: Name
ruleBndrTyConName :: Name
tySynEqnTyConName :: Name
roleTyConName :: Name
derivClauseTyConName :: Name
kindTyConName :: Name
tyVarBndrUnitTyConName :: Name
tyVarBndrSpecTyConName :: Name
derivStrategyTyConName :: Name
quoteExpName :: Name
quotePatName :: Name
quoteDecName :: Name
quoteTypeName :: Name
noInlineDataConName :: Name
inlineDataConName :: Name
inlinableDataConName :: Name
conLikeDataConName :: Name
funLikeDataConName :: Name
allPhasesDataConName :: Name
fromPhaseDataConName :: Name
beforePhaseDataConName :: Name
overlappableDataConName :: Name
overlappingDataConName :: Name
overlapsDataConName :: Name
incoherentDataConName :: Name
liftClassKey :: Unique
quoteClassKey :: Unique
expTyConKey :: Unique
matchTyConKey :: Unique
clauseTyConKey :: Unique
qTyConKey :: Unique
expQTyConKey :: Unique
patTyConKey :: Unique
stmtTyConKey :: Unique
conTyConKey :: Unique
typeQTyConKey :: Unique
typeTyConKey :: Unique
tyVarBndrUnitTyConKey :: Unique
tyVarBndrSpecTyConKey :: Unique
decTyConKey :: Unique
bangTypeTyConKey :: Unique
varBangTypeTyConKey :: Unique
fieldExpTyConKey :: Unique
fieldPatTyConKey :: Unique
nameTyConKey :: Unique
patQTyConKey :: Unique
funDepTyConKey :: Unique
predTyConKey :: Unique
predQTyConKey :: Unique
decsQTyConKey :: Unique
ruleBndrTyConKey :: Unique
tySynEqnTyConKey :: Unique
roleTyConKey :: Unique
codeTyConKey :: Unique
injAnnTyConKey :: Unique
kindTyConKey :: Unique
overlapTyConKey :: Unique
derivClauseTyConKey :: Unique
derivStrategyTyConKey :: Unique
decsTyConKey :: Unique
modNameTyConKey :: Unique
noInlineDataConKey :: Unique
inlineDataConKey :: Unique
inlinableDataConKey :: Unique
conLikeDataConKey :: Unique
funLikeDataConKey :: Unique
allPhasesDataConKey :: Unique
fromPhaseDataConKey :: Unique
beforePhaseDataConKey :: Unique
overlappableDataConKey :: Unique
overlappingDataConKey :: Unique
overlapsDataConKey :: Unique
incoherentDataConKey :: Unique
returnQIdKey :: Unique
bindQIdKey :: Unique
sequenceQIdKey :: Unique
liftIdKey :: Unique
newNameIdKey :: Unique
mkNameIdKey :: Unique
mkNameG_vIdKey :: Unique
mkNameG_dIdKey :: Unique
mkNameG_tcIdKey :: Unique
mkNameLIdKey :: Unique
mkNameSIdKey :: Unique
unTypeIdKey :: Unique
unTypeCodeIdKey :: Unique
unsafeCodeCoerceIdKey :: Unique
liftTypedIdKey :: Unique
mkModNameIdKey :: Unique
mkNameQIdKey :: Unique
charLIdKey :: Unique
stringLIdKey :: Unique
integerLIdKey :: Unique
intPrimLIdKey :: Unique
wordPrimLIdKey :: Unique
floatPrimLIdKey :: Unique
doublePrimLIdKey :: Unique
rationalLIdKey :: Unique
stringPrimLIdKey :: Unique
charPrimLIdKey :: Unique
liftStringIdKey :: Unique
litPIdKey :: Unique
varPIdKey :: Unique
tupPIdKey :: Unique
unboxedTupPIdKey :: Unique
unboxedSumPIdKey :: Unique
conPIdKey :: Unique
infixPIdKey :: Unique
tildePIdKey :: Unique
bangPIdKey :: Unique
asPIdKey :: Unique
wildPIdKey :: Unique
recPIdKey :: Unique
listPIdKey :: Unique
sigPIdKey :: Unique
viewPIdKey :: Unique
fieldPatIdKey :: Unique
matchIdKey :: Unique
clauseIdKey :: Unique
varEIdKey :: Unique
conEIdKey :: Unique
litEIdKey :: Unique
appEIdKey :: Unique
appTypeEIdKey :: Unique
infixEIdKey :: Unique
infixAppIdKey :: Unique
sectionLIdKey :: Unique
sectionRIdKey :: Unique
lamEIdKey :: Unique
lamCaseEIdKey :: Unique
lamCasesEIdKey :: Unique
tupEIdKey :: Unique
unboxedTupEIdKey :: Unique
unboxedSumEIdKey :: Unique
condEIdKey :: Unique
multiIfEIdKey :: Unique
letEIdKey :: Unique
caseEIdKey :: Unique
doEIdKey :: Unique
compEIdKey :: Unique
fromEIdKey :: Unique
fromThenEIdKey :: Unique
fromToEIdKey :: Unique
fromThenToEIdKey :: Unique
listEIdKey :: Unique
sigEIdKey :: Unique
recConEIdKey :: Unique
recUpdEIdKey :: Unique
staticEIdKey :: Unique
unboundVarEIdKey :: Unique
labelEIdKey :: Unique
implicitParamVarEIdKey :: Unique
mdoEIdKey :: Unique
getFieldEIdKey :: Unique
projectionEIdKey :: Unique
fieldExpIdKey :: Unique
guardedBIdKey :: Unique
normalBIdKey :: Unique
normalGEIdKey :: Unique
patGEIdKey :: Unique
bindSIdKey :: Unique
letSIdKey :: Unique
noBindSIdKey :: Unique
parSIdKey :: Unique
recSIdKey :: Unique
funDIdKey :: Unique
valDIdKey :: Unique
dataDIdKey :: Unique
newtypeDIdKey :: Unique
tySynDIdKey :: Unique
classDIdKey :: Unique
instanceWithOverlapDIdKey :: Unique
instanceDIdKey :: Unique
sigDIdKey :: Unique
forImpDIdKey :: Unique
pragInlDIdKey :: Unique
pragSpecDIdKey :: Unique
pragSpecInlDIdKey :: Unique
pragSpecInstDIdKey :: Unique
pragRuleDIdKey :: Unique
pragAnnDIdKey :: Unique
defaultSigDIdKey :: Unique
dataFamilyDIdKey :: Unique
openTypeFamilyDIdKey :: Unique
closedTypeFamilyDIdKey :: Unique
dataInstDIdKey :: Unique
newtypeInstDIdKey :: Unique
tySynInstDIdKey :: Unique
standaloneDerivWithStrategyDIdKey :: Unique
infixLDIdKey :: Unique
infixRDIdKey :: Unique
infixNDIdKey :: Unique
roleAnnotDIdKey :: Unique
patSynDIdKey :: Unique
patSynSigDIdKey :: Unique
pragCompleteDIdKey :: Unique
implicitParamBindDIdKey :: Unique
kiSigDIdKey :: Unique
defaultDIdKey :: Unique
pragOpaqueDIdKey :: Unique
typeDataDIdKey :: Unique
cxtIdKey :: Unique
noSourceUnpackednessKey :: Unique
sourceNoUnpackKey :: Unique
sourceUnpackKey :: Unique
noSourceStrictnessKey :: Unique
sourceLazyKey :: Unique
sourceStrictKey :: Unique
normalCIdKey :: Unique
recCIdKey :: Unique
infixCIdKey :: Unique
forallCIdKey :: Unique
gadtCIdKey :: Unique
recGadtCIdKey :: Unique
bangIdKey :: Unique
bangTKey :: Unique
varBangTKey :: Unique
unidirPatSynIdKey :: Unique
implBidirPatSynIdKey :: Unique
explBidirPatSynIdKey :: Unique
prefixPatSynIdKey :: Unique
infixPatSynIdKey :: Unique
recordPatSynIdKey :: Unique
forallTIdKey :: Unique
forallVisTIdKey :: Unique
varTIdKey :: Unique
conTIdKey :: Unique
tupleTIdKey :: Unique
unboxedTupleTIdKey :: Unique
unboxedSumTIdKey :: Unique
arrowTIdKey :: Unique
listTIdKey :: Unique
appTIdKey :: Unique
appKindTIdKey :: Unique
sigTIdKey :: Unique
equalityTIdKey :: Unique
litTIdKey :: Unique
promotedTIdKey :: Unique
promotedTupleTIdKey :: Unique
promotedNilTIdKey :: Unique
promotedConsTIdKey :: Unique
wildCardTIdKey :: Unique
implicitParamTIdKey :: Unique
infixTIdKey :: Unique
numTyLitIdKey :: Unique
strTyLitIdKey :: Unique
charTyLitIdKey :: Unique
plainTVIdKey :: Unique
kindedTVIdKey :: Unique
plainInvisTVIdKey :: Unique
kindedInvisTVIdKey :: Unique
nominalRIdKey :: Unique
representationalRIdKey :: Unique
phantomRIdKey :: Unique
inferRIdKey :: Unique
starKIdKey :: Unique
constraintKIdKey :: Unique
noSigIdKey :: Unique
kindSigIdKey :: Unique
tyVarSigIdKey :: Unique
injectivityAnnIdKey :: Unique
cCallIdKey :: Unique
stdCallIdKey :: Unique
cApiCallIdKey :: Unique
primCallIdKey :: Unique
javaScriptCallIdKey :: Unique
unsafeIdKey :: Unique
safeIdKey :: Unique
interruptibleIdKey :: Unique
funDepIdKey :: Unique
mulArrowTIdKey :: Unique
tySynEqnIdKey :: Unique
quoteExpKey :: Unique
quotePatKey :: Unique
quoteDecKey :: Unique
quoteTypeKey :: Unique
ruleVarIdKey :: Unique
typedRuleVarIdKey :: Unique
valueAnnotationIdKey :: Unique
typeAnnotationIdKey :: Unique
moduleAnnotationIdKey :: Unique
derivClauseIdKey :: Unique
stockStrategyIdKey :: Unique
anyclassStrategyIdKey :: Unique
newtypeStrategyIdKey :: Unique
viaStrategyIdKey :: Unique
specifiedSpecKey :: Unique
inferredSpecKey :: Unique
lift_RDR :: RdrName
liftTyped_RDR :: RdrName
mkNameG_dRDR :: RdrName
mkNameG_vRDR :: RdrName
unsafeCodeCoerce_RDR :: RdrName
conE_RDR :: RdrName
litE_RDR :: RdrName
appE_RDR :: RdrName
infixApp_RDR :: RdrName
stringL_RDR :: RdrName
intPrimL_RDR :: RdrName
wordPrimL_RDR :: RdrName
floatPrimL_RDR :: RdrName
doublePrimL_RDR :: RdrName
stringPrimL_RDR :: RdrName
charPrimL_RDR :: RdrName


-- | This module defines TyCons that can't be expressed in Haskell. They
--   are all, therefore, wired-in TyCons. C.f module
--   <a>GHC.Builtin.Types</a>
module GHC.Builtin.Types.Prim
mkTemplateKindVar :: Kind -> TyVar
mkTemplateKindVars :: [Kind] -> [TyVar]
mkTemplateTyVars :: [Kind] -> [TyVar]
mkTemplateTyVarsFrom :: Int -> [Kind] -> [TyVar]
mkTemplateKiTyVars :: [Kind] -> ([Kind] -> [Kind]) -> [TyVar]
mkTemplateKiTyVar :: Kind -> (Kind -> [Kind]) -> [TyVar]
mkTemplateTyConBinders :: [Kind] -> ([Kind] -> [Kind]) -> [TyConBinder]
mkTemplateKindTyConBinders :: [Kind] -> [TyConBinder]
mkTemplateAnonTyConBinders :: [Kind] -> [TyConBinder]
alphaTyVars :: [TyVar]
alphaTyVar :: TyVar
betaTyVar :: TyVar
gammaTyVar :: TyVar
deltaTyVar :: TyVar
alphaTyVarSpec :: TyVarBinder
betaTyVarSpec :: TyVarBinder
gammaTyVarSpec :: TyVarBinder
deltaTyVarSpec :: TyVarBinder
alphaTys :: [Type]
alphaTy :: Type
betaTy :: Type
gammaTy :: Type
deltaTy :: Type
alphaTyVarsUnliftedRep :: [TyVar]
alphaTyVarUnliftedRep :: TyVar
alphaTysUnliftedRep :: [Type]
alphaTyUnliftedRep :: Type
runtimeRep1TyVar :: TyVar
runtimeRep2TyVar :: TyVar
runtimeRep3TyVar :: TyVar
runtimeRep1TyVarInf :: TyVarBinder
runtimeRep2TyVarInf :: TyVarBinder
runtimeRep1Ty :: RuntimeRepType
runtimeRep2Ty :: RuntimeRepType
runtimeRep3Ty :: RuntimeRepType
levity1TyVar :: TyVar
levity2TyVar :: TyVar
levity1TyVarInf :: TyVarBinder
levity2TyVarInf :: TyVarBinder
levity1Ty :: Type
levity2Ty :: Type
alphaConstraintTyVar :: TyVar
alphaConstraintTy :: Type
openAlphaTyVar :: TyVar
openBetaTyVar :: TyVar
openGammaTyVar :: TyVar
openAlphaTyVarSpec :: TyVarBinder
openBetaTyVarSpec :: TyVarBinder
openGammaTyVarSpec :: TyVarBinder
openAlphaTy :: Type
openBetaTy :: Type
openGammaTy :: Type
levPolyAlphaTyVar :: TyVar
levPolyBetaTyVar :: TyVar
levPolyAlphaTyVarSpec :: TyVarBinder
levPolyBetaTyVarSpec :: TyVarBinder
levPolyAlphaTy :: Type
levPolyBetaTy :: Type
multiplicityTyVar1 :: TyVar
multiplicityTyVar2 :: TyVar
tYPETyCon :: TyCon
tYPETyConName :: Name
tYPEKind :: Type
cONSTRAINTTyCon :: TyCon
cONSTRAINTTyConName :: Name
cONSTRAINTKind :: Type
funTyFlagTyCon :: FunTyFlag -> TyCon
isArrowTyCon :: TyCon -> Bool

-- | The <tt>FUN</tt> type constructor.
--   
--   <pre>
--   FUN :: forall (m :: Multiplicity) -&gt;
--          forall {rep1 :: RuntimeRep} {rep2 :: RuntimeRep}.
--          TYPE rep1 -&gt; TYPE rep2 -&gt; Type
--   </pre>
--   
--   The runtime representations quantification is left inferred. This
--   means they cannot be specified with <tt>-XTypeApplications</tt>.
--   
--   This is a deliberate choice to allow future extensions to the function
--   arrow.
fUNTyCon :: TyCon
fUNTyConName :: Name
ctArrowTyCon :: TyCon
ctArrowTyConName :: Name
ccArrowTyCon :: TyCon
ccArrowTyConName :: Name
tcArrowTyCon :: TyCon
tcArrowTyConName :: Name

-- | Primitive <a>TyCon</a>s that are defined in GHC.Prim but not
--   "exposed". See Note [Unexposed TyCons]
unexposedPrimTyCons :: [TyCon]

-- | Primitive <a>TyCon</a>s that are defined in, and exported from,
--   GHC.Prim.
exposedPrimTyCons :: [TyCon]
primTyCons :: [TyCon]
charPrimTyCon :: TyCon
charPrimTy :: Type
charPrimTyConName :: Name
intPrimTyCon :: TyCon
intPrimTy :: Type
intPrimTyConName :: Name
wordPrimTyCon :: TyCon
wordPrimTy :: Type
wordPrimTyConName :: Name
addrPrimTyCon :: TyCon
addrPrimTy :: Type
addrPrimTyConName :: Name
floatPrimTyCon :: TyCon
floatPrimTy :: Type
floatPrimTyConName :: Name
doublePrimTyCon :: TyCon
doublePrimTy :: Type
doublePrimTyConName :: Name
statePrimTyCon :: TyCon
mkStatePrimTy :: Type -> Type
realWorldTyCon :: TyCon
realWorldTy :: Type
realWorldStatePrimTy :: Type
proxyPrimTyCon :: TyCon
mkProxyPrimTy :: Type -> Type -> Type
arrayPrimTyCon :: TyCon
mkArrayPrimTy :: Type -> Type
byteArrayPrimTyCon :: TyCon
byteArrayPrimTy :: Type
smallArrayPrimTyCon :: TyCon
mkSmallArrayPrimTy :: Type -> Type
mutableArrayPrimTyCon :: TyCon
mkMutableArrayPrimTy :: Type -> Type -> Type
mutableByteArrayPrimTyCon :: TyCon
mkMutableByteArrayPrimTy :: Type -> Type
smallMutableArrayPrimTyCon :: TyCon
mkSmallMutableArrayPrimTy :: Type -> Type -> Type
mutVarPrimTyCon :: TyCon
mkMutVarPrimTy :: Type -> Type -> Type
mVarPrimTyCon :: TyCon
mkMVarPrimTy :: Type -> Type -> Type
ioPortPrimTyCon :: TyCon
mkIOPortPrimTy :: Type -> Type -> Type
tVarPrimTyCon :: TyCon
mkTVarPrimTy :: Type -> Type -> Type
stablePtrPrimTyCon :: TyCon
mkStablePtrPrimTy :: Type -> Type
stableNamePrimTyCon :: TyCon
mkStableNamePrimTy :: Type -> Type
compactPrimTyCon :: TyCon
compactPrimTy :: Type
bcoPrimTyCon :: TyCon
bcoPrimTy :: Type
weakPrimTyCon :: TyCon
mkWeakPrimTy :: Type -> Type
threadIdPrimTyCon :: TyCon
threadIdPrimTy :: Type
stackSnapshotPrimTyCon :: TyCon
stackSnapshotPrimTy :: Type
promptTagPrimTyCon :: TyCon
mkPromptTagPrimTy :: Type -> Type
int8PrimTyCon :: TyCon
int8PrimTy :: Type
int8PrimTyConName :: Name
word8PrimTyCon :: TyCon
word8PrimTy :: Type
word8PrimTyConName :: Name
int16PrimTyCon :: TyCon
int16PrimTy :: Type
int16PrimTyConName :: Name
word16PrimTyCon :: TyCon
word16PrimTy :: Type
word16PrimTyConName :: Name
int32PrimTyCon :: TyCon
int32PrimTy :: Type
int32PrimTyConName :: Name
word32PrimTyCon :: TyCon
word32PrimTy :: Type
word32PrimTyConName :: Name
int64PrimTyCon :: TyCon
int64PrimTy :: Type
int64PrimTyConName :: Name
word64PrimTyCon :: TyCon
word64PrimTy :: Type
word64PrimTyConName :: Name
eqPrimTyCon :: TyCon
eqReprPrimTyCon :: TyCon
eqPhantPrimTyCon :: TyCon

-- | Given a Role, what TyCon is the type of equality predicates at that
--   role?
equalityTyCon :: Role -> TyCon
int8X16PrimTy :: Type
int8X16PrimTyCon :: TyCon
int16X8PrimTy :: Type
int16X8PrimTyCon :: TyCon
int32X4PrimTy :: Type
int32X4PrimTyCon :: TyCon
int64X2PrimTy :: Type
int64X2PrimTyCon :: TyCon
int8X32PrimTy :: Type
int8X32PrimTyCon :: TyCon
int16X16PrimTy :: Type
int16X16PrimTyCon :: TyCon
int32X8PrimTy :: Type
int32X8PrimTyCon :: TyCon
int64X4PrimTy :: Type
int64X4PrimTyCon :: TyCon
int8X64PrimTy :: Type
int8X64PrimTyCon :: TyCon
int16X32PrimTy :: Type
int16X32PrimTyCon :: TyCon
int32X16PrimTy :: Type
int32X16PrimTyCon :: TyCon
int64X8PrimTy :: Type
int64X8PrimTyCon :: TyCon
word8X16PrimTy :: Type
word8X16PrimTyCon :: TyCon
word16X8PrimTy :: Type
word16X8PrimTyCon :: TyCon
word32X4PrimTy :: Type
word32X4PrimTyCon :: TyCon
word64X2PrimTy :: Type
word64X2PrimTyCon :: TyCon
word8X32PrimTy :: Type
word8X32PrimTyCon :: TyCon
word16X16PrimTy :: Type
word16X16PrimTyCon :: TyCon
word32X8PrimTy :: Type
word32X8PrimTyCon :: TyCon
word64X4PrimTy :: Type
word64X4PrimTyCon :: TyCon
word8X64PrimTy :: Type
word8X64PrimTyCon :: TyCon
word16X32PrimTy :: Type
word16X32PrimTyCon :: TyCon
word32X16PrimTy :: Type
word32X16PrimTyCon :: TyCon
word64X8PrimTy :: Type
word64X8PrimTyCon :: TyCon
floatX4PrimTy :: Type
floatX4PrimTyCon :: TyCon
doubleX2PrimTy :: Type
doubleX2PrimTyCon :: TyCon
floatX8PrimTy :: Type
floatX8PrimTyCon :: TyCon
doubleX4PrimTy :: Type
doubleX4PrimTyCon :: TyCon
floatX16PrimTy :: Type
floatX16PrimTyCon :: TyCon
doubleX8PrimTy :: Type
doubleX8PrimTyCon :: TyCon

module GHC.Core.TyCo.FVs
shallowTyCoVarsOfType :: Type -> TyCoVarSet
shallowTyCoVarsOfTypes :: [Type] -> TyCoVarSet
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet

-- | Returns free variables of types, including kind variables as a
--   deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
tyCoVarsOfTypesDSet :: [Type] -> DTyCoVarSet
tyCoFVsBndr :: ForAllTyBinder -> FV -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in
--   deterministic order. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeList :: Type -> [TyCoVar]
tyCoFVsOfTypes :: [Type] -> FV

-- | Returns free variables of types, including kind variables as a
--   deterministically ordered list. For type synonyms it does <i>not</i>
--   expand the synonym.
tyCoVarsOfTypesList :: [Type] -> [TyCoVar]
deepTcvFolder :: TyCoFolder TyCoVarSet (Endo TyCoVarSet)

-- | Returns free variables of types, including kind variables as a
--   non-deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
shallowTyCoVarsOfTyVarEnv :: TyVarEnv Type -> TyCoVarSet
shallowTyCoVarsOfCoVarEnv :: CoVarEnv Coercion -> TyCoVarSet
shallowTyCoVarsOfCo :: Coercion -> TyCoVarSet
shallowTyCoVarsOfCos :: [Coercion] -> TyCoVarSet
tyCoVarsOfCo :: Coercion -> TyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet
tyCoVarsOfMCo :: MCoercion -> TyCoVarSet
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> CoVarSet
coVarsOfCo :: Coercion -> CoVarSet
coVarsOfCos :: [Coercion] -> CoVarSet

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV
tyCoVarsOfCoList :: Coercion -> [TyCoVar]

-- | Given a covar and a coercion, returns True if covar is almost devoid
--   in the coercion. That is, covar can only appear in Refl and GRefl. See
--   last wrinkle in Note [Unused coercion variable in ForAllCo] in
--   <a>GHC.Core.Coercion</a>
almostDevoidCoVarOfCo :: CoVar -> Coercion -> Bool

-- | Returns the free variables of a <a>Type</a> that are in injective
--   positions. Specifically, it finds the free variables while:
--   
--   <ul>
--   <li>Expanding type synonyms</li>
--   <li>Ignoring the coercion in <tt>(ty |&gt; co)</tt></li>
--   <li>Ignoring the non-injective fields of a <a>TyConApp</a></li>
--   </ul>
--   
--   For example, if <tt>F</tt> is a non-injective type family, then:
--   
--   <pre>
--   injectiveTyVarsOf( Either c (Maybe (a, F b c)) ) = {a,c}
--   </pre>
--   
--   If <tt><a>injectiveVarsOfType</a> ty = itvs</tt>, then knowing
--   <tt>ty</tt> fixes <tt>itvs</tt>. More formally, if <tt>a</tt> is in
--   <tt><a>injectiveVarsOfType</a> ty</tt> and <tt>S1(ty) ~ S2(ty)</tt>,
--   then <tt>S1(a) ~ S2(a)</tt>, where <tt>S1</tt> and <tt>S2</tt> are
--   arbitrary substitutions.
--   
--   See <tt>Note [When does a tycon application need an explicit kind
--   signature?]</tt>.
injectiveVarsOfType :: Bool -> Type -> FV

-- | Returns the free variables of a <a>Type</a> that are in injective
--   positions. Specifically, it finds the free variables while:
--   
--   <ul>
--   <li>Expanding type synonyms</li>
--   <li>Ignoring the coercion in <tt>(ty |&gt; co)</tt></li>
--   <li>Ignoring the non-injective fields of a <a>TyConApp</a></li>
--   </ul>
--   
--   See <tt>Note [When does a tycon application need an explicit kind
--   signature?]</tt>.
injectiveVarsOfTypes :: Bool -> [Type] -> FV

-- | Returns the set of variables that are used invisibly anywhere within
--   the given type. A variable will be included even if it is used both
--   visibly and invisibly. An invisible use site includes: * In the kind
--   of a variable * In the kind of a bound variable in a forall * In a
--   coercion * In a Specified or Inferred argument to a function See Note
--   [VarBndrs, ForAllTyBinders, TyConBinders, and visibility] in
--   <a>GHC.Core.TyCo.Rep</a>
invisibleVarsOfType :: Type -> FV

-- | Like <a>invisibleVarsOfType</a>, but for many types.
invisibleVarsOfTypes :: [Type] -> FV
anyFreeVarsOfType :: (TyCoVar -> Bool) -> Type -> Bool
anyFreeVarsOfTypes :: (TyCoVar -> Bool) -> [Type] -> Bool
anyFreeVarsOfCo :: (TyCoVar -> Bool) -> Coercion -> Bool
noFreeVarsOfType :: Type -> Bool
noFreeVarsOfTypes :: [Type] -> Bool
noFreeVarsOfCo :: Coercion -> Bool

-- | All type constructors occurring in the type; looking through type
--   synonyms, but not newtypes. When it finds a Class, it returns the
--   class TyCon.
tyConsOfType :: Type -> UniqSet TyCon
tyConsOfTypes :: [Type] -> UniqSet TyCon
visVarsOfTypes :: [Type] -> Pair TyCoVarSet

-- | Retrieve the free variables in this type, splitting them based on
--   whether they are used visibly or invisibly. Invisible ones come first.
visVarsOfType :: Type -> Pair TyCoVarSet
occCheckExpand :: [Var] -> Type -> Maybe Type

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | Get the free vars of a type in scoped order
tyCoVarsOfTypeWellScoped :: Type -> [TyVar]

-- | Get the free vars of types in scoped order
tyCoVarsOfTypesWellScoped :: [Type] -> [TyVar]

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministically ordered list.
closeOverKindsList :: [TyVar] -> [TyVar]
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   Endo f &lt;&gt; Endo g == Endo (f . g)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo (*3) &lt;&gt; Endo (+1)
--   
--   &gt;&gt;&gt; appEndo computation 1
--   6
--   </pre>
newtype () => Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a
runTyCoVars :: Endo TyCoVarSet -> TyCoVarSet


-- | Tidying types and coercions for printing in error messages.
module GHC.Core.TyCo.Tidy

-- | Tidy a Type
--   
--   See Note [Strictness in tidyType and friends]
tidyType :: TidyEnv -> Type -> Type

-- | Tidy a list of Types
--   
--   See Note [Strictness in tidyType and friends]
tidyTypes :: TidyEnv -> [Type] -> [Type]
tidyOpenType :: TidyEnv -> Type -> (TidyEnv, Type)

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypes :: TidyEnv -> [Type] -> (TidyEnv, [Type])
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv
avoidNameClashes :: [TyCoVar] -> TidyEnv -> TidyEnv

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a>
tidyOpenTyCoVar :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)
tidyOpenTyCoVars :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type

-- | Tidy a Coercion
--   
--   See Note [Strictness in tidyType and friends]
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]
tidyForAllTyBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyForAllTyBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])


-- | Substitution into types and coercions.
module GHC.Core.TyCo.Subst

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion

-- | A substitution of <tt>Expr</tt>s for non-coercion <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr
emptyIdSubstEnv :: IdSubstEnv
emptyTvSubstEnv :: TvSubstEnv
emptyCvSubstEnv :: CvSubstEnv

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition. This function leaves IdSubstEnv
--   untouched because IdSubstEnv is not used during substitution for
--   types.
composeTCvSubst :: Subst -> Subst -> Subst
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst

-- | Checks whether the tyvar and covar environments are empty. This
--   function should be used over <a>isEmptySubst</a> when substituting for
--   types, because types currently do not contain expressions; we can
--   safely disregard the expression environment when deciding whether to
--   skip a substitution. Using <a>isEmptyTCvSubst</a> gives us a
--   non-trivial performance boost (up to 70% less allocation for T18223)
isEmptyTCvSubst :: Subst -> Bool
isEmptySubst :: Subst -> Bool
mkSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> IdSubstEnv -> Subst

-- | Make a TCvSubst with specified tyvar subst and empty covar subst
mkTvSubst :: InScopeSet -> TvSubstEnv -> Subst

-- | Make a TCvSubst with specified covar subst and empty tyvar subst
mkCvSubst :: InScopeSet -> CvSubstEnv -> Subst
mkIdSubst :: InScopeSet -> IdSubstEnv -> Subst
getTvSubstEnv :: Subst -> TvSubstEnv
getIdSubstEnv :: Subst -> IdSubstEnv
getCvSubstEnv :: Subst -> CvSubstEnv

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet
setInScope :: Subst -> InScopeSet -> Subst

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getSubstRangeTyCoFVs :: Subst -> VarSet
isInScope :: Var -> Subst -> Bool
elemSubst :: Var -> Subst -> Bool
notElemSubst :: Var -> Subst -> Bool

-- | Remove all substitutions that might have been built up while
--   preserving the in-scope set originally called zapSubstEnv
zapSubst :: Subst -> Subst

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeSet :: Subst -> VarSet -> Subst
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst
extendTCvSubstWithClone :: Subst -> TyCoVar -> TyCoVar -> Subst

-- | Add a substitution from a <a>CoVar</a> to a <a>Coercion</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set satisfies Note
--   [The substitution invariant] after extending the substitution like
--   this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst
extendCvSubstWithClone :: Subst -> CoVar -> CoVar -> Subst

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that Note [The substitution invariant]
--   holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst
extendTvSubstBinderAndInScope :: Subst -> PiTyBinder -> Type -> Subst
extendTvSubstWithClone :: Subst -> TyVar -> TyVar -> Subst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
extendTCvSubstList :: Subst -> [Var] -> [Type] -> Subst
unionSubst :: Subst -> Subst -> Subst

-- | The InScopeSet is just a thunk so with a bit of luck it'll never be
--   evaluated
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv

-- | Generates the in-scope set for the <a>Subst</a> from the types in the
--   incoming environment. No CoVars or Ids, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> Subst

-- | Generates the in-scope set for the <a>Subst</a> from the types in the
--   incoming environment. No TyVars, please!
zipCvSubst :: HasDebugCallStack => [CoVar] -> [Coercion] -> Subst
zipTCvSubst :: HasDebugCallStack => [TyCoVar] -> [Type] -> Subst

-- | Generates the in-scope set for the <tt>TCvSubst</tt> from the types in
--   the incoming environment. No CoVars, please! The InScopeSet is just a
--   thunk so with a bit of luck it'll never be evaluated
mkTvSubstPrs :: [(TyVar, Type)] -> Subst

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasDebugCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Substitute covars within a type
substTyWithCoVars :: [CoVar] -> [Coercion] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: [TyVar] -> [Type] -> [Type] -> [Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTysWithCoVars :: [CoVar] -> [Coercion] -> [Type] -> [Type]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasDebugCallStack => [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasDebugCallStack => Subst -> Type -> Type

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: Subst -> Type -> Type
substScaledTy :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: Subst -> [Type] -> [Type]
substScaledTysUnchecked :: Subst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: Subst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type
substScaledTyUnchecked :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: Subst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute tyvars within a type using a known <a>InScopeSet</a>.
--   Pre-condition: the <tt>in_scope</tt> set should satisfy Note [The
--   substitution invariant]; specifically it should include the free vars
--   of <tt>tys</tt>, and of <tt>ty</tt> minus the domain of the subst.
substTyWithInScope :: InScopeSet -> [TyVar] -> [Type] -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasDebugCallStack => Subst -> [Type] -> [Type]
substScaledTys :: HasDebugCallStack => Subst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasDebugCallStack => Subst -> ThetaType -> ThetaType
lookupTyVar :: Subst -> TyVar -> Maybe Type

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasDebugCallStack => Subst -> [Coercion] -> [Coercion]
substCoVar :: Subst -> CoVar -> Coercion
substCoVars :: Subst -> [CoVar] -> [Coercion]
lookupCoVar :: Subst -> Var -> Maybe Coercion
cloneTyVarBndr :: Subst -> TyVar -> Unique -> (Subst, TyVar)
cloneTyVarBndrs :: Subst -> [TyVar] -> UniqSupply -> (Subst, [TyVar])
substVarBndr :: HasDebugCallStack => Subst -> TyCoVar -> (Subst, TyCoVar)
substVarBndrs :: HasDebugCallStack => Subst -> [TyCoVar] -> (Subst, [TyCoVar])
substTyVarBndr :: HasDebugCallStack => Subst -> TyVar -> (Subst, TyVar)
substTyVarBndrs :: HasDebugCallStack => Subst -> [TyVar] -> (Subst, [TyVar])
substCoVarBndr :: HasDebugCallStack => Subst -> CoVar -> (Subst, CoVar)
substTyVar :: Subst -> TyVar -> Type
substTyVars :: Subst -> [TyVar] -> [Type]
substTyVarToTyVar :: HasDebugCallStack => Subst -> TyVar -> TyVar
substTyCoVars :: Subst -> [TyCoVar] -> [Type]
substTyCoBndr :: Subst -> PiTyBinder -> (Subst, PiTyBinder)
substForAllCoBndr :: Subst -> TyCoVar -> KindCoercion -> (Subst, TyCoVar, Coercion)
substVarBndrUsing :: (Subst -> Type -> Type) -> Subst -> TyCoVar -> (Subst, TyCoVar)
substForAllCoBndrUsing :: Bool -> (Coercion -> Coercion) -> Subst -> TyCoVar -> KindCoercion -> (Subst, TyCoVar, KindCoercion)

-- | This checks if the substitution satisfies the invariant from Note [The
--   substitution invariant].
checkValidSubst :: HasDebugCallStack => Subst -> [Type] -> [Coercion] -> a -> a

-- | When calling <a>substTy</a> it should be the case that the in-scope
--   set in the substitution is a superset of the free vars of the range of
--   the substitution. See also Note [The substitution invariant]. TODO:
--   take into account ids and rename as isValidSubst
isValidTCvSubst :: Subst -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Core.TyCo.Subst.Subst


-- | Main functions for manipulating types and type-related things
module GHC.Core.Type
data Type

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Specified :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag

-- | Whether an <a>Invisible</a> argument may appear in source Haskell.
data Specificity

-- | the argument may not appear in source Haskell, it is only inferred.
InferredSpec :: Specificity

-- | the argument may appear in source Haskell, but isn't required.
SpecifiedSpec :: Specificity

-- | The key representation of types within the compiler
type KindOrType = Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]
type FRRType = Type

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Type or kind Variable
type TyVar = Var

-- | Is this a type-level (i.e., computationally irrelevant, thus erasable)
--   variable? Satisfies <tt>isTyVar = not . isId</tt>.
isTyVar :: Var -> Bool

-- | Type or Coercion Variable
type TyCoVar = Id

-- | A <a>PiTyBinder</a> represents an argument to a function. PiTyBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [PiTyBinders]
data PiTyBinder

-- | Variable Binder
--   
--   A <a>ForAllTyBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in
--   <a>GHC.Core.TyCo.Rep</a>, because it's used in
--   GHC.Core.DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type ForAllTyBinder = VarBndr TyCoVar ForAllTyFlag
type TyVarBinder = VarBndr TyVar ForAllTyFlag

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied ty = ty

-- | Type synonym used for types of kind RuntimeRep.
type RuntimeRepType = Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: HasDebugCallStack => Type -> TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>
getTyVar_maybe :: Type -> Maybe TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>, without
--   any expansion
repGetTyVar_maybe :: Type -> Maybe TyVar

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind ty
getCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)
tyVarKind :: TyVar -> Kind

-- | The type or kind of the <a>Var</a> in question
varType :: Var -> Kind

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type
mkAppTys :: Type -> [Type] -> Type

-- | Attempts to take a type application apart, as in
--   <a>splitAppTy_maybe</a>, and panics if this is not possible
splitAppTy :: Type -> (Type, Type)

-- | Recursively splits a type as far as is possible, leaving a residual
--   type being applied to and the type arguments applied to it. Never
--   fails, even if that means returning an empty list of type
--   applications.
splitAppTys :: Type -> (Type, [Type])

-- | Like <a>splitAppTys</a>, but doesn't look through type synonyms
splitAppTysNoView :: HasDebugCallStack => Type -> (Type, [Type])

-- | Attempt to take a type application apart, whether it is a function,
--   type constructor, or plain type application. Note that type family
--   applications are NEVER unsaturated by this!
splitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Does the AppTy split as in <a>splitAppTy_maybe</a>, but assumes that
--   any coreView stuff is already done
splitAppTyNoView_maybe :: HasDebugCallStack => Type -> Maybe (Type, Type)

-- | Just like splitAppTyNoView_maybe, but does not split (c =&gt; t) See
--   Note [Decomposing fat arrow c=&gt;t]
tcSplitAppTyNoView_maybe :: Type -> Maybe (Type, Type)
mkFunTy :: HasDebugCallStack => FunTyFlag -> Mult -> Type -> Type -> Type
infixr 3 `mkFunTy`
mkVisFunTy :: HasDebugCallStack => Mult -> Type -> Type -> Type

-- | Make nested arrow types | Special, common, case: Arrow type with mult
--   Many
mkVisFunTyMany :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
mkVisFunTysMany :: [Type] -> Type -> Type
mkScaledFunTys :: HasDebugCallStack => [Scaled Type] -> Type -> Type
mkInvisFunTy :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkInvisFunTy`
mkInvisFunTys :: HasDebugCallStack => [Type] -> Type -> Type
tcMkVisFunTy :: Mult -> Type -> Type -> Type
tcMkScaledFunTys :: [Scaled Type] -> Type -> Type
tcMkInvisFunTy :: TypeOrConstraint -> Type -> Type -> Type

-- | Attempts to extract the multiplicity, argument and result types from a
--   type, and panics if that is not possible. See also
--   <a>splitFunTy_maybe</a>
splitFunTy :: Type -> (Mult, Type, Type)

-- | Attempts to extract the multiplicity, argument and result types from a
--   type
splitFunTy_maybe :: Type -> Maybe (FunTyFlag, Mult, Type, Type)
splitFunTys :: Type -> ([Scaled Type], Type)

-- | Extract the function result type and panic if that is not possible
funResultTy :: HasDebugCallStack => Type -> Type

-- | Just like <a>piResultTys</a> but for a single argument Try not to
--   iterate <a>piResultTy</a>, because it's inefficient to substitute one
--   variable at a time; instead use 'piResultTys"
--   
--   Extract the function argument type and panic if that is not possible
funArgTy :: Type -> Type

-- | Given the components of a FunTy figure out the corresponding TyConApp.
funTyConAppTy_maybe :: FunTyFlag -> Type -> Type -> Type -> Maybe (TyCon, [Type])
funTyFlagTyCon :: FunTyFlag -> TyCon

-- | Return Just if this TyConApp should be represented as a FunTy
tyConAppFunTy_maybe :: HasDebugCallStack => TyCon -> [Type] -> Maybe Type

-- | Return Just if this TyConAppCo should be represented as a FunCo
tyConAppFunCo_maybe :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Maybe Coercion

-- | This one works out the FunTyFlag from the argument type See
--   GHC.Types.Var Note [FunTyFlag]
mkFunctionType :: HasDebugCallStack => Mult -> Type -> Type -> Type

-- | Like mkFunctionType, compute the FunTyFlag from the arguments
mkScaledFunctionTys :: [Scaled Type] -> Type -> Type

-- | See GHC.Types.Var Note [FunTyFlag]
chooseFunTyFlag :: HasDebugCallStack => Type -> Type -> FunTyFlag

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | (mkTyConTy tc) returns (TyConApp tc []) but arranges to share that
--   TyConApp among all calls See Note [Sharing nullary TyConApps] So it's
--   just an alias for tyConNullaryTy!
mkTyConTy :: TyCon -> Type

-- | The same as <tt>fst . splitTyConApp</tt> We can short-cut the FunTy
--   case
tyConAppTyCon_maybe :: Type -> Maybe TyCon

-- | Retrieve the tycon heading this type, if there is one. Does <i>not</i>
--   look through synonyms.
tyConAppTyConPicky_maybe :: Type -> Maybe TyCon

-- | The same as <tt>snd . splitTyConApp</tt>
tyConAppArgs_maybe :: Type -> Maybe [Type]
tyConAppTyCon :: HasDebugCallStack => Type -> TyCon
tyConAppArgs :: HasCallStack => Type -> [Type]

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor
splitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])
splitTyConAppNoView_maybe :: Type -> Maybe (TyCon, [Type])

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor. Panics if
--   that is not possible. See also <a>splitTyConApp_maybe</a>
splitTyConApp :: Type -> (TyCon, [Type])
tcSplitTyConApp :: Type -> (TyCon, [Type])

-- | tcSplitTyConApp_maybe splits a type constructor application into its
--   type constructor and applied types.
--   
--   Differs from splitTyConApp_maybe in that it does *not* split types
--   headed with (=&gt;), as that's not a TyCon in the type-checker.
--   
--   Note that this may fail (in funTyConAppTy_maybe) in the case of a
--   <a>FunTy</a> with an argument of unknown kind <a>FunTy</a> (e.g.
--   `FunTy (a :: k) Int`, since the kind of <tt>a</tt> isn't of the form
--   `TYPE rep`. This isn't usually a problem but may be temporarily the
--   cas during canonicalization: see Note [Decomposing FunTy] in
--   GHC.Tc.Solver.Canonical and Note [The Purely Kinded Type Invariant
--   (PKTI)] in GHC.Tc.Gen.HsType, Wrinkle around FunTy
--   
--   Consequently, you may need to zonk your type before using this
--   function.
tcSplitTyConApp_maybe :: HasCallStack => Type -> Maybe (TyCon, [Type])

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: ForAllTyBinder -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [ForAllTyBinder] -> Type -> Type

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Inferred</a>, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | Like <a>mkForAllTy</a>, but assumes the variable is dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type

-- | Like mkForAllTys, but assumes all variables are dependent and visible
mkVisForAllTys :: [TyVar] -> Type -> Type

-- | Make a dependent forall over an <a>Inferred</a> variable
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTy</a>, but tv should be a tyvar
mkInfForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInfForAllTys :: [TyVar] -> Type -> Type

-- | Take a ForAllTy apart, returning the list of tycovars and the result
--   type. This always succeeds, even if it returns only an empty list.
--   Note that the result type returned may have free variables that were
--   bound by a forall.
splitForAllTyCoVars :: Type -> ([TyCoVar], Type)

-- | Like <a>splitForAllTyCoVars</a>, but split only for tyvars. This
--   always succeeds, even if it returns only an empty list. Note that the
--   result type returned may have free variables that were bound by a
--   forall.
splitForAllTyVars :: Type -> ([TyVar], Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Required</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with <tt>()</tt>.
splitForAllReqTyBinders :: Type -> ([ReqTyBinder], Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with its <a>Specificity</a>.
splitForAllInvisTyBinders :: Type -> ([InvisTyBinder], Type)

-- | Take a ForAllTy apart, returning the binders and result type
splitForAllForAllTyBinders :: Type -> ([ForAllTyBinder], Type)

-- | Attempts to take a forall type apart, but only if it's a proper
--   forall, with a named binder
splitForAllTyCoVar_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Take a forall type apart, or panics if that is not possible.
splitForAllTyCoVar :: Type -> (TyCoVar, Type)

-- | Like <a>splitForAllTyCoVar_maybe</a>, but only returns Just if it is a
--   tyvar binder.
splitForAllTyVar_maybe :: Type -> Maybe (TyVar, Type)

-- | Like <a>splitForAllTyCoVar_maybe</a>, but only returns Just if it is a
--   covar binder.
splitForAllCoVar_maybe :: Type -> Maybe (CoVar, Type)

-- | Attempts to take a forall type apart; works with proper foralls and
--   functions
splitPiTy_maybe :: Type -> Maybe (PiTyBinder, Type)

-- | Takes a forall type apart, or panics
splitPiTy :: Type -> (PiTyBinder, Type)

-- | Split off all PiTyBinders to a type, splitting both proper foralls and
--   functions
splitPiTys :: Type -> ([PiTyBinder], Type)

-- | Extracts a list of run-time arguments from a function type, looking
--   through newtypes to the right of arrows.
--   
--   Examples:
--   
--   <pre>
--   newtype Identity a = I a
--   
--   getRuntimeArgTys (Int -&gt; Bool -&gt; Double) == [(Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (Identity Int -&gt; Bool -&gt; Double) == [(Identity Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (Int -&gt; Identity (Bool -&gt; Identity Double)) == [(Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (forall a. Show a =&gt; Identity a -&gt; a -&gt; Int -&gt; Bool)
--            == [(Show a, FTF_C_T), (Identity a, FTF_T_T),(a, FTF_T_T),(Int, FTF_T_T)]
--   </pre>
--   
--   Note that, in the last case, the returned types might mention an
--   out-of-scope type variable. This function is used only when we really
--   care about the <i>kinds</i> of the returned types, so this is OK.
--   
--   <ul>
--   <li>*Warning**: this function can return an infinite list. For
--   example:</li>
--   </ul>
--   
--   <pre>
--   newtype N a = MkN (a -&gt; N a)
--   getRuntimeArgTys (N a) == repeat (a, FTF_T_T)
--   </pre>
getRuntimeArgTys :: Type -> [(Scaled Type, FunTyFlag)]

-- | Given a list of type-level vars and the free vars of a result kind,
--   makes PiTyBinders, preferring anonymous binders if the variable is, in
--   fact, not dependent. e.g. mkTyConBindersPreferAnon
--   <a>(k:*),(b:k),(c:k)</a> We want (k:*) Named, (b:k) Anon, (c:k) Anon
--   
--   All non-coercion binders are <i>visible</i>.
mkTyConBindersPreferAnon :: [TyVar] -> TyCoVarSet -> [TyConBinder]
mkPiTy :: PiTyBinder -> Type -> Type
mkPiTys :: [PiTyBinder] -> Type -> Type
piResultTy :: HasDebugCallStack => Type -> Type -> Type

-- | (piResultTys f_ty [ty1, .., tyn]) gives the type of (f ty1 .. tyn)
--   where f :: f_ty <a>piResultTys</a> is interesting because: 1.
--   <tt>f_ty</tt> may have more for-alls than there are args 2. Less
--   obviously, it may have fewer for-alls For case 2. think of:
--   piResultTys (forall a.a) [forall b.b, Int] This really can happen, but
--   only (I think) in situations involving undefined. For example:
--   undefined :: forall a. a Term: undefined <tt>(forall b. b-&gt;b)
--   </tt>Int This term should have type (Int -&gt; Int), but notice that
--   there are more type args than foralls in <a>undefined</a>s type.
piResultTys :: HasDebugCallStack => Type -> [Type] -> Type
applyTysX :: HasDebugCallStack => [TyVar] -> Type -> [Type] -> Type

-- | Drops all ForAllTys
dropForAlls :: Type -> Type

-- | Given a family instance TyCon and its arg types, return the
--   corresponding family type. E.g:
--   
--   <pre>
--   data family T a
--   data instance T (Maybe b) = MkT b
--   </pre>
--   
--   Where the instance tycon is :RTL, so:
--   
--   <pre>
--   mkFamilyTyConApp :RTL Int  =  T (Maybe Int)
--   </pre>
mkFamilyTyConApp :: TyCon -> [Type] -> Type
buildSynTyCon :: Name -> [KnotTied TyConBinder] -> Kind -> [Role] -> KnotTied Type -> TyCon
mkNumLitTy :: Integer -> Type

-- | Is this a numeric literal. We also look through type synonyms.
isNumLitTy :: Type -> Maybe Integer
mkStrLitTy :: FastString -> Type

-- | Is this a symbol literal. We also look through type synonyms.
isStrLitTy :: Type -> Maybe FastString
mkCharLitTy :: Char -> Type

-- | Is this a char literal? We also look through type synonyms.
isCharLitTy :: Type -> Maybe Char

-- | Is this a type literal (symbol, numeric, or char)?
isLitTy :: Type -> Maybe TyLit
isPredTy :: HasDebugCallStack => Type -> Bool

-- | Extract the RuntimeRep classifier of a type. For instance,
--   <tt>getRuntimeRep_maybe Int = LiftedRep</tt>. Panics if this is not
--   possible.
getRuntimeRep :: HasDebugCallStack => Type -> RuntimeRepType

-- | (splitRuntimeRep_maybe rr) takes a Type rr :: RuntimeRep, and returns
--   the (TyCon,[Type]) for the RuntimeRep, if possible, where the TyCon is
--   one of the promoted DataCons of RuntimeRep. Remember: the unique on
--   TyCon that is a a promoted DataCon is the same as the unique on the
--   DataCon See Note [Promoted data constructors] in GHC.Core.TyCon May
--   not be possible if <tt>rr</tt> is a type variable or type family
--   application
splitRuntimeRep_maybe :: RuntimeRepType -> Maybe (TyCon, [Type])

-- | Given a kind (TYPE rr) or (CONSTRAINT rr), extract its RuntimeRep
--   classifier rr. For example, <tt>kindRep_maybe * = Just LiftedRep</tt>
--   Returns <a>Nothing</a> if the kind is not of form (TYPE rr)
kindRep_maybe :: HasDebugCallStack => Kind -> Maybe RuntimeRepType

-- | Extract the RuntimeRep classifier of a type from its kind. For
--   example, <tt>kindRep * = LiftedRep</tt>; Panics if this is not
--   possible. Treats * and Constraint as the same
kindRep :: HasDebugCallStack => Kind -> RuntimeRepType

-- | Extract the <a>PromDataConInfo</a> of a type. For example,
--   <tt>getLevity Int = Lifted</tt>, or <tt>getLevity (Array# Int) =
--   Unlifted</tt>.
--   
--   Panics if this is not possible. Does not look through type family
--   applications.
getLevity :: HasDebugCallStack => Type -> Type

-- | <tt>levity_maybe</tt> takes a Type of kind Levity, and returns its
--   levity May not be possible for a type variable or type family
--   application
levityType_maybe :: LevityType -> Maybe Levity

-- | Make a <a>CastTy</a>. The Coercion must be nominal. Checks the
--   Coercion for reflexivity, dropping it if it's reflexive. See <tt>Note
--   [Respecting definitional equality]</tt> in <a>GHC.Core.TyCo.Rep</a>
mkCastTy :: Type -> Coercion -> Type
mkCoercionTy :: Coercion -> Type
splitCastTy_maybe :: Type -> Maybe (Type, Coercion)

-- | Is this type a custom user error? If so, give us the kind and the
--   error message.
userTypeError_maybe :: Type -> Maybe Type

-- | Render a type corresponding to a user type error into a SDoc.
pprUserTypeErrorTy :: Type -> SDoc

-- | Get the type on the LHS of a coercion induced by a type/data family
--   instance.
coAxNthLHS :: CoAxiom br -> Int -> Type
stripCoercionTy :: Type -> Coercion

-- | Like <a>splitPiTys</a>, but returns only *invisible* binders,
--   including constraints. Stops at the first visible binder.
splitInvisPiTys :: Type -> ([PiTyBinder], Type)

-- | Same as <a>splitInvisPiTys</a>, but stop when - you have found
--   <tt>n</tt> <a>PiTyBinder</a>s, - or you run out of invisible binders
splitInvisPiTysN :: Int -> Type -> ([PiTyBinder], Type)
invisibleTyBndrCount :: Type -> Int

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   invisible (i.e., <a>Inferred</a> or <a>Specified</a>) arguments.
filterOutInvisibleTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   <a>Inferred</a> arguments.
filterOutInferredTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, partition the
--   arguments into:
--   
--   <ol>
--   <li><a>Inferred</a> or <a>Specified</a> (i.e., invisible) arguments
--   and</li>
--   <li><a>Required</a> (i.e., visible) arguments</li>
--   </ol>
partitionInvisibleTypes :: TyCon -> [Type] -> ([Type], [Type])

-- | Given a list of things paired with their visibilities, partition the
--   things into (invisible things, visible things).
partitionInvisibles :: [(a, ForAllTyFlag)] -> ([a], [a])

-- | Given a <a>TyCon</a> and a list of argument types to which the
--   <a>TyCon</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Wrinkle: consider the following scenario:
--   
--   <pre>
--   T :: forall k. k -&gt; k
--   tyConForAllTyFlags T [forall m. m -&gt; m -&gt; m, S, R, Q]
--   </pre>
--   
--   After substituting, we get
--   
--   <pre>
--   T (forall m. m -&gt; m -&gt; m) :: (forall m. m -&gt; m -&gt; m) -&gt; forall n. n -&gt; n -&gt; n
--   </pre>
--   
--   Thus, the first argument is invisible, <tt>S</tt> is visible,
--   <tt>R</tt> is invisible again, and <tt>Q</tt> is visible.
tyConForAllTyFlags :: TyCon -> [Type] -> [ForAllTyFlag]

-- | Given a <a>Type</a> and a list of argument types to which the
--   <a>Type</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Most of the time, the arguments will be <a>Required</a>, but not
--   always. Consider <tt>f :: forall a. a -&gt; Type</tt>. In <tt>f Type
--   Bool</tt>, the first argument (<tt>Type</tt>) is <a>Specified</a> and
--   the second argument (<tt>Bool</tt>) is <a>Required</a>. It is
--   precisely this sort of higher-rank situation in which
--   <a>appTyForAllTyFlags</a> comes in handy, since <tt>f Type Bool</tt>
--   would be represented in Core using <a>AppTy</a>s. (See also #15792).
appTyForAllTyFlags :: Type -> [Type] -> [ForAllTyFlag]

-- | This describes how a "map" operation over a type/coercion should
--   behave
data TyCoMapper env m
TyCoMapper :: (env -> TyVar -> m Type) -> (env -> CoVar -> m Coercion) -> (env -> CoercionHole -> m Coercion) -> (env -> TyCoVar -> ForAllTyFlag -> m (env, TyCoVar)) -> (TyCon -> m TyCon) -> TyCoMapper env m
[tcm_tyvar] :: TyCoMapper env m -> env -> TyVar -> m Type
[tcm_covar] :: TyCoMapper env m -> env -> CoVar -> m Coercion

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcm_hole] :: TyCoMapper env m -> env -> CoercionHole -> m Coercion

-- | The returned env is used in the extended scope
[tcm_tycobinder] :: TyCoMapper env m -> env -> TyCoVar -> ForAllTyFlag -> m (env, TyCoVar)

-- | This is used only for TcTyCons a) To zonk TcTyCons b) To turn TcTyCons
--   into TyCons. See Note [Type checking recursive type and class
--   declarations] in <a>GHC.Tc.TyCl</a>
[tcm_tycon] :: TyCoMapper env m -> TyCon -> m TyCon
mapTyCo :: Monad m => TyCoMapper () m -> (Type -> m Type, [Type] -> m [Type], Coercion -> m Coercion, [Coercion] -> m [Coercion])
mapTyCoX :: Monad m => TyCoMapper env m -> (env -> Type -> m Type, env -> [Type] -> m [Type], env -> Coercion -> m Coercion, env -> [Coercion] -> m [Coercion])
data TyCoFolder env a
TyCoFolder :: (Type -> Maybe Type) -> (env -> TyVar -> a) -> (env -> CoVar -> a) -> (env -> CoercionHole -> a) -> (env -> TyCoVar -> ForAllTyFlag -> env) -> TyCoFolder env a
[tcf_view] :: TyCoFolder env a -> Type -> Maybe Type
[tcf_tyvar] :: TyCoFolder env a -> env -> TyVar -> a
[tcf_covar] :: TyCoFolder env a -> env -> CoVar -> a

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcf_hole] :: TyCoFolder env a -> env -> CoercionHole -> a

-- | The returned env is used in the extended scope
[tcf_tycobinder] :: TyCoFolder env a -> env -> TyCoVar -> ForAllTyFlag -> env
foldTyCo :: Monoid a => TyCoFolder env a -> env -> (Type -> a, [Type] -> a, Coercion -> a, [Coercion] -> a)

-- | A view function that looks through nothing.
noView :: Type -> Maybe Type

-- | Unwrap one <tt>layer</tt> of newtype on a type constructor and its
--   arguments, using an eta-reduced version of the <tt>newtype</tt> if
--   possible. This requires tys to have at least <tt>newTyConInstArity
--   tycon</tt> elements.
newTyConInstRhs :: TyCon -> [Type] -> Type

-- | Make a named binder
mkForAllTyBinder :: vis -> TyCoVar -> VarBndr TyCoVar vis

-- | Make many named binders
mkForAllTyBinders :: vis -> [TyCoVar] -> [VarBndr TyCoVar vis]

-- | Make a named binder <tt>var</tt> should be a type variable
mkTyVarBinder :: vis -> TyVar -> VarBndr TyVar vis

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: vis -> [TyVar] -> [VarBndr TyVar vis]
tyVarSpecToBinders :: [VarBndr a Specificity] -> [VarBndr a ForAllTyFlag]

-- | Does this binder bind a variable that is <i>not</i> erased? Returns
--   <a>True</a> for anonymous binders.
isAnonPiTyBinder :: PiTyBinder -> Bool
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]
binderType :: VarBndr TyCoVar argf -> Type
binderFlag :: VarBndr tv argf -> argf
binderFlags :: [VarBndr tv argf] -> [argf]
piTyBinderType :: PiTyBinder -> Type
namedPiTyBinder_maybe :: PiTyBinder -> Maybe TyCoVar

-- | Extract a relevant type, if there is one.
anonPiTyBinderType_maybe :: PiTyBinder -> Maybe Type

-- | Does this <a>ForAllTyFlag</a> classify an argument that is written in
--   Haskell?
isVisibleForAllTyFlag :: ForAllTyFlag -> Bool

-- | Does this <a>ForAllTyFlag</a> classify an argument that is not written
--   in Haskell?
isInvisibleForAllTyFlag :: ForAllTyFlag -> Bool

-- | Does this binder bind a visible argument?
isVisiblePiTyBinder :: PiTyBinder -> Bool

-- | Does this binder bind an invisible argument?
isInvisiblePiTyBinder :: PiTyBinder -> Bool
isNamedPiTyBinder :: PiTyBinder -> Bool
tyConBindersPiTyBinders :: [TyConBinder] -> [PiTyBinder]
isTyVarTy :: Type -> Bool

-- | Is this a function?
isFunTy :: Type -> Bool
isCoercionTy :: Type -> Bool
isCoercionTy_maybe :: Type -> Maybe Coercion

-- | Checks whether this is a proper forall (with a named binder)
isForAllTy :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a tyvar binder
isForAllTy_ty :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a covar binder
isForAllTy_co :: Type -> Bool

-- | Is this a function or forall?
isPiTy :: Type -> Bool
isTauTy :: Type -> Bool
isFamFreeTy :: Type -> Bool

-- | Does this type classify a core (unlifted) Coercion? At either role
--   nominal or representational (t1 ~# t2) or (t1 ~R# t2) See Note [Types
--   for coercions, predicates, and evidence] in <a>GHC.Core.TyCo.Rep</a>
isCoVarType :: Type -> Bool
isAtomicTy :: Type -> Bool

-- | Determine whether a type could be the type of a join point of given
--   total arity, according to the polymorphism rule. A join point cannot
--   be polymorphic in its return type, since given join j <tt>a </tt>b x y
--   z = e1 in e2, the types of e1 and e2 must be the same, and a and b are
--   not in scope for e2. (See Note [The polymorphism rule of join points]
--   in <a>GHC.Core</a>.) Returns False also if the type simply doesn't
--   have enough arguments.
--   
--   Note that we need to know how many arguments (type *and* value) the
--   putative join point takes; for instance, if j :: forall a. a -&gt; Int
--   then j could be a binary join point returning an Int, but it could
--   *not* be a unary join point returning a -&gt; Int.
--   
--   TODO: See Note [Excess polymorphism and join points]
isValidJoinPointType :: JoinArity -> Type -> Bool

-- | Does a <a>TyCon</a> (that is applied to some number of arguments) need
--   to be ascribed with an explicit kind signature to resolve ambiguity if
--   rendered as a source-syntax type? (See <tt>Note [When does a tycon
--   application need an explicit kind signature?]</tt> for a full
--   explanation of what this function checks for.)
tyConAppNeedsKindSig :: Bool -> TyCon -> Int -> Bool
mkTYPEapp :: RuntimeRepType -> Type

-- | Given a <tt>RuntimeRep</tt>, applies <tt>TYPE</tt> to it. On the fly
--   it rewrites TYPE LiftedRep --&gt; liftedTypeKind (a synonym) TYPE
--   UnliftedRep --&gt; unliftedTypeKind (ditto) TYPE ZeroBitRep --&gt;
--   zeroBitTypeKind (ditto) NB: no need to check for TYPE (BoxedRep
--   Lifted), TYPE (BoxedRep Unlifted) because those inner types should
--   already have been rewritten to LiftedRep and UnliftedRep respectively,
--   by mkTyConApp
--   
--   see Note [TYPE and CONSTRAINT] in GHC.Builtin.Types.Prim. See Note
--   [Using synonyms to compress types] in GHC.Core.Type
mkTYPEapp_maybe :: RuntimeRepType -> Maybe Type

-- | Just like mkTYPEapp
mkCONSTRAINTapp :: RuntimeRepType -> Type

-- | Just like mkTYPEapp_maybe
mkCONSTRAINTapp_maybe :: RuntimeRepType -> Maybe Type

-- | Given a <a>PromDataConInfo</a>, apply <tt>BoxedRep</tt> to it On the
--   fly, rewrite BoxedRep Lifted --&gt; liftedRepTy (a synonym) BoxedRep
--   Unlifted --&gt; unliftedRepTy (ditto) See Note [TYPE and CONSTRAINT]
--   in GHC.Builtin.Types.Prim. See Note [Using synonyms to compress types]
--   in GHC.Core.Type
mkBoxedRepApp_maybe :: LevityType -> Maybe Type

-- | Given a `[RuntimeRep]`, apply <tt>TupleRep</tt> to it On the fly,
--   rewrite TupleRep [] -&gt; zeroBitRepTy (a synonym) See Note [TYPE and
--   CONSTRAINT] in GHC.Builtin.Types.Prim. See Note [Using synonyms to
--   compress types] in GHC.Core.Type
mkTupleRepApp_maybe :: Type -> Maybe Type
typeOrConstraintKind :: TypeOrConstraint -> RuntimeRepType -> Kind
sORTKind_maybe :: Kind -> Maybe (TypeOrConstraint, Type)
typeTypeOrConstraint :: HasDebugCallStack => Type -> TypeOrConstraint

-- | Tries to compute the <a>PromDataConInfo</a> of the given type. Returns
--   either a definite <a>PromDataConInfo</a>, or <a>Nothing</a> if we
--   aren't sure (e.g. the type is representation-polymorphic).
--   
--   Panics if the kind does not have the shape <tt>TYPE r</tt>.
typeLevity_maybe :: HasDebugCallStack => Type -> Maybe Levity
tyConIsTYPEorCONSTRAINT :: TyCon -> Bool

-- | Returns True if the argument is (lifted) Type or Constraint See Note
--   [TYPE and CONSTRAINT] in GHC.Builtin.Types.Prim
isLiftedTypeKind :: Kind -> Bool

-- | Returns True if the kind classifies unlifted types (like 'Int#') and
--   False otherwise. Note that this returns False for
--   representation-polymorphic kinds, which may be specialized to a kind
--   that classifies unlifted types.
isUnliftedTypeKind :: Kind -> Bool
pickyIsLiftedTypeKind :: Kind -> Bool

-- | Check whether a type of kind <a>RuntimeRep</a> is lifted.
--   
--   <a>isLiftedRuntimeRep</a> is:
--   
--   <ul>
--   <li>True of <tt>LiftedRep :: RuntimeRep</tt></li>
--   <li>False of type variables, type family applications, and of other
--   reps such as <tt>IntRep :: RuntimeRep</tt>.</li>
--   </ul>
isLiftedRuntimeRep :: RuntimeRepType -> Bool

-- | Check whether a type of kind <a>RuntimeRep</a> is unlifted.
--   
--   <ul>
--   <li>True of definitely unlifted <a>RuntimeRep</a>s such as
--   <a>UnliftedRep</a>, <a>IntRep</a>, <a>FloatRep</a>, ...</li>
--   <li>False of <a>LiftedRep</a>,</li>
--   <li>False for type variables and type family applications.</li>
--   </ul>
isUnliftedRuntimeRep :: RuntimeRepType -> Bool

-- | Check whether a type of kind <a>RuntimeRep</a> is lifted, unlifted, or
--   unknown.
--   
--   `isLiftedRuntimeRep rr` returns:
--   
--   <ul>
--   <li>`Just Lifted` if <tt>rr</tt> is `LiftedRep :: RuntimeRep`</li>
--   <li>`Just Unlifted` if <tt>rr</tt> is definitely unlifted, e.g.
--   <a>IntRep</a></li>
--   <li><a>Nothing</a> if not known (e.g. it's a type variable or a type
--   family application).</li>
--   </ul>
runtimeRepLevity_maybe :: RuntimeRepType -> Maybe Levity

-- | See <a>isBoxedRuntimeRep_maybe</a>.
isBoxedRuntimeRep :: RuntimeRepType -> Bool
isLiftedLevity :: Type -> Bool
isUnliftedLevity :: Type -> Bool

-- | Is the given type definitely unlifted? See
--   <a>Type#type_classification</a> for what an unlifted type is.
--   
--   Panics on representation-polymorphic types; See
--   <a>mightBeUnliftedType</a> for a more approximate predicate that
--   behaves better in the presence of representation polymorphism.
isUnliftedType :: HasDebugCallStack => Type -> Bool

-- | See <a>Type#type_classification</a> for what a boxed type is. Panics
--   on representation-polymorphic types; See <a>mightBeUnliftedType</a>
--   for a more approximate predicate that behaves better in the presence
--   of representation polymorphism.
isBoxedType :: Type -> Bool
isUnboxedTupleType :: Type -> Bool
isUnboxedSumType :: Type -> Bool

-- | Check whether a kind is of the form `TYPE (BoxedRep Lifted)` or `TYPE
--   (BoxedRep Unlifted)`.
--   
--   Returns:
--   
--   <ul>
--   <li>`Just Lifted` for `TYPE (BoxedRep Lifted)` and <a>Type</a>,</li>
--   <li>`Just Unlifted` for `TYPE (BoxedRep Unlifted)` and
--   <tt>UnliftedType</tt>,</li>
--   <li><a>Nothing</a> for anything else, e.g. `TYPE IntRep`, `TYPE
--   (BoxedRep l)`, etc.</li>
--   </ul>
kindBoxedRepLevity_maybe :: Type -> Maybe Levity

-- | Returns:
--   
--   <ul>
--   <li><a>False</a> if the type is <i>guaranteed</i> unlifted or</li>
--   <li><a>True</a> if it lifted, OR we aren't sure (e.g. in a
--   representation-polymorphic case)</li>
--   </ul>
mightBeLiftedType :: Type -> Bool

-- | Returns:
--   
--   <ul>
--   <li><a>False</a> if the type is <i>guaranteed</i> lifted or</li>
--   <li><a>True</a> if it is unlifted, OR we aren't sure (e.g. in a
--   representation-polymorphic case)</li>
--   </ul>
mightBeUnliftedType :: Type -> Bool

-- | See <a>Type#type_classification</a> for what an algebraic type is.
--   Should only be applied to <i>types</i>, as opposed to e.g. partially
--   saturated type constructors
isAlgType :: Type -> Bool

-- | Check whether a type is a data family type
isDataFamilyAppType :: Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | Computes whether an argument (or let right hand side) should be
--   computed strictly or lazily, based only on its type. Currently, it's
--   just <a>isUnliftedType</a>. Panics on representation-polymorphic
--   types.
isStrictType :: HasDebugCallStack => Type -> Bool

-- | Is this the type <a>PromDataConInfo</a>?
isLevityTy :: Type -> Bool

-- | Is a tyvar of type <a>PromDataConInfo</a>?
isLevityVar :: TyVar -> Bool

-- | Is this the type <a>RuntimeRep</a>?
isRuntimeRepTy :: Type -> Bool

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Is this a type of kind RuntimeRep? (e.g. LiftedRep)
isRuntimeRepKindedTy :: Type -> Bool

-- | Drops prefix of RuntimeRep constructors in <a>TyConApp</a>s. Useful
--   for e.g. dropping 'LiftedRep arguments of unboxed tuple TyCon
--   applications:
--   
--   dropRuntimeRepArgs [ 'LiftedRep, 'IntRep , String, Int# ] == [String,
--   Int#]
dropRuntimeRepArgs :: [Type] -> [Type]

-- | Is this the type <tt>Multiplicity</tt>?
isMultiplicityTy :: Type -> Bool

-- | Is a tyvar of type <tt>Multiplicity</tt>?
isMultiplicityVar :: TyVar -> Bool

-- | Scale a payload by Many
unrestricted :: a -> Scaled a

-- | Scale a payload by One
linear :: a -> Scaled a

-- | Scale a payload by Many; used for type arguments in core
tymult :: a -> Scaled a
mkScaled :: Mult -> a -> Scaled a
irrelevantMult :: Scaled a -> a
scaledSet :: Scaled a -> b -> Scaled b
pattern OneTy :: Mult
pattern ManyTy :: Mult
isOneTy :: Mult -> Bool
isManyTy :: Mult -> Bool

-- | <tt>isLinear t</tt> returns <tt>True</tt> of a if <tt>t</tt> is a type
--   of (curried) function where at least one argument is linear (or
--   otherwise non-unrestricted). We use this function to check whether it
--   is safe to eta reduce an Id in CorePrep. It is always safe to return
--   <a>True</a>, because <a>True</a> deactivates the optimisation.
isLinearType :: Type -> Bool

-- | The key type representing kinds in the compiler.
type Kind = Type
typeKind :: HasDebugCallStack => Type -> Kind

-- | Returns True if a type has a syntactically fixed runtime rep, as per
--   Note [Fixed RuntimeRep] in GHC.Tc.Utils.Concrete.
--   
--   This function is equivalent to `isFixedRuntimeRepKind . typeKind` but
--   much faster.
--   
--   <b>Precondition:</b> The type has kind <tt>(<tt>TYPE</tt> blah)</tt>
typeHasFixedRuntimeRep :: HasDebugCallStack => Type -> Bool

-- | True if the argument types of this function type all have a
--   fixed-runtime-rep
argsHaveFixedRuntimeRep :: Type -> Bool

-- | Is this kind equivalent to <a>Type</a> i.e. TYPE LiftedRep?
tcIsLiftedTypeKind :: Kind -> Bool
isConstraintKind :: Kind -> Bool
isConstraintLikeKind :: Kind -> Bool
returnsConstraintKind :: Kind -> Bool

-- | Is this kind equivalent to <tt>TYPE (BoxedRep l)</tt> for some <tt>l
--   :: Levity</tt>?
tcIsBoxedTypeKind :: Kind -> Bool

-- | Is this kind equivalent to <tt>TYPE r</tt> (for some unknown r)?
--   
--   This considers <tt>Constraint</tt> to be distinct from <tt>*</tt>.
isTypeLikeKind :: Kind -> Bool
liftedTypeKind :: Kind
unliftedTypeKind :: Kind

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV
tyCoFVsBndr :: ForAllTyBinder -> FV -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> CoVarSet
anyFreeVarsOfType :: (TyCoVar -> Bool) -> Type -> Bool
anyFreeVarsOfTypes :: (TyCoVar -> Bool) -> [Type] -> Bool
noFreeVarsOfType :: Type -> Bool

-- | Expand out all type synonyms. Actually, it'd suffice to expand out
--   just the ones that discard type variables (e.g. type Funny a = Int)
--   But we don't know which those are currently, so we just expand all.
--   
--   <a>expandTypeSynonyms</a> only expands out type synonyms mentioned in
--   the type, not in the kinds of any TyCon or TyVar mentioned in the
--   type.
--   
--   Keep this synchronized with <tt>synonymTyConsOfType</tt>
expandTypeSynonyms :: Type -> Type
typeSize :: Type -> Int
occCheckExpand :: [Var] -> Type -> Maybe Type

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministically ordered list.
closeOverKindsList :: [TyVar] -> [TyVar]
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | Get the free vars of a type in scoped order
tyCoVarsOfTypeWellScoped :: Type -> [TyVar]

-- | Get the free vars of types in scoped order
tyCoVarsOfTypesWellScoped :: [Type] -> [TyVar]
seqType :: Type -> ()
seqTypes :: [Type] -> ()

-- | This function strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   <a>Nothing</a> if there is nothing to look through.
--   
--   This function does not look through type family applications.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type

-- | All type constructors occurring in the type; looking through type
--   synonyms, but not newtypes. When it finds a Class, it returns the
--   class TyCon.
tyConsOfType :: Type -> UniqSet TyCon

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A substitution of <tt>Expr</tt>s for non-coercion <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst
emptyTvSubstEnv :: TvSubstEnv
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst
mkSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> IdSubstEnv -> Subst

-- | Generates the in-scope set for the <a>Subst</a> from the types in the
--   incoming environment. No CoVars or Ids, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> Subst

-- | Generates the in-scope set for the <tt>TCvSubst</tt> from the types in
--   the incoming environment. No CoVars, please! The InScopeSet is just a
--   thunk so with a bit of luck it'll never be evaluated
mkTvSubstPrs :: [(TyVar, Type)] -> Subst
zipTCvSubst :: HasDebugCallStack => [TyCoVar] -> [Type] -> Subst
notElemSubst :: Var -> Subst -> Bool
getTvSubstEnv :: Subst -> TvSubstEnv

-- | Remove all substitutions that might have been built up while
--   preserving the in-scope set originally called zapSubstEnv
zapSubst :: Subst -> Subst

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet
setInScope :: Subst -> InScopeSet -> Subst

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getSubstRangeTyCoFVs :: Subst -> VarSet

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeSet :: Subst -> VarSet -> Subst
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst

-- | Add a substitution from a <a>CoVar</a> to a <a>Coercion</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set satisfies Note
--   [The substitution invariant] after extending the substitution like
--   this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that Note [The substitution invariant]
--   holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst
extendTvSubstBinderAndInScope :: Subst -> PiTyBinder -> Type -> Subst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
extendTCvSubstList :: Subst -> [Var] -> [Type] -> Subst
extendTvSubstWithClone :: Subst -> TyVar -> TyVar -> Subst
extendTCvSubstWithClone :: Subst -> TyCoVar -> TyCoVar -> Subst
isInScope :: Var -> Subst -> Bool

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition. This function leaves IdSubstEnv
--   untouched because IdSubstEnv is not used during substitution for
--   types.
composeTCvSubst :: Subst -> Subst -> Subst

-- | The InScopeSet is just a thunk so with a bit of luck it'll never be
--   evaluated
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv
isEmptySubst :: Subst -> Bool
unionSubst :: Subst -> Subst -> Subst

-- | Checks whether the tyvar and covar environments are empty. This
--   function should be used over <a>isEmptySubst</a> when substituting for
--   types, because types currently do not contain expressions; we can
--   safely disregard the expression environment when deciding whether to
--   skip a substitution. Using <a>isEmptyTCvSubst</a> gives us a
--   non-trivial performance boost (up to 70% less allocation for T18223)
isEmptyTCvSubst :: Subst -> Bool

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasDebugCallStack => Subst -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasDebugCallStack => Subst -> [Type] -> [Type]
substScaledTy :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type
substScaledTys :: HasDebugCallStack => Subst -> [Scaled Type] -> [Scaled Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasDebugCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: [TyVar] -> [Type] -> [Type] -> [Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasDebugCallStack => Subst -> ThetaType -> ThetaType

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: Subst -> Type -> Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: Subst -> [Type] -> [Type]
substScaledTyUnchecked :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type
substScaledTysUnchecked :: Subst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: Subst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: Subst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion
substTyVarBndr :: HasDebugCallStack => Subst -> TyVar -> (Subst, TyVar)
substTyVarBndrs :: HasDebugCallStack => Subst -> [TyVar] -> (Subst, [TyVar])
substTyVar :: Subst -> TyVar -> Type
substTyVars :: Subst -> [TyVar] -> [Type]
substVarBndr :: HasDebugCallStack => Subst -> TyCoVar -> (Subst, TyCoVar)
substVarBndrs :: HasDebugCallStack => Subst -> [TyCoVar] -> (Subst, [TyCoVar])
substTyCoBndr :: Subst -> PiTyBinder -> (Subst, PiTyBinder)
substTyVarToTyVar :: HasDebugCallStack => Subst -> TyVar -> TyVar
cloneTyVarBndr :: Subst -> TyVar -> Unique -> (Subst, TyVar)
cloneTyVarBndrs :: Subst -> [TyVar] -> UniqSupply -> (Subst, [TyVar])
lookupTyVar :: Subst -> TyVar -> Maybe Type

-- | Tidy a Type
--   
--   See Note [Strictness in tidyType and friends]
tidyType :: TidyEnv -> Type -> Type

-- | Tidy a list of Types
--   
--   See Note [Strictness in tidyType and friends]
tidyTypes :: TidyEnv -> [Type] -> [Type]
tidyOpenType :: TidyEnv -> Type -> (TidyEnv, Type)

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypes :: TidyEnv -> [Type] -> (TidyEnv, [Type])
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a>
tidyOpenTyCoVar :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)
tidyOpenTyCoVars :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type
tidyForAllTyBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyForAllTyBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, TYPE Lifted, TYPE IntRep, TYPE v, Constraint.
--   
--   True of a kind `TYPE _` or `CONSTRAINT _`
isTYPEorCONSTRAINT :: Kind -> Bool

-- | Tests whether the given type is concrete, i.e. it whether it consists
--   only of concrete type constructors, concrete type variables, and
--   applications.
--   
--   See Note [Concrete types] in GHC.Tc.Utils.Concrete.
isConcrete :: Type -> Bool

-- | Checks that a kind of the form <a>Type</a>, <tt>Constraint</tt> or
--   <tt>'TYPE r</tt> is concrete. See <a>isConcrete</a>.
--   
--   <b>Precondition:</b> The type has kind `TYPE blah` or `CONSTRAINT
--   blah`
isFixedRuntimeRepKind :: HasDebugCallStack => Kind -> Bool


-- | Source-language literals
module Language.Haskell.Syntax.Lit

-- | Haskell Literal
data HsLit x

-- | Character
HsChar :: XHsChar x -> Char -> HsLit x

-- | Unboxed character
HsCharPrim :: XHsCharPrim x -> Char -> HsLit x

-- | String
HsString :: XHsString x -> FastString -> HsLit x

-- | Packed bytes
HsStringPrim :: XHsStringPrim x -> !ByteString -> HsLit x

-- | Genuinely an Int; arises from <a>GHC.Tc.Deriv.Generate</a>, and from
--   TRANSLATION
HsInt :: XHsInt x -> IntegralLit -> HsLit x

-- | literal <tt>Int#</tt>
HsIntPrim :: XHsIntPrim x -> Integer -> HsLit x

-- | literal <tt>Word#</tt>
HsWordPrim :: XHsWordPrim x -> Integer -> HsLit x

-- | literal <tt>Int64#</tt>
HsInt64Prim :: XHsInt64Prim x -> Integer -> HsLit x

-- | literal <tt>Word64#</tt>
HsWord64Prim :: XHsWord64Prim x -> Integer -> HsLit x

-- | Genuinely an integer; arises only from TRANSLATION (overloaded
--   literals are done with HsOverLit)
HsInteger :: XHsInteger x -> Integer -> Type -> HsLit x

-- | Genuinely a rational; arises only from TRANSLATION (overloaded
--   literals are done with HsOverLit)
HsRat :: XHsRat x -> FractionalLit -> Type -> HsLit x

-- | Unboxed Float
HsFloatPrim :: XHsFloatPrim x -> FractionalLit -> HsLit x

-- | Unboxed Double
HsDoublePrim :: XHsDoublePrim x -> FractionalLit -> HsLit x
XLit :: !XXLit x -> HsLit x

-- | Haskell Overloaded Literal
data HsOverLit p
OverLit :: XOverLit p -> OverLitVal -> HsOverLit p
[ol_ext] :: HsOverLit p -> XOverLit p
[ol_val] :: HsOverLit p -> OverLitVal
XOverLit :: !XXOverLit p -> HsOverLit p

-- | Overloaded Literal Value
data OverLitVal

-- | Integer-looking literals;
HsIntegral :: !IntegralLit -> OverLitVal

-- | Frac-looking literals
HsFractional :: !FractionalLit -> OverLitVal

-- | String-looking literals
HsIsString :: !SourceText -> !FastString -> OverLitVal
negateOverLitVal :: OverLitVal -> OverLitVal
instance Data.Data.Data Language.Haskell.Syntax.Lit.OverLitVal
instance GHC.Classes.Eq (Language.Haskell.Syntax.Extension.XXOverLit p) => GHC.Classes.Eq (Language.Haskell.Syntax.Lit.HsOverLit p)
instance GHC.Classes.Ord (Language.Haskell.Syntax.Extension.XXOverLit p) => GHC.Classes.Ord (Language.Haskell.Syntax.Lit.HsOverLit p)
instance GHC.Classes.Eq Language.Haskell.Syntax.Lit.OverLitVal
instance GHC.Classes.Ord Language.Haskell.Syntax.Lit.OverLitVal
instance GHC.Classes.Eq (Language.Haskell.Syntax.Lit.HsLit x)

module GHC.Types.Tickish
data GenTickish pass

-- | An <tt>{-# SCC #-}</tt> profiling annotation, either automatically
--   added by the desugarer as a result of -auto-all, or added by the user.
ProfNote :: CostCentre -> !Bool -> !Bool -> GenTickish pass

-- | the cost centre
[profNoteCC] :: GenTickish pass -> CostCentre

-- | bump the entry count?
[profNoteCount] :: GenTickish pass -> !Bool

-- | scopes over the enclosed expression (i.e. not just a tick)
[profNoteScope] :: GenTickish pass -> !Bool

-- | A "tick" used by HPC to track the execution of each subexpression in
--   the original source code.
HpcTick :: Module -> !Int -> GenTickish pass
[tickModule] :: GenTickish pass -> Module
[tickId] :: GenTickish pass -> !Int

-- | A breakpoint for the GHCi debugger. This behaves like an HPC tick, but
--   has a list of free variables which will be available for inspection in
--   GHCi when the program stops at the breakpoint.
--   
--   NB. we must take account of these Ids when (a) counting free
--   variables, and (b) substituting (don't substitute for them)
Breakpoint :: XBreakpoint pass -> !Int -> [XTickishId pass] -> GenTickish pass
[breakpointExt] :: GenTickish pass -> XBreakpoint pass
[breakpointId] :: GenTickish pass -> !Int

-- | the order of this list is important: it matches the order of the lists
--   in the appropriate entry in <a>ModBreaks</a>.
--   
--   Careful about substitution! See Note [substTickish] in
--   <a>GHC.Core.Subst</a>.
[breakpointFVs] :: GenTickish pass -> [XTickishId pass]

-- | A source note.
--   
--   Source notes are pure annotations: Their presence should neither
--   influence compilation nor execution. The semantics are given by
--   causality: The presence of a source note means that a local change in
--   the referenced source code span will possibly provoke the generated
--   code to change. On the flip-side, the functionality of annotated code
--   *must* be invariant against changes to all source code *except* the
--   spans referenced in the source notes (see "Causality of optimized
--   Haskell" paper for details).
--   
--   Therefore extending the scope of any given source note is always
--   valid. Note that it is still undesirable though, as this reduces their
--   usefulness for debugging and profiling. Therefore we will generally
--   try only to make use of this property where it is necessary to enable
--   optimizations.
SourceNote :: RealSrcSpan -> String -> GenTickish pass

-- | Source covered
[sourceSpan] :: GenTickish pass -> RealSrcSpan

-- | Name for source location (uses same names as CCs)
[sourceName] :: GenTickish pass -> String
type CoreTickish = GenTickish 'TickishPassCore
type StgTickish = GenTickish 'TickishPassStg

-- | Tickish in Cmm context (annotations only)
type CmmTickish = GenTickish 'TickishPassCmm
type family XTickishId (pass :: TickishPass)

-- | A "counting tick" (where tickishCounts is True) is one that counts
--   evaluations in some way. We cannot discard a counting tick, and the
--   compiler should preserve the number of counting ticks as far as
--   possible.
--   
--   However, we still allow the simplifier to increase or decrease
--   sharing, so in practice the actual number of ticks may vary, except
--   that we never change the value from zero to non-zero or vice versa.
tickishCounts :: GenTickish pass -> Bool

-- | Specifies the scoping behaviour of ticks. This governs the behaviour
--   of ticks that care about the covered code and the cost associated with
--   it. Important for ticks relating to profiling.
data TickishScoping

-- | No scoping: The tick does not care about what code it covers.
--   Transformations can freely move code inside as well as outside without
--   any additional annotation obligations
NoScope :: TickishScoping

-- | Soft scoping: We want all code that is covered to stay covered. Note
--   that this scope type does not forbid transformations from happening,
--   as long as all results of the transformations are still covered by
--   this tick or a copy of it. For example
--   
--   let x = tick<a>...</a> (let y = foo in bar) in baz ===&gt; let x =
--   tick<a>...</a> bar; y = tick<a>...</a> foo in baz
--   
--   Is a valid transformation as far as "bar" and "foo" is concerned,
--   because both still are scoped over by the tick.
--   
--   Note though that one might object to the "let" not being covered by
--   the tick any more. However, we are generally lax with this - constant
--   costs don't matter too much, and given that the "let" was effectively
--   merged we can view it as having lost its identity anyway.
--   
--   Also note that this scoping behaviour allows floating a tick "upwards"
--   in pretty much any situation. For example:
--   
--   case foo of x -&gt; tick<a>...</a> bar ==&gt; tick<a>...</a> case foo
--   of x -&gt; bar
--   
--   While this is always legal, we want to make a best effort to only make
--   us of this where it exposes transformation opportunities.
SoftScope :: TickishScoping

-- | Cost centre scoping: We don't want any costs to move to other
--   cost-centre stacks. This means we not only want no code or cost to get
--   moved out of their cost centres, but we also object to code getting
--   associated with new cost-centre ticks - or changing the order in which
--   they get applied.
--   
--   A rule of thumb is that we don't want any code to gain new
--   annotations. However, there are notable exceptions, for example:
--   
--   let f = y -&gt; foo in tick<a>...</a> ... (f x) ... ==&gt;
--   tick<a>...</a> ... foo[x/y] ...
--   
--   In-lining lambdas like this is always legal, because inlining a
--   function does not change the cost-centre stack when the function is
--   called.
CostCentreScope :: TickishScoping

-- | Returns the intended scoping rule for a Tickish
tickishScoped :: GenTickish pass -> TickishScoping

-- | Returns whether the tick scoping rule is at least as permissive as the
--   given scoping rule.
tickishScopesLike :: GenTickish pass -> TickishScoping -> Bool

-- | Returns <tt>True</tt> for ticks that can be floated upwards easily
--   even where it might change execution counts, such as:
--   
--   Just (tick<a>...</a> foo) ==&gt; tick<a>...</a> (Just foo)
--   
--   This is a combination of <tt>tickishSoftScope</tt> and
--   <tt>tickishCounts</tt>. Note that in principle splittable ticks can
--   become floatable using <tt>mkNoTick</tt> -- even though there's
--   currently no tickish for which that is the case.
tickishFloatable :: GenTickish pass -> Bool

-- | Returns <tt>True</tt> for a tick that is both counting <i>and</i>
--   scoping and can be split into its (tick, scope) parts using
--   <a>mkNoScope</a> and <tt>mkNoTick</tt> respectively.
tickishCanSplit :: GenTickish pass -> Bool
mkNoCount :: GenTickish pass -> GenTickish pass
mkNoScope :: GenTickish pass -> GenTickish pass

-- | Return <tt>True</tt> if this source annotation compiles to some
--   backend code. Without this flag, the tickish is seen as a simple
--   annotation that does not have any associated evaluation code.
--   
--   What this means that we are allowed to disregard the tick if doing so
--   means that we can skip generating any code in the first place. A
--   typical example is top-level bindings:
--   
--   foo = tick<a>...</a> y -&gt; ... ==&gt; foo = y -&gt; tick<a>...</a>
--   ...
--   
--   Here there is just no operational difference between the first and the
--   second version. Therefore code generation should simply translate the
--   code as if it found the latter.
tickishIsCode :: GenTickish pass -> Bool
isProfTick :: GenTickish pass -> Bool

-- | Governs the kind of expression that the tick gets placed on when
--   annotating for example using <tt>mkTick</tt>. If we find that we want
--   to put a tickish on an expression ruled out here, we try to float it
--   inwards until we find a suitable expression.
data TickishPlacement

-- | Place ticks exactly on run-time expressions. We can still move the
--   tick through pure compile-time constructs such as other ticks, casts
--   or type lambdas. This is the most restrictive placement rule for
--   ticks, as all tickishs have in common that they want to track runtime
--   processes. The only legal placement rule for counting ticks. NB: We
--   generally try to move these as close to the relevant runtime
--   expression as possible. This means they get pushed through tyoe
--   arguments. E.g. we create `(tick f) <tt>Bool` instead of `tick (f
--   </tt>Bool)`.
PlaceRuntime :: TickishPlacement

-- | As <tt>PlaceRuntime</tt>, but we float the tick through all lambdas.
--   This makes sense where there is little difference between annotating
--   the lambda and annotating the lambda's code.
PlaceNonLam :: TickishPlacement

-- | In addition to floating through lambdas, cost-centre style tickishs
--   can also be moved from constructors, non-function variables and
--   literals. For example:
--   
--   let x = scc<a>...</a> C (scc<a>...</a> y) (scc<a>...</a> 3) in ...
--   
--   Neither the constructor application, the variable or the literal are
--   likely to have any cost worth mentioning. And even if y names a thunk,
--   the call would not care about the evaluation context. Therefore
--   removing all annotations in the above example is safe.
PlaceCostCentre :: TickishPlacement

-- | Placement behaviour we want for the ticks
tickishPlace :: GenTickish pass -> TickishPlacement

-- | Returns whether one tick "contains" the other one, therefore making
--   the second tick redundant.
tickishContains :: Eq (GenTickish pass) => GenTickish pass -> GenTickish pass -> Bool
instance GHC.Classes.Eq GHC.Types.Tickish.TickishScoping
instance GHC.Show.Show GHC.Types.Tickish.TickishPlacement
instance GHC.Classes.Eq GHC.Types.Tickish.TickishPlacement
instance GHC.Classes.Eq (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCore)
instance GHC.Classes.Ord (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCore)
instance Data.Data.Data (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCore)
instance Data.Data.Data (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassStg)
instance GHC.Classes.Eq (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCmm)
instance GHC.Classes.Ord (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCmm)
instance Data.Data.Data (GHC.Types.Tickish.GenTickish 'GHC.Types.Tickish.TickishPassCmm)
instance GHC.Utils.Outputable.Outputable GHC.Types.Tickish.TickishPlacement


-- | This module defines the semi-ring of multiplicities, and associated
--   functions. Multiplicities annotate arrow types to indicate the
--   linearity of the arrow (in the sense of linear types).
--   
--   Mult is a type synonym for Type, used only when its kind is
--   Multiplicity. To simplify dealing with multiplicities, functions such
--   as mkMultMul perform simplifications such as Many * x = Many on the
--   fly.
module GHC.Core.Multiplicity

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type
pattern OneTy :: Mult
pattern ManyTy :: Mult
isMultMul :: Mult -> Maybe (Mult, Mult)
mkMultAdd :: Mult -> Mult -> Mult
mkMultMul :: Mult -> Mult -> Mult

-- | <tt>mkMultSup w1 w2</tt> returns a multiplicity such that
--   <tt>mkMultSup w1 w2 &gt;= w1</tt> and <tt>mkMultSup w1 w2 &gt;=
--   w2</tt>. See Note [Overapproximating multiplicities].
mkMultSup :: Mult -> Mult -> Mult

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a
Scaled :: !Mult -> a -> Scaled a
scaledMult :: Scaled a -> Mult
scaledThing :: Scaled a -> a

-- | Scale a payload by Many
unrestricted :: a -> Scaled a

-- | Scale a payload by One
linear :: a -> Scaled a

-- | Scale a payload by Many; used for type arguments in core
tymult :: a -> Scaled a
irrelevantMult :: Scaled a -> a
mkScaled :: Mult -> a -> Scaled a
scaledSet :: Scaled a -> b -> Scaled b
scaleScaled :: Mult -> Scaled a -> Scaled a
data IsSubmult
Submult :: IsSubmult
Unknown :: IsSubmult

-- | <tt>submult w1 w2</tt> check whether a value of multiplicity
--   <tt>w1</tt> is allowed where a value of multiplicity <tt>w2</tt> is
--   expected. This is a partial order.
submult :: Mult -> Mult -> IsSubmult

-- | Apply a function to both the Mult and the Type in a 'Scaled Type'
mapScaledType :: (Type -> Type) -> Scaled Type -> Scaled Type
pprArrowWithMultiplicity :: FunTyFlag -> Either Bool SDoc -> SDoc
instance GHC.Classes.Eq GHC.Core.Multiplicity.IsSubmult
instance GHC.Show.Show GHC.Core.Multiplicity.IsSubmult
instance GHC.Utils.Outputable.Outputable GHC.Core.Multiplicity.IsSubmult

module GHC.Core.UsageEnv
data Usage
Zero :: Usage
Bottom :: Usage
MUsage :: Mult -> Usage
data UsageEnv
addUE :: UsageEnv -> UsageEnv -> UsageEnv
addUsage :: Usage -> Usage -> Usage
bottomUE :: UsageEnv
deleteUE :: NamedThing n => UsageEnv -> n -> UsageEnv

-- | |lookupUE x env| returns the multiplicity assigned to |x| in |env|, if
--   |x| is not bound in |env|, then returns |Zero| or |Bottom|.
lookupUE :: NamedThing n => UsageEnv -> n -> Usage
scaleUE :: Mult -> UsageEnv -> UsageEnv
scaleUsage :: Mult -> Usage -> Usage
supUE :: UsageEnv -> UsageEnv -> UsageEnv
supUEs :: [UsageEnv] -> UsageEnv
unitUE :: NamedThing n => n -> Mult -> UsageEnv
zeroUE :: UsageEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.UsageEnv.UsageEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.UsageEnv.Usage


-- | Type equality and comparison
module GHC.Core.TyCo.Compare

-- | Type equality on source types. Does not look through
--   <tt>newtypes</tt>, <a>PredType</a>s or type families, but it does look
--   through type synonyms. This first checks that the kinds of the types
--   are equal and then checks whether the types are equal, ignoring casts
--   and coercions. (The kind check is a recursive call, but since all
--   kinds have type <tt>Type</tt>, there is no need to check the types of
--   kinds.) See also Note [Non-trivial definitional equality] in
--   <a>GHC.Core.TyCo.Rep</a>.
eqType :: Type -> Type -> Bool

-- | Compare types with respect to a (presumably) non-empty <a>RnEnv2</a>.
eqTypeX :: RnEnv2 -> Type -> Type -> Bool

-- | Type equality on lists of types, looking through type synonyms but not
--   newtypes.
eqTypes :: [Type] -> [Type] -> Bool
nonDetCmpType :: Type -> Type -> Ordering
nonDetCmpTypes :: [Type] -> [Type] -> Ordering
nonDetCmpTypeX :: RnEnv2 -> Type -> Type -> Ordering
nonDetCmpTypesX :: RnEnv2 -> [Type] -> [Type] -> Ordering

-- | Compare two <a>TyCon</a>s. See Note [nonDetCmpType nondeterminism]
nonDetCmpTc :: TyCon -> TyCon -> Ordering
eqVarBndrs :: RnEnv2 -> [Var] -> [Var] -> Maybe RnEnv2

-- | Like <tt>pickyEqTypeVis</tt>, but returns a Bool for convenience
pickyEqType :: Type -> Type -> Bool

-- | tcEqType implements typechecker equality It behaves just like eqType,
--   but is implemented differently (for now)
tcEqType :: HasDebugCallStack => Type -> Type -> Bool
tcEqKind :: HasDebugCallStack => Kind -> Kind -> Bool

-- | Just like <a>tcEqType</a>, but will return True for types of different
--   kinds as long as their non-coercion structure is identical.
tcEqTypeNoKindCheck :: Type -> Type -> Bool

-- | Like <a>tcEqType</a>, but returns True if the <i>visible</i> part of
--   the types are equal, even if they are really unequal (in the invisible
--   bits)
tcEqTypeVis :: Type -> Type -> Bool

-- | Check whether two TyConApps are the same; if the number of arguments
--   are different, just checks the common prefix of arguments.
tcEqTyConApps :: TyCon -> [Type] -> TyCon -> [Type] -> Bool

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
eqForAllVis :: ForAllTyFlag -> ForAllTyFlag -> Bool

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
cmpForAllVis :: ForAllTyFlag -> ForAllTyFlag -> Ordering
instance GHC.Enum.Bounded GHC.Core.TyCo.Compare.TypeOrdering
instance GHC.Enum.Enum GHC.Core.TyCo.Compare.TypeOrdering
instance GHC.Classes.Ord GHC.Core.TyCo.Compare.TypeOrdering
instance GHC.Classes.Eq GHC.Core.TyCo.Compare.TypeOrdering


-- | Core literals
module GHC.Types.Literal

-- | So-called <a>Literal</a>s are one of:
--   
--   <ul>
--   <li>An unboxed numeric literal or floating-point literal which is
--   presumed to be surrounded by appropriate constructors (<tt>Int#</tt>,
--   etc.), so that the overall thing makes sense.</li>
--   </ul>
--   
--   We maintain the invariant that the <a>Integer</a> in the
--   <a>LitNumber</a> constructor is actually in the (possibly
--   target-dependent) range. The mkLit{Int,Word}*Wrap smart constructors
--   ensure this by applying the target machine's wrapping semantics. Use
--   these in situations where you know the wrapping semantics are correct.
--   
--   <ul>
--   <li>The literal derived from the label mentioned in a "foreign label"
--   declaration (<a>LitLabel</a>)</li>
--   <li>A <a>LitRubbish</a> to be used in place of values that are never
--   used.</li>
--   <li>A character</li>
--   <li>A string</li>
--   <li>The NULL pointer</li>
--   </ul>
data Literal

-- | <tt>Char#</tt> - at least 31 bits. Create with <a>mkLitChar</a>
LitChar :: Char -> Literal

-- | Any numeric literal that can be internally represented with an
--   Integer.
LitNumber :: !LitNumType -> !Integer -> Literal

-- | A string-literal: stored and emitted UTF-8 encoded, we'll arrange to
--   decode it at runtime. Also emitted with a <tt>'\0'</tt> terminator.
--   Create with <a>mkLitString</a>
LitString :: !ByteString -> Literal

-- | The <tt>NULL</tt> pointer, the only pointer value that can be
--   represented as a Literal. Create with <a>nullAddrLit</a>
LitNullAddr :: Literal

-- | A nonsense value; See Note [Rubbish literals].
LitRubbish :: TypeOrConstraint -> RuntimeRepType -> Literal

-- | <tt>Float#</tt>. Create with <a>mkLitFloat</a>
LitFloat :: Rational -> Literal

-- | <tt>Double#</tt>. Create with <a>mkLitDouble</a>
LitDouble :: Rational -> Literal

-- | A label literal. Parameters:
--   
--   1) The name of the symbol mentioned in the declaration
--   
--   2) The size (in bytes) of the arguments the label expects. Only
--   applicable with <tt>stdcall</tt> labels. <tt>Just x</tt> =&gt;
--   <tt>&lt;x&gt;</tt> will be appended to label name when emitting
--   assembly.
--   
--   3) Flag indicating whether the symbol references a function or a data
LitLabel :: FastString -> Maybe Int -> FunctionOrData -> Literal

-- | Numeric literal type
data LitNumType

-- | <tt>Bignat</tt> (see Note [BigNum literals])
LitNumBigNat :: LitNumType

-- | <tt>Int#</tt> - according to target machine
LitNumInt :: LitNumType

-- | <tt>Int8#</tt> - exactly 8 bits
LitNumInt8 :: LitNumType

-- | <tt>Int16#</tt> - exactly 16 bits
LitNumInt16 :: LitNumType

-- | <tt>Int32#</tt> - exactly 32 bits
LitNumInt32 :: LitNumType

-- | <tt>Int64#</tt> - exactly 64 bits
LitNumInt64 :: LitNumType

-- | <tt>Word#</tt> - according to target machine
LitNumWord :: LitNumType

-- | <tt>Word8#</tt> - exactly 8 bits
LitNumWord8 :: LitNumType

-- | <tt>Word16#</tt> - exactly 16 bits
LitNumWord16 :: LitNumType

-- | <tt>Word32#</tt> - exactly 32 bits
LitNumWord32 :: LitNumType

-- | <tt>Word64#</tt> - exactly 64 bits
LitNumWord64 :: LitNumType

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>
mkLitInt :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>. If the argument is out
--   of the (target-dependent) range, it is wrapped. See Note [Word<i>Int
--   underflow</i>overflow]
mkLitIntWrap :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>, as well as a
--   <a>Bool</a>ean flag indicating overflow. That is, if the argument is
--   out of the (target-dependent) range the argument is wrapped and the
--   overflow flag will be set. See Note [Word<i>Int underflow</i>overflow]
mkLitIntWrapC :: Platform -> Integer -> (Literal, Bool)

-- | Creates a <a>Literal</a> of type <tt>Int#</tt> without checking its
--   range.
mkLitIntUnchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>
mkLitWord :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>. If the argument is
--   out of the (target-dependent) range, it is wrapped. See Note
--   [Word<i>Int underflow</i>overflow]
mkLitWordWrap :: Platform -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>, as well as a
--   <a>Bool</a>ean flag indicating carry. That is, if the argument is out
--   of the (target-dependent) range the argument is wrapped and the carry
--   flag will be set. See Note [Word<i>Int underflow</i>overflow]
mkLitWordWrapC :: Platform -> Integer -> (Literal, Bool)

-- | Creates a <a>Literal</a> of type <tt>Word#</tt> without checking its
--   range.
mkLitWordUnchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int8#</tt>
mkLitInt8 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int8#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt8Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int8#</tt> without checking its
--   range.
mkLitInt8Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word8#</tt>
mkLitWord8 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word8#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord8Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word8#</tt> without checking its
--   range.
mkLitWord8Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int16#</tt>
mkLitInt16 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int16#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt16Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int16#</tt> without checking its
--   range.
mkLitInt16Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word16#</tt>
mkLitWord16 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word16#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord16Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word16#</tt> without checking its
--   range.
mkLitWord16Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int32#</tt>
mkLitInt32 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int32#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt32Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int32#</tt> without checking its
--   range.
mkLitInt32Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word32#</tt>
mkLitWord32 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word32#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord32Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word32#</tt> without checking its
--   range.
mkLitWord32Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int64#</tt>
mkLitInt64 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int64#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt64Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int64#</tt> without checking its
--   range.
mkLitInt64Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word64#</tt>
mkLitWord64 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word64#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord64Wrap :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word64#</tt> without checking its
--   range.
mkLitWord64Unchecked :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Float#</tt>
mkLitFloat :: Rational -> Literal

-- | Creates a <a>Literal</a> of type <tt>Double#</tt>
mkLitDouble :: Rational -> Literal

-- | Creates a <a>Literal</a> of type <tt>Char#</tt>
mkLitChar :: Char -> Literal

-- | Creates a <a>Literal</a> of type <tt>Addr#</tt>, which is appropriate
--   for passing to e.g. some of the "error" functions in GHC.Err such as
--   <tt>GHC.Err.runtimeError</tt>
mkLitString :: String -> Literal
mkLitBigNat :: Integer -> Literal

-- | Create a numeric <a>Literal</a> of the given type
mkLitNumber :: Platform -> LitNumType -> Integer -> Literal

-- | Make a literal number using wrapping semantics if the value is out of
--   bound.
mkLitNumberWrap :: Platform -> LitNumType -> Integer -> Literal

-- | Find the Haskell <a>Type</a> the literal occupies
literalType :: Literal -> Type
pprLiteral :: (SDoc -> SDoc) -> Literal -> SDoc

-- | Indicate if a numeric literal type supports negative numbers
litNumIsSigned :: LitNumType -> Bool

-- | Get the literal range
litNumRange :: Platform -> LitNumType -> (Maybe Integer, Maybe Integer)

-- | Check that a given number is in the range of a numeric literal
litNumCheckRange :: Platform -> LitNumType -> Integer -> Bool

-- | Wrap a literal number according to its type using wrapping semantics.
litNumWrap :: Platform -> Literal -> Literal

-- | Coerce a literal number into another using wrapping semantics.
litNumCoerce :: LitNumType -> Platform -> Literal -> Literal

-- | Narrow a literal number by converting it into another number type and
--   then converting it back to its original type.
litNumNarrow :: LitNumType -> Platform -> Literal -> Literal

-- | Number of bits
litNumBitSize :: Platform -> LitNumType -> Maybe Word
isMinBound :: Platform -> Literal -> Bool
isMaxBound :: Platform -> Literal -> Bool

-- | True if code space does not go bad if we duplicate this literal
litIsDupable :: Platform -> Literal -> Bool

-- | True if there is absolutely no penalty to duplicating the literal.
--   False principally of strings.
--   
--   "Why?", you say? I'm glad you asked. Well, for one duplicating strings
--   would blow up code sizes. Not only this, it's also unsafe.
--   
--   Consider a program that wants to traverse a string. One way it might
--   do this is to first compute the Addr# pointing to the end of the
--   string, and then, starting from the beginning, bump a pointer using
--   eqAddr# to determine the end. For instance,
--   
--   <pre>
--   -- Given pointers to the start and end of a string, count how many zeros
--   -- the string contains.
--   countZeros :: Addr# -&gt; Addr# -&gt; -&gt; Int
--   countZeros start end = go start 0
--     where
--       go off n
--         | off <tt>addrEq#</tt> end = n
--         | otherwise         = go (off <tt>plusAddr#</tt> 1) n'
--         where n' | isTrue# (indexInt8OffAddr# off 0# ==# 0#) = n + 1
--                  | otherwise                                 = n
--   </pre>
--   
--   Consider what happens if we considered strings to be trivial (and
--   therefore duplicable) and emitted a call like <tt>countZeros "hello"#
--   ("hello"# <tt>plusAddr</tt># 5)</tt>. The beginning and end pointers
--   do not belong to the same string, meaning that an iteration like the
--   above would blow up terribly. This is what happened in #12757.
--   
--   Ultimately the solution here is to make primitive strings a bit more
--   structured, ensuring that the compiler can't inline in ways that will
--   break user code. One approach to this is described in #8472.
litIsTrivial :: Literal -> Bool
litIsLifted :: Literal -> Bool
inCharRange :: Char -> Bool

-- | Tests whether the literal represents a zero of whatever type it is
isZeroLit :: Literal -> Bool

-- | Tests whether the literal represents a one of whatever type it is
isOneLit :: Literal -> Bool
litFitsInChar :: Literal -> Bool

-- | Returns the <a>Integer</a> contained in the <a>Literal</a>, for when
--   that makes sense, i.e. for <a>Char</a> and numbers.
litValue :: Literal -> Integer

-- | Apply a function to the <a>Integer</a> contained in the
--   <a>Literal</a>, for when that makes sense, e.g. for <a>Char</a> and
--   numbers. For fixed-size integral literals, the result will be wrapped
--   in accordance with the semantics of the target type. See Note
--   [Word<i>Int underflow</i>overflow]
mapLitValue :: Platform -> (Integer -> Integer) -> Literal -> Literal

-- | Returns the <a>Integer</a> contained in the <a>Literal</a>, for when
--   that makes sense, i.e. for <a>Char</a> and numbers.
isLitValue_maybe :: Literal -> Maybe Integer
isLitRubbish :: Literal -> Bool
narrowInt8Lit :: Literal -> Literal
narrowInt16Lit :: Literal -> Literal
narrowInt32Lit :: Literal -> Literal
narrowInt64Lit :: Literal -> Literal
narrowWord8Lit :: Literal -> Literal
narrowWord16Lit :: Literal -> Literal
narrowWord32Lit :: Literal -> Literal
narrowWord64Lit :: Literal -> Literal

-- | Extend or narrow a fixed-width literal (e.g. <tt>Int16#</tt>) to a
--   target word-sized literal (<tt>Int#</tt> or <tt>Word#</tt>). Narrowing
--   can only happen on 32-bit architectures when we convert a 64-bit
--   literal into a 32-bit one.
convertToIntLit :: Platform -> Literal -> Literal

-- | Extend or narrow a fixed-width literal (e.g. <tt>Int16#</tt>) to a
--   target word-sized literal (<tt>Int#</tt> or <tt>Word#</tt>). Narrowing
--   can only happen on 32-bit architectures when we convert a 64-bit
--   literal into a 32-bit one.
convertToWordLit :: Platform -> Literal -> Literal
charToIntLit :: Literal -> Literal
intToCharLit :: Literal -> Literal
floatToIntLit :: Literal -> Literal
intToFloatLit :: Literal -> Literal
doubleToIntLit :: Literal -> Literal
intToDoubleLit :: Literal -> Literal
nullAddrLit :: Literal
floatToDoubleLit :: Literal -> Literal
doubleToFloatLit :: Literal -> Literal
instance GHC.Classes.Ord GHC.Types.Literal.LitNumType
instance GHC.Classes.Eq GHC.Types.Literal.LitNumType
instance GHC.Enum.Enum GHC.Types.Literal.LitNumType
instance Data.Data.Data GHC.Types.Literal.LitNumType
instance Data.Data.Data GHC.Types.Literal.Literal
instance GHC.Utils.Binary.Binary GHC.Types.Literal.Literal
instance GHC.Utils.Outputable.Outputable GHC.Types.Literal.Literal
instance GHC.Classes.Eq GHC.Types.Literal.Literal
instance GHC.Classes.Ord GHC.Types.Literal.Literal
instance GHC.Utils.Binary.Binary GHC.Types.Literal.LitNumType

module GHC.Data.TrieMap
data MaybeMap m a
data ListMap m a
type LiteralMap a = Map Literal a
class Functor m => TrieMap m where {
    type Key m :: Type;
}
emptyTM :: TrieMap m => m a
lookupTM :: forall b. TrieMap m => Key m -> m b -> Maybe b
alterTM :: forall b. TrieMap m => Key m -> XT b -> m b -> m b
filterTM :: TrieMap m => (a -> Bool) -> m a -> m a
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
insertTM :: TrieMap m => Key m -> a -> m a -> m a
deleteTM :: TrieMap m => Key m -> m a -> m a
foldMapTM :: (TrieMap m, Monoid r) => (a -> r) -> m a -> r
isEmptyTM :: TrieMap m => m a -> Bool
(>.>) :: (a -> b) -> (b -> c) -> a -> c
infixr 1 >.>
(|>) :: a -> (a -> b) -> b
infixr 1 |>
(|>>) :: TrieMap m2 => (XT (m2 a) -> m1 (m2 a) -> m1 (m2 a)) -> (m2 a -> m2 a) -> m1 (m2 a) -> m1 (m2 a)
infixr 1 |>>
type XT a = Maybe a -> Maybe a
foldMaybe :: (a -> b -> b) -> Maybe a -> b -> b
filterMaybe :: (a -> Bool) -> Maybe a -> Maybe a
data GenMap m a
lkG :: (Eq (Key m), TrieMap m) => Key m -> GenMap m a -> Maybe a
xtG :: (Eq (Key m), TrieMap m) => Key m -> XT a -> GenMap m a -> GenMap m a
mapG :: Functor m => (a -> b) -> GenMap m a -> GenMap m b
fdG :: TrieMap m => (a -> b -> b) -> GenMap m a -> b -> b
xtList :: TrieMap m => (forall b. k -> XT b -> m b -> m b) -> [k] -> XT a -> ListMap m a -> ListMap m a
lkList :: TrieMap m => (forall b. k -> m b -> Maybe b) -> [k] -> ListMap m a -> Maybe a
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable (m a)) => GHC.Utils.Outputable.Outputable (GHC.Data.TrieMap.GenMap m a)
instance GHC.Base.Functor m => GHC.Base.Functor (GHC.Data.TrieMap.GenMap m)
instance (GHC.Classes.Eq (GHC.Data.TrieMap.Key m), GHC.Data.TrieMap.TrieMap m) => GHC.Data.TrieMap.TrieMap (GHC.Data.TrieMap.GenMap m)
instance (GHC.Classes.Eq (GHC.Data.TrieMap.Key m), GHC.Data.TrieMap.TrieMap m) => Data.Foldable.Foldable (GHC.Data.TrieMap.GenMap m)
instance GHC.Base.Functor m => GHC.Base.Functor (GHC.Data.TrieMap.ListMap m)
instance GHC.Data.TrieMap.TrieMap m => GHC.Data.TrieMap.TrieMap (GHC.Data.TrieMap.ListMap m)
instance GHC.Data.TrieMap.TrieMap m => Data.Foldable.Foldable (GHC.Data.TrieMap.ListMap m)
instance (GHC.Data.TrieMap.TrieMap m, GHC.Utils.Outputable.Outputable a) => GHC.Utils.Outputable.Outputable (GHC.Data.TrieMap.ListMap m a)
instance GHC.Base.Functor m => GHC.Base.Functor (GHC.Data.TrieMap.MaybeMap m)
instance GHC.Data.TrieMap.TrieMap m => GHC.Data.TrieMap.TrieMap (GHC.Data.TrieMap.MaybeMap m)
instance GHC.Data.TrieMap.TrieMap m => Data.Foldable.Foldable (GHC.Data.TrieMap.MaybeMap m)
instance GHC.Data.TrieMap.TrieMap Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => GHC.Data.TrieMap.TrieMap (Data.Map.Internal.Map k)
instance GHC.Types.Unique.Uniquable key => GHC.Data.TrieMap.TrieMap (GHC.Types.Unique.DFM.UniqDFM key)

module GHC.Cmm.Dataflow.Label
data Label
data LabelMap v
data LabelSet
type FactBase f = LabelMap f
lookupFact :: Label -> FactBase f -> Maybe f
mkHooplLabel :: Word64 -> Label
instance GHC.Classes.Ord GHC.Cmm.Dataflow.Label.Label
instance GHC.Classes.Eq GHC.Cmm.Dataflow.Label.Label
instance GHC.Base.Semigroup GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Base.Monoid GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Show.Show GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Classes.Ord GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Classes.Eq GHC.Cmm.Dataflow.Label.LabelSet
instance Data.Traversable.Traversable GHC.Cmm.Dataflow.Label.LabelMap
instance Data.Foldable.Foldable GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Base.Functor GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Show.Show v => GHC.Show.Show (GHC.Cmm.Dataflow.Label.LabelMap v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (GHC.Cmm.Dataflow.Label.LabelMap v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (GHC.Cmm.Dataflow.Label.LabelMap v)
instance GHC.Cmm.Dataflow.Collections.IsMap GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Cmm.Dataflow.Label.LabelMap a)
instance GHC.Utils.Outputable.OutputableP env a => GHC.Utils.Outputable.OutputableP env (GHC.Cmm.Dataflow.Label.LabelMap a)
instance GHC.Data.TrieMap.TrieMap GHC.Cmm.Dataflow.Label.LabelMap
instance GHC.Cmm.Dataflow.Collections.IsSet GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Dataflow.Label.LabelSet
instance GHC.Show.Show GHC.Cmm.Dataflow.Label.Label
instance GHC.Types.Unique.Uniquable GHC.Cmm.Dataflow.Label.Label
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Dataflow.Label.Label
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.Dataflow.Label.Label

module GHC.Data.Graph.Collapse

-- | A "supernode" stands for a collection of one or more nodes (basic
--   blocks) that have been coalesced by the Hecht-Ullman algorithm. A
--   collection in a supernode constitutes a <i>reducible</i> subgraph of a
--   control-flow graph. (When an entire control-flow graph is collapsed to
--   a single supernode, the flow graph is reducible.)
--   
--   The idea of node splitting is to collapse a control-flow graph down to
--   a single supernode, then materialize (`<tt>inflate'</tt>) the
--   reducible equivalent graph from that supernode. The <a>Supernode</a>
--   class defines only the methods needed to collapse; rematerialization
--   is the responsiblity of the client.
--   
--   During the Hecht-Ullman algorithm, every supernode has a unique entry
--   point, which is given by <a>superLabel</a>. But this invariant is not
--   guaranteed by the class methods and is not a law of the class. The
--   <a>mapLabels</a> function rewrites all labels that appear in a
--   supernode (both definitions and uses). The <a>freshen</a> function
--   replaces every appearance of a <i>defined</i> label with a fresh
--   label. (Appearances include both definitions and uses.)
--   
--   Laws: <tt> superLabel (n &lt;&gt; n') == superLabel n blocks (n
--   &lt;&gt; n') == blocks n <a>union</a> blocks n' mapLabels f (n
--   &lt;&gt; n') = mapLabels f n &lt;&gt; mapLabels f n' mapLabels id ==
--   id mapLabels (f . g) == mapLabels f . mapLabels g </tt>
--   
--   (We expect <a>freshen</a> to distribute over <a>&lt;&gt;</a>, but
--   because of the fresh names involved, formulating a precise law is a
--   bit challenging.)
class (Semigroup node) => PureSupernode node
superLabel :: PureSupernode node => node -> Label
mapLabels :: PureSupernode node => (Label -> Label) -> node -> node
class (MonadUnique m, PureSupernode node) => Supernode node m
freshen :: Supernode node m => node -> m node

-- | Using the algorithm of Hecht and Ullman (1972), collapse a graph into
--   a single node, splitting nodes as needed. Record visualization events
--   in monad <tt>m</tt>.
collapseInductiveGraph :: (DynGraph gr, Supernode s m, VizCollapseMonad m gr s) => gr s () -> m (gr s ())
class (MonadUniqSM m, Graph gr, Supernode s m) => VizCollapseMonad m gr s
consumeByInGraph :: VizCollapseMonad m gr s => Node -> Node -> gr s () -> m ()
splitGraphAt :: VizCollapseMonad m gr s => gr s () -> LNode s -> m ()
finalGraph :: VizCollapseMonad m gr s => gr s () -> m ()

-- | The identity monad as a <a>VizCollapseMonad</a>. Use this monad when
--   you want efficiency in graph collapse.
newtype NullCollapseViz a
NullCollapseViz :: UniqSM a -> NullCollapseViz a
[unNCV] :: NullCollapseViz a -> UniqSM a
runNullCollapse :: NullCollapseViz a -> UniqSM a

-- | Module : GHC.Data.Graph.Collapse Description : Implement the
--   "collapsing" algorithm Hecht and Ullman
--   
--   A control-flow graph is reducible if and only if it is collapsible
--   according to the definition of Hecht and Ullman (1972). This module
--   implements the collapsing algorithm of Hecht and Ullman, and if it
--   encounters a graph that is not collapsible, it splits nodes until the
--   graph is fully collapsed. It then reports what nodes (if any) had to
--   be split in order to collapse the graph. The information is used
--   upstream to node-split Cmm graphs.
--   
--   The module uses the inductive graph representation cloned from the
--   Functional Graph Library (Hackage package <tt>fgl</tt>, modules
--   <a>*</a>.)
--   
--   If you want to visualize the graph-collapsing algorithm, create an
--   instance of monad <a>VizCollapseMonad</a>. Each step in the algorithm
--   is announced to the monad as a side effect. If you don't care about
--   visualization, you would use the <a>NullCollapseViz</a> monad, in
--   which these operations are no-ops.
class (Monad m) => MonadUniqSM m
liftUniqSM :: MonadUniqSM m => UniqSM a -> m a
instance GHC.Types.Unique.Supply.MonadUnique GHC.Data.Graph.Collapse.NullCollapseViz
instance GHC.Base.Monad GHC.Data.Graph.Collapse.NullCollapseViz
instance GHC.Base.Applicative GHC.Data.Graph.Collapse.NullCollapseViz
instance GHC.Base.Functor GHC.Data.Graph.Collapse.NullCollapseViz
instance (GHC.Data.Graph.Inductive.Graph.Graph gr, GHC.Data.Graph.Collapse.Supernode s GHC.Data.Graph.Collapse.NullCollapseViz) => GHC.Data.Graph.Collapse.VizCollapseMonad GHC.Data.Graph.Collapse.NullCollapseViz gr s
instance GHC.Data.Graph.Collapse.MonadUniqSM GHC.Data.Graph.Collapse.NullCollapseViz

module GHC.Cmm.Dataflow.Graph

-- | A (possibly empty) collection of closed/closed blocks
type Body n = LabelMap (Block n C C)

-- | A control-flow graph, which may take any of four shapes (O/O, O<i>C,
--   C</i>O, C/C). A graph open at the entry has a single, distinguished,
--   anonymous entry point; if a graph is closed at the entry, its entry
--   point(s) are supplied by a context.
type Graph = Graph' Block

-- | <tt>Graph'</tt> is abstracted over the block type, so that we can
--   build graphs of annotated blocks for example (Compiler.Hoopl.Dataflow
--   needs this).
data Graph' block (n :: Extensibility -> Extensibility -> Type) e x
[GNil] :: Graph' block n O O
[GUnit] :: block n O O -> Graph' block n O O
[GMany] :: MaybeO e (block n O C) -> Body' block n -> MaybeO x (block n C O) -> Graph' block n e x

-- | Gives access to the anchor points for nonlocal edges as well as the
--   edges themselves
class NonLocal thing
entryLabel :: NonLocal thing => thing C x -> Label
successors :: NonLocal thing => thing e C -> [Label]
addBlock :: (NonLocal block, HasDebugCallStack) => block C C -> LabelMap (block C C) -> LabelMap (block C C)
bodyList :: Body' block n -> [(Label, block n C C)]
bodyToBlockList :: Body n -> [Block n C C]
emptyBody :: Body' block n
labelsDefined :: forall block n e x. NonLocal (block n) => Graph' block n e x -> LabelSet

-- | Maps over all nodes in a graph.
mapGraph :: (forall e x. n e x -> n' e x) -> Graph n e x -> Graph n' e x

-- | Function <a>mapGraphBlocks</a> enables a change of representation of
--   blocks, nodes, or both. It lifts a polymorphic block transform into a
--   polymorphic graph transform. When the block representation stabilizes,
--   a similar function should be provided for blocks.
mapGraphBlocks :: forall block n block' n' e x. (forall e x. block n e x -> block' n' e x) -> Graph' block n e x -> Graph' block' n' e x

-- | Returns a list of blocks reachable from the provided Labels in the
--   reverse postorder.
--   
--   This is the most important traversal over this data structure. It
--   drops unreachable code and puts blocks in an order that is good for
--   solving forward dataflow problems quickly. The reverse order is good
--   for solving backward dataflow problems quickly. The forward order is
--   also reasonably good for emitting instructions, except that it will
--   not usually exploit Forrest Baskett's trick of eliminating the
--   unconditional branch from a loop. For that you would need a more
--   serious analysis, probably based on dominators, to identify loop
--   headers.
--   
--   For forward analyses we want reverse postorder visitation, consider:
--   <tt> A -&gt; [B,C] B -&gt; D C -&gt; D </tt> Postorder: [D, C, B, A]
--   (or [D, B, C, A]) Reverse postorder: [A, B, C, D] (or [A, C, B, D])
--   This matters for, e.g., forward analysis, because we want to analyze
--   *both* B and C before we analyze D.
revPostorderFrom :: forall block. NonLocal block => LabelMap (block C C) -> Label -> [block C C]
instance GHC.Cmm.Dataflow.Graph.NonLocal n => GHC.Cmm.Dataflow.Graph.NonLocal (GHC.Cmm.Dataflow.Block.Block n)

module GHC.Iface.Type
type IfExtName = Name
type IfLclName = FastString

-- | A kind of universal type, used for types and kinds.
--   
--   Any time a <tt>Type</tt> is pretty-printed, it is first converted to
--   an <a>IfaceType</a> before being printed. See Note [Pretty printing
--   via Iface syntax] in <a>GHC.Types.TyThing.Ppr</a>
data IfaceType
IfaceFreeTyVar :: TyVar -> IfaceType
IfaceTyVar :: IfLclName -> IfaceType
IfaceLitTy :: IfaceTyLit -> IfaceType
IfaceAppTy :: IfaceType -> IfaceAppArgs -> IfaceType
IfaceFunTy :: FunTyFlag -> IfaceMult -> IfaceType -> IfaceType -> IfaceType
IfaceForAllTy :: IfaceForAllBndr -> IfaceType -> IfaceType
IfaceTyConApp :: IfaceTyCon -> IfaceAppArgs -> IfaceType
IfaceCastTy :: IfaceType -> IfaceCoercion -> IfaceType
IfaceCoercionTy :: IfaceCoercion -> IfaceType
IfaceTupleTy :: TupleSort -> PromotionFlag -> IfaceAppArgs -> IfaceType
type IfacePredType = IfaceType
type IfaceKind = IfaceType
data IfaceCoercion
IfaceReflCo :: IfaceType -> IfaceCoercion
IfaceGReflCo :: Role -> IfaceType -> IfaceMCoercion -> IfaceCoercion
IfaceFunCo :: Role -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceTyConAppCo :: Role -> IfaceTyCon -> [IfaceCoercion] -> IfaceCoercion
IfaceAppCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceForAllCo :: IfaceBndr -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceCoVarCo :: IfLclName -> IfaceCoercion
IfaceAxiomInstCo :: IfExtName -> BranchIndex -> [IfaceCoercion] -> IfaceCoercion
IfaceAxiomRuleCo :: IfLclName -> [IfaceCoercion] -> IfaceCoercion
IfaceUnivCo :: IfaceUnivCoProv -> Role -> IfaceType -> IfaceType -> IfaceCoercion
IfaceSymCo :: IfaceCoercion -> IfaceCoercion
IfaceTransCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceSelCo :: CoSel -> IfaceCoercion -> IfaceCoercion
IfaceLRCo :: LeftOrRight -> IfaceCoercion -> IfaceCoercion
IfaceInstCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceKindCo :: IfaceCoercion -> IfaceCoercion
IfaceSubCo :: IfaceCoercion -> IfaceCoercion
IfaceFreeCoVar :: CoVar -> IfaceCoercion

-- | See Note [Holes in IfaceCoercion]
IfaceHoleCo :: CoVar -> IfaceCoercion
data IfaceMCoercion
IfaceMRefl :: IfaceMCoercion
IfaceMCo :: IfaceCoercion -> IfaceMCoercion
data IfaceUnivCoProv
IfacePhantomProv :: IfaceCoercion -> IfaceUnivCoProv
IfaceProofIrrelProv :: IfaceCoercion -> IfaceUnivCoProv
IfacePluginProv :: String -> IfaceUnivCoProv
IfaceCorePrepProv :: Bool -> IfaceUnivCoProv
type IfaceMult = IfaceType
data IfaceTyCon
IfaceTyCon :: IfExtName -> IfaceTyConInfo -> IfaceTyCon
[ifaceTyConName] :: IfaceTyCon -> IfExtName
[ifaceTyConInfo] :: IfaceTyCon -> IfaceTyConInfo
data IfaceTyConInfo
IfaceTyConInfo :: PromotionFlag -> IfaceTyConSort -> IfaceTyConInfo
[ifaceTyConIsPromoted] :: IfaceTyConInfo -> PromotionFlag
[ifaceTyConSort] :: IfaceTyConInfo -> IfaceTyConSort
mkIfaceTyConInfo :: PromotionFlag -> IfaceTyConSort -> IfaceTyConInfo

-- | The various types of TyCons which have special, built-in syntax.
data IfaceTyConSort

-- | a regular tycon
IfaceNormalTyCon :: IfaceTyConSort

-- | a tuple, e.g. <tt>(a, b, c)</tt> or <tt>(#a, b, c#)</tt>. The arity is
--   the tuple width, not the tycon arity (which is twice the width in the
--   case of unboxed tuples).
IfaceTupleTyCon :: !Arity -> !TupleSort -> IfaceTyConSort

-- | an unboxed sum, e.g. <tt>(# a | b | c #)</tt>
IfaceSumTyCon :: !Arity -> IfaceTyConSort

-- | A heterogeneous equality TyCon (i.e. eqPrimTyCon, eqReprPrimTyCon,
--   heqTyCon) that is actually being applied to two types of the same
--   kind. This affects pretty-printing only: see Note [Equality predicates
--   in IfaceType]
IfaceEqualityTyCon :: IfaceTyConSort
data IfaceTyLit
IfaceNumTyLit :: Integer -> IfaceTyLit
IfaceStrTyLit :: FastString -> IfaceTyLit
IfaceCharTyLit :: Char -> IfaceTyLit

-- | Stores the arguments in a type application as a list. See <tt>Note
--   [Suppressing invisible arguments]</tt>.
data IfaceAppArgs
IA_Nil :: IfaceAppArgs
IA_Arg :: IfaceType -> ForAllTyFlag -> IfaceAppArgs -> IfaceAppArgs
type IfaceContext = [IfacePredType]
data IfaceBndr
IfaceIdBndr :: {-# UNPACK #-} !IfaceIdBndr -> IfaceBndr
IfaceTvBndr :: {-# UNPACK #-} !IfaceTvBndr -> IfaceBndr
data IfaceOneShot
IfaceNoOneShot :: IfaceOneShot
IfaceOneShot :: IfaceOneShot
type IfaceLamBndr = (IfaceBndr, IfaceOneShot)
type IfaceTvBndr = (IfLclName, IfaceKind)
type IfaceIdBndr = (IfaceType, IfLclName, IfaceType)
type IfaceTyConBinder = VarBndr IfaceBndr TyConBndrVis
type IfaceForAllSpecBndr = VarBndr IfaceBndr Specificity
type IfaceForAllBndr = VarBndr IfaceBndr ForAllTyFlag

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Specified :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag

-- | Show forall flag
--   
--   Unconditionally show the forall quantifier with
--   (<a>ShowForAllMust</a>) or when (<a>ShowForAllWhen</a>) the names used
--   are free in the binder or when compiling with
--   -fprint-explicit-foralls.
data ShowForAllFlag
ShowForAllMust :: ShowForAllFlag
ShowForAllWhen :: ShowForAllFlag

-- | Make an <a>IfaceForAllBndr</a> from an <a>IfaceTvBndr</a>.
mkIfaceForAllTvBndr :: ForAllTyFlag -> IfaceTvBndr -> IfaceForAllBndr

-- | Build the <a>tyConKind</a> from the binders and the result kind. Keep
--   in sync with <a>mkTyConKind</a> in <a>GHC.Core.TyCon</a>.
mkIfaceTyConKind :: [IfaceTyConBinder] -> IfaceKind -> IfaceKind
ifaceForAllSpecToBndrs :: [IfaceForAllSpecBndr] -> [IfaceForAllBndr]
ifaceForAllSpecToBndr :: IfaceForAllSpecBndr -> IfaceForAllBndr

-- | Extract an <a>IfaceBndr</a> from an <a>IfaceForAllBndr</a>.
ifForAllBndrVar :: IfaceForAllBndr -> IfaceBndr

-- | Extract the variable name from an <a>IfaceForAllBndr</a>.
ifForAllBndrName :: IfaceForAllBndr -> IfLclName
ifaceBndrName :: IfaceBndr -> IfLclName

-- | Extract an <a>IfaceBndr</a> from an <a>IfaceTyConBinder</a>.
ifTyConBinderVar :: IfaceTyConBinder -> IfaceBndr

-- | Extract the variable name from an <a>IfaceTyConBinder</a>.
ifTyConBinderName :: IfaceTyConBinder -> IfLclName

-- | Returns true for Type or (TYPE LiftedRep)
isIfaceLiftedTypeKind :: IfaceKind -> Bool
appArgsIfaceTypes :: IfaceAppArgs -> [IfaceType]
appArgsIfaceTypesForAllTyFlags :: IfaceAppArgs -> [(IfaceType, ForAllTyFlag)]

-- | Do we want to suppress kind annotations on binders? See Note
--   [Suppressing binder signatures]
newtype SuppressBndrSig
SuppressBndrSig :: Bool -> SuppressBndrSig
newtype UseBndrParens
UseBndrParens :: Bool -> UseBndrParens
newtype PrintExplicitKinds
PrintExplicitKinds :: Bool -> PrintExplicitKinds
pprIfaceType :: IfaceType -> SDoc
pprParendIfaceType :: IfaceType -> SDoc
pprPrecIfaceType :: PprPrec -> IfaceType -> SDoc

-- | Prints a context or <tt>()</tt> if empty You give it the context
--   precedence
pprIfaceContext :: PprPrec -> [IfacePredType] -> SDoc

-- | Prints "(C a, D b) =&gt;", including the arrow. Used when we want to
--   print a context in a type, so we use <a>funPrec</a> to decide whether
--   to parenthesise a singleton predicate; e.g. Num a =&gt; a -&gt; a
pprIfaceContextArr :: [IfacePredType] -> SDoc
pprIfaceIdBndr :: IfaceIdBndr -> SDoc
pprIfaceLamBndr :: IfaceLamBndr -> SDoc
pprIfaceTvBndr :: IfaceTvBndr -> SuppressBndrSig -> UseBndrParens -> SDoc
pprIfaceTyConBinders :: SuppressBndrSig -> [IfaceTyConBinder] -> SDoc
pprIfaceBndrs :: [IfaceBndr] -> SDoc
pprIfaceAppArgs :: IfaceAppArgs -> SDoc
pprParendIfaceAppArgs :: IfaceAppArgs -> SDoc
pprIfaceForAllPart :: [IfaceForAllBndr] -> [IfacePredType] -> SDoc -> SDoc

-- | Like <a>pprIfaceForAllPart</a>, but always uses an explicit
--   <tt>forall</tt>.
pprIfaceForAllPartMust :: [IfaceForAllBndr] -> [IfacePredType] -> SDoc -> SDoc

-- | Render the "forall ... ." or "forall ... -&gt;" bit of a type.
pprIfaceForAll :: [IfaceForAllBndr] -> SDoc
pprIfaceSigmaType :: ShowForAllFlag -> IfaceType -> SDoc
pprIfaceTyLit :: IfaceTyLit -> SDoc
pprIfaceCoercion :: IfaceCoercion -> SDoc
pprParendIfaceCoercion :: IfaceCoercion -> SDoc
splitIfaceSigmaTy :: IfaceType -> ([IfaceForAllBndr], [IfacePredType], IfaceType)
pprIfaceTypeApp :: PprPrec -> IfaceTyCon -> IfaceAppArgs -> SDoc
pprUserIfaceForAll :: [IfaceForAllBndr] -> SDoc
pprIfaceCoTcApp :: PprPrec -> IfaceTyCon -> [IfaceCoercion] -> SDoc
pprTyTcApp :: PprPrec -> IfaceTyCon -> IfaceAppArgs -> SDoc
pprIfacePrefixApp :: PprPrec -> SDoc -> [SDoc] -> SDoc
isIfaceRhoType :: IfaceType -> Bool
suppressIfaceInvisibles :: PrintExplicitKinds -> [IfaceTyConBinder] -> [a] -> [a]
stripIfaceInvisVars :: PrintExplicitKinds -> [IfaceTyConBinder] -> [IfaceTyConBinder]
stripInvisArgs :: PrintExplicitKinds -> IfaceAppArgs -> IfaceAppArgs
mkIfaceTySubst :: [(IfLclName, IfaceType)] -> IfaceTySubst
substIfaceTyVar :: IfaceTySubst -> IfLclName -> IfaceType
substIfaceAppArgs :: IfaceTySubst -> IfaceAppArgs -> IfaceAppArgs
inDomIfaceTySubst :: IfaceTySubst -> IfaceTvBndr -> Bool

-- | The type 'Many :: Multiplicity'.
many_ty :: IfaceType
pprTypeArrow :: FunTyFlag -> IfaceMult -> SDoc
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyLit
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyConSort
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyConInfo
instance GHC.Classes.Eq GHC.Iface.Type.IfaceTyCon
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceBndr
instance GHC.Base.Semigroup GHC.Iface.Type.IfaceAppArgs
instance GHC.Base.Monoid GHC.Iface.Type.IfaceAppArgs
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceBndr
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceType
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceAppArgs
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceCoercion
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceAppArgs
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceType
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceMCoercion
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceCoercion
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceUnivCoProv
instance GHC.Utils.Binary.Binary (GHC.Types.Basic.DefMethSpec GHC.Iface.Type.IfaceType)
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceType
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceCoercion
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceUnivCoProv
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceMCoercion
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceBndr
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceAppArgs
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyCon
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyCon
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyCon
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyConInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyConInfo
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyConInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyConSort
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyConSort
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyConSort
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceTyLit
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceTyLit
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceTyLit
instance GHC.Utils.Outputable.Outputable GHC.Iface.Type.IfaceOneShot
instance GHC.Utils.Binary.Binary GHC.Iface.Type.IfaceOneShot
instance Control.DeepSeq.NFData GHC.Iface.Type.IfaceOneShot


-- | Pretty-printing types and coercions.
module GHC.Core.TyCo.Ppr

-- | A general-purpose pretty-printing precedence type.
newtype PprPrec
PprPrec :: Int -> PprPrec
topPrec :: PprPrec
sigPrec :: PprPrec
opPrec :: PprPrec
funPrec :: PprPrec
appPrec :: PprPrec
maybeParen :: PprPrec -> PprPrec -> SDoc -> SDoc
pprType :: Type -> SDoc
pprParendType :: Type -> SDoc
pprTidiedType :: Type -> SDoc
pprPrecType :: PprPrec -> Type -> SDoc
pprPrecTypeX :: TidyEnv -> PprPrec -> Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc
pprTCvBndr :: ForAllTyBinder -> SDoc
pprTCvBndrs :: [ForAllTyBinder] -> SDoc
pprSigmaType :: Type -> SDoc
pprTheta :: ThetaType -> SDoc
pprParendTheta :: ThetaType -> SDoc
pprForAll :: [ForAllTyBinder] -> SDoc

-- | Print a user-level forall; see <tt>Note [When to print foralls]</tt>
--   in <a>GHC.Iface.Type</a>.
pprUserForAll :: [ForAllTyBinder] -> SDoc
pprTyVar :: TyVar -> SDoc
pprTyVars :: [TyVar] -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
pprClassPred :: Class -> [Type] -> SDoc
pprKind :: Kind -> SDoc
pprParendKind :: Kind -> SDoc
pprTyLit :: TyLit -> SDoc
pprDataCons :: TyCon -> SDoc

-- | Display all kind information (with <tt>-fprint-explicit-kinds</tt>)
--   when the provided <a>Bool</a> argument is <a>True</a>. See <tt>Note
--   [Kind arguments in error messages]</tt> in <a>GHC.Tc.Errors</a>.
pprWithExplicitKindsWhen :: Bool -> SDoc -> SDoc

-- | This variant preserves any use of TYPE in a type, effectively locally
--   setting -fprint-explicit-runtime-reps.
pprWithTYPE :: Type -> SDoc

-- | Pretty prints a <a>TyCon</a>, using the family instance in case of a
--   representation tycon. For example:
--   
--   <pre>
--   data T [a] = ...
--   </pre>
--   
--   In that case we want to print <tt>T [a]</tt>, where <tt>T</tt> is the
--   family <a>TyCon</a>
pprSourceTyCon :: TyCon -> SDoc
pprCo :: Coercion -> SDoc
pprParendCo :: Coercion -> SDoc

-- | debugPprType is a simple pretty printer that prints a type without
--   going through IfaceType. It does not format as prettily as the normal
--   route, but it's much more direct, and that can be useful for
--   debugging. E.g. with -dppr-debug it prints the kind on type-variable
--   <i>occurrences</i> which the normal route fundamentally cannot do.
debugPprType :: Type -> SDoc

module GHC.Core.PatSyn

-- | Pattern Synonym
--   
--   See Note [Pattern synonym representation] See Note [Pattern synonym
--   signature contexts]
data PatSyn
type PatSynMatcher = (Name, Type, Bool)
type PatSynBuilder = Maybe (Name, Type, Bool)

-- | Build a new pattern synonym
mkPatSyn :: Name -> Bool -> ([InvisTVBinder], ThetaType) -> ([InvisTVBinder], ThetaType) -> [FRRType] -> Type -> PatSynMatcher -> PatSynBuilder -> [FieldLabel] -> PatSyn

-- | The <a>Name</a> of the <a>PatSyn</a>, giving it a unique, rooted
--   identification
patSynName :: PatSyn -> Name

-- | Arity of the pattern synonym
patSynArity :: PatSyn -> Arity

-- | Should the <a>PatSyn</a> be presented infix?
patSynIsInfix :: PatSyn -> Bool
patSynResultType :: PatSyn -> Type

-- | Is this a 'vanilla' pattern synonym (no existentials, no provided
--   constraints)?
isVanillaPatSyn :: PatSyn -> Bool
patSynArgs :: PatSyn -> [Type]
patSynMatcher :: PatSyn -> PatSynMatcher
patSynBuilder :: PatSyn -> PatSynBuilder
patSynUnivTyVarBinders :: PatSyn -> [InvisTVBinder]
patSynExTyVars :: PatSyn -> [TyVar]
patSynExTyVarBinders :: PatSyn -> [InvisTVBinder]
patSynSig :: PatSyn -> ([TyVar], ThetaType, [TyVar], ThetaType, [Scaled Type], Type)
patSynSigBndr :: PatSyn -> ([InvisTVBinder], ThetaType, [InvisTVBinder], ThetaType, [Scaled Type], Type)
patSynInstArgTys :: PatSyn -> [Type] -> [Type]
patSynInstResTy :: PatSyn -> [Type] -> Type
patSynFieldLabels :: PatSyn -> [FieldLabel]

-- | Extract the type for any given labelled field of the <tt>DataCon</tt>
patSynFieldType :: PatSyn -> FieldLabelString -> Type

-- | Print the type of a pattern synonym. The foralls are printed
--   explicitly
pprPatSynType :: PatSyn -> SDoc
instance GHC.Classes.Eq GHC.Core.PatSyn.PatSyn
instance GHC.Types.Unique.Uniquable GHC.Core.PatSyn.PatSyn
instance GHC.Types.Name.NamedThing GHC.Core.PatSyn.PatSyn
instance GHC.Utils.Outputable.Outputable GHC.Core.PatSyn.PatSyn
instance GHC.Utils.Outputable.OutputableBndr GHC.Core.PatSyn.PatSyn
instance Data.Data.Data GHC.Core.PatSyn.PatSyn


-- | <a>RoughMap</a> is an approximate finite map data structure keyed on
--   <tt>[<a>RoughMatchTc</a>]</tt>. This is useful when keying maps on
--   lists of <a>Type</a>s (e.g. an instance head).
module GHC.Core.RoughMap
data RoughMatchTc
RM_KnownTc :: Name -> RoughMatchTc
RM_WildCard :: RoughMatchTc
isRoughWildcard :: RoughMatchTc -> Bool
typeToRoughMatchTc :: Type -> RoughMatchTc
data RoughMatchLookupTc

-- | The position only matches the specified KnownTc
RML_KnownTc :: Name -> RoughMatchLookupTc

-- | The position definitely doesn't match any KnownTc
RML_NoKnownTc :: RoughMatchLookupTc

-- | The position can match anything
RML_WildCard :: RoughMatchLookupTc
typeToRoughMatchLookupTc :: Type -> RoughMatchLookupTc
roughMatchTcToLookup :: RoughMatchTc -> RoughMatchLookupTc
roughMatchTcs :: [Type] -> [RoughMatchTc]
roughMatchTcsLookup :: [Type] -> [RoughMatchLookupTc]
instanceCantMatch :: [RoughMatchTc] -> [RoughMatchTc] -> Bool

-- | Trie of <tt>[RoughMatchTc]</tt>
--   
--   <ul>
--   <li>Examples* <tt> insert [OtherTc] 1 insert [OtherTc] 2 lookup
--   [OtherTc] == [1,2] </tt></li>
--   </ul>
data RoughMap a
emptyRM :: RoughMap a

-- | Order of result is deterministic.
lookupRM :: [RoughMatchLookupTc] -> RoughMap a -> [a]

-- | N.B. Returns a <a>Bag</a> for matches, which allows us to avoid
--   rebuilding all of the lists we find in <a>rm_empty</a>, which would
--   otherwise be necessary due to <a>++</a> if we returned a list. We use
--   a list for unifiers because the tail is computed lazily and we often
--   only care about the first couple of potential unifiers. Constructing a
--   bag forces the tail which performs much too much work.
--   
--   See Note [Matching a RoughMap] See Note [Matches vs Unifiers]
lookupRM' :: [RoughMatchLookupTc] -> RoughMap a -> (Bag a, [a])
insertRM :: [RoughMatchTc] -> a -> RoughMap a -> RoughMap a
filterRM :: (a -> Bool) -> RoughMap a -> RoughMap a

-- | Filter all elements that might match a particular key with the given
--   predicate.
filterMatchingRM :: (a -> Bool) -> [RoughMatchTc] -> RoughMap a -> RoughMap a
elemsRM :: RoughMap a -> [a]
sizeRM :: RoughMap a -> Int
foldRM :: (a -> b -> b) -> b -> RoughMap a -> b
unionRM :: RoughMap a -> RoughMap a -> RoughMap a
instance Data.Data.Data GHC.Core.RoughMap.RoughMatchTc
instance Data.Data.Data GHC.Core.RoughMap.RoughMatchLookupTc
instance GHC.Base.Functor GHC.Core.RoughMap.RoughMap
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.RoughMap.RoughMap a)
instance GHC.Utils.Outputable.Outputable GHC.Core.RoughMap.RoughMatchLookupTc
instance GHC.Utils.Outputable.Outputable GHC.Core.RoughMap.RoughMatchTc


-- | Module for (a) type kinds and (b) type coercions, as used in System
--   FC. See <a>Expr</a> for more on System FC and how coercions fit into
--   it.
module GHC.Core.Coercion

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion
type CoercionN = Coercion
type CoercionR = Coercion
type CoercionP = Coercion

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionN = MCoercion
type MCoercionR = MCoercion
data CoSel
SelTyCon :: Int -> Role -> CoSel
SelFun :: FunSel -> CoSel
SelForAll :: CoSel
data FunSel
SelMult :: FunSel
SelArg :: FunSel
SelRes :: FunSel

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
coHoleCoVar :: CoercionHole -> CoVar
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Coercion Variable
type CoVar = Id

-- | Type or Coercion Variable
type TyCoVar = Id

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
ltRole :: Role -> Role -> Bool
coVarRType :: HasDebugCallStack => CoVar -> Type
coVarLType :: HasDebugCallStack => CoVar -> Type
coVarTypes :: HasDebugCallStack => CoVar -> Pair Type
coVarKind :: CoVar -> Type
coVarKindsTypesRole :: HasDebugCallStack => CoVar -> (Kind, Kind, Type, Type, Role)
coVarRole :: CoVar -> Role
coercionType :: Coercion -> Type

-- | Makes a coercion type from two types: the types whose equality is
--   proven by the relevant <a>Coercion</a>
mkCoercionType :: Role -> Type -> Type -> Type

-- | If it is the case that
--   
--   <pre>
--   c :: (t1 ~ t2)
--   </pre>
--   
--   i.e. the kind of <tt>c</tt> relates <tt>t1</tt> and <tt>t2</tt>, then
--   <tt>coercionKind c = Pair t1 t2</tt>.
coercionKind :: Coercion -> Pair Type
coercionLKind :: Coercion -> Type
coercionRKind :: Coercion -> Type

-- | Apply <a>coercionKind</a> to multiple <a>Coercion</a>s
coercionKinds :: [Coercion] -> Pair [Type]

-- | Retrieve the role from a coercion.
coercionRole :: Coercion -> Role

-- | Get a coercion's kind and role.
coercionKindRole :: Coercion -> (Pair Type, Role)

-- | Make a generalized reflexive coercion
mkGReflCo :: Role -> Type -> MCoercionN -> Coercion

-- | Make a reflexive coercion
mkReflCo :: Role -> Type -> Coercion

-- | Make a representational reflexive coercion
mkRepReflCo :: Type -> Coercion

-- | Make a nominal reflexive coercion
mkNomReflCo :: Type -> Coercion
mkCoVarCo :: CoVar -> Coercion
mkCoVarCos :: [CoVar] -> [Coercion]
mkAxInstCo :: Role -> CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Coercion
mkUnbranchedAxInstCo :: Role -> CoAxiom Unbranched -> [Type] -> [Coercion] -> Coercion
mkAxInstRHS :: CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type
mkUnbranchedAxInstRHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Return the left-hand type of the axiom, when the axiom is instantiated
--   at the types given.
mkAxInstLHS :: CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type

-- | Instantiate the left-hand side of an unbranched axiom
mkUnbranchedAxInstLHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Make a forall <a>Coercion</a>, where both types related by the
--   coercion are quantified over the same variable.
mkPiCo :: Role -> Var -> Coercion -> Coercion
mkPiCos :: Role -> [Var] -> Coercion -> Coercion
mkCoCast :: Coercion -> CoercionR -> Coercion

-- | Create a symmetric version of the given <a>Coercion</a> that asserts
--   equality between the same types but in the other "direction", so a
--   kind of <tt>t1 ~ t2</tt> becomes the kind <tt>t2 ~ t1</tt>.
mkSymCo :: Coercion -> Coercion

-- | Create a new <a>Coercion</a> by composing the two given
--   <a>Coercion</a>s transitively. (co1 ; co2)
mkTransCo :: Coercion -> Coercion -> Coercion
mkSelCo :: HasDebugCallStack => CoSel -> Coercion -> Coercion

-- | Extract the nth field of a FunCo
getNthFun :: FunSel -> a -> a -> a -> a
getNthFromType :: HasDebugCallStack => CoSel -> Type -> Type
mkLRCo :: LeftOrRight -> Coercion -> Coercion

-- | Instantiates a <a>Coercion</a>.
mkInstCo :: Coercion -> CoercionN -> Coercion

-- | Apply a <a>Coercion</a> to another <a>Coercion</a>. The second
--   coercion must be Nominal, unless the first is Phantom. If the first is
--   Phantom, then the second can be either Phantom or Nominal.
mkAppCo :: Coercion -> Coercion -> Coercion

-- | Applies multiple <a>Coercion</a>s to another <a>Coercion</a>, from
--   left to right. See also <a>mkAppCo</a>.
mkAppCos :: Coercion -> [Coercion] -> Coercion

-- | Apply a type constructor to a list of coercions. It is the caller's
--   responsibility to get the roles correct on argument coercions.
mkTyConAppCo :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Coercion

-- | Build a function <a>Coercion</a> from two other <a>Coercion</a>s. That
--   is, given <tt>co1 :: a ~ b</tt> and <tt>co2 :: x ~ y</tt> produce
--   <tt>co :: (a -&gt; x) ~ (b -&gt; y)</tt> or <tt>(a =&gt; x) ~ (b =&gt;
--   y)</tt>, depending on the kind of <tt>a</tt>/<tt>b</tt>. This (most
--   common) version takes a single FunTyFlag, which is used for both
--   fco_afl and ftf_afr of the FunCo
mkFunCo1 :: HasDebugCallStack => Role -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunCo2 :: HasDebugCallStack => Role -> FunTyFlag -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunCoNoFTF :: HasDebugCallStack => Role -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunResCo :: Role -> Id -> Coercion -> Coercion
mkNakedFunCo1 :: Role -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkNakedFunCo2 :: Role -> FunTyFlag -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion

-- | Make a Coercion from a tycovar, a kind coercion, and a body coercion.
--   The kind of the tycovar should be the left-hand kind of the kind
--   coercion. See Note [Unused coercion variable in ForAllCo]
mkForAllCo :: TyCoVar -> CoercionN -> Coercion -> Coercion

-- | Make nested ForAllCos
mkForAllCos :: [(TyCoVar, CoercionN)] -> Coercion -> Coercion

-- | Make a Coercion quantified over a type/coercion variable; the variable
--   has the same type in both sides of the coercion
mkHomoForAllCos :: [TyCoVar] -> Coercion -> Coercion

-- | Make a phantom coercion between two types. The coercion passed in must
--   be a nominal coercion between the kinds of the types.
mkPhantomCo :: Coercion -> Type -> Type -> Coercion

-- | Make a coercion from a coercion hole
mkHoleCo :: CoercionHole -> Coercion

-- | Make a universal coercion between two arbitrary types.
mkUnivCo :: UnivCoProvenance -> Role -> Type -> Type -> Coercion
mkSubCo :: HasDebugCallStack => Coercion -> Coercion
mkAxiomInstCo :: CoAxiom Branched -> BranchIndex -> [Coercion] -> Coercion

-- | Make a "coercion between coercions".
mkProofIrrelCo :: Role -> CoercionN -> Coercion -> Coercion -> Coercion

-- | Like <a>downgradeRole_maybe</a>, but panics if the change isn't a
--   downgrade. See Note [Role twiddling functions]
downgradeRole :: Role -> Role -> Coercion -> Coercion
mkAxiomRuleCo :: CoAxiomRule -> [Coercion] -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, produces <tt>co' ::
--   ty ~r (ty |&gt; co)</tt>
mkGReflRightCo :: Role -> Type -> CoercionN -> Coercion

-- | Given <tt>r</tt>, <tt>ty :: k1</tt>, and <tt>co :: k1 ~N k2</tt>,
--   produces <tt>co' :: (ty |&gt; co) ~r ty</tt>
mkGReflLeftCo :: Role -> Type -> CoercionN -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty ~r
--   ty'</tt>, produces @co' :: (ty |&gt; co) ~r ty' It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceLeftCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty' ~r
--   ty</tt>, produces @co' :: ty' ~r (ty |&gt; co) It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceRightCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>co :: (a :: k) ~ (b :: k')</tt> produce <tt>co' :: k ~
--   k'</tt>.
mkKindCo :: Coercion -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind g h1 h2</tt>, where <tt>g :: t1 ~r t2</tt>,
--   has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt> and
--   <tt>h2</tt> must be nominal. It calls <tt>coercionKindRole</tt>, so
--   it's quite inefficient (which <tt>I</tt> stands for) Use
--   <tt>castCoercionKind2</tt> instead if <tt>t1</tt>, <tt>t2</tt>, and
--   <tt>r</tt> are known beforehand.
castCoercionKind :: Coercion -> CoercionN -> CoercionN -> Coercion

-- | <tt>castCoercionKind1 g r t1 t2 h</tt> = <tt>coercionKind g r t1 t2 h
--   h</tt> That is, it's a specialised form of castCoercionKind, where the
--   two kind coercions are identical <tt>castCoercionKind1 g r t1 t2
--   h</tt>, where <tt>g :: t1 ~r t2</tt>, has type <tt>(t1 |&gt; h) ~r (t2
--   |&gt; h)</tt>. <tt>h</tt> must be nominal. See Note
--   [castCoercionKind1]
castCoercionKind1 :: Coercion -> Role -> Type -> Type -> CoercionN -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind2 g r t1 t2 h1 h2</tt>, where <tt>g :: t1 ~r
--   t2</tt>, has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt>
--   and <tt>h2</tt> must be nominal.
castCoercionKind2 :: Coercion -> Role -> Type -> Type -> CoercionN -> CoercionN -> Coercion

-- | Creates a primitive type equality predicate. Invariant: the types are
--   not Coercions
mkPrimEqPred :: Type -> Type -> Type
mkReprPrimEqPred :: Type -> Type -> Type

-- | Makes a lifted equality predicate at the given role
mkPrimEqPredRole :: Role -> Type -> Type -> PredType

-- | Creates a primitive type equality predicate with explicit kinds
mkHeteroPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | Creates a primitive representational type equality predicate with
--   explicit kinds
mkHeteroReprPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | If `instNewTyCon_maybe T ts = Just (rep_ty, co)` then `co :: T ts ~R#
--   rep_ty`
--   
--   Checks for a newtype, and for being saturated
instNewTyCon_maybe :: TyCon -> [Type] -> Maybe (Type, Coercion)

-- | A function to check if we can reduce a type by one step. Used with
--   <a>topNormaliseTypeX</a>.
type NormaliseStepper ev = RecTcChecker -> TyCon -> [Type] -> NormaliseStepResult ev

-- | The result of stepping in a normalisation function. See
--   <a>topNormaliseTypeX</a>.
data NormaliseStepResult ev

-- | Nothing more to do
NS_Done :: NormaliseStepResult ev

-- | Utter failure. The outer function should fail too.
NS_Abort :: NormaliseStepResult ev

-- | We stepped, yielding new bits; ^ ev is evidence; Usually a co :: old
--   type ~ new type
NS_Step :: RecTcChecker -> Type -> ev -> NormaliseStepResult ev

-- | Try one stepper and then try the next, if the first doesn't make
--   progress. So if it returns NS_Done, it means that both steppers are
--   satisfied
composeSteppers :: NormaliseStepper ev -> NormaliseStepper ev -> NormaliseStepper ev

-- | A <a>NormaliseStepper</a> that unwraps newtypes, careful not to fall
--   into a loop. If it would fall into a loop, it produces
--   <a>NS_Abort</a>.
unwrapNewTypeStepper :: NormaliseStepper Coercion

-- | Sometimes we want to look through a <tt>newtype</tt> and get its
--   associated coercion. This function strips off <tt>newtype</tt> layers
--   enough to reveal something that isn't a <tt>newtype</tt>.
--   Specifically, here's the invariant:
--   
--   <pre>
--   topNormaliseNewType_maybe rec_nts ty = Just (co, ty')
--   </pre>
--   
--   then (a) <tt>co : ty ~R ty'</tt>. (b) ty' is not a newtype.
--   
--   The function returns <tt>Nothing</tt> for non-<tt>newtypes</tt>, or
--   unsaturated applications
--   
--   This function does *not* look through type families, because it has no
--   access to the type family environment. If you do have that at hand,
--   consider to use topNormaliseType_maybe, which should be a drop-in
--   replacement for topNormaliseNewType_maybe If topNormliseNewType_maybe
--   ty = Just (co, ty'), then co : ty ~R ty'
topNormaliseNewType_maybe :: Type -> Maybe (Coercion, Type)

-- | A general function for normalising the top-level of a type. It
--   continues to use the provided <a>NormaliseStepper</a> until that
--   function fails, and then this function returns. The roles of the
--   coercions produced by the <a>NormaliseStepper</a> must all be the
--   same, which is the role returned from the call to
--   <a>topNormaliseTypeX</a>.
--   
--   Typically ev is Coercion.
--   
--   If topNormaliseTypeX step plus ty = Just (ev, ty') then ty ~ev1~ t1
--   ~ev2~ t2 ... ~evn~ ty' and ev = ev1 <tt>plus</tt> ev2 <tt>plus</tt>
--   ... <tt>plus</tt> evn If it returns Nothing then no newtype unwrapping
--   could happen
topNormaliseTypeX :: NormaliseStepper ev -> (ev -> ev -> ev) -> Type -> Maybe (ev, Type)

-- | This breaks a <a>Coercion</a> with type <tt>T A B C ~ T D E F</tt>
--   into a list of <a>Coercion</a>s of kinds <tt>A ~ D</tt>, <tt>B ~
--   E</tt> and <tt>E ~ F</tt>. Hence:
--   
--   <pre>
--   decomposeCo 3 c [r1, r2, r3] = [nth r1 0 c, nth r2 1 c, nth r3 2 c]
--   </pre>
decomposeCo :: Arity -> Coercion -> Infinite Role -> [Coercion]
decomposeFunCo :: HasDebugCallStack => Coercion -> (CoercionN, Coercion, Coercion)
decomposePiCos :: HasDebugCallStack => CoercionN -> Pair Type -> [Type] -> ([CoercionN], CoercionN)

-- | Extract a covar, if possible. This check is dirty. Be ashamed of
--   yourself. (It's dirty because it cares about the structure of a
--   coercion, which is morally reprehensible.)
getCoVar_maybe :: Coercion -> Maybe CoVar

-- | Attempt to take a coercion application apart.
splitAppCo_maybe :: Coercion -> Maybe (Coercion, Coercion)
splitFunCo_maybe :: Coercion -> Maybe (Coercion, Coercion)
splitForAllCo_maybe :: Coercion -> Maybe (TyCoVar, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for tyvar
--   binder
splitForAllCo_ty_maybe :: Coercion -> Maybe (TyVar, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for covar
--   binder
splitForAllCo_co_maybe :: Coercion -> Maybe (CoVar, Coercion, Coercion)
tyConRole :: Role -> TyCon -> Int -> Role
tyConRolesX :: Role -> TyCon -> Infinite Role
tyConRolesRepresentational :: TyCon -> Infinite Role

-- | Converts a coercion to be nominal, if possible. See Note [Role
--   twiddling functions]
setNominalRole_maybe :: Role -> Coercion -> Maybe CoercionN
tyConRoleListX :: Role -> TyCon -> [Role]
tyConRoleListRepresentational :: TyCon -> [Role]
funRole :: Role -> FunSel -> Role
pickLR :: LeftOrRight -> (a, a) -> a

-- | Tests if this coercion is obviously a generalized reflexive coercion.
--   Guaranteed to work very quickly.
isGReflCo :: Coercion -> Bool

-- | Tests if this coercion is obviously reflexive. Guaranteed to work very
--   quickly. Sometimes a coercion can be reflexive, but not obviously so.
--   c.f. <a>isReflexiveCo</a>
isReflCo :: Coercion -> Bool

-- | Returns the type coerced if this coercion is reflexive. Guaranteed to
--   work very quickly. Sometimes a coercion can be reflexive, but not
--   obviously so. c.f. <a>isReflexiveCo_maybe</a>
isReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Returns the type coerced if this coercion is a generalized reflexive
--   coercion. Guaranteed to work very quickly.
isGReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Slowly checks if the coercion is reflexive. Don't call this in a loop,
--   as it walks over the entire coercion.
isReflexiveCo :: Coercion -> Bool

-- | Extracts the coerced type from a reflexive coercion. This potentially
--   walks over the entire coercion, so avoid doing this in a loop.
isReflexiveCo_maybe :: Coercion -> Maybe (Type, Role)
isReflCoVar_maybe :: Var -> Maybe Coercion

-- | Tests if this MCoercion is obviously generalized reflexive Guaranteed
--   to work very quickly.
isGReflMCo :: MCoercion -> Bool
mkGReflLeftMCo :: Role -> Type -> MCoercionN -> Coercion
mkGReflRightMCo :: Role -> Type -> MCoercionN -> Coercion

-- | Like <a>mkCoherenceRightCo</a>, but with an <a>MCoercion</a>
mkCoherenceRightMCo :: Role -> Type -> MCoercionN -> Coercion -> Coercion
coToMCo :: Coercion -> MCoercion

-- | Compose two MCoercions via transitivity
mkTransMCo :: MCoercion -> MCoercion -> MCoercion
mkTransMCoL :: MCoercion -> Coercion -> MCoercion
mkTransMCoR :: Coercion -> MCoercion -> MCoercion

-- | Cast a type by an <a>MCoercion</a>
mkCastTyMCo :: Type -> MCoercion -> Type

-- | Get the reverse of an <a>MCoercion</a>
mkSymMCo :: MCoercion -> MCoercion
mkHomoForAllMCo :: TyCoVar -> MCoercion -> MCoercion
mkFunResMCo :: Id -> MCoercionR -> MCoercionR
mkPiMCos :: [Var] -> MCoercion -> MCoercion
isReflMCo :: MCoercion -> Bool
checkReflexiveMCo :: MCoercion -> MCoercion
mkCoVar :: Name -> Type -> CoVar

-- | Is this a coercion variable? Satisfies <tt><a>isId</a> v ==&gt;
--   <a>isCoVar</a> v == not (<a>isNonCoVarId</a> v)</tt>.
isCoVar :: Var -> Bool
coVarName :: CoVar -> Name
setCoVarName :: CoVar -> Name -> CoVar
setCoVarUnique :: CoVar -> Unique -> CoVar
tyCoVarsOfCo :: Coercion -> TyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet
coVarsOfCo :: Coercion -> CoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
coercionSize :: Coercion -> Int
anyFreeVarsOfCo :: (TyCoVar -> Bool) -> Coercion -> Bool

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion
emptyCvSubstEnv :: CvSubstEnv
lookupCoVar :: Subst -> Var -> Maybe Coercion

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasDebugCallStack => Subst -> [Coercion] -> [Coercion]
substCoVar :: Subst -> CoVar -> Coercion
substCoVars :: Subst -> [CoVar] -> [Coercion]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasDebugCallStack => [TyVar] -> [Type] -> Coercion -> Coercion
substCoVarBndr :: HasDebugCallStack => Subst -> CoVar -> (Subst, CoVar)
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
getCvSubstEnv :: Subst -> CvSubstEnv

-- | <tt>liftCoSubst role lc ty</tt> produces a coercion (at role
--   <tt>role</tt>) that coerces between <tt>lc_left(ty)</tt> and
--   <tt>lc_right(ty)</tt>, where <tt>lc_left</tt> is a substitution
--   mapping type variables to the left-hand types of the mapped coercions
--   in <tt>lc</tt>, and similar for <tt>lc_right</tt>.
liftCoSubst :: HasDebugCallStack => Role -> LiftingContext -> Type -> Coercion
liftCoSubstTyVar :: LiftingContext -> Role -> TyVar -> Maybe Coercion
liftCoSubstWith :: Role -> [TyCoVar] -> [Coercion] -> Type -> Coercion
liftCoSubstWithEx :: Role -> [TyVar] -> [Coercion] -> [TyCoVar] -> [Type] -> (Type -> Coercion, [Type])
emptyLiftingContext :: InScopeSet -> LiftingContext

-- | Extend a lifting context with a new mapping.
extendLiftingContext :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext

-- | Extend a lifting context with a new mapping, and extend the in-scope
--   set
extendLiftingContextAndInScope :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext
liftCoSubstVarBndrUsing :: (r -> CoercionN) -> (LiftingContext -> Type -> r) -> LiftingContext -> TyCoVar -> (LiftingContext, TyCoVar, r)

-- | Is a var in the domain of a lifting context?
isMappedByLC :: TyCoVar -> LiftingContext -> Bool
mkSubstLiftingContext :: Subst -> LiftingContext

-- | Erase the environments in a lifting context
zapLiftingContext :: LiftingContext -> LiftingContext

-- | Like <a>substForAllCoBndr</a>, but works on a lifting context
substForAllCoBndrUsingLC :: Bool -> (Coercion -> Coercion) -> LiftingContext -> TyCoVar -> Coercion -> (LiftingContext, TyCoVar, Coercion)

-- | Extract the underlying substitution from the LiftingContext
lcSubst :: LiftingContext -> Subst

-- | Get the <a>InScopeSet</a> from a <a>LiftingContext</a>
lcInScopeSet :: LiftingContext -> InScopeSet
type LiftCoEnv = VarEnv Coercion
data LiftingContext
LC :: Subst -> LiftCoEnv -> LiftingContext
liftEnvSubstLeft :: Subst -> LiftCoEnv -> Subst
liftEnvSubstRight :: Subst -> LiftCoEnv -> Subst
substRightCo :: LiftingContext -> Coercion -> Coercion
substLeftCo :: LiftingContext -> Coercion -> Coercion

-- | Apply "sym" to all coercions in a <a>LiftCoEnv</a>
swapLiftCoEnv :: LiftCoEnv -> LiftCoEnv
lcSubstLeft :: LiftingContext -> Subst
lcSubstRight :: LiftingContext -> Subst

-- | Syntactic equality of coercions
eqCoercion :: Coercion -> Coercion -> Bool

-- | Compare two <a>Coercion</a>s, with respect to an RnEnv2
eqCoercionX :: RnEnv2 -> Coercion -> Coercion -> Bool
seqCo :: Coercion -> ()
pprCo :: Coercion -> SDoc
pprParendCo :: Coercion -> SDoc
pprCoAxiom :: CoAxiom br -> SDoc
pprCoAxBranch :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchLHS :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchUser :: TyCon -> CoAxBranch -> SDoc
tidyCoAxBndrsForUser :: TidyEnv -> [Var] -> (TidyEnv, [Var])
etaExpandCoAxBranch :: CoAxBranch -> ([TyVar], [Type], Type)

-- | Tidy a Coercion
--   
--   See Note [Strictness in tidyType and friends]
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]

-- | like mkKindCo, but aggressively &amp; recursively optimizes to avoid
--   using a KindCo constructor. The output role is nominal.
promoteCoercion :: Coercion -> CoercionN

-- | Assuming that two types are the same, ignoring coercions, find a
--   nominal coercion between the types. This is useful when optimizing
--   transitivity over coercion applications, where splitting two AppCos
--   might yield different kinds. See Note [EtaAppCo] in
--   <a>GHC.Core.Coercion.Opt</a>.
buildCoercion :: Type -> Type -> CoercionN
multToCo :: Mult -> Coercion

-- | Given a coercion `co :: (t1 :: TYPE r1) ~ (t2 :: TYPE r2)` produce a
--   coercion `rep_co :: r1 ~ r2` But actually it is possible that co ::
--   (t1 :: CONSTRAINT r1) ~ (t2 :: CONSTRAINT r2) or co :: (t1 :: TYPE r1)
--   ~ (t2 :: CONSTRAINT r2) or co :: (t1 :: CONSTRAINT r1) ~ (t2 :: TYPE
--   r2) See Note [mkRuntimeRepCo]
mkRuntimeRepCo :: HasDebugCallStack => Coercion -> Coercion

-- | Is there a coercion hole in this type?
hasCoercionHoleTy :: Type -> Bool

-- | Is there a coercion hole in this coercion?
hasCoercionHoleCo :: Coercion -> Bool
hasThisCoercionHoleTy :: Type -> CoercionHole -> Bool

-- | Set the type of a <a>CoercionHole</a>
setCoHoleType :: CoercionHole -> Type -> CoercionHole
instance GHC.Base.Functor GHC.Core.Coercion.NormaliseStepResult
instance GHC.Utils.Outputable.Outputable GHC.Core.Coercion.LiftingContext
instance GHC.Utils.Outputable.Outputable ev => GHC.Utils.Outputable.Outputable (GHC.Core.Coercion.NormaliseStepResult ev)

module GHC.Types.Hint

-- | A type for hints emitted by GHC. A <i>hint</i> suggests a possible way
--   to deal with a particular warning or error.
data GhcHint

-- | An "unknown" hint. This type constructor allows arbitrary -- hints to
--   be embedded. The typical use case would be GHC plugins -- willing to
--   emit hints alongside their custom diagnostics.
UnknownHint :: a -> GhcHint

-- | Suggests adding a particular language extension. GHC will do its best
--   trying to guess when the user is using the syntax of a particular
--   language extension without having the relevant extension enabled.
--   
--   Example: If the user uses the keyword "mdo" (and we are in a monadic
--   block), but the relevant extension is not enabled, GHC will emit a
--   'SuggestExtension RecursiveDo'.
--   
--   Test case(s): parser<i>should_fail</i>T12429,
--   parser<i>should_fail</i>T8501c, parser<i>should_fail</i>T18251e, ...
--   (and many more)
SuggestExtension :: !LanguageExtensionHint -> GhcHint

-- | Suggests possible corrections of a misspelled pragma. Its argument
--   represents all applicable suggestions.
--   
--   Example: {-# LNGUAGE BangPatterns #-}
--   
--   Test case(s): parser<i>should_compile</i>T21589
SuggestCorrectPragmaName :: ![String] -> GhcHint

-- | Suggests that a monadic code block is probably missing a "do" keyword.
--   
--   Example: main = putStrLn "hello" putStrLn "world"
--   
--   Test case(s): parser<i>should_fail</i>T8501a,
--   parser<i>should_fail</i>readFail007,
--   parser<i>should_fail</i>InfixAppPatErr, parser<i>should_fail</i>T984
SuggestMissingDo :: GhcHint

-- | Suggests that a "let" expression is needed in a "do" block.
--   
--   Test cases: None (that explicitly test this particular hint is
--   emitted).
SuggestLetInDo :: GhcHint

-- | Suggests to add an ".hsig" signature file to the Cabal manifest.
--   
--   Triggered by: <a>DriverUnexpectedSignature</a>, if Cabal is being
--   used.
--   
--   Example: See comment of <tt>DriverUnexpectedSignature</tt>.
--   
--   Test case(s): driver/T12955
SuggestAddSignatureCabalFile :: !ModuleName -> GhcHint

-- | Suggests to explicitly list the instantiations for the signatures in
--   the GHC invocation command.
--   
--   Triggered by: <a>DriverUnexpectedSignature</a>, if Cabal is <i>not</i>
--   being used.
--   
--   Example: See comment of <tt>DriverUnexpectedSignature</tt>.
--   
--   Test case(s): driver/T12955
SuggestSignatureInstantiations :: !ModuleName -> [InstantiationSuggestion] -> GhcHint

-- | Suggests to use spaces instead of tabs.
--   
--   Triggered by: <a>PsWarnTab</a>.
--   
--   Examples: None Test Case(s): None
SuggestUseSpaces :: GhcHint

-- | Suggests adding a whitespace after the given symbol.
--   
--   Examples: None Test Case(s): parser<i>should_compile</i>T18834a.hs
SuggestUseWhitespaceAfter :: !OperatorWhitespaceSymbol -> GhcHint

-- | Suggests adding a whitespace around the given operator symbol, as it
--   might be repurposed as special syntax by a future language extension.
--   The second parameter is how such operator occurred, if in a prefix,
--   suffix or tight infix position.
--   
--   Triggered by: <a>PsWarnOperatorWhitespace</a>.
--   
--   Example: h a b = a+b -- not OK, no spaces around <a>+</a>.
--   
--   Test Case(s): parser<i>should_compile</i>T18834b.hs
SuggestUseWhitespaceAround :: !String -> !OperatorWhitespaceOccurrence -> GhcHint

-- | Suggests wrapping an expression in parentheses
--   
--   Examples: None Test Case(s): None
SuggestParentheses :: GhcHint

-- | Suggests to increase the -fmax-pmcheck-models limit for the pattern
--   match checker.
--   
--   Triggered by: <a>DsMaxPmCheckModelsReached</a>
--   
--   Test case(s): pmcheck<i>should_compile</i>TooManyDeltas
--   pmcheck<i>should_compile</i>TooManyDeltas
--   pmcheck<i>should_compile</i>T11822
SuggestIncreaseMaxPmCheckModels :: GhcHint

-- | Suggests adding a type signature, typically to resolve ambiguity or
--   help GHC inferring types.
SuggestAddTypeSignatures :: AvailableBindings -> GhcHint

-- | Suggests to explicitly discard the result of a monadic action by
--   binding the result to the '_' wilcard.
--   
--   Example: main = do _ &lt;- getCurrentTime
SuggestBindToWildcard :: !LHsExpr GhcTc -> GhcHint
SuggestAddInlineOrNoInlinePragma :: !Var -> !Activation -> GhcHint
SuggestAddPhaseToCompetingRule :: !RuleName -> GhcHint

-- | Suggests adding an identifier to the export list of a signature.
SuggestAddToHSigExportList :: !Name -> !Maybe Module -> GhcHint

-- | Suggests increasing the limit for the number of iterations in the
--   simplifier.
SuggestIncreaseSimplifierIterations :: GhcHint

-- | Suggests to explicitly import <tt>Type</tt> from the <a>Kind</a>
--   module, because using "*" to mean <a>Type</a> relies on the StarIsType
--   extension, which will become deprecated in the future.
--   
--   Triggered by: <a>PsWarnStarIsType</a> Example: None Test case(s):
--   wcompat-warnings/WCompatWarningsOn.hs
SuggestUseTypeFromDataKind :: Maybe RdrName -> GhcHint

-- | Suggests placing the <tt>qualified</tt> keyword <i>after</i> the
--   module name.
--   
--   Triggered by: <a>PsWarnImportPreQualified</a> Example: None Test
--   case(s): module/mod184.hs
SuggestQualifiedAfterModuleName :: GhcHint

-- | Suggests using TemplateHaskell quotation syntax.
--   
--   Triggered by: <a>PsErrEmptyDoubleQuotes</a> only if TemplateHaskell is
--   enabled. Example: None Test case(s):
--   parser<i>should_fail</i>T13450TH.hs
SuggestThQuotationSyntax :: GhcHint

-- | Suggests alternative roles in case we found an illegal one.
--   
--   Triggered by: <a>PsErrIllegalRoleName</a> Example: None Test case(s):
--   roles<i>should_fail</i>Roles7.hs
SuggestRoles :: [Role] -> GhcHint

-- | Suggests qualifying the <a>*</a> operator in modules where StarIsType
--   is enabled.
--   
--   Triggered by: <a>PsWarnStarBinder</a> Test case(s):
--   warnings<i>should_compile</i>StarBinder.hs
SuggestQualifyStarOperator :: GhcHint

-- | Suggests that a type signature should have form <a>variable</a> ::
--   <a>type</a> in order to be accepted by GHC.
--   
--   Triggered by: <a>PsErrInvalidTypeSignature</a> Test case(s):
--   parser<i>should_fail</i>T3811
SuggestTypeSignatureForm :: GhcHint

-- | Suggests to move an orphan instance or to newtype-wrap it.
--   
--   Triggered by: <a>TcRnOrphanInstance</a> Test cases(s):
--   warnings<i>should_compile</i>T9178 typecheck<i>should_compile</i>T4912
SuggestFixOrphanInstance :: GhcHint

-- | Suggests to use a standalone deriving declaration when GHC can't
--   derive a typeclass instance in a trivial way.
--   
--   Triggered by: <a>DerivBadErrConstructor</a> Test cases(s):
--   typecheck<i>should_fail</i>tcfail086
SuggestAddStandaloneDerivation :: GhcHint

-- | Suggests the user to fill in the wildcard constraint to disambiguate
--   which constraint that is.
--   
--   Example: deriving instance _ =&gt; Eq (Foo f a)
--   
--   Triggered by: <a>DerivBadErrConstructor</a> Test cases(s):
--   partial-sigs<i>should_fail</i>T13324_fail2
SuggestFillInWildcardConstraint :: GhcHint

-- | Suggests to use an identifier other than <tt>forall</tt> Triggered by:
--   <a>TcRnForallIdentifier</a>
SuggestRenameForall :: GhcHint

-- | Suggests to use the appropriate Template Haskell tick: a single tick
--   for a term-level <a>NameSpace</a>, or a double tick for a type-level
--   <a>NameSpace</a>.
--   
--   Triggered by: <a>TcRnIncorrectNameSpace</a>.
SuggestAppropriateTHTick :: NameSpace -> GhcHint

-- | Suggests enabling -ddump-splices to help debug an issue when a
--   <a>Name</a> is not in scope or is used in multiple different
--   namespaces (e.g. both as a data constructor and a type constructor).
--   
--   Concomitant with <tt>NoExactName</tt> or <tt>SameName</tt> errors, see
--   e.g. "GHC.Rename.Env.lookupExactOcc_either". Test cases: T5971, T7241,
--   T13937.
SuggestDumpSlices :: GhcHint

-- | Suggests adding a tick to refer to something which has been promoted
--   to the type level, e.g. a data constructor.
--   
--   Test cases: T9778, T19984.
SuggestAddTick :: UntickedPromotedThing -> GhcHint

-- | Something is split off from its corresponding declaration. For
--   example, a datatype is given a role declaration in a different module.
--   
--   Test cases: T495, T8485, T2713, T5533.
SuggestMoveToDeclarationSite :: SDoc -> RdrName -> GhcHint

-- | Suggest a similar name that the user might have meant, e.g. suggest
--   <a>traverse</a> when the user has written <tt>travrese</tt>.
--   
--   Test case: mod73.
SuggestSimilarNames :: RdrName -> NonEmpty SimilarName -> GhcHint

-- | Remind the user that the field selector has been suppressed because of
--   -XNoFieldSelectors.
--   
--   Test cases: NFSSuppressed, records-nofieldselectors.
RemindFieldSelectorSuppressed :: RdrName -> [Name] -> GhcHint
[suppressed_selector] :: GhcHint -> RdrName
[suppressed_parents] :: GhcHint -> [Name]

-- | Suggest importing from a module, removing a <tt>hiding</tt> clause, or
--   explain to the user that we couldn't find a module with the given
--   <a>ModuleName</a>.
--   
--   Test cases: mod28, mod36, mod87, mod114, ...
ImportSuggestion :: ImportSuggestion -> GhcHint

-- | Suggest importing a data constructor to bring it into scope Triggered
--   by: <a>TcRnTypeCannotBeMarshaled</a>
--   
--   Test cases: ccfail004
SuggestImportingDataCon :: GhcHint
SuggestPlacePragmaInHeader :: GhcHint

-- | Suggest using pattern matching syntax for a non-bidirectional pattern
--   synonym
--   
--   Test cases: patsyn<i>should_fail</i>record-exquant
--   typecheck<i>should_fail</i>T3176
SuggestPatternMatchingSyntax :: GhcHint

-- | Suggest tips for making a definition visible for the purpose of
--   writing a SPECIALISE pragma for it in a different module.
--   
--   Test cases: none
SuggestSpecialiseVisibilityHints :: Name -> GhcHint
LoopySuperclassSolveHint :: PredType -> ClsInstOrQC -> GhcHint

-- | Suggest binding explicitly; e.g data T @k (a :: F k) = ....
SuggestBindTyVarExplicitly :: Name -> GhcHint

-- | The bindings we have available in scope when suggesting an explicit
--   type signature.
data AvailableBindings
NamedBindings :: NonEmpty Name -> AvailableBindings

-- | An unknown binding (i.e. too complicated to turn into a <a>Name</a>)
UnnamedBinding :: AvailableBindings

-- | An <a>InstantiationSuggestion</a> for a '.hsig' file. This is
--   generated by GHC in case of a <tt>DriverUnexpectedSignature</tt> and
--   suggests a way to instantiate a particular signature, where the first
--   argument is the signature name and the second is the module where the
--   signature was defined. Example:
--   
--   src/MyStr.hsig:2:11: error: Unexpected signature: ‘MyStr’ (Try passing
--   -instantiated-with="MyStr=<a>MyStr</a>" replacing <a>MyStr</a> as
--   necessary.)
data InstantiationSuggestion
InstantiationSuggestion :: !ModuleName -> !Module -> InstantiationSuggestion
data LanguageExtensionHint

-- | Suggest to enable the input extension. This is the hint that GHC emits
--   if this is not a "known" fix, i.e. this is GHC giving its best guess
--   on what extension might be necessary to make a certain program
--   compile. For example, GHC might suggests to enable
--   <tt>BlockArguments</tt> when the user simply formatted incorrectly the
--   input program, so GHC here is trying to be as helpful as possible. If
--   the input <a>SDoc</a> is not empty, it will contain some extra
--   information about the why the extension is required, but it's totally
--   irrelevant/redundant for IDEs and other tools.
SuggestSingleExtension :: !SDoc -> !Extension -> LanguageExtensionHint

-- | Suggest to enable the input extensions. The list is to be intended as
--   <i>disjunctive</i> i.e. the user is suggested to enable <i>any</i> of
--   the extensions listed. If the input <a>SDoc</a> is not empty, it will
--   contain some extra information about the why the extensions are
--   required, but it's totally irrelevant/redundant for IDEs and other
--   tools.
SuggestAnyExtension :: !SDoc -> [Extension] -> LanguageExtensionHint

-- | Suggest to enable the input extensions. The list is to be intended as
--   <i>conjunctive</i> i.e. the user is suggested to enable <i>all</i> the
--   extensions listed. If the input <a>SDoc</a> is not empty, it will
--   contain some extra information about the why the extensions are
--   required, but it's totally irrelevant/redundant for IDEs and other
--   tools.
SuggestExtensions :: !SDoc -> [Extension] -> LanguageExtensionHint

-- | Suggest to enable the input extension in order to fix a certain
--   problem. This is the suggestion that GHC emits when is more-or-less
--   clear "what's going on". For example, if both <tt>DeriveAnyClass</tt>
--   and <tt>GeneralizedNewtypeDeriving</tt> are turned on, the right thing
--   to do is to enabled <tt>DerivingStrategies</tt>, so in contrast to
--   <a>SuggestSingleExtension</a> GHC will be a bit more "imperative"
--   (i.e. "Use X Y Z in order to ... "). If the input <a>SDoc</a> is not
--   empty, it will contain some extra information about the why the
--   extensions are required, but it's totally irrelevant/redundant for
--   IDEs and other tools.
SuggestExtensionInOrderTo :: !SDoc -> !Extension -> LanguageExtensionHint

-- | Suggest how to fix an import.
data ImportSuggestion

-- | Some module exports what we want, but we aren't explicitly importing
--   it.
CouldImportFrom :: NonEmpty (Module, ImportedModsVal) -> OccName -> ImportSuggestion

-- | Some module exports what we want, but we are explicitly hiding it.
CouldUnhideFrom :: NonEmpty (Module, ImportedModsVal) -> OccName -> ImportSuggestion

-- | Explain how something is in scope.
data HowInScope

-- | It was locally bound at this particular source location.
LocallyBoundAt :: SrcSpan -> HowInScope

-- | It was imported by this particular import declaration.
ImportedBy :: ImpDeclSpec -> HowInScope
data SimilarName
SimilarName :: Name -> SimilarName
SimilarRdrName :: RdrName -> HowInScope -> SimilarName

-- | Whether <a>*</a> is a synonym for <a>Type</a>.
data StarIsType
StarIsNotType :: StarIsType
StarIsType :: StarIsType

-- | Something is promoted to the type-level without a promotion tick.
data UntickedPromotedThing
UntickedConstructor :: LexicalFixity -> Name -> UntickedPromotedThing
UntickedExplicitList :: UntickedPromotedThing
pprUntickedConstructor :: LexicalFixity -> Name -> SDoc

-- | Whether a constructor name is printed out as a bare symbol, e.g.
--   <tt>:</tt>.
--   
--   True for symbolic names in infix position.
--   
--   Used for pretty-printing.
isBareSymbol :: LexicalFixity -> Name -> Bool

-- | Suggests a single extension without extra user info.
suggestExtension :: Extension -> GhcHint

-- | Like <a>suggestExtension</a> but allows supplying extra info for the
--   user.
suggestExtensionWithInfo :: SDoc -> Extension -> GhcHint

-- | Suggests to enable <i>every</i> extension in the list.
suggestExtensions :: [Extension] -> GhcHint

-- | Like <a>suggestExtensions</a> but allows supplying extra info for the
--   user.
suggestExtensionsWithInfo :: SDoc -> [Extension] -> GhcHint

-- | Suggests to enable <i>any</i> extension in the list.
suggestAnyExtension :: [Extension] -> GhcHint

-- | Like <a>suggestAnyExtension</a> but allows supplying extra info for
--   the user.
suggestAnyExtensionWithInfo :: SDoc -> [Extension] -> GhcHint
useExtensionInOrderTo :: SDoc -> Extension -> GhcHint

-- | Display info about the treatment of <a>*</a> under NoStarIsType.
--   
--   With StarIsType, three properties of <a>*</a> hold:
--   
--   (a) it is not an infix operator (b) it is always in scope (c) it is a
--   synonym for Data.Kind.Type
--   
--   However, the user might not know that they are working on a module
--   with NoStarIsType and write code that still assumes (a), (b), and (c),
--   which actually do not hold in that module.
--   
--   Violation of (a) shows up in the parser. For instance, in the
--   following examples, we have <a>*</a> not applied to enough arguments:
--   
--   data A :: * data F :: * -&gt; *
--   
--   Violation of (b) or (c) show up in the renamer and the typechecker
--   respectively. For instance:
--   
--   type K = Either * Bool
--   
--   This will parse differently depending on whether StarIsType is
--   enabled, but it will parse nonetheless. With NoStarIsType it is parsed
--   as a type operator, thus we have ((*) Either Bool). Now there are two
--   cases to consider:
--   
--   <ol>
--   <li>There is no definition of (*) in scope. In this case the renamer
--   will fail to look it up. This is a violation of assumption (b).</li>
--   <li>There is a definition of the (*) type operator in scope (for
--   example coming from GHC.TypeNats). In this case the user will get a
--   kind mismatch error. This is a violation of assumption (c).</li>
--   </ol>
--   
--   The user might unknowingly be working on a module with NoStarIsType or
--   use <a>*</a> as <a>Type</a> out of habit. So it is important to give a
--   hint whenever an assumption about <a>*</a> is violated. Unfortunately,
--   it is somewhat difficult to deal with (c), so we limit ourselves to
--   (a) and (b).
--   
--   <a>noStarIsTypeHints</a> returns appropriate hints to the user
--   depending on the extensions enabled in the module and the name that
--   triggered the error. That is, if we have NoStarIsType and the error is
--   related to <a>*</a> or its Unicode variant, we will suggest using
--   <a>Type</a>; otherwise we won't suggest anything.
noStarIsTypeHints :: StarIsType -> RdrName -> [GhcHint]

module GHC.Types.Error

-- | A collection of messages emitted by GHC during error reporting. A
--   diagnostic message is typically a warning or an error. See Note
--   [Messages].
--   
--   <i>INVARIANT</i>: All the messages in this collection must be
--   relevant, i.e. their <a>Severity</a> should <i>not</i> be
--   <a>SevIgnore</a>. The smart constructor <a>mkMessages</a> will filter
--   out any message which <a>Severity</a> is <a>SevIgnore</a>.
data Messages e
mkMessages :: Bag (MsgEnvelope e) -> Messages e
getMessages :: Messages e -> Bag (MsgEnvelope e)
emptyMessages :: Messages e
isEmptyMessages :: Messages e -> Bool
singleMessage :: MsgEnvelope e -> Messages e

-- | Adds a <tt>Message</tt> to the input collection of messages. See Note
--   [Discarding Messages].
addMessage :: MsgEnvelope e -> Messages e -> Messages e

-- | Joins two collections of messages together. See Note [Discarding
--   Messages].
unionMessages :: Messages e -> Messages e -> Messages e

-- | Joins many <a>Messages</a>s together
unionManyMessages :: Foldable f => f (Messages e) -> Messages e

-- | An envelope for GHC's facts about a running program, parameterised
--   over the <i>domain-specific</i> (i.e. parsing, typecheck-renaming,
--   etc) diagnostics.
--   
--   To say things differently, GHC emits <i>diagnostics</i> about the
--   running program, each of which is wrapped into a <a>MsgEnvelope</a>
--   that carries specific information like where the error happened, etc.
--   Finally, multiple <a>MsgEnvelope</a>s are aggregated into
--   <a>Messages</a> that are returned to the user.
data MsgEnvelope e
MsgEnvelope :: SrcSpan -> NamePprCtx -> e -> Severity -> MsgEnvelope e

-- | The SrcSpan is used for sorting errors into line-number order
[errMsgSpan] :: MsgEnvelope e -> SrcSpan
[errMsgContext] :: MsgEnvelope e -> NamePprCtx
[errMsgDiagnostic] :: MsgEnvelope e -> e
[errMsgSeverity] :: MsgEnvelope e -> Severity

-- | The class for a diagnostic message. The main purpose is to classify a
--   message within GHC, to distinguish it from a debug/dump message vs a
--   proper diagnostic, for which we include a <a>DiagnosticReason</a>.
data MessageClass
MCOutput :: MessageClass
MCFatal :: MessageClass
MCInteractive :: MessageClass

-- | Log message intended for compiler developers No file/line/column stuff
MCDump :: MessageClass

-- | Log messages intended for end users. No file/line/column stuff.
MCInfo :: MessageClass

-- | Diagnostics from the compiler. This constructor is very powerful as it
--   allows the construction of a <a>MessageClass</a> with a completely
--   arbitrary permutation of <a>Severity</a> and <a>DiagnosticReason</a>.
--   As such, users are encouraged to use the <tt>mkMCDiagnostic</tt> smart
--   constructor instead. Use this constructor directly only if you need to
--   construct and manipulate diagnostic messages directly, for example
--   inside <a>Error</a>. In all the other circumstances, <i>especially</i>
--   when emitting compiler diagnostics, use the smart constructor.
--   
--   The <tt>Maybe <a>DiagnosticCode</a></tt> field carries a code (if
--   available) for this diagnostic. If you are creating a message not tied
--   to any error-message type, then use Nothing. In the long run, this
--   really should always have a <a>DiagnosticCode</a>. See Note
--   [Diagnostic codes].
MCDiagnostic :: Severity -> DiagnosticReason -> Maybe DiagnosticCode -> MessageClass

-- | Used to describe warnings and errors o The message has a
--   file/line/column heading, plus "warning:" or "error:", added by
--   mkLocMessage o With <a>SevIgnore</a> the message is suppressed o
--   Output is intended for end users
data Severity

-- | Ignore this message, for example in case of suppression of warnings
--   users don't want to see. See Note [Suppressing Messages]
SevIgnore :: Severity
SevWarning :: Severity
SevError :: Severity

-- | A class identifying a diagnostic. Dictionary.com defines a diagnostic
--   as:
--   
--   "a message output by a computer diagnosing an error in a computer
--   program, computer system, or component device".
--   
--   A <a>Diagnostic</a> carries the <i>actual</i> description of the
--   message (which, in GHC's case, it can be an error or a warning) and
--   the <i>reason</i> why such message was generated in the first place.
class Diagnostic a where {
    
    -- | Type of configuration options for the diagnostic.
    type DiagnosticOpts a;
}
defaultDiagnosticOpts :: Diagnostic a => DiagnosticOpts a

-- | Extract the error message text from a <a>Diagnostic</a>.
diagnosticMessage :: Diagnostic a => DiagnosticOpts a -> a -> DecoratedSDoc

-- | Extract the reason for this diagnostic. For warnings, a
--   <a>DiagnosticReason</a> includes the warning flag.
diagnosticReason :: Diagnostic a => a -> DiagnosticReason

-- | Extract any hints a user might use to repair their code to avoid this
--   diagnostic.
diagnosticHints :: Diagnostic a => a -> [GhcHint]

-- | Get the <a>DiagnosticCode</a> associated with this <a>Diagnostic</a>.
--   This can return <a>Nothing</a> for at least two reasons:
--   
--   <ol>
--   <li>The message might be from a plugin that does not supply
--   codes.</li>
--   <li>The message might not yet have been assigned a code. See the
--   <a>Diagnostic</a> instance for <a>DiagnosticMessage</a>.</li>
--   </ol>
--   
--   Ideally, case (2) would not happen, but because some errors in GHC
--   still use the old system of just writing the error message in-place
--   (instead of using a dedicated error type and constructor), we do not
--   have error codes for all errors. #18516 tracks our progress toward
--   this goal.
diagnosticCode :: Diagnostic a => a -> Maybe DiagnosticCode

-- | An existential wrapper around an unknown diagnostic.
data UnknownDiagnostic
[UnknownDiagnostic] :: (DiagnosticOpts a ~ NoDiagnosticOpts, Diagnostic a, Typeable a) => a -> UnknownDiagnostic

-- | A generic <a>Diagnostic</a> message, without any further
--   classification or provenance: By looking at a <a>DiagnosticMessage</a>
--   we don't know neither <i>where</i> it was generated nor how to
--   intepret its payload (as it's just a structured document). All we can
--   do is to print it out and look at its <a>DiagnosticReason</a>.
data DiagnosticMessage
DiagnosticMessage :: !DecoratedSDoc -> !DiagnosticReason -> [GhcHint] -> DiagnosticMessage
[diagMessage] :: DiagnosticMessage -> !DecoratedSDoc
[diagReason] :: DiagnosticMessage -> !DiagnosticReason
[diagHints] :: DiagnosticMessage -> [GhcHint]

-- | The reason <i>why</i> a <a>Diagnostic</a> was emitted in the first
--   place. Diagnostic messages are born within GHC with a very precise
--   reason, which can be completely statically-computed (i.e. this is an
--   error or a warning no matter what), or influenced by the specific
--   state of the <tt>DynFlags</tt> at the moment of the creation of a new
--   <a>Diagnostic</a>. For example, a parsing error is <i>always</i> going
--   to be an error, whereas a 'WarningWithoutFlag Opt_WarnUnusedImports'
--   might turn into an error due to '-Werror' or
--   '-Werror=warn-unused-imports'. Interpreting a <a>DiagnosticReason</a>
--   together with its associated <a>Severity</a> gives us the full
--   picture.
data DiagnosticReason

-- | Born as a warning.
WarningWithoutFlag :: DiagnosticReason

-- | Warning was enabled with the flag.
WarningWithFlag :: !WarningFlag -> DiagnosticReason

-- | Born as an error.
ErrorWithoutFlag :: DiagnosticReason

-- | A generic <tt>Hint</tt> message, to be used with
--   <a>DiagnosticMessage</a>.
data DiagnosticHint
DiagnosticHint :: !SDoc -> DiagnosticHint
mkPlainDiagnostic :: DiagnosticReason -> [GhcHint] -> SDoc -> DiagnosticMessage

-- | Create an error <a>DiagnosticMessage</a> holding just a single
--   <a>SDoc</a>
mkPlainError :: [GhcHint] -> SDoc -> DiagnosticMessage

-- | Create a <a>DiagnosticMessage</a> from a list of bulleted SDocs and a
--   <a>DiagnosticReason</a>
mkDecoratedDiagnostic :: DiagnosticReason -> [GhcHint] -> [SDoc] -> DiagnosticMessage

-- | Create an error <a>DiagnosticMessage</a> from a list of bulleted SDocs
mkDecoratedError :: [GhcHint] -> [SDoc] -> DiagnosticMessage
data NoDiagnosticOpts
NoDiagnosticOpts :: NoDiagnosticOpts

-- | A type for hints emitted by GHC. A <i>hint</i> suggests a possible way
--   to deal with a particular warning or error.
data GhcHint

-- | An "unknown" hint. This type constructor allows arbitrary -- hints to
--   be embedded. The typical use case would be GHC plugins -- willing to
--   emit hints alongside their custom diagnostics.
UnknownHint :: a -> GhcHint

-- | Suggests adding a particular language extension. GHC will do its best
--   trying to guess when the user is using the syntax of a particular
--   language extension without having the relevant extension enabled.
--   
--   Example: If the user uses the keyword "mdo" (and we are in a monadic
--   block), but the relevant extension is not enabled, GHC will emit a
--   'SuggestExtension RecursiveDo'.
--   
--   Test case(s): parser<i>should_fail</i>T12429,
--   parser<i>should_fail</i>T8501c, parser<i>should_fail</i>T18251e, ...
--   (and many more)
SuggestExtension :: !LanguageExtensionHint -> GhcHint

-- | Suggests possible corrections of a misspelled pragma. Its argument
--   represents all applicable suggestions.
--   
--   Example: {-# LNGUAGE BangPatterns #-}
--   
--   Test case(s): parser<i>should_compile</i>T21589
SuggestCorrectPragmaName :: ![String] -> GhcHint

-- | Suggests that a monadic code block is probably missing a "do" keyword.
--   
--   Example: main = putStrLn "hello" putStrLn "world"
--   
--   Test case(s): parser<i>should_fail</i>T8501a,
--   parser<i>should_fail</i>readFail007,
--   parser<i>should_fail</i>InfixAppPatErr, parser<i>should_fail</i>T984
SuggestMissingDo :: GhcHint

-- | Suggests that a "let" expression is needed in a "do" block.
--   
--   Test cases: None (that explicitly test this particular hint is
--   emitted).
SuggestLetInDo :: GhcHint

-- | Suggests to add an ".hsig" signature file to the Cabal manifest.
--   
--   Triggered by: <a>DriverUnexpectedSignature</a>, if Cabal is being
--   used.
--   
--   Example: See comment of <tt>DriverUnexpectedSignature</tt>.
--   
--   Test case(s): driver/T12955
SuggestAddSignatureCabalFile :: !ModuleName -> GhcHint

-- | Suggests to explicitly list the instantiations for the signatures in
--   the GHC invocation command.
--   
--   Triggered by: <a>DriverUnexpectedSignature</a>, if Cabal is <i>not</i>
--   being used.
--   
--   Example: See comment of <tt>DriverUnexpectedSignature</tt>.
--   
--   Test case(s): driver/T12955
SuggestSignatureInstantiations :: !ModuleName -> [InstantiationSuggestion] -> GhcHint

-- | Suggests to use spaces instead of tabs.
--   
--   Triggered by: <a>PsWarnTab</a>.
--   
--   Examples: None Test Case(s): None
SuggestUseSpaces :: GhcHint

-- | Suggests adding a whitespace after the given symbol.
--   
--   Examples: None Test Case(s): parser<i>should_compile</i>T18834a.hs
SuggestUseWhitespaceAfter :: !OperatorWhitespaceSymbol -> GhcHint

-- | Suggests adding a whitespace around the given operator symbol, as it
--   might be repurposed as special syntax by a future language extension.
--   The second parameter is how such operator occurred, if in a prefix,
--   suffix or tight infix position.
--   
--   Triggered by: <a>PsWarnOperatorWhitespace</a>.
--   
--   Example: h a b = a+b -- not OK, no spaces around <a>+</a>.
--   
--   Test Case(s): parser<i>should_compile</i>T18834b.hs
SuggestUseWhitespaceAround :: !String -> !OperatorWhitespaceOccurrence -> GhcHint

-- | Suggests wrapping an expression in parentheses
--   
--   Examples: None Test Case(s): None
SuggestParentheses :: GhcHint

-- | Suggests to increase the -fmax-pmcheck-models limit for the pattern
--   match checker.
--   
--   Triggered by: <a>DsMaxPmCheckModelsReached</a>
--   
--   Test case(s): pmcheck<i>should_compile</i>TooManyDeltas
--   pmcheck<i>should_compile</i>TooManyDeltas
--   pmcheck<i>should_compile</i>T11822
SuggestIncreaseMaxPmCheckModels :: GhcHint

-- | Suggests adding a type signature, typically to resolve ambiguity or
--   help GHC inferring types.
SuggestAddTypeSignatures :: AvailableBindings -> GhcHint

-- | Suggests to explicitly discard the result of a monadic action by
--   binding the result to the '_' wilcard.
--   
--   Example: main = do _ &lt;- getCurrentTime
SuggestBindToWildcard :: !LHsExpr GhcTc -> GhcHint
SuggestAddInlineOrNoInlinePragma :: !Var -> !Activation -> GhcHint
SuggestAddPhaseToCompetingRule :: !RuleName -> GhcHint

-- | Suggests adding an identifier to the export list of a signature.
SuggestAddToHSigExportList :: !Name -> !Maybe Module -> GhcHint

-- | Suggests increasing the limit for the number of iterations in the
--   simplifier.
SuggestIncreaseSimplifierIterations :: GhcHint

-- | Suggests to explicitly import <tt>Type</tt> from the <a>Kind</a>
--   module, because using "*" to mean <a>Type</a> relies on the StarIsType
--   extension, which will become deprecated in the future.
--   
--   Triggered by: <a>PsWarnStarIsType</a> Example: None Test case(s):
--   wcompat-warnings/WCompatWarningsOn.hs
SuggestUseTypeFromDataKind :: Maybe RdrName -> GhcHint

-- | Suggests placing the <tt>qualified</tt> keyword <i>after</i> the
--   module name.
--   
--   Triggered by: <a>PsWarnImportPreQualified</a> Example: None Test
--   case(s): module/mod184.hs
SuggestQualifiedAfterModuleName :: GhcHint

-- | Suggests using TemplateHaskell quotation syntax.
--   
--   Triggered by: <a>PsErrEmptyDoubleQuotes</a> only if TemplateHaskell is
--   enabled. Example: None Test case(s):
--   parser<i>should_fail</i>T13450TH.hs
SuggestThQuotationSyntax :: GhcHint

-- | Suggests alternative roles in case we found an illegal one.
--   
--   Triggered by: <a>PsErrIllegalRoleName</a> Example: None Test case(s):
--   roles<i>should_fail</i>Roles7.hs
SuggestRoles :: [Role] -> GhcHint

-- | Suggests qualifying the <a>*</a> operator in modules where StarIsType
--   is enabled.
--   
--   Triggered by: <a>PsWarnStarBinder</a> Test case(s):
--   warnings<i>should_compile</i>StarBinder.hs
SuggestQualifyStarOperator :: GhcHint

-- | Suggests that a type signature should have form <a>variable</a> ::
--   <a>type</a> in order to be accepted by GHC.
--   
--   Triggered by: <a>PsErrInvalidTypeSignature</a> Test case(s):
--   parser<i>should_fail</i>T3811
SuggestTypeSignatureForm :: GhcHint

-- | Suggests to move an orphan instance or to newtype-wrap it.
--   
--   Triggered by: <a>TcRnOrphanInstance</a> Test cases(s):
--   warnings<i>should_compile</i>T9178 typecheck<i>should_compile</i>T4912
SuggestFixOrphanInstance :: GhcHint

-- | Suggests to use a standalone deriving declaration when GHC can't
--   derive a typeclass instance in a trivial way.
--   
--   Triggered by: <a>DerivBadErrConstructor</a> Test cases(s):
--   typecheck<i>should_fail</i>tcfail086
SuggestAddStandaloneDerivation :: GhcHint

-- | Suggests the user to fill in the wildcard constraint to disambiguate
--   which constraint that is.
--   
--   Example: deriving instance _ =&gt; Eq (Foo f a)
--   
--   Triggered by: <a>DerivBadErrConstructor</a> Test cases(s):
--   partial-sigs<i>should_fail</i>T13324_fail2
SuggestFillInWildcardConstraint :: GhcHint

-- | Suggests to use an identifier other than <tt>forall</tt> Triggered by:
--   <a>TcRnForallIdentifier</a>
SuggestRenameForall :: GhcHint

-- | Suggests to use the appropriate Template Haskell tick: a single tick
--   for a term-level <a>NameSpace</a>, or a double tick for a type-level
--   <a>NameSpace</a>.
--   
--   Triggered by: <a>TcRnIncorrectNameSpace</a>.
SuggestAppropriateTHTick :: NameSpace -> GhcHint

-- | Suggests enabling -ddump-splices to help debug an issue when a
--   <a>Name</a> is not in scope or is used in multiple different
--   namespaces (e.g. both as a data constructor and a type constructor).
--   
--   Concomitant with <tt>NoExactName</tt> or <tt>SameName</tt> errors, see
--   e.g. "GHC.Rename.Env.lookupExactOcc_either". Test cases: T5971, T7241,
--   T13937.
SuggestDumpSlices :: GhcHint

-- | Suggests adding a tick to refer to something which has been promoted
--   to the type level, e.g. a data constructor.
--   
--   Test cases: T9778, T19984.
SuggestAddTick :: UntickedPromotedThing -> GhcHint

-- | Something is split off from its corresponding declaration. For
--   example, a datatype is given a role declaration in a different module.
--   
--   Test cases: T495, T8485, T2713, T5533.
SuggestMoveToDeclarationSite :: SDoc -> RdrName -> GhcHint

-- | Suggest a similar name that the user might have meant, e.g. suggest
--   <a>traverse</a> when the user has written <tt>travrese</tt>.
--   
--   Test case: mod73.
SuggestSimilarNames :: RdrName -> NonEmpty SimilarName -> GhcHint

-- | Remind the user that the field selector has been suppressed because of
--   -XNoFieldSelectors.
--   
--   Test cases: NFSSuppressed, records-nofieldselectors.
RemindFieldSelectorSuppressed :: RdrName -> [Name] -> GhcHint
[suppressed_selector] :: GhcHint -> RdrName
[suppressed_parents] :: GhcHint -> [Name]

-- | Suggest importing from a module, removing a <tt>hiding</tt> clause, or
--   explain to the user that we couldn't find a module with the given
--   <a>ModuleName</a>.
--   
--   Test cases: mod28, mod36, mod87, mod114, ...
ImportSuggestion :: ImportSuggestion -> GhcHint

-- | Suggest importing a data constructor to bring it into scope Triggered
--   by: <a>TcRnTypeCannotBeMarshaled</a>
--   
--   Test cases: ccfail004
SuggestImportingDataCon :: GhcHint
SuggestPlacePragmaInHeader :: GhcHint

-- | Suggest using pattern matching syntax for a non-bidirectional pattern
--   synonym
--   
--   Test cases: patsyn<i>should_fail</i>record-exquant
--   typecheck<i>should_fail</i>T3176
SuggestPatternMatchingSyntax :: GhcHint

-- | Suggest tips for making a definition visible for the purpose of
--   writing a SPECIALISE pragma for it in a different module.
--   
--   Test cases: none
SuggestSpecialiseVisibilityHints :: Name -> GhcHint
LoopySuperclassSolveHint :: PredType -> ClsInstOrQC -> GhcHint

-- | Suggest binding explicitly; e.g data T @k (a :: F k) = ....
SuggestBindTyVarExplicitly :: Name -> GhcHint

-- | The bindings we have available in scope when suggesting an explicit
--   type signature.
data AvailableBindings
NamedBindings :: NonEmpty Name -> AvailableBindings

-- | An unknown binding (i.e. too complicated to turn into a <a>Name</a>)
UnnamedBinding :: AvailableBindings
data LanguageExtensionHint

-- | Suggest to enable the input extension. This is the hint that GHC emits
--   if this is not a "known" fix, i.e. this is GHC giving its best guess
--   on what extension might be necessary to make a certain program
--   compile. For example, GHC might suggests to enable
--   <tt>BlockArguments</tt> when the user simply formatted incorrectly the
--   input program, so GHC here is trying to be as helpful as possible. If
--   the input <a>SDoc</a> is not empty, it will contain some extra
--   information about the why the extension is required, but it's totally
--   irrelevant/redundant for IDEs and other tools.
SuggestSingleExtension :: !SDoc -> !Extension -> LanguageExtensionHint

-- | Suggest to enable the input extensions. The list is to be intended as
--   <i>disjunctive</i> i.e. the user is suggested to enable <i>any</i> of
--   the extensions listed. If the input <a>SDoc</a> is not empty, it will
--   contain some extra information about the why the extensions are
--   required, but it's totally irrelevant/redundant for IDEs and other
--   tools.
SuggestAnyExtension :: !SDoc -> [Extension] -> LanguageExtensionHint

-- | Suggest to enable the input extensions. The list is to be intended as
--   <i>conjunctive</i> i.e. the user is suggested to enable <i>all</i> the
--   extensions listed. If the input <a>SDoc</a> is not empty, it will
--   contain some extra information about the why the extensions are
--   required, but it's totally irrelevant/redundant for IDEs and other
--   tools.
SuggestExtensions :: !SDoc -> [Extension] -> LanguageExtensionHint

-- | Suggest to enable the input extension in order to fix a certain
--   problem. This is the suggestion that GHC emits when is more-or-less
--   clear "what's going on". For example, if both <tt>DeriveAnyClass</tt>
--   and <tt>GeneralizedNewtypeDeriving</tt> are turned on, the right thing
--   to do is to enabled <tt>DerivingStrategies</tt>, so in contrast to
--   <a>SuggestSingleExtension</a> GHC will be a bit more "imperative"
--   (i.e. "Use X Y Z in order to ... "). If the input <a>SDoc</a> is not
--   empty, it will contain some extra information about the why the
--   extensions are required, but it's totally irrelevant/redundant for
--   IDEs and other tools.
SuggestExtensionInOrderTo :: !SDoc -> !Extension -> LanguageExtensionHint

-- | Suggests a single extension without extra user info.
suggestExtension :: Extension -> GhcHint

-- | Like <a>suggestExtension</a> but allows supplying extra info for the
--   user.
suggestExtensionWithInfo :: SDoc -> Extension -> GhcHint

-- | Suggests to enable <i>every</i> extension in the list.
suggestExtensions :: [Extension] -> GhcHint

-- | Like <a>suggestExtensions</a> but allows supplying extra info for the
--   user.
suggestExtensionsWithInfo :: SDoc -> [Extension] -> GhcHint

-- | Suggests to enable <i>any</i> extension in the list.
suggestAnyExtension :: [Extension] -> GhcHint

-- | Like <a>suggestAnyExtension</a> but allows supplying extra info for
--   the user.
suggestAnyExtensionWithInfo :: SDoc -> [Extension] -> GhcHint
useExtensionInOrderTo :: SDoc -> Extension -> GhcHint

-- | Helper function to use when no hints can be provided. Currently this
--   function can be used to construct plain <a>DiagnosticMessage</a> and
--   add hints to them, but once #18516 will be fully executed, the main
--   usage of this function would be in the implementation of the
--   <a>diagnosticHints</a> typeclass method, to report the fact that a
--   particular <a>Diagnostic</a> has no hints.
noHints :: [GhcHint]

-- | Represents a pretty-printable document.
--   
--   To display an <a>SDoc</a>, use <a>printSDoc</a>, <a>printSDocLn</a>,
--   <a>bufLeftRenderSDoc</a>, or <a>renderWithContext</a>. Avoid calling
--   <a>runSDoc</a> directly as it breaks the abstraction layer.
data SDoc

-- | A <a>DecoratedSDoc</a> is isomorphic to a '[SDoc]' but it carries the
--   invariant that the input '[SDoc]' needs to be rendered
--   <i>decorated</i> into its final form, where the typical case would be
--   adding bullets between each elements of the list. The type of
--   decoration depends on the formatting function used, but in practice
--   GHC uses the <tt>formatBulleted</tt>.
data DecoratedSDoc

-- | Creates a new <a>DecoratedSDoc</a> out of a list of <a>SDoc</a>.
mkDecorated :: [SDoc] -> DecoratedSDoc

-- | Creates a new <a>DecoratedSDoc</a> out of a single <a>SDoc</a>
mkSimpleDecorated :: SDoc -> DecoratedSDoc

-- | Joins two <a>DecoratedSDoc</a> together. The resulting
--   <a>DecoratedSDoc</a> will have a number of entries which is the sum of
--   the lengths of the input.
unionDecoratedSDoc :: DecoratedSDoc -> DecoratedSDoc -> DecoratedSDoc

-- | Apply a transformation function to all elements of a
--   <a>DecoratedSDoc</a>.
mapDecoratedSDoc :: (SDoc -> SDoc) -> DecoratedSDoc -> DecoratedSDoc
pprMessageBag :: Bag SDoc -> SDoc
mkLocMessage :: MessageClass -> SrcSpan -> SDoc -> SDoc

-- | Make an error message with location info, specifying whether to show
--   warning groups (if applicable).
mkLocMessageWarningGroups :: Bool -> MessageClass -> SrcSpan -> SDoc -> SDoc
getCaretDiagnostic :: MessageClass -> SrcSpan -> IO SDoc

-- | Returns <a>True</a> if this is, intrinsically, a failure. See Note
--   [Intrinsic And Extrinsic Failures].
isIntrinsicErrorMessage :: Diagnostic e => MsgEnvelope e -> Bool

-- | Returns <a>True</a> if the envelope contains a message that will stop
--   compilation: either an intrinsic error or a fatal (-Werror) warning
isExtrinsicErrorMessage :: MsgEnvelope e -> Bool
isWarningMessage :: Diagnostic e => MsgEnvelope e -> Bool
getErrorMessages :: Diagnostic e => Messages e -> Bag (MsgEnvelope e)
getWarningMessages :: Diagnostic e => Messages e -> Bag (MsgEnvelope e)

-- | Partitions the <a>Messages</a> and returns a tuple which first element
--   are the warnings, and the second the errors.
partitionMessages :: Diagnostic e => Messages e -> (Messages e, Messages e)

-- | Are there any hard errors here? -Werror warnings are <i>not</i>
--   detected. If you want to check for -Werror warnings, use
--   <a>errorsOrFatalWarningsFound</a>.
errorsFound :: Diagnostic e => Messages e -> Bool

-- | Are there any errors or -Werror warnings here?
errorsOrFatalWarningsFound :: Messages e -> Bool

-- | A diagnostic code is a namespaced numeric identifier unique to the
--   given diagnostic (error or warning).
--   
--   All diagnostic codes defined within GHC are given the GHC namespace.
--   
--   See Note [Diagnostic codes] in GHC.Types.Error.Codes.
data DiagnosticCode
DiagnosticCode :: String -> Natural -> DiagnosticCode

-- | diagnostic code prefix (e.g. <a>GHC</a>)
[diagnosticCodeNameSpace] :: DiagnosticCode -> String

-- | the actual diagnostic code
[diagnosticCodeNumber] :: DiagnosticCode -> Natural
instance GHC.Show.Show GHC.Types.Error.DiagnosticReason
instance GHC.Classes.Eq GHC.Types.Error.DiagnosticReason
instance GHC.Show.Show GHC.Types.Error.Severity
instance GHC.Classes.Eq GHC.Types.Error.Severity
instance Data.Traversable.Traversable GHC.Types.Error.MsgEnvelope
instance Data.Foldable.Foldable GHC.Types.Error.MsgEnvelope
instance GHC.Base.Functor GHC.Types.Error.MsgEnvelope
instance Data.Traversable.Traversable GHC.Types.Error.Messages
instance Data.Foldable.Foldable GHC.Types.Error.Messages
instance GHC.Base.Functor GHC.Types.Error.Messages
instance GHC.Base.Monoid (GHC.Types.Error.Messages e)
instance GHC.Base.Semigroup (GHC.Types.Error.Messages e)
instance GHC.Types.Error.Diagnostic GHC.Types.Error.UnknownDiagnostic
instance GHC.Types.Error.Diagnostic e => GHC.Utils.Outputable.Outputable (GHC.Types.Error.Messages e)
instance GHC.Types.Error.Diagnostic GHC.Types.Error.DiagnosticMessage
instance GHC.Utils.Json.ToJson GHC.Types.Error.MessageClass
instance GHC.Utils.Outputable.Outputable GHC.Types.Error.DiagnosticCode
instance GHC.Show.Show (GHC.Types.Error.MsgEnvelope GHC.Types.Error.DiagnosticMessage)
instance GHC.Utils.Outputable.Outputable GHC.Types.Error.Severity
instance GHC.Utils.Json.ToJson GHC.Types.Error.Severity
instance GHC.Utils.Outputable.Outputable GHC.Types.Error.DiagnosticReason
instance GHC.Utils.Outputable.Outputable GHC.Types.Error.DiagnosticHint


-- | Logger
--   
--   The Logger is an configurable entity that is used by the compiler to
--   output messages on the console (stdout, stderr) and in dump files.
--   
--   The behaviour of default Logger returned by <a>initLogger</a> can be
--   modified with hooks. The compiler itself uses hooks in multithreaded
--   code (--make) and it is also probably used by ghc-api users (IDEs,
--   etc.).
--   
--   In addition to hooks, the Logger supports LogFlags: basically a subset
--   of the command-line flags that control the logger behaviour at a
--   higher level than hooks.
--   
--   <ol>
--   <li>Hooks are used to define how to generate a
--   info<i>warning</i>error/dump messages</li>
--   <li>LogFlags are used to decide when and how to generate messages</li>
--   </ol>
module GHC.Utils.Logger
data Logger
class HasLogger m
getLogger :: HasLogger m => m Logger
class ContainsLogger t
extractLogger :: ContainsLogger t => t -> Logger
initLogger :: IO Logger
type LogAction = LogFlags -> MessageClass -> SrcSpan -> SDoc -> IO ()
type DumpAction = LogFlags -> PprStyle -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()
type TraceAction a = LogFlags -> String -> SDoc -> a -> a

-- | Format of a dump
--   
--   Dump formats are loosely defined: dumps may contain various additional
--   headers and annotations and they may be partial. <a>DumpFormat</a> is
--   mainly a hint (e.g. for syntax highlighters).
data DumpFormat

-- | Haskell
FormatHaskell :: DumpFormat

-- | Core
FormatCore :: DumpFormat

-- | STG
FormatSTG :: DumpFormat

-- | ByteCode
FormatByteCode :: DumpFormat

-- | Cmm
FormatCMM :: DumpFormat

-- | Assembly code
FormatASM :: DumpFormat

-- | C code/header
FormatC :: DumpFormat

-- | LLVM bytecode
FormatLLVM :: DumpFormat

-- | JavaScript code
FormatJS :: DumpFormat

-- | Unstructured dump
FormatText :: DumpFormat

-- | Pop a log hook
popLogHook :: Logger -> Logger

-- | Push a log hook
pushLogHook :: (LogAction -> LogAction) -> Logger -> Logger

-- | Pop a dump hook
popDumpHook :: Logger -> Logger

-- | Push a dump hook
pushDumpHook :: (DumpAction -> DumpAction) -> Logger -> Logger

-- | Pop a trace hook
popTraceHook :: Logger -> Logger

-- | Push a trace hook
pushTraceHook :: (forall a. TraceAction a -> TraceAction a) -> Logger -> Logger

-- | Make the logger thread-safe
makeThreadSafe :: Logger -> IO Logger

-- | Logger flags
data LogFlags
LogFlags :: SDocContext -> SDocContext -> !EnumSet DumpFlag -> !Bool -> !Bool -> !Bool -> !Bool -> !Maybe FilePath -> !FilePath -> !Maybe FilePath -> !Bool -> !Bool -> !Int -> !Maybe Ways -> LogFlags
[log_default_user_context] :: LogFlags -> SDocContext
[log_default_dump_context] :: LogFlags -> SDocContext

-- | Dump flags
[log_dump_flags] :: LogFlags -> !EnumSet DumpFlag

-- | Show caret in diagnostics
[log_show_caret] :: LogFlags -> !Bool

-- | Show warning flag groups
[log_show_warn_groups] :: LogFlags -> !Bool

-- | Enable timestamps
[log_enable_timestamps] :: LogFlags -> !Bool

-- | Enable dump to file
[log_dump_to_file] :: LogFlags -> !Bool

-- | Dump directory
[log_dump_dir] :: LogFlags -> !Maybe FilePath

-- | Normal dump path ("basename.")
[log_dump_prefix] :: LogFlags -> !FilePath

-- | Overriden dump path
[log_dump_prefix_override] :: LogFlags -> !Maybe FilePath

-- | Use different dump files names for different ways
[log_with_ways] :: LogFlags -> !Bool

-- | Enable debug output
[log_enable_debug] :: LogFlags -> !Bool

-- | Verbosity level
[log_verbosity] :: LogFlags -> !Int

-- | Current ways (to name dump files)
[log_ways] :: LogFlags -> !Maybe Ways

-- | Default LogFlags
defaultLogFlags :: LogFlags

-- | Test if a DumpFlag is enabled
log_dopt :: DumpFlag -> LogFlags -> Bool

-- | Enable a DumpFlag
log_set_dopt :: DumpFlag -> LogFlags -> LogFlags

-- | Set LogFlags
setLogFlags :: Logger -> LogFlags -> Logger

-- | Update LogFlags
updateLogFlags :: Logger -> (LogFlags -> LogFlags) -> Logger

-- | Logger flags
logFlags :: Logger -> LogFlags

-- | Test if a DumpFlag is set
logHasDumpFlag :: Logger -> DumpFlag -> Bool

-- | Test if verbosity is &gt;= to the given value
logVerbAtLeast :: Logger -> Int -> Bool
jsonLogAction :: LogAction

-- | Log something
putLogMsg :: Logger -> LogAction
defaultLogAction :: LogAction

-- | Like <a>defaultLogActionHPutStrDoc</a> but appends an extra newline.
defaultLogActionHPrintDoc :: LogFlags -> Bool -> Handle -> SDoc -> IO ()

-- | The boolean arguments let's the pretty printer know if it can optimize
--   indent by writing ascii ' ' characters without going through decoding.
defaultLogActionHPutStrDoc :: LogFlags -> Bool -> Handle -> SDoc -> IO ()

-- | Log something
logMsg :: Logger -> MessageClass -> SrcSpan -> SDoc -> IO ()

-- | Log a dump message (not a dump file)
logDumpMsg :: Logger -> String -> SDoc -> IO ()

-- | Default action for <tt>dumpAction</tt> hook
defaultDumpAction :: DumpCache -> LogAction -> DumpAction

-- | Dump something
putDumpFile :: Logger -> DumpAction

-- | Dump if the given DumpFlag is set
putDumpFileMaybe :: Logger -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()

-- | Dump if the given DumpFlag is set
--   
--   Unlike <a>putDumpFileMaybe</a>, has a NamePprCtx argument
putDumpFileMaybe' :: Logger -> NamePprCtx -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()

-- | Run an action with the handle of a <a>DumpFlag</a> if we are
--   outputting to a file, otherwise <a>Nothing</a>.
withDumpFileHandle :: DumpCache -> LogFlags -> DumpFlag -> (Maybe Handle -> IO ()) -> IO ()

-- | Ensure that a dump file is created even if it stays empty
touchDumpFile :: Logger -> DumpFlag -> IO ()

-- | Dump something
logDumpFile :: Logger -> PprStyle -> DumpFlag -> String -> DumpFormat -> SDoc -> IO ()

-- | Default action for <tt>traceAction</tt> hook
defaultTraceAction :: TraceAction a

-- | Trace something
putTraceMsg :: Logger -> TraceAction a

-- | Set the trace flushing function
--   
--   The currently set trace flushing function is passed to the updating
--   function
loggerTraceFlushUpdate :: Logger -> (IO () -> IO ()) -> Logger

-- | Calls the trace flushing function
loggerTraceFlush :: Logger -> IO ()

-- | Log a trace message
logTraceMsg :: Logger -> String -> SDoc -> a -> a
instance GHC.Classes.Eq GHC.Utils.Logger.DumpFormat
instance GHC.Show.Show GHC.Utils.Logger.DumpFormat

module GHC.Utils.Error
data Validity' a

-- | Everything is fine
IsValid :: Validity' a

-- | A problem, and some indication of why
NotValid :: a -> Validity' a

-- | Monomorphic version of <tt>Validity'</tt> specialised for
--   <a>SDoc</a>s.
type Validity = Validity' SDoc
andValid :: Validity' a -> Validity' a -> Validity' a

-- | If they aren't all valid, return the first
allValid :: [Validity' a] -> Validity' a
getInvalids :: [Validity' a] -> [a]

-- | Used to describe warnings and errors o The message has a
--   file/line/column heading, plus "warning:" or "error:", added by
--   mkLocMessage o With <a>SevIgnore</a> the message is suppressed o
--   Output is intended for end users
data Severity

-- | Ignore this message, for example in case of suppression of warnings
--   users don't want to see. See Note [Suppressing Messages]
SevIgnore :: Severity
SevWarning :: Severity
SevError :: Severity

-- | A class identifying a diagnostic. Dictionary.com defines a diagnostic
--   as:
--   
--   "a message output by a computer diagnosing an error in a computer
--   program, computer system, or component device".
--   
--   A <a>Diagnostic</a> carries the <i>actual</i> description of the
--   message (which, in GHC's case, it can be an error or a warning) and
--   the <i>reason</i> why such message was generated in the first place.
class Diagnostic a where {
    
    -- | Type of configuration options for the diagnostic.
    type DiagnosticOpts a;
}
defaultDiagnosticOpts :: Diagnostic a => DiagnosticOpts a

-- | Extract the error message text from a <a>Diagnostic</a>.
diagnosticMessage :: Diagnostic a => DiagnosticOpts a -> a -> DecoratedSDoc

-- | Extract the reason for this diagnostic. For warnings, a
--   <a>DiagnosticReason</a> includes the warning flag.
diagnosticReason :: Diagnostic a => a -> DiagnosticReason

-- | Extract any hints a user might use to repair their code to avoid this
--   diagnostic.
diagnosticHints :: Diagnostic a => a -> [GhcHint]

-- | Get the <a>DiagnosticCode</a> associated with this <a>Diagnostic</a>.
--   This can return <a>Nothing</a> for at least two reasons:
--   
--   <ol>
--   <li>The message might be from a plugin that does not supply
--   codes.</li>
--   <li>The message might not yet have been assigned a code. See the
--   <a>Diagnostic</a> instance for <a>DiagnosticMessage</a>.</li>
--   </ol>
--   
--   Ideally, case (2) would not happen, but because some errors in GHC
--   still use the old system of just writing the error message in-place
--   (instead of using a dedicated error type and constructor), we do not
--   have error codes for all errors. #18516 tracks our progress toward
--   this goal.
diagnosticCode :: Diagnostic a => a -> Maybe DiagnosticCode

-- | An envelope for GHC's facts about a running program, parameterised
--   over the <i>domain-specific</i> (i.e. parsing, typecheck-renaming,
--   etc) diagnostics.
--   
--   To say things differently, GHC emits <i>diagnostics</i> about the
--   running program, each of which is wrapped into a <a>MsgEnvelope</a>
--   that carries specific information like where the error happened, etc.
--   Finally, multiple <a>MsgEnvelope</a>s are aggregated into
--   <a>Messages</a> that are returned to the user.
data MsgEnvelope e
MsgEnvelope :: SrcSpan -> NamePprCtx -> e -> Severity -> MsgEnvelope e

-- | The SrcSpan is used for sorting errors into line-number order
[errMsgSpan] :: MsgEnvelope e -> SrcSpan
[errMsgContext] :: MsgEnvelope e -> NamePprCtx
[errMsgDiagnostic] :: MsgEnvelope e -> e
[errMsgSeverity] :: MsgEnvelope e -> Severity

-- | The class for a diagnostic message. The main purpose is to classify a
--   message within GHC, to distinguish it from a debug/dump message vs a
--   proper diagnostic, for which we include a <a>DiagnosticReason</a>.
data MessageClass
MCOutput :: MessageClass
MCFatal :: MessageClass
MCInteractive :: MessageClass

-- | Log message intended for compiler developers No file/line/column stuff
MCDump :: MessageClass

-- | Log messages intended for end users. No file/line/column stuff.
MCInfo :: MessageClass

-- | Diagnostics from the compiler. This constructor is very powerful as it
--   allows the construction of a <a>MessageClass</a> with a completely
--   arbitrary permutation of <a>Severity</a> and <a>DiagnosticReason</a>.
--   As such, users are encouraged to use the <tt>mkMCDiagnostic</tt> smart
--   constructor instead. Use this constructor directly only if you need to
--   construct and manipulate diagnostic messages directly, for example
--   inside <a>Error</a>. In all the other circumstances, <i>especially</i>
--   when emitting compiler diagnostics, use the smart constructor.
--   
--   The <tt>Maybe <a>DiagnosticCode</a></tt> field carries a code (if
--   available) for this diagnostic. If you are creating a message not tied
--   to any error-message type, then use Nothing. In the long run, this
--   really should always have a <a>DiagnosticCode</a>. See Note
--   [Diagnostic codes].
MCDiagnostic :: Severity -> DiagnosticReason -> Maybe DiagnosticCode -> MessageClass

-- | Represents a pretty-printable document.
--   
--   To display an <a>SDoc</a>, use <a>printSDoc</a>, <a>printSDocLn</a>,
--   <a>bufLeftRenderSDoc</a>, or <a>renderWithContext</a>. Avoid calling
--   <a>runSDoc</a> directly as it breaks the abstraction layer.
data SDoc

-- | A <a>DecoratedSDoc</a> is isomorphic to a '[SDoc]' but it carries the
--   invariant that the input '[SDoc]' needs to be rendered
--   <i>decorated</i> into its final form, where the typical case would be
--   adding bullets between each elements of the list. The type of
--   decoration depends on the formatting function used, but in practice
--   GHC uses the <tt>formatBulleted</tt>.
data DecoratedSDoc

-- | A collection of messages emitted by GHC during error reporting. A
--   diagnostic message is typically a warning or an error. See Note
--   [Messages].
--   
--   <i>INVARIANT</i>: All the messages in this collection must be
--   relevant, i.e. their <a>Severity</a> should <i>not</i> be
--   <a>SevIgnore</a>. The smart constructor <a>mkMessages</a> will filter
--   out any message which <a>Severity</a> is <a>SevIgnore</a>.
data Messages e
mkMessages :: Bag (MsgEnvelope e) -> Messages e

-- | Joins two collections of messages together. See Note [Discarding
--   Messages].
unionMessages :: Messages e -> Messages e -> Messages e

-- | Are there any hard errors here? -Werror warnings are <i>not</i>
--   detected. If you want to check for -Werror warnings, use
--   <a>errorsOrFatalWarningsFound</a>.
errorsFound :: Diagnostic e => Messages e -> Bool
isEmptyMessages :: Messages e -> Bool
pprMessageBag :: Bag SDoc -> SDoc
pprMsgEnvelopeBagWithLoc :: Diagnostic e => DiagnosticOpts e -> Bag (MsgEnvelope e) -> [SDoc]

-- | Print the messages with the suitable default configuration, usually
--   not what you want but sometimes you don't really care about what the
--   configuration is (for example, if the message is in a panic).
pprMsgEnvelopeBagWithLocDefault :: forall e. Diagnostic e => Bag (MsgEnvelope e) -> [SDoc]
pprMessages :: Diagnostic e => DiagnosticOpts e -> Messages e -> SDoc
pprLocMsgEnvelope :: Diagnostic e => DiagnosticOpts e -> MsgEnvelope e -> SDoc
pprLocMsgEnvelopeDefault :: forall e. Diagnostic e => MsgEnvelope e -> SDoc

-- | Formats the input list of structured document, where each element of
--   the list gets a bullet.
formatBulleted :: SDocContext -> DecoratedSDoc -> SDoc
data DiagOpts
DiagOpts :: !EnumSet WarningFlag -> !EnumSet WarningFlag -> !Bool -> !Bool -> !Maybe Int -> !SDocContext -> DiagOpts

-- | Enabled warnings
[diag_warning_flags] :: DiagOpts -> !EnumSet WarningFlag

-- | Fatal warnings
[diag_fatal_warning_flags] :: DiagOpts -> !EnumSet WarningFlag

-- | Treat warnings as errors
[diag_warn_is_error] :: DiagOpts -> !Bool

-- | Reverse error reporting order
[diag_reverse_errors] :: DiagOpts -> !Bool

-- | Max reported error count
[diag_max_errors] :: DiagOpts -> !Maybe Int

-- | Error printing context
[diag_ppr_ctx] :: DiagOpts -> !SDocContext
diag_wopt :: WarningFlag -> DiagOpts -> Bool
diag_fatal_wopt :: WarningFlag -> DiagOpts -> Bool
emptyMessages :: Messages e

-- | Creates a new <a>DecoratedSDoc</a> out of a list of <a>SDoc</a>.
mkDecorated :: [SDoc] -> DecoratedSDoc
mkLocMessage :: MessageClass -> SrcSpan -> SDoc -> SDoc

-- | Wrap a <a>Diagnostic</a> in a <a>MsgEnvelope</a>, recording its
--   location. If you know your <a>Diagnostic</a> is an error, consider
--   using <a>mkErrorMsgEnvelope</a>, which does not require looking at the
--   <a>DiagOpts</a>
mkMsgEnvelope :: Diagnostic e => DiagOpts -> SrcSpan -> NamePprCtx -> e -> MsgEnvelope e

-- | Variant that doesn't care about qualified/unqualified names.
mkPlainMsgEnvelope :: Diagnostic e => DiagOpts -> SrcSpan -> e -> MsgEnvelope e

-- | Variant of <a>mkPlainMsgEnvelope</a> which can be used when we are
--   <i>sure</i> we are constructing a diagnostic with a
--   <a>ErrorWithoutFlag</a> reason.
mkPlainErrorMsgEnvelope :: Diagnostic e => SrcSpan -> e -> MsgEnvelope e

-- | Wrap a <a>Diagnostic</a> in a <a>MsgEnvelope</a>, recording its
--   location. Precondition: the diagnostic is, in fact, an error. That is,
--   <tt>diagnosticReason msg == ErrorWithoutFlag</tt>.
mkErrorMsgEnvelope :: Diagnostic e => SrcSpan -> NamePprCtx -> e -> MsgEnvelope e

-- | Make a <a>MessageClass</a> for a given <a>DiagnosticReason</a>,
--   consulting the 'DiagOpts.
mkMCDiagnostic :: DiagOpts -> DiagnosticReason -> Maybe DiagnosticCode -> MessageClass

-- | Varation of <a>mkMCDiagnostic</a> which can be used when we are
--   <i>sure</i> the input <a>DiagnosticReason</a> <i>is</i>
--   <a>ErrorWithoutFlag</a> and there is no diagnostic code.
errorDiagnostic :: MessageClass

-- | Computes the <i>right</i> <a>Severity</a> for the input
--   <a>DiagnosticReason</a> out of the 'DiagOpts. This function <i>has</i>
--   to be called when a diagnostic is constructed, i.e. with a 'DiagOpts
--   "snapshot" taken as close as possible to where a particular diagnostic
--   message is built, otherwise the computed <a>Severity</a> might not be
--   correct, due to the mutable nature of the <tt>DynFlags</tt> in GHC.
diagReasonSeverity :: DiagOpts -> DiagnosticReason -> Severity

-- | Create an error <a>DiagnosticMessage</a> holding just a single
--   <a>SDoc</a>
mkPlainError :: [GhcHint] -> SDoc -> DiagnosticMessage
mkPlainDiagnostic :: DiagnosticReason -> [GhcHint] -> SDoc -> DiagnosticMessage

-- | Create an error <a>DiagnosticMessage</a> from a list of bulleted SDocs
mkDecoratedError :: [GhcHint] -> [SDoc] -> DiagnosticMessage

-- | Create a <a>DiagnosticMessage</a> from a list of bulleted SDocs and a
--   <a>DiagnosticReason</a>
mkDecoratedDiagnostic :: DiagnosticReason -> [GhcHint] -> [SDoc] -> DiagnosticMessage

-- | Helper function to use when no hints can be provided. Currently this
--   function can be used to construct plain <a>DiagnosticMessage</a> and
--   add hints to them, but once #18516 will be fully executed, the main
--   usage of this function would be in the implementation of the
--   <a>diagnosticHints</a> typeclass method, to report the fact that a
--   particular <a>Diagnostic</a> has no hints.
noHints :: [GhcHint]
getCaretDiagnostic :: MessageClass -> SrcSpan -> IO SDoc
putMsg :: Logger -> SDoc -> IO ()
printInfoForUser :: Logger -> NamePprCtx -> SDoc -> IO ()
printOutputForUser :: Logger -> NamePprCtx -> SDoc -> IO ()
logInfo :: Logger -> SDoc -> IO ()

-- | Like <a>logInfo</a> but with <tt>SevOutput</tt> rather then
--   <tt>SevInfo</tt>
logOutput :: Logger -> SDoc -> IO ()
errorMsg :: Logger -> SDoc -> IO ()
fatalErrorMsg :: Logger -> SDoc -> IO ()
compilationProgressMsg :: Logger -> SDoc -> IO ()
showPass :: Logger -> String -> IO ()

-- | Time a compilation phase.
--   
--   When timings are enabled (e.g. with the <tt>-v2</tt> flag), the
--   allocations and CPU time used by the phase will be reported to stderr.
--   Consider a typical usage: <tt>withTiming getDynFlags (text "simplify")
--   force PrintTimings pass</tt>. When timings are enabled the following
--   costs are included in the produced accounting,
--   
--   <ul>
--   <li>The cost of executing <tt>pass</tt> to a result <tt>r</tt> in
--   WHNF</li>
--   <li>The cost of evaluating <tt>force r</tt> to WHNF (e.g.
--   <tt>()</tt>)</li>
--   </ul>
--   
--   The choice of the <tt>force</tt> function depends upon the amount of
--   forcing desired; the goal here is to ensure that the cost of
--   evaluating the result is, to the greatest extent possible, included in
--   the accounting provided by <a>withTiming</a>. Often the pass already
--   sufficiently forces its result during construction; in this case
--   <tt>const ()</tt> is a reasonable choice. In other cases, it is
--   necessary to evaluate the result to normal form, in which case
--   something like <tt>Control.DeepSeq.rnf</tt> is appropriate.
--   
--   To avoid adversely affecting compiler performance when timings are not
--   requested, the result is only forced when timings are enabled.
--   
--   See Note [withTiming] for more.
withTiming :: MonadIO m => Logger -> SDoc -> (a -> ()) -> m a -> m a

-- | Same as <a>withTiming</a>, but doesn't print timings in the console
--   (when given <tt>-vN</tt>, <tt>N &gt;= 2</tt> or
--   <tt>-ddump-timings</tt>).
--   
--   See Note [withTiming] for more.
withTimingSilent :: MonadIO m => Logger -> SDoc -> (a -> ()) -> m a -> m a
debugTraceMsg :: Logger -> Int -> SDoc -> IO ()
ghcExit :: Logger -> Int -> IO ()
prettyPrintGhcErrors :: ExceptionMonad m => Logger -> m a -> m a

-- | Trace a command (when verbosity level &gt;= 3)
traceCmd :: Logger -> String -> String -> IO a -> IO a

-- | Record in the eventlog when the given tool command starts and
--   finishes, prepending the given <a>String</a> with "systool:", to
--   easily be able to collect and process all the systool events.
--   
--   For those events to show up in the eventlog, you need to run GHC with
--   <tt>-v2</tt> or <tt>-ddump-timings</tt>.
traceSystoolCommand :: Logger -> String -> IO a -> IO a
sortMsgBag :: Maybe DiagOpts -> Bag (MsgEnvelope e) -> [MsgEnvelope e]
instance GHC.Base.Functor GHC.Utils.Error.Validity'
instance GHC.Show.Show GHC.Utils.Error.PrintTimings
instance GHC.Classes.Eq GHC.Utils.Error.PrintTimings


-- | Temporary file-system management
module GHC.Utils.TmpFs

-- | Temporary file-system
data TmpFs

-- | Initialise an empty TmpFs
initTmpFs :: IO TmpFs

-- | Initialise an empty TmpFs sharing unique numbers and per-process
--   temporary directories with the given TmpFs
--   
--   It's not safe to use the subdirs created by the original TmpFs with
--   the forked one. Use <tt>newTempSubDir</tt> to create new subdirs
--   instead.
forkTmpFsFrom :: TmpFs -> IO TmpFs

-- | Merge the first TmpFs into the second.
--   
--   The first TmpFs is returned emptied.
mergeTmpFsInto :: TmpFs -> TmpFs -> IO ()

-- | A collection of paths that must be deleted before ghc exits.
data PathsToClean
PathsToClean :: !Set FilePath -> !Set FilePath -> PathsToClean

-- | Paths that will be deleted at the end of runGhc(T)
[ptcGhcSession] :: PathsToClean -> !Set FilePath

-- | Paths that will be deleted the next time
--   <a>cleanCurrentModuleTempFiles</a> is called, or otherwise at the end
--   of the session.
[ptcCurrentModule] :: PathsToClean -> !Set FilePath

-- | An empty PathsToClean
emptyPathsToClean :: PathsToClean

-- | Used when a temp file is created. This determines which component Set
--   of PathsToClean will get the temp file
data TempFileLifetime

-- | A file with lifetime TFL_CurrentModule will be cleaned up at the end
--   of upweep_mod
TFL_CurrentModule :: TempFileLifetime

-- | A file with lifetime TFL_GhcSession will be cleaned up at the end of
--   runGhc(T)
TFL_GhcSession :: TempFileLifetime
newtype TempDir
TempDir :: FilePath -> TempDir
cleanTempDirs :: Logger -> TmpFs -> IO ()

-- | Delete all paths in <tt>tmp_files_to_clean</tt> and
--   <tt>tmp_subdirs_to_clean</tt>.
cleanTempFiles :: Logger -> TmpFs -> IO ()

-- | Delete all paths in <tt>tmp_files_to_clean</tt> and
--   <tt>tmp_subdirs_to_clean</tt> That have lifetime TFL_CurrentModule. If
--   a file must be cleaned eventually, but must survive a
--   cleanCurrentModuleTempFiles, ensure it has lifetime TFL_GhcSession.
cleanCurrentModuleTempFiles :: Logger -> TmpFs -> IO ()

-- | Keep all the paths in <tt>tmp_files_to_clean</tt> and
--   <tt>tmp_subdirs_to_clean</tt> that have lifetime TFL_CurrentModule.
--   This function is used when `-keep-tmp-files` is used in an OPTIONS_GHC
--   pragma. This function removes the temporary file from the TmpFs so we
--   no longer remove it at the env when cleanTempFiles is called.
keepCurrentModuleTempFiles :: HasCallStack => Logger -> TmpFs -> IO ()

-- | Ensure that new_files are cleaned on the next call of
--   <a>cleanTempFiles</a> or <a>cleanCurrentModuleTempFiles</a>, depending
--   on lifetime. If any of new_files are already tracked, they will have
--   their lifetime updated.
addFilesToClean :: TmpFs -> TempFileLifetime -> [FilePath] -> IO ()

-- | Update the lifetime of files already being tracked. If any files are
--   not being tracked they will be discarded.
changeTempFilesLifetime :: TmpFs -> TempFileLifetime -> [FilePath] -> IO ()
newTempName :: Logger -> TmpFs -> TempDir -> TempFileLifetime -> Suffix -> IO FilePath
newTempLibName :: Logger -> TmpFs -> TempDir -> TempFileLifetime -> Suffix -> IO (FilePath, FilePath, String)

-- | Create a new temporary subdirectory that doesn't already exist The
--   temporary subdirectory is automatically removed at the end of the GHC
--   session, but its contents aren't. Make sure to leave the directory
--   empty before the end of the session, either by removing content
--   directly or by using <tt>addFilesToClean</tt>.
--   
--   If the created subdirectory is not empty, it will not be removed
--   (along with its parent temporary directory) and a warning message will
--   be printed at verbosity 2 and higher.
newTempSubDir :: Logger -> TmpFs -> TempDir -> IO FilePath

-- | Create and use a temporary directory in the system standard temporary
--   directory.
--   
--   Behaves exactly the same as <a>withTempDirectory</a>, except that the
--   parent temporary directory will be that returned by
--   <a>getTemporaryDirectory</a>.
withSystemTempDirectory :: String -> (FilePath -> IO a) -> IO a

-- | Create and use a temporary directory.
--   
--   Creates a new temporary directory inside the given directory, making
--   use of the template. The temp directory is deleted after use. For
--   example:
--   
--   <pre>
--   withTempDirectory "src" "sdist." $ \tmpDir -&gt; do ...
--   </pre>
--   
--   The <tt>tmpDir</tt> will be a new subdirectory of the given directory,
--   e.g. <tt>src/sdist.342</tt>.
withTempDirectory :: FilePath -> String -> (FilePath -> IO a) -> IO a
instance GHC.Show.Show GHC.Utils.TmpFs.TempFileLifetime


-- | The stg to cmm code generator configuration
module GHC.StgToCmm.Config
data StgToCmmConfig
StgToCmmConfig :: !Profile -> Module -> !TempDir -> !SDocContext -> !Bool -> !Maybe Word -> !Int -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> Maybe String -> !Bool -> !Bool -> !Bool -> StgToCmmConfig

-- | Current profile
[stgToCmmProfile] :: StgToCmmConfig -> !Profile

-- | The module being compiled. This field kept lazy for Cmm/Parser.y which
--   preloads it with a panic
[stgToCmmThisModule] :: StgToCmmConfig -> Module

-- | Temp Dir for files used in compilation
[stgToCmmTmpDir] :: StgToCmmConfig -> !TempDir

-- | Context for StgToCmm phase
[stgToCmmContext] :: StgToCmmConfig -> !SDocContext

-- | Whether we wish to output debug information
[stgToCmmEmitDebugInfo] :: StgToCmmConfig -> !Bool

-- | Threshold at which Binary literals (e.g. strings) are either dumped to
--   a file and a CmmFileEmbed literal is emitted (over threshold), or
--   become a CmmString Literal (under or at threshold). CmmFileEmbed is
--   only supported with the NCG, thus a Just means two things: We have a
--   threshold, and will be using the NCG. Conversely, a Nothing implies we
--   are not using NCG and disables CmmFileEmbed. See Note [Embedding large
--   binary blobs] in GHC.CmmToAsm.Ppr, and <tt>cgTopBinding</tt> in
--   GHC.StgToCmm.
[stgToCmmBinBlobThresh] :: StgToCmmConfig -> !Maybe Word

-- | Max size, in bytes, of inline array allocations.
[stgToCmmMaxInlAllocSize] :: StgToCmmConfig -> !Int

-- | Ticky profiling enabled (cf <tt>-ticky</tt>)
[stgToCmmDoTicky] :: StgToCmmConfig -> !Bool

-- | True indicates ticky prof traces allocs of each named thing in
--   addition to allocs _by_ that thing
[stgToCmmTickyAllocd] :: StgToCmmConfig -> !Bool

-- | True indicates ticky uses name-specific counters for join-points
--   (let-no-escape)
[stgToCmmTickyLNE] :: StgToCmmConfig -> !Bool

-- | True indicates ticky uses name-specific counters for dynamic thunks
[stgToCmmTickyDynThunk] :: StgToCmmConfig -> !Bool

-- | True indicates ticky will count number of avoided tag checks by tag
--   inference.
[stgToCmmTickyTag] :: StgToCmmConfig -> !Bool

-- | Loopification enabled (cf <tt>-floopification</tt>)
[stgToCmmLoopification] :: StgToCmmConfig -> !Bool

-- | Insert alignment check (cf <tt>-falignment-sanitisation</tt>)
[stgToCmmAlignCheck] :: StgToCmmConfig -> !Bool

-- | perform code generation for code coverage
[stgToCmmOptHpc] :: StgToCmmConfig -> !Bool
[stgToCmmFastPAPCalls] :: StgToCmmConfig -> !Bool

-- | Check if cost-centre profiling is enabled
[stgToCmmSCCProfiling] :: StgToCmmConfig -> !Bool
[stgToCmmEagerBlackHole] :: StgToCmmConfig -> !Bool

-- | true means generate C Stub for IPE map, See Note [Mapping Info Tables
--   to Source Positions]
[stgToCmmInfoTableMap] :: StgToCmmConfig -> !Bool

-- | Include info tables with fallback source locations in the info table
--   map
[stgToCmmInfoTableMapWithFallback] :: StgToCmmConfig -> !Bool

-- | Include info tables for STACK closures in the info table map
[stgToCmmInfoTableMapWithStack] :: StgToCmmConfig -> !Bool

-- | true means omit heap checks when no allocation is performed
[stgToCmmOmitYields] :: StgToCmmConfig -> !Bool

-- | true means don't generate interface programs (implied by -O0)
[stgToCmmOmitIfPragmas] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fPIC</tt>
[stgToCmmPIC] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fPIE</tt>
[stgToCmmPIE] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fexternal-dynamic-refs</tt>, meaning generate code for
--   linking against dynamic libraries
[stgToCmmExtDynRefs] :: StgToCmmConfig -> !Bool

-- | decides whether to check array bounds in StgToCmm.Prim or not
[stgToCmmDoBoundsCheck] :: StgToCmmConfig -> !Bool

-- | Verify tag inference predictions.
[stgToCmmDoTagCheck] :: StgToCmmConfig -> !Bool

-- | Allowed to emit larger than native size arithmetic (only LLVM and C
--   backends)
[stgToCmmAllowBigArith] :: StgToCmmConfig -> !Bool

-- | Allowed to generate QuotRem instructions
[stgToCmmAllowQuotRemInstr] :: StgToCmmConfig -> !Bool

-- | Allowed to generate QuotRem
[stgToCmmAllowQuotRem2] :: StgToCmmConfig -> !Bool

-- | Allowed to generate AddWordC, SubWordC, Add2, etc.
[stgToCmmAllowExtendedAddSubInstrs] :: StgToCmmConfig -> !Bool

-- | Allowed to generate IntMul2 instruction
[stgToCmmAllowIntMul2Instr] :: StgToCmmConfig -> !Bool

-- | Disable use of precomputed standard thunks.
[stgToCmmTickyAP] :: StgToCmmConfig -> !Bool

-- | Error (if any) to raise when vector instructions are used, see
--   <tt>StgToCmm.Prim.checkVecCompatibility</tt>
[stgToCmmVecInstrsErr] :: StgToCmmConfig -> Maybe String

-- | check for Advanced Vector Extensions
[stgToCmmAvx] :: StgToCmmConfig -> !Bool

-- | check for Advanced Vector Extensions 2
[stgToCmmAvx2] :: StgToCmmConfig -> !Bool

-- | check for Advanced Vector 512-bit Extensions
[stgToCmmAvx512f] :: StgToCmmConfig -> !Bool
stgToCmmPlatform :: StgToCmmConfig -> Platform


-- | The <a>TPipelineClass</a> and <a>MonadUse</a> classes and associated
--   types
module GHC.Driver.Pipeline.Monad
type TPipelineClass (f :: Type -> Type) (m :: Type -> Type) = (Functor m, MonadIO m, Applicative m, Monad m, MonadUse f m)

-- | Lift a <tt>f</tt> action into an <tt>m</tt> action.
class MonadUse f m
use :: MonadUse f m => f a -> m a
data PipeEnv
PipeEnv :: StopPhase -> String -> String -> String -> Phase -> PipelineOutput -> PipeEnv

-- | Stop just after this phase
[stop_phase] :: PipeEnv -> StopPhase

-- | basename of original input source
[src_filename] :: PipeEnv -> String

-- | basename of original input source
[src_basename] :: PipeEnv -> String

-- | its extension
[src_suffix] :: PipeEnv -> String
[start_phase] :: PipeEnv -> Phase

-- | says where to put the pipeline output
[output_spec] :: PipeEnv -> PipelineOutput
data PipelineOutput

-- | Output should be to a temporary file: we're going to run more
--   compilation steps on this output later.
Temporary :: TempFileLifetime -> PipelineOutput

-- | We want a persistent file, i.e. a file in the current directory
--   derived from the input filename, but with the appropriate extension.
--   eg. in "ghc -c Foo.hs" the output goes into ./Foo.o.
Persistent :: PipelineOutput

-- | The output must go into the specific outputFile in DynFlags. We don't
--   store the filename in the constructor as it changes when doing
--   -dynamic-too.
SpecificFile :: PipelineOutput

-- | No output should be created, like in Interpreter or NoBackend.
NoOutputFile :: PipelineOutput
instance GHC.Show.Show GHC.Driver.Pipeline.Monad.PipelineOutput

module GHC.SysTools.Elf

-- | Given a section name, read its contents as a ByteString.
--   
--   If the section isn't found or if there is any parsing error, we return
--   Nothing
readElfSectionByName :: Logger -> ByteString -> String -> IO (Maybe ByteString)

-- | read a Note as a String
--   
--   If you try to read a note from a section which does not support the
--   Note format, the parsing is likely to fail and Nothing will be
--   returned
readElfNoteAsString :: Logger -> FilePath -> String -> String -> IO (Maybe String)

-- | Generate the GAS code to create a Note section
--   
--   Header fields for notes are 32-bit long (see Note [ELF
--   specification]).
makeElfNote :: Platform -> String -> String -> Word32 -> String -> SDoc


-- | This module exports the <a>Backend</a> type and all the available
--   values of that type. The type is abstract, and GHC assumes a "closed
--   world": all the back ends are known and are known here. The compiler
--   driver chooses a <a>Backend</a> value based on how it is asked to
--   generate code.
--   
--   A <a>Backend</a> value encapsulates the knowledge needed to take Cmm,
--   STG, or Core and write assembly language to a file. A back end also
--   provides a function that enables the compiler driver to run an
--   assembler on the code that is written, if any (the "post-backend
--   pipeline"). Finally, a back end has myriad <i>properties</i>.
--   Properties mediate interactions between a back end and the rest of the
--   compiler, especially the driver. Examples include the following:
--   
--   <ul>
--   <li>Property <a>backendValidityOfCImport</a> says whether the back end
--   can import foreign C functions.</li>
--   <li>Property <a>backendForcesOptimization0</a> says whether the back
--   end can be used with optimization levels higher than `-O0`.</li>
--   <li>Property <a>backendCDefs</a> tells the compiler driver, "if you're
--   using this back end, then these are the command-line flags you should
--   add to any invocation of the C compiler."</li>
--   </ul>
--   
--   These properties are used elsewhere in GHC, primarily in the driver,
--   to fine-tune operations according to the capabilities of the chosen
--   back end. You might use a property to make GHC aware of a potential
--   limitation of certain back ends, or a special feature available only
--   in certain back ends. If your client code needs to know a fact that is
--   not exposed in an existing property, you would define and export a new
--   property. Conditioning client code on the <i>identity</i> or
--   <i>name</i> of a back end is Not Done.
--   
--   For full details, see the documentation of each property.
module GHC.Driver.Backend

-- | A value of type <tt>Backend</tt> represents one of GHC's back ends.
--   The set of back ends cannot be extended except by modifying the
--   definition of <tt>Backend</tt> in this module.
--   
--   The <tt>Backend</tt> type is abstract; that is, its value constructors
--   are not exported. It's crucial that they not be exported, because a
--   value of type <tt>Backend</tt> carries only the back end's
--   <i>name</i>, not its behavior or properties. If <tt>Backend</tt> were
--   not abstract, then code elsewhere in the compiler could depend
--   directly on the name, not on the semantics, which would make it
--   challenging to create a new back end. Because <tt>Backend</tt>
--   <i>is</i> abstract, all the obligations of a new back end are
--   enumerated in this module, in the form of functions that take
--   <tt>Backend</tt> as an argument.
--   
--   The issue of abstraction is discussed at great length in #20927 and
--   !7442.
data Backend

-- | The native code generator. Compiles Cmm code into textual assembler,
--   then relies on an external assembler toolchain to produce machine
--   code.
--   
--   Only supports a few platforms (X86, PowerPC, SPARC).
--   
--   See <a>GHC.CmmToAsm</a>.
ncgBackend :: Backend

-- | The LLVM backend.
--   
--   Compiles Cmm code into LLVM textual IR, then relies on LLVM toolchain
--   to produce machine code.
--   
--   It relies on LLVM support for the calling convention used by the NCG
--   backend to produce code objects ABI compatible with it (see "cc 10" or
--   "ghccc" calling convention in
--   <a>https://llvm.org/docs/LangRef.html#calling-conventions)</a>.
--   
--   Supports a few platforms (X86, AArch64, s390x, ARM).
--   
--   See <a>GHC.CmmToLlvm</a>
llvmBackend :: Backend

-- | The JavaScript Backend
--   
--   See documentation in GHC.StgToJS
jsBackend :: Backend

-- | Via-C ("unregisterised") backend.
--   
--   Compiles Cmm code into C code, then relies on a C compiler to produce
--   machine code.
--   
--   It produces code objects that are <i>not</i> ABI compatible with those
--   produced by NCG and LLVM backends.
--   
--   Produced code is expected to be less efficient than the one produced
--   by NCG and LLVM backends because STG registers are not pinned into
--   real registers. On the other hand, it supports more target platforms
--   (those having a valid C toolchain).
--   
--   See <a>GHC.CmmToC</a>
viaCBackend :: Backend

-- | The ByteCode interpreter.
--   
--   Produce ByteCode objects (BCO, see <a>GHC.ByteCode</a>) that can be
--   interpreted. It is used by GHCi.
--   
--   Currently some extensions are not supported (foreign primops).
--   
--   See <a>GHC.StgToByteCode</a>
interpreterBackend :: Backend

-- | A dummy back end that generates no code.
--   
--   Use this back end to disable code generation. It is particularly
--   useful when GHC is used as a library for other purpose than generating
--   code (e.g. to generate documentation with Haddock) or when the user
--   requested it (via `-fno-code`) for some reason.
noBackend :: Backend

-- | A list of all back ends. They are ordered as we wish them to appear
--   when they are enumerated in error messages.
allBackends :: [Backend]

-- | This enumeration type specifies how the back end wishes GHC's
--   primitives to be implemented. (Module <a>GHC.StgToCmm.Prim</a>
--   provides a generic implementation of every primitive, but some
--   primitives, like <tt>IntQuotRemOp</tt>, can be implemented more
--   efficiently by certain back ends on certain platforms. For example, by
--   using a machine instruction that simultaneously computes quotient and
--   remainder.)
--   
--   For the meaning of each alternative, consult
--   <a>GHC.StgToCmm.Config</a>. (In a perfect world, type
--   <a>PrimitiveImplementation</a> would be defined there, in the module
--   that determines its meaning. But I could not figure out how to do it
--   without mutual recursion across module boundaries.)
data PrimitiveImplementation

-- | Primitives supported by LLVM
LlvmPrimitives :: PrimitiveImplementation

-- | Primitives supported by the native code generator
NcgPrimitives :: PrimitiveImplementation

-- | Primitives supported by JS backend
JSPrimitives :: PrimitiveImplementation

-- | Primitives supported by all back ends
GenericPrimitives :: PrimitiveImplementation

-- | Names a function that generates code and writes the results to a file,
--   of this type:
--   
--   <pre>
--      Logger
--   -&gt; DynFlags
--   -&gt; Module -- ^ module being compiled
--   -&gt; ModLocation
--   -&gt; FilePath -- ^ Where to write output
--   -&gt; Set UnitId -- ^ dependencies
--   -&gt; Stream IO RawCmmGroup a -- results from `StgToCmm`
--   -&gt; IO a
--   </pre>
--   
--   The functions so named are defined in <a>GHC.Driver.CodeOutput</a>.
--   
--   We expect one function per back end—or more precisely, one function
--   for each back end that writes code to a file. (The interpreter does
--   not write to files; its output lives only in memory.)
data DefunctionalizedCodeOutput
NcgCodeOutput :: DefunctionalizedCodeOutput
ViaCCodeOutput :: DefunctionalizedCodeOutput
LlvmCodeOutput :: DefunctionalizedCodeOutput
JSCodeOutput :: DefunctionalizedCodeOutput

-- | Names a function that tells the driver what should happen after
--   assembly code is written. This might include running a C compiler,
--   running LLVM, running an assembler, or various similar activities. The
--   function named normally has this type:
--   
--   <pre>
--      TPipelineClass TPhase m
--   =&gt; PipeEnv
--   -&gt; HscEnv
--   -&gt; Maybe ModLocation
--   -&gt; FilePath
--   -&gt; m (Maybe FilePath)
--   </pre>
--   
--   The functions so named are defined in <a>GHC.Driver.Pipeline</a>.
data DefunctionalizedPostHscPipeline
NcgPostHscPipeline :: DefunctionalizedPostHscPipeline
ViaCPostHscPipeline :: DefunctionalizedPostHscPipeline
LlvmPostHscPipeline :: DefunctionalizedPostHscPipeline
JSPostHscPipeline :: DefunctionalizedPostHscPipeline

-- | After code generation, nothing else need happen.
NoPostHscPipeline :: DefunctionalizedPostHscPipeline

-- | Names a function that runs the assembler, of this type:
--   
--   <pre>
--   Logger -&gt; DynFlags -&gt; Platform -&gt; [Option] -&gt; IO ()
--   </pre>
--   
--   The functions so named are defined in
--   <a>GHC.Driver.Pipeline.Execute</a>.
data DefunctionalizedAssemblerProg

-- | Use the standard system assembler
StandardAssemblerProg :: DefunctionalizedAssemblerProg

-- | JS Backend compile to JS via Stg, and so does not use any assembler
JSAssemblerProg :: DefunctionalizedAssemblerProg

-- | If running on Darwin, use the assembler from the <tt>clang</tt>
--   toolchain. Otherwise use the standard system assembler.
DarwinClangAssemblerProg :: DefunctionalizedAssemblerProg

-- | Names a function that discover from what toolchain the assembler is
--   coming, of this type:
--   
--   <pre>
--   Logger -&gt; DynFlags -&gt; Platform -&gt; IO CompilerInfo
--   </pre>
--   
--   The functions so named are defined in
--   <a>GHC.Driver.Pipeline.Execute</a>.
data DefunctionalizedAssemblerInfoGetter

-- | Interrogate the standard system assembler
StandardAssemblerInfoGetter :: DefunctionalizedAssemblerInfoGetter

-- | If using the JS backend; return <tt>Emscripten</tt>
JSAssemblerInfoGetter :: DefunctionalizedAssemblerInfoGetter

-- | If running on Darwin, return <tt>Clang</tt>; otherwise interrogate the
--   standard system assembler.
DarwinClangAssemblerInfoGetter :: DefunctionalizedAssemblerInfoGetter

-- | Names a function that tells the driver what command-line options to
--   include when invoking a C compiler. It's meant for <tt>-D</tt> options
--   that define symbols for the C preprocessor. Because the exact symbols
--   defined might depend on versions of tools located in the file system
--   (<i>cough</i> LLVM <i>cough</i>), the function requires an <a>IO</a>
--   action. The function named has this type:
--   
--   <pre>
--   Logger -&gt; DynFlags -&gt; IO [String]
--   </pre>
data DefunctionalizedCDefs

-- | No additional command-line options are needed
NoCDefs :: DefunctionalizedCDefs

-- | Return command-line options that tell GHC about the LLVM version.
LlvmCDefs :: DefunctionalizedCDefs
data BackendName

-- | An informal description of the back end, for use in issuing warning
--   messages <i>only</i>. If code depends on what's in the string, you
--   deserve what happens to you.
backendDescription :: Backend -> String

-- | This flag tells the compiler driver whether the back end will write
--   files: interface files and object files. It is typically true for
--   "real" back ends that generate code into the filesystem. (That means,
--   not the interpreter.)
backendWritesFiles :: Backend -> Bool

-- | When the back end does write files, this value tells the compiler in
--   what manner of file the output should go: temporary, persistent, or
--   specific.
backendPipelineOutput :: Backend -> PipelineOutput

-- | This flag tells the driver whether the back end can reuse code
--   (bytecode or object code) that has been loaded dynamically. Likely
--   true only of the interpreter.
backendCanReuseLoadedCode :: Backend -> Bool

-- | It is is true of every back end except <tt>-fno-code</tt> that it
--   "generates code." Surprisingly, this property influences the driver in
--   a ton of ways. Some examples:
--   
--   <ul>
--   <li>If the back end does not generate code, then the driver needs to
--   turn on code generation for Template Haskell (because that code needs
--   to be generated and run at compile time).</li>
--   <li>If the back end does not generate code, then the driver does not
--   need to deal with an output file.</li>
--   <li>If the back end <i>does</i> generated code, then the driver
--   supports <tt>HscRecomp</tt>. If not, recompilation does not need a
--   linkable (and is automatically up to date).</li>
--   </ul>
backendGeneratesCode :: Backend -> Bool
backendGeneratesCodeForHsBoot :: Backend -> Bool

-- | When set, this flag turns on interface writing for Backpack. It should
--   probably be the same as <a>backendGeneratesCode</a>, but it is kept
--   distinct for reasons described in Note [-fno-code mode].
backendSupportsInterfaceWriting :: Backend -> Bool

-- | When preparing code for this back end, the type checker should pay
--   attention to SPECIALISE pragmas. If this flag is <a>False</a>, then
--   the type checker ignores SPECIALISE pragmas (for imported things?).
backendRespectsSpecialise :: Backend -> Bool

-- | This back end wants the <tt>mi_globals</tt> field of a
--   <tt>ModIface</tt> to be populated (with the top-level bindings of the
--   original source). True for the interpreter, and also true for "no
--   backend", which is used by Haddock. (After typechecking a module,
--   Haddock wants access to the module's <tt>GlobalRdrEnv</tt>.)
backendWantsGlobalBindings :: Backend -> Bool

-- | The back end targets a technology that implements <tt>switch</tt>
--   natively. (For example, LLVM or C.) Therefore it is not necessary for
--   GHC to ccompile a Cmm <tt>Switch</tt> form into a decision tree with
--   jump tables at the leaves.
backendHasNativeSwitch :: Backend -> Bool

-- | As noted in the documentation for <a>PrimitiveImplementation</a>,
--   certain primitives have multiple implementations, depending on the
--   capabilities of the back end. This field signals to module
--   <a>GHC.StgToCmm.Prim</a> what implementations to use with this back
--   end.
backendPrimitiveImplementation :: Backend -> PrimitiveImplementation

-- | When this value is <a>IsValid</a>, the back end is compatible with
--   vector instructions. When it is <a>NotValid</a>, it carries a message
--   that is shown to users.
backendSimdValidity :: Backend -> Validity' String

-- | This flag says whether the back end supports large binary blobs. See
--   Note [Embedding large binary blobs] in <a>GHC.CmmToAsm.Ppr</a>.
backendSupportsEmbeddedBlobs :: Backend -> Bool

-- | This flag tells the compiler driver that the back end does not support
--   every target platform; it supports only platforms that claim NCG
--   support. (It's set only for the native code generator.) Crufty. If the
--   driver tries to use the native code generator <i>without</i> platform
--   support, the driver fails over to the LLVM back end.
backendNeedsPlatformNcgSupport :: Backend -> Bool

-- | This flag is set if the back end can generate code for proc points. If
--   the flag is not set, then a Cmm pass needs to split proc points (that
--   is, turn each proc point into a standalone procedure).
backendSupportsUnsplitProcPoints :: Backend -> Bool

-- | This flag guides the driver in resolving issues about API support on
--   the target platform. If the flag is set, then these things are true:
--   
--   <ul>
--   <li>When the target platform supports <i>only</i> an unregisterised
--   API, this backend can be replaced with compilation via C.</li>
--   <li>When the target does <i>not</i> support an unregisterised API,
--   this back end can replace compilation via C.</li>
--   </ul>
backendSwappableWithViaC :: Backend -> Bool

-- | This flag is true if the back end works *only* with the unregisterised
--   ABI.
backendUnregisterisedAbiOnly :: Backend -> Bool

-- | This flag is set if the back end generates C code in a <tt>.hc</tt>
--   file. The flag lets the compiler driver know if the command-line flag
--   <tt>-C</tt> is meaningful.
backendGeneratesHc :: Backend -> Bool

-- | This flag says whether SPT (static pointer table) entries will be
--   inserted dynamically if needed. If this flag is <a>False</a>, then
--   <a>GHC.Iface.Tidy</a> should emit C stubs that initialize the SPT
--   entries.
backendSptIsDynamic :: Backend -> Bool

-- | If this flag is set, then <a>GHC.HsToCore.Ticks</a> inserts
--   <tt>Breakpoint</tt> ticks. Used only for the interpreter.
backendWantsBreakpointTicks :: Backend -> Bool

-- | If this flag is set, then the driver forces the optimization level to
--   0, issuing a warning message if the command line requested a higher
--   optimization level.
backendForcesOptimization0 :: Backend -> Bool

-- | I don't understand exactly how this works. But if this flag is set
--   *and* another condition is met, then <tt>ghc/Main.hs</tt> will alter
--   the <tt>DynFlags</tt> so that all the <tt>hostFullWays</tt> are asked
--   for. It is set only for the interpreter.
backendNeedsFullWays :: Backend -> Bool

-- | This flag is also special for the interpreter: if a message about a
--   module needs to be shown, do we know anything special about where the
--   module came from? The Boolean argument is a <tt>recomp</tt> flag.
backendSpecialModuleSource :: Backend -> Bool -> Maybe String

-- | This flag says whether the back end supports Haskell Program Coverage
--   (HPC). If not, the compiler driver will ignore the `-fhpc` option (and
--   will issue a warning message if it is used).
backendSupportsHpc :: Backend -> Bool

-- | This flag says whether the back end supports foreign import of C
--   functions. (<a>Supports</a> means "does not barf on," so
--   <tt>-fno-code</tt> supports foreign C imports.)
backendSupportsCImport :: Backend -> Bool

-- | This flag says whether the back end supports foreign export of Haskell
--   functions to C.
backendSupportsCExport :: Backend -> Bool

-- | This (defunctionalized) function runs the assembler used on the code
--   that is written by this back end. A program determined by a
--   combination of back end, <tt>DynFlags</tt>, and <a>Platform</a> is run
--   with the given <tt>Option</tt>s.
--   
--   The function's type is <tt> Logger -&gt; DynFlags -&gt; Platform -&gt;
--   [Option] -&gt; IO () </tt>
--   
--   This field is usually defaulted.
backendAssemblerProg :: Backend -> DefunctionalizedAssemblerProg

-- | This (defunctionalized) function is used to retrieve an enumeration
--   value that characterizes the C/assembler part of a toolchain. The
--   function caches the info in a mutable variable that is part of the
--   <tt>DynFlags</tt>.
--   
--   The function's type is <tt> Logger -&gt; DynFlags -&gt; Platform -&gt;
--   IO CompilerInfo </tt>
--   
--   This field is usually defaulted.
backendAssemblerInfoGetter :: Backend -> DefunctionalizedAssemblerInfoGetter

-- | When using this back end, it may be necessary or advisable to pass
--   some `-D` options to a C compiler. This (defunctionalized) function
--   produces those options, if any. An IO action may be necessary in order
--   to interrogate external tools about what version they are, for
--   example.
--   
--   The function's type is <tt> Logger -&gt; DynFlags -&gt; IO [String]
--   </tt>
--   
--   This field is usually defaulted.
backendCDefs :: Backend -> DefunctionalizedCDefs

-- | This (defunctionalized) function generates code and writes it to a
--   file. The type of the function is
--   
--   <pre>
--      Logger
--   -&gt; DynFlags
--   -&gt; Module -- ^ module being compiled
--   -&gt; ModLocation
--   -&gt; FilePath -- ^ Where to write output
--   -&gt; Set UnitId -- ^ dependencies
--   -&gt; Stream IO RawCmmGroup a -- results from `StgToCmm`
--   -&gt; IO a
--   </pre>
backendCodeOutput :: Backend -> DefunctionalizedCodeOutput
backendUseJSLinker :: Backend -> Bool

-- | This (defunctionalized) function tells the compiler driver what else
--   has to be run after code output. The type of the function is
--   
--   <pre>
--      TPipelineClass TPhase m
--   =&gt; PipeEnv
--   -&gt; HscEnv
--   -&gt; Maybe ModLocation
--   -&gt; FilePath
--   -&gt; m (Maybe FilePath)
--   </pre>
backendPostHscPipeline :: Backend -> DefunctionalizedPostHscPipeline

-- | Somewhere in the compiler driver, when compiling Haskell source (as
--   opposed to a boot file or a sig file), it needs to know what to do
--   with the code that the <a>backendCodeOutput</a> writes to a file. This
--   <a>Phase</a> value gives instructions like "run the C compiler", "run
--   the assembler," or "run the LLVM Optimizer."
backendNormalSuccessorPhase :: Backend -> Phase

-- | Name of the back end, if any. Used to migrate legacy clients of the
--   GHC API. Code within the GHC source tree should not refer to a back
--   end's name.
backendName :: Backend -> BackendName

-- | When foreign C import or export is invalid, the carried value
--   enumerates the <i>valid</i> back ends.
backendValidityOfCImport :: Backend -> Validity' [Backend]

-- | When foreign C import or export is invalid, the carried value
--   enumerates the <i>valid</i> back ends.
backendValidityOfCExport :: Backend -> Validity' [Backend]
platformDefaultBackend :: Platform -> Backend

-- | Is the platform supported by the Native Code Generator?
platformNcgSupported :: Platform -> Bool
instance GHC.Show.Show GHC.Driver.Backend.PrimitiveImplementation
instance GHC.Show.Show GHC.Driver.Backend.Backend

module GHC.Cmm.Switch

-- | A value of type SwitchTargets contains the alternatives for a
--   <tt>CmmSwitch</tt> value, and knows whether the value is signed, the
--   possible range, an optional default value and a map from values to
--   jump labels.
data SwitchTargets

-- | The smart constructor mkSwitchTargets normalises the map a bit: * No
--   entries outside the range * No entries equal to the default * No
--   default if all elements have explicit values
mkSwitchTargets :: Bool -> (Integer, Integer) -> Maybe Label -> Map Integer Label -> SwitchTargets

-- | Returns the list of non-default branches of the SwitchTargets value
switchTargetsCases :: SwitchTargets -> [(Integer, Label)]

-- | Return the default label of the SwitchTargets value
switchTargetsDefault :: SwitchTargets -> Maybe Label

-- | Return the range of the SwitchTargets value
switchTargetsRange :: SwitchTargets -> (Integer, Integer)

-- | Return whether this is used for a signed value
switchTargetsSigned :: SwitchTargets -> Bool

-- | Changes all labels mentioned in the SwitchTargets value
mapSwitchTargets :: (Label -> Label) -> SwitchTargets -> SwitchTargets

-- | switchTargetsToTable creates a dense jump table, usable for code
--   generation.
--   
--   Also returns an offset to add to the value; the list is 0-based on the
--   result of that addition.
--   
--   The conversion from Integer to Int is a bit of a wart, as the actual
--   scrutinee might be an unsigned word, but it just works, due to
--   wrap-around arithmetic (as verified by the CmmSwitchTest test case).
switchTargetsToTable :: SwitchTargets -> (Int, [Maybe Label])

-- | Groups cases with equal targets, suitable for pretty-printing to a
--   c-like switch statement with fall-through semantics.
switchTargetsFallThrough :: SwitchTargets -> ([(NonEmpty Integer, Label)], Maybe Label)

-- | The list of all labels occurring in the SwitchTargets value.
switchTargetsToList :: SwitchTargets -> [Label]

-- | Custom equality helper, needed for <a>GHC.Cmm.CommonBlockElim</a>
eqSwitchTargetWith :: (Label -> Label -> Bool) -> SwitchTargets -> SwitchTargets -> Bool

-- | A SwitchPlan abstractly describes how a Switch statement ought to be
--   implemented. See Note [createSwitchPlan]
data SwitchPlan
Unconditionally :: Label -> SwitchPlan
IfEqual :: Integer -> Label -> SwitchPlan -> SwitchPlan
IfLT :: Bool -> Integer -> SwitchPlan -> SwitchPlan -> SwitchPlan
JumpTable :: SwitchTargets -> SwitchPlan

-- | The back end targets a technology that implements <tt>switch</tt>
--   natively. (For example, LLVM or C.) Therefore it is not necessary for
--   GHC to ccompile a Cmm <tt>Switch</tt> form into a decision tree with
--   jump tables at the leaves.
backendHasNativeSwitch :: Backend -> Bool

-- | This function creates a SwitchPlan from a SwitchTargets value,
--   breaking it down into smaller pieces suitable for code generation.
createSwitchPlan :: SwitchTargets -> SwitchPlan
instance GHC.Classes.Eq GHC.Cmm.Switch.SwitchTargets
instance GHC.Show.Show GHC.Cmm.Switch.SwitchTargets
instance GHC.Show.Show GHC.Cmm.Switch.SwitchPlan

module GHC.Driver.Pipeline.LogQueue

-- | Each module is given a unique <a>LogQueue</a> to redirect compilation
--   messages to. A <a>Nothing</a> value contains the result of
--   compilation, and denotes the end of the message queue.
data LogQueue
LogQueue :: !Int -> !IORef [Maybe (MessageClass, SrcSpan, SDoc, LogFlags)] -> !MVar () -> LogQueue
[logQueueId] :: LogQueue -> !Int
[logQueueMessages] :: LogQueue -> !IORef [Maybe (MessageClass, SrcSpan, SDoc, LogFlags)]
[logQueueSemaphore] :: LogQueue -> !MVar ()
newLogQueue :: Int -> IO LogQueue
finishLogQueue :: LogQueue -> IO ()
writeLogQueue :: LogQueue -> (MessageClass, SrcSpan, SDoc, LogFlags) -> IO ()
parLogAction :: LogQueue -> LogAction
data LogQueueQueue
LogQueueQueue :: Int -> IntMap LogQueue -> LogQueueQueue
initLogQueue :: TVar LogQueueQueue -> LogQueue -> STM ()

-- | Return all items in the queue in ascending order
allLogQueues :: LogQueueQueue -> [LogQueue]
newLogQueueQueue :: LogQueueQueue
logThread :: Int -> Int -> Logger -> TVar Bool -> TVar LogQueueQueue -> IO (IO ())


-- | Command-line parser
--   
--   This is an abstract command-line parser used by DynFlags.
--   
--   (c) The University of Glasgow 2005
module GHC.Driver.CmdLine
processArgs :: Monad m => [Flag m] -> [Located String] -> (FilePath -> EwM m [Located String]) -> m ([Located String], [Err], [Warn])

-- | Parse a response file into arguments.
parseResponseFile :: MonadIO m => FilePath -> EwM m [Located String]
data OptKind m
NoArg :: EwM m () -> OptKind m
HasArg :: (String -> EwM m ()) -> OptKind m
SepArg :: (String -> EwM m ()) -> OptKind m
Prefix :: (String -> EwM m ()) -> OptKind m
OptPrefix :: (String -> EwM m ()) -> OptKind m
OptIntSuffix :: (Maybe Int -> EwM m ()) -> OptKind m
IntSuffix :: (Int -> EwM m ()) -> OptKind m
Word64Suffix :: (Word64 -> EwM m ()) -> OptKind m
FloatSuffix :: (Float -> EwM m ()) -> OptKind m
PassFlag :: (String -> EwM m ()) -> OptKind m
AnySuffix :: (String -> EwM m ()) -> OptKind m

-- | GHC flag modes describing when a flag has an effect.
data GhcFlagMode

-- | The flag only affects the non-interactive GHC
OnlyGhc :: GhcFlagMode

-- | The flag only affects the interactive GHC
OnlyGhci :: GhcFlagMode

-- | The flag affects multiple ghc modes
AllModes :: GhcFlagMode

-- | This flag should not be seen in cli completion
HiddenFlag :: GhcFlagMode
data Flag m
Flag :: String -> OptKind m -> GhcFlagMode -> Flag m
[flagName] :: Flag m -> String
[flagOptKind] :: Flag m -> OptKind m
[flagGhcMode] :: Flag m -> GhcFlagMode
defFlag :: String -> OptKind m -> Flag m
defGhcFlag :: String -> OptKind m -> Flag m
defGhciFlag :: String -> OptKind m -> Flag m
defHiddenFlag :: String -> OptKind m -> Flag m
hoistFlag :: forall m n. (forall a. m a -> n a) -> Flag m -> Flag n
errorsToGhcException :: [(String, String)] -> GhcException

-- | A command-line error message
newtype Err
Err :: Located String -> Err
[errMsg] :: Err -> Located String

-- | A command-line warning message and the reason it arose
data Warn
Warn :: DiagnosticReason -> Located String -> Warn
[warnReason] :: Warn -> DiagnosticReason
[warnMsg] :: Warn -> Located String

-- | Used when filtering warnings: if a reason is given it can be filtered
--   out when displaying.
data WarnReason
NoReason :: WarnReason
ReasonDeprecatedFlag :: WarnReason
ReasonUnrecognisedFlag :: WarnReason
data EwM m a
runEwM :: EwM m a -> m (Errs, Warns, a)
addErr :: Monad m => String -> EwM m ()
addWarn :: Monad m => String -> EwM m ()
addFlagWarn :: Monad m => DiagnosticReason -> String -> EwM m ()
getArg :: Monad m => EwM m String
getCurLoc :: Monad m => EwM m SrcSpan
liftEwM :: Monad m => m a -> EwM m a
instance GHC.Show.Show GHC.Driver.CmdLine.WarnReason
instance GHC.Classes.Eq GHC.Driver.CmdLine.WarnReason
instance GHC.Base.Functor m => GHC.Base.Functor (GHC.Driver.CmdLine.EwM m)
instance GHC.Base.Monad m => GHC.Base.Applicative (GHC.Driver.CmdLine.EwM m)
instance GHC.Base.Monad m => GHC.Base.Monad (GHC.Driver.CmdLine.EwM m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (GHC.Driver.CmdLine.EwM m)
instance GHC.Utils.Outputable.Outputable GHC.Driver.CmdLine.WarnReason
instance GHC.Utils.Json.ToJson GHC.Driver.CmdLine.WarnReason

module GHC.Core.Opt.Stats
data SimplCount
doSimplTick :: Int -> Tick -> SimplCount -> SimplCount
doFreeSimplTick :: Tick -> SimplCount -> SimplCount
simplCountN :: SimplCount -> Int
pprSimplCount :: SimplCount -> SDoc
plusSimplCount :: SimplCount -> SimplCount -> SimplCount
zeroSimplCount :: Bool -> SimplCount
isZeroSimplCount :: SimplCount -> Bool
hasDetailedCounts :: SimplCount -> Bool
data Tick
PreInlineUnconditionally :: Id -> Tick
PostInlineUnconditionally :: Id -> Tick
UnfoldingDone :: Id -> Tick
RuleFired :: FastString -> Tick
LetFloatFromLet :: Tick
EtaExpansion :: Id -> Tick
EtaReduction :: Id -> Tick
BetaReduction :: Id -> Tick
CaseOfCase :: Id -> Tick
KnownBranch :: Id -> Tick
CaseMerge :: Id -> Tick
AltMerge :: Id -> Tick
CaseElim :: Id -> Tick
CaseIdentity :: Id -> Tick
FillInCaseDefault :: Id -> Tick
SimplifierDone :: Tick
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Stats.Tick
instance GHC.Classes.Eq GHC.Core.Opt.Stats.Tick
instance GHC.Classes.Ord GHC.Core.Opt.Stats.Tick

module GHC.Core.Predicate

-- | A predicate in the solver. The solver tries to prove Wanted predicates
--   from Given ones.
data Pred

-- | A typeclass predicate.
ClassPred :: Class -> [Type] -> Pred

-- | A type equality predicate.
EqPred :: EqRel -> Type -> Type -> Pred

-- | An irreducible predicate.
IrredPred :: PredType -> Pred

-- | A quantified predicate.
--   
--   See Note [Quantified constraints] in GHC.Tc.Solver.Canonical
ForAllPred :: [TyVar] -> [PredType] -> PredType -> Pred
classifyPredType :: PredType -> Pred
isPredTy :: HasDebugCallStack => Type -> Bool
isEvVarType :: Type -> Bool

-- | A choice of equality relation. This is separate from the type
--   <a>Role</a> because <a>Phantom</a> does not define a (non-trivial)
--   equality relation.
data EqRel
NomEq :: EqRel
ReprEq :: EqRel
eqRelRole :: EqRel -> Role
isEqPrimPred :: PredType -> Bool
isEqPred :: PredType -> Bool
getEqPredTys :: PredType -> (Type, Type)
getEqPredTys_maybe :: PredType -> Maybe (Role, Type, Type)
getEqPredRole :: PredType -> Role

-- | Get the equality relation relevant for a pred type.
predTypeEqRel :: PredType -> EqRel

-- | Creates a primitive type equality predicate. Invariant: the types are
--   not Coercions
mkPrimEqPred :: Type -> Type -> Type
mkReprPrimEqPred :: Type -> Type -> Type

-- | Makes a lifted equality predicate at the given role
mkPrimEqPredRole :: Role -> Type -> Type -> PredType

-- | Creates a primitive type equality predicate with explicit kinds
mkHeteroPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | Creates a primitive representational type equality predicate with
--   explicit kinds
mkHeteroReprPrimEqPred :: Kind -> Kind -> Type -> Type -> Type
mkClassPred :: Class -> [Type] -> PredType
isDictTy :: Type -> Bool
typeDeterminesValue :: Type -> Bool
isClassPred :: PredType -> Bool
isEqPredClass :: Class -> Bool
isCTupleClass :: Class -> Bool
getClassPredTys :: HasDebugCallStack => PredType -> (Class, [Type])
getClassPredTys_maybe :: PredType -> Maybe (Class, [Type])
classMethodTy :: Id -> Type
classMethodInstTy :: Id -> [Type] -> Type
isIPLikePred :: Type -> Bool
hasIPSuperClasses :: Class -> [Type] -> Bool
isIPTyCon :: TyCon -> Bool
isIPClass :: Class -> Bool

-- | Is a type a <tt>CallStack</tt>?
isCallStackTy :: Type -> Bool

-- | Is a <a>PredType</a> a <tt>CallStack</tt> implicit parameter?
--   
--   If so, return the name of the parameter.
isCallStackPred :: Class -> [Type] -> Maybe FastString
isCallStackPredTy :: Type -> Bool

-- | Decomposes a predicate if it is an implicit parameter. Does not look
--   in superclasses. See also [Local implicit parameters].
isIPPred_maybe :: Type -> Maybe (FastString, Type)

-- | Dictionary Identifier
type DictId = EvId
isEvVar :: Var -> Bool
isDictId :: Id -> Bool
instance GHC.Classes.Ord GHC.Core.Predicate.EqRel
instance GHC.Classes.Eq GHC.Core.Predicate.EqRel
instance GHC.Utils.Outputable.Outputable GHC.Core.Predicate.EqRel

module GHC.Core.Reduction

-- | A <a>Reduction</a> is the result of an operation that rewrites a type
--   <tt>ty_in</tt>. The <a>Reduction</a> includes the rewritten type
--   <tt>ty_out</tt> and a <a>Coercion</a> <tt>co</tt> such that <tt>co ::
--   ty_in ~ ty_out</tt>, where the role of the coercion is determined by
--   the context. That is, the LHS type of the coercion is the original
--   type <tt>ty_in</tt>, while its RHS type is the rewritten type
--   <tt>ty_out</tt>.
--   
--   A Reduction is always homogeneous, unless it is wrapped inside a
--   <a>HetReduction</a>, which separately stores the kind coercion.
--   
--   See Note [The Reduction type].
data Reduction
Reduction :: Coercion -> !Type -> Reduction
[reductionCoercion] :: Reduction -> Coercion
[reductionReducedType] :: Reduction -> !Type

-- | A <a>Reduction</a> in which the <a>Coercion</a> has <a>Nominal</a>
--   role.
type ReductionN = Reduction

-- | A <a>Reduction</a> in which the <a>Coercion</a> has
--   <a>Representational</a> role.
type ReductionR = Reduction

-- | Stores a heterogeneous reduction.
--   
--   The stored kind coercion must relate the kinds of the stored
--   reduction. That is, in <tt>HetReduction (Reduction co xi) kco</tt>, we
--   must have:
--   
--   <pre>
--    co :: ty ~ xi
--   kco :: typeKind ty ~ typeKind xi
--   </pre>
data HetReduction
HetReduction :: Reduction -> MCoercionN -> HetReduction

-- | A collection of <a>Reduction</a>s where the coercions and the types
--   are stored separately.
--   
--   Use <a>unzipRedns</a> to obtain <a>Reductions</a> from a list of
--   <a>Reduction</a>s.
--   
--   This datatype is used in <a>mkAppRedns</a>, <tt>mkClassPredRedns</tt>
--   and <a>mkTyConAppRedn</a>, which expect separate types and coercions.
--   
--   Invariant: the two stored lists are of the same length, and the RHS
--   type of each coercion is the corresponding type.
data Reductions
Reductions :: [Coercion] -> [Type] -> Reductions

-- | Create a <a>Reduction</a> from a pair of a <a>Coercion</a> and a
--   'Type.
--   
--   Pre-condition: the RHS type of the coercion matches the provided type
--   (perhaps up to zonking).
--   
--   Use <a>coercionRedn</a> when you only have the coercion.
mkReduction :: Coercion -> Type -> Reduction

-- | Create <a>Reductions</a> from individual lists of coercions and types.
--   
--   The lists should be of the same length, and the RHS type of each
--   coercion should match the specified type in the other list.
mkReductions :: [Coercion] -> [Type] -> Reductions

-- | Create a heterogeneous reduction.
--   
--   Pre-condition: the provided kind coercion (second argument) relates
--   the kinds of the stored reduction. That is, if the coercion stored in
--   the <a>Reduction</a> is of the form
--   
--   <pre>
--   co :: ty ~ xi
--   </pre>
--   
--   Then the kind coercion supplied must be of the form:
--   
--   <pre>
--   kco :: typeKind ty ~ typeKind xi
--   </pre>
mkHetReduction :: Reduction -> MCoercionN -> HetReduction

-- | Turn a <a>Coercion</a> into a <a>Reduction</a> by inspecting the RHS
--   type of the coercion.
--   
--   Prefer using <a>mkReduction</a> when you already know the RHS type of
--   the coercion, to avoid computing it anew.
coercionRedn :: Coercion -> Reduction

-- | Get the original, unreduced type corresponding to a <a>Reduction</a>.
--   
--   This is obtained by computing the LHS kind of the stored coercion,
--   which may be slow.
reductionOriginalType :: Reduction -> Type

-- | Downgrade the role of the coercion stored in the <a>Reduction</a>.
downgradeRedn :: Role -> Role -> Reduction -> Reduction

-- | Downgrade the role of the coercion stored in the <a>Reduction</a>,
--   from <a>Nominal</a> to <a>Representational</a>.
mkSubRedn :: Reduction -> Reduction

-- | Compose a reduction with a coercion on the left.
--   
--   Pre-condition: the provided coercion's RHS type must match the LHS
--   type of the coercion that is stored in the reduction.
mkTransRedn :: Coercion -> Reduction -> Reduction

-- | Apply a cast to the result of a <a>Reduction</a>.
--   
--   Given a <a>Reduction</a> <tt>ty1 ~co1~&gt; (ty2 :: k2)</tt> and a kind
--   coercion <tt>kco</tt> with LHS kind <tt>k2</tt>, produce a new
--   <a>Reduction</a> <tt>ty1 ~co2~&gt; ( ty2 |&gt; kco )</tt> of the given
--   <a>Role</a> (which must match the role of the coercion stored in the
--   <a>Reduction</a> argument).
mkCoherenceRightRedn :: Role -> Reduction -> CoercionN -> Reduction

-- | Apply a cast to the result of a <a>Reduction</a>, using an
--   <a>MCoercionN</a>.
--   
--   Given a <a>Reduction</a> <tt>ty1 ~co1~&gt; (ty2 :: k2)</tt> and a kind
--   coercion <tt>mco</tt> with LHS kind <tt>k2</tt>, produce a new
--   <a>Reduction</a> <tt>ty1 ~co2~&gt; ( ty2 |&gt; mco )</tt> of the given
--   <a>Role</a> (which must match the role of the coercion stored in the
--   <a>Reduction</a> argument).
mkCoherenceRightMRedn :: Role -> Reduction -> MCoercionN -> Reduction

-- | Apply a cast to a <a>Reduction</a>, casting both the original and the
--   reduced type.
--   
--   Given <tt>cast_co</tt> and <a>Reduction</a> <tt>ty ~co~&gt; xi</tt>,
--   this function returns the <a>Reduction</a> <tt>(ty |&gt; cast_co)
--   ~return_co~&gt; (xi |&gt; cast_co)</tt> of the given <a>Role</a>
--   (which must match the role of the coercion stored in the
--   <a>Reduction</a> argument).
--   
--   Pre-condition: the <a>Type</a> passed in is the same as the LHS type
--   of the coercion stored in the <a>Reduction</a>.
mkCastRedn1 :: Role -> Type -> CoercionN -> Reduction -> Reduction

-- | Apply casts on both sides of a <a>Reduction</a> (of the given
--   <a>Role</a>).
--   
--   Use <a>mkCastRedn1</a> when you want to cast both the original and
--   reduced types in a <a>Reduction</a> using the same coercion.
--   
--   Pre-condition: the <a>Type</a> passed in is the same as the LHS type
--   of the coercion stored in the <a>Reduction</a>.
mkCastRedn2 :: Role -> Type -> CoercionN -> Reduction -> CoercionN -> Reduction

-- | The reflexive reduction.
mkReflRedn :: Role -> Type -> Reduction

-- | Create a <a>Reduction</a> from a kind cast, in which the casted type
--   is the rewritten type.
--   
--   Given <tt>ty :: k1</tt>, <tt>mco :: k1 ~ k2</tt>, produces the
--   <a>Reduction</a> <tt>ty ~res_co~&gt; (ty |&gt; mco)</tt> at the given
--   <a>Role</a>.
mkGReflRightRedn :: Role -> Type -> CoercionN -> Reduction

-- | Create a <a>Reduction</a> from a kind cast, in which the casted type
--   is the rewritten type.
--   
--   Given <tt>ty :: k1</tt>, <tt>mco :: k1 ~ k2</tt>, produces the
--   <a>Reduction</a> <tt>ty ~res_co~&gt; (ty |&gt; mco)</tt> at the given
--   <a>Role</a>.
mkGReflRightMRedn :: Role -> Type -> MCoercionN -> Reduction

-- | Create a <a>Reduction</a> from a kind cast, in which the casted type
--   is the original (non-rewritten) type.
--   
--   Given <tt>ty :: k1</tt>, <tt>mco :: k1 ~ k2</tt>, produces the
--   <a>Reduction</a> <tt>(ty |&gt; mco) ~res_co~&gt; ty</tt> at the given
--   <a>Role</a>.
mkGReflLeftRedn :: Role -> Type -> CoercionN -> Reduction

-- | Create a <a>Reduction</a> from a kind cast, in which the casted type
--   is the original (non-rewritten) type.
--   
--   Given <tt>ty :: k1</tt>, <tt>mco :: k1 ~ k2</tt>, produces the
--   <a>Reduction</a> <tt>(ty |&gt; mco) ~res_co~&gt; ty</tt> at the given
--   <a>Role</a>.
mkGReflLeftMRedn :: Role -> Type -> MCoercionN -> Reduction

-- | Apply one <a>Reduction</a> to another.
--   
--   Combines <a>mkAppCo</a> and <a>mkAppTy</a>.
mkAppRedn :: Reduction -> Reduction -> Reduction

-- | Combines <a>mkAppCos</a> and <a>mkAppTys</a>.
mkAppRedns :: Reduction -> Reductions -> Reduction

-- | Create a function <a>Reduction</a>.
--   
--   Combines <tt>mkFunCo</tt> and <a>mkFunTy</a>.
mkFunRedn :: Role -> FunTyFlag -> ReductionN -> Reduction -> Reduction -> Reduction

-- | Create a <a>Reduction</a> associated to a Π type, from a kind
--   <a>Reduction</a> and a body <a>Reduction</a>.
--   
--   Combines <a>mkForAllCo</a> and <a>mkForAllTy</a>.
mkForAllRedn :: ForAllTyFlag -> TyVar -> ReductionN -> Reduction -> Reduction

-- | Create a <a>Reduction</a> of a quantified type from a <a>Reduction</a>
--   of the body.
--   
--   Combines <a>mkHomoForAllCos</a> and <a>mkForAllTys</a>.
mkHomoForAllRedn :: [TyVarBinder] -> Reduction -> Reduction

-- | <tt>TyConAppCo</tt> for <a>Reduction</a>s: combines
--   <a>mkTyConAppCo</a> and <a>mkTyConApp</a>.
mkTyConAppRedn :: Role -> TyCon -> Reductions -> Reduction

-- | Reduce the arguments of a <a>Class</a> <a>TyCon</a>.
mkClassPredRedn :: Class -> Reductions -> Reduction

-- | Create a <a>Reduction</a> from a coercion between coercions.
--   
--   Combines <a>mkProofIrrelCo</a> and <a>mkCoercionTy</a>.
mkProofIrrelRedn :: Role -> CoercionN -> Coercion -> Coercion -> Reduction

-- | Create a reflexive <a>Reduction</a> whose RHS is the given
--   <a>Coercion</a>, with the specified <a>Role</a>.
mkReflCoRedn :: Role -> Coercion -> Reduction

-- | Homogenise a heterogeneous reduction.
--   
--   Given <tt>HetReduction (Reduction co xi) kco</tt>, with
--   
--   <pre>
--    co :: ty ~ xi
--   kco :: typeKind(ty) ~ typeKind(xi)
--   </pre>
--   
--   this returns the homogeneous reduction:
--   
--   <pre>
--   hco :: ty ~ ( xi |&gt; sym kco )
--   </pre>
homogeniseHetRedn :: Role -> HetReduction -> Reduction

-- | Obtain <a>Reductions</a> from a list of <a>Reduction</a>s by
--   unzipping.
unzipRedns :: [Reduction] -> Reductions

-- | Stores <a>Reductions</a> as well as a kind coercion.
--   
--   Used when rewriting arguments to a type function <tt>f</tt>.
--   
--   Invariant: when the stored reductions are of the form co_i :: ty_i ~
--   xi_i, the kind coercion is of the form kco :: typeKind (f ty_1 ...
--   ty_n) ~ typeKind (f xi_1 ... xi_n)
--   
--   The type function <tt>f</tt> depends on context.
data ArgsReductions
ArgsReductions :: {-# UNPACK #-} !Reductions -> !MCoercionN -> ArgsReductions
simplifyArgsWorker :: HasDebugCallStack => [PiTyBinder] -> Kind -> TyCoVarSet -> Infinite Role -> [Reduction] -> ArgsReductions
instance GHC.Utils.Outputable.Outputable GHC.Core.Reduction.Reduction

module GHC.Core.Map.Type
class Functor m => TrieMap m where {
    type Key m :: Type;
}
emptyTM :: TrieMap m => m a
lookupTM :: forall b. TrieMap m => Key m -> m b -> Maybe b
alterTM :: forall b. TrieMap m => Key m -> XT b -> m b -> m b
filterTM :: TrieMap m => (a -> Bool) -> m a -> m a
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
type XT a = Maybe a -> Maybe a

-- | <tt>TypeMap a</tt> is a map from <a>Type</a> to <tt>a</tt>. If you are
--   a client, this is the type you want. The keys in this map may have
--   different kinds.
data TypeMap a
emptyTypeMap :: TypeMap a
extendTypeMap :: TypeMap a -> Type -> a -> TypeMap a
lookupTypeMap :: TypeMap a -> Type -> Maybe a
foldTypeMap :: (a -> b -> b) -> b -> TypeMap a -> b

-- | A <a>LooseTypeMap</a> doesn't do a kind-check. Thus, when lookup up (t
--   |&gt; g), you'll find entries inserted under (t), even if (g) is
--   non-reflexive.
data LooseTypeMap a
data CmEnv
lookupCME :: CmEnv -> Var -> Maybe BoundVar

-- | Extend a <a>TypeMap</a> with a type in the given context.
--   <tt>extendTypeMapWithScope m (mkDeBruijnContext [a,b,c]) t v</tt> is
--   equivalent to <tt>extendTypeMap m (forall a b c. t) v</tt>, but allows
--   reuse of the context over multiple insertions.
extendTypeMapWithScope :: TypeMap a -> CmEnv -> Type -> a -> TypeMap a
lookupTypeMapWithScope :: TypeMap a -> CmEnv -> Type -> Maybe a

-- | Construct a deBruijn environment with the given variables in scope.
--   e.g. <tt>mkDeBruijnEnv [a,b,c]</tt> constructs a context <tt>forall a
--   b c.</tt>
mkDeBruijnContext :: [Var] -> CmEnv
extendCME :: CmEnv -> Var -> CmEnv
extendCMEs :: CmEnv -> [Var] -> CmEnv
emptyCME :: CmEnv

-- | <tt>TypeMapG a</tt> is a map from <tt>DeBruijn Type</tt> to
--   <tt>a</tt>. The extended key makes it suitable for recursive
--   traversal, since it can track binders, but it is strictly internal to
--   this module. If you are including a <a>TypeMap</a> inside another
--   <a>TrieMap</a>, this is the type you want. Note that this lookup does
--   not do a kind-check. Thus, all keys in this map must have the same
--   kind. Also note that this map respects the distinction between
--   <tt>Type</tt> and <tt>Constraint</tt>, despite the fact that they are
--   equivalent type synonyms in Core.
type TypeMapG = GenMap TypeMapX
type CoercionMapG = GenMap CoercionMapX

-- | <tt>DeBruijn a</tt> represents <tt>a</tt> modulo alpha-renaming. This
--   is achieved by equipping the value with a <a>CmEnv</a>, which tracks
--   an on-the-fly deBruijn numbering. This allows us to define an
--   <a>Eq</a> instance for <tt>DeBruijn a</tt>, even if this was not
--   (easily) possible for <tt>a</tt>. Note: we purposely don't export the
--   constructor. Make a helper function if you find yourself needing it.
data DeBruijn a
D :: CmEnv -> a -> DeBruijn a

-- | Synthesizes a <tt>DeBruijn a</tt> from an <tt>a</tt>, by assuming that
--   there are no bound binders (an empty <a>CmEnv</a>). This is usually
--   what you want if there isn't already a <a>CmEnv</a> in scope.
deBruijnize :: a -> DeBruijn a
eqDeBruijnType :: DeBruijn Type -> DeBruijn Type -> Bool
eqDeBruijnVar :: DeBruijn Var -> DeBruijn Var -> Bool

-- | A <a>BndrMap</a> is a <a>TypeMapG</a> which allows us to distinguish
--   between binding forms whose binders have different types. For example,
--   if we are doing a <a>TrieMap</a> lookup on <tt>(x :: Int) -&gt;
--   ()</tt>, we should not pick up an entry in the <a>TrieMap</a> for
--   <tt>(x :: Bool) -&gt; ()</tt>: we can disambiguate this by matching on
--   the type (or kind, if this a binder in a type) of the binder.
--   
--   We also need to do the same for multiplicity! Which, since
--   multiplicities are encoded simply as a <a>Type</a>, amounts to have a
--   Trie for a pair of types. Tries of pairs are composition.
data BndrMap a
xtBndr :: forall a. CmEnv -> Var -> XT a -> BndrMap a -> BndrMap a
lkBndr :: CmEnv -> Var -> BndrMap a -> Maybe a
data VarMap a
xtVar :: CmEnv -> Var -> XT a -> VarMap a -> VarMap a
lkVar :: CmEnv -> Var -> VarMap a -> Maybe a
lkDFreeVar :: Var -> DVarEnv a -> Maybe a
xtDFreeVar :: Var -> XT a -> DVarEnv a -> DVarEnv a
xtDNamed :: NamedThing n => n -> XT a -> DNameEnv a -> DNameEnv a
lkDNamed :: NamedThing n => n -> DNameEnv a -> Maybe a
instance GHC.Base.Functor GHC.Core.Map.Type.CoercionMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.CoercionMap
instance GHC.Base.Functor GHC.Core.Map.Type.CoercionMapX
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.CoercionMapX
instance GHC.Base.Functor GHC.Core.Map.Type.TypeMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.TypeMap
instance GHC.Base.Functor GHC.Core.Map.Type.LooseTypeMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.LooseTypeMap
instance GHC.Base.Functor GHC.Core.Map.Type.TypeMapX
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.TypeMapX
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.Map.Type.TypeMapG a)
instance GHC.Base.Functor GHC.Core.Map.Type.BndrMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.BndrMap
instance GHC.Base.Functor GHC.Core.Map.Type.VarMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.VarMap
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.TyCo.Rep.Coercion)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.TyCo.Rep.Type)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Types.Var.Var)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn a) => GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn [a])
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn a) => GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn (GHC.Maybe.Maybe a))
instance GHC.Base.Functor GHC.Core.Map.Type.TyLitMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Type.TyLitMap

module GHC.Core.Unify

-- | <tt>tcMatchTy t1 t2</tt> produces a substitution (over fvs(t1))
--   <tt>s</tt> such that <tt>s(t1)</tt> equals <tt>t2</tt>. The returned
--   substitution might bind coercion variables, if the variable is an
--   argument to a GADT constructor.
--   
--   Precondition: typeKind ty1 <a>eqType</a> typeKind ty2
--   
--   We don't pass in a set of "template variables" to be bound by the
--   match, because tcMatchTy (and similar functions) are always used on
--   top-level types, so we can bind any of the free variables of the LHS.
--   See also Note [tcMatchTy vs tcMatchTyKi]
tcMatchTy :: Type -> Type -> Maybe Subst

-- | Like <a>tcMatchTy</a>, but allows the kinds of the types to differ,
--   and thus matches them as well. See also Note [tcMatchTy vs
--   tcMatchTyKi]
tcMatchTyKi :: Type -> Type -> Maybe Subst

-- | Like <a>tcMatchTy</a> but over a list of types. See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTys :: [Type] -> [Type] -> Maybe Subst

-- | Like <a>tcMatchTyKi</a> but over a list of types. See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTyKis :: [Type] -> [Type] -> Maybe Subst

-- | This is similar to <a>tcMatchTy</a>, but extends a substitution See
--   also Note [tcMatchTy vs tcMatchTyKi]
tcMatchTyX :: Subst -> Type -> Type -> Maybe Subst

-- | Like <a>tcMatchTys</a>, but extending a substitution See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTysX :: Subst -> [Type] -> [Type] -> Maybe Subst

-- | Like <a>tcMatchTyKis</a>, but extending a substitution See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTyKisX :: Subst -> [Type] -> [Type] -> Maybe Subst
tcMatchTyX_BM :: BindFun -> Subst -> Type -> Type -> Maybe Subst

-- | This one is called from the expression matcher, which already has a
--   MatchEnv in hand
ruleMatchTyKiX :: TyCoVarSet -> RnEnv2 -> TvSubstEnv -> Type -> Type -> Maybe TvSubstEnv

-- | Simple unification of two types; all type variables are bindable
--   Precondition: the kinds are already equal
tcUnifyTy :: Type -> Type -> Maybe Subst

-- | Like <a>tcUnifyTy</a>, but also unifies the kinds
tcUnifyTyKi :: Type -> Type -> Maybe Subst
tcUnifyTys :: BindFun -> [Type] -> [Type] -> Maybe Subst

-- | Like <a>tcUnifyTys</a> but also unifies the kinds
tcUnifyTyKis :: BindFun -> [Type] -> [Type] -> Maybe Subst

-- | <tt>tcUnifyTysFG bind_tv tys1 tys2</tt> attempts to find a
--   substitution <tt>s</tt> (whose domain elements all respond
--   <a>BindMe</a> to <tt>bind_tv</tt>) such that <tt>s(tys1)</tt> and that
--   of <tt>s(tys2)</tt> are equal, as witnessed by the returned Coercions.
--   This version requires that the kinds of the types are the same, if you
--   unify left-to-right.
tcUnifyTysFG :: BindFun -> [Type] -> [Type] -> UnifyResult

-- | Unify two types, treating type family applications as possibly
--   unifying with anything and looking through injective type family
--   applications. Precondition: kinds are the same
tcUnifyTyWithTFs :: Bool -> InScopeSet -> Type -> Type -> Maybe Subst

-- | Some unification functions are parameterised by a <a>BindFun</a>,
--   which says whether or not to allow a certain unification to take
--   place. A <a>BindFun</a> takes the <a>TyVar</a> involved along with the
--   <a>Type</a> it will potentially be bound to.
--   
--   It is possible for the variable to actually be a coercion variable
--   (Note [Matching coercion variables]), but only when one-way matching.
--   In this case, the <a>Type</a> will be a <a>CoercionTy</a>.
type BindFun = TyCoVar -> Type -> BindFlag
data BindFlag

-- | A regular type variable
BindMe :: BindFlag

-- | Declare that this type variable is <i>apart</i> from the type
--   provided. That is, the type variable will never be instantiated to
--   that type. See also Note [Binding when looking up instances] in
--   GHC.Core.InstEnv.
Apart :: BindFlag

-- | Allow binding only for any variable in the set. Variables may be bound
--   to any type. Used when doing simple matching; e.g. can we find a
--   substitution
--   
--   <pre>
--   S = [a :-&gt; t1, b :-&gt; t2] such that
--       S( Maybe (a, b-&gt;Int )  =   Maybe (Bool, Char -&gt; Int)
--   </pre>
matchBindFun :: TyCoVarSet -> BindFun

-- | Allow the binding of any variable to any type
alwaysBindFun :: BindFun
type UnifyResult = UnifyResultM Subst

-- | See Note [Unification result]
data UnifyResultM a
Unifiable :: a -> UnifyResultM a
MaybeApart :: MaybeApartReason -> a -> UnifyResultM a
SurelyApart :: UnifyResultM a

-- | Why are two types <a>MaybeApart</a>? <a>MARInfinite</a> takes
--   precedence: This is used (only) in Note [Infinitary substitution in
--   lookup] in GHC.Core.InstEnv As of Feb 2022, we never differentiate
--   between MARTypeFamily and MARTypeVsConstraint; it's really only
--   MARInfinite that's interesting here.
data MaybeApartReason

-- | matching e.g. F Int ~? Bool
MARTypeFamily :: MaybeApartReason

-- | matching e.g. a ~? Maybe a
MARInfinite :: MaybeApartReason

-- | matching Type ~? Constraint or the arrow types See Note [Type and
--   Constraint are not apart] in GHC.Builtin.Types.Prim
MARTypeVsConstraint :: MaybeApartReason

-- | Given a list of pairs of types, are any two members of a pair surely
--   apart, even after arbitrary type function evaluation and substitution?
typesCantMatch :: [(Type, Type)] -> Bool
typesAreApart :: Type -> Type -> Bool

-- | <a>liftCoMatch</a> is sort of inverse to <a>liftCoSubst</a>. In
--   particular, if <tt>liftCoMatch vars ty co == Just s</tt>, then
--   <tt>liftCoSubst s ty == co</tt>, where <tt>==</tt> there means that
--   the result of <a>liftCoSubst</a> has the same type as the original co;
--   but may be different under the hood. That is, it matches a type
--   against a coercion of the same "shape", and returns a lifting
--   substitution which could have been used to produce the given coercion
--   from the given type. Note that this function is incomplete -- it might
--   return Nothing when there does indeed exist a possible lifting
--   context.
--   
--   This function is incomplete in that it doesn't respect the equality in
--   <a>eqType</a>. That is, it's possible that this will succeed for t1
--   and fail for t2, even when t1 <a>eqType</a> t2. That's because it
--   depends on there being a very similar structure between the type and
--   the coercion. This incompleteness shouldn't be all that surprising,
--   especially because it depends on the structure of the coercion, which
--   is a silly thing to do.
--   
--   The lifting context produced doesn't have to be exacting in the roles
--   of the mappings. This is because any use of the lifting context will
--   also require a desired role. Thus, this algorithm prefers mapping to
--   nominal coercions where it can do so.
liftCoMatch :: TyCoVarSet -> Type -> Coercion -> Maybe LiftingContext
flattenTys :: InScopeSet -> [Type] -> [Type]
flattenTysX :: InScopeSet -> [Type] -> ([Type], TyVarEnv (TyCon, [Type]))
instance GHC.Base.Functor GHC.Core.Unify.UnifyResultM
instance GHC.Classes.Eq GHC.Core.Unify.BindFlag
instance GHC.Base.Functor GHC.Core.Unify.UM
instance GHC.Base.Applicative GHC.Core.Unify.UM
instance GHC.Base.Monad GHC.Core.Unify.UM
instance Control.Monad.Fail.MonadFail GHC.Core.Unify.UM
instance GHC.Base.Applicative GHC.Core.Unify.UnifyResultM
instance GHC.Base.Monad GHC.Core.Unify.UnifyResultM
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.Unify.UnifyResultM a)
instance GHC.Utils.Outputable.Outputable GHC.Core.Unify.MaybeApartReason
instance GHC.Base.Semigroup GHC.Core.Unify.MaybeApartReason

module GHC.Core.DataCon

-- | A data constructor
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnClose</a>,<a>AnnComma</a></li>
--   </ul>
data DataCon

-- | Data Constructor Representation See Note [Data constructor workers and
--   wrappers]
data DataConRep
NoDataConRep :: DataConRep
DCR :: Id -> DataConBoxer -> [Scaled Type] -> [StrictnessMark] -> [HsImplBang] -> DataConRep
[dcr_wrap_id] :: DataConRep -> Id
[dcr_boxer] :: DataConRep -> DataConBoxer
[dcr_arg_tys] :: DataConRep -> [Scaled Type]
[dcr_stricts] :: DataConRep -> [StrictnessMark]
[dcr_bangs] :: DataConRep -> [HsImplBang]

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness

-- | Haskell Source Bang
--   
--   Bangs on data constructor arguments as the user wrote them in the
--   source code.
--   
--   <tt>(HsSrcBang _ SrcUnpack SrcLazy)</tt> and <tt>(HsSrcBang _
--   SrcUnpack NoSrcStrict)</tt> (without StrictData) makes no sense, we
--   emit a warning (in checkValidDataCon) and treat it like <tt>(HsSrcBang
--   _ NoSrcUnpack SrcLazy)</tt>
data HsSrcBang
HsSrcBang :: SourceText -> SrcUnpackedness -> SrcStrictness -> HsSrcBang

-- | Haskell Implementation Bang
--   
--   Bangs of data constructor arguments as generated by the compiler after
--   consulting HsSrcBang, flags, etc.
data HsImplBang

-- | Lazy field, or one with an unlifted type
HsLazy :: HsImplBang

-- | Strict but not unpacked field True <a>=</a> we could have unpacked,
--   but opted not to because of -O0. See Note [Detecting useless UNPACK
--   pragmas]
HsStrict :: Bool -> HsImplBang

-- | Strict and unpacked field co :: arg-ty ~ product-ty HsBang
HsUnpack :: Maybe Coercion -> HsImplBang
data StrictnessMark
MarkedStrict :: StrictnessMark
NotMarkedStrict :: StrictnessMark

-- | A *one-index* constructor tag
--   
--   Type of the tags associated with each constructor possibility or
--   superclass selector
type ConTag = Int
type DataConEnv a = UniqFM DataCon a

-- | An <a>EqSpec</a> is a tyvar/type pair representing an equality made in
--   rejigging a GADT constructor
data EqSpec

-- | Make a non-dependent <a>EqSpec</a>
mkEqSpec :: TyVar -> Type -> EqSpec
eqSpecTyVar :: EqSpec -> TyVar
eqSpecType :: EqSpec -> Type
eqSpecPair :: EqSpec -> (TyVar, Type)
eqSpecPreds :: [EqSpec] -> ThetaType

-- | Fields in an algebraic record type; see Note [FieldLabel].
data FieldLabel
FieldLabel :: FieldLabelString -> DuplicateRecordFields -> FieldSelectors -> Name -> FieldLabel

-- | User-visible label of the field
[flLabel] :: FieldLabel -> FieldLabelString

-- | Was <tt>DuplicateRecordFields</tt> on in the defining module for this
--   datatype?
[flHasDuplicateRecordFields] :: FieldLabel -> DuplicateRecordFields

-- | Was <tt>FieldSelectors</tt> enabled in the defining module for this
--   datatype? See Note [NoFieldSelectors] in GHC.Rename.Env
[flHasFieldSelector] :: FieldLabel -> FieldSelectors

-- | Record selector function
[flSelector] :: FieldLabel -> Name

-- | Field labels are just represented as strings; they are not necessarily
--   unique (even within a module)
data FieldLabelString

-- | Build a new data constructor
mkDataCon :: Name -> Bool -> TyConRepName -> [HsSrcBang] -> [FieldLabel] -> [TyVar] -> [TyCoVar] -> [InvisTVBinder] -> [EqSpec] -> KnotTied ThetaType -> [KnotTied (Scaled Type)] -> KnotTied Type -> PromDataConInfo -> KnotTied TyCon -> ConTag -> ThetaType -> Id -> DataConRep -> DataCon

-- | Tags are allocated from here for real constructors or for superclass
--   selectors
fIRST_TAG :: ConTag

-- | The representation type of the data constructor, i.e. the sort type
--   that will represent values of this type at runtime
dataConRepType :: DataCon -> Type

-- | Instantiate the universal tyvars of a data con, returning (
--   instantiated existentials , instantiated constraints including
--   dependent GADT equalities which are *also* listed in the instantiated
--   existentials , instantiated args)
dataConInstSig :: DataCon -> [Type] -> ([TyCoVar], ThetaType, [Type])

-- | The "full signature" of the <a>DataCon</a> returns, in order:
--   
--   1) The result of <a>dataConUnivTyVars</a>
--   
--   2) The result of <a>dataConExTyCoVars</a>
--   
--   3) The non-dependent GADT equalities. Dependent GADT equalities are
--   implied by coercion variables in return value (2).
--   
--   4) The other constraints of the data constructor type, excluding GADT
--   equalities
--   
--   5) The original argument types to the <a>DataCon</a> (i.e. before any
--   change of the representation of the type) with linearity annotations
--   
--   6) The original result type of the <a>DataCon</a>
dataConFullSig :: DataCon -> ([TyVar], [TyCoVar], [EqSpec], ThetaType, [Scaled Type], Type)

-- | The <a>Name</a> of the <a>DataCon</a>, giving it a unique, rooted
--   identification
dataConName :: DataCon -> Name

-- | The string <tt>package:module.name</tt> identifying a constructor,
--   which is attached to its info table and used by the GHCi debugger and
--   the heap profiler
dataConIdentity :: DataCon -> ByteString

-- | The tag used for ordering <a>DataCon</a>s
dataConTag :: DataCon -> ConTag
dataConTagZ :: DataCon -> ConTagZ

-- | The type constructor that we are building via this data constructor
dataConTyCon :: DataCon -> TyCon

-- | The original type constructor used in the definition of this data
--   constructor. In case of a data family instance, that will be the
--   family type constructor.
dataConOrigTyCon :: DataCon -> TyCon

-- | The user-declared type of the data constructor in the nice-to-read
--   form:
--   
--   <pre>
--   T :: forall a b. a -&gt; b -&gt; T [a]
--   </pre>
--   
--   rather than:
--   
--   <pre>
--   T :: forall a c. forall b. (c~[a]) =&gt; a -&gt; b -&gt; T c
--   </pre>
--   
--   The type variables are quantified in the order that the user wrote
--   them. See <tt>Note [DataCon user type variable binders]</tt>.
--   
--   NB: If the constructor is part of a data instance, the result type
--   mentions the family tycon, not the internal one.
dataConWrapperType :: DataCon -> Type
dataConNonlinearType :: DataCon -> Type
dataConDisplayType :: Bool -> DataCon -> Type

-- | The universally-quantified type variables of the constructor
dataConUnivTyVars :: DataCon -> [TyVar]

-- | The existentially-quantified type/coercion variables of the
--   constructor including dependent (kind-) GADT equalities
dataConExTyCoVars :: DataCon -> [TyCoVar]

-- | Both the universal and existential type/coercion variables of the
--   constructor
dataConUnivAndExTyCoVars :: DataCon -> [TyCoVar]

-- | The type variables of the constructor, in the order the user wrote
--   them
dataConUserTyVars :: DataCon -> [TyVar]

-- | <a>InvisTVBinder</a>s for the type variables of the constructor, in
--   the order the user wrote them
dataConUserTyVarBinders :: DataCon -> [InvisTVBinder]

-- | The *full* constraints on the constructor type, including dependent
--   GADT equalities.
dataConTheta :: DataCon -> ThetaType

-- | The "stupid theta" of the <a>DataCon</a>, such as <tt>data Eq a</tt>
--   in:
--   
--   <pre>
--   data Eq a =&gt; T a = ...
--   </pre>
--   
--   See <tt>Note [The stupid context]</tt>.
dataConStupidTheta :: DataCon -> ThetaType

-- | Returns constraints in the wrapper type, other than those in the
--   dataConEqSpec
dataConOtherTheta :: DataCon -> ThetaType

-- | Finds the instantiated types of the arguments required to construct a
--   <a>DataCon</a> representation NB: these INCLUDE any dictionary args
--   but EXCLUDE the data-declaration context, which is discarded It's all
--   post-flattening etc; this is a representation type
dataConInstArgTys :: DataCon -> [Type] -> [Scaled Type]

-- | Returns the argument types of the wrapper, excluding all dictionary
--   arguments and without substituting for any type variables
dataConOrigArgTys :: DataCon -> [Scaled Type]
dataConOrigResTy :: DataCon -> Type

-- | Returns just the instantiated <i>value</i> argument types of a
--   <a>DataCon</a>, (excluding dictionary args)
dataConInstOrigArgTys :: DataCon -> [Type] -> [Scaled Type]

-- | Returns the arg types of the worker, including *all* non-dependent
--   evidence, after any flattening has been done and without substituting
--   for any type variables
dataConRepArgTys :: DataCon -> [Scaled Type]

-- | Were the type variables of the data con written in a different order
--   than the regular order (universal tyvars followed by existential
--   tyvars)?
--   
--   This is not a cheap test, so we minimize its use in GHC as much as
--   possible. Currently, its only call site in the GHC codebase is in
--   <tt>mkDataConRep</tt> in <a>MkId</a>, and so
--   <a>dataConUserTyVarsNeedWrapper</a> is only called at most once during
--   a data constructor's lifetime.
dataConResRepTyArgs :: DataCon -> [Type]

-- | Given a data constructor <tt>dc</tt> with <i>n</i> universally
--   quantified type variables <tt>a_{1}</tt>, <tt>a_{2}</tt>, ...,
--   <tt>a_{n}</tt>, and given a list of argument types <tt>dc_args</tt> of
--   length <i>m</i> where <i>m</i> &lt;= <i>n</i>, then:
--   
--   <pre>
--   dataConInstUnivs dc dc_args
--   </pre>
--   
--   Will return:
--   
--   <pre>
--   [dc_arg_{1}, dc_arg_{2}, ..., dc_arg_{m}, a_{m+1}, ..., a_{n}]
--   </pre>
--   
--   That is, return the list of universal type variables with
--   <tt>a_{1}</tt>, <tt>a_{2}</tt>, ..., <tt>a_{m}</tt> instantiated with
--   <tt>dc_arg_{1}</tt>, <tt>dc_arg_{2}</tt>, ..., <tt>dc_arg_{m}</tt>. It
--   is possible for <tt>m</tt> to be less than <tt>n</tt>, in which case
--   the remaining <tt>n - m</tt> elements will simply be universal type
--   variables (with their kinds possibly instantiated).
--   
--   Examples:
--   
--   <ul>
--   <li>Given the data constructor <tt>D :: forall a b. Foo a b</tt> and
--   <tt>dc_args</tt> <tt>[Int, Bool]</tt>, then <tt>dataConInstUnivs D
--   dc_args</tt> will return <tt>[Int, Bool]</tt>.</li>
--   <li>Given the data constructor <tt>D :: forall a b. Foo a b</tt> and
--   <tt>dc_args</tt> <tt>[Int]</tt>, then @<tt>dataConInstUnivs D
--   dc_args</tt> will return <tt>[Int, b]</tt>.</li>
--   <li>Given the data constructor <tt>E :: forall k (a :: k). Bar k
--   a</tt> and <tt>dc_args</tt> <tt>[Type]</tt>, then
--   @<tt>dataConInstUnivs D dc_args</tt> will return <tt>[Type, (a ::
--   Type)]</tt>.</li>
--   </ul>
--   
--   This is primarily used in <tt>GHC.Tc.Deriv.*</tt> in service of
--   instantiating data constructors' field types. See <tt>Note
--   [Instantiating field types in stock deriving]</tt> for a notable
--   example of this.
dataConInstUnivs :: DataCon -> [Type] -> [Type]

-- | The labels for the fields of this particular <a>DataCon</a>
dataConFieldLabels :: DataCon -> [FieldLabel]

-- | Extract the type for any given labelled field of the <a>DataCon</a>
dataConFieldType :: DataCon -> FieldLabelString -> Type

-- | Extract the label and type for any given labelled field of the
--   <a>DataCon</a>, or return <a>Nothing</a> if the field does not belong
--   to it
dataConFieldType_maybe :: DataCon -> FieldLabelString -> Maybe (FieldLabel, Type)

-- | Strictness/unpack annotations, from user; or, for imported DataCons,
--   from the interface file The list is in one-to-one correspondence with
--   the arity of the <a>DataCon</a>
dataConSrcBangs :: DataCon -> [HsSrcBang]

-- | Source-level arity of the data constructor
dataConSourceArity :: DataCon -> Arity

-- | Gives the number of value arguments (including zero-width coercions)
--   stored by the given <a>DataCon</a>'s worker in its Core
--   representation. This may differ from the number of arguments that
--   appear in the source code; see also Note [DataCon arities]
dataConRepArity :: DataCon -> Arity

-- | Should the <a>DataCon</a> be presented infix?
dataConIsInfix :: DataCon -> Bool

-- | Get the Id of the <a>DataCon</a> worker: a function that is the
--   "actual" constructor and has no top level binding in the program. The
--   type may be different from the obvious one written in the source
--   program. Panics if there is no such <a>Id</a> for this <a>DataCon</a>
dataConWorkId :: DataCon -> Id

-- | Returns an Id which looks like the Haskell-source constructor by using
--   the wrapper if it exists (see <a>dataConWrapId_maybe</a>) and failing
--   over to the worker (see <a>dataConWorkId</a>)
dataConWrapId :: DataCon -> Id

-- | Get the Id of the <a>DataCon</a> wrapper: a function that wraps the
--   "actual" constructor so it has the type visible in the source program:
--   c.f. <a>dataConWorkId</a>. Returns Nothing if there is no wrapper,
--   which occurs for an algebraic data constructor and also for a newtype
--   (whose constructor is inlined compulsorily)
dataConWrapId_maybe :: DataCon -> Maybe Id

-- | Find all the <a>Id</a>s implicitly brought into scope by the data
--   constructor. Currently, the union of the <a>dataConWorkId</a> and the
--   <a>dataConWrapId</a>
dataConImplicitTyThings :: DataCon -> [TyThing]

-- | Give the demands on the arguments of a Core constructor application
--   (Con dc args)
dataConRepStrictness :: DataCon -> [StrictnessMark]
dataConImplBangs :: DataCon -> [HsImplBang]
dataConBoxer :: DataCon -> Maybe DataConBoxer

-- | Extract the type constructor, type argument, data constructor and it's
--   <i>representation</i> argument types from a type if it is a product
--   type.
--   
--   Precisely, we return <tt>Just</tt> for any data type that is all of:
--   
--   <ul>
--   <li>Concrete (i.e. constructors visible)</li>
--   <li>Single-constructor</li>
--   <li>... which has no existentials</li>
--   </ul>
--   
--   Whether the type is a <tt>data</tt> type or a <tt>newtype</tt>.
splitDataProductType_maybe :: Type -> Maybe (TyCon, [Type], DataCon, [Scaled Type])

-- | Return whether there are any argument types for this <a>DataCon</a>s
--   original source type See Note [DataCon arities]
isNullarySrcDataCon :: DataCon -> Bool

-- | Return whether this <a>DataCon</a>'s worker, in its Core
--   representation, takes any value arguments.
--   
--   In particular, remember that we include coercion arguments in the
--   arity of the Core representation of the <a>DataCon</a> -- both lifted
--   and unlifted coercions, despite the latter having zero-width runtime
--   representation.
--   
--   See also Note [DataCon arities].
isNullaryRepDataCon :: DataCon -> Bool
isTupleDataCon :: DataCon -> Bool
isBoxedTupleDataCon :: DataCon -> Bool
isUnboxedTupleDataCon :: DataCon -> Bool
isUnboxedSumDataCon :: DataCon -> Bool
isCovertGadtDataCon :: DataCon -> Bool

-- | Vanilla <a>DataCon</a>s are those that are nice boring Haskell 98
--   constructors
isVanillaDataCon :: DataCon -> Bool

-- | Is this the <a>DataCon</a> of a newtype?
isNewDataCon :: DataCon -> Bool

-- | Is this data constructor in a "type data" declaration? See Note [Type
--   data declarations] in GHC.Rename.Module.
isTypeDataCon :: DataCon -> Bool
classDataCon :: Class -> DataCon
dataConCannotMatch :: [Type] -> DataCon -> Bool
dataConUserTyVarsNeedWrapper :: DataCon -> Bool
checkDataConTyVars :: DataCon -> Bool
isBanged :: HsImplBang -> Bool
isMarkedStrict :: StrictnessMark -> Bool
cbvFromStrictMark :: StrictnessMark -> CbvMark

-- | Compare strictness annotations
eqHsBang :: HsImplBang -> HsImplBang -> Bool
isSrcStrict :: SrcStrictness -> Bool
isSrcUnpacked :: SrcUnpackedness -> Bool

-- | Should this DataCon be allowed in a type even without -XDataKinds?
--   Currently, only Lifted &amp; Unlifted
specialPromotedDc :: DataCon -> Bool
promoteDataCon :: DataCon -> TyCon
instance Data.Data.Data GHC.Core.DataCon.HsSrcBang
instance Data.Data.Data GHC.Core.DataCon.HsImplBang
instance GHC.Classes.Eq GHC.Core.DataCon.StrictnessMark
instance GHC.Classes.Eq GHC.Core.DataCon.DataCon
instance GHC.Types.Unique.Uniquable GHC.Core.DataCon.DataCon
instance GHC.Types.Name.NamedThing GHC.Core.DataCon.DataCon
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.DataCon
instance GHC.Utils.Outputable.OutputableBndr GHC.Core.DataCon.DataCon
instance Data.Data.Data GHC.Core.DataCon.DataCon
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.EqSpec
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.StrictnessMark
instance GHC.Utils.Binary.Binary GHC.Core.DataCon.StrictnessMark
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.HsImplBang
instance GHC.Utils.Outputable.Outputable GHC.Core.DataCon.HsSrcBang
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.SrcStrictness
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Basic.SrcUnpackedness
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Basic.SrcStrictness
instance GHC.Utils.Binary.Binary Language.Haskell.Syntax.Basic.SrcUnpackedness

module Language.Haskell.Syntax.Type

-- | This is used in the syntax. In constructor declaration. It must keep
--   the arrow representation.
data HsScaled pass a
HsScaled :: HsArrow pass -> a -> HsScaled pass a
hsMult :: HsScaled pass a -> HsArrow pass
hsScaledThing :: HsScaled pass a -> a

-- | Denotes the type of arrows in the surface language
data HsArrow pass

-- | a -&gt; b or a → b
HsUnrestrictedArrow :: !LHsUniToken "->" "→" pass -> HsArrow pass

-- | a %1 -&gt; b or a %1 → b, or a ⊸ b
HsLinearArrow :: !HsLinearArrowTokens pass -> HsArrow pass

-- | a %m -&gt; b or a %m → b (very much including `a %Many -&gt; b`! This
--   is how the programmer wrote it). It is stored as an <a>HsType</a> so
--   as to preserve the syntax as written in the program.
HsExplicitMult :: !LHsToken "%" pass -> !LHsType pass -> !LHsUniToken "->" "→" pass -> HsArrow pass
data HsLinearArrowTokens pass
HsPct1 :: !LHsToken "%1" pass -> !LHsUniToken "->" "→" pass -> HsLinearArrowTokens pass
HsLolly :: !LHsToken "⊸" pass -> HsLinearArrowTokens pass

-- | Haskell Type
data HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnForall</a>,
--   <a>AnnDot</a>,<a>AnnDarrow</a> For details on above see Note [exact
--   print annotations] in <a>GHC.Parser.Annotation</a></li>
--   </ul>
HsForAllTy :: XForAllTy pass -> HsForAllTelescope pass -> LHsType pass -> HsType pass
[hst_xforall] :: HsType pass -> XForAllTy pass
[hst_tele] :: HsType pass -> HsForAllTelescope pass
[hst_body] :: HsType pass -> LHsType pass
HsQualTy :: XQualTy pass -> LHsContext pass -> LHsType pass -> HsType pass
[hst_xqual] :: HsType pass -> XQualTy pass
[hst_ctxt] :: HsType pass -> LHsContext pass
[hst_body] :: HsType pass -> LHsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsTyVar :: XTyVar pass -> PromotionFlag -> LIdP pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsAppTy :: XAppTy pass -> LHsType pass -> LHsType pass -> HsType pass
HsAppKindTy :: XAppKindTy pass -> LHsType pass -> LHsKind pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a>,</li>
--   </ul>
HsFunTy :: XFunTy pass -> HsArrow pass -> LHsType pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
HsListTy :: XListTy pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(' or '(#'</tt>,
--   <a>AnnClose</a> <tt>')' or '#)'</tt></li>
--   </ul>
HsTupleTy :: XTupleTy pass -> HsTupleSort -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnClose</a> '#)'@</li>
--   </ul>
HsSumTy :: XSumTy pass -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsOpTy :: XOpTy pass -> PromotionFlag -> LHsType pass -> LIdP pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
HsParTy :: XParTy pass -> LHsType pass -> HsType pass

-- | <pre>
--   (?x :: ty)
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
HsIParamTy :: XIParamTy pass -> XRec pass HsIPName -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsStarTy :: XStarTy pass -> Bool -> HsType pass

-- | <pre>
--   (ty :: kind)
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>,
--   <a>AnnDcolon</a>,<a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsKindSig :: XKindSig pass -> LHsType pass -> LHsKind pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'$('</tt>,
--   <a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsSpliceTy :: XSpliceTy pass -> HsUntypedSplice pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsDocTy :: XDocTy pass -> LHsType pass -> LHsDoc pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# UNPACK' or '{-#
--   NOUNPACK'</tt>, <a>AnnClose</a> <tt>'#-}'</tt> <a>AnnBang</a>
--   <tt>'!'</tt></li>
--   </ul>
HsBangTy :: XBangTy pass -> HsSrcBang -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>, <a>AnnClose</a>
--   <tt>'}'</tt></li>
--   </ul>
HsRecTy :: XRecTy pass -> [LConDeclField pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>"'["</tt>,
--   <a>AnnClose</a> <tt>']'</tt></li>
--   </ul>
HsExplicitListTy :: XExplicitListTy pass -> PromotionFlag -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>"'("</tt>,
--   <a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsExplicitTupleTy :: XExplicitTupleTy pass -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsTyLit :: XTyLit pass -> HsTyLit pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsWildCardTy :: XWildCardTy pass -> HsType pass
XHsType :: !XXType pass -> HsType pass

-- | Located Haskell Type
type LHsType pass = -- | May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when --   in a list XRec pass (HsType pass)

-- | Haskell Kind
type HsKind pass = HsType pass

-- | Located Haskell Kind
type LHsKind pass = -- | 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon' XRec pass (HsKind pass)

-- | The type variable binders in an <a>HsForAllTy</a>. See also <tt>Note
--   [Variable Specificity and Forall Visibility]</tt> in
--   <a>GHC.Tc.Gen.HsType</a>.
data HsForAllTelescope pass

-- | A visible <tt>forall</tt> (e.g., <tt>forall a -&gt; {...}</tt>). These
--   do not have any notion of specificity, so we use <tt>()</tt> as a
--   placeholder value.
HsForAllVis :: XHsForAllVis pass -> [LHsTyVarBndr () pass] -> HsForAllTelescope pass
[hsf_xvis] :: HsForAllTelescope pass -> XHsForAllVis pass
[hsf_vis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr () pass]

-- | An invisible <tt>forall</tt> (e.g., <tt>forall a {b} c. {...}</tt>),
--   where each binder has a <a>Specificity</a>.
HsForAllInvis :: XHsForAllInvis pass -> [LHsTyVarBndr Specificity pass] -> HsForAllTelescope pass
[hsf_xinvis] :: HsForAllTelescope pass -> XHsForAllInvis pass
[hsf_invis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr Specificity pass]
XHsForAllTelescope :: !XXHsForAllTelescope pass -> HsForAllTelescope pass

-- | Haskell Type Variable Binder The flag annotates the binder. It is
--   <a>Specificity</a> in places where explicit specificity is allowed
--   (e.g. x :: forall {a} b. ...) or <tt>()</tt> in other places.
data HsTyVarBndr flag pass
UserTyVar :: XUserTyVar pass -> flag -> LIdP pass -> HsTyVarBndr flag pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnDcolon</a>,
--   <a>AnnClose</a></li>
--   </ul>
KindedTyVar :: XKindedTyVar pass -> flag -> LIdP pass -> LHsKind pass -> HsTyVarBndr flag pass
XTyVarBndr :: !XXTyVarBndr pass -> HsTyVarBndr flag pass

-- | Located Haskell Type Variable Binder
type LHsTyVarBndr flag pass = XRec pass (HsTyVarBndr flag pass)

-- | Located Haskell Quantified Type Variables
data LHsQTyVars pass
HsQTvs :: XHsQTvs pass -> [LHsTyVarBndr () pass] -> LHsQTyVars pass
[hsq_ext] :: LHsQTyVars pass -> XHsQTvs pass
[hsq_explicit] :: LHsQTyVars pass -> [LHsTyVarBndr () pass]
XLHsQTyVars :: !XXLHsQTyVars pass -> LHsQTyVars pass

-- | The outermost type variables in a type that obeys the
--   <tt>forall</tt>-or-nothing rule. See <tt>Note [forall-or-nothing
--   rule]</tt>.
data HsOuterTyVarBndrs flag pass

-- | Implicit forall, e.g., <tt>f :: a -&gt; b -&gt; b</tt>
HsOuterImplicit :: XHsOuterImplicit pass -> HsOuterTyVarBndrs flag pass
[hso_ximplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterImplicit pass

-- | Explicit forall, e.g., <tt>f :: forall a b. a -&gt; b -&gt; b</tt>
HsOuterExplicit :: XHsOuterExplicit pass flag -> [LHsTyVarBndr flag (NoGhcTc pass)] -> HsOuterTyVarBndrs flag pass
[hso_xexplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterExplicit pass flag
[hso_bndrs] :: HsOuterTyVarBndrs flag pass -> [LHsTyVarBndr flag (NoGhcTc pass)]
XHsOuterTyVarBndrs :: !XXHsOuterTyVarBndrs pass -> HsOuterTyVarBndrs flag pass

-- | Used for type-family instance equations, e.g.,
--   
--   <pre>
--   type instance forall a. F [a] = Tree a
--   </pre>
--   
--   The notion of specificity is irrelevant in type family equations, so
--   we use <tt>()</tt> for the <a>HsOuterTyVarBndrs</a> <tt>flag</tt>.
type HsOuterFamEqnTyVarBndrs = HsOuterTyVarBndrs ()

-- | Used for signatures, e.g.,
--   
--   <pre>
--   f :: forall a {b}. blah
--   </pre>
--   
--   We use <a>Specificity</a> for the <a>HsOuterTyVarBndrs</a>
--   <tt>flag</tt> to allow distinguishing between specified and inferred
--   type variables.
type HsOuterSigTyVarBndrs = HsOuterTyVarBndrs Specificity

-- | Haskell Wildcard Binders
data HsWildCardBndrs pass thing
HsWC :: XHsWC pass thing -> thing -> HsWildCardBndrs pass thing
[hswc_ext] :: HsWildCardBndrs pass thing -> XHsWC pass thing
[hswc_body] :: HsWildCardBndrs pass thing -> thing
XHsWildCardBndrs :: !XXHsWildCardBndrs pass thing -> HsWildCardBndrs pass thing

-- | Types that can appear in pattern signatures, as well as the signatures
--   for term-level binders in RULES. See <tt>Note [Pattern signature
--   binders and scoping]</tt>.
--   
--   This is very similar to <tt>HsSigWcType</tt>, but with slightly
--   different semantics: see <tt>Note [HsType binders]</tt>. See also
--   <tt>Note [The wildcard story for types]</tt>.
data HsPatSigType pass
HsPS :: XHsPS pass -> LHsType pass -> HsPatSigType pass

-- | After renamer: <tt>HsPSRn</tt>
[hsps_ext] :: HsPatSigType pass -> XHsPS pass

-- | Main payload (the type itself)
[hsps_body] :: HsPatSigType pass -> LHsType pass
XHsPatSigType :: !XXHsPatSigType pass -> HsPatSigType pass

-- | A type signature that obeys the <tt>forall</tt>-or-nothing rule. In
--   other words, an <a>LHsType</a> that uses an
--   <a>HsOuterSigTyVarBndrs</a> to represent its outermost type variable
--   quantification. See <tt>Note [Representing type signatures]</tt>.
data HsSigType pass
HsSig :: XHsSig pass -> HsOuterSigTyVarBndrs pass -> LHsType pass -> HsSigType pass
[sig_ext] :: HsSigType pass -> XHsSig pass
[sig_bndrs] :: HsSigType pass -> HsOuterSigTyVarBndrs pass
[sig_body] :: HsSigType pass -> LHsType pass
XHsSigType :: !XXHsSigType pass -> HsSigType pass

-- | Located Haskell Signature Type
type LHsSigType pass = XRec pass (HsSigType pass)

-- | Located Haskell Signature Wildcard Type
type LHsSigWcType pass = HsWildCardBndrs pass (LHsSigType pass)

-- | Located Haskell Wildcard Type
type LHsWcType pass = HsWildCardBndrs pass (LHsType pass)

-- | Haskell Tuple Sort
data HsTupleSort
HsUnboxedTuple :: HsTupleSort
HsBoxedOrConstraintTuple :: HsTupleSort

-- | Haskell Context
type HsContext pass = [LHsType pass]

-- | Located Haskell Context
type LHsContext pass = -- | 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnUnit' -- For details on above see Note [exact print annotations] in GHC.Parser.Annotation XRec pass (HsContext pass)

-- | Haskell Type Literal
data HsTyLit pass
HsNumTy :: XNumTy pass -> Integer -> HsTyLit pass
HsStrTy :: XStrTy pass -> FastString -> HsTyLit pass
HsCharTy :: XCharTy pass -> Char -> HsTyLit pass
XTyLit :: !XXTyLit pass -> HsTyLit pass

-- | These names are used early on to store the names of implicit
--   parameters. They completely disappear after type-checking.
newtype HsIPName
HsIPName :: FastString -> HsIPName
hsIPNameFS :: HsIPName -> FastString

-- | Arguments in an expression/type after splitting
data HsArg tm ty
HsValArg :: tm -> HsArg tm ty
HsTypeArg :: SrcSpan -> ty -> HsArg tm ty
HsArgPar :: SrcSpan -> HsArg tm ty
type LHsTypeArg p = HsArg (LHsType p) (LHsKind p)

-- | Located Bang Type
type LBangType pass = XRec pass (BangType pass)

-- | Bang Type
--   
--   In the parser, strictness and packedness annotations bind more tightly
--   than docstrings. This means that when consuming a <a>BangType</a> (and
--   looking for <a>HsBangTy</a>) we must be ready to peer behind a
--   potential layer of <a>HsDocTy</a>. See #15206 for motivation and
--   <tt>getBangType</tt> for an example.
type BangType pass = HsType pass

-- | Haskell Source Bang
--   
--   Bangs on data constructor arguments as the user wrote them in the
--   source code.
--   
--   <tt>(HsSrcBang _ SrcUnpack SrcLazy)</tt> and <tt>(HsSrcBang _
--   SrcUnpack NoSrcStrict)</tt> (without StrictData) makes no sense, we
--   emit a warning (in checkValidDataCon) and treat it like <tt>(HsSrcBang
--   _ NoSrcUnpack SrcLazy)</tt>
data HsSrcBang
HsSrcBang :: SourceText -> SrcUnpackedness -> SrcStrictness -> HsSrcBang

-- | Is a TyCon a promoted data constructor or just a normal type
--   constructor?
data PromotionFlag
NotPromoted :: PromotionFlag
IsPromoted :: PromotionFlag
isPromoted :: PromotionFlag -> Bool

-- | Constructor Declaration Field
data ConDeclField pass
ConDeclField :: XConDeclField pass -> [LFieldOcc pass] -> LBangType pass -> Maybe (LHsDoc pass) -> ConDeclField pass
[cd_fld_ext] :: ConDeclField pass -> XConDeclField pass

-- | See Note [ConDeclField pass]
[cd_fld_names] :: ConDeclField pass -> [LFieldOcc pass]
[cd_fld_type] :: ConDeclField pass -> LBangType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
[cd_fld_doc] :: ConDeclField pass -> Maybe (LHsDoc pass)
XConDeclField :: !XXConDeclField pass -> ConDeclField pass

-- | Located Constructor Declaration Field
type LConDeclField pass = -- | May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when --   in a list XRec pass (ConDeclField pass)

-- | Describes the arguments to a data constructor. This is a common
--   representation for several constructor-related concepts, including:
--   
--   <ul>
--   <li>The arguments in a Haskell98-style constructor declaration (see
--   <tt>HsConDeclH98Details</tt> in <a>GHC.Hs.Decls</a>).</li>
--   <li>The arguments in constructor patterns in <tt>case</tt>/function
--   definitions (see <tt>HsConPatDetails</tt> in <a>GHC.Hs.Pat</a>).</li>
--   <li>The left-hand side arguments in a pattern synonym binding (see
--   <tt>HsPatSynDetails</tt> in <a>GHC.Hs.Binds</a>).</li>
--   </ul>
--   
--   One notable exception is the arguments in a GADT constructor, which
--   uses a separate data type entirely (see <tt>HsConDeclGADTDetails</tt>
--   in <a>GHC.Hs.Decls</a>). This is because GADT constructors cannot be
--   declared with infix syntax, unlike the concepts above (#18844).
data HsConDetails tyarg arg rec
PrefixCon :: [tyarg] -> [arg] -> HsConDetails tyarg arg rec
RecCon :: rec -> HsConDetails tyarg arg rec
InfixCon :: arg -> arg -> HsConDetails tyarg arg rec

-- | An empty list that can be used to indicate that there are no type
--   arguments allowed in cases where HsConDetails is applied to Void.
noTypeArgs :: [Void]

-- | Field Occurrence
--   
--   Represents an *occurrence* of a field. This may or may not be a
--   binding occurrence (e.g. this type is used in <a>ConDeclField</a> and
--   <tt>RecordPatSynField</tt> which bind their fields, but also in
--   <tt>HsRecField</tt> for record construction and patterns, which do
--   not).
--   
--   We store both the <a>RdrName</a> the user originally wrote, and after
--   the renamer we use the extension field to store the selector function.
data FieldOcc pass
FieldOcc :: XCFieldOcc pass -> XRec pass RdrName -> FieldOcc pass
[foExt] :: FieldOcc pass -> XCFieldOcc pass
[foLabel] :: FieldOcc pass -> XRec pass RdrName
XFieldOcc :: !XXFieldOcc pass -> FieldOcc pass

-- | Located Field Occurrence
type LFieldOcc pass = XRec pass (FieldOcc pass)

-- | Ambiguous Field Occurrence
--   
--   Represents an *occurrence* of a field that is potentially ambiguous
--   after the renamer, with the ambiguity resolved by the typechecker. We
--   always store the <a>RdrName</a> that the user originally wrote, and
--   store the selector function after the renamer (for unambiguous
--   occurrences) or the typechecker (for ambiguous occurrences).
--   
--   See Note [HsRecField and HsRecUpdField] in <a>GHC.Hs.Pat</a>. See Note
--   [Located RdrNames] in <a>GHC.Hs.Expr</a>.
data AmbiguousFieldOcc pass
Unambiguous :: XUnambiguous pass -> XRec pass RdrName -> AmbiguousFieldOcc pass
Ambiguous :: XAmbiguous pass -> XRec pass RdrName -> AmbiguousFieldOcc pass
XAmbiguousFieldOcc :: !XXAmbiguousFieldOcc pass -> AmbiguousFieldOcc pass

-- | Located Ambiguous Field Occurence
type LAmbiguousFieldOcc pass = XRec pass (AmbiguousFieldOcc pass)
mapHsOuterImplicit :: (XHsOuterImplicit pass -> XHsOuterImplicit pass) -> HsOuterTyVarBndrs flag pass -> HsOuterTyVarBndrs flag pass
hsQTvExplicit :: LHsQTyVars pass -> [LHsTyVarBndr () pass]

-- | Does this <a>HsTyVarBndr</a> come with an explicit kind annotation?
isHsKindedTyVar :: HsTyVarBndr flag pass -> Bool
hsPatSigType :: HsPatSigType pass -> LHsType pass
instance Data.Data.Data Language.Haskell.Syntax.Type.PromotionFlag
instance GHC.Classes.Eq Language.Haskell.Syntax.Type.PromotionFlag
instance Data.Data.Data Language.Haskell.Syntax.Type.HsIPName
instance GHC.Classes.Eq Language.Haskell.Syntax.Type.HsIPName
instance Data.Data.Data Language.Haskell.Syntax.Type.HsTupleSort
instance (Data.Data.Data tyarg, Data.Data.Data rec, Data.Data.Data arg) => Data.Data.Data (Language.Haskell.Syntax.Type.HsConDetails tyarg arg rec)
instance (GHC.Classes.Eq (Language.Haskell.Syntax.Extension.XRec pass GHC.Types.Name.Reader.RdrName), GHC.Classes.Eq (Language.Haskell.Syntax.Extension.XCFieldOcc pass), GHC.Classes.Eq (Language.Haskell.Syntax.Extension.XXFieldOcc pass)) => GHC.Classes.Eq (Language.Haskell.Syntax.Type.FieldOcc pass)

module Language.Haskell.Syntax.Pat

-- | Pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnBang</a></li>
--   </ul>
data Pat p

-- | Wildcard Pattern The sole reason for a type on a WildPat is to support
--   hsPatType :: Pat Id -&gt; Type
WildPat :: XWildPat p -> Pat p

-- | Variable Pattern
VarPat :: XVarPat p -> LIdP p -> Pat p

-- | Lazy Pattern ^ - <a>AnnKeywordId</a> : <a>AnnTilde</a>
LazyPat :: XLazyPat p -> LPat p -> Pat p

-- | As pattern ^ - <a>AnnKeywordId</a> : <a>AnnAt</a>
AsPat :: XAsPat p -> LIdP p -> !LHsToken "@" p -> LPat p -> Pat p
ParPat :: XParPat p -> !LHsToken "(" p -> LPat p -> !LHsToken ")" p -> Pat p

-- | Bang pattern ^ - <a>AnnKeywordId</a> : <a>AnnBang</a>
BangPat :: XBangPat p -> LPat p -> Pat p

-- | Syntactic List
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
ListPat :: XListPat p -> [LPat p] -> Pat p

-- | Tuple sub-patterns
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt> or
--   <tt>'(#'</tt>, <a>AnnClose</a> <tt>')'</tt> or <tt>'#)'</tt></li>
--   </ul>
TuplePat :: XTuplePat p -> [LPat p] -> Boxity -> Pat p

-- | Anonymous sum pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnClose</a> <tt>'#)'</tt></li>
--   </ul>
SumPat :: XSumPat p -> LPat p -> ConTag -> SumWidth -> Pat p

-- | Constructor Pattern
ConPat :: XConPat p -> XRec p (ConLikeP p) -> HsConPatDetails p -> Pat p
[pat_con_ext] :: Pat p -> XConPat p
[pat_con] :: Pat p -> XRec p (ConLikeP p)
[pat_args] :: Pat p -> HsConPatDetails p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a></li>
--   </ul>
ViewPat :: XViewPat p -> LHsExpr p -> LPat p -> Pat p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'$('</tt> <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
SplicePat :: XSplicePat p -> HsUntypedSplice p -> Pat p

-- | Literal Pattern Used for *non-overloaded* literal patterns: Int#,
--   Char#, Int, Char, String, etc.
LitPat :: XLitPat p -> HsLit p -> Pat p

-- | Natural Pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnVal</a> <tt><tt>+</tt></tt></li>
--   </ul>
NPat :: XNPat p -> XRec p (HsOverLit p) -> Maybe (SyntaxExpr p) -> SyntaxExpr p -> Pat p

-- | n+k pattern
NPlusKPat :: XNPlusKPat p -> LIdP p -> XRec p (HsOverLit p) -> HsOverLit p -> SyntaxExpr p -> SyntaxExpr p -> Pat p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
SigPat :: XSigPat p -> LPat p -> HsPatSigType (NoGhcTc p) -> Pat p
XPat :: !XXPat p -> Pat p
type LPat p = XRec p (Pat p)
type family ConLikeP x

-- | Haskell Constructor Pattern Details
type HsConPatDetails p = HsConDetails (HsConPatTyArg (NoGhcTc p)) (LPat p) (HsRecFields p (LPat p))
hsConPatArgs :: forall p. UnXRec p => HsConPatDetails p -> [LPat p]

-- | Type argument in a data constructor pattern, e.g. the <tt>@a</tt> in
--   <tt>f (Just @a x) = ...</tt>.
data HsConPatTyArg p
HsConPatTyArg :: !LHsToken "@" p -> HsPatSigType p -> HsConPatTyArg p

-- | Haskell Record Fields
--   
--   HsRecFields is used only for patterns and expressions (not data type
--   declarations)
data HsRecFields p arg
HsRecFields :: [LHsRecField p arg] -> Maybe (XRec p RecFieldsDotDot) -> HsRecFields p arg
[rec_flds] :: HsRecFields p arg -> [LHsRecField p arg]
[rec_dotdot] :: HsRecFields p arg -> Maybe (XRec p RecFieldsDotDot)

-- | Haskell Field Binding
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a>,</li>
--   </ul>
--   
--   For details on above see Note [exact print annotations] in
--   GHC.Parser.Annotation
data HsFieldBind lhs rhs
HsFieldBind :: XHsFieldBind lhs -> lhs -> rhs -> Bool -> HsFieldBind lhs rhs
[hfbAnn] :: HsFieldBind lhs rhs -> XHsFieldBind lhs
[hfbLHS] :: HsFieldBind lhs rhs -> lhs

-- | Filled in by renamer when punning
[hfbRHS] :: HsFieldBind lhs rhs -> rhs

-- | Note [Punning]
[hfbPun] :: HsFieldBind lhs rhs -> Bool

-- | Located Haskell Record Field
type LHsFieldBind p id arg = XRec p (HsFieldBind id arg)

-- | Haskell Record Field
type HsRecField p arg = HsFieldBind (LFieldOcc p) arg

-- | Located Haskell Record Field
type LHsRecField p arg = XRec p (HsRecField p arg)

-- | Haskell Record Update Field
type HsRecUpdField p = HsFieldBind (LAmbiguousFieldOcc p) (LHsExpr p)

-- | Located Haskell Record Update Field
type LHsRecUpdField p = XRec p (HsRecUpdField p)

-- | Newtype to be able to have a specific XRec instance for the Int in
--   <a>rec_dotdot</a>
newtype RecFieldsDotDot
RecFieldsDotDot :: Int -> RecFieldsDotDot
[unRecFieldsDotDot] :: RecFieldsDotDot -> Int
hsRecFields :: forall p arg. UnXRec p => HsRecFields p arg -> [XCFieldOcc p]
hsRecFieldSel :: forall p arg. UnXRec p => HsRecField p arg -> XCFieldOcc p
hsRecFieldsArgs :: forall p arg. UnXRec p => HsRecFields p arg -> [arg]
instance GHC.Classes.Ord Language.Haskell.Syntax.Pat.RecFieldsDotDot
instance GHC.Classes.Eq Language.Haskell.Syntax.Pat.RecFieldsDotDot
instance Data.Data.Data Language.Haskell.Syntax.Pat.RecFieldsDotDot
instance Data.Traversable.Traversable (Language.Haskell.Syntax.Pat.HsFieldBind lhs)
instance Data.Foldable.Foldable (Language.Haskell.Syntax.Pat.HsFieldBind lhs)
instance GHC.Base.Functor (Language.Haskell.Syntax.Pat.HsFieldBind lhs)

module Language.Haskell.Syntax.Binds

-- | Haskell Local Bindings
type HsLocalBinds id = HsLocalBindsLR id id

-- | Located Haskell local bindings
type LHsLocalBinds id = XRec id (HsLocalBinds id)

-- | Haskell Local Bindings with separate Left and Right identifier types
--   
--   Bindings in a 'let' expression or a 'where' clause
data HsLocalBindsLR idL idR

-- | Haskell Value Bindings
HsValBinds :: XHsValBinds idL idR -> HsValBindsLR idL idR -> HsLocalBindsLR idL idR

-- | Haskell Implicit Parameter Bindings
HsIPBinds :: XHsIPBinds idL idR -> HsIPBinds idR -> HsLocalBindsLR idL idR

-- | Empty Local Bindings
EmptyLocalBinds :: XEmptyLocalBinds idL idR -> HsLocalBindsLR idL idR
XHsLocalBindsLR :: !XXHsLocalBindsLR idL idR -> HsLocalBindsLR idL idR
type LHsLocalBindsLR idL idR = XRec idL (HsLocalBindsLR idL idR)

-- | Haskell Value Bindings
type HsValBinds id = HsValBindsLR id id

-- | Haskell Value bindings with separate Left and Right identifier types
--   (not implicit parameters) Used for both top level and nested bindings
--   May contain pattern synonym bindings
data HsValBindsLR idL idR

-- | Value Bindings In
--   
--   Before renaming RHS; idR is always RdrName Not dependency analysed
--   Recursive by default
ValBinds :: XValBinds idL idR -> LHsBindsLR idL idR -> [LSig idR] -> HsValBindsLR idL idR

-- | Value Bindings Out
--   
--   After renaming RHS; idR can be Name or Id Dependency analysed, later
--   bindings in the list may depend on earlier ones.
XValBindsLR :: !XXValBindsLR idL idR -> HsValBindsLR idL idR

-- | Located Haskell Binding
type LHsBind id = LHsBindLR id id

-- | Located Haskell Bindings
type LHsBinds id = LHsBindsLR id id

-- | Haskell Binding
type HsBind id = HsBindLR id id

-- | Located Haskell Bindings with separate Left and Right identifier types
type LHsBindsLR idL idR = Bag (LHsBindLR idL idR)

-- | Located Haskell Binding with separate Left and Right identifier types
type LHsBindLR idL idR = XRec idL (HsBindLR idL idR)

-- | Haskell Binding with separate Left and Right id's
data HsBindLR idL idR

-- | Function-like Binding
--   
--   FunBind is used for both functions <tt>f x = e</tt> and variables
--   <tt>f = x -&gt; e</tt> and strict variables <tt>!x = x + 1</tt>
--   
--   Reason 1: Special case for type inference: see <a>tcMonoBinds</a>.
--   
--   Reason 2: Instance decls can only have FunBinds, which is convenient.
--   If you change this, you'll need to change e.g. rnMethodBinds
--   
--   But note that the form <tt>f :: a-&gt;a = ...</tt> parses as a pattern
--   binding, just like <tt>(f :: a -&gt; a) = ... </tt>
--   
--   Strict bindings have their strictness recorded in the
--   <tt>SrcStrictness</tt> of their <tt>MatchContext</tt>. See Note
--   [FunBind vs PatBind] for details about the relationship between
--   FunBind and PatBind.
--   
--   <a>AnnKeywordId</a>s
--   
--   <ul>
--   <li><a>AnnFunId</a>, attached to each element of fun_matches</li>
--   <li><a>AnnEqual</a>,<a>AnnWhere</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a>,</li>
--   </ul>
FunBind :: XFunBind idL idR -> LIdP idL -> MatchGroup idR (LHsExpr idR) -> HsBindLR idL idR
[fun_ext] :: HsBindLR idL idR -> XFunBind idL idR
[fun_id] :: HsBindLR idL idR -> LIdP idL

-- | The payload
[fun_matches] :: HsBindLR idL idR -> MatchGroup idR (LHsExpr idR)

-- | Pattern Binding
--   
--   The pattern is never a simple variable; That case is done by FunBind.
--   See Note [FunBind vs PatBind] for details about the relationship
--   between FunBind and PatBind.
PatBind :: XPatBind idL idR -> LPat idL -> GRHSs idR (LHsExpr idR) -> HsBindLR idL idR
[pat_ext] :: HsBindLR idL idR -> XPatBind idL idR
[pat_lhs] :: HsBindLR idL idR -> LPat idL
[pat_rhs] :: HsBindLR idL idR -> GRHSs idR (LHsExpr idR)

-- | Variable Binding
--   
--   Dictionary binding and suchlike. All VarBinds are introduced by the
--   type checker
VarBind :: XVarBind idL idR -> IdP idL -> LHsExpr idR -> HsBindLR idL idR
[var_ext] :: HsBindLR idL idR -> XVarBind idL idR
[var_id] :: HsBindLR idL idR -> IdP idL

-- | Located only for consistency
[var_rhs] :: HsBindLR idL idR -> LHsExpr idR

-- | Patterns Synonym Binding
PatSynBind :: XPatSynBind idL idR -> PatSynBind idL idR -> HsBindLR idL idR
XHsBindsLR :: !XXHsBindsLR idL idR -> HsBindLR idL idR

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnPattern</a>,
--   <a>AnnEqual</a>,<a>AnnLarrow</a>, <a>AnnWhere</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt>,</li>
--   </ul>
--   
--   Pattern Synonym binding
data PatSynBind idL idR
PSB :: XPSB idL idR -> LIdP idL -> HsPatSynDetails idR -> LPat idR -> HsPatSynDir idR -> PatSynBind idL idR
[psb_ext] :: PatSynBind idL idR -> XPSB idL idR

-- | Name of the pattern synonym
[psb_id] :: PatSynBind idL idR -> LIdP idL

-- | Formal parameter names
[psb_args] :: PatSynBind idL idR -> HsPatSynDetails idR

-- | Right-hand side
[psb_def] :: PatSynBind idL idR -> LPat idR

-- | Directionality
[psb_dir] :: PatSynBind idL idR -> HsPatSynDir idR
XPatSynBind :: !XXPatSynBind idL idR -> PatSynBind idL idR

-- | Haskell Implicit Parameter Bindings
data HsIPBinds id
IPBinds :: XIPBinds id -> [LIPBind id] -> HsIPBinds id
XHsIPBinds :: !XXHsIPBinds id -> HsIPBinds id

-- | Located Implicit Parameter Binding
--   
--   May have <a>AnnKeywordId</a> : <a>AnnSemi</a> when in a list
type LIPBind id = XRec id (IPBind id)

-- | Implicit parameter bindings.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a></li>
--   </ul>
data IPBind id
IPBind :: XCIPBind id -> XRec id HsIPName -> LHsExpr id -> IPBind id
XIPBind :: !XXIPBind id -> IPBind id

-- | Located Signature
type LSig pass = XRec pass (Sig pass)

-- | Signatures and pragmas
data Sig pass

-- | An ordinary type signature
--   
--   <pre>
--   f :: Num a =&gt; a -&gt; a
--   </pre>
--   
--   After renaming, this list of Names contains the named wildcards
--   brought into scope by this signature. For a signature <tt>_ -&gt; _a
--   -&gt; Bool</tt>, the renamer will leave the unnamed wildcard
--   <tt>_</tt> untouched, and the named wildcard <tt>_a</tt> is then
--   replaced with fresh meta vars in the type. Their names are stored in
--   the type signature that brought them into scope, in this third field
--   to be more specific.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a>, <a>AnnComma</a></li>
--   </ul>
TypeSig :: XTypeSig pass -> [LIdP pass] -> LHsSigWcType pass -> Sig pass

-- | A pattern synonym type signature
--   
--   <pre>
--   pattern Single :: () =&gt; (Show a) =&gt; a -&gt; [a]
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnPattern</a>,
--   <a>AnnDcolon</a>,<a>AnnForall</a> <a>AnnDot</a>,<a>AnnDarrow</a></li>
--   </ul>
PatSynSig :: XPatSynSig pass -> [LIdP pass] -> LHsSigType pass -> Sig pass

-- | A signature for a class method False: ordinary class-method signature
--   True: generic-default class method signature e.g. class C a where op
--   :: a -&gt; a -- Ordinary default op :: Eq a =&gt; a -&gt; a -- Generic
--   default No wildcards allowed here
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDefault</a>, <a>AnnDcolon</a></li>
--   </ul>
ClassOpSig :: XClassOpSig pass -> Bool -> [LIdP pass] -> LHsSigType pass -> Sig pass

-- | An ordinary fixity declaration
--   
--   <pre>
--   infixl 8 ***
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnInfix</a>, <a>AnnVal</a></li>
--   </ul>
FixSig :: XFixSig pass -> FixitySig pass -> Sig pass

-- | An inline pragma
--   
--   <pre>
--   {#- INLINE f #-}
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# INLINE'</tt> and
--   <tt>'['</tt>, <a>AnnClose</a>,<a>AnnOpen</a>,
--   <a>AnnVal</a>,<a>AnnTilde</a>, <a>AnnClose</a></li>
--   </ul>
InlineSig :: XInlineSig pass -> LIdP pass -> InlinePragma -> Sig pass

-- | A specialisation pragma
--   
--   <pre>
--   {-# SPECIALISE f :: Int -&gt; Int #-}
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnOpen</a> <tt>'{-#
--   SPECIALISE'</tt> and <tt>'['</tt>, <a>AnnTilde</a>, <a>AnnVal</a>,
--   <a>AnnClose</a> <tt>']'</tt> and <tt>'#-}'</tt>, <a>AnnDcolon</a></li>
--   </ul>
SpecSig :: XSpecSig pass -> LIdP pass -> [LHsSigType pass] -> InlinePragma -> Sig pass

-- | A specialisation pragma for instance declarations only
--   
--   <pre>
--   {-# SPECIALISE instance Eq [Int] #-}
--   </pre>
--   
--   (Class tys); should be a specialisation of the current instance
--   declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnInstance</a>,<a>AnnClose</a></li>
--   </ul>
SpecInstSig :: XSpecInstSig pass -> LHsSigType pass -> Sig pass

-- | A minimal complete definition pragma
--   
--   <pre>
--   {-# MINIMAL a | (b, c | (d | e)) #-}
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnVbar</a>,<a>AnnComma</a>, <a>AnnClose</a></li>
--   </ul>
MinimalSig :: XMinimalSig pass -> LBooleanFormula (LIdP pass) -> Sig pass

-- | A "set cost centre" pragma for declarations
--   
--   <pre>
--   {-# SCC funName #-}
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# SCC funName "cost_centre_name" #-}
--   </pre>
SCCFunSig :: XSCCFunSig pass -> LIdP pass -> Maybe (XRec pass StringLiteral) -> Sig pass

-- | A complete match pragma
--   
--   <pre>
--   {-# COMPLETE C, D [:: T] #-}
--   </pre>
--   
--   Used to inform the pattern match checker about additional complete
--   matchings which, for example, arise from pattern synonym definitions.
CompleteMatchSig :: XCompleteMatchSig pass -> XRec pass [LIdP pass] -> Maybe (LIdP pass) -> Sig pass
XSig :: !XXSig pass -> Sig pass

-- | Located Fixity Signature
type LFixitySig pass = XRec pass (FixitySig pass)

-- | Fixity Signature
data FixitySig pass
FixitySig :: XFixitySig pass -> [LIdP pass] -> Fixity -> FixitySig pass
XFixitySig :: !XXFixitySig pass -> FixitySig pass
isFixityLSig :: forall p. UnXRec p => LSig p -> Bool
isTypeLSig :: forall p. UnXRec p => LSig p -> Bool
isSpecLSig :: forall p. UnXRec p => LSig p -> Bool
isSpecInstLSig :: forall p. UnXRec p => LSig p -> Bool
isPragLSig :: forall p. UnXRec p => LSig p -> Bool
isInlineLSig :: forall p. UnXRec p => LSig p -> Bool
isMinimalLSig :: forall p. UnXRec p => LSig p -> Bool
isSCCFunSig :: forall p. UnXRec p => LSig p -> Bool
isCompleteMatchSig :: forall p. UnXRec p => LSig p -> Bool

-- | Haskell Pattern Synonym Details
type HsPatSynDetails pass = HsConDetails Void (LIdP pass) [RecordPatSynField pass]

-- | Record Pattern Synonym Field
data RecordPatSynField pass
RecordPatSynField :: FieldOcc pass -> LIdP pass -> RecordPatSynField pass

-- | Field label visible in rest of the file
[recordPatSynField] :: RecordPatSynField pass -> FieldOcc pass

-- | Filled in by renamer, the name used internally by the pattern
[recordPatSynPatVar] :: RecordPatSynField pass -> LIdP pass

-- | Haskell Pattern Synonym Direction
data HsPatSynDir id
Unidirectional :: HsPatSynDir id
ImplicitBidirectional :: HsPatSynDir id
ExplicitBidirectional :: MatchGroup id (LHsExpr id) -> HsPatSynDir id


-- | Abstract syntax of global declarations.
--   
--   Definitions for: <tt>SynDecl</tt> and <tt>ConDecl</tt>,
--   <tt>ClassDecl</tt>, <tt>InstDecl</tt>, <tt>DefaultDecl</tt> and
--   <tt>ForeignDecl</tt>.
module Language.Haskell.Syntax.Decls

-- | A Haskell Declaration
data HsDecl p

-- | Type or Class Declaration
TyClD :: XTyClD p -> TyClDecl p -> HsDecl p

-- | Instance declaration
InstD :: XInstD p -> InstDecl p -> HsDecl p

-- | Deriving declaration
DerivD :: XDerivD p -> DerivDecl p -> HsDecl p

-- | Value declaration
ValD :: XValD p -> HsBind p -> HsDecl p

-- | Signature declaration
SigD :: XSigD p -> Sig p -> HsDecl p

-- | Standalone kind signature
KindSigD :: XKindSigD p -> StandaloneKindSig p -> HsDecl p

-- | 'default' declaration
DefD :: XDefD p -> DefaultDecl p -> HsDecl p

-- | Foreign declaration
ForD :: XForD p -> ForeignDecl p -> HsDecl p

-- | Warning declaration
WarningD :: XWarningD p -> WarnDecls p -> HsDecl p

-- | Annotation declaration
AnnD :: XAnnD p -> AnnDecl p -> HsDecl p

-- | Rule declaration
RuleD :: XRuleD p -> RuleDecls p -> HsDecl p

-- | Splice declaration (Includes quasi-quotes)
SpliceD :: XSpliceD p -> SpliceDecl p -> HsDecl p

-- | Documentation comment declaration
DocD :: XDocD p -> DocDecl p -> HsDecl p

-- | Role annotation declaration
RoleAnnotD :: XRoleAnnotD p -> RoleAnnotDecl p -> HsDecl p
XHsDecl :: !XXHsDecl p -> HsDecl p
type LHsDecl p = -- | When in a list this may have -- --  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' -- XRec p (HsDecl p)

-- | Haskell Data type Definition
data HsDataDefn pass

-- | Declares a data type or newtype, giving its constructors <tt>
--   data/newtype T a = <a>constrs</a> data/newtype instance T [a] =
--   <a>constrs</a> </tt>
HsDataDefn :: XCHsDataDefn pass -> Maybe (LHsContext pass) -> Maybe (XRec pass CType) -> Maybe (LHsKind pass) -> DataDefnCons (LConDecl pass) -> HsDeriving pass -> HsDataDefn pass
[dd_ext] :: HsDataDefn pass -> XCHsDataDefn pass

-- | Context
[dd_ctxt] :: HsDataDefn pass -> Maybe (LHsContext pass)
[dd_cType] :: HsDataDefn pass -> Maybe (XRec pass CType)

-- | Optional kind signature.
--   
--   <tt>(Just k)</tt> for a GADT-style <tt>data</tt>, or <tt>data
--   instance</tt> decl, with explicit kind sig
--   
--   Always <tt>Nothing</tt> for H98-syntax decls
[dd_kindSig] :: HsDataDefn pass -> Maybe (LHsKind pass)

-- | Data constructors
--   
--   For <tt>data T a = T1 | T2 a</tt> the <a>LConDecl</a>s all have
--   <a>ConDeclH98</a>. For <tt>data T a where { T1 :: T a }</tt> the
--   <tt>LConDecls</tt> all have <a>ConDeclGADT</a>.
[dd_cons] :: HsDataDefn pass -> DataDefnCons (LConDecl pass)

-- | Optional 'deriving' clause
[dd_derivs] :: HsDataDefn pass -> HsDeriving pass
XHsDataDefn :: !XXHsDataDefn pass -> HsDataDefn pass

-- | Haskell Deriving clause
type HsDeriving pass = -- | The optional @deriving@ clauses of a data declaration. "Clauses" is -- plural because one can specify multiple deriving clauses using the -- @-XDerivingStrategies@ language extension. -- -- The list of 'LHsDerivingClause's corresponds to exactly what the user -- requested to derive, in order. If no deriving clauses were specified, -- the list is empty. [LHsDerivingClause pass]
type LHsFunDep pass = XRec pass (FunDep pass)
data FunDep pass
FunDep :: XCFunDep pass -> [LIdP pass] -> [LIdP pass] -> FunDep pass
XFunDep :: !XXFunDep pass -> FunDep pass

-- | A single <tt>deriving</tt> clause of a data declaration.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDeriving</a>, <a>AnnStock</a>,
--   <a>AnnAnyClass</a>, <a>AnnNewtype</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
data HsDerivingClause pass
HsDerivingClause :: XCHsDerivingClause pass -> Maybe (LDerivStrategy pass) -> LDerivClauseTys pass -> HsDerivingClause pass
[deriv_clause_ext] :: HsDerivingClause pass -> XCHsDerivingClause pass

-- | The user-specified strategy (if any) to use when deriving
--   <a>deriv_clause_tys</a>.
[deriv_clause_strategy] :: HsDerivingClause pass -> Maybe (LDerivStrategy pass)

-- | The types to derive.
[deriv_clause_tys] :: HsDerivingClause pass -> LDerivClauseTys pass
XHsDerivingClause :: !XXHsDerivingClause pass -> HsDerivingClause pass
type LHsDerivingClause pass = XRec pass (HsDerivingClause pass)

-- | The types mentioned in a single <tt>deriving</tt> clause. This can
--   come in two forms, <a>DctSingle</a> or <a>DctMulti</a>, depending on
--   whether the types are surrounded by enclosing parentheses or not.
--   These parentheses are semantically different than <a>HsParTy</a>. For
--   example, <tt>deriving ()</tt> means "derive zero classes" rather than
--   "derive an instance of the 0-tuple".
--   
--   <a>DerivClauseTys</a> use <a>LHsSigType</a> because <tt>deriving</tt>
--   clauses can mention type variables that aren't bound by the datatype,
--   e.g.
--   
--   <pre>
--   data T b = ... deriving (C [a])
--   </pre>
--   
--   should produce a derived instance for <tt>C [a] (T b)</tt>.
data DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a single type. Moreover, that type can
--   only be a type constructor without any arguments.
--   
--   Example: <tt>deriving Eq</tt>
DctSingle :: XDctSingle pass -> LHsSigType pass -> DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a comma-separated list of types,
--   surrounded by enclosing parentheses.
--   
--   Example: <tt>deriving (Eq, C a)</tt>
DctMulti :: XDctMulti pass -> [LHsSigType pass] -> DerivClauseTys pass
XDerivClauseTys :: !XXDerivClauseTys pass -> DerivClauseTys pass
type LDerivClauseTys pass = XRec pass (DerivClauseTys pass)

-- | When we only care whether a data-type declaration is `data` or
--   `newtype`, but not what constructors it has
data NewOrData

-- | <pre>
--   newtype Blah ...
--   </pre>
NewType :: NewOrData

-- | <pre>
--   data Blah ...
--   </pre>
DataType :: NewOrData

-- | Whether a data-type declaration is <tt>data</tt> or <tt>newtype</tt>,
--   and its constructors.
data DataDefnCons a
NewTypeCon :: a -> DataDefnCons a
DataTypeCons :: Bool -> [a] -> DataDefnCons a
dataDefnConsNewOrData :: DataDefnCons a -> NewOrData

-- | Are the constructors within a <tt>type data</tt> declaration? See Note
--   [Type data declarations] in GHC.Rename.Module.
isTypeDataDefnCons :: DataDefnCons a -> Bool
data StandaloneKindSig pass
StandaloneKindSig :: XStandaloneKindSig pass -> LIdP pass -> LHsSigType pass -> StandaloneKindSig pass
XStandaloneKindSig :: !XXStandaloneKindSig pass -> StandaloneKindSig pass

-- | Located Standalone Kind Signature
type LStandaloneKindSig pass = XRec pass (StandaloneKindSig pass)

-- | A type or class declaration.
data TyClDecl pass

-- | <pre>
--   type/data family T :: *-&gt;*
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnData</a>,
--   <a>AnnFamily</a>,<a>AnnDcolon</a>, <a>AnnWhere</a>,<a>AnnOpenP</a>,
--   <a>AnnDcolon</a>,<a>AnnCloseP</a>, <a>AnnEqual</a>,<a>AnnRarrow</a>,
--   <a>AnnVbar</a></li>
--   </ul>
FamDecl :: XFamDecl pass -> FamilyDecl pass -> TyClDecl pass
[tcdFExt] :: TyClDecl pass -> XFamDecl pass
[tcdFam] :: TyClDecl pass -> FamilyDecl pass

-- | <tt>type</tt> declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnEqual</a>,</li>
--   </ul>
SynDecl :: XSynDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LHsType pass -> TyClDecl pass

-- | Post renamer, FVs
[tcdSExt] :: TyClDecl pass -> XSynDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | RHS of type declaration
[tcdRhs] :: TyClDecl pass -> LHsType pass

-- | <tt>data</tt> declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnData</a>, <a>AnnFamily</a>,
--   <a>AnnNewType</a>, <a>AnnNewType</a>,<a>AnnDcolon</a>
--   <a>AnnWhere</a>,</li>
--   </ul>
DataDecl :: XDataDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> HsDataDefn pass -> TyClDecl pass

-- | Post renamer, CUSK flag, FVs
[tcdDExt] :: TyClDecl pass -> XDataDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity
[tcdDataDefn] :: TyClDecl pass -> HsDataDefn pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnClass</a>,
--   <a>AnnWhere</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   <li>The tcdFDs will have <a>AnnVbar</a>, <a>AnnComma</a>
--   <a>AnnRarrow</a> For details on above see Note [exact print
--   annotations] in GHC.Parser.Annotation</li>
--   </ul>
ClassDecl :: XClassDecl pass -> !LayoutInfo pass -> Maybe (LHsContext pass) -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> [LHsFunDep pass] -> [LSig pass] -> LHsBinds pass -> [LFamilyDecl pass] -> [LTyFamDefltDecl pass] -> [LDocDecl pass] -> TyClDecl pass

-- | Post renamer, FVs
[tcdCExt] :: TyClDecl pass -> XClassDecl pass

-- | Explicit or virtual braces See Note [Class LayoutInfo]
[tcdLayout] :: TyClDecl pass -> !LayoutInfo pass

-- | Context...
[tcdCtxt] :: TyClDecl pass -> Maybe (LHsContext pass)

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | Functional deps
[tcdFDs] :: TyClDecl pass -> [LHsFunDep pass]

-- | Methods' signatures
[tcdSigs] :: TyClDecl pass -> [LSig pass]

-- | Default methods
[tcdMeths] :: TyClDecl pass -> LHsBinds pass

-- | Associated types;
[tcdATs] :: TyClDecl pass -> [LFamilyDecl pass]

-- | Associated type defaults
[tcdATDefs] :: TyClDecl pass -> [LTyFamDefltDecl pass]

-- | Haddock docs
[tcdDocs] :: TyClDecl pass -> [LDocDecl pass]
XTyClDecl :: !XXTyClDecl pass -> TyClDecl pass

-- | Located Declaration of a Type or Class
type LTyClDecl pass = XRec pass (TyClDecl pass)

-- | Type or Class Group
data TyClGroup pass
TyClGroup :: XCTyClGroup pass -> [LTyClDecl pass] -> [LRoleAnnotDecl pass] -> [LStandaloneKindSig pass] -> [LInstDecl pass] -> TyClGroup pass
[group_ext] :: TyClGroup pass -> XCTyClGroup pass
[group_tyclds] :: TyClGroup pass -> [LTyClDecl pass]
[group_roles] :: TyClGroup pass -> [LRoleAnnotDecl pass]
[group_kisigs] :: TyClGroup pass -> [LStandaloneKindSig pass]
[group_instds] :: TyClGroup pass -> [LInstDecl pass]
XTyClGroup :: !XXTyClGroup pass -> TyClGroup pass
tyClGroupTyClDecls :: [TyClGroup pass] -> [LTyClDecl pass]
tyClGroupInstDecls :: [TyClGroup pass] -> [LInstDecl pass]
tyClGroupRoleDecls :: [TyClGroup pass] -> [LRoleAnnotDecl pass]
tyClGroupKindSigs :: [TyClGroup pass] -> [LStandaloneKindSig pass]

-- | type class
isClassDecl :: TyClDecl pass -> Bool

-- | <tt>True</tt> <a>=</a> argument is a <tt>data</tt>/<tt>newtype</tt>
--   declaration.
isDataDecl :: TyClDecl pass -> Bool

-- | type or type instance declaration
isSynDecl :: TyClDecl pass -> Bool

-- | type/data family declaration
isFamilyDecl :: TyClDecl pass -> Bool

-- | type family declaration
isTypeFamilyDecl :: TyClDecl pass -> Bool

-- | data family declaration
isDataFamilyDecl :: TyClDecl pass -> Bool

-- | open type family info
isOpenTypeFamilyInfo :: FamilyInfo pass -> Bool

-- | closed type family info
isClosedTypeFamilyInfo :: FamilyInfo pass -> Bool
tyClDeclTyVars :: TyClDecl pass -> LHsQTyVars pass

-- | type Family Declaration
data FamilyDecl pass
FamilyDecl :: XCFamilyDecl pass -> FamilyInfo pass -> TopLevelFlag -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LFamilyResultSig pass -> Maybe (LInjectivityAnn pass) -> FamilyDecl pass
[fdExt] :: FamilyDecl pass -> XCFamilyDecl pass
[fdInfo] :: FamilyDecl pass -> FamilyInfo pass
[fdTopLevel] :: FamilyDecl pass -> TopLevelFlag
[fdLName] :: FamilyDecl pass -> LIdP pass
[fdTyVars] :: FamilyDecl pass -> LHsQTyVars pass
[fdFixity] :: FamilyDecl pass -> LexicalFixity
[fdResultSig] :: FamilyDecl pass -> LFamilyResultSig pass
[fdInjectivityAnn] :: FamilyDecl pass -> Maybe (LInjectivityAnn pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnData</a>,
--   <a>AnnFamily</a>, <a>AnnWhere</a>, <a>AnnOpenP</a>, <a>AnnDcolon</a>,
--   <a>AnnCloseP</a>, <a>AnnEqual</a>, <a>AnnRarrow</a>,
--   <a>AnnVbar</a></li>
--   </ul>
XFamilyDecl :: !XXFamilyDecl pass -> FamilyDecl pass

-- | Located type Family Declaration
type LFamilyDecl pass = XRec pass (FamilyDecl pass)

-- | Instance Declaration
data InstDecl pass
ClsInstD :: XClsInstD pass -> ClsInstDecl pass -> InstDecl pass
[cid_d_ext] :: InstDecl pass -> XClsInstD pass
[cid_inst] :: InstDecl pass -> ClsInstDecl pass
DataFamInstD :: XDataFamInstD pass -> DataFamInstDecl pass -> InstDecl pass
[dfid_ext] :: InstDecl pass -> XDataFamInstD pass
[dfid_inst] :: InstDecl pass -> DataFamInstDecl pass
TyFamInstD :: XTyFamInstD pass -> TyFamInstDecl pass -> InstDecl pass
[tfid_ext] :: InstDecl pass -> XTyFamInstD pass
[tfid_inst] :: InstDecl pass -> TyFamInstDecl pass
XInstDecl :: !XXInstDecl pass -> InstDecl pass

-- | Located Instance Declaration
type LInstDecl pass = XRec pass (InstDecl pass)
data FamilyInfo pass
DataFamily :: FamilyInfo pass
OpenTypeFamily :: FamilyInfo pass

-- | <a>Nothing</a> if we're in an hs-boot file and the user said "type
--   family Foo x where .."
ClosedTypeFamily :: Maybe [LTyFamInstEqn pass] -> FamilyInfo pass

-- | Type Family Instance Declaration
data TyFamInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnInstance</a>,</li>
--   </ul>
TyFamInstDecl :: XCTyFamInstDecl pass -> TyFamInstEqn pass -> TyFamInstDecl pass
[tfid_xtn] :: TyFamInstDecl pass -> XCTyFamInstDecl pass
[tfid_eqn] :: TyFamInstDecl pass -> TyFamInstEqn pass
XTyFamInstDecl :: !XXTyFamInstDecl pass -> TyFamInstDecl pass

-- | Located Type Family Instance Declaration
type LTyFamInstDecl pass = XRec pass (TyFamInstDecl pass)

-- | Type family default declarations. A convenient synonym for
--   <a>TyFamInstDecl</a>. See <tt>Note [Type family instance declarations
--   in HsSyn]</tt>.
type TyFamDefltDecl = TyFamInstDecl

-- | Located type family default declarations.
type LTyFamDefltDecl pass = XRec pass (TyFamDefltDecl pass)

-- | Data Family Instance Declaration
newtype DataFamInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnData</a>,
--   <a>AnnNewType</a>,<a>AnnInstance</a>, <a>AnnDcolon</a>
--   <a>AnnWhere</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
DataFamInstDecl :: FamEqn pass (HsDataDefn pass) -> DataFamInstDecl pass
[dfid_eqn] :: DataFamInstDecl pass -> FamEqn pass (HsDataDefn pass)

-- | Located Data Family Instance Declaration
type LDataFamInstDecl pass = XRec pass (DataFamInstDecl pass)

-- | Family Equation
--   
--   One equation in a type family instance declaration, data family
--   instance declaration, or type family default. See Note [Type family
--   instance declarations in HsSyn] See Note [Family instance declaration
--   binders]
data FamEqn pass rhs
FamEqn :: XCFamEqn pass rhs -> LIdP pass -> HsOuterFamEqnTyVarBndrs pass -> HsTyPats pass -> LexicalFixity -> rhs -> FamEqn pass rhs
[feqn_ext] :: FamEqn pass rhs -> XCFamEqn pass rhs
[feqn_tycon] :: FamEqn pass rhs -> LIdP pass

-- | Optional quantified type vars
[feqn_bndrs] :: FamEqn pass rhs -> HsOuterFamEqnTyVarBndrs pass
[feqn_pats] :: FamEqn pass rhs -> HsTyPats pass

-- | Fixity used in the declaration
[feqn_fixity] :: FamEqn pass rhs -> LexicalFixity

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a></li>
--   </ul>
[feqn_rhs] :: FamEqn pass rhs -> rhs
XFamEqn :: !XXFamEqn pass rhs -> FamEqn pass rhs

-- | Type Family Instance Equation
type TyFamInstEqn pass = FamEqn pass (LHsType pass)

-- | Located Type Family Instance Equation
type LTyFamInstEqn pass = -- | May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' --   when in a list XRec pass (TyFamInstEqn pass)

-- | Haskell Type Patterns
type HsTyPats pass = [LHsTypeArg pass]

-- | Located Class Instance Declaration
type LClsInstDecl pass = XRec pass (ClsInstDecl pass)

-- | Class Instance Declaration - <a>AnnKeywordId</a> : <a>AnnInstance</a>,
--   <a>AnnWhere</a>, <a>AnnOpen</a>,<a>AnnClose</a>, For details on above
--   see Note [exact print annotations] in GHC.Parser.Annotation
data ClsInstDecl pass
ClsInstDecl :: XCClsInstDecl pass -> LHsSigType pass -> LHsBinds pass -> [LSig pass] -> [LTyFamInstDecl pass] -> [LDataFamInstDecl pass] -> Maybe (XRec pass OverlapMode) -> ClsInstDecl pass
[cid_ext] :: ClsInstDecl pass -> XCClsInstDecl pass
[cid_poly_ty] :: ClsInstDecl pass -> LHsSigType pass
[cid_binds] :: ClsInstDecl pass -> LHsBinds pass
[cid_sigs] :: ClsInstDecl pass -> [LSig pass]
[cid_tyfam_insts] :: ClsInstDecl pass -> [LTyFamInstDecl pass]
[cid_datafam_insts] :: ClsInstDecl pass -> [LDataFamInstDecl pass]

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a>,</li>
--   </ul>
[cid_overlap_mode] :: ClsInstDecl pass -> Maybe (XRec pass OverlapMode)
XClsInstDecl :: !XXClsInstDecl pass -> ClsInstDecl pass

-- | Stand-alone 'deriving instance' declaration
data DerivDecl pass
DerivDecl :: XCDerivDecl pass -> LHsSigWcType pass -> Maybe (LDerivStrategy pass) -> Maybe (XRec pass OverlapMode) -> DerivDecl pass
[deriv_ext] :: DerivDecl pass -> XCDerivDecl pass

-- | The instance type to derive.
--   
--   It uses an <a>LHsSigWcType</a> because the context is allowed to be a
--   single wildcard:
--   
--   <pre>
--   deriving instance _ =&gt; Eq (Foo a)
--   </pre>
--   
--   Which signifies that the context should be inferred.
[deriv_type] :: DerivDecl pass -> LHsSigWcType pass
[deriv_strategy] :: DerivDecl pass -> Maybe (LDerivStrategy pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDeriving</a>, <a>AnnInstance</a>,
--   <a>AnnStock</a>, <a>AnnAnyClass</a>, <a>AnnNewtype</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
[deriv_overlap_mode] :: DerivDecl pass -> Maybe (XRec pass OverlapMode)
XDerivDecl :: !XXDerivDecl pass -> DerivDecl pass

-- | Located stand-alone 'deriving instance' declaration
type LDerivDecl pass = XRec pass (DerivDecl pass)

-- | Which technique the user explicitly requested when deriving an
--   instance.
data DerivStrategy pass

-- | GHC's "standard" strategy, which is to implement a custom instance for
--   the data type. This only works for certain types that GHC knows about
--   (e.g., <a>Eq</a>, <a>Show</a>, <a>Functor</a> when
--   <tt>-XDeriveFunctor</tt> is enabled, etc.)
StockStrategy :: XStockStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: XAnyClassStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: XNewtypeStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: XViaStrategy pass -> DerivStrategy pass

-- | A <tt>Located</tt> <a>DerivStrategy</a>.
type LDerivStrategy pass = XRec pass (DerivStrategy pass)

-- | Located Rule Declarations
type LRuleDecls pass = XRec pass (RuleDecls pass)

-- | Rule Declarations
data RuleDecls pass
HsRules :: XCRuleDecls pass -> [LRuleDecl pass] -> RuleDecls pass
[rds_ext] :: RuleDecls pass -> XCRuleDecls pass
[rds_rules] :: RuleDecls pass -> [LRuleDecl pass]
XRuleDecls :: !XXRuleDecls pass -> RuleDecls pass

-- | Rule Declaration
data RuleDecl pass
HsRule :: XHsRule pass -> XRec pass RuleName -> Activation -> Maybe [LHsTyVarBndr () (NoGhcTc pass)] -> [LRuleBndr pass] -> XRec pass (HsExpr pass) -> XRec pass (HsExpr pass) -> RuleDecl pass

-- | After renamer, free-vars from the LHS and RHS
[rd_ext] :: RuleDecl pass -> XHsRule pass

-- | Note [Pragma source text] in <a>GHC.Types.Basic</a>
[rd_name] :: RuleDecl pass -> XRec pass RuleName
[rd_act] :: RuleDecl pass -> Activation

-- | Forall'd type vars
[rd_tyvs] :: RuleDecl pass -> Maybe [LHsTyVarBndr () (NoGhcTc pass)]

-- | Forall'd term vars, before typechecking; after typechecking this
--   includes all forall'd vars
[rd_tmvs] :: RuleDecl pass -> [LRuleBndr pass]
[rd_lhs] :: RuleDecl pass -> XRec pass (HsExpr pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,<a>AnnTilde</a>,
--   <a>AnnVal</a>, <a>AnnClose</a>, <a>AnnForall</a>,<a>AnnDot</a>,
--   <a>AnnEqual</a>,</li>
--   </ul>
[rd_rhs] :: RuleDecl pass -> XRec pass (HsExpr pass)
XRuleDecl :: !XXRuleDecl pass -> RuleDecl pass

-- | Located Rule Declaration
type LRuleDecl pass = XRec pass (RuleDecl pass)

-- | Rule Binder
data RuleBndr pass
RuleBndr :: XCRuleBndr pass -> LIdP pass -> RuleBndr pass
RuleBndrSig :: XRuleBndrSig pass -> LIdP pass -> HsPatSigType pass -> RuleBndr pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnDcolon</a>,<a>AnnClose</a></li>
--   </ul>
XRuleBndr :: !XXRuleBndr pass -> RuleBndr pass

-- | Located Rule Binder
type LRuleBndr pass = XRec pass (RuleBndr pass)
collectRuleBndrSigTys :: [RuleBndr pass] -> [HsPatSigType pass]

-- | Default Declaration
data DefaultDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnDefault</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
DefaultDecl :: XCDefaultDecl pass -> [LHsType pass] -> DefaultDecl pass
XDefaultDecl :: !XXDefaultDecl pass -> DefaultDecl pass

-- | Located Default Declaration
type LDefaultDecl pass = XRec pass (DefaultDecl pass)

-- | A splice can appear with various decorations wrapped around it. This
--   data type captures explicitly how it was originally written, for use
--   in the pretty printer.
data SpliceDecoration

-- | $splice
DollarSplice :: SpliceDecoration

-- | bare splice
BareSplice :: SpliceDecoration

-- | Splice Declaration
data SpliceDecl p
SpliceDecl :: XSpliceDecl p -> XRec p (HsUntypedSplice p) -> SpliceDecoration -> SpliceDecl p
XSpliceDecl :: !XXSpliceDecl p -> SpliceDecl p

-- | Located Splice Declaration
type LSpliceDecl pass = XRec pass (SpliceDecl pass)

-- | Foreign Declaration
data ForeignDecl pass
ForeignImport :: XForeignImport pass -> LIdP pass -> LHsSigType pass -> ForeignImport pass -> ForeignDecl pass
[fd_i_ext] :: ForeignDecl pass -> XForeignImport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fi] :: ForeignDecl pass -> ForeignImport pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnForeign</a>,
--   <a>AnnImport</a>,<a>AnnExport</a>, <a>AnnDcolon</a></li>
--   </ul>
ForeignExport :: XForeignExport pass -> LIdP pass -> LHsSigType pass -> ForeignExport pass -> ForeignDecl pass
[fd_e_ext] :: ForeignDecl pass -> XForeignExport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fe] :: ForeignDecl pass -> ForeignExport pass
XForeignDecl :: !XXForeignDecl pass -> ForeignDecl pass

-- | Located Foreign Declaration
type LForeignDecl pass = XRec pass (ForeignDecl pass)
data ForeignImport pass
CImport :: XCImport pass -> XRec pass CCallConv -> XRec pass Safety -> Maybe Header -> CImportSpec -> ForeignImport pass
XForeignImport :: !XXForeignImport pass -> ForeignImport pass
data ForeignExport pass
CExport :: XCExport pass -> XRec pass CExportSpec -> ForeignExport pass
XForeignExport :: !XXForeignExport pass -> ForeignExport pass
data CImportSpec
CLabel :: CLabelString -> CImportSpec
CFunction :: CCallTarget -> CImportSpec
CWrapper :: CImportSpec

-- | <pre>
--   data T b = forall a. Eq a =&gt; MkT a b
--     MkT :: forall b a. Eq a =&gt; MkT a b
--   
--   data T b where
--        MkT1 :: Int -&gt; T Int
--   
--   data T = Int <tt>MkT</tt> Int
--          | MkT2
--   
--   data T a where
--        Int <tt>MkT</tt> Int :: T Int
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a>,
--   <a>AnnDotdot</a>,<a>AnnCLose</a>, <a>AnnEqual</a>,<a>AnnVbar</a>,
--   <a>AnnDarrow</a>,<a>AnnDarrow</a>, <a>AnnForall</a>,<a>AnnDot</a></li>
--   </ul>
--   
--   data Constructor Declaration
data ConDecl pass
ConDeclGADT :: XConDeclGADT pass -> NonEmpty (LIdP pass) -> !LHsUniToken "::" "∷" pass -> XRec pass (HsOuterSigTyVarBndrs pass) -> Maybe (LHsContext pass) -> HsConDeclGADTDetails pass -> LHsType pass -> Maybe (LHsDoc pass) -> ConDecl pass
[con_g_ext] :: ConDecl pass -> XConDeclGADT pass
[con_names] :: ConDecl pass -> NonEmpty (LIdP pass)
[con_dcolon] :: ConDecl pass -> !LHsUniToken "::" "∷" pass

-- | The outermost type variable binders, be they explicit or implicit. The
--   <a>XRec</a> is used to anchor exact print annotations, AnnForall and
--   AnnDot.
[con_bndrs] :: ConDecl pass -> XRec pass (HsOuterSigTyVarBndrs pass)

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; never infix
[con_g_args] :: ConDecl pass -> HsConDeclGADTDetails pass

-- | Result type
[con_res_ty] :: ConDecl pass -> LHsType pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe (LHsDoc pass)
ConDeclH98 :: XConDeclH98 pass -> LIdP pass -> Bool -> [LHsTyVarBndr Specificity pass] -> Maybe (LHsContext pass) -> HsConDeclH98Details pass -> Maybe (LHsDoc pass) -> ConDecl pass
[con_ext] :: ConDecl pass -> XConDeclH98 pass
[con_name] :: ConDecl pass -> LIdP pass

-- | True <a>=</a> explicit user-written forall e.g. data T a = forall b.
--   MkT b (b-&gt;a) con_ex_tvs = {b} False =&gt; con_ex_tvs is empty
[con_forall] :: ConDecl pass -> Bool

-- | Existentials only
[con_ex_tvs] :: ConDecl pass -> [LHsTyVarBndr Specificity pass]

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; can be infix
[con_args] :: ConDecl pass -> HsConDeclH98Details pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe (LHsDoc pass)
XConDecl :: !XXConDecl pass -> ConDecl pass

-- | Located data Constructor Declaration
type LConDecl pass = -- | May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when --   in a GADT constructor list XRec pass (ConDecl pass)

-- | The arguments in a Haskell98-style data constructor.
type HsConDeclH98Details pass = HsConDetails Void (HsScaled pass (LBangType pass)) (XRec pass [LConDeclField pass])

-- | The arguments in a GADT constructor. Unlike Haskell98-style
--   constructors, GADT constructors cannot be declared with infix syntax.
--   As a result, we do not use <a>HsConDetails</a> here, as
--   <a>InfixCon</a> would be an unrepresentable state. (There is a notion
--   of infix GADT constructors for the purposes of derived Show
--   instances—see Note [Infix GADT constructors] in GHC.Tc.TyCl—but that
--   is an orthogonal concern.)
data HsConDeclGADTDetails pass
PrefixConGADT :: [HsScaled pass (LBangType pass)] -> HsConDeclGADTDetails pass
RecConGADT :: XRec pass [LConDeclField pass] -> LHsUniToken "->" "→" pass -> HsConDeclGADTDetails pass

-- | Documentation comment Declaration
data DocDecl pass
DocCommentNext :: LHsDoc pass -> DocDecl pass
DocCommentPrev :: LHsDoc pass -> DocDecl pass
DocCommentNamed :: String -> LHsDoc pass -> DocDecl pass
DocGroup :: Int -> LHsDoc pass -> DocDecl pass

-- | Located Documentation comment Declaration
type LDocDecl pass = XRec pass (DocDecl pass)
docDeclDoc :: DocDecl pass -> LHsDoc pass

-- | Warning pragma Declaration
data WarnDecl pass
Warning :: XWarning pass -> [LIdP pass] -> WarningTxt pass -> WarnDecl pass
XWarnDecl :: !XXWarnDecl pass -> WarnDecl pass

-- | Located Warning pragma Declaration
type LWarnDecl pass = XRec pass (WarnDecl pass)

-- | Warning pragma Declarations
data WarnDecls pass
Warnings :: XWarnings pass -> [LWarnDecl pass] -> WarnDecls pass
[wd_ext] :: WarnDecls pass -> XWarnings pass
[wd_warnings] :: WarnDecls pass -> [LWarnDecl pass]
XWarnDecls :: !XXWarnDecls pass -> WarnDecls pass

-- | Located Warning Declarations
type LWarnDecls pass = XRec pass (WarnDecls pass)

-- | Annotation Declaration
data AnnDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnType</a>
--   <a>AnnModule</a> <a>AnnClose</a></li>
--   </ul>
HsAnnotation :: XHsAnnotation pass -> AnnProvenance pass -> XRec pass (HsExpr pass) -> AnnDecl pass
XAnnDecl :: !XXAnnDecl pass -> AnnDecl pass

-- | Located Annotation Declaration
type LAnnDecl pass = XRec pass (AnnDecl pass)

-- | Annotation Provenance
data AnnProvenance pass
ValueAnnProvenance :: LIdP pass -> AnnProvenance pass
TypeAnnProvenance :: LIdP pass -> AnnProvenance pass
ModuleAnnProvenance :: AnnProvenance pass
annProvenanceName_maybe :: forall p. UnXRec p => AnnProvenance p -> Maybe (IdP p)

-- | Role Annotation Declaration
data RoleAnnotDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnRole</a></li>
--   </ul>
RoleAnnotDecl :: XCRoleAnnotDecl pass -> LIdP pass -> [XRec pass (Maybe Role)] -> RoleAnnotDecl pass
XRoleAnnotDecl :: !XXRoleAnnotDecl pass -> RoleAnnotDecl pass

-- | Located Role Annotation Declaration
type LRoleAnnotDecl pass = XRec pass (RoleAnnotDecl pass)

-- | type Family Result Signature
data FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> :</li>
--   </ul>
NoSig :: XNoSig pass -> FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a>,<a>AnnDcolon</a>,
--   <a>AnnCloseP</a></li>
--   </ul>
KindSig :: XCKindSig pass -> LHsKind pass -> FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a>,<a>AnnDcolon</a>,
--   <a>AnnCloseP</a>, <a>AnnEqual</a></li>
--   </ul>
TyVarSig :: XTyVarSig pass -> LHsTyVarBndr () pass -> FamilyResultSig pass
XFamilyResultSig :: !XXFamilyResultSig pass -> FamilyResultSig pass

-- | Located type Family Result Signature
type LFamilyResultSig pass = XRec pass (FamilyResultSig pass)

-- | If the user supplied an injectivity annotation it is represented using
--   InjectivityAnn. At the moment this is a single injectivity condition -
--   see Note [Injectivity annotation]. `Located name` stores the LHS of
--   injectivity condition. `[Located name]` stores the RHS of injectivity
--   condition. Example:
--   
--   type family Foo a b c = r | r -&gt; a c where ...
--   
--   This will be represented as "InjectivityAnn <tt>r</tt> [<tt>a</tt>,
--   <tt>c</tt>]"
data InjectivityAnn pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a>, <a>AnnVbar</a></li>
--   </ul>
InjectivityAnn :: XCInjectivityAnn pass -> LIdP pass -> [LIdP pass] -> InjectivityAnn pass
XInjectivityAnn :: !XXInjectivityAnn pass -> InjectivityAnn pass

-- | Located Injectivity Annotation
type LInjectivityAnn pass = XRec pass (InjectivityAnn pass)

-- | Haskell Group
--   
--   A <a>HsDecl</a> is categorised into a <a>HsGroup</a> before being fed
--   to the renamer.
data HsGroup p
HsGroup :: XCHsGroup p -> HsValBinds p -> [LSpliceDecl p] -> [TyClGroup p] -> [LDerivDecl p] -> [LFixitySig p] -> [LDefaultDecl p] -> [LForeignDecl p] -> [LWarnDecls p] -> [LAnnDecl p] -> [LRuleDecls p] -> [LDocDecl p] -> HsGroup p
[hs_ext] :: HsGroup p -> XCHsGroup p
[hs_valds] :: HsGroup p -> HsValBinds p
[hs_splcds] :: HsGroup p -> [LSpliceDecl p]
[hs_tyclds] :: HsGroup p -> [TyClGroup p]
[hs_derivds] :: HsGroup p -> [LDerivDecl p]
[hs_fixds] :: HsGroup p -> [LFixitySig p]
[hs_defds] :: HsGroup p -> [LDefaultDecl p]
[hs_fords] :: HsGroup p -> [LForeignDecl p]
[hs_warnds] :: HsGroup p -> [LWarnDecls p]
[hs_annds] :: HsGroup p -> [LAnnDecl p]
[hs_ruleds] :: HsGroup p -> [LRuleDecls p]
[hs_docs] :: HsGroup p -> [LDocDecl p]
XHsGroup :: !XXHsGroup p -> HsGroup p
hsGroupInstDecls :: HsGroup id -> [LInstDecl id]
instance GHC.Show.Show Language.Haskell.Syntax.Decls.SpliceDecoration
instance GHC.Classes.Eq Language.Haskell.Syntax.Decls.SpliceDecoration
instance Data.Data.Data Language.Haskell.Syntax.Decls.SpliceDecoration
instance Data.Data.Data Language.Haskell.Syntax.Decls.NewOrData
instance GHC.Classes.Eq Language.Haskell.Syntax.Decls.NewOrData
instance Data.Traversable.Traversable Language.Haskell.Syntax.Decls.DataDefnCons
instance GHC.Base.Functor Language.Haskell.Syntax.Decls.DataDefnCons
instance Data.Foldable.Foldable Language.Haskell.Syntax.Decls.DataDefnCons
instance Data.Data.Data a => Data.Data.Data (Language.Haskell.Syntax.Decls.DataDefnCons a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Haskell.Syntax.Decls.DataDefnCons a)
instance Data.Data.Data Language.Haskell.Syntax.Decls.CImportSpec
instance (Data.Data.Data pass, Data.Data.Data (Language.Haskell.Syntax.Extension.IdP pass)) => Data.Data.Data (Language.Haskell.Syntax.Decls.DocDecl pass)


-- | Abstract Haskell syntax for expressions.
module Language.Haskell.Syntax.Expr

-- | RecordDotSyntax field updates
type LFieldLabelStrings p = XRec p (FieldLabelStrings p)
newtype FieldLabelStrings p
FieldLabelStrings :: [XRec p (DotFieldOcc p)] -> FieldLabelStrings p
type RecProj p arg = HsFieldBind (LFieldLabelStrings p) arg
type LHsRecProj p arg = XRec p (RecProj p arg)
type RecUpdProj p = RecProj p (LHsExpr p)
type LHsRecUpdProj p = XRec p (RecUpdProj p)

-- | Located Haskell Expression
type LHsExpr p = -- | May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when --   in a list XRec p (HsExpr p)

-- | Syntax Expression
--   
--   SyntaxExpr is represents the function used in interpreting rebindable
--   syntax. In the parser, we have no information to supply; in the
--   renamer, we have the name of the function (but see Note [Monad fail :
--   Rebindable syntax, overloaded strings] for a wrinkle) and in the
--   type-checker we have a more elaborate structure <tt>SyntaxExprTc</tt>.
--   
--   In some contexts, rebindable syntax is not implemented, and so we have
--   constructors to represent that possibility in both the renamer and
--   typechecker instantiations.
--   
--   E.g. <tt>(&gt;&gt;=)</tt> is filled in before the renamer by the
--   appropriate <tt>Name</tt> for <tt>(&gt;&gt;=)</tt>, and then
--   instantiated by the type checker with its type args etc
type family SyntaxExpr p

-- | A Haskell expression.
data HsExpr p

-- | Variable See Note [Located RdrNames]
HsVar :: XVar p -> LIdP p -> HsExpr p

-- | Unbound variable; also used for "holes" (_ or _x). Turned from HsVar
--   to HsUnboundVar by the renamer, when it finds an out-of-scope variable
--   or hole. The (XUnboundVar p) field becomes an HoleExprRef after
--   typechecking; this is where the erroring expression will be written
--   after solving. See Note [Holes] in GHC.Tc.Types.Constraint.
HsUnboundVar :: XUnboundVar p -> RdrName -> HsExpr p

-- | Variable pointing to record selector See Note [Non-overloaded record
--   field selectors] and Note [Record selectors in the AST]
HsRecSel :: XRecSel p -> FieldOcc p -> HsExpr p

-- | Overloaded label (Note [Overloaded labels] in GHC.OverloadedLabels)
--   Note [Pragma source text] in GHC.Types.SourceText
HsOverLabel :: XOverLabel p -> SourceText -> FastString -> HsExpr p

-- | Implicit parameter (not in use after typechecking)
HsIPVar :: XIPVar p -> HsIPName -> HsExpr p

-- | Overloaded literals
HsOverLit :: XOverLitE p -> HsOverLit p -> HsExpr p

-- | Simple (non-overloaded) literals
HsLit :: XLitE p -> HsLit p -> HsExpr p

-- | Lambda abstraction. Currently always a single match
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>, <a>AnnRarrow</a>,</li>
--   </ul>
HsLam :: XLam p -> MatchGroup p (LHsExpr p) -> HsExpr p

-- | Lambda-case
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>,
--   <a>AnnCase</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>,
--   <a>AnnCases</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
HsLamCase :: XLamCase p -> LamCaseVariant -> MatchGroup p (LHsExpr p) -> HsExpr p

-- | Application
HsApp :: XApp p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Visible type application
--   
--   Explicit type argument; e.g f @Int x y NB: Has wildcards, but no
--   implicit quantification
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnAt</a>,</li>
--   </ul>
HsAppType :: XAppTypeE p -> LHsExpr p -> !LHsToken "@" p -> LHsWcType (NoGhcTc p) -> HsExpr p

-- | Operator applications: NB Bracketed ops such as (+) come out as Vars.
OpApp :: XOpApp p -> LHsExpr p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Negation operator. Contains the negated expression and the name of
--   <tt>negate</tt>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnMinus</a></li>
--   </ul>
NegApp :: XNegApp p -> LHsExpr p -> SyntaxExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
HsPar :: XPar p -> !LHsToken "(" p -> LHsExpr p -> !LHsToken ")" p -> HsExpr p
SectionL :: XSectionL p -> LHsExpr p -> LHsExpr p -> HsExpr p
SectionR :: XSectionR p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Used for explicit tuples and sections thereof
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
ExplicitTuple :: XExplicitTuple p -> [HsTupArg p] -> Boxity -> HsExpr p

-- | Used for unboxed sum types
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnVbar</a>, <a>AnnClose</a> <tt>'#)'</tt>,</li>
--   </ul>
--   
--   There will be multiple <a>AnnVbar</a>, (1 - alternative) before the
--   expression, (arity - alternative) after it
ExplicitSum :: XExplicitSum p -> ConTag -> SumWidth -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnCase</a>, <a>AnnOf</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
HsCase :: XCase p -> LHsExpr p -> MatchGroup p (LHsExpr p) -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnIf</a>, <a>AnnSemi</a>,
--   <a>AnnThen</a>,<a>AnnSemi</a>, <a>AnnElse</a>,</li>
--   </ul>
HsIf :: XIf p -> LHsExpr p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Multi-way if
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnIf</a>
--   <a>AnnOpen</a>,<a>AnnClose</a>,</li>
--   </ul>
HsMultiIf :: XMultiIf p -> [LGRHS p (LHsExpr p)] -> HsExpr p

-- | let(rec)
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLet</a>, <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnClose</a> <tt>'}'</tt>,<a>AnnIn</a></li>
--   </ul>
HsLet :: XLet p -> !LHsToken "let" p -> HsLocalBinds p -> !LHsToken "in" p -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDo</a>, <a>AnnOpen</a>,
--   <a>AnnSemi</a>, <a>AnnVbar</a>, <a>AnnClose</a></li>
--   </ul>
HsDo :: XDo p -> HsDoFlavour -> XRec p [ExprLStmt p] -> HsExpr p

-- | Syntactic list: [a,b,c,...]
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
ExplicitList :: XExplicitList p -> [LHsExpr p] -> HsExpr p

-- | Record construction
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnDotdot</a>,<a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
RecordCon :: XRecordCon p -> XRec p (ConLikeP p) -> HsRecordBinds p -> HsExpr p
[rcon_ext] :: HsExpr p -> XRecordCon p
[rcon_con] :: HsExpr p -> XRec p (ConLikeP p)
[rcon_flds] :: HsExpr p -> HsRecordBinds p

-- | Record update
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnDotdot</a>,<a>AnnClose</a> <tt>'}'</tt>
--   'GHC.Parser.Annotation.AnnComma, <a>AnnDot</a>, <a>AnnClose</a>
--   <tt>'}'</tt></li>
--   </ul>
RecordUpd :: XRecordUpd p -> LHsExpr p -> Either [LHsRecUpdField p] [LHsRecUpdProj p] -> HsExpr p
[rupd_ext] :: HsExpr p -> XRecordUpd p
[rupd_expr] :: HsExpr p -> LHsExpr p
[rupd_flds] :: HsExpr p -> Either [LHsRecUpdField p] [LHsRecUpdProj p]

-- | Record field selection e.g <tt>z.x</tt>.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDot</a></li>
--   </ul>
HsGetField :: XGetField p -> LHsExpr p -> XRec p (DotFieldOcc p) -> HsExpr p
[gf_ext] :: HsExpr p -> XGetField p
[gf_expr] :: HsExpr p -> LHsExpr p
[gf_field] :: HsExpr p -> XRec p (DotFieldOcc p)

-- | Record field selector. e.g. <tt>(.x)</tt> or <tt>(.x.y)</tt>
--   
--   This case only arises when the OverloadedRecordDot langauge extensions
--   is enabled. See Note [Record selectors in the AST].
HsProjection :: XProjection p -> NonEmpty (XRec p (DotFieldOcc p)) -> HsExpr p
[proj_ext] :: HsExpr p -> XProjection p
[proj_flds] :: HsExpr p -> NonEmpty (XRec p (DotFieldOcc p))

-- | Expression with an explicit type signature. <tt>e :: type</tt>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
ExprWithTySig :: XExprWithTySig p -> LHsExpr p -> LHsSigWcType (NoGhcTc p) -> HsExpr p

-- | Arithmetic sequence
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>,
--   <a>AnnComma</a>,<a>AnnDotdot</a>, <a>AnnClose</a> <tt>']'</tt></li>
--   </ul>
ArithSeq :: XArithSeq p -> Maybe (SyntaxExpr p) -> ArithSeqInfo p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnOpenE</a>,<a>AnnOpenEQ</a>,
--   <a>AnnClose</a>,<a>AnnCloseQ</a></li>
--   </ul>
HsTypedBracket :: XTypedBracket p -> LHsExpr p -> HsExpr p
HsUntypedBracket :: XUntypedBracket p -> HsQuote p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
HsTypedSplice :: XTypedSplice p -> LHsExpr p -> HsExpr p
HsUntypedSplice :: XUntypedSplice p -> HsUntypedSplice p -> HsExpr p

-- | <tt>proc</tt> notation for Arrows
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnProc</a>, <a>AnnRarrow</a></li>
--   </ul>
HsProc :: XProc p -> LPat p -> LHsCmdTop p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnStatic</a>,</li>
--   </ul>
HsStatic :: XStatic p -> LHsExpr p -> HsExpr p
HsPragE :: XPragE p -> HsPragE p -> LHsExpr p -> HsExpr p
XExpr :: !XXExpr p -> HsExpr p
data DotFieldOcc p
DotFieldOcc :: XCDotFieldOcc p -> XRec p FieldLabelString -> DotFieldOcc p
[dfoExt] :: DotFieldOcc p -> XCDotFieldOcc p
[dfoLabel] :: DotFieldOcc p -> XRec p FieldLabelString
XDotFieldOcc :: !XXDotFieldOcc p -> DotFieldOcc p

-- | A pragma, written as {-# ... #-}, that may appear within an
--   expression.
data HsPragE p
HsPragSCC :: XSCC p -> StringLiteral -> HsPragE p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnOpen</a> <tt>'{-#
--   GENERATED'</tt>, <a>AnnVal</a>,<a>AnnVal</a>,
--   <a>AnnColon</a>,<a>AnnVal</a>, <a>AnnMinus</a>,
--   <a>AnnVal</a>,<a>AnnColon</a>, <a>AnnVal</a>, <a>AnnClose</a>
--   <tt>'#-}'</tt></li>
--   </ul>
XHsPragE :: !XXPragE p -> HsPragE p

-- | Located Haskell Tuple Argument
--   
--   <a>HsTupArg</a> is used for tuple sections <tt>(,a,)</tt> is
--   represented by <tt>ExplicitTuple [Missing ty1, Present a, Missing
--   ty3]</tt> Which in turn stands for <tt>(x:ty1 y:ty2. (x,a,y))</tt>
type LHsTupArg id = XRec id (HsTupArg id)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnComma</a></li>
--   </ul>
--   
--   Haskell Tuple Argument
data HsTupArg id

-- | The argument
Present :: XPresent id -> LHsExpr id -> HsTupArg id

-- | The argument is missing, but this is its type
Missing :: XMissing id -> HsTupArg id

-- | Extension point; see Note [Trees That Grow] in
--   Language.Haskell.Syntax.Extension
XTupArg :: !XXTupArg id -> HsTupArg id

-- | Which kind of lambda case are we dealing with?
data LamCaseVariant

-- | `case`
LamCase :: LamCaseVariant

-- | `cases`
LamCases :: LamCaseVariant

-- | Located Haskell Command (for arrow syntax)
type LHsCmd id = XRec id (HsCmd id)

-- | Haskell Command (e.g. a "statement" in an Arrow proc block)
data HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>Annlarrowtail</a>,
--   <a>Annrarrowtail</a>,<a>AnnLarrowtail</a>, <a>AnnRarrowtail</a></li>
--   </ul>
HsCmdArrApp :: XCmdArrApp id -> LHsExpr id -> LHsExpr id -> HsArrAppType -> Bool -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenB</a> <tt>'(|'</tt>,
--   <a>AnnCloseB</a> <tt>'|)'</tt></li>
--   </ul>
HsCmdArrForm :: XCmdArrForm id -> LHsExpr id -> LexicalFixity -> Maybe Fixity -> [LHsCmdTop id] -> HsCmd id
HsCmdApp :: XCmdApp id -> LHsCmd id -> LHsExpr id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>, <a>AnnRarrow</a>,</li>
--   </ul>
HsCmdLam :: XCmdLam id -> MatchGroup id (LHsCmd id) -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
HsCmdPar :: XCmdPar id -> !LHsToken "(" id -> LHsCmd id -> !LHsToken ")" id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnCase</a>, <a>AnnOf</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
HsCmdCase :: XCmdCase id -> LHsExpr id -> MatchGroup id (LHsCmd id) -> HsCmd id

-- | Lambda-case
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>, <a>AnnCase</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt></li>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>,
--   <a>AnnCases</a>,<a>AnnOpen</a> <tt>'{'</tt>, <a>AnnClose</a>
--   <tt>'}'</tt></li>
--   </ul>
HsCmdLamCase :: XCmdLamCase id -> LamCaseVariant -> MatchGroup id (LHsCmd id) -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnIf</a>, <a>AnnSemi</a>,
--   <a>AnnThen</a>,<a>AnnSemi</a>, <a>AnnElse</a>,</li>
--   </ul>
HsCmdIf :: XCmdIf id -> SyntaxExpr id -> LHsExpr id -> LHsCmd id -> LHsCmd id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLet</a>, <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnClose</a> <tt>'}'</tt>,<a>AnnIn</a></li>
--   </ul>
HsCmdLet :: XCmdLet id -> !LHsToken "let" id -> HsLocalBinds id -> !LHsToken "in" id -> LHsCmd id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDo</a>, <a>AnnOpen</a>,
--   <a>AnnSemi</a>, <a>AnnVbar</a>, <a>AnnClose</a></li>
--   </ul>
HsCmdDo :: XCmdDo id -> XRec id [CmdLStmt id] -> HsCmd id
XCmd :: !XXCmd id -> HsCmd id

-- | Haskell arrow application type.
data HsArrAppType

-- | First order arrow application <tt>-&lt;</tt>
HsHigherOrderApp :: HsArrAppType

-- | Higher order arrow application <tt>-&lt;&lt;</tt>
HsFirstOrderApp :: HsArrAppType

-- | Top-level command, introducing a new arrow. This may occur inside a
--   proc (where the stack is empty) or as an argument of a command-forming
--   operator.
--   
--   Located Haskell Top-level Command
type LHsCmdTop p = XRec p (HsCmdTop p)

-- | Haskell Top-level Command
data HsCmdTop p
HsCmdTop :: XCmdTop p -> LHsCmd p -> HsCmdTop p
XCmdTop :: !XXCmdTop p -> HsCmdTop p

-- | Haskell Record Bindings
type HsRecordBinds p = HsRecFields p (LHsExpr p)
data MatchGroup p body
MG :: XMG p body -> XRec p [LMatch p body] -> MatchGroup p body
[mg_ext] :: MatchGroup p body -> XMG p body
[mg_alts] :: MatchGroup p body -> XRec p [LMatch p body]
XMatchGroup :: !XXMatchGroup p body -> MatchGroup p body

-- | Located Match
--   
--   May have <a>AnnKeywordId</a> : <a>AnnSemi</a> when in a list
type LMatch id body = XRec id (Match id body)
data Match p body
Match :: XCMatch p body -> HsMatchContext p -> [LPat p] -> GRHSs p body -> Match p body
[m_ext] :: Match p body -> XCMatch p body
[m_ctxt] :: Match p body -> HsMatchContext p
[m_pats] :: Match p body -> [LPat p]
[m_grhss] :: Match p body -> GRHSs p body
XMatch :: !XXMatch p body -> Match p body
isInfixMatch :: Match id body -> Bool

-- | Guarded Right-Hand Sides
--   
--   GRHSs are used both for pattern bindings and for Matches
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnVbar</a>,
--   <a>AnnEqual</a>,<a>AnnWhere</a>, <a>AnnOpen</a>,<a>AnnClose</a>
--   <a>AnnRarrow</a>,<a>AnnSemi</a></li>
--   </ul>
data GRHSs p body
GRHSs :: XCGRHSs p body -> [LGRHS p body] -> HsLocalBinds p -> GRHSs p body
[grhssExt] :: GRHSs p body -> XCGRHSs p body

-- | Guarded RHSs
[grhssGRHSs] :: GRHSs p body -> [LGRHS p body]

-- | The where clause
[grhssLocalBinds] :: GRHSs p body -> HsLocalBinds p
XGRHSs :: !XXGRHSs p body -> GRHSs p body

-- | Located Guarded Right-Hand Side
type LGRHS id body = XRec id (GRHS id body)

-- | Guarded Right Hand Side.
data GRHS p body
GRHS :: XCGRHS p body -> [GuardLStmt p] -> body -> GRHS p body
XGRHS :: !XXGRHS p body -> GRHS p body

-- | Located <tt>do</tt> block Statement
type LStmt id body = XRec id (StmtLR id id body)

-- | Located Statement with separate Left and Right id's
type LStmtLR idL idR body = XRec idL (StmtLR idL idR body)

-- | <tt>do</tt> block Statement
type Stmt id body = StmtLR id id body

-- | Command Located Statement
type CmdLStmt id = LStmt id (LHsCmd id)

-- | Command Statement
type CmdStmt id = Stmt id (LHsCmd id)

-- | Expression Located Statement
type ExprLStmt id = LStmt id (LHsExpr id)

-- | Expression Statement
type ExprStmt id = Stmt id (LHsExpr id)

-- | Guard Located Statement
type GuardLStmt id = LStmt id (LHsExpr id)

-- | Guard Statement
type GuardStmt id = Stmt id (LHsExpr id)

-- | Ghci Located Statement
type GhciLStmt id = LStmt id (LHsExpr id)

-- | Ghci Statement
type GhciStmt id = Stmt id (LHsExpr id)

-- | Exact print annotations when in qualifier lists or guards -
--   <a>AnnKeywordId</a> : <a>AnnVbar</a>, <a>AnnComma</a>,<a>AnnThen</a>,
--   <a>AnnBy</a>,<a>AnnBy</a>, <a>AnnGroup</a>,<a>AnnUsing</a>
data StmtLR idL idR body
LastStmt :: XLastStmt idL idR body -> body -> Maybe Bool -> SyntaxExpr idR -> StmtLR idL idR body
BindStmt :: XBindStmt idL idR body -> LPat idL -> body -> StmtLR idL idR body

-- | <a>ApplicativeStmt</a> represents an applicative expression built with
--   <tt>&lt;$&gt;</tt> and <tt>&lt;*&gt;</tt>. It is generated by the
--   renamer, and is desugared into the appropriate applicative expression
--   by the desugarer, but it is intended to be invisible in error
--   messages.
--   
--   For full details, see Note [ApplicativeDo] in <a>GHC.Rename.Expr</a>
ApplicativeStmt :: XApplicativeStmt idL idR body -> [(SyntaxExpr idR, ApplicativeArg idL)] -> Maybe (SyntaxExpr idR) -> StmtLR idL idR body
BodyStmt :: XBodyStmt idL idR body -> body -> SyntaxExpr idR -> SyntaxExpr idR -> StmtLR idL idR body

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLet</a> <a>AnnOpen</a>
--   <tt>'{'</tt>,<a>AnnClose</a> <tt>'}'</tt>,</li>
--   </ul>
LetStmt :: XLetStmt idL idR body -> HsLocalBindsLR idL idR -> StmtLR idL idR body
ParStmt :: XParStmt idL idR body -> [ParStmtBlock idL idR] -> HsExpr idR -> SyntaxExpr idR -> StmtLR idL idR body
TransStmt :: XTransStmt idL idR body -> TransForm -> [ExprLStmt idL] -> [(IdP idR, IdP idR)] -> LHsExpr idR -> Maybe (LHsExpr idR) -> SyntaxExpr idR -> SyntaxExpr idR -> HsExpr idR -> StmtLR idL idR body
[trS_ext] :: StmtLR idL idR body -> XTransStmt idL idR body
[trS_form] :: StmtLR idL idR body -> TransForm
[trS_stmts] :: StmtLR idL idR body -> [ExprLStmt idL]
[trS_bndrs] :: StmtLR idL idR body -> [(IdP idR, IdP idR)]
[trS_using] :: StmtLR idL idR body -> LHsExpr idR
[trS_by] :: StmtLR idL idR body -> Maybe (LHsExpr idR)
[trS_ret] :: StmtLR idL idR body -> SyntaxExpr idR
[trS_bind] :: StmtLR idL idR body -> SyntaxExpr idR
[trS_fmap] :: StmtLR idL idR body -> HsExpr idR

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRec</a></li>
--   </ul>
RecStmt :: XRecStmt idL idR body -> XRec idR [LStmtLR idL idR body] -> [IdP idR] -> [IdP idR] -> SyntaxExpr idR -> SyntaxExpr idR -> SyntaxExpr idR -> StmtLR idL idR body
[recS_ext] :: StmtLR idL idR body -> XRecStmt idL idR body
[recS_stmts] :: StmtLR idL idR body -> XRec idR [LStmtLR idL idR body]
[recS_later_ids] :: StmtLR idL idR body -> [IdP idR]
[recS_rec_ids] :: StmtLR idL idR body -> [IdP idR]
[recS_bind_fn] :: StmtLR idL idR body -> SyntaxExpr idR
[recS_ret_fn] :: StmtLR idL idR body -> SyntaxExpr idR
[recS_mfix_fn] :: StmtLR idL idR body -> SyntaxExpr idR
XStmtLR :: !XXStmtLR idL idR body -> StmtLR idL idR body
data TransForm
ThenForm :: TransForm
GroupForm :: TransForm

-- | Parenthesised Statement Block
data ParStmtBlock idL idR
ParStmtBlock :: XParStmtBlock idL idR -> [ExprLStmt idL] -> [IdP idR] -> SyntaxExpr idR -> ParStmtBlock idL idR
XParStmtBlock :: !XXParStmtBlock idL idR -> ParStmtBlock idL idR

-- | The fail operator
--   
--   This is used for `.. &lt;-` "bind statements" in do notation,
--   including non-monadic "binds" in applicative.
--   
--   The fail operator is 'Just expr' if it potentially fail monadically.
--   if the pattern match cannot fail, or shouldn't fail monadically
--   (regular incomplete pattern exception), it is <a>Nothing</a>.
--   
--   See Note [Monad fail : Rebindable syntax, overloaded strings] for the
--   type of expression in the <a>Just</a> case, and why it is so.
--   
--   See Note [Failing pattern matches in Stmts] for which contexts for
--   '<tt>BindStmt</tt>'s should use the monadic fail and which shouldn't.
type FailOperator id = Maybe (SyntaxExpr id)

-- | Applicative Argument
data ApplicativeArg idL
ApplicativeArgOne :: XApplicativeArgOne idL -> LPat idL -> LHsExpr idL -> Bool -> ApplicativeArg idL

-- | The fail operator, after renaming
--   
--   The fail operator is needed if this is a BindStmt where the pattern
--   can fail. E.g.: (Just a) &lt;- stmt The fail operator will be invoked
--   if the pattern match fails. It is also used for guards in
--   MonadComprehensions. The fail operator is Nothing if the pattern match
--   can't fail
[xarg_app_arg_one] :: ApplicativeArg idL -> XApplicativeArgOne idL
[app_arg_pattern] :: ApplicativeArg idL -> LPat idL
[arg_expr] :: ApplicativeArg idL -> LHsExpr idL

-- | True <a>=</a> was a BodyStmt, False <a>=</a> was a BindStmt. See Note
--   [Applicative BodyStmt]
[is_body_stmt] :: ApplicativeArg idL -> Bool
ApplicativeArgMany :: XApplicativeArgMany idL -> [ExprLStmt idL] -> HsExpr idL -> LPat idL -> HsDoFlavour -> ApplicativeArg idL
[xarg_app_arg_many] :: ApplicativeArg idL -> XApplicativeArgMany idL
[app_stmts] :: ApplicativeArg idL -> [ExprLStmt idL]
[final_expr] :: ApplicativeArg idL -> HsExpr idL
[bv_pattern] :: ApplicativeArg idL -> LPat idL

-- | context of the do expression, used in pprArg
[stmt_context] :: ApplicativeArg idL -> HsDoFlavour
XApplicativeArg :: !XXApplicativeArg idL -> ApplicativeArg idL

-- | Haskell Splice
data HsUntypedSplice id
HsUntypedSpliceExpr :: XUntypedSpliceExpr id -> LHsExpr id -> HsUntypedSplice id
HsQuasiQuote :: XQuasiQuote id -> IdP id -> XRec id FastString -> HsUntypedSplice id
XUntypedSplice :: !XXUntypedSplice id -> HsUntypedSplice id

-- | Haskell (Untyped) Quote = Expr + Pat + Type + Var
data HsQuote p
ExpBr :: XExpBr p -> LHsExpr p -> HsQuote p
PatBr :: XPatBr p -> LPat p -> HsQuote p
DecBrL :: XDecBrL p -> [LHsDecl p] -> HsQuote p
DecBrG :: XDecBrG p -> HsGroup p -> HsQuote p
TypBr :: XTypBr p -> LHsType p -> HsQuote p
VarBr :: XVarBr p -> Bool -> LIdP p -> HsQuote p
XQuote :: !XXQuote p -> HsQuote p

-- | Arithmetic Sequence Information
data ArithSeqInfo id
From :: LHsExpr id -> ArithSeqInfo id
FromThen :: LHsExpr id -> LHsExpr id -> ArithSeqInfo id
FromTo :: LHsExpr id -> LHsExpr id -> ArithSeqInfo id
FromThenTo :: LHsExpr id -> LHsExpr id -> LHsExpr id -> ArithSeqInfo id

-- | Haskell Match Context
--   
--   Context of a pattern match. This is more subtle than it would seem.
--   See Note [FunBind vs PatBind].
data HsMatchContext p

-- | A pattern matching on an argument of a function binding
FunRhs :: LIdP (NoGhcTc p) -> LexicalFixity -> SrcStrictness -> HsMatchContext p

-- | function binder of <tt>f</tt> See Note [mc_fun field of FunRhs] See
--   #20415 for a long discussion about this field and why it uses NoGhcTc.
[mc_fun] :: HsMatchContext p -> LIdP (NoGhcTc p)

-- | fixing of <tt>f</tt>
[mc_fixity] :: HsMatchContext p -> LexicalFixity

-- | was <tt>f</tt> banged? See Note [FunBind vs PatBind]
[mc_strictness] :: HsMatchContext p -> SrcStrictness

-- | Patterns of a lambda
LambdaExpr :: HsMatchContext p

-- | Patterns and guards in a case alternative
CaseAlt :: HsMatchContext p

-- | Patterns and guards in <tt>case</tt> and <tt>cases</tt>
LamCaseAlt :: LamCaseVariant -> HsMatchContext p

-- | Guards of a multi-way if alternative
IfAlt :: HsMatchContext p

-- | A pattern match inside arrow notation
ArrowMatchCtxt :: HsArrowMatchContext -> HsMatchContext p

-- | A pattern binding eg [y] &lt;- e = e
PatBindRhs :: HsMatchContext p

-- | Guards of pattern bindings, e.g., (Just b) | Just _ &lt;- x = e |
--   otherwise = e'
PatBindGuards :: HsMatchContext p

-- | Record update [used only in GHC.HsToCore.Expr to tell matchWrapper
--   what sort of runtime error message to generate]
RecUpd :: HsMatchContext p

-- | Pattern of a do-stmt, list comprehension, pattern guard, etc
StmtCtxt :: HsStmtContext p -> HsMatchContext p

-- | A Template Haskell pattern splice
ThPatSplice :: HsMatchContext p

-- | A Template Haskell pattern quotation [p| (a,b) |]
ThPatQuote :: HsMatchContext p

-- | A pattern synonym declaration
PatSyn :: HsMatchContext p
isPatSynCtxt :: HsMatchContext p -> Bool

-- | Haskell Statement Context.
data HsStmtContext p

-- | Context for HsDo (do-notation and comprehensions)
HsDoStmt :: HsDoFlavour -> HsStmtContext p

-- | Pattern guard for specified thing
PatGuard :: HsMatchContext p -> HsStmtContext p

-- | A branch of a parallel stmt
ParStmtCtxt :: HsStmtContext p -> HsStmtContext p

-- | A branch of a transform stmt
TransStmtCtxt :: HsStmtContext p -> HsStmtContext p

-- | do-notation in an arrow-command context
ArrowExpr :: HsStmtContext p

-- | Haskell arrow match context.
data HsArrowMatchContext

-- | A proc expression
ProcExpr :: HsArrowMatchContext

-- | A case alternative inside arrow notation
ArrowCaseAlt :: HsArrowMatchContext

-- | A case or cases alternative inside arrow notation
ArrowLamCaseAlt :: LamCaseVariant -> HsArrowMatchContext

-- | An arrow kappa abstraction
KappaExpr :: HsArrowMatchContext
data HsDoFlavour

-- | <ul>
--   <li><i>ModuleName.</i> do { ... }</li>
--   </ul>
DoExpr :: Maybe ModuleName -> HsDoFlavour

-- | <ul>
--   <li><i>ModuleName.</i> mdo { ... } ie recursive do-expression</li>
--   </ul>
MDoExpr :: Maybe ModuleName -> HsDoFlavour

-- | A command-line Stmt in GHCi pat &lt;- rhs
GhciStmtCtxt :: HsDoFlavour
ListComp :: HsDoFlavour
MonadComp :: HsDoFlavour
qualifiedDoModuleName_maybe :: HsStmtContext p -> Maybe ModuleName
isComprehensionContext :: HsStmtContext id -> Bool
isDoComprehensionContext :: HsDoFlavour -> Bool

-- | Is this a monadic context?
isMonadStmtContext :: HsStmtContext id -> Bool
isMonadDoStmtContext :: HsDoFlavour -> Bool
isMonadCompContext :: HsStmtContext id -> Bool
isMonadDoCompContext :: HsDoFlavour -> Bool
instance GHC.Classes.Eq Language.Haskell.Syntax.Expr.LamCaseVariant
instance Data.Data.Data Language.Haskell.Syntax.Expr.LamCaseVariant
instance Data.Data.Data Language.Haskell.Syntax.Expr.HsArrAppType
instance Data.Data.Data Language.Haskell.Syntax.Expr.TransForm

module Language.Haskell.Syntax

-- | A ModuleName is essentially a simple string, e.g. <tt>Data.List</tt>.
newtype ModuleName
ModuleName :: FastString -> ModuleName

-- | Haskell Module
--   
--   All we actually declare here is the top-level structure for a module.
data HsModule p

-- | <a>AnnKeywordId</a>s
--   
--   <ul>
--   <li><a>AnnModule</a>,<a>AnnWhere</a></li>
--   <li><a>AnnOpen</a>,<a>AnnSemi</a>, <a>AnnClose</a> for explicit braces
--   and semi around hsmodImports,hsmodDecls if this style is used.</li>
--   </ul>
HsModule :: XCModule p -> Maybe (XRec p ModuleName) -> Maybe (XRec p [LIE p]) -> [LImportDecl p] -> [LHsDecl p] -> HsModule p

-- | HsModule extension point
[hsmodExt] :: HsModule p -> XCModule p

-- | <tt>Nothing</tt>: "module X where" is omitted (in which case the next
--   field is Nothing too)
[hsmodName] :: HsModule p -> Maybe (XRec p ModuleName)

-- | Export list
--   
--   <ul>
--   <li><tt>Nothing</tt>: export list omitted, so export everything</li>
--   <li><tt>Just []</tt>: export <i>nothing</i></li>
--   <li><tt>Just [...]</tt>: as you would expect...</li>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a> ,<a>AnnClose</a></li>
--   </ul>
[hsmodExports] :: HsModule p -> Maybe (XRec p [LIE p])
[hsmodImports] :: HsModule p -> [LImportDecl p]

-- | Type, class, value, and interface signature decls
[hsmodDecls] :: HsModule p -> [LHsDecl p]
XModule :: !XXModule p -> HsModule p

module GHC.Types.RepType
type UnaryType = Type
type NvUnaryType = Type
isNvUnaryType :: Type -> Bool

-- | Gets rid of the stuff that prevents us from understanding the runtime
--   representation of a type. Including: 1. Casts 2. Newtypes 3. Foralls
--   4. Synonyms But not type/data families, because we don't have the envs
--   to hand.
unwrapType :: Type -> Type

-- | True if the type has zero width.
isZeroBitTy :: HasDebugCallStack => Type -> Bool

-- | Discovers the primitive representation of a <a>Type</a>. Returns a
--   list of <a>PrimRep</a>: it's a list because of the possibility of no
--   runtime representation (void) or multiple (unboxed tuple/sum) See also
--   Note [Getting from RuntimeRep to PrimRep]
typePrimRep :: HasDebugCallStack => Type -> [PrimRep]

-- | Like <a>typePrimRep</a>, but assumes that there is precisely one
--   <a>PrimRep</a> output; an empty list of PrimReps becomes a VoidRep.
--   This assumption holds after unarise, see Note [Post-unarisation
--   invariants]. Before unarise it may or may not hold. See also Note
--   [RuntimeRep and PrimRep] and Note [VoidRep]
typePrimRep1 :: HasDebugCallStack => UnaryType -> PrimRep

-- | Take a type of kind RuntimeRep and extract the list of <a>PrimRep</a>
--   that it encodes. See also Note [Getting from RuntimeRep to PrimRep].
--   The <tt>[PrimRep]</tt> is the final runtime representation
--   <i>after</i> unarisation.
--   
--   The result does not contain any VoidRep.
runtimeRepPrimRep :: HasDebugCallStack => SDoc -> RuntimeRepType -> [PrimRep]
typePrimRepArgs :: HasDebugCallStack => Type -> [PrimRep]

-- | A <a>PrimRep</a> is an abstraction of a type. It contains information
--   that the code generator needs in order to pass arguments, return
--   results, and store values of this type. See also Note [RuntimeRep and
--   PrimRep] in <a>GHC.Types.RepType</a> and Note [VoidRep] in
--   <a>GHC.Types.RepType</a>.
data PrimRep
VoidRep :: PrimRep
LiftedRep :: PrimRep

-- | Unlifted pointer
UnliftedRep :: PrimRep

-- | Signed, 8-bit value
Int8Rep :: PrimRep

-- | Signed, 16-bit value
Int16Rep :: PrimRep

-- | Signed, 32-bit value
Int32Rep :: PrimRep

-- | Signed, 64 bit value
Int64Rep :: PrimRep

-- | Signed, word-sized value
IntRep :: PrimRep

-- | Unsigned, 8 bit value
Word8Rep :: PrimRep

-- | Unsigned, 16 bit value
Word16Rep :: PrimRep

-- | Unsigned, 32 bit value
Word32Rep :: PrimRep

-- | Unsigned, 64 bit value
Word64Rep :: PrimRep

-- | Unsigned, word-sized value
WordRep :: PrimRep

-- | A pointer, but <i>not</i> to a Haskell value (use '(Un)liftedRep')
AddrRep :: PrimRep
FloatRep :: PrimRep
DoubleRep :: PrimRep

-- | A vector
VecRep :: Int -> PrimElemRep -> PrimRep

-- | Convert a <a>PrimRep</a> to a <a>Type</a> of kind RuntimeRep
primRepToRuntimeRep :: PrimRep -> RuntimeRepType

-- | Convert a PrimRep back to a Type. Used only in the unariser to give
--   types to fresh Ids. Really, only the type's representation matters.
--   See also Note [RuntimeRep and PrimRep]
primRepToType :: PrimRep -> Type
countFunRepArgs :: Arity -> Type -> RepArity
countConRepArgs :: DataCon -> RepArity

-- | Give the demands on the arguments of a Core constructor application
--   (Con dc args) at runtime. Assumes the constructor is not levity
--   polymorphic. For example unboxed tuples won't work.
dataConRuntimeRepStrictness :: HasDebugCallStack => DataCon -> [StrictnessMark]

-- | Find the runtime representation of a <a>TyCon</a>. Defined here to
--   avoid module loops. Returns a list of the register shapes necessary.
--   See also Note [Getting from RuntimeRep to PrimRep]
tyConPrimRep :: HasDebugCallStack => TyCon -> [PrimRep]

-- | Like <a>tyConPrimRep</a>, but assumed that there is precisely zero or
--   one <a>PrimRep</a> output See also Note [Getting from RuntimeRep to
--   PrimRep] and Note [VoidRep]
tyConPrimRep1 :: HasDebugCallStack => TyCon -> PrimRep

-- | Take a type of kind RuntimeRep and extract the list of <a>PrimRep</a>
--   that it encodes. See also Note [Getting from RuntimeRep to PrimRep].
--   The <tt>[PrimRep]</tt> is the final runtime representation
--   <i>after</i> unarisation and does not contain VoidRep.
--   
--   Returns <tt>Nothing</tt> if rep can't be determined. Eg. levity
--   polymorphic types.
runtimeRepPrimRep_maybe :: Type -> Maybe [PrimRep]

-- | Take a kind (of shape `TYPE rr` or `CONSTRAINT rr`) and produce the
--   <a>PrimRep</a>s of values of types of this kind. See also Note
--   [Getting from RuntimeRep to PrimRep] Returns Nothing if rep can't be
--   determined. Eg. levity polymorphic types.
kindPrimRep_maybe :: HasDebugCallStack => Kind -> Maybe [PrimRep]

-- | Discovers the primitive representation of a <a>Type</a>. Returns a
--   list of <a>PrimRep</a>: it's a list because of the possibility of no
--   runtime representation (void) or multiple (unboxed tuple/sum) See also
--   Note [Getting from RuntimeRep to PrimRep] Returns Nothing if rep can't
--   be determined. Eg. levity polymorphic types.
typePrimRep_maybe :: Type -> Maybe [PrimRep]

-- | Given the arguments of a sum type constructor application, return the
--   unboxed sum rep type.
--   
--   E.g.
--   
--   (# Int# | Maybe Int | (# Int#, Float# #) #)
--   
--   We call `ubxSumRepType [ [IntRep], [LiftedRep], [IntRep, FloatRep] ]`,
--   which returns [WordSlot, PtrSlot, WordSlot, FloatSlot]
--   
--   INVARIANT: Result slots are sorted (via Ord SlotTy), except that at
--   the head of the list we have the slot for the tag.
ubxSumRepType :: [[PrimRep]] -> NonEmpty SlotTy
layoutUbxSum :: HasDebugCallStack => SortedSlotTys -> [SlotTy] -> [Int]
typeSlotTy :: UnaryType -> Maybe SlotTy
data SlotTy
PtrLiftedSlot :: SlotTy
PtrUnliftedSlot :: SlotTy
WordSlot :: SlotTy
Word64Slot :: SlotTy
FloatSlot :: SlotTy
DoubleSlot :: SlotTy
VecSlot :: Int -> PrimElemRep -> SlotTy
slotPrimRep :: SlotTy -> PrimRep
primRepSlot :: PrimRep -> SlotTy
mightBeFunTy :: Type -> Bool
instance GHC.Classes.Ord GHC.Types.RepType.SlotTy
instance GHC.Classes.Eq GHC.Types.RepType.SlotTy
instance GHC.Utils.Outputable.Outputable GHC.Types.RepType.SlotTy


-- | A language to express the evaluation context of an expression as a
--   <a>Demand</a> and track how an expression evaluates free variables and
--   arguments in turn as a <a>DmdType</a>.
--   
--   Lays out the abstract domain for <a>GHC.Core.Opt.DmdAnal</a>.
module GHC.Types.Demand
data Boxity
Boxed :: Boxity
Unboxed :: Boxity

-- | Describes an interval of <i>evaluation cardinalities</i>. See Note
--   [Evaluation cardinalities] See Note [Bit vector representation for
--   Card]
data Card

-- | Absent, {0}. Pretty-printed as A.
pattern C_00 :: Card

-- | Used at most once, {0,1}. Pretty-printed as M.
pattern C_01 :: Card

-- | Every possible cardinality; the top element, {0,1,n}. Pretty-printed
--   as L.
pattern C_0N :: Card

-- | Bottom, {}. Pretty-printed as A.
pattern C_10 :: Card

-- | Strict and used once, {1}. Pretty-printed as 1.
pattern C_11 :: Card

-- | Strict and used (possibly) many times, {1,n}. Pretty-printed as S.
pattern C_1N :: Card

-- | A subtype of <a>Card</a> for which the upper bound is never 0 (no
--   <a>C_00</a> or <a>C_10</a>). The only four inhabitants are
--   <a>C_01</a>, <a>C_0N</a>, <a>C_11</a>, <a>C_1N</a>. Membership can be
--   tested with <a>isCardNonAbs</a>. See <a>D</a> and <a>Call</a> for use
--   sites and explanation.
type CardNonAbs = Card

-- | A subtype of <a>Card</a> for which the upper bound is never 1 (no
--   <a>C_01</a> or <a>C_11</a>). The only four inhabitants are
--   <a>C_00</a>, <a>C_0N</a>, <a>C_10</a>, <a>C_1N</a>. Membership can be
--   tested with <a>isCardNonOnce</a>. See <a>Poly</a> for use sites and
--   explanation.
type CardNonOnce = Card

-- | A demand describes
--   
--   <ul>
--   <li>How many times a variable is evaluated, via a <a>Card</a>inality,
--   and</li>
--   <li>How deep its value was evaluated in turn, via a
--   <a>SubDemand</a>.</li>
--   </ul>
--   
--   Examples (using Note [Demand notation]):
--   
--   <ul>
--   <li><a>seq</a> puts demand <tt>1A</tt> on its first argument: It
--   evaluates the argument strictly (<tt>1</tt>), but not any deeper
--   (<tt>A</tt>).</li>
--   <li><a>fst</a> puts demand <tt>1P(1L,A)</tt> on its argument: It
--   evaluates the argument pair strictly and the first component strictly,
--   but no nested info beyond that (<tt>L</tt>). Its second argument is
--   not used at all.</li>
--   <li><a>$</a> puts demand <tt>1C(1,L)</tt> on its first argument: It
--   calls (<tt>C</tt>) the argument function with one argument, exactly
--   once (<tt>1</tt>). No info on how the result of that call is evaluated
--   (<tt>L</tt>).</li>
--   <li><a>maybe</a> puts demand <tt>MC(M,L)</tt> on its second argument:
--   It evaluates the argument function at most once ((M)aybe) and calls it
--   once when it is evaluated.</li>
--   <li><tt>fst p + fst p</tt> puts demand <tt>SP(SL,A)</tt> on
--   <tt>p</tt>: It's <tt>1P(1L,A)</tt> multiplied by two, so we get
--   <tt>S</tt> (used at least once, possibly multiple times).</li>
--   </ul>
--   
--   This data type is quite similar to <tt><tt>Scaled</tt>
--   <a>SubDemand</a></tt>, but it's scaled by <a>Card</a>, which is an
--   <i>interval</i> on <tt>Multiplicity</tt>, the upper bound of which
--   could be used to infer uniqueness types. Also we treat <a>AbsDmd</a>
--   and <a>BotDmd</a> specially, as the concept of a <a>SubDemand</a>
--   doesn't apply when there isn't any evaluation at all. If you don't
--   care, simply use <a>(:*)</a>.
data Demand

-- | A bottoming demand, produced by a diverging function (<a>C_10</a>),
--   hence there is no <a>SubDemand</a> that describes how it was
--   evaluated.
BotDmd :: Demand

-- | An absent demand: Evaluated exactly 0 times (<a>C_00</a>), hence there
--   is no <a>SubDemand</a> that describes how it was evaluated.
AbsDmd :: Demand

-- | <tt>c :* sd</tt> is a demand that says "evaluated <tt>c</tt> times,
--   and any trace in which it is evaluated will evaluate at least as deep
--   as <tt>sd</tt>".
--   
--   Matching on this pattern synonym is a complete match. If the matched
--   demand was <a>AbsDmd</a>, it will match as <tt>C_00 :* seqSubDmd</tt>.
--   If the matched demand was <a>BotDmd</a>, it will match as <tt>C_10 :*
--   botSubDmd</tt>. The builder of this pattern synonym simply
--   <i>discards</i> the <a>SubDemand</a> if the <a>Card</a> was absent and
--   returns <a>AbsDmd</a> or <a>BotDmd</a> instead. It will assert that
--   the discarded sub-demand was <a>seqSubDmd</a> and <a>botSubDmd</a>,
--   respectively.
--   
--   Call sites should consider whether they really want to look at the
--   <a>SubDemand</a> of an absent demand and match on <a>AbsDmd</a> and/or
--   <a>BotDmd</a> otherwise. Really, any other <a>SubDemand</a> would be
--   allowed and might work better, depending on context.
pattern (:*) :: HasDebugCallStack => Card -> SubDemand -> Demand

-- | A sub-demand describes an <i>evaluation context</i> (in the sense of
--   an operational semantics), e.g. how deep the denoted thing is going to
--   be evaluated. See <a>Demand</a> for examples.
--   
--   See Note [SubDemand denotes at least one evaluation] for a more
--   detailed description of what a sub-demand means.
--   
--   See Note [Demand notation] for the extensively used short-hand
--   notation. See also Note [Why Boxity in SubDemand and not in Demand?].
data SubDemand

-- | Polymorphic demand, the denoted thing is evaluated arbitrarily deep,
--   with the specified cardinality at every level. The <a>Boxity</a>
--   applies only to the outer evaluation context as well as all inner
--   evaluation context. See Note [Boxity in Poly] for why we want it to
--   carry <a>Boxity</a>. Expands to <a>Call</a> via <a>viewCall</a> and to
--   <a>Prod</a> via <a>viewProd</a>.
--   
--   <tt>Poly b n</tt> is semantically equivalent to <tt>Prod b [n :* Poly
--   b n, ...] or </tt>Call n (Poly Boxed n)@. <a>viewCall</a> and
--   <a>viewProd</a> do these rewrites.
--   
--   In Note [Demand notation]: <tt>L === P(L,L,...)</tt> and <tt>L ===
--   C(L)</tt>, <tt>B === P(B,B,...)</tt> and <tt>B === C(B)</tt>, <tt>!A
--   === !P(A,A,...)</tt> and <tt>!A === C(A)</tt>, and so on.
--   
--   We'll only see <a>Poly</a> with <a>C_10</a> (B), <a>C_00</a> (A),
--   <a>C_0N</a> (L) and sometimes <a>C_1N</a> (S) through
--   <a>plusSubDmd</a>, never <a>C_01</a> (M) or <a>C_11</a> (1) (grep the
--   source code). Hence <a>CardNonOnce</a>, which is closed under
--   <tt>lub</tt> and <tt>plus</tt>.
--   
--   Why doesn't this constructor simply carry a <a>Demand</a> instead of
--   its fields? See Note [Call SubDemand vs. evaluation Demand].
Poly :: !Boxity -> !CardNonOnce -> SubDemand

-- | <tt>Prod b ds</tt> describes the evaluation context of a case
--   scrutinisation on an expression of product type, where the product
--   components are evaluated according to <tt>ds</tt>. The <a>Boxity</a>
--   <tt>b</tt> says whether or not the box of the product was used.
Prod :: !Boxity -> ![Demand] -> SubDemand

-- | A smart constructor for <a>Prod</a>, applying rewrite rules along the
--   semantic equality <tt>Prod b [n :* Poly Boxed n, ...] === Poly b
--   n</tt>, simplifying to <a>Poly</a> <a>SubDemand</a>s when possible.
--   Examples:
--   
--   <ul>
--   <li>Rewrites <tt>P(L,L)</tt> (e.g., arguments <tt>Boxed</tt>,
--   <tt>[L,L]</tt>) to <tt>L</tt></li>
--   <li>Rewrites <tt>!P(L!L,L!L)</tt> (e.g., arguments <tt>Unboxed</tt>,
--   <tt>[L!L,L!L]</tt>) to <tt>!L</tt></li>
--   <li>Does not rewrite <tt>P(1L)</tt>, <tt>P(L!L)</tt>, <tt>!P(L)</tt>
--   or <tt>P(L,A)</tt></li>
--   </ul>
mkProd :: Boxity -> [Demand] -> SubDemand

-- | <tt>viewProd n sd</tt> interprets <tt>sd</tt> as a <a>Prod</a> of
--   arity <tt>n</tt>, expanding <a>Poly</a> demands as necessary.
viewProd :: Arity -> SubDemand -> Maybe (Boxity, [Demand])
absDmd :: Demand
topDmd :: Demand
botDmd :: Demand
seqDmd :: Demand
topSubDmd :: SubDemand

-- | Denotes <tt>∪</tt> on <a>Card</a>.
lubCard :: Card -> Card -> Card

-- | Denotes <tt>∪</tt> on <a>Demand</a>.
lubDmd :: Demand -> Demand -> Demand
lubSubDmd :: SubDemand -> SubDemand -> SubDemand

-- | Denotes <a>+</a> on lower and upper bounds of <a>Card</a>.
plusCard :: Card -> Card -> Card

-- | Denotes <a>+</a> on <a>Demand</a>.
plusDmd :: Demand -> Demand -> Demand
plusSubDmd :: SubDemand -> SubDemand -> SubDemand

-- | Denotes <a>*</a> on lower and upper bounds of <a>Card</a>.
multCard :: Card -> Card -> Card
multDmd :: Card -> Demand -> Demand
multSubDmd :: Card -> SubDemand -> SubDemand

-- | True <a>=</a> upper bound is 0.
isAbs :: Card -> Bool

-- | True <a>=</a> upper bound is 1.
isUsedOnce :: Card -> Bool

-- | True <a>=</a> lower bound is 1.
isStrict :: Card -> Bool
isAbsDmd :: Demand -> Bool

-- | Is the value used at most once?
isUsedOnceDmd :: Demand -> Bool

-- | Not absent and used strictly. See Note [Strict demands]
isStrUsedDmd :: Demand -> Bool

-- | Contrast with isStrictUsedDmd. See Note [Strict demands]
isStrictDmd :: Demand -> Bool

-- | Used to suppress pretty-printing of an uninformative demand
isTopDmd :: Demand -> Bool

-- | We try to avoid tracking weak free variable demands in strictness
--   signatures for analysis performance reasons. See Note [Lazy and
--   unleashable free variables] in <a>GHC.Core.Opt.DmdAnal</a>.
isWeakDmd :: Demand -> Bool

-- | True when the signature indicates all arguments are boxed
onlyBoxedArguments :: DmdSig -> Bool
evalDmd :: Demand

-- | First argument of catch#: <tt>MC(M,L)</tt>. Evaluates its arg lazily,
--   but then applies it exactly once to one argument.
lazyApply1Dmd :: Demand

-- | Second argument of catch#: <tt>MC(M,C(1,L))</tt>. Calls its arg
--   lazily, but then applies it exactly once to an additional argument.
lazyApply2Dmd :: Demand

-- | First argument of 'GHC.Exts.maskAsyncExceptions#': <tt>1C(1,L)</tt>.
--   Called exactly once.
strictOnceApply1Dmd :: Demand

-- | First argument of 'GHC.Exts.atomically#': <tt>SC(S,L)</tt>. Called at
--   least once, possibly many times.
strictManyApply1Dmd :: Demand

-- | Intersect with [0,1].
oneifyCard :: Card -> Card

-- | Make a <a>Demand</a> evaluated at-most-once.
oneifyDmd :: Demand -> Demand

-- | Make a <a>Demand</a> evaluated at-least-once (e.g. strict).
strictifyDmd :: Demand -> Demand

-- | If the argument is a used non-newtype dictionary, give it strict
--   demand. Also split the product type &amp; demand and recur in order to
--   similarly strictify the argument's contained used non-newtype
--   superclass dictionaries. We use the demand as our recursive measure to
--   guarantee termination.
strictifyDictDmd :: Type -> Demand -> Demand

-- | Make a <a>Demand</a> lazy.
lazifyDmd :: Demand -> Demand

-- | Peels one call level from the sub-demand, and also returns how many
--   times we entered the lambda body.
peelCallDmd :: SubDemand -> (Card, SubDemand)
peelManyCalls :: Arity -> SubDemand -> (Card, SubDemand)

-- | Wraps the <a>SubDemand</a> with a one-shot call demand: <tt>d</tt>
--   -&gt; <tt>C(1,d)</tt>.
mkCalledOnceDmd :: SubDemand -> SubDemand

-- | <tt>mkCalledOnceDmds n d</tt> returns <tt>C(1,C1...C(1,d))</tt> where
--   there are <tt>n</tt> <tt>C1</tt>'s.
mkCalledOnceDmds :: Arity -> SubDemand -> SubDemand
mkWorkerDemand :: Int -> Demand

-- | Extract the <a>SubDemand</a> of a <a>Demand</a>. PRECONDITION: The
--   SubDemand must be used in a context where the expression denoted by
--   the Demand is under evaluation.
subDemandIfEvaluated :: Demand -> SubDemand

-- | See Note [Computing one-shot info]
argOneShots :: Demand -> [OneShotInfo]

-- | See Note [Computing one-shot info]
argsOneShots :: DmdSig -> Arity -> [[OneShotInfo]]

-- | <tt>saturatedByOneShots n C(M,C(M,...)) = True</tt> <a>=</a> There are
--   at least n nested C(M,..) calls. See Note [Demand on the worker] in
--   GHC.Core.Opt.WorkWrap
saturatedByOneShots :: Int -> Demand -> Bool

-- | Sets <a>Boxity</a> to <a>Unboxed</a> for the <a>Demand</a>, recursing
--   into <a>Prod</a>s. Don't recurse into lazy arguments; see
--   GHC.Core.Opt.DmdAnal Note [No lazy, Unboxed demands in demand
--   signature]
unboxDeeplyDmd :: Demand -> Demand

-- | <a>Divergence</a> characterises whether something surely diverges.
--   Models a subset lattice of the following exhaustive set of divergence
--   results:
--   
--   <ul>
--   <li><i>n</i> nontermination (e.g. loops)</li>
--   <li><i>i</i> throws imprecise exception</li>
--   <li><i>p</i> throws precise exceTtion</li>
--   <li><i>c</i> converges (reduces to WHNF).</li>
--   </ul>
--   
--   The different lattice elements correspond to different subsets,
--   indicated by juxtaposition of indicators (e.g. <b>nc</b> definitely
--   doesn't throw an exception, and may or may not reduce to WHNF).
--   
--   <pre>
--    Dunno (nipc)
--         |
--   ExnOrDiv (nip)
--         |
--   Diverges (ni)
--   </pre>
--   
--   As you can see, we don't distinguish <b>n</b> and <b>i</b>. See Note
--   [Precise exceptions and strictness analysis] for why <b>p</b> is so
--   special compared to <b>i</b>.
data Divergence

-- | Definitely throws an imprecise exception or diverges.
Diverges :: Divergence

-- | Definitely throws a *precise* exception, an imprecise exception or
--   diverges. Never converges, hence <a>isDeadEndDiv</a>! See scenario 1
--   in Note [Precise exceptions and strictness analysis].
ExnOrDiv :: Divergence

-- | Might diverge, throw any kind of exception or converge.
Dunno :: Divergence
topDiv :: Divergence
botDiv :: Divergence
exnDiv :: Divergence
lubDivergence :: Divergence -> Divergence -> Divergence

-- | True if the <a>Divergence</a> indicates that evaluation will not
--   return. See Note [Dead ends].
isDeadEndDiv :: Divergence -> Bool

-- | Captures the result of an evaluation of an expression, by
--   
--   <ul>
--   <li>Listing how the free variables of that expression have been
--   evaluted (<a>de_fvs</a>)</li>
--   <li>Saying whether or not evaluation would surely diverge
--   (<a>de_div</a>)</li>
--   </ul>
--   
--   See Note [Demand env Equality].
data DmdEnv
DE :: !VarEnv Demand -> !Divergence -> DmdEnv
[de_fvs] :: DmdEnv -> !VarEnv Demand
[de_div] :: DmdEnv -> !Divergence
addVarDmdEnv :: DmdEnv -> Id -> Demand -> DmdEnv

-- | Build a potentially terminating <a>DmdEnv</a> from a finite map that
--   says what has been evaluated so far
mkTermDmdEnv :: VarEnv Demand -> DmdEnv
nopDmdEnv :: DmdEnv
plusDmdEnv :: DmdEnv -> DmdEnv -> DmdEnv

-- | <a>DmdEnv</a> is a monoid via <a>plusDmdEnv</a> and <a>nopDmdEnv</a>;
--   this is its <tt>msum</tt>
plusDmdEnvs :: [DmdEnv] -> DmdEnv
reuseEnv :: DmdEnv -> DmdEnv

-- | Characterises how an expression
--   
--   <ul>
--   <li>Evaluates its free variables (<a>dt_env</a>) including divergence
--   info</li>
--   <li>Evaluates its arguments (<a>dt_args</a>)</li>
--   </ul>
data DmdType
DmdType :: !DmdEnv -> ![Demand] -> DmdType

-- | Demands on free variables. See Note [Demand type Divergence]
[dt_env] :: DmdType -> !DmdEnv

-- | Demand on arguments
[dt_args] :: DmdType -> ![Demand]
dmdTypeDepth :: DmdType -> Arity

-- | The demand type of doing nothing (lazy, absent, no Divergence
--   information). Note that it is '<tt>not'</tt> the top of the lattice
--   (which would be "may use everything"), so it is (no longer) called
--   topDmdType.
nopDmdType :: DmdType
botDmdType :: DmdType

-- | Compute the least upper bound of two <a>DmdType</a>s elicited /by the
--   same incoming demand/!
lubDmdType :: DmdType -> DmdType -> DmdType
plusDmdType :: DmdType -> DmdEnv -> DmdType
multDmdType :: Card -> DmdType -> DmdType
discardArgDmds :: DmdType -> DmdEnv
peelFV :: DmdType -> Var -> (DmdType, Demand)
findIdDemand :: DmdType -> Var -> Demand
addDemand :: Demand -> DmdType -> DmdType
splitDmdTy :: DmdType -> (Demand, DmdType)

-- | When e is evaluated after executing an IO action that may throw a
--   precise exception, we act as if there is an additional control flow
--   path that is taken if e throws a precise exception. The demand type of
--   this control flow path * is lazy and absent (<a>topDmd</a>) and boxed
--   in all free variables and arguments * has <a>exnDiv</a>
--   <a>Divergence</a> result See Note [Precise exceptions and strictness
--   analysis]
--   
--   So we can simply take a variant of <a>nopDmdType</a>,
--   <a>exnDmdType</a>. Why not <a>nopDmdType</a>? Because then the result
--   of <tt>e</tt> can never be <a>exnDiv</a>! That means failure to drop
--   dead-ends, see #18086.
deferAfterPreciseException :: DmdType -> DmdType

-- | The depth of the wrapped <a>DmdType</a> encodes the arity at which it
--   is safe to unleash. Better construct this through
--   <a>mkDmdSigForArity</a>. See Note [Understanding DmdType and DmdSig]
newtype DmdSig
DmdSig :: DmdType -> DmdSig

-- | Turns a <a>DmdType</a> computed for the particular <a>Arity</a> into a
--   <a>DmdSig</a> unleashable at that arity. See Note [Understanding
--   DmdType and DmdSig].
mkDmdSigForArity :: Arity -> DmdType -> DmdSig
mkClosedDmdSig :: [Demand] -> Divergence -> DmdSig
mkVanillaDmdSig :: Arity -> Divergence -> DmdSig
splitDmdSig :: DmdSig -> ([Demand], Divergence)
dmdSigDmdEnv :: DmdSig -> DmdEnv
hasDemandEnvSig :: DmdSig -> Bool
nopSig :: DmdSig
botSig :: DmdSig
isNopSig :: DmdSig -> Bool

-- | True if the signature diverges or throws an imprecise exception in a
--   saturated call. NB: In constrast to <a>isDeadEndSig</a> this returns
--   False for <a>exnDiv</a>. See Note [Dead ends] and Note [Precise vs
--   imprecise exceptions].
isBottomingSig :: DmdSig -> Bool

-- | True if the signature diverges or throws an exception in a saturated
--   call. See Note [Dead ends].
isDeadEndSig :: DmdSig -> Bool

-- | Returns true if an application to n value args would diverge or throw
--   an exception.
--   
--   If a function having <a>botDiv</a> is applied to a less number of
--   arguments than its syntactic arity, we cannot say for sure that it is
--   going to diverge. Hence this function conservatively returns False in
--   that case. See Note [Dead ends].
isDeadEndAppSig :: DmdSig -> Int -> Bool
trimBoxityDmdSig :: DmdSig -> DmdSig
transferArgBoxityDmdSig :: DmdSig -> DmdSig -> DmdSig

-- | Add extra (<a>topDmd</a>) arguments to a strictness signature. In
--   contrast to <a>etaConvertDmdSig</a>, this <i>prepends</i> additional
--   argument demands. This is used by FloatOut.
prependArgsDmdSig :: Int -> DmdSig -> DmdSig

-- | We are expanding (x y. e) to (x y z. e z) or reducing from the latter
--   to the former (when the Simplifier identifies a new join points, for
--   example). In contrast to <a>prependArgsDmdSig</a>, this <i>appends</i>
--   extra arg demands if necessary. This works by looking at the
--   <a>DmdType</a> (which was produced under a call demand for the old
--   arity) and trying to transfer as many facts as we can to the call
--   demand of new arity. An arity increase (resulting in a stronger
--   incoming demand) can retain much of the info, while an arity decrease
--   (a weakening of the incoming demand) must fall back to a conservative
--   default.
etaConvertDmdSig :: Arity -> DmdSig -> DmdSig

-- | A <i>demand transformer</i> is a monotone function from an incoming
--   evaluation context (<a>SubDemand</a>) to a <a>DmdType</a>, describing
--   how the denoted thing (i.e. expression, function) uses its arguments
--   and free variables, and whether it diverges.
--   
--   See Note [Understanding DmdType and DmdSig] and Note [What are demand
--   signatures?].
type DmdTransformer = SubDemand -> DmdType

-- | Extrapolate a demand signature (<a>DmdSig</a>) into a
--   <a>DmdTransformer</a>.
--   
--   Given a function's <a>DmdSig</a> and a <a>SubDemand</a> for the
--   evaluation context, return how the function evaluates its free
--   variables and arguments.
dmdTransformSig :: DmdSig -> DmdTransformer

-- | A special <a>DmdTransformer</a> for data constructors that feeds
--   product demands into the constructor arguments.
dmdTransformDataConSig :: [StrictnessMark] -> DmdTransformer

-- | A special <a>DmdTransformer</a> for dictionary selectors that feeds
--   the demand on the result into the indicated dictionary component (if
--   saturated). See Note [Demand transformer for a dictionary selector].
dmdTransformDictSelSig :: DmdSig -> DmdTransformer
data TypeShape
TsFun :: TypeShape -> TypeShape
TsProd :: [TypeShape] -> TypeShape
TsUnk :: TypeShape
trimToType :: Demand -> TypeShape -> Demand

-- | Drop all boxity
trimBoxity :: Demand -> Demand
seqDemand :: Demand -> ()
seqDemandList :: [Demand] -> ()
seqDmdType :: DmdType -> ()
seqDmdSig :: DmdSig -> ()
zapUsageDemand :: Demand -> Demand

-- | Remove the demand environment from the signature.
zapDmdEnvSig :: DmdSig -> DmdSig

-- | Remove all `C_01 :*` info (but not <tt>CM</tt> sub-demands) from the
--   demand
zapUsedOnceDemand :: Demand -> Demand

-- | Remove all `C_01 :*` info (but not <tt>CM</tt> sub-demands) from the
--   strictness signature
zapUsedOnceSig :: DmdSig -> DmdSig
instance GHC.Classes.Eq GHC.Types.Demand.Card
instance GHC.Classes.Eq GHC.Types.Demand.Demand
instance GHC.Classes.Eq GHC.Types.Demand.Divergence
instance GHC.Classes.Eq GHC.Types.Demand.DmdSig
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.TypeShape
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.DmdSig
instance GHC.Utils.Binary.Binary GHC.Types.Demand.DmdSig
instance GHC.Classes.Eq GHC.Types.Demand.DmdType
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.DmdType
instance GHC.Utils.Binary.Binary GHC.Types.Demand.DmdType
instance GHC.Classes.Eq GHC.Types.Demand.DmdEnv
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.DmdEnv
instance GHC.Utils.Binary.Binary GHC.Types.Demand.DmdEnv
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.Divergence
instance GHC.Utils.Binary.Binary GHC.Types.Demand.Divergence
instance GHC.Classes.Eq GHC.Types.Demand.SubDemand
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.Demand
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.SubDemand
instance GHC.Utils.Binary.Binary GHC.Types.Demand.Demand
instance GHC.Utils.Binary.Binary GHC.Types.Demand.SubDemand
instance GHC.Show.Show GHC.Types.Demand.Card
instance GHC.Utils.Outputable.Outputable GHC.Types.Demand.Card
instance GHC.Utils.Binary.Binary GHC.Types.Demand.Card


-- | Types for the Constructed Product Result lattice.
--   <a>GHC.Core.Opt.CprAnal</a> and <a>GHC.Core.Opt.WorkWrap.Utils</a> are
--   its primary customers via <a>idCprSig</a>.
module GHC.Types.Cpr
data Cpr
pattern ConCpr :: ConTag -> [Cpr] -> Cpr
topCpr :: Cpr
botCpr :: Cpr
flatConCpr :: ConTag -> Cpr
asConCpr :: Cpr -> Maybe (ConTag, [Cpr])

-- | The abstract domain &lt;math&gt; from the original 'CPR for Haskell'
--   paper.
data CprType
CprType :: !Arity -> !Cpr -> CprType

-- | Number of value arguments the denoted expression eats before returning
--   the <a>ct_cpr</a>
[ct_arty] :: CprType -> !Arity

-- | <a>Cpr</a> eventually unleashed when applied to <a>ct_arty</a>
--   arguments
[ct_cpr] :: CprType -> !Cpr
topCprType :: CprType
botCprType :: CprType
flatConCprType :: ConTag -> CprType
lubCprType :: CprType -> CprType -> CprType
applyCprTy :: CprType -> Arity -> CprType
abstractCprTy :: CprType -> CprType
trimCprTy :: CprType -> CprType

-- | The result of <a>unpackConFieldsCpr</a>.
data UnpackConFieldsResult
AllFieldsSame :: !Cpr -> UnpackConFieldsResult
ForeachField :: ![Cpr] -> UnpackConFieldsResult

-- | Unpacks a <a>ConCpr</a>-shaped <a>Cpr</a> and returns the field
--   <a>Cpr</a>s wrapped in a <a>ForeachField</a>. Otherwise, it returns
--   <a>AllFieldsSame</a> with the appropriate <a>Cpr</a> to assume for
--   each field.
--   
--   The use of <a>UnpackConFieldsResult</a> allows O(1) space for the
--   common, non-<a>ConCpr</a> case.
unpackConFieldsCpr :: DataCon -> Cpr -> UnpackConFieldsResult

-- | The arity of the wrapped <a>CprType</a> is the arity at which it is
--   safe to unleash. See Note [Understanding DmdType and DmdSig] in
--   <a>GHC.Types.Demand</a>
newtype CprSig
CprSig :: CprType -> CprSig
[getCprSig] :: CprSig -> CprType
topCprSig :: CprSig
isTopCprSig :: CprSig -> Bool

-- | Turns a <a>CprType</a> computed for the particular <a>Arity</a> into a
--   <a>CprSig</a> unleashable at that arity. See Note [Understanding
--   DmdType and DmdSig] in <a>GHC.Types.Demand</a>
mkCprSigForArity :: Arity -> CprType -> CprSig
mkCprSig :: Arity -> Cpr -> CprSig
seqCprSig :: CprSig -> ()

-- | Add extra value args to CprSig
prependArgsCprSig :: Arity -> CprSig -> CprSig
instance GHC.Classes.Eq GHC.Types.Cpr.Cpr
instance GHC.Utils.Binary.Binary GHC.Types.Cpr.CprSig
instance GHC.Classes.Eq GHC.Types.Cpr.CprSig
instance GHC.Utils.Outputable.Outputable GHC.Types.Cpr.CprSig
instance GHC.Classes.Eq GHC.Types.Cpr.CprType
instance GHC.Utils.Outputable.Outputable GHC.Types.Cpr.CprType
instance GHC.Utils.Binary.Binary GHC.Types.Cpr.CprType
instance GHC.Utils.Outputable.Outputable GHC.Types.Cpr.Cpr
instance GHC.Utils.Binary.Binary GHC.Types.Cpr.Cpr

module GHC.StgToCmm.Types

-- | Codegen-generated Id infos, to be passed to downstream via interfaces.
--   
--   This stuff is for optimization purposes only, they're not compulsory.
--   
--   <ul>
--   <li>When CafInfo of an imported Id is not known it's safe to treat it
--   as CAFFY.</li>
--   <li>When LambdaFormInfo of an imported Id is not known it's safe to
--   treat it as `LFUnknown True` (which just says "it could be anything"
--   and we do slow entry).</li>
--   </ul>
--   
--   See also Note [Conveying CAF-info and LFInfo between modules] above.
data CmmCgInfos
CmmCgInfos :: !NonCaffySet -> !ModuleLFInfos -> !CStub -> CmmCgInfos

-- | Exported Non-CAFFY closures in the current module. Everything else is
--   either not exported of CAFFY.
[cgNonCafs] :: CmmCgInfos -> !NonCaffySet

-- | LambdaFormInfos of exported closures in the current module.
[cgLFInfos] :: CmmCgInfos -> !ModuleLFInfos

-- | The C stub which is used for IPE information
[cgIPEStub] :: CmmCgInfos -> !CStub

-- | Information about an identifier, from the code generator's point of
--   view. Every identifier is bound to a LambdaFormInfo in the
--   environment, which gives the code generator enough info to be able to
--   tail call or return that identifier.
data LambdaFormInfo
LFReEntrant :: !TopLevelFlag -> !RepArity -> !Bool -> !ArgDescr -> LambdaFormInfo
LFThunk :: !TopLevelFlag -> !Bool -> !Bool -> !StandardFormInfo -> !Bool -> LambdaFormInfo
LFCon :: !DataCon -> LambdaFormInfo
LFUnknown :: !Bool -> LambdaFormInfo
LFUnlifted :: LambdaFormInfo
LFLetNoEscape :: LambdaFormInfo

-- | Maps names in the current module to their LambdaFormInfos
type ModuleLFInfos = NameEnv LambdaFormInfo

-- | StandardFormInfo tells whether this thunk has one of a small number of
--   standard forms
data StandardFormInfo
NonStandardThunk :: StandardFormInfo
SelectorThunk :: !WordOff -> StandardFormInfo
ApThunk :: !RepArity -> StandardFormInfo
type DoSCCProfiling = Bool
type DoExtDynRefs = Bool
instance GHC.Classes.Eq GHC.StgToCmm.Types.StandardFormInfo
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Types.LambdaFormInfo
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Types.StandardFormInfo

module GHC.Core.ConLike

-- | A constructor-like thing
data ConLike
RealDataCon :: DataCon -> ConLike
PatSynCon :: PatSyn -> ConLike

-- | Is this a 'vanilla' constructor-like thing (no existentials, no
--   provided constraints)?
isVanillaConLike :: ConLike -> Bool

-- | Number of arguments
conLikeArity :: ConLike -> Arity

-- | Names of fields used for selectors
conLikeFieldLabels :: ConLike -> [FieldLabel]

-- | Returns just the instantiated <i>value</i> argument types of a
--   <a>ConLike</a>, (excluding dictionary args)
conLikeInstOrigArgTys :: ConLike -> [Type] -> [Scaled Type]

-- | <a>TyVarBinder</a>s for the type variables of the <a>ConLike</a>. For
--   pattern synonyms, this will always consist of the universally
--   quantified variables followed by the existentially quantified type
--   variables. For data constructors, the situation is slightly more
--   complicated—see <tt>Note [DataCon user type variable binders]</tt> in
--   <a>GHC.Core.DataCon</a>.
conLikeUserTyVarBinders :: ConLike -> [InvisTVBinder]

-- | Existentially quantified type/coercion variables
conLikeExTyCoVars :: ConLike -> [TyCoVar]
conLikeName :: ConLike -> Name

-- | The "stupid theta" of the <a>ConLike</a>, such as <tt>data Eq a</tt>
--   in:
--   
--   <pre>
--   data Eq a =&gt; T a = ...
--   </pre>
--   
--   It is empty for <a>PatSynCon</a> as they do not allow such contexts.
--   See <tt>Note [The stupid context]</tt> in <a>GHC.Core.DataCon</a>.
conLikeStupidTheta :: ConLike -> ThetaType

-- | Returns the strictness information for each constructor
conLikeImplBangs :: ConLike -> [HsImplBang]

-- | The "full signature" of the <a>ConLike</a> returns, in order:
--   
--   1) The universally quantified type variables
--   
--   2) The existentially quantified type/coercion variables
--   
--   3) The equality specification
--   
--   4) The provided theta (the constraints provided by a match)
--   
--   5) The required theta (the constraints required for a match)
--   
--   6) The original argument types (i.e. before any change of the
--   representation of the type)
--   
--   7) The original result type
conLikeFullSig :: ConLike -> ([TyVar], [TyCoVar], [EqSpec], ThetaType, ThetaType, [Scaled Type], Type)

-- | Returns the type of the whole pattern
conLikeResTy :: ConLike -> [Type] -> Type

-- | Extract the type for any given labelled field of the <a>ConLike</a>
conLikeFieldType :: ConLike -> FieldLabelString -> Type

-- | The ConLikes that have *all* the given fields
conLikesWithFields :: [ConLike] -> [FieldLabelString] -> [ConLike]
conLikeIsInfix :: ConLike -> Bool

-- | <a>conLikeHasBuilder</a> returns True except for uni-directional
--   pattern synonyms, which have no builder
conLikeHasBuilder :: ConLike -> Bool
instance GHC.Classes.Eq GHC.Core.ConLike.ConLike
instance GHC.Types.Unique.Uniquable GHC.Core.ConLike.ConLike
instance GHC.Types.Name.NamedThing GHC.Core.ConLike.ConLike
instance GHC.Utils.Outputable.Outputable GHC.Core.ConLike.ConLike
instance GHC.Utils.Outputable.OutputableBndr GHC.Core.ConLike.ConLike
instance Data.Data.Data GHC.Core.ConLike.ConLike


-- | COMPLETE signature
module GHC.Types.CompleteMatch

-- | A list of conlikes which represents a complete pattern match. These
--   arise from <tt>COMPLETE</tt> signatures. See also Note [Implementation
--   of COMPLETE pragmas].
data CompleteMatch
CompleteMatch :: UniqDSet ConLike -> Maybe TyCon -> CompleteMatch

-- | The set of <a>ConLike</a> values
[cmConLikes] :: CompleteMatch -> UniqDSet ConLike

-- | The optional, concrete result TyCon the set applies to
[cmResultTyCon] :: CompleteMatch -> Maybe TyCon
vanillaCompleteMatch :: UniqDSet ConLike -> CompleteMatch
type CompleteMatches = [CompleteMatch]
completeMatchAppliesAtType :: Type -> CompleteMatch -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Types.CompleteMatch.CompleteMatch


-- | GHC.Core holds all the main data types for use by for the Glasgow
--   Haskell Compiler midsection
module GHC.Core

-- | This is the data type that represents GHCs core intermediate language.
--   Currently GHC uses System FC
--   <a>https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions/</a>
--   for this purpose, which is closely related to the simpler and better
--   known System F <a>http://en.wikipedia.org/wiki/System_F</a>.
--   
--   We get from Haskell source to this Core language in a number of
--   stages:
--   
--   <ol>
--   <li>The source code is parsed into an abstract syntax tree, which is
--   represented by the data type <a>HsExpr</a> with the names being
--   <a>RdrNames</a></li>
--   <li>This syntax tree is <i>renamed</i>, which attaches a <a>Unique</a>
--   to every <a>RdrName</a> (yielding a <a>Name</a>) to disambiguate
--   identifiers which are lexically identical. For example, this
--   program:</li>
--   </ol>
--   
--   <pre>
--   f x = let f x = x + 1
--         in f (x - 2)
--   </pre>
--   
--   Would be renamed by having <tt>Unique</tt>s attached so it looked
--   something like this:
--   
--   <pre>
--   f_1 x_2 = let f_3 x_4 = x_4 + 1
--             in f_3 (x_2 - 2)
--   </pre>
--   
--   But see Note [Shadowing] below.
--   
--   <ol>
--   <li>The resulting syntax tree undergoes type checking (which also
--   deals with instantiating type class arguments) to yield a
--   <a>HsExpr</a> type that has <a>Id</a> as it's names.</li>
--   <li>Finally the syntax tree is <i>desugared</i> from the expressive
--   <a>HsExpr</a> type into this <a>Expr</a> type, which has far fewer
--   constructors and hence is easier to perform optimization, analysis and
--   code generation on.</li>
--   </ol>
--   
--   The type parameter <tt>b</tt> is for the type of binders in the
--   expression tree.
--   
--   The language consists of the following elements:
--   
--   <ul>
--   <li>Variables See Note [Variable occurrences in Core]</li>
--   <li>Primitive literals</li>
--   <li>Applications: note that the argument may be a <a>Type</a>. See
--   Note [Representation polymorphism invariants]</li>
--   <li>Lambda abstraction See Note [Representation polymorphism
--   invariants]</li>
--   <li>Recursive and non recursive <tt>let</tt>s. Operationally this
--   corresponds to allocating a thunk for the things bound and then
--   executing the sub-expression.</li>
--   </ul>
--   
--   See Note [Core letrec invariant] See Note [Core let-can-float
--   invariant] See Note [Representation polymorphism invariants] See Note
--   [Core type and coercion invariant]
--   
--   <ul>
--   <li>Case expression. Operationally this corresponds to evaluating the
--   scrutinee (expression examined) to weak head normal form and then
--   examining at most one level of resulting constructor (i.e. you cannot
--   do nested pattern matching directly with this).</li>
--   </ul>
--   
--   The binder gets bound to the value of the scrutinee, and the
--   <a>Type</a> must be that of all the case alternatives
--   
--   IMPORTANT: see Note [Case expression invariants]
--   
--   <ul>
--   <li>Cast an expression to a particular type. This is used to implement
--   <tt>newtype</tt>s (a <tt>newtype</tt> constructor or destructor just
--   becomes a <a>Cast</a> in Core) and GADTs.</li>
--   <li>Ticks. These are used to represent all the source annotation we
--   support: profiling SCCs, HPC ticks, and GHCi breakpoints.</li>
--   <li>A type: this should only show up at the top level of an Arg</li>
--   <li>A coercion</li>
--   </ul>
data Expr b
Var :: Id -> Expr b
Lit :: Literal -> Expr b
App :: Expr b -> Arg b -> Expr b
Lam :: b -> Expr b -> Expr b
Let :: Bind b -> Expr b -> Expr b
Case :: Expr b -> b -> Type -> [Alt b] -> Expr b
Cast :: Expr b -> CoercionR -> Expr b
Tick :: CoreTickish -> Expr b -> Expr b
Type :: Type -> Expr b
Coercion :: Coercion -> Expr b
infixl 4 `App`

-- | A case split alternative. Consists of the constructor leading to the
--   alternative, the variables bound from the constructor, and the
--   expression to be executed given that binding. The default alternative
--   is <tt>(DEFAULT, [], rhs)</tt>
data Alt b
Alt :: AltCon -> [b] -> Expr b -> Alt b

-- | Binding, used for top level bindings in a module and local bindings in
--   a <tt>let</tt>.
data Bind b
NonRec :: b -> Expr b -> Bind b
Rec :: [(b, Expr b)] -> Bind b

-- | A case alternative constructor (i.e. pattern match)
data AltCon
DataAlt :: DataCon -> AltCon

-- | A literal: <tt>case e of { 1 -&gt; ... }</tt> Invariant: always an
--   *unlifted* literal See Note [Literal alternatives]
LitAlt :: Literal -> AltCon

-- | Trivial alternative: <tt>case e of { _ -&gt; ... }</tt>
DEFAULT :: AltCon

-- | Type synonym for expressions that occur in function argument
--   positions. Only <a>Arg</a> should contain a <a>Type</a> at top level,
--   general <a>Expr</a> should not
type Arg b = Expr b
type CoreProgram = [CoreBind]

-- | Expressions where binders are <a>CoreBndr</a>s
type CoreExpr = Expr CoreBndr

-- | Case alternatives where binders are <a>CoreBndr</a>s
type CoreAlt = Alt CoreBndr

-- | Binding groups where binders are <a>CoreBndr</a>s
type CoreBind = Bind CoreBndr

-- | Argument expressions where binders are <a>CoreBndr</a>s
type CoreArg = Arg CoreBndr

-- | The common case for the type of binders and variables when we are
--   manipulating the Core language within GHC
type CoreBndr = Var
type TaggedExpr t = Expr (TaggedBndr t)
type TaggedAlt t = Alt (TaggedBndr t)
type TaggedBind t = Bind (TaggedBndr t)
type TaggedArg t = Arg (TaggedBndr t)

-- | Binders are <i>tagged</i> with a t
data TaggedBndr t
TB :: CoreBndr -> t -> TaggedBndr t
deTagExpr :: TaggedExpr t -> CoreExpr
type InId = Id
type InBind = CoreBind
type InExpr = CoreExpr
type InAlt = CoreAlt
type InArg = CoreArg
type InType = Type
type InKind = Kind
type InBndr = CoreBndr
type InVar = Var
type InCoercion = Coercion
type InTyVar = TyVar
type InCoVar = CoVar
type OutId = Id
type OutBind = CoreBind
type OutExpr = CoreExpr
type OutAlt = CoreAlt
type OutArg = CoreArg
type OutType = Type
type OutKind = Kind
type OutBndr = CoreBndr
type OutVar = Var
type OutCoercion = Coercion
type OutTyVar = TyVar
type OutCoVar = CoVar
type MOutCoercion = MCoercion
mkLet :: Bind b -> Expr b -> Expr b

-- | Bind all supplied binding groups over an expression in a nested let
--   expression. Assumes that the rhs satisfies the let-can-float
--   invariant. Prefer to use <a>mkCoreLets</a> if possible, which does
--   guarantee the invariant
mkLets :: [Bind b] -> Expr b -> Expr b

-- | <tt>mkLetNonRec bndr rhs body</tt> wraps <tt>body</tt> in a
--   <tt>let</tt> binding <tt>bndr</tt>.
mkLetNonRec :: b -> Expr b -> Expr b -> Expr b

-- | <tt>mkLetRec binds body</tt> wraps <tt>body</tt> in a <tt>let rec</tt>
--   with the given set of <tt>binds</tt> if binds is non-empty.
mkLetRec :: [(b, Expr b)] -> Expr b -> Expr b

-- | Bind all supplied binders over an expression in a nested lambda
--   expression. Prefer to use <a>mkCoreLams</a> if possible
mkLams :: [b] -> Expr b -> Expr b

-- | Apply a list of argument expressions to a function expression in a
--   nested fashion. Prefer to use <a>mkCoreApps</a> if possible
mkApps :: Expr b -> [Arg b] -> Expr b
infixl 4 `mkApps`

-- | Apply a list of type argument expressions to a function expression in
--   a nested fashion
mkTyApps :: Expr b -> [Type] -> Expr b
infixl 4 `mkTyApps`

-- | Apply a list of coercion argument expressions to a function expression
--   in a nested fashion
mkCoApps :: Expr b -> [Coercion] -> Expr b
infixl 4 `mkCoApps`

-- | Apply a list of type or value variables to a function expression in a
--   nested fashion
mkVarApps :: Expr b -> [Var] -> Expr b
infixl 4 `mkVarApps`
mkTyArg :: Type -> Expr b

-- | Create a machine integer literal expression of type <tt>Int#</tt> from
--   an <tt>Integer</tt>. If you want an expression of type <tt>Int</tt>
--   use <a>mkIntExpr</a>
mkIntLit :: Platform -> Integer -> Expr b

-- | Create a machine integer literal expression of type <tt>Int#</tt> from
--   an <tt>Integer</tt>, wrapping if necessary. If you want an expression
--   of type <tt>Int</tt> use <a>mkIntExpr</a>
mkIntLitWrap :: Platform -> Integer -> Expr b

-- | Create a machine word literal expression of type <tt>Word#</tt> from
--   an <tt>Integer</tt>. If you want an expression of type <tt>Word</tt>
--   use <a>mkWordExpr</a>
mkWordLit :: Platform -> Integer -> Expr b

-- | Create a machine word literal expression of type <tt>Word#</tt> from
--   an <tt>Integer</tt>, wrapping if necessary. If you want an expression
--   of type <tt>Word</tt> use <a>mkWordExpr</a>
mkWordLitWrap :: Platform -> Integer -> Expr b
mkWord8Lit :: Integer -> Expr b
mkWord64LitWord64 :: Word64 -> Expr b
mkInt64LitInt64 :: Int64 -> Expr b

-- | Create a machine character literal expression of type <tt>Char#</tt>.
--   If you want an expression of type <tt>Char</tt> use <a>mkCharExpr</a>
mkCharLit :: Char -> Expr b

-- | Create a machine string literal expression of type <tt>Addr#</tt>. If
--   you want an expression of type <tt>String</tt> use <a>mkStringExpr</a>
mkStringLit :: String -> Expr b

-- | Create a machine single precision literal expression of type
--   <tt>Float#</tt> from a <tt>Rational</tt>. If you want an expression of
--   type <tt>Float</tt> use <a>mkFloatExpr</a>
mkFloatLit :: Rational -> Expr b

-- | Create a machine single precision literal expression of type
--   <tt>Float#</tt> from a <tt>Float</tt>. If you want an expression of
--   type <tt>Float</tt> use <a>mkFloatExpr</a>
mkFloatLitFloat :: Float -> Expr b

-- | Create a machine double precision literal expression of type
--   <tt>Double#</tt> from a <tt>Rational</tt>. If you want an expression
--   of type <tt>Double</tt> use <a>mkDoubleExpr</a>
mkDoubleLit :: Rational -> Expr b

-- | Create a machine double precision literal expression of type
--   <tt>Double#</tt> from a <tt>Double</tt>. If you want an expression of
--   type <tt>Double</tt> use <a>mkDoubleExpr</a>
mkDoubleLitDouble :: Double -> Expr b

-- | Apply a list of argument expressions to a data constructor in a nested
--   fashion. Prefer to use <a>mkCoreConApps</a> if possible
mkConApp :: DataCon -> [Arg b] -> Expr b
mkConApp2 :: DataCon -> [Type] -> [Var] -> Expr b

-- | Create a binding group where a type variable is bound to a type. Per
--   Note [Core type and coercion invariant], this can only be used to bind
--   something in a non-recursive <tt>let</tt> expression
mkTyBind :: TyVar -> Type -> CoreBind

-- | Create a binding group where a type variable is bound to a type. Per
--   Note [Core type and coercion invariant], this can only be used to bind
--   something in a non-recursive <tt>let</tt> expression
mkCoBind :: CoVar -> Coercion -> CoreBind

-- | Convert a binder into either a <a>Expr</a> or <a>Type</a> <a>Expr</a>
--   appropriately
varToCoreExpr :: CoreBndr -> Expr b
varsToCoreExprs :: [CoreBndr] -> [Expr b]

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Var</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool

-- | Compares <a>AltCon</a>s within a single list of alternatives DEFAULT
--   comes out smallest, so that sorting by AltCon puts alternatives in the
--   order required: see Note [Case expression invariants]
cmpAltCon :: AltCon -> AltCon -> Ordering
cmpAlt :: Alt a -> Alt a -> Ordering
ltAlt :: Alt a -> Alt a -> Bool

-- | Extract every variable by this group
bindersOf :: Bind b -> [b]

-- | <a>bindersOf</a> applied to a list of binding groups
bindersOfBinds :: [Bind b] -> [b]
rhssOfBind :: Bind b -> [Expr b]
rhssOfAlts :: [Alt b] -> [Expr b]
foldBindersOfBindStrict :: (a -> b -> a) -> a -> Bind b -> a
foldBindersOfBindsStrict :: (a -> b -> a) -> a -> [Bind b] -> a

-- | We often want to strip off leading lambdas before getting down to
--   business. Variants are <a>collectTyBinders</a>,
--   <a>collectValBinders</a>, and <a>collectTyAndValBinders</a>
collectBinders :: Expr b -> ([b], Expr b)
collectTyBinders :: CoreExpr -> ([TyVar], CoreExpr)
collectTyAndValBinders :: CoreExpr -> ([TyVar], [Id], CoreExpr)

-- | Strip off exactly N leading lambdas (type or value). Good for use with
--   join points. Panic if there aren't enough
collectNBinders :: JoinArity -> Expr b -> ([b], Expr b)

-- | Strip off exactly N leading value lambdas returning all the binders
--   found up to that point Return Nothing if there aren't enough
collectNValBinders_maybe :: Arity -> CoreExpr -> Maybe ([Var], CoreExpr)

-- | Takes a nested application expression and returns the function being
--   applied and the arguments to which it is applied
collectArgs :: Expr b -> (Expr b, [Arg b])

-- | Attempt to remove the last N arguments of a function call. Strip off
--   any ticks or coercions encountered along the way and any at the end.
stripNArgs :: Word -> Expr a -> Maybe (Expr a)

-- | Like <tt>collectArgs</tt>, but also collects looks through floatable
--   ticks if it means that we can find more arguments.
collectArgsTicks :: (CoreTickish -> Bool) -> Expr b -> (Expr b, [Arg b], [CoreTickish])

-- | Collapse all the bindings in the supplied groups into a single list of
--   lhs/rhs pairs suitable for binding in a <a>Rec</a> binding group
flattenBinds :: [Bind b] -> [(b, Expr b)]

-- | Takes a nested application expression and returns the function being
--   applied. Looking through casts and ticks to find it.
collectFunSimple :: Expr b -> Expr b

-- | If the expression is a <a>Type</a>, converts. Otherwise, panics. NB:
--   This does <i>not</i> convert <a>Coercion</a> to <tt>CoercionTy</tt>.
exprToType :: CoreExpr -> Type

-- | fmap on the body of a lambda. wrapLamBody f (x -&gt; body) == (x -&gt;
--   f body)
wrapLamBody :: (CoreExpr -> CoreExpr) -> CoreExpr -> CoreExpr

-- | Returns <tt>True</tt> for value arguments, false for type args NB:
--   coercions are value arguments (zero width, to be sure, like State#,
--   but still value args).
isValArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Type</a> expression
--   at its top level. Note this does NOT include <a>Coercion</a>s.
isTypeArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Coercion</a>
--   expression at its top level
isCoArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Type</a> or
--   <a>Coercion</a> expression at its top level
isTyCoArg :: Expr b -> Bool

-- | The number of argument expressions that are values rather than types
--   at their top level
valArgCount :: [Arg b] -> Int

-- | The number of binders that bind values rather than types
valBndrCount :: [CoreBndr] -> Int

-- | Will this argument expression exist at runtime?
isRuntimeArg :: CoreExpr -> Bool

-- | Will this variable exist at runtime?
isRuntimeVar :: Var -> Bool

-- | Records the <i>unfolding</i> of an identifier, which is approximately
--   the form the identifier would have if we substituted its definition in
--   for the identifier. This type should be treated as abstract everywhere
--   except in <a>GHC.Core.Unfold</a>
data Unfolding

-- | We have no information about the unfolding.
NoUnfolding :: Unfolding

-- | We have no information about the unfolding, because this <a>Id</a>
--   came from an <tt>hi-boot</tt> file. See Note [Inlining and hs-boot
--   files] in <a>GHC.CoreToIface</a> for what this is used for.
BootUnfolding :: Unfolding

-- | It ain't one of these constructors. <tt>OtherCon xs</tt> also
--   indicates that something has been evaluated and hence there's no point
--   in re-evaluating it. <tt>OtherCon []</tt> is used even for
--   non-data-type values to indicated evaluated-ness. Notably:
--   
--   <pre>
--   data C = C !(Int -&gt; Int)
--   case x of { C f -&gt; ... }
--   </pre>
--   
--   Here, <tt>f</tt> gets an <tt>OtherCon []</tt> unfolding.
OtherCon :: [AltCon] -> Unfolding
DFunUnfolding :: [Var] -> DataCon -> [CoreExpr] -> Unfolding
[df_bndrs] :: Unfolding -> [Var]
[df_con] :: Unfolding -> DataCon
[df_args] :: Unfolding -> [CoreExpr]

-- | An unfolding with redundant cached information. Parameters:
--   
--   uf_tmpl: Template used to perform unfolding; NB: Occurrence info is
--   guaranteed correct: see Note [OccInfo in unfoldings and rules]
--   
--   uf_is_top: Is this a top level binding?
--   
--   uf_is_value: <tt>exprIsHNF</tt> template (cached); it is ok to discard
--   a <a>seq</a> on this variable
--   
--   uf_is_work_free: Does this waste only a little work if we expand it
--   inside an inlining? Basically this is a cached version of
--   <tt>exprIsWorkFree</tt>
--   
--   uf_guidance: Tells us about the <i>size</i> of the unfolding template
CoreUnfolding :: CoreExpr -> UnfoldingSource -> Bool -> UnfoldingCache -> UnfoldingGuidance -> Unfolding
[uf_tmpl] :: Unfolding -> CoreExpr
[uf_src] :: Unfolding -> UnfoldingSource
[uf_is_top] :: Unfolding -> Bool
[uf_cache] :: Unfolding -> UnfoldingCache
[uf_guidance] :: Unfolding -> UnfoldingGuidance

-- | Properties of a <a>CoreUnfolding</a> that could be computed on-demand
--   from its template. See Note [UnfoldingCache]
data UnfoldingCache
UnfoldingCache :: !Bool -> !Bool -> !Bool -> !Bool -> UnfoldingCache
[uf_is_value] :: UnfoldingCache -> !Bool
[uf_is_conlike] :: UnfoldingCache -> !Bool
[uf_is_work_free] :: UnfoldingCache -> !Bool
[uf_expandable] :: UnfoldingCache -> !Bool

-- | <a>UnfoldingGuidance</a> says when unfolding should take place
data UnfoldingGuidance
UnfWhen :: Arity -> Bool -> Bool -> UnfoldingGuidance
[ug_arity] :: UnfoldingGuidance -> Arity
[ug_unsat_ok] :: UnfoldingGuidance -> Bool
[ug_boring_ok] :: UnfoldingGuidance -> Bool
UnfIfGoodArgs :: [Int] -> Int -> Int -> UnfoldingGuidance
[ug_args] :: UnfoldingGuidance -> [Int]
[ug_size] :: UnfoldingGuidance -> Int
[ug_res] :: UnfoldingGuidance -> Int
UnfNever :: UnfoldingGuidance
data UnfoldingSource
VanillaSrc :: UnfoldingSource
StableUserSrc :: UnfoldingSource
StableSystemSrc :: UnfoldingSource
CompulsorySrc :: UnfoldingSource

-- | There is no known <a>Unfolding</a>
noUnfolding :: Unfolding

-- | There is no known <a>Unfolding</a>, because this came from an hi-boot
--   file.
bootUnfolding :: Unfolding

-- | This unfolding marks the associated thing as being evaluated
evaldUnfolding :: Unfolding
mkOtherCon :: [AltCon] -> Unfolding
unSaturatedOk :: Bool
needSaturated :: Bool
boringCxtOk :: Bool
boringCxtNotOk :: Bool

-- | Retrieves the template of an unfolding: panics if none is known
unfoldingTemplate :: Unfolding -> CoreExpr
expandUnfolding_maybe :: Unfolding -> Maybe CoreExpr

-- | Retrieves the template of an unfolding if possible
--   maybeUnfoldingTemplate is used mainly when specialising, and we do
--   want to specialise DFuns, so it's important to return a template for
--   DFunUnfoldings
maybeUnfoldingTemplate :: Unfolding -> Maybe CoreExpr

-- | The constructors that the unfolding could never be: returns
--   <tt>[]</tt> if no information is available
otherCons :: Unfolding -> [AltCon]

-- | Determines if it is certainly the case that the unfolding will yield a
--   value (something in HNF): returns <tt>False</tt> if unsure
isValueUnfolding :: Unfolding -> Bool

-- | Determines if it possibly the case that the unfolding will yield a
--   value. Unlike <a>isValueUnfolding</a> it returns <tt>True</tt> for
--   <a>OtherCon</a>
isEvaldUnfolding :: Unfolding -> Bool

-- | Is the thing we will unfold into certainly cheap?
isCheapUnfolding :: Unfolding -> Bool
isExpandableUnfolding :: Unfolding -> Bool

-- | <tt>True</tt> if the unfolding is a constructor application, the
--   application of a CONLIKE function or <a>OtherCon</a>
isConLikeUnfolding :: Unfolding -> Bool
isCompulsoryUnfolding :: Unfolding -> Bool
isStableUnfolding :: Unfolding -> Bool
isStableUserUnfolding :: Unfolding -> Bool
isStableSystemUnfolding :: Unfolding -> Bool

-- | True of a <i>stable</i> unfolding that is (a) always inlined; that is,
--   with an <a>UnfWhen</a> guidance, or (b) a DFunUnfolding which never
--   needs to be inlined
isInlineUnfolding :: Unfolding -> Bool
isBootUnfolding :: Unfolding -> Bool
hasCoreUnfolding :: Unfolding -> Bool

-- | Only returns False if there is no unfolding information available at
--   all
hasSomeUnfolding :: Unfolding -> Bool
canUnfold :: Unfolding -> Bool
neverUnfoldGuidance :: UnfoldingGuidance -> Bool
isStableSource :: UnfoldingSource -> Bool

-- | Annotated core: allows annotation at every node in the tree
type AnnExpr bndr annot = (annot, AnnExpr' bndr annot)

-- | A clone of the <a>Expr</a> type but allowing annotation at every tree
--   node
data AnnExpr' bndr annot
AnnVar :: Id -> AnnExpr' bndr annot
AnnLit :: Literal -> AnnExpr' bndr annot
AnnLam :: bndr -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnApp :: AnnExpr bndr annot -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnCase :: AnnExpr bndr annot -> bndr -> Type -> [AnnAlt bndr annot] -> AnnExpr' bndr annot
AnnLet :: AnnBind bndr annot -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnCast :: AnnExpr bndr annot -> (annot, Coercion) -> AnnExpr' bndr annot
AnnTick :: CoreTickish -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnType :: Type -> AnnExpr' bndr annot
AnnCoercion :: Coercion -> AnnExpr' bndr annot

-- | A clone of the <a>Bind</a> type but allowing annotation at every tree
--   node
data AnnBind bndr annot
AnnNonRec :: bndr -> AnnExpr bndr annot -> AnnBind bndr annot
AnnRec :: [(bndr, AnnExpr bndr annot)] -> AnnBind bndr annot

-- | A clone of the <a>Alt</a> type but allowing annotation at every tree
--   node
data AnnAlt bndr annot
AnnAlt :: AltCon -> [bndr] -> AnnExpr bndr annot -> AnnAlt bndr annot

-- | Takes a nested application expression and returns the function being
--   applied and the arguments to which it is applied
collectAnnArgs :: AnnExpr b a -> (AnnExpr b a, [AnnExpr b a])
collectAnnArgsTicks :: (CoreTickish -> Bool) -> AnnExpr b a -> (AnnExpr b a, [AnnExpr b a], [CoreTickish])
deAnnotate :: AnnExpr bndr annot -> Expr bndr
deAnnotate' :: AnnExpr' bndr annot -> Expr bndr
deAnnAlt :: AnnAlt bndr annot -> Alt bndr
deAnnBind :: AnnBind b annot -> Bind b

-- | As <a>collectBinders</a> but for <a>AnnExpr</a> rather than
--   <a>Expr</a>
collectAnnBndrs :: AnnExpr bndr annot -> ([bndr], AnnExpr bndr annot)

-- | As <a>collectNBinders</a> but for <a>AnnExpr</a> rather than
--   <a>Expr</a>
collectNAnnBndrs :: Int -> AnnExpr bndr annot -> ([bndr], AnnExpr bndr annot)

-- | Is this instance an orphan? If it is not an orphan, contains an
--   <a>OccName</a> witnessing the instance's non-orphanhood. See Note
--   [Orphans]
data IsOrphan
IsOrphan :: IsOrphan
NotOrphan :: !OccName -> IsOrphan

-- | Returns true if <a>IsOrphan</a> is orphan.
isOrphan :: IsOrphan -> Bool

-- | Returns true if <a>IsOrphan</a> is not an orphan.
notOrphan :: IsOrphan -> Bool
chooseOrphanAnchor :: NameSet -> IsOrphan

-- | A <a>CoreRule</a> is:
--   
--   <ul>
--   <li>"Local" if the function it is a rule for is defined in the same
--   module as the rule itself.</li>
--   <li>"Orphan" if nothing on the LHS is defined in the same module as
--   the rule itself</li>
--   </ul>
data CoreRule
Rule :: RuleName -> Activation -> !Name -> [Maybe Name] -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> Bool -> !Module -> !IsOrphan -> Bool -> CoreRule

-- | Name of the rule, for communication with the user
[ru_name] :: CoreRule -> RuleName

-- | When the rule is active
[ru_act] :: CoreRule -> Activation

-- | Name of the <a>Id</a> at the head of this rule
[ru_fn] :: CoreRule -> !Name

-- | Name at the head of each argument to the left hand side
[ru_rough] :: CoreRule -> [Maybe Name]

-- | Variables quantified over
[ru_bndrs] :: CoreRule -> [CoreBndr]

-- | Left hand side arguments
[ru_args] :: CoreRule -> [CoreExpr]

-- | Right hand side of the rule Occurrence info is guaranteed correct See
--   Note [OccInfo in unfoldings and rules]
[ru_rhs] :: CoreRule -> CoreExpr

-- | <tt>True</tt> <a>=</a> this rule is auto-generated (notably by
--   Specialise or SpecConstr) <tt>False</tt> <a>=</a> generated at the
--   user's behest See Note [Trimming auto-rules] in <a>GHC.Iface.Tidy</a>
--   for the sole purpose of this field.
[ru_auto] :: CoreRule -> Bool

-- | <a>GenModule</a> the rule was defined in, used to test if we should
--   see an orphan rule.
[ru_origin] :: CoreRule -> !Module

-- | Whether or not the rule is an orphan.
[ru_orphan] :: CoreRule -> !IsOrphan

-- | <tt>True</tt> iff the fn at the head of the rule is defined in the
--   same module as the rule and is not an implicit <a>Id</a> (like a
--   record selector, class operation, or data constructor). This is
--   different from <a>ru_orphan</a>, where a rule can avoid being an
--   orphan if *any* Name in LHS of the rule was defined in the same module
--   as the rule.
[ru_local] :: CoreRule -> Bool

-- | Built-in rules are used for constant folding and suchlike. They have
--   no free variables. A built-in rule is always visible (there is no such
--   thing as an orphan built-in rule.)
BuiltinRule :: RuleName -> Name -> Int -> RuleFun -> CoreRule

-- | Name of the rule, for communication with the user
[ru_name] :: CoreRule -> RuleName

-- | Name of the <a>Id</a> at the head of this rule
[ru_fn] :: CoreRule -> Name

-- | Number of arguments that <a>ru_try</a> consumes, if it fires,
--   including type arguments
[ru_nargs] :: CoreRule -> Int

-- | This function does the rewrite. It given too many arguments, it simply
--   discards them; the returned <a>CoreExpr</a> is just the rewrite of
--   <a>ru_fn</a> applied to the first <a>ru_nargs</a> args
[ru_try] :: CoreRule -> RuleFun
type RuleName = FastString
type RuleFun = RuleOpts -> InScopeEnv -> Id -> [CoreExpr] -> Maybe CoreExpr
type IdUnfoldingFun = Id -> Unfolding

-- | The <a>InScopeSet</a> in the <a>InScopeEnv</a> is a <i>superset</i> of
--   variables that are currently in scope. See Note [The InScopeSet
--   invariant].
data InScopeEnv
ISE :: InScopeSet -> IdUnfoldingFun -> InScopeEnv

-- | Rule options
data RuleOpts

-- | The number of arguments the <a>ru_fn</a> must be applied to before the
--   rule can match on it
ruleArity :: CoreRule -> Int
ruleName :: CoreRule -> RuleName

-- | The <a>Name</a> of the <a>Id</a> at the head of the rule left hand
--   side
ruleIdName :: CoreRule -> Name
ruleActivation :: CoreRule -> Activation

-- | Set the <a>Name</a> of the <a>Id</a> at the head of the rule left hand
--   side
setRuleIdName :: Name -> CoreRule -> CoreRule
ruleModule :: CoreRule -> Maybe Module
isBuiltinRule :: CoreRule -> Bool
isLocalRule :: CoreRule -> Bool
isAutoRule :: CoreRule -> Bool
instance Data.Data.Data GHC.Core.AltCon
instance GHC.Classes.Eq GHC.Core.AltCon
instance Data.Data.Data b => Data.Data.Data (GHC.Core.Alt b)
instance Data.Data.Data b => Data.Data.Data (GHC.Core.Expr b)
instance Data.Data.Data b => Data.Data.Data (GHC.Core.Bind b)
instance Data.Data.Data GHC.Core.IsOrphan
instance GHC.Classes.Eq GHC.Core.UnfoldingCache
instance GHC.Classes.Eq GHC.Core.UnfoldingGuidance
instance GHC.Utils.Outputable.Outputable b => GHC.Utils.Outputable.Outputable (GHC.Core.TaggedBndr b)
instance GHC.Utils.Binary.Binary GHC.Core.IsOrphan
instance GHC.Classes.Ord GHC.Core.AltCon
instance GHC.Utils.Outputable.Outputable GHC.Core.AltCon

module GHC.Types.Id.Info

-- | Identifier Details
--   
--   The <a>IdDetails</a> of an <tt>Id</tt> give stable, and necessary,
--   information about the Id.
data IdDetails
VanillaId :: IdDetails

-- | The <tt>Id</tt> for a record selector
RecSelId :: RecSelParent -> Bool -> IdDetails
[sel_tycon] :: IdDetails -> RecSelParent
[sel_naughty] :: IdDetails -> Bool

-- | The <tt>Id</tt> is for a data constructor <i>worker</i>
DataConWorkId :: DataCon -> IdDetails

-- | The <tt>Id</tt> is for a data constructor <i>wrapper</i>
DataConWrapId :: DataCon -> IdDetails

-- | The <tt>Id</tt> is a superclass selector, or class operation of a
--   class
ClassOpId :: Class -> IdDetails

-- | The <tt>Id</tt> is for a primitive operator True <a>=</a> is
--   representation-polymorphic, and hence has no binding This lev-poly
--   flag is used only in GHC.Types.Id.hasNoBinding
PrimOpId :: PrimOp -> Bool -> IdDetails

-- | The <tt>Id</tt> is for a foreign call. Type will be simple: no type
--   families, newtypes, etc
FCallId :: ForeignCall -> IdDetails

-- | The <tt>Id</tt> is for a HPC tick box (both traditional and binary)
TickBoxOpId :: TickBoxOp -> IdDetails

-- | A dictionary function. Bool = True <a>=</a> the class has only one
--   method, so may be implemented with a newtype, so it might be bad to be
--   strict on this dictionary
DFunId :: Bool -> IdDetails

-- | A coercion variable This only covers <i>un-lifted</i> coercions, of
--   type (t1 ~# t2) or (t1 ~R# t2), not their lifted variants
CoVarId :: IdDetails

-- | An <tt>Id</tt> for a join point taking n arguments Note [Join points]
--   in <a>GHC.Core</a> Can also work as a WorkerLikeId if given
--   <a>CbvMark</a>s. See Note [CBV Function Ids] The [CbvMark] is always
--   empty (and ignored) until after Tidy.
JoinId :: JoinArity -> Maybe [CbvMark] -> IdDetails

-- | An <tt>Id</tt> for a worker like function, which might expect some
--   arguments to be passed both evaluated and tagged. Worker like
--   functions are create by W/W and SpecConstr and we can expect that they
--   aren't used unapplied. See Note [CBV Function Ids] See Note [Tag
--   Inference] The [CbvMark] is always empty (and ignored) until after
--   Tidy for ids from the current module.
WorkerLikeId :: [CbvMark] -> IdDetails
pprIdDetails :: IdDetails -> SDoc

-- | Just a synonym for <a>CoVarId</a>. Written separately so it can be
--   exported in the hs-boot file.
coVarDetails :: IdDetails

-- | Check if an <a>IdDetails</a> says <a>CoVarId</a>.
isCoVarDetails :: IdDetails -> Bool

-- | The number of arguments that a join point takes. Unlike the arity of a
--   function, this is a purely syntactic property and is fixed when the
--   join point is created (or converted from a value). Both type and value
--   arguments are counted.
type JoinArity = Int
isJoinIdDetails_maybe :: IdDetails -> Maybe (JoinArity, Maybe [CbvMark])

-- | Recursive Selector Parent
data RecSelParent
RecSelData :: TyCon -> RecSelParent
RecSelPatSyn :: PatSyn -> RecSelParent

-- | Identifier Information
--   
--   An <a>IdInfo</a> gives <i>optional</i> information about an
--   <tt>Id</tt>. If present it never lies, but it may not be present, in
--   which case there is always a conservative assumption which can be
--   made.
--   
--   Two <tt>Id</tt>s may have different info even though they have the
--   same <tt>Unique</tt> (and are hence the same <tt>Id</tt>); for
--   example, one might lack the properties attached to the other.
--   
--   Most of the <a>IdInfo</a> gives information about the value, or
--   definition, of the <tt>Id</tt>, independent of its usage. Exceptions
--   to this are <a>demandInfo</a>, <a>occInfo</a>, <a>oneShotInfo</a> and
--   <a>callArityInfo</a>.
--   
--   Performance note: when we update <a>IdInfo</a>, we have to reallocate
--   this entire record, so it is a good idea not to let this data
--   structure get too big.
data IdInfo

-- | Basic <a>IdInfo</a> that carries no useful information whatsoever
vanillaIdInfo :: IdInfo

-- | More informative <a>IdInfo</a> we can use when we know the <tt>Id</tt>
--   has no CAF references
noCafIdInfo :: IdInfo

-- | If the <tt>Id</tt> is a lambda-bound variable then it may have
--   lambda-bound variable info. Sometimes we know whether the lambda
--   binding this variable is a "one-shot" lambda; that is, whether it is
--   applied at most once.
--   
--   This information may be useful in optimisation, as computations may
--   safely be floated inside such a lambda without risk of duplicating
--   work.
--   
--   See also Note [OneShotInfo overview] above.
data OneShotInfo

-- | No information
NoOneShotInfo :: OneShotInfo

-- | The lambda is applied at most once.
OneShotLam :: OneShotInfo

-- | Info about a lambda-bound variable, if the <tt>Id</tt> is one
oneShotInfo :: IdInfo -> OneShotInfo

-- | It is always safe to assume that an <tt>Id</tt> has no lambda-bound
--   variable information
noOneShotInfo :: OneShotInfo
hasNoOneShotInfo :: OneShotInfo -> Bool
setOneShotInfo :: IdInfo -> OneShotInfo -> IdInfo
infixl 1 `setOneShotInfo`

-- | This is used to remove information on lambda binders that we have
--   setup as part of a lambda group, assuming they will be applied all at
--   once, but turn out to be part of an unsaturated lambda as in e.g:
--   
--   <pre>
--   (\x1. \x2. e) arg1
--   </pre>
zapLamInfo :: IdInfo -> Maybe IdInfo

-- | Zap info that depends on free variables
zapFragileInfo :: IdInfo -> Maybe IdInfo

-- | Remove all demand info on the <a>IdInfo</a>
zapDemandInfo :: IdInfo -> Maybe IdInfo

-- | Remove usage (but not strictness) info on the <a>IdInfo</a>
zapUsageInfo :: IdInfo -> Maybe IdInfo

-- | Remove usage environment info from the strictness signature on the
--   <a>IdInfo</a>
zapUsageEnvInfo :: IdInfo -> Maybe IdInfo
zapUsedOnceInfo :: IdInfo -> Maybe IdInfo
zapTailCallInfo :: IdInfo -> Maybe IdInfo
zapCallArityInfo :: IdInfo -> IdInfo
trimUnfolding :: Unfolding -> Unfolding

-- | Arity Information
--   
--   An <a>ArityInfo</a> of <tt>n</tt> tells us that partial application of
--   this <tt>Id</tt> to up to <tt>n-1</tt> value arguments does
--   essentially no work.
--   
--   That is not necessarily the same as saying that it has <tt>n</tt>
--   leading lambdas, because coerces may get in the way.
--   
--   The arity might increase later in the compilation process, if an extra
--   lambda floats up to the binding site.
--   
--   <i>Invariant:</i> the <a>Arity</a> of an <tt>Id</tt> must never exceed
--   the number of value arguments that appear in the type of the
--   <tt>Id</tt>. See Note [Arity and function types].
type ArityInfo = Arity

-- | It is always safe to assume that an <tt>Id</tt> has an arity of 0
unknownArity :: Arity

-- | <tt>Id</tt> arity, as computed by <a>GHC.Core.Opt.Arity</a>. Specifies
--   how many arguments this <tt>Id</tt> has to be applied to before it
--   does any meaningful work.
arityInfo :: IdInfo -> ArityInfo
setArityInfo :: IdInfo -> ArityInfo -> IdInfo
infixl 1 `setArityInfo`
ppArityInfo :: Int -> SDoc

-- | How this is called. This is the number of arguments to which a binding
--   can be eta-expanded without losing any sharing. n <a>=</a> all calls
--   have at least n arguments
callArityInfo :: IdInfo -> ArityInfo
setCallArityInfo :: IdInfo -> ArityInfo -> IdInfo

-- | A strictness signature. Describes how a function uses its arguments
--   See Note [idArity varies independently of dmdTypeDepth] in
--   GHC.Core.Opt.DmdAnal
dmdSigInfo :: IdInfo -> DmdSig
setDmdSigInfo :: IdInfo -> DmdSig -> IdInfo
infixl 1 `setDmdSigInfo`

-- | Information on whether the function will ultimately return a freshly
--   allocated constructor.
cprSigInfo :: IdInfo -> CprSig
setCprSigInfo :: IdInfo -> CprSig -> IdInfo
infixl 1 `setCprSigInfo`

-- | ID demand information
demandInfo :: IdInfo -> Demand
setDemandInfo :: IdInfo -> Demand -> IdInfo
infixl 1 `setDemandInfo`
pprStrictness :: DmdSig -> SDoc

-- | The <tt>Id</tt>s unfolding
realUnfoldingInfo :: IdInfo -> Unfolding

-- | Essentially returns the <a>realUnfoldingInfo</a> field, but does not
--   expose the unfolding of a strong loop breaker.
--   
--   This is the right thing to call if you plan to decide whether an
--   unfolding will inline.
unfoldingInfo :: IdInfo -> Unfolding
setUnfoldingInfo :: IdInfo -> Unfolding -> IdInfo
infixl 1 `setUnfoldingInfo`

-- | True of a <i>non-loop-breaker</i> Id that has a <i>stable</i>
--   unfolding that is (a) always inlined; that is, with an <a>UnfWhen</a>
--   guidance, or (b) a DFunUnfolding which never needs to be inlined
hasInlineUnfolding :: IdInfo -> Bool

-- | Inline Pragma Information
--   
--   Tells when the inlining is active. When it is active the thing may be
--   inlined, depending on how big it is.
--   
--   If there was an <tt>INLINE</tt> pragma, then as a separate matter, the
--   RHS will have been made to look small with a Core inline <tt>Note</tt>
--   
--   The default <a>InlinePragInfo</a> is <a>AlwaysActive</a>, so the info
--   serves entirely as a way to inhibit inlining until we want it
type InlinePragInfo = InlinePragma

-- | Any inline pragma attached to the <tt>Id</tt>
inlinePragInfo :: IdInfo -> InlinePragma
setInlinePragInfo :: IdInfo -> InlinePragma -> IdInfo
infixl 1 `setInlinePragInfo`

-- | identifier Occurrence Information
data OccInfo

-- | There are many occurrences, or unknown occurrences
ManyOccs :: !TailCallInfo -> OccInfo
[occ_tail] :: OccInfo -> !TailCallInfo

-- | Marks unused variables. Sometimes useful for lambda and case-bound
--   variables.
IAmDead :: OccInfo

-- | Occurs exactly once (per branch), not inside a rule
OneOcc :: !InsideLam -> {-# UNPACK #-} !BranchCount -> !InterestingCxt -> !TailCallInfo -> OccInfo
[occ_in_lam] :: OccInfo -> !InsideLam
[occ_n_br] :: OccInfo -> {-# UNPACK #-} !BranchCount
[occ_int_cxt] :: OccInfo -> !InterestingCxt
[occ_tail] :: OccInfo -> !TailCallInfo

-- | This identifier breaks a loop of mutually recursive functions. The
--   field marks whether it is only a loop breaker due to a reference in a
--   rule
IAmALoopBreaker :: !RulesOnly -> !TailCallInfo -> OccInfo
[occ_rules_only] :: OccInfo -> !RulesOnly
[occ_tail] :: OccInfo -> !TailCallInfo
isDeadOcc :: OccInfo -> Bool
isStrongLoopBreaker :: OccInfo -> Bool
isWeakLoopBreaker :: OccInfo -> Bool

-- | How the <tt>Id</tt> occurs in the program
occInfo :: IdInfo -> OccInfo
setOccInfo :: IdInfo -> OccInfo -> IdInfo
infixl 1 `setOccInfo`

-- | Inside Lambda
data InsideLam

-- | Occurs inside a non-linear lambda Substituting a redex for this
--   occurrence is dangerous because it might duplicate work.
IsInsideLam :: InsideLam
NotInsideLam :: InsideLam
type BranchCount = Int
data TailCallInfo
AlwaysTailCalled :: JoinArity -> TailCallInfo
NoTailCallInfo :: TailCallInfo
tailCallInfo :: OccInfo -> TailCallInfo
isAlwaysTailCalled :: OccInfo -> Bool

-- | Rule Information
--   
--   Records the specializations of this <tt>Id</tt> that we know about in
--   the form of rewrite <a>CoreRule</a>s that target them
data RuleInfo
RuleInfo :: [CoreRule] -> DVarSet -> RuleInfo

-- | Assume that no specializations exist: always safe
emptyRuleInfo :: RuleInfo
isEmptyRuleInfo :: RuleInfo -> Bool

-- | Retrieve the locally-defined free variables of both the left and right
--   hand sides of the specialization rules
ruleInfoFreeVars :: RuleInfo -> DVarSet
ruleInfoRules :: RuleInfo -> [CoreRule]

-- | Change the name of the function the rule is keyed on all of the
--   <a>CoreRule</a>s
setRuleInfoHead :: Name -> RuleInfo -> RuleInfo

-- | Specialisations of the <tt>Id</tt>s function which exist. See Note
--   [Specialisations and RULES in IdInfo]
ruleInfo :: IdInfo -> RuleInfo
setRuleInfo :: IdInfo -> RuleInfo -> IdInfo
infixl 1 `setRuleInfo`
tagSigInfo :: IdInfo -> Maybe TagSig

-- | Constant applicative form Information
--   
--   Records whether an <tt>Id</tt> makes Constant Applicative Form
--   references
data CafInfo

-- | Indicates that the <tt>Id</tt> is for either:
--   
--   <ol>
--   <li>A function or static constructor that refers to one or more CAFs,
--   or</li>
--   <li>A real live CAF</li>
--   </ol>
MayHaveCafRefs :: CafInfo

-- | A function or static constructor that refers to no CAFs.
NoCafRefs :: CafInfo
ppCafInfo :: CafInfo -> SDoc
mayHaveCafRefs :: CafInfo -> Bool

-- | <tt>Id</tt> CAF info
cafInfo :: IdInfo -> CafInfo
setCafInfo :: IdInfo -> CafInfo -> IdInfo
infixl 1 `setCafInfo`

-- | Information about an identifier, from the code generator's point of
--   view. Every identifier is bound to a LambdaFormInfo in the
--   environment, which gives the code generator enough info to be able to
--   tail call or return that identifier.
data LambdaFormInfo

-- | See Note [The LFInfo of Imported Ids] in GHC.StgToCmm.Closure
lfInfo :: IdInfo -> Maybe LambdaFormInfo
setLFInfo :: IdInfo -> LambdaFormInfo -> IdInfo
setTagSig :: IdInfo -> TagSig -> IdInfo
tagSig :: IdInfo -> Maybe TagSig

-- | Tick box for Hpc-style coverage
data TickBoxOp
TickBox :: Module -> {-# UNPACK #-} !TickBoxId -> TickBoxOp
type TickBoxId = Int
instance GHC.Classes.Eq GHC.Types.Id.Info.RecSelParent
instance GHC.Classes.Ord GHC.Types.Id.Info.CafInfo
instance GHC.Classes.Eq GHC.Types.Id.Info.CafInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.IdDetails
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.TickBoxOp
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.CafInfo
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.RecSelParent


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see
--   <a>GHC.Types.Name.Occurrence#name_types</a></li>
--   <li><a>RdrName</a>: see <a>GHC.Types.Name.Reader#name_types</a></li>
--   <li><a>Name</a>: see <a>GHC.Types.Name#name_types</a></li>
--   <li><a>Id</a> represents names that not only have a <a>Name</a> but
--   also a <a>Type</a> and some additional details (a <a>IdInfo</a> and
--   one of LocalIdDetails or GlobalIdDetails) that are added, modified and
--   inspected by various compiler passes. These <a>Var</a> names may
--   either be global or local, see <a>GHC.Types.Var#globalvslocal</a></li>
--   <li><a>Var</a>: see <a>GHC.Types.Var#name_types</a></li>
--   </ul>
module GHC.Types.Id

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Identifier
type Id = Var

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Var</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool
type InVar = Var
type InId = Id
type OutVar = Var
type OutId = Id

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var.Var#globalvslocal</a>
mkGlobalId :: IdDetails -> Name -> Type -> IdInfo -> Id

-- | Make a global <a>Id</a> without any extra information at all
mkVanillaGlobal :: Name -> Type -> Id

-- | Make a global <a>Id</a> with no global information but some generic
--   <a>IdInfo</a>
mkVanillaGlobalWithInfo :: Name -> Type -> IdInfo -> Id

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var#globalvslocal</a>
mkLocalId :: HasDebugCallStack => Name -> Mult -> Type -> Id

-- | Make a local CoVar
mkLocalCoVar :: Name -> Type -> CoVar

-- | Like <a>mkLocalId</a>, but checks the type to see if it should make a
--   covar
mkLocalIdOrCoVar :: Name -> Mult -> Type -> Id
mkLocalIdWithInfo :: HasDebugCallStack => Name -> Mult -> Type -> IdInfo -> Id

-- | Create a local <a>Id</a> that is marked as exported. This prevents
--   things attached to it from being removed as dead code. See Note
--   [Exported LocalIds]
mkExportedLocalId :: IdDetails -> Name -> Type -> Id
mkExportedVanillaId :: Name -> Type -> Id

-- | Create a system local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>Var#globalvslocal</a>) that are created by the compiler out of thin
--   air
mkSysLocal :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Like <a>mkSysLocal</a>, but checks to see if we have a covar type
mkSysLocalOrCoVar :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalOrCoVarM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Create a user local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>GHC.Types.Var#globalvslocal</a>) with a name and location that the
--   user might recognize
mkUserLocal :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Like <a>mkUserLocal</a>, but checks if we have a coercion type
mkUserLocalOrCoVar :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Create a template local for a series of types
mkTemplateLocals :: [Type] -> [Id]

-- | Create a template local for a series of type, but start from a
--   specified template local
mkTemplateLocalsNum :: Int -> [Type] -> [Id]

-- | Create a <i>template local</i>: a family of system local <a>Id</a>s in
--   bijection with <tt>Int</tt>s, typically used in unfoldings
mkTemplateLocal :: Int -> Type -> Id
mkScaledTemplateLocal :: Int -> Scaled Type -> Id

-- | Workers get local names. <a>CoreTidy</a> will externalise these if
--   necessary
mkWorkerId :: Unique -> Id -> Type -> Id
idName :: Id -> Name
idType :: Id -> Kind
idMult :: Id -> Mult
idScaledType :: Id -> Scaled Type
idUnique :: Id -> Unique
idInfo :: HasDebugCallStack => Id -> IdInfo
idDetails :: Id -> IdDetails

-- | If the <a>Id</a> is that for a record selector, extract the
--   <a>sel_tycon</a>. Panic otherwise.
recordSelectorTyCon :: Id -> RecSelParent
recordSelectorTyCon_maybe :: Id -> Maybe RecSelParent
setIdName :: Id -> Name -> Id
setIdUnique :: Id -> Unique -> Id

-- | Not only does this set the <a>Id</a> <a>Type</a>, it also evaluates
--   the type to try and reduce space usage
setIdType :: Id -> Type -> Id
setIdMult :: Id -> Mult -> Id
updateIdTypeButNotMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMultM :: Monad m => (Type -> m Type) -> Id -> m Id
setIdExported :: Id -> Id
setIdNotExported :: Id -> Id

-- | If it's a local, make it global
globaliseId :: Id -> Id
localiseId :: Id -> Id
setIdInfo :: Id -> IdInfo -> Id
lazySetIdInfo :: Id -> IdInfo -> Id
modifyIdInfo :: HasDebugCallStack => (IdInfo -> IdInfo) -> Id -> Id
maybeModifyIdInfo :: Maybe IdInfo -> Id -> Id
zapLamIdInfo :: Id -> Id
zapIdDemandInfo :: Id -> Id
zapIdUsageInfo :: Id -> Id
zapIdUsageEnvInfo :: Id -> Id
zapIdUsedOnceInfo :: Id -> Id
zapIdTailCallInfo :: Id -> Id
zapFragileIdInfo :: Id -> Id
zapIdDmdSig :: Id -> Id
zapStableUnfolding :: Id -> Id
transferPolyIdInfo :: Id -> [Var] -> Id -> Id
scaleIdBy :: Mult -> Id -> Id

-- | Like <a>scaleIdBy</a>, but skips non-Ids. Useful for scaling a mixed
--   list of ids and tyvars.
scaleVarBy :: Mult -> Var -> Var

-- | <a>isImplicitId</a> tells whether an <a>Id</a>s info is implied by
--   other declarations, so we don't need to put its signature in an
--   interface file, even if it's mentioned in some other interface
--   unfolding.
isImplicitId :: Id -> Bool
isDeadBinder :: Id -> Bool

-- | <a>isStrictId</a> says whether either (a) the <a>Id</a> has a strict
--   demand placed on it or (b) definitely has a "strict type", such that
--   it can always be evaluated strictly (i.e an unlifted type) We need to
--   check (b) as well as (a), because when the demand for the given
--   <a>id</a> hasn't been computed yet but <a>id</a> has a strict type, we
--   still want `isStrictId id` to be <a>True</a>. Returns False if the
--   type is levity polymorphic; False is always safe.
isStrictId :: Id -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool
isLocalId :: Var -> Bool
isGlobalId :: Var -> Bool
isRecordSelector :: Id -> Bool
isNaughtyRecordSelector :: Id -> Bool
isPatSynRecordSelector :: Id -> Bool
isDataConRecordSelector :: Id -> Bool
isClassOpId :: Id -> Bool
isClassOpId_maybe :: Id -> Maybe Class
isDFunId :: Id -> Bool
isPrimOpId :: Id -> Bool
isPrimOpId_maybe :: Id -> Maybe PrimOp
isFCallId :: Id -> Bool
isFCallId_maybe :: Id -> Maybe ForeignCall
isDataConWorkId :: Id -> Bool
isDataConWorkId_maybe :: Id -> Maybe DataCon
isDataConWrapId :: Id -> Bool
isDataConWrapId_maybe :: Id -> Maybe DataCon
isDataConId_maybe :: Id -> Maybe DataCon

-- | Get from either the worker or the wrapper <a>Id</a> to the
--   <a>DataCon</a>. Currently used only in the desugarer.
--   
--   INVARIANT: <tt>idDataCon (dataConWrapId d) = d</tt>: remember,
--   <a>dataConWrapId</a> can return either the wrapper or the worker
idDataCon :: Id -> DataCon
isConLikeId :: Id -> Bool

-- | An Id for which we might require all callers to pass strict arguments
--   properly tagged + evaluated.
--   
--   See Note [CBV Function Ids]
isWorkerLikeId :: Id -> Bool

-- | Returns true if an application to n args diverges or throws an
--   exception See Note [Dead ends] in <a>GHC.Types.Demand</a>.
isDeadEndId :: Var -> Bool
idIsFrom :: Module -> Id -> Bool

-- | Returns <tt>True</tt> of an <a>Id</a> which may not have a binding,
--   even though it is defined in this module.
hasNoBinding :: Id -> Bool
type JoinId = Id
isJoinId :: Var -> Bool

-- | Doesn't return strictness marks
isJoinId_maybe :: Var -> Maybe JoinArity
idJoinArity :: JoinId -> JoinArity
asJoinId :: Id -> JoinArity -> JoinId
infixl 1 `asJoinId`
asJoinId_maybe :: Id -> Maybe JoinArity -> Id
infixl 1 `asJoinId_maybe`
zapJoinId :: Id -> Id
idInlinePragma :: Id -> InlinePragma
setInlinePragma :: Id -> InlinePragma -> Id
infixl 1 `setInlinePragma`
modifyInlinePragma :: Id -> (InlinePragma -> InlinePragma) -> Id
idInlineActivation :: Id -> Activation
setInlineActivation :: Id -> Activation -> Id
infixl 1 `setInlineActivation`
idRuleMatchInfo :: Id -> RuleMatchInfo
setOneShotLambda :: Id -> Id
clearOneShotLambda :: Id -> Id
updOneShotInfo :: Id -> OneShotInfo -> Id
setIdOneShotInfo :: Id -> OneShotInfo -> Id
infixl 1 `setIdOneShotInfo`
idArity :: Id -> Arity
idCallArity :: Id -> Arity

-- | This function counts all arguments post-unarisation, which includes
--   arguments with no runtime representation -- see Note [Unarisation and
--   arity]
idFunRepArity :: Id -> RepArity
idSpecialisation :: Id -> RuleInfo
idCoreRules :: Id -> [CoreRule]
idHasRules :: Id -> Bool
idCafInfo :: Id -> CafInfo
infixl 1 `idCafInfo`
idLFInfo_maybe :: Id -> Maybe LambdaFormInfo
idOneShotInfo :: Id -> OneShotInfo
idOccInfo :: Id -> OccInfo
type IdUnfoldingFun = Id -> Unfolding

-- | Returns the <a>Id</a>s unfolding, but does not expose the unfolding of
--   a strong loop breaker. See <a>unfoldingInfo</a>.
--   
--   If you really want the unfolding of a strong loopbreaker, call
--   <a>realIdUnfolding</a>.
idUnfolding :: IdUnfoldingFun

-- | Expose the unfolding if there is one, including for loop breakers
realIdUnfolding :: Id -> Unfolding

-- | Returns an unfolding only if (a) not a strong loop breaker and (b)
--   always active
alwaysActiveUnfoldingFun :: IdUnfoldingFun

-- | Returns an unfolding only if (a) not a strong loop breaker and (b)
--   active in according to is_active
whenActiveUnfoldingFun :: (Activation -> Bool) -> IdUnfoldingFun
noUnfoldingFun :: IdUnfoldingFun
setIdUnfolding :: Id -> Unfolding -> Id
infixl 1 `setIdUnfolding`

-- | Similar to trimUnfolding, but also removes evaldness info.
zapIdUnfolding :: Id -> Id
setCaseBndrEvald :: StrictnessMark -> Id -> Id
setIdArity :: Id -> Arity -> Id
infixl 1 `setIdArity`
setIdCallArity :: Id -> Arity -> Id
infixl 1 `setIdCallArity`
setIdSpecialisation :: Id -> RuleInfo -> Id
infixl 1 `setIdSpecialisation`
setIdCafInfo :: Id -> CafInfo -> Id
setIdOccInfo :: Id -> OccInfo -> Id
infixl 1 `setIdOccInfo`
zapIdOccInfo :: Id -> Id
setIdLFInfo :: Id -> LambdaFormInfo -> Id
setIdDemandInfo :: Id -> Demand -> Id
infixl 1 `setIdDemandInfo`
setIdDmdSig :: Id -> DmdSig -> Id
infixl 1 `setIdDmdSig`
setIdCprSig :: Id -> CprSig -> Id
infixl 1 `setIdCprSig`

-- | If all marks are NotMarkedStrict we just set nothing.
setIdCbvMarks :: Id -> [CbvMark] -> Id
infixl 1 `setIdCbvMarks`
idCbvMarks_maybe :: Id -> Maybe [CbvMark]
idCbvMarkArity :: Id -> Arity

-- | Turn this id into a WorkerLikeId if possible.
asWorkerLikeId :: Id -> Id

-- | Remove any cbv marks on arguments from a given Id.
asNonWorkerLikeId :: Id -> Id
idDemandInfo :: Id -> Demand

-- | Accesses the <tt>Id'</tt>s <a>dmdSigInfo</a>.
idDmdSig :: Id -> DmdSig
idCprSig :: Id -> CprSig
idTagSig_maybe :: Id -> Maybe TagSig
setIdTagSig :: Id -> TagSig -> Id


-- | A global typecheckable-thing, essentially anything that has a name.
module GHC.Types.TyThing

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See
--   <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a> given a
--   <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing

-- | Class that abstracts out the common ability of the monads in GHC to
--   lookup a <a>TyThing</a> in the monadic environment by <a>Name</a>.
--   Provides a number of related convenience functions for accessing
--   particular kinds of <a>TyThing</a>
class Monad m => MonadThings m
lookupThing :: MonadThings m => Name -> m TyThing
lookupId :: MonadThings m => Name -> m Id
lookupDataCon :: MonadThings m => Name -> m DataCon
lookupTyCon :: MonadThings m => Name -> m TyCon
mkATyCon :: TyCon -> TyThing
mkAnId :: Id -> TyThing
pprShortTyThing :: TyThing -> SDoc
pprTyThingCategory :: TyThing -> SDoc
tyThingCategory :: TyThing -> String

-- | Determine the <a>TyThing</a>s brought into scope by another
--   <a>TyThing</a> <i>other</i> than itself. For example, Id's don't have
--   any implicit TyThings as they just bring themselves into scope, but
--   classes bring their dictionary datatype, type constructor and some
--   selector functions into scope, just for a start!
implicitTyThings :: TyThing -> [TyThing]
implicitConLikeThings :: ConLike -> [TyThing]
implicitClassThings :: Class -> [TyThing]
implicitTyConThings :: TyCon -> [TyThing]
implicitCoTyCon :: TyCon -> [TyThing]

-- | Returns <tt>True</tt> if there should be no interface-file declaration
--   for this thing on its own: either it is built-in, or it is part of
--   some other declaration, or it is generated implicitly by some other
--   declaration.
isImplicitTyThing :: TyThing -> Bool

-- | tyThingParent_maybe x returns (Just p) when pprTyThingInContext should
--   print a declaration for p (albeit with some "..." in it) when asked to
--   show x It returns the *immediate* parent. So a datacon returns its
--   tycon but the tycon could be the associated type of a class, so it in
--   turn might have a parent.
tyThingParent_maybe :: TyThing -> Maybe TyThing
tyThingsTyCoVars :: [TyThing] -> TyCoVarSet

-- | The Names that a TyThing should bring into scope. Used to build the
--   GlobalRdrEnv for the InteractiveContext.
tyThingAvailInfo :: TyThing -> [AvailInfo]

-- | Get the <a>TyCon</a> from a <a>TyThing</a> if it is a type constructor
--   thing. Panics otherwise
tyThingTyCon :: HasDebugCallStack => TyThing -> TyCon

-- | Get the <a>CoAxiom</a> from a <a>TyThing</a> if it is a coercion axiom
--   thing. Panics otherwise
tyThingCoAxiom :: HasDebugCallStack => TyThing -> CoAxiom Branched

-- | Get the <a>DataCon</a> from a <a>TyThing</a> if it is a data
--   constructor thing. Panics otherwise
tyThingDataCon :: HasDebugCallStack => TyThing -> DataCon

-- | Get the <a>ConLike</a> from a <a>TyThing</a> if it is a data
--   constructor thing. Panics otherwise
tyThingConLike :: HasDebugCallStack => TyThing -> ConLike

-- | Get the <a>Id</a> from a <a>TyThing</a> if it is a id *or* data
--   constructor thing. Panics otherwise
tyThingId :: HasDebugCallStack => TyThing -> Id
instance GHC.Types.TyThing.MonadThings m => GHC.Types.TyThing.MonadThings (Control.Monad.Trans.Reader.ReaderT s m)
instance GHC.Utils.Outputable.Outputable GHC.Types.TyThing.TyThing
instance GHC.Types.Name.NamedThing GHC.Types.TyThing.TyThing

module GHC.Stg.Subst

-- | A renaming substitution from <a>Id</a>s to <a>Id</a>s. Like
--   <a>RnEnv2</a>, but not maintaining pairs of substitutions. Like
--   <a>Subst</a>, but with the domain being <a>Id</a>s instead of entire
--   <tt>CoreExpr</tt>.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> Subst
type IdSubstEnv = IdEnv Id

-- | <pre>
--   emptySubst = <a>mkEmptySubst</a> <a>emptyInScopeSet</a>
--   </pre>
emptySubst :: Subst

-- | Constructs a new <a>Subst</a> assuming the variables in the given
--   <a>InScopeSet</a> are in scope.
mkEmptySubst :: InScopeSet -> Subst

-- | Substitutes an <a>Id</a> for another one according to the <a>Subst</a>
--   given in a way that avoids shadowing the <a>InScopeSet</a>, returning
--   the result and an updated <a>Subst</a> that should be used by
--   subsequent substitutions.
substBndr :: Id -> Subst -> (Id, Subst)

-- | <pre>
--   substBndrs = runState . traverse (state . substBndr)
--   </pre>
substBndrs :: Traversable f => f Id -> Subst -> (f Id, Subst)

-- | Substitutes an occurrence of an identifier for its counterpart
--   recorded in the <a>Subst</a>.
lookupIdSubst :: HasCallStack => Id -> Subst -> Id

-- | Substitutes an occurrence of an identifier for its counterpart
--   recorded in the <a>Subst</a>. Does not generate a debug warning if the
--   identifier to to substitute wasn't in scope.
noWarnLookupIdSubst :: HasCallStack => Id -> Subst -> Id

-- | Add the <a>Id</a> to the in-scope set and remove any existing
--   substitutions for it.
extendInScope :: Id -> Subst -> Subst

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that TyCoSubst Note [The
--   substitution invariant] holds after extending the substitution like
--   this.
extendSubst :: Id -> Id -> Subst -> Subst

module GHC.Runtime.Eval.Types
data Resume
Resume :: String -> ForeignRef (ResumeContext [HValueRef]) -> ResumeBindings -> [Id] -> ForeignHValue -> Maybe BreakInfo -> SrcSpan -> String -> RemotePtr CostCentreStack -> [History] -> Int -> Resume
[resumeStmt] :: Resume -> String
[resumeContext] :: Resume -> ForeignRef (ResumeContext [HValueRef])
[resumeBindings] :: Resume -> ResumeBindings
[resumeFinalIds] :: Resume -> [Id]
[resumeApStack] :: Resume -> ForeignHValue
[resumeBreakInfo] :: Resume -> Maybe BreakInfo
[resumeSpan] :: Resume -> SrcSpan
[resumeDecl] :: Resume -> String
[resumeCCS] :: Resume -> RemotePtr CostCentreStack
[resumeHistory] :: Resume -> [History]
[resumeHistoryIx] :: Resume -> Int
type ResumeBindings = ([TyThing], IcGlobalRdrEnv)

-- | Essentially a GlobalRdrEnv, but with additional cached values to allow
--   efficient re-calculation when the imports change. Fields are strict to
--   avoid space leaks (see T4029) All operations are in
--   GHC.Runtime.Context. See Note [icReaderEnv recalculation]
data IcGlobalRdrEnv
IcGlobalRdrEnv :: !GlobalRdrEnv -> !GlobalRdrEnv -> IcGlobalRdrEnv

-- | The final environment
[igre_env] :: IcGlobalRdrEnv -> !GlobalRdrEnv

-- | Just the things defined at the prompt (excluding imports!)
[igre_prompt_env] :: IcGlobalRdrEnv -> !GlobalRdrEnv
data History
History :: ForeignHValue -> BreakInfo -> [String] -> History
[historyApStack] :: History -> ForeignHValue
[historyBreakInfo] :: History -> BreakInfo
[historyEnclosingDecls] :: History -> [String]
data ExecResult
ExecComplete :: Either SomeException [Name] -> Word64 -> ExecResult
[execResult] :: ExecResult -> Either SomeException [Name]
[execAllocation] :: ExecResult -> Word64
ExecBreak :: [Name] -> Maybe BreakInfo -> ExecResult
[breakNames] :: ExecResult -> [Name]
[breakInfo] :: ExecResult -> Maybe BreakInfo
data SingleStep
RunToCompletion :: SingleStep
SingleStep :: SingleStep
RunAndLogSteps :: SingleStep
isStep :: SingleStep -> Bool
data ExecOptions
ExecOptions :: SingleStep -> String -> Int -> (ForeignHValue -> EvalExpr ForeignHValue) -> ExecOptions

-- | stepping mode
[execSingleStep] :: ExecOptions -> SingleStep

-- | filename (for errors)
[execSourceFile] :: ExecOptions -> String

-- | line number (for errors)
[execLineNumber] :: ExecOptions -> Int
[execWrap] :: ExecOptions -> ForeignHValue -> EvalExpr ForeignHValue


-- | Functions to computing the statistics reflective of the "size" of a
--   Core expression
module GHC.Core.Stats
coreBindsSize :: [CoreBind] -> Int

-- | A measure of the size of the expressions, strictly greater than 0
--   Counts *leaves*, not internal nodes. Types and coercions are not
--   counted.
exprSize :: CoreExpr -> Int
data CoreStats
CS :: !Int -> !Int -> !Int -> !Int -> !Int -> CoreStats
[cs_tm] :: CoreStats -> !Int
[cs_ty] :: CoreStats -> !Int
[cs_co] :: CoreStats -> !Int
[cs_vb] :: CoreStats -> !Int
[cs_jb] :: CoreStats -> !Int
coreBindsStats :: [CoreBind] -> CoreStats
exprStats :: CoreExpr -> CoreStats
instance GHC.Utils.Outputable.Outputable GHC.Core.Stats.CoreStats


-- | Various utilities for forcing Core structures
--   
--   It can often be useful to force various parts of the AST. This module
--   provides a number of <tt>seq</tt>-like functions to accomplish this.
module GHC.Core.Seq
seqExpr :: CoreExpr -> ()
seqExprs :: [CoreExpr] -> ()
seqUnfolding :: Unfolding -> ()
seqRules :: [CoreRule] -> ()

-- | Evaluate all the fields of the <a>IdInfo</a> that are generally
--   demanded by the compiler
megaSeqIdInfo :: IdInfo -> ()
seqRuleInfo :: RuleInfo -> ()
seqBinds :: [Bind CoreBndr] -> ()

module GHC.Core.Ppr
pprCoreExpr :: OutputableBndr b => Expr b -> SDoc
pprParendExpr :: OutputableBndr b => Expr b -> SDoc
pprCoreBinding :: OutputableBndr b => Bind b -> SDoc
pprCoreBindings :: OutputableBndr b => [Bind b] -> SDoc
pprCoreAlt :: OutputableBndr a => Alt a -> SDoc
pprCoreBindingWithSize :: CoreBind -> SDoc
pprCoreBindingsWithSize :: [CoreBind] -> SDoc
pprCoreBinder :: BindingSite -> Var -> SDoc
pprCoreBinders :: [Var] -> SDoc
pprId :: Id -> SDoc
pprIds :: [Id] -> SDoc
pprRule :: CoreRule -> SDoc
pprRules :: [CoreRule] -> SDoc
pprOptCo :: Coercion -> SDoc
pprOcc :: OutputableBndr a => LexicalFixity -> a -> SDoc
pprOccWithTick :: OutputableBndr a => LexicalFixity -> PromotionFlag -> a -> SDoc
instance GHC.Utils.Outputable.OutputableBndr b => GHC.Utils.Outputable.Outputable (GHC.Core.Bind b)
instance GHC.Utils.Outputable.OutputableBndr b => GHC.Utils.Outputable.Outputable (GHC.Core.Expr b)
instance GHC.Utils.Outputable.OutputableBndr b => GHC.Utils.Outputable.Outputable (GHC.Core.Alt b)
instance GHC.Utils.Outputable.OutputableBndr GHC.Types.Var.Var
instance GHC.Utils.Outputable.Outputable b => GHC.Utils.Outputable.OutputableBndr (GHC.Core.TaggedBndr b)
instance GHC.Utils.Outputable.Outputable GHC.Types.Id.Info.IdInfo
instance GHC.Utils.Outputable.Outputable GHC.Core.UnfoldingGuidance
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfolding
instance GHC.Utils.Outputable.Outputable GHC.Core.UnfoldingCache
instance GHC.Utils.Outputable.Outputable GHC.Core.CoreRule
instance GHC.Utils.Outputable.Outputable (GHC.Types.Tickish.XTickishId pass) => GHC.Utils.Outputable.Outputable (GHC.Types.Tickish.GenTickish pass)


-- | Source-language literals
module GHC.Hs.Lit
data OverLitRn
OverLitRn :: Bool -> LIdP GhcRn -> OverLitRn
[$sel:ol_rebindable:OverLitRn] :: OverLitRn -> Bool
[$sel:ol_from_fun:OverLitRn] :: OverLitRn -> LIdP GhcRn
data OverLitTc
OverLitTc :: Bool -> HsExpr GhcTc -> Type -> OverLitTc
[$sel:ol_rebindable:OverLitTc] :: OverLitTc -> Bool
[$sel:ol_witness:OverLitTc] :: OverLitTc -> HsExpr GhcTc
[$sel:ol_type:OverLitTc] :: OverLitTc -> Type
pprXOverLit :: GhcPass p -> XOverLit (GhcPass p) -> SDoc
overLitType :: HsOverLit GhcTc -> Type

-- | <tt><a>hsOverLitNeedsParens</a> p ol</tt> returns <a>True</a> if an
--   overloaded literal <tt>ol</tt> needs to be parenthesized under
--   precedence <tt>p</tt>.
hsOverLitNeedsParens :: PprPrec -> HsOverLit x -> Bool

-- | <tt><a>hsLitNeedsParens</a> p l</tt> returns <a>True</a> if a literal
--   <tt>l</tt> needs to be parenthesized under precedence <tt>p</tt>.
--   
--   See Note [Printing of literals in Core] in GHC.Types.Literal for the
--   reasoning.
hsLitNeedsParens :: PprPrec -> HsLit x -> Bool

-- | Convert a literal from one index type to another
convertLit :: HsLit (GhcPass p1) -> HsLit (GhcPass p2)

-- | pmPprHsLit pretty prints literals and is used when pretty printing
--   pattern match warnings. All are printed the same (i.e., without hashes
--   if they are primitive and not wrapped in constructors if they are
--   boxed). This happens mainly for too reasons: * We do not want to
--   expose their internal representation * The warnings become too messy
pmPprHsLit :: HsLit (GhcPass x) -> SDoc
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Lit.HsLit (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Lit.HsOverLit (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Lit.OverLitVal

module GHC.Core.Map.Expr

-- | <tt>CoreMap a</tt> is a map from <a>CoreExpr</a> to <tt>a</tt>. If you
--   are a client, this is the type you want.
data CoreMap a
emptyCoreMap :: CoreMap a
extendCoreMap :: CoreMap a -> CoreExpr -> a -> CoreMap a
lookupCoreMap :: CoreMap a -> CoreExpr -> Maybe a
foldCoreMap :: (a -> b -> b) -> b -> CoreMap a -> b
eqDeBruijnExpr :: DeBruijn CoreExpr -> DeBruijn CoreExpr -> Bool
eqCoreExpr :: CoreExpr -> CoreExpr -> Bool
class Functor m => TrieMap m where {
    type Key m :: Type;
}
emptyTM :: TrieMap m => m a
lookupTM :: forall b. TrieMap m => Key m -> m b -> Maybe b
alterTM :: forall b. TrieMap m => Key m -> XT b -> m b -> m b
filterTM :: TrieMap m => (a -> Bool) -> m a -> m a
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
insertTM :: TrieMap m => Key m -> a -> m a -> m a
deleteTM :: TrieMap m => Key m -> m a -> m a
lkDFreeVar :: Var -> DVarEnv a -> Maybe a
xtDFreeVar :: Var -> XT a -> DVarEnv a -> DVarEnv a
lkDNamed :: NamedThing n => n -> DNameEnv a -> Maybe a
xtDNamed :: NamedThing n => n -> XT a -> DNameEnv a -> DNameEnv a
(>.>) :: (a -> b) -> (b -> c) -> a -> c
infixr 1 >.>
(|>) :: a -> (a -> b) -> b
infixr 1 |>
(|>>) :: TrieMap m2 => (XT (m2 a) -> m1 (m2 a) -> m1 (m2 a)) -> (m2 a -> m2 a) -> m1 (m2 a) -> m1 (m2 a)
infixr 1 |>>
instance GHC.Base.Functor GHC.Core.Map.Expr.CoreMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Expr.CoreMap
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Core.Map.Expr.CoreMap a)
instance GHC.Base.Functor GHC.Core.Map.Expr.CoreMapX
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Expr.CoreMapX
instance GHC.Base.Functor GHC.Core.Map.Expr.AltMap
instance GHC.Data.TrieMap.TrieMap GHC.Core.Map.Expr.AltMap
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.CoreExpr)
instance GHC.Classes.Eq (GHC.Core.Map.Type.DeBruijn GHC.Core.CoreAlt)


-- | This module is about types that can be defined in Haskell, but which
--   must be wired into the compiler nonetheless. C.f module
--   <a>GHC.Builtin.Types.Prim</a>
module GHC.Builtin.Types
mkWiredInTyConName :: BuiltInSyntax -> Module -> FastString -> Unique -> TyCon -> Name
mkWiredInIdName :: Module -> FastString -> Unique -> Id -> Name
wiredInTyCons :: [TyCon]

-- | Built-in syntax isn't "in scope" so these OccNames map to wired-in
--   Names with BuiltInSyntax. However, this should only be necessary while
--   resolving names produced by Template Haskell splices since we take
--   care to encode built-in syntax names specially in interface files. See
--   Note [Symbol table representation of names].
--   
--   Moreover, there is no need to include names of things that the user
--   can't write (e.g. type representation bindings like $tc(,,,)).
isBuiltInOcc_maybe :: OccName -> Maybe Name
isPunOcc_maybe :: Module -> OccName -> Maybe Name
boolTy :: Type
boolTyCon :: TyCon
boolTyCon_RDR :: RdrName
boolTyConName :: Name
trueDataCon :: DataCon
trueDataConId :: Id
true_RDR :: RdrName
falseDataCon :: DataCon
falseDataConId :: Id
false_RDR :: RdrName
promotedFalseDataCon :: TyCon
promotedTrueDataCon :: TyCon
orderingTyCon :: TyCon
ordLTDataCon :: DataCon
ordLTDataConId :: Id
ordEQDataCon :: DataCon
ordEQDataConId :: Id
ordGTDataCon :: DataCon
ordGTDataConId :: Id
promotedLTDataCon :: TyCon
promotedEQDataCon :: TyCon
promotedGTDataCon :: TyCon

-- | Given a type <tt>ty</tt>, if <tt>ty</tt> is not of kind Type, return a
--   data constructor that will box it, and the type of the boxed thing,
--   which <i>does</i> now have kind Type. See Note [Boxing constructors]
boxingDataCon :: Type -> BoxingInfo b
data BoxingInfo b
BI_NoBoxNeeded :: BoxingInfo b
BI_NoBoxAvailable :: BoxingInfo b
BI_Box :: DataCon -> Expr b -> Type -> BoxingInfo b
[bi_data_con] :: BoxingInfo b -> DataCon
[bi_inst_con] :: BoxingInfo b -> Expr b
[bi_boxed_type] :: BoxingInfo b -> Type
charTyCon :: TyCon
charDataCon :: DataCon
charTyCon_RDR :: RdrName
charTy :: Type
stringTy :: Type
charTyConName :: Name
stringTyCon_RDR :: RdrName
doubleTyCon :: TyCon
doubleDataCon :: DataCon
doubleTy :: Type
doubleTyConName :: Name
floatTyCon :: TyCon
floatDataCon :: DataCon
floatTy :: Type
floatTyConName :: Name
intTyCon :: TyCon
intDataCon :: DataCon
intTyCon_RDR :: RdrName
intDataCon_RDR :: RdrName
intTyConName :: Name
intTy :: Type
wordTyCon :: TyCon
wordDataCon :: DataCon
wordTyConName :: Name
wordTy :: Type
word8TyCon :: TyCon
word8DataCon :: DataCon
word8Ty :: Type
listTyCon :: TyCon
listTyCon_RDR :: RdrName
listTyConName :: Name
listTyConKey :: Unique
nilDataCon :: DataCon
nilDataConName :: Name
nilDataConKey :: Unique
consDataCon_RDR :: RdrName
consDataCon :: DataCon
consDataConName :: Name
promotedNilDataCon :: TyCon
promotedConsDataCon :: TyCon
mkListTy :: Type -> Type

-- | Make a *promoted* list.
mkPromotedListTy :: Kind -> [Type] -> Type
maybeTyCon :: TyCon
maybeTyConName :: Name
nothingDataCon :: DataCon
nothingDataConName :: Name
promotedNothingDataCon :: TyCon
justDataCon :: DataCon
justDataConName :: Name
promotedJustDataCon :: TyCon
mkPromotedMaybeTy :: Kind -> Maybe Type -> Type
mkMaybeTy :: Type -> Kind
isPromotedMaybeTy :: Type -> Maybe (Maybe Type)

-- | Make a tuple type. The list of types should <i>not</i> include any
--   RuntimeRep specifications. Boxed 1-tuples are flattened. See Note
--   [One-tuples]
mkTupleTy :: Boxity -> [Type] -> Type

-- | Make a tuple type. The list of types should <i>not</i> include any
--   RuntimeRep specifications. Boxed 1-tuples are *not* flattened. See
--   Note [One-tuples] and Note [Don't flatten tuples from HsSyn] in
--   <a>GHC.Core.Make</a>
mkTupleTy1 :: Boxity -> [Type] -> Type

-- | Build the type of a small tuple that holds the specified type of thing
--   Flattens 1-tuples. See Note [One-tuples].
mkBoxedTupleTy :: [Type] -> Type
mkTupleStr :: Boxity -> NameSpace -> Arity -> String
tupleTyCon :: Boxity -> Arity -> TyCon
tupleDataCon :: Boxity -> Arity -> DataCon
tupleTyConName :: TupleSort -> Arity -> Name
tupleDataConName :: Boxity -> Arity -> Name
promotedTupleDataCon :: Boxity -> Arity -> TyCon
unitTyCon :: TyCon
unitDataCon :: DataCon
unitDataConId :: Id
unitTy :: Type
unitTyConKey :: Unique
soloTyCon :: TyCon
pairTyCon :: TyCon
mkPromotedPairTy :: Kind -> Kind -> Type -> Type -> Type
isPromotedPairType :: Type -> Maybe (Type, Type)
unboxedUnitTy :: Type
unboxedUnitTyCon :: TyCon
unboxedUnitDataCon :: DataCon

-- | Specialization of <a>unboxedTupleSumKind</a> for tuples
unboxedTupleKind :: [Type] -> Kind

-- | Specialization of <a>unboxedTupleSumKind</a> for sums
unboxedSumKind :: [Type] -> Kind

-- | Replaces constraint tuple names with corresponding boxed ones.
filterCTuple :: RdrName -> RdrName
mkConstraintTupleTy :: [Type] -> Type
cTupleTyCon :: Arity -> TyCon
cTupleTyConName :: Arity -> Name
cTupleTyConNames :: [Name]
isCTupleTyConName :: Name -> Bool

-- | If the given name is that of a constraint tuple, return its arity.
cTupleTyConNameArity_maybe :: Name -> Maybe Arity
cTupleDataCon :: Arity -> DataCon
cTupleDataConName :: Arity -> Name
cTupleDataConNames :: [Name]
cTupleSelId :: ConTag -> Arity -> Id
cTupleSelIdName :: ConTag -> Arity -> Name
anyTyCon :: TyCon
anyTy :: Type
anyTypeOfKind :: Kind -> Type

-- | Make a fake, recovery <a>TyCon</a> from an existing one. Used when
--   recovering from errors in type declarations
makeRecoveryTyCon :: TyCon -> TyCon
mkSumTy :: [Type] -> Type

-- | Type constructor for n-ary unboxed sum.
sumTyCon :: Arity -> TyCon

-- | Data constructor for i-th alternative of a n-ary unboxed sum.
sumDataCon :: ConTag -> Arity -> DataCon
typeSymbolKindCon :: TyCon
typeSymbolKind :: Kind
isLiftedTypeKindTyConName :: Name -> Bool
typeToTypeKind :: Type

-- | <pre>
--   type LiftedRep = 'BoxedRep 'Lifted
--   </pre>
liftedRepTyCon :: TyCon

-- | <pre>
--   type UnliftedRep = 'BoxedRep 'Unlifted
--   </pre>
unliftedRepTyCon :: TyCon
tYPETyCon :: TyCon
tYPETyConName :: Name
tYPEKind :: Type
cONSTRAINTTyCon :: TyCon
cONSTRAINTTyConName :: Name
cONSTRAINTKind :: Type
constraintKind :: Kind
liftedTypeKind :: Type
unliftedTypeKind :: Type
zeroBitTypeKind :: Type
constraintKindTyCon :: TyCon
liftedTypeKindTyCon :: TyCon
unliftedTypeKindTyCon :: TyCon
constraintKindTyConName :: Name
liftedTypeKindTyConName :: Name
unliftedTypeKindTyConName :: Name
liftedRepTyConName :: Name
unliftedRepTyConName :: Name
heqTyCon :: TyCon
heqTyConName :: Name
heqClass :: Class
heqDataCon :: DataCon
eqTyCon :: TyCon
eqTyConName :: Name
eqClass :: Class
eqDataCon :: DataCon
eqTyCon_RDR :: RdrName
coercibleTyCon :: TyCon
coercibleTyConName :: Name
coercibleDataCon :: DataCon
coercibleClass :: Class
runtimeRepTyCon :: TyCon
vecCountTyCon :: TyCon
vecElemTyCon :: TyCon
boxedRepDataConTyCon :: TyCon
runtimeRepTy :: Type
liftedRepTy :: RuntimeRepType
unliftedRepTy :: RuntimeRepType
zeroBitRepTy :: RuntimeRepType
vecRepDataConTyCon :: TyCon
tupleRepDataConTyCon :: TyCon
sumRepDataConTyCon :: TyCon
levityTyCon :: TyCon
levityTy :: Type
liftedDataConTyCon :: TyCon
unliftedDataConTyCon :: TyCon
liftedDataConTy :: Type
unliftedDataConTy :: Type
intRepDataConTy :: RuntimeRepType
int8RepDataConTy :: RuntimeRepType
int16RepDataConTy :: RuntimeRepType
int32RepDataConTy :: RuntimeRepType
int64RepDataConTy :: RuntimeRepType
wordRepDataConTy :: RuntimeRepType
word8RepDataConTy :: RuntimeRepType
word16RepDataConTy :: RuntimeRepType
word32RepDataConTy :: RuntimeRepType
word64RepDataConTy :: RuntimeRepType
addrRepDataConTy :: RuntimeRepType
floatRepDataConTy :: RuntimeRepType
doubleRepDataConTy :: RuntimeRepType
vec2DataConTy :: Type
vec4DataConTy :: Type
vec8DataConTy :: Type
vec16DataConTy :: Type
vec32DataConTy :: Type
vec64DataConTy :: Type
int8ElemRepDataConTy :: Type
int16ElemRepDataConTy :: Type
int32ElemRepDataConTy :: Type
int64ElemRepDataConTy :: Type
word8ElemRepDataConTy :: Type
word16ElemRepDataConTy :: Type
word32ElemRepDataConTy :: Type
word64ElemRepDataConTy :: Type
floatElemRepDataConTy :: Type
doubleElemRepDataConTy :: Type
multiplicityTyConName :: Name
oneDataConName :: Name
manyDataConName :: Name
multiplicityTy :: Type
multiplicityTyCon :: TyCon
oneDataCon :: DataCon
manyDataCon :: DataCon
oneDataConTy :: Type
manyDataConTy :: Type
oneDataConTyCon :: TyCon
manyDataConTyCon :: TyCon
multMulTyCon :: TyCon
unrestrictedFunTyCon :: TyCon
unrestrictedFunTyConName :: Name
integerTy :: Type
integerTyCon :: TyCon
integerTyConName :: Name
integerISDataCon :: DataCon
integerISDataConName :: Name
integerIPDataCon :: DataCon
integerIPDataConName :: Name
integerINDataCon :: DataCon
integerINDataConName :: Name
naturalTy :: Type
naturalTyCon :: TyCon
naturalTyConName :: Name
naturalNSDataCon :: DataCon
naturalNSDataConName :: Name
naturalNBDataCon :: DataCon
naturalNBDataConName :: Name


-- | The Name Cache
module GHC.Types.Name.Cache

-- | The NameCache makes sure that there is just one Unique assigned for
--   each original name; i.e. (module-name, occ-name) pair and provides
--   something of a lookup mechanism for those names.
data NameCache
NameCache :: {-# UNPACK #-} !Char -> {-# UNPACK #-} !MVar OrigNameCache -> NameCache
[nsUniqChar] :: NameCache -> {-# UNPACK #-} !Char
[nsNames] :: NameCache -> {-# UNPACK #-} !MVar OrigNameCache
initNameCache :: Char -> [Name] -> IO NameCache
takeUniqFromNameCache :: NameCache -> IO Unique

-- | Update the name cache with the given function
updateNameCache' :: NameCache -> (OrigNameCache -> IO (OrigNameCache, c)) -> IO c

-- | Update the name cache with the given function
--   
--   Additionally, it ensures that the given Module and OccName are
--   evaluated. If not, chaos can ensue: we read the name-cache then pull
--   on mod (say) which does some stuff that modifies the name cache This
--   did happen, with tycon_mod in GHC.IfaceToCore.tcIfaceAlt (DataAlt..)
updateNameCache :: NameCache -> Module -> OccName -> (OrigNameCache -> IO (OrigNameCache, c)) -> IO c

-- | Per-module cache of original <a>OccName</a>s given <a>Name</a>s
type OrigNameCache = ModuleEnv (OccEnv Name)
lookupOrigNameCache :: OrigNameCache -> Module -> OccName -> Maybe Name
extendOrigNameCache' :: OrigNameCache -> Name -> OrigNameCache
extendOrigNameCache :: OrigNameCache -> Module -> OccName -> Name -> OrigNameCache

module GHC.Iface.Syntax
data IfaceDecl
IfaceId :: IfaceTopBndr -> IfaceType -> IfaceIdDetails -> IfaceIdInfo -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifType] :: IfaceDecl -> IfaceType
[ifIdDetails] :: IfaceDecl -> IfaceIdDetails
[ifIdInfo] :: IfaceDecl -> IfaceIdInfo
IfaceData :: IfaceTopBndr -> [IfaceTyConBinder] -> IfaceType -> Maybe CType -> [Role] -> IfaceContext -> IfaceConDecls -> Bool -> IfaceTyConParent -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceType
[ifCType] :: IfaceDecl -> Maybe CType
[ifRoles] :: IfaceDecl -> [Role]
[ifCtxt] :: IfaceDecl -> IfaceContext
[ifCons] :: IfaceDecl -> IfaceConDecls
[ifGadtSyntax] :: IfaceDecl -> Bool
[ifParent] :: IfaceDecl -> IfaceTyConParent
IfaceSynonym :: IfaceTopBndr -> [Role] -> [IfaceTyConBinder] -> IfaceKind -> IfaceType -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifRoles] :: IfaceDecl -> [Role]
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceKind
[ifSynRhs] :: IfaceDecl -> IfaceType
IfaceFamily :: IfaceTopBndr -> Maybe IfLclName -> [IfaceTyConBinder] -> IfaceKind -> IfaceFamTyConFlav -> Injectivity -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifResVar] :: IfaceDecl -> Maybe IfLclName
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceKind
[ifFamFlav] :: IfaceDecl -> IfaceFamTyConFlav
[ifFamInj] :: IfaceDecl -> Injectivity
IfaceClass :: IfaceTopBndr -> [Role] -> [IfaceTyConBinder] -> [FunDep IfLclName] -> IfaceClassBody -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifRoles] :: IfaceDecl -> [Role]
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifFDs] :: IfaceDecl -> [FunDep IfLclName]
[ifBody] :: IfaceDecl -> IfaceClassBody
IfaceAxiom :: IfaceTopBndr -> IfaceTyCon -> Role -> [IfaceAxBranch] -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifTyCon] :: IfaceDecl -> IfaceTyCon
[ifRole] :: IfaceDecl -> Role
[ifAxBranches] :: IfaceDecl -> [IfaceAxBranch]
IfacePatSyn :: IfaceTopBndr -> Bool -> (IfExtName, Bool) -> Maybe (IfExtName, Bool) -> [IfaceForAllSpecBndr] -> [IfaceForAllSpecBndr] -> IfaceContext -> IfaceContext -> [IfaceType] -> IfaceType -> [FieldLabel] -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifPatIsInfix] :: IfaceDecl -> Bool
[ifPatMatcher] :: IfaceDecl -> (IfExtName, Bool)
[ifPatBuilder] :: IfaceDecl -> Maybe (IfExtName, Bool)
[ifPatUnivBndrs] :: IfaceDecl -> [IfaceForAllSpecBndr]
[ifPatExBndrs] :: IfaceDecl -> [IfaceForAllSpecBndr]
[ifPatProvCtxt] :: IfaceDecl -> IfaceContext
[ifPatReqCtxt] :: IfaceDecl -> IfaceContext
[ifPatArgs] :: IfaceDecl -> [IfaceType]
[ifPatTy] :: IfaceDecl -> IfaceType
[ifFieldLabels] :: IfaceDecl -> [FieldLabel]
data IfaceFamTyConFlav
IfaceDataFamilyTyCon :: IfaceFamTyConFlav
IfaceOpenSynFamilyTyCon :: IfaceFamTyConFlav

-- | Name of associated axiom and branches for pretty printing purposes, or
--   <a>Nothing</a> for an empty closed family without an axiom See Note
--   [Pretty printing via Iface syntax] in <a>GHC.Types.TyThing.Ppr</a>
IfaceClosedSynFamilyTyCon :: Maybe (IfExtName, [IfaceAxBranch]) -> IfaceFamTyConFlav
IfaceAbstractClosedSynFamilyTyCon :: IfaceFamTyConFlav
IfaceBuiltInSynFamTyCon :: IfaceFamTyConFlav
data IfaceClassOp
IfaceClassOp :: IfaceTopBndr -> IfaceType -> Maybe (DefMethSpec IfaceType) -> IfaceClassOp
data IfaceAT
IfaceAT :: IfaceDecl -> Maybe IfaceType -> IfaceAT
data IfaceConDecl
IfCon :: IfaceTopBndr -> Bool -> Bool -> [IfaceBndr] -> [IfaceForAllSpecBndr] -> IfaceEqSpec -> IfaceContext -> [(IfaceMult, IfaceType)] -> [FieldLabel] -> [IfaceBang] -> [IfaceSrcBang] -> IfaceConDecl
[ifConName] :: IfaceConDecl -> IfaceTopBndr
[ifConWrapper] :: IfaceConDecl -> Bool
[ifConInfix] :: IfaceConDecl -> Bool
[ifConExTCvs] :: IfaceConDecl -> [IfaceBndr]
[ifConUserTvBinders] :: IfaceConDecl -> [IfaceForAllSpecBndr]
[ifConEqSpec] :: IfaceConDecl -> IfaceEqSpec
[ifConCtxt] :: IfaceConDecl -> IfaceContext
[ifConArgTys] :: IfaceConDecl -> [(IfaceMult, IfaceType)]
[ifConFields] :: IfaceConDecl -> [FieldLabel]
[ifConStricts] :: IfaceConDecl -> [IfaceBang]
[ifConSrcStricts] :: IfaceConDecl -> [IfaceSrcBang]
data IfaceConDecls
IfAbstractTyCon :: IfaceConDecls
IfDataTyCon :: !Bool -> [IfaceConDecl] -> IfaceConDecls
IfNewTyCon :: IfaceConDecl -> IfaceConDecls
type IfaceEqSpec = [(IfLclName, IfaceType)]
data IfaceExpr
IfaceLcl :: IfLclName -> IfaceExpr
IfaceExt :: IfExtName -> IfaceExpr
IfaceType :: IfaceType -> IfaceExpr
IfaceCo :: IfaceCoercion -> IfaceExpr
IfaceTuple :: TupleSort -> [IfaceExpr] -> IfaceExpr
IfaceLam :: IfaceLamBndr -> IfaceExpr -> IfaceExpr
IfaceApp :: IfaceExpr -> IfaceExpr -> IfaceExpr
IfaceCase :: IfaceExpr -> IfLclName -> [IfaceAlt] -> IfaceExpr
IfaceECase :: IfaceExpr -> IfaceType -> IfaceExpr
IfaceLet :: IfaceBinding IfaceLetBndr -> IfaceExpr -> IfaceExpr
IfaceCast :: IfaceExpr -> IfaceCoercion -> IfaceExpr
IfaceLit :: Literal -> IfaceExpr
IfaceLitRubbish :: TypeOrConstraint -> IfaceType -> IfaceExpr
IfaceFCall :: ForeignCall -> IfaceType -> IfaceExpr
IfaceTick :: IfaceTickish -> IfaceExpr -> IfaceExpr
data IfaceAlt
IfaceAlt :: IfaceConAlt -> [IfLclName] -> IfaceExpr -> IfaceAlt
data IfaceLetBndr
IfLetBndr :: IfLclName -> IfaceType -> IfaceIdInfo -> IfaceJoinInfo -> IfaceLetBndr
data IfaceJoinInfo
IfaceNotJoinPoint :: IfaceJoinInfo
IfaceJoinPoint :: JoinArity -> IfaceJoinInfo
type IfaceBinding b = IfaceBindingX IfaceExpr b
data IfaceBindingX r b
IfaceNonRec :: b -> r -> IfaceBindingX r b
IfaceRec :: [(b, r)] -> IfaceBindingX r b
data IfaceMaybeRhs
IfUseUnfoldingRhs :: IfaceMaybeRhs
IfRhs :: IfaceExpr -> IfaceMaybeRhs
data IfaceConAlt
IfaceDefault :: IfaceConAlt
IfaceDataAlt :: IfExtName -> IfaceConAlt
IfaceLitAlt :: Literal -> IfaceConAlt
type IfaceIdInfo = [IfaceInfoItem]
data IfaceIdDetails
IfVanillaId :: IfaceIdDetails
IfWorkerLikeId :: [CbvMark] -> IfaceIdDetails
IfRecSelId :: Either IfaceTyCon IfaceDecl -> Bool -> IfaceIdDetails
IfDFunId :: IfaceIdDetails
data IfaceUnfolding
IfCoreUnfold :: UnfoldingSource -> IfUnfoldingCache -> IfGuidance -> IfaceExpr -> IfaceUnfolding
IfDFunUnfold :: [IfaceBndr] -> [IfaceExpr] -> IfaceUnfolding
data IfGuidance
IfNoGuidance :: IfGuidance
IfWhen :: Arity -> Bool -> Bool -> IfGuidance
data IfaceInfoItem
HsArity :: Arity -> IfaceInfoItem
HsDmdSig :: DmdSig -> IfaceInfoItem
HsCprSig :: CprSig -> IfaceInfoItem
HsInline :: InlinePragma -> IfaceInfoItem
HsUnfold :: Bool -> IfaceUnfolding -> IfaceInfoItem
HsNoCafRefs :: IfaceInfoItem
HsLFInfo :: IfaceLFInfo -> IfaceInfoItem
HsTagSig :: TagSig -> IfaceInfoItem
data IfaceRule
IfaceRule :: RuleName -> Activation -> [IfaceBndr] -> IfExtName -> [IfaceExpr] -> IfaceExpr -> Bool -> IsOrphan -> IfaceRule
[ifRuleName] :: IfaceRule -> RuleName
[ifActivation] :: IfaceRule -> Activation
[ifRuleBndrs] :: IfaceRule -> [IfaceBndr]
[ifRuleHead] :: IfaceRule -> IfExtName
[ifRuleArgs] :: IfaceRule -> [IfaceExpr]
[ifRuleRhs] :: IfaceRule -> IfaceExpr
[ifRuleAuto] :: IfaceRule -> Bool
[ifRuleOrph] :: IfaceRule -> IsOrphan
data IfaceAnnotation
IfaceAnnotation :: IfaceAnnTarget -> AnnPayload -> IfaceAnnotation
[ifAnnotatedTarget] :: IfaceAnnotation -> IfaceAnnTarget
[ifAnnotatedValue] :: IfaceAnnotation -> AnnPayload
type IfaceAnnTarget = AnnTarget OccName
data IfaceClsInst
IfaceClsInst :: IfExtName -> [Maybe IfaceTyCon] -> IfExtName -> OverlapFlag -> IsOrphan -> IfaceClsInst
[ifInstCls] :: IfaceClsInst -> IfExtName
[ifInstTys] :: IfaceClsInst -> [Maybe IfaceTyCon]
[ifDFun] :: IfaceClsInst -> IfExtName
[ifOFlag] :: IfaceClsInst -> OverlapFlag
[ifInstOrph] :: IfaceClsInst -> IsOrphan
data IfaceFamInst
IfaceFamInst :: IfExtName -> [Maybe IfaceTyCon] -> IfExtName -> IsOrphan -> IfaceFamInst
[ifFamInstFam] :: IfaceFamInst -> IfExtName
[ifFamInstTys] :: IfaceFamInst -> [Maybe IfaceTyCon]
[ifFamInstAxiom] :: IfaceFamInst -> IfExtName
[ifFamInstOrph] :: IfaceFamInst -> IsOrphan
data IfaceTickish
IfaceHpcTick :: Module -> Int -> IfaceTickish
IfaceSCC :: CostCentre -> Bool -> Bool -> IfaceTickish
IfaceSource :: RealSrcSpan -> String -> IfaceTickish
data IfaceClassBody
IfAbstractClass :: IfaceClassBody
IfConcreteClass :: IfaceContext -> [IfaceAT] -> [IfaceClassOp] -> BooleanFormula IfLclName -> IfaceClassBody
[ifClassCtxt] :: IfaceClassBody -> IfaceContext
[ifATs] :: IfaceClassBody -> [IfaceAT]
[ifSigs] :: IfaceClassBody -> [IfaceClassOp]
[ifMinDef] :: IfaceClassBody -> BooleanFormula IfLclName

-- | This corresponds to an HsImplBang; that is, the final implementation
--   decision about the data constructor arg
data IfaceBang
IfNoBang :: IfaceBang
IfStrict :: IfaceBang
IfUnpack :: IfaceBang
IfUnpackCo :: IfaceCoercion -> IfaceBang

-- | This corresponds to HsSrcBang
data IfaceSrcBang
IfSrcBang :: SrcUnpackedness -> SrcStrictness -> IfaceSrcBang

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness
data IfaceAxBranch
IfaceAxBranch :: [IfaceTvBndr] -> [IfaceTvBndr] -> [IfaceIdBndr] -> IfaceAppArgs -> [Role] -> IfaceType -> [BranchIndex] -> IfaceAxBranch
[ifaxbTyVars] :: IfaceAxBranch -> [IfaceTvBndr]
[ifaxbEtaTyVars] :: IfaceAxBranch -> [IfaceTvBndr]
[ifaxbCoVars] :: IfaceAxBranch -> [IfaceIdBndr]
[ifaxbLHS] :: IfaceAxBranch -> IfaceAppArgs
[ifaxbRoles] :: IfaceAxBranch -> [Role]
[ifaxbRHS] :: IfaceAxBranch -> IfaceType
[ifaxbIncomps] :: IfaceAxBranch -> [BranchIndex]
data IfaceTyConParent
IfNoParent :: IfaceTyConParent
IfDataInstance :: IfExtName -> IfaceTyCon -> IfaceAppArgs -> IfaceTyConParent
data IfaceCompleteMatch
IfaceCompleteMatch :: [IfExtName] -> Maybe IfaceTyCon -> IfaceCompleteMatch

-- | Iface type for LambdaFormInfo. Fields not relevant for imported Ids
--   are omitted in this type.
data IfaceLFInfo
IfLFReEntrant :: !RepArity -> IfaceLFInfo
IfLFThunk :: !Bool -> !Bool -> IfaceLFInfo
IfLFCon :: !Name -> IfaceLFInfo
IfLFUnknown :: !Bool -> IfaceLFInfo
IfLFUnlifted :: IfaceLFInfo
data IfaceTopBndrInfo
IfLclTopBndr :: IfLclName -> IfaceType -> IfaceIdInfo -> IfaceIdDetails -> IfaceTopBndrInfo
IfGblTopBndr :: IfaceTopBndr -> IfaceTopBndrInfo

-- | A binding top-level <a>Name</a> in an interface file (e.g. the name of
--   an <a>IfaceDecl</a>).
type IfaceTopBndr = Name
putIfaceTopBndr :: BinHandle -> IfaceTopBndr -> IO ()
getIfaceTopBndr :: BinHandle -> IO IfaceTopBndr
ifaceDeclImplicitBndrs :: IfaceDecl -> [OccName]
visibleIfConDecls :: IfaceConDecls -> [IfaceConDecl]
ifaceDeclFingerprints :: Fingerprint -> IfaceDecl -> [(OccName, Fingerprint)]
freeNamesIfDecl :: IfaceDecl -> NameSet
freeNamesIfRule :: IfaceRule -> NameSet
freeNamesIfFamInst :: IfaceFamInst -> NameSet

-- | Pretty Print an IfaceExpr
--   
--   The first argument should be a function that adds parens in context
--   that need an atomic value (e.g. function args)
pprIfaceExpr :: (SDoc -> SDoc) -> IfaceExpr -> SDoc
pprIfaceDecl :: ShowSub -> IfaceDecl -> SDoc
newtype AltPpr
AltPpr :: Maybe (OccName -> SDoc) -> AltPpr
data ShowSub
ShowSub :: ShowHowMuch -> ShowForAllFlag -> ShowSub
[ss_how_much] :: ShowSub -> ShowHowMuch
[ss_forall] :: ShowSub -> ShowForAllFlag
data ShowHowMuch

-- | Header information only, not rhs
ShowHeader :: AltPpr -> ShowHowMuch

-- | Show only some sub-components. Specifically,
--   
--   <ul>
--   <li><i><tt>[]</tt></i> Print all sub-components.</li>
--   <li><i><tt>(n:ns)</tt></i> Print sub-component <tt>n</tt> with
--   <tt>ShowSub = ns</tt>; elide other sub-components to <tt>...</tt> May
--   14: the list is max 1 element long at the moment</li>
--   </ul>
ShowSome :: [OccName] -> AltPpr -> ShowHowMuch

-- | Everything including GHC-internal information (used in --show-iface)
ShowIface :: ShowHowMuch
showToIface :: ShowSub
showToHeader :: ShowSub
instance (GHC.Classes.Eq b, GHC.Classes.Eq r) => GHC.Classes.Eq (GHC.Iface.Syntax.IfaceBindingX r b)
instance (GHC.Classes.Ord b, GHC.Classes.Ord r) => GHC.Classes.Ord (GHC.Iface.Syntax.IfaceBindingX r b)
instance Data.Traversable.Traversable (GHC.Iface.Syntax.IfaceBindingX r)
instance Data.Foldable.Foldable (GHC.Iface.Syntax.IfaceBindingX r)
instance GHC.Base.Functor (GHC.Iface.Syntax.IfaceBindingX r)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.ShowHowMuch
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceRule
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceRule
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceRule
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceTopBndrInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceTopBndrInfo
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceTopBndrInfo
instance GHC.Types.Name.NamedThing GHC.Iface.Syntax.IfaceDecl
instance GHC.Types.Name.Occurrence.HasOccName GHC.Iface.Syntax.IfaceDecl
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceDecl
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceAT
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceIdDetails
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceDecl
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAT
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceIdDetails
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceDecl
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceClassBody
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAT
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceIdDetails
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceMaybeRhs
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceMaybeRhs
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceMaybeRhs
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceExpr
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceInfoItem
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceUnfolding
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceInfoItem
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceUnfolding
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAlt
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceExpr
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceLetBndr
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceInfoItem
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceUnfolding
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceExpr
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAlt
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceLetBndr
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceJoinInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceJoinInfo
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceJoinInfo
instance (GHC.Utils.Outputable.Outputable r, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Iface.Syntax.IfaceBindingX r b)
instance (GHC.Utils.Binary.Binary r, GHC.Utils.Binary.Binary b) => GHC.Utils.Binary.Binary (GHC.Iface.Syntax.IfaceBindingX b r)
instance (Control.DeepSeq.NFData b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (GHC.Iface.Syntax.IfaceBindingX a b)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceConAlt
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceConAlt
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceConAlt
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceTickish
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceTickish
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceLFInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceLFInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfGuidance
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfGuidance
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfGuidance
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceCompleteMatch
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceCompleteMatch
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceCompleteMatch
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceAnnotation
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAnnotation
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAnnotation
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceFamInst
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceFamInst
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceFamInst
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceClsInst
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceClsInst
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceClsInst
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceConDecls
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceConDecls
instance GHC.Types.Name.NamedThing GHC.Iface.Syntax.IfaceConDecl
instance GHC.Types.Name.Occurrence.HasOccName GHC.Iface.Syntax.IfaceConDecl
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceConDecl
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceConDecl
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceSrcBang
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceSrcBang
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceBang
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceBang
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceFamTyConFlav
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceFamTyConFlav
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceAxBranch
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceAxBranch
instance GHC.Types.Name.NamedThing GHC.Iface.Syntax.IfaceClassOp
instance GHC.Types.Name.Occurrence.HasOccName GHC.Iface.Syntax.IfaceClassOp
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceClassOp
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceClassOp
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceClassOp
instance GHC.Utils.Outputable.Outputable GHC.Iface.Syntax.IfaceTyConParent
instance GHC.Utils.Binary.Binary GHC.Iface.Syntax.IfaceTyConParent
instance Control.DeepSeq.NFData GHC.Iface.Syntax.IfaceTyConParent

module GHC.Unit.Module.WholeCoreBindings
data WholeCoreBindings
WholeCoreBindings :: [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo] -> Module -> ModLocation -> WholeCoreBindings

-- | serialised tidied core bindings.
[wcb_bindings] :: WholeCoreBindings -> [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo]

-- | The module which the bindings are for
[wcb_module] :: WholeCoreBindings -> Module

-- | The location where the sources reside.
[wcb_mod_location] :: WholeCoreBindings -> ModLocation

module GHC.Hs.Type

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type

-- | This is used in the syntax. In constructor declaration. It must keep
--   the arrow representation.
data HsScaled pass a
HsScaled :: HsArrow pass -> a -> HsScaled pass a
hsMult :: HsScaled pass a -> HsArrow pass
hsScaledThing :: HsScaled pass a -> a

-- | Denotes the type of arrows in the surface language
data HsArrow pass

-- | a -&gt; b or a → b
HsUnrestrictedArrow :: !LHsUniToken "->" "→" pass -> HsArrow pass

-- | a %1 -&gt; b or a %1 → b, or a ⊸ b
HsLinearArrow :: !HsLinearArrowTokens pass -> HsArrow pass

-- | a %m -&gt; b or a %m → b (very much including `a %Many -&gt; b`! This
--   is how the programmer wrote it). It is stored as an <a>HsType</a> so
--   as to preserve the syntax as written in the program.
HsExplicitMult :: !LHsToken "%" pass -> !LHsType pass -> !LHsUniToken "->" "→" pass -> HsArrow pass

-- | Convert an arrow into its corresponding multiplicity. In essence this
--   erases the information of whether the programmer wrote an explicit
--   multiplicity or a shorthand.
arrowToHsType :: HsArrow GhcRn -> LHsType GhcRn
data HsLinearArrowTokens pass
HsPct1 :: !LHsToken "%1" pass -> !LHsUniToken "->" "→" pass -> HsLinearArrowTokens pass
HsLolly :: !LHsToken "⊸" pass -> HsLinearArrowTokens pass
hsLinear :: a -> HsScaled (GhcPass p) a
hsUnrestricted :: a -> HsScaled (GhcPass p) a
isUnrestricted :: HsArrow GhcRn -> Bool
pprHsArrow :: OutputableBndrId pass => HsArrow (GhcPass pass) -> SDoc

-- | Haskell Type
data HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnForall</a>,
--   <a>AnnDot</a>,<a>AnnDarrow</a> For details on above see Note [exact
--   print annotations] in <a>GHC.Parser.Annotation</a></li>
--   </ul>
HsForAllTy :: XForAllTy pass -> HsForAllTelescope pass -> LHsType pass -> HsType pass
[hst_xforall] :: HsType pass -> XForAllTy pass
[hst_tele] :: HsType pass -> HsForAllTelescope pass
[hst_body] :: HsType pass -> LHsType pass
HsQualTy :: XQualTy pass -> LHsContext pass -> LHsType pass -> HsType pass
[hst_xqual] :: HsType pass -> XQualTy pass
[hst_ctxt] :: HsType pass -> LHsContext pass
[hst_body] :: HsType pass -> LHsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsTyVar :: XTyVar pass -> PromotionFlag -> LIdP pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsAppTy :: XAppTy pass -> LHsType pass -> LHsType pass -> HsType pass
HsAppKindTy :: XAppKindTy pass -> LHsType pass -> LHsKind pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a>,</li>
--   </ul>
HsFunTy :: XFunTy pass -> HsArrow pass -> LHsType pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
HsListTy :: XListTy pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(' or '(#'</tt>,
--   <a>AnnClose</a> <tt>')' or '#)'</tt></li>
--   </ul>
HsTupleTy :: XTupleTy pass -> HsTupleSort -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnClose</a> '#)'@</li>
--   </ul>
HsSumTy :: XSumTy pass -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsOpTy :: XOpTy pass -> PromotionFlag -> LHsType pass -> LIdP pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
HsParTy :: XParTy pass -> LHsType pass -> HsType pass

-- | <pre>
--   (?x :: ty)
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
HsIParamTy :: XIParamTy pass -> XRec pass HsIPName -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsStarTy :: XStarTy pass -> Bool -> HsType pass

-- | <pre>
--   (ty :: kind)
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>,
--   <a>AnnDcolon</a>,<a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsKindSig :: XKindSig pass -> LHsType pass -> LHsKind pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'$('</tt>,
--   <a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsSpliceTy :: XSpliceTy pass -> HsUntypedSplice pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsDocTy :: XDocTy pass -> LHsType pass -> LHsDoc pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# UNPACK' or '{-#
--   NOUNPACK'</tt>, <a>AnnClose</a> <tt>'#-}'</tt> <a>AnnBang</a>
--   <tt>'!'</tt></li>
--   </ul>
HsBangTy :: XBangTy pass -> HsSrcBang -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>, <a>AnnClose</a>
--   <tt>'}'</tt></li>
--   </ul>
HsRecTy :: XRecTy pass -> [LConDeclField pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>"'["</tt>,
--   <a>AnnClose</a> <tt>']'</tt></li>
--   </ul>
HsExplicitListTy :: XExplicitListTy pass -> PromotionFlag -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>"'("</tt>,
--   <a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsExplicitTupleTy :: XExplicitTupleTy pass -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsTyLit :: XTyLit pass -> HsTyLit pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsWildCardTy :: XWildCardTy pass -> HsType pass
XHsType :: !XXType pass -> HsType pass
type HsCoreTy = Type

-- | Located Haskell Type
type LHsType pass = -- | May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when --   in a list XRec pass (HsType pass)

-- | Haskell Kind
type HsKind pass = HsType pass

-- | Located Haskell Kind
type LHsKind pass = -- | 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon' XRec pass (HsKind pass)

-- | The type variable binders in an <a>HsForAllTy</a>. See also <tt>Note
--   [Variable Specificity and Forall Visibility]</tt> in
--   <a>GHC.Tc.Gen.HsType</a>.
data HsForAllTelescope pass

-- | A visible <tt>forall</tt> (e.g., <tt>forall a -&gt; {...}</tt>). These
--   do not have any notion of specificity, so we use <tt>()</tt> as a
--   placeholder value.
HsForAllVis :: XHsForAllVis pass -> [LHsTyVarBndr () pass] -> HsForAllTelescope pass
[hsf_xvis] :: HsForAllTelescope pass -> XHsForAllVis pass
[hsf_vis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr () pass]

-- | An invisible <tt>forall</tt> (e.g., <tt>forall a {b} c. {...}</tt>),
--   where each binder has a <a>Specificity</a>.
HsForAllInvis :: XHsForAllInvis pass -> [LHsTyVarBndr Specificity pass] -> HsForAllTelescope pass
[hsf_xinvis] :: HsForAllTelescope pass -> XHsForAllInvis pass
[hsf_invis_bndrs] :: HsForAllTelescope pass -> [LHsTyVarBndr Specificity pass]
XHsForAllTelescope :: !XXHsForAllTelescope pass -> HsForAllTelescope pass
type EpAnnForallTy = -- | Location of 'forall' and '->' for HsForAllVis -- Location of 'forall' and '.' for HsForAllInvis EpAnn (AddEpAnn, AddEpAnn)

-- | Haskell Type Variable Binder The flag annotates the binder. It is
--   <a>Specificity</a> in places where explicit specificity is allowed
--   (e.g. x :: forall {a} b. ...) or <tt>()</tt> in other places.
data HsTyVarBndr flag pass
UserTyVar :: XUserTyVar pass -> flag -> LIdP pass -> HsTyVarBndr flag pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnDcolon</a>,
--   <a>AnnClose</a></li>
--   </ul>
KindedTyVar :: XKindedTyVar pass -> flag -> LIdP pass -> LHsKind pass -> HsTyVarBndr flag pass
XTyVarBndr :: !XXTyVarBndr pass -> HsTyVarBndr flag pass

-- | Located Haskell Type Variable Binder
type LHsTyVarBndr flag pass = XRec pass (HsTyVarBndr flag pass)

-- | Located Haskell Quantified Type Variables
data LHsQTyVars pass
HsQTvs :: XHsQTvs pass -> [LHsTyVarBndr () pass] -> LHsQTyVars pass
[hsq_ext] :: LHsQTyVars pass -> XHsQTvs pass
[hsq_explicit] :: LHsQTyVars pass -> [LHsTyVarBndr () pass]
XLHsQTyVars :: !XXLHsQTyVars pass -> LHsQTyVars pass

-- | The outermost type variables in a type that obeys the
--   <tt>forall</tt>-or-nothing rule. See <tt>Note [forall-or-nothing
--   rule]</tt>.
data HsOuterTyVarBndrs flag pass

-- | Implicit forall, e.g., <tt>f :: a -&gt; b -&gt; b</tt>
HsOuterImplicit :: XHsOuterImplicit pass -> HsOuterTyVarBndrs flag pass
[hso_ximplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterImplicit pass

-- | Explicit forall, e.g., <tt>f :: forall a b. a -&gt; b -&gt; b</tt>
HsOuterExplicit :: XHsOuterExplicit pass flag -> [LHsTyVarBndr flag (NoGhcTc pass)] -> HsOuterTyVarBndrs flag pass
[hso_xexplicit] :: HsOuterTyVarBndrs flag pass -> XHsOuterExplicit pass flag
[hso_bndrs] :: HsOuterTyVarBndrs flag pass -> [LHsTyVarBndr flag (NoGhcTc pass)]
XHsOuterTyVarBndrs :: !XXHsOuterTyVarBndrs pass -> HsOuterTyVarBndrs flag pass

-- | Used for type-family instance equations, e.g.,
--   
--   <pre>
--   type instance forall a. F [a] = Tree a
--   </pre>
--   
--   The notion of specificity is irrelevant in type family equations, so
--   we use <tt>()</tt> for the <a>HsOuterTyVarBndrs</a> <tt>flag</tt>.
type HsOuterFamEqnTyVarBndrs = HsOuterTyVarBndrs ()

-- | Used for signatures, e.g.,
--   
--   <pre>
--   f :: forall a {b}. blah
--   </pre>
--   
--   We use <a>Specificity</a> for the <a>HsOuterTyVarBndrs</a>
--   <tt>flag</tt> to allow distinguishing between specified and inferred
--   type variables.
type HsOuterSigTyVarBndrs = HsOuterTyVarBndrs Specificity

-- | Haskell Wildcard Binders
data HsWildCardBndrs pass thing
HsWC :: XHsWC pass thing -> thing -> HsWildCardBndrs pass thing
[hswc_ext] :: HsWildCardBndrs pass thing -> XHsWC pass thing
[hswc_body] :: HsWildCardBndrs pass thing -> thing
XHsWildCardBndrs :: !XXHsWildCardBndrs pass thing -> HsWildCardBndrs pass thing

-- | Types that can appear in pattern signatures, as well as the signatures
--   for term-level binders in RULES. See <tt>Note [Pattern signature
--   binders and scoping]</tt>.
--   
--   This is very similar to <tt>HsSigWcType</tt>, but with slightly
--   different semantics: see <tt>Note [HsType binders]</tt>. See also
--   <tt>Note [The wildcard story for types]</tt>.
data HsPatSigType pass
HsPS :: XHsPS pass -> LHsType pass -> HsPatSigType pass

-- | After renamer: <tt>HsPSRn</tt>
[hsps_ext] :: HsPatSigType pass -> XHsPS pass

-- | Main payload (the type itself)
[hsps_body] :: HsPatSigType pass -> LHsType pass
XHsPatSigType :: !XXHsPatSigType pass -> HsPatSigType pass

-- | The extension field for <a>HsPatSigType</a>, which is only used in the
--   renamer onwards. See <tt>Note [Pattern signature binders and
--   scoping]</tt>.
data HsPSRn
HsPSRn :: [Name] -> [Name] -> HsPSRn

-- | Wildcard names
[hsps_nwcs] :: HsPSRn -> [Name]

-- | Implicitly bound variable names
[hsps_imp_tvs] :: HsPSRn -> [Name]

-- | A type signature that obeys the <tt>forall</tt>-or-nothing rule. In
--   other words, an <a>LHsType</a> that uses an
--   <a>HsOuterSigTyVarBndrs</a> to represent its outermost type variable
--   quantification. See <tt>Note [Representing type signatures]</tt>.
data HsSigType pass
HsSig :: XHsSig pass -> HsOuterSigTyVarBndrs pass -> LHsType pass -> HsSigType pass
[sig_ext] :: HsSigType pass -> XHsSig pass
[sig_bndrs] :: HsSigType pass -> HsOuterSigTyVarBndrs pass
[sig_body] :: HsSigType pass -> LHsType pass
XHsSigType :: !XXHsSigType pass -> HsSigType pass

-- | Located Haskell Signature Type
type LHsSigType pass = XRec pass (HsSigType pass)

-- | Located Haskell Signature Wildcard Type
type LHsSigWcType pass = HsWildCardBndrs pass (LHsSigType pass)

-- | Located Haskell Wildcard Type
type LHsWcType pass = HsWildCardBndrs pass (LHsType pass)

-- | Haskell Tuple Sort
data HsTupleSort
HsUnboxedTuple :: HsTupleSort
HsBoxedOrConstraintTuple :: HsTupleSort

-- | Haskell Context
type HsContext pass = [LHsType pass]

-- | Located Haskell Context
type LHsContext pass = -- | 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnUnit' -- For details on above see Note [exact print annotations] in GHC.Parser.Annotation XRec pass (HsContext pass)
fromMaybeContext :: Maybe (LHsContext (GhcPass p)) -> HsContext (GhcPass p)

-- | Haskell Type Literal
data HsTyLit pass
HsNumTy :: XNumTy pass -> Integer -> HsTyLit pass
HsStrTy :: XStrTy pass -> FastString -> HsTyLit pass
HsCharTy :: XCharTy pass -> Char -> HsTyLit pass
XTyLit :: !XXTyLit pass -> HsTyLit pass

-- | These names are used early on to store the names of implicit
--   parameters. They completely disappear after type-checking.
newtype HsIPName
HsIPName :: FastString -> HsIPName
hsIPNameFS :: HsIPName -> FastString

-- | Arguments in an expression/type after splitting
data HsArg tm ty
HsValArg :: tm -> HsArg tm ty
HsTypeArg :: SrcSpan -> ty -> HsArg tm ty
HsArgPar :: SrcSpan -> HsArg tm ty
numVisibleArgs :: [HsArg tm ty] -> Arity

-- | <tt><a>pprHsArgsApp</a> id fixity args</tt> pretty-prints an
--   application of <tt>id</tt> to <tt>args</tt>, using the <tt>fixity</tt>
--   to tell whether <tt>id</tt> should be printed prefix or infix.
--   Examples:
--   
--   <pre>
--   pprHsArgsApp T Prefix [HsTypeArg Bool, HsValArg Int]                        = T @Bool Int
--   pprHsArgsApp T Prefix [HsTypeArg Bool, HsArgPar, HsValArg Int]              = (T @Bool) Int
--   pprHsArgsApp (++) Infix [HsValArg Char, HsValArg Double]                    = Char ++ Double
--   pprHsArgsApp (++) Infix [HsValArg Char, HsValArg Double, HsVarArg Ordering] = (Char ++ Double) Ordering
--   </pre>
pprHsArgsApp :: (OutputableBndr id, Outputable tm, Outputable ty) => id -> LexicalFixity -> [HsArg tm ty] -> SDoc
type LHsTypeArg p = HsArg (LHsType p) (LHsKind p)

-- | Compute the <a>SrcSpan</a> associated with an <a>LHsTypeArg</a>.
lhsTypeArgSrcSpan :: LHsTypeArg (GhcPass pass) -> SrcSpan
class OutputableBndrFlag flag p

-- | Located Bang Type
type LBangType pass = XRec pass (BangType pass)

-- | Bang Type
--   
--   In the parser, strictness and packedness annotations bind more tightly
--   than docstrings. This means that when consuming a <a>BangType</a> (and
--   looking for <a>HsBangTy</a>) we must be ready to peer behind a
--   potential layer of <a>HsDocTy</a>. See #15206 for motivation and
--   <tt>getBangType</tt> for an example.
type BangType pass = HsType pass

-- | Haskell Source Bang
--   
--   Bangs on data constructor arguments as the user wrote them in the
--   source code.
--   
--   <tt>(HsSrcBang _ SrcUnpack SrcLazy)</tt> and <tt>(HsSrcBang _
--   SrcUnpack NoSrcStrict)</tt> (without StrictData) makes no sense, we
--   emit a warning (in checkValidDataCon) and treat it like <tt>(HsSrcBang
--   _ NoSrcUnpack SrcLazy)</tt>
data HsSrcBang
HsSrcBang :: SourceText -> SrcUnpackedness -> SrcStrictness -> HsSrcBang

-- | Haskell Implementation Bang
--   
--   Bangs of data constructor arguments as generated by the compiler after
--   consulting HsSrcBang, flags, etc.
data HsImplBang

-- | Lazy field, or one with an unlifted type
HsLazy :: HsImplBang

-- | Strict but not unpacked field True <a>=</a> we could have unpacked,
--   but opted not to because of -O0. See Note [Detecting useless UNPACK
--   pragmas]
HsStrict :: Bool -> HsImplBang

-- | Strict and unpacked field co :: arg-ty ~ product-ty HsBang
HsUnpack :: Maybe Coercion -> HsImplBang

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie <tt>~</tt>
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {-# UNPACK #-} specified
SrcUnpack :: SrcUnpackedness

-- | {-# NOUNPACK #-} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness
getBangType :: LHsType (GhcPass p) -> LHsType (GhcPass p)
getBangStrictness :: LHsType (GhcPass p) -> HsSrcBang

-- | Constructor Declaration Field
data ConDeclField pass
ConDeclField :: XConDeclField pass -> [LFieldOcc pass] -> LBangType pass -> Maybe (LHsDoc pass) -> ConDeclField pass
[cd_fld_ext] :: ConDeclField pass -> XConDeclField pass

-- | See Note [ConDeclField pass]
[cd_fld_names] :: ConDeclField pass -> [LFieldOcc pass]
[cd_fld_type] :: ConDeclField pass -> LBangType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
[cd_fld_doc] :: ConDeclField pass -> Maybe (LHsDoc pass)
XConDeclField :: !XXConDeclField pass -> ConDeclField pass

-- | Located Constructor Declaration Field
type LConDeclField pass = -- | May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when --   in a list XRec pass (ConDeclField pass)
pprConDeclFields :: OutputableBndrId p => [LConDeclField (GhcPass p)] -> SDoc

-- | Describes the arguments to a data constructor. This is a common
--   representation for several constructor-related concepts, including:
--   
--   <ul>
--   <li>The arguments in a Haskell98-style constructor declaration (see
--   <tt>HsConDeclH98Details</tt> in <a>GHC.Hs.Decls</a>).</li>
--   <li>The arguments in constructor patterns in <tt>case</tt>/function
--   definitions (see <tt>HsConPatDetails</tt> in <a>GHC.Hs.Pat</a>).</li>
--   <li>The left-hand side arguments in a pattern synonym binding (see
--   <tt>HsPatSynDetails</tt> in <a>GHC.Hs.Binds</a>).</li>
--   </ul>
--   
--   One notable exception is the arguments in a GADT constructor, which
--   uses a separate data type entirely (see <tt>HsConDeclGADTDetails</tt>
--   in <a>GHC.Hs.Decls</a>). This is because GADT constructors cannot be
--   declared with infix syntax, unlike the concepts above (#18844).
data HsConDetails tyarg arg rec
PrefixCon :: [tyarg] -> [arg] -> HsConDetails tyarg arg rec
RecCon :: rec -> HsConDetails tyarg arg rec
InfixCon :: arg -> arg -> HsConDetails tyarg arg rec

-- | An empty list that can be used to indicate that there are no type
--   arguments allowed in cases where HsConDetails is applied to Void.
noTypeArgs :: [Void]

-- | Field Occurrence
--   
--   Represents an *occurrence* of a field. This may or may not be a
--   binding occurrence (e.g. this type is used in <a>ConDeclField</a> and
--   <tt>RecordPatSynField</tt> which bind their fields, but also in
--   <tt>HsRecField</tt> for record construction and patterns, which do
--   not).
--   
--   We store both the <a>RdrName</a> the user originally wrote, and after
--   the renamer we use the extension field to store the selector function.
data FieldOcc pass
FieldOcc :: XCFieldOcc pass -> XRec pass RdrName -> FieldOcc pass
[foExt] :: FieldOcc pass -> XCFieldOcc pass
[foLabel] :: FieldOcc pass -> XRec pass RdrName
XFieldOcc :: !XXFieldOcc pass -> FieldOcc pass

-- | Located Field Occurrence
type LFieldOcc pass = XRec pass (FieldOcc pass)
mkFieldOcc :: LocatedN RdrName -> FieldOcc GhcPs

-- | Ambiguous Field Occurrence
--   
--   Represents an *occurrence* of a field that is potentially ambiguous
--   after the renamer, with the ambiguity resolved by the typechecker. We
--   always store the <a>RdrName</a> that the user originally wrote, and
--   store the selector function after the renamer (for unambiguous
--   occurrences) or the typechecker (for ambiguous occurrences).
--   
--   See Note [HsRecField and HsRecUpdField] in <a>GHC.Hs.Pat</a>. See Note
--   [Located RdrNames] in <a>GHC.Hs.Expr</a>.
data AmbiguousFieldOcc pass
Unambiguous :: XUnambiguous pass -> XRec pass RdrName -> AmbiguousFieldOcc pass
Ambiguous :: XAmbiguous pass -> XRec pass RdrName -> AmbiguousFieldOcc pass
XAmbiguousFieldOcc :: !XXAmbiguousFieldOcc pass -> AmbiguousFieldOcc pass

-- | Located Ambiguous Field Occurence
type LAmbiguousFieldOcc pass = XRec pass (AmbiguousFieldOcc pass)
mkAmbiguousFieldOcc :: LocatedN RdrName -> AmbiguousFieldOcc GhcPs
rdrNameAmbiguousFieldOcc :: AmbiguousFieldOcc (GhcPass p) -> RdrName
selectorAmbiguousFieldOcc :: AmbiguousFieldOcc GhcTc -> Id
unambiguousFieldOcc :: AmbiguousFieldOcc GhcTc -> FieldOcc GhcTc
ambiguousFieldOcc :: FieldOcc GhcTc -> AmbiguousFieldOcc GhcTc
mkAnonWildCardTy :: HsType GhcPs
pprAnonWildCard :: SDoc
hsOuterTyVarNames :: HsOuterTyVarBndrs flag GhcRn -> [Name]
hsOuterExplicitBndrs :: HsOuterTyVarBndrs flag (GhcPass p) -> [LHsTyVarBndr flag (NoGhcTc (GhcPass p))]
mapHsOuterImplicit :: (XHsOuterImplicit pass -> XHsOuterImplicit pass) -> HsOuterTyVarBndrs flag pass -> HsOuterTyVarBndrs flag pass
mkHsOuterImplicit :: HsOuterTyVarBndrs flag GhcPs
mkHsOuterExplicit :: EpAnnForallTy -> [LHsTyVarBndr flag GhcPs] -> HsOuterTyVarBndrs flag GhcPs
mkHsImplicitSigType :: LHsType GhcPs -> HsSigType GhcPs
mkHsExplicitSigType :: EpAnnForallTy -> [LHsTyVarBndr Specificity GhcPs] -> LHsType GhcPs -> HsSigType GhcPs
mkHsWildCardBndrs :: thing -> HsWildCardBndrs GhcPs thing
mkHsPatSigType :: EpAnnCO -> LHsType GhcPs -> HsPatSigType GhcPs
mkEmptyWildCardBndrs :: thing -> HsWildCardBndrs GhcRn thing
mkHsForAllVisTele :: EpAnnForallTy -> [LHsTyVarBndr () (GhcPass p)] -> HsForAllTelescope (GhcPass p)
mkHsForAllInvisTele :: EpAnnForallTy -> [LHsTyVarBndr Specificity (GhcPass p)] -> HsForAllTelescope (GhcPass p)
mkHsQTvs :: [LHsTyVarBndr () GhcPs] -> LHsQTyVars GhcPs
hsQTvExplicit :: LHsQTyVars pass -> [LHsTyVarBndr () pass]
emptyLHsQTvs :: LHsQTyVars GhcRn

-- | Does this <a>HsTyVarBndr</a> come with an explicit kind annotation?
isHsKindedTyVar :: HsTyVarBndr flag pass -> Bool

-- | Do all type variables in this <a>LHsQTyVars</a> come with kind
--   annotations?
hsTvbAllKinded :: LHsQTyVars (GhcPass p) -> Bool
hsScopedTvs :: LHsSigType GhcRn -> [Name]
hsWcScopedTvs :: LHsSigWcType GhcRn -> [Name]
dropWildCards :: LHsSigWcType pass -> LHsSigType pass
hsTyVarName :: HsTyVarBndr flag (GhcPass p) -> IdP (GhcPass p)
hsAllLTyVarNames :: LHsQTyVars GhcRn -> [Name]
hsLTyVarLocNames :: LHsQTyVars (GhcPass p) -> [LocatedN (IdP (GhcPass p))]
hsLTyVarName :: LHsTyVarBndr flag (GhcPass p) -> IdP (GhcPass p)
hsLTyVarNames :: [LHsTyVarBndr flag (GhcPass p)] -> [IdP (GhcPass p)]
hsLTyVarLocName :: LHsTyVarBndr flag (GhcPass p) -> LocatedN (IdP (GhcPass p))
hsExplicitLTyVarNames :: LHsQTyVars (GhcPass p) -> [IdP (GhcPass p)]

-- | Decompose a type class instance type (of the form <tt>forall
--   <a>tvs</a>. context =&gt; instance_head</tt>) into its constituent
--   parts. Note that the <tt>[Name]</tt>s returned correspond to either:
--   
--   <ul>
--   <li>The implicitly bound type variables (if the type lacks an
--   outermost <tt>forall</tt>), or</li>
--   <li>The explicitly bound type variables (if the type has an outermost
--   <tt>forall</tt>).</li>
--   </ul>
--   
--   This function is careful not to look through parentheses. See <tt>Note
--   [No nested foralls or contexts in instance types]</tt> for why this is
--   important.
splitLHsInstDeclTy :: LHsSigType GhcRn -> ([Name], Maybe (LHsContext GhcRn), LHsType GhcRn)

-- | Decompose a type class instance type (of the form <tt>forall
--   <a>tvs</a>. context =&gt; instance_head</tt>) into the
--   <tt>instance_head</tt>.
getLHsInstDeclHead :: LHsSigType (GhcPass p) -> LHsType (GhcPass p)

-- | Decompose a type class instance type (of the form <tt>forall
--   <a>tvs</a>. context =&gt; instance_head</tt>) into the
--   <tt>instance_head</tt> and retrieve the underlying class type
--   constructor (if it exists).
getLHsInstDeclClass_maybe :: Anno (IdGhcP p) ~ SrcSpanAnnN => LHsSigType (GhcPass p) -> Maybe (LocatedN (IdP (GhcPass p)))

-- | Decompose a pattern synonym type signature into its constituent parts.
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(forall a. <a>...</a>)</tt>. The downside to this is
--   that it is not generally possible to take the returned types and
--   reconstruct the original type (parentheses and all) from them.
splitLHsPatSynTy :: LHsSigType (GhcPass p) -> ([LHsTyVarBndr Specificity (GhcPass (NoGhcTcPass p))], Maybe (LHsContext (GhcPass p)), [LHsTyVarBndr Specificity (GhcPass p)], Maybe (LHsContext (GhcPass p)), LHsType (GhcPass p))

-- | Decompose a type of the form <tt>forall <a>tvs</a>. body</tt> into its
--   constituent parts. Only splits type variable binders that were
--   quantified invisibly (e.g., <tt>forall a.</tt>, with a dot).
--   
--   This function is used to split apart certain types, such as instance
--   declaration types, which disallow visible <tt>forall</tt>s. For
--   instance, if GHC split apart the <tt>forall</tt> in <tt>instance
--   forall a -&gt; Show (Blah a)</tt>, then that declaration would
--   mistakenly be accepted!
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(forall a. <a>...</a>)</tt>. The downside to this is
--   that it is not generally possible to take the returned types and
--   reconstruct the original type (parentheses and all) from them. Unlike
--   <a>splitLHsSigmaTyInvis</a>, this function does not look through
--   parentheses, hence the suffix <tt>_KP</tt> (short for "Keep
--   Parentheses").
splitLHsForAllTyInvis :: LHsType (GhcPass pass) -> ((EpAnnForallTy, [LHsTyVarBndr Specificity (GhcPass pass)]), LHsType (GhcPass pass))

-- | Decompose a type of the form <tt>forall <a>tvs</a>. body</tt> into its
--   constituent parts. Only splits type variable binders that were
--   quantified invisibly (e.g., <tt>forall a.</tt>, with a dot).
--   
--   This function is used to split apart certain types, such as instance
--   declaration types, which disallow visible <tt>forall</tt>s. For
--   instance, if GHC split apart the <tt>forall</tt> in <tt>instance
--   forall a -&gt; Show (Blah a)</tt>, then that declaration would
--   mistakenly be accepted!
--   
--   Unlike <a>splitLHsForAllTyInvis</a>, this function does not look
--   through parentheses, hence the suffix <tt>_KP</tt> (short for "Keep
--   Parentheses").
splitLHsForAllTyInvis_KP :: LHsType (GhcPass pass) -> (Maybe (EpAnnForallTy, [LHsTyVarBndr Specificity (GhcPass pass)]), LHsType (GhcPass pass))

-- | Decompose a type of the form <tt>context =&gt; body</tt> into its
--   constituent parts.
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(context =&gt; <a>...</a>)</tt>. The downside to
--   this is that it is not generally possible to take the returned types
--   and reconstruct the original type (parentheses and all) from them.
splitLHsQualTy :: LHsType (GhcPass pass) -> (Maybe (LHsContext (GhcPass pass)), LHsType (GhcPass pass))

-- | Decompose a sigma type (of the form <tt>forall <a>tvs</a>. context
--   =&gt; body</tt>) into its constituent parts. Only splits type variable
--   binders that were quantified invisibly (e.g., <tt>forall a.</tt>, with
--   a dot).
--   
--   This function is used to split apart certain types, such as instance
--   declaration types, which disallow visible <tt>forall</tt>s. For
--   instance, if GHC split apart the <tt>forall</tt> in <tt>instance
--   forall a -&gt; Show (Blah a)</tt>, then that declaration would
--   mistakenly be accepted!
--   
--   Note that this function looks through parentheses, so it will work on
--   types such as <tt>(forall a. <a>...</a>)</tt>. The downside to this is
--   that it is not generally possible to take the returned types and
--   reconstruct the original type (parentheses and all) from them.
splitLHsSigmaTyInvis :: LHsType (GhcPass p) -> ([LHsTyVarBndr Specificity (GhcPass p)], Maybe (LHsContext (GhcPass p)), LHsType (GhcPass p))

-- | Decompose a GADT type into its constituent parts. Returns
--   <tt>(outer_bndrs, mb_ctxt, body)</tt>, where:
--   
--   <ul>
--   <li><tt>outer_bndrs</tt> are <a>HsOuterExplicit</a> if the type has
--   explicit, outermost type variable binders. Otherwise, they are
--   <a>HsOuterImplicit</a>.</li>
--   <li><tt>mb_ctxt</tt> is <tt>Just</tt> the context, if it is provided.
--   Otherwise, it is <tt>Nothing</tt>.</li>
--   <li><tt>body</tt> is the body of the type after the optional
--   <tt>forall</tt>s and context.</li>
--   </ul>
--   
--   This function is careful not to look through parentheses. See <tt>Note
--   [GADT abstract syntax] (Wrinkle: No nested foralls or contexts)</tt>
--   <a>GHC.Hs.Decls</a> for why this is important.
splitLHsGadtTy :: LHsSigType GhcPs -> (HsOuterSigTyVarBndrs GhcPs, Maybe (LHsContext GhcPs), LHsType GhcPs)
splitHsFunType :: LHsType (GhcPass p) -> ([AddEpAnn], EpAnnComments, [HsScaled (GhcPass p) (LHsType (GhcPass p))], LHsType (GhcPass p))

-- | Retrieve the name of the "head" of a nested type application. This is
--   somewhat like <tt>GHC.Tc.Gen.HsType.splitHsAppTys</tt>, but a little
--   more thorough. The purpose of this function is to examine instance
--   heads, so it doesn't handle *all* cases (like lists, tuples,
--   <tt>(~)</tt>, etc.).
hsTyGetAppHead_maybe :: Anno (IdGhcP p) ~ SrcSpanAnnN => LHsType (GhcPass p) -> Maybe (LocatedN (IdP (GhcPass p)))
mkHsOpTy :: Anno (IdGhcP p) ~ SrcSpanAnnN => PromotionFlag -> LHsType (GhcPass p) -> LocatedN (IdP (GhcPass p)) -> LHsType (GhcPass p) -> HsType (GhcPass p)
mkHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
mkHsAppTys :: LHsType (GhcPass p) -> [LHsType (GhcPass p)] -> LHsType (GhcPass p)
mkHsAppKindTy :: XAppKindTy (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
ignoreParens :: LHsType (GhcPass p) -> LHsType (GhcPass p)
hsSigWcType :: forall p. UnXRec p => LHsSigWcType p -> LHsType p
hsPatSigType :: HsPatSigType pass -> LHsType pass

-- | Get the kind signature of a type, ignoring parentheses:
--   
--   hsTyKindSig `Maybe ` = Nothing hsTyKindSig `Maybe :: Type -&gt; Type `
--   = Just `Type -&gt; Type` hsTyKindSig `Maybe :: ((Type -&gt; Type))` =
--   Just `Type -&gt; Type`
--   
--   This is used to extract the result kind of type synonyms with a CUSK:
--   
--   type S = (F :: res_kind) ^^^^^^^^
hsTyKindSig :: LHsType (GhcPass p) -> Maybe (LHsKind (GhcPass p))

-- | Set the attached flag
setHsTyVarBndrFlag :: flag -> HsTyVarBndr flag' (GhcPass pass) -> HsTyVarBndr flag (GhcPass pass)

-- | Return the attached flag
hsTyVarBndrFlag :: HsTyVarBndr flag (GhcPass pass) -> flag
pprHsType :: OutputableBndrId p => HsType (GhcPass p) -> SDoc

-- | Prints a forall; When passed an empty list, prints <tt>forall
--   .</tt>/<tt>forall -&gt;</tt> only when <tt>-dppr-debug</tt> is
--   enabled.
pprHsForAll :: forall p. OutputableBndrId p => HsForAllTelescope (GhcPass p) -> Maybe (LHsContext (GhcPass p)) -> SDoc

-- | Prints the explicit <tt>forall</tt> in a type family equation if one
--   is written. If there is no explicit <tt>forall</tt>, nothing is
--   printed.
pprHsOuterFamEqnTyVarBndrs :: OutputableBndrId p => HsOuterFamEqnTyVarBndrs (GhcPass p) -> SDoc

-- | Prints the outermost <tt>forall</tt> in a type signature if one is
--   written. If there is no outermost <tt>forall</tt>, nothing is printed.
pprHsOuterSigTyVarBndrs :: OutputableBndrId p => HsOuterSigTyVarBndrs (GhcPass p) -> SDoc
pprLHsContext :: OutputableBndrId p => Maybe (LHsContext (GhcPass p)) -> SDoc

-- | <tt><a>hsTypeNeedsParens</a> p t</tt> returns <a>True</a> if the type
--   <tt>t</tt> needs parentheses under precedence <tt>p</tt>.
hsTypeNeedsParens :: PprPrec -> HsType (GhcPass p) -> Bool

-- | <tt><a>parenthesizeHsType</a> p ty</tt> checks if
--   <tt><a>hsTypeNeedsParens</a> p ty</tt> is true, and if so, surrounds
--   <tt>ty</tt> with an <a>HsParTy</a>. Otherwise, it simply returns
--   <tt>ty</tt>.
parenthesizeHsType :: PprPrec -> LHsType (GhcPass p) -> LHsType (GhcPass p)

-- | <tt><a>parenthesizeHsContext</a> p ctxt</tt> checks if <tt>ctxt</tt>
--   is a single constraint <tt>c</tt> such that
--   <tt><a>hsTypeNeedsParens</a> p c</tt> is true, and if so, surrounds
--   <tt>c</tt> with an <a>HsParTy</a> to form a parenthesized
--   <tt>ctxt</tt>. Otherwise, it simply returns <tt>ctxt</tt> unchanged.
parenthesizeHsContext :: PprPrec -> LHsContext (GhcPass p) -> LHsContext (GhcPass p)
instance Data.Data.Data GHC.Hs.Type.HsPSRn
instance GHC.Hs.Type.OutputableBndrFlag () p
instance GHC.Hs.Type.OutputableBndrFlag GHC.Types.Var.Specificity p
instance (GHC.Hs.Type.OutputableBndrFlag flag p, GHC.Hs.Type.OutputableBndrFlag flag (GHC.Hs.Extension.NoGhcTcPass p), GHC.Hs.Extension.OutputableBndrId p) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag (GHC.Hs.Extension.GhcPass p))
instance (GHC.Hs.Extension.OutputableBndrId p, GHC.Hs.Type.OutputableBndrFlag flag p) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsTyVarBndr flag (GHC.Hs.Extension.GhcPass p))
instance GHC.Types.Name.NamedThing (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcRn)
instance GHC.Hs.Extension.OutputableBndrId pass => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsArrow (GHC.Hs.Extension.GhcPass pass))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.ConDeclField (GHC.Hs.Extension.GhcPass p))
instance (GHC.Utils.Outputable.Outputable tm, GHC.Utils.Outputable.Outputable ty) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsArg tm ty)
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.AmbiguousFieldOcc (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Type.AmbiguousFieldOcc (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.OutputableBndr (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Type.AmbiguousFieldOcc (GHC.Hs.Extension.GhcPass p)))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsSigType (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsType (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.LHsQTyVars (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsForAllTelescope (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable thing => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsWildCardBndrs (GHC.Hs.Extension.GhcPass p) thing)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsPatSigType (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsTyLit (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Type.HsIPName
instance GHC.Utils.Outputable.OutputableBndr Language.Haskell.Syntax.Type.HsIPName
instance (GHC.Utils.Outputable.Outputable tyarg, GHC.Utils.Outputable.Outputable arg, GHC.Utils.Outputable.Outputable rec) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsConDetails tyarg arg rec)
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec pass GHC.Types.Name.Reader.RdrName) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.FieldOcc pass)
instance (Language.Haskell.Syntax.Extension.UnXRec pass, GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Extension.XRec pass GHC.Types.Name.Reader.RdrName)) => GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Type.FieldOcc pass)
instance (Language.Haskell.Syntax.Extension.UnXRec pass, GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Extension.XRec pass GHC.Types.Name.Reader.RdrName)) => GHC.Utils.Outputable.OutputableBndr (GHC.Types.SrcLoc.GenLocated GHC.Types.SrcLoc.SrcSpan (Language.Haskell.Syntax.Type.FieldOcc pass))


-- | A module concerned with finding the free variables of an expression.
module GHC.Core.FVs

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a non-deterministic set.
exprFreeVars :: CoreExpr -> VarSet

-- | Find all locally-defined free Ids or type variables in several
--   expressions returning a non-deterministic set.
exprsFreeVars :: [CoreExpr] -> VarSet

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a deterministic set.
exprFreeVarsDSet :: CoreExpr -> DVarSet

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a deterministically ordered list.
exprFreeVarsList :: CoreExpr -> [Var]

-- | Find all locally-defined free Ids or type variables in several
--   expressions returning a deterministically ordered list.
exprsFreeVarsList :: [CoreExpr] -> [Var]

-- | Find all locally-defined free Ids in an expression
exprFreeIds :: CoreExpr -> IdSet
exprsFreeIds :: [CoreExpr] -> IdSet

-- | Find all locally-defined free Ids in an expression returning a
--   deterministic set.
exprFreeIdsDSet :: CoreExpr -> DIdSet

-- | Find all locally-defined free Ids in several expressions returning a
--   deterministic set.
exprsFreeIdsDSet :: [CoreExpr] -> DIdSet

-- | Find all locally-defined free Ids in an expression returning a
--   deterministically ordered list.
exprFreeIdsList :: CoreExpr -> [Id]

-- | Find all locally-defined free Ids in several expressions returning a
--   deterministically ordered list.
exprsFreeIdsList :: [CoreExpr] -> [Id]

-- | Find all locally defined free Ids in a binding group
bindFreeVars :: CoreBind -> VarSet

-- | Predicate on possible free variables: returns <tt>True</tt> iff the
--   variable is interesting
type InterestingVarFun = Var -> Bool

-- | Finds free variables in an expression selected by a predicate
exprSomeFreeVars :: InterestingVarFun -> CoreExpr -> VarSet

-- | Finds free variables in several expressions selected by a predicate
exprsSomeFreeVars :: InterestingVarFun -> [CoreExpr] -> VarSet

-- | Finds free variables in an expression selected by a predicate
--   returning a deterministically ordered list.
exprSomeFreeVarsList :: InterestingVarFun -> CoreExpr -> [Var]

-- | Finds free variables in several expressions selected by a predicate
--   returning a deterministically ordered list.
exprsSomeFreeVarsList :: InterestingVarFun -> [CoreExpr] -> [Var]
varTypeTyCoVars :: Var -> TyCoVarSet
varTypeTyCoFVs :: Var -> FV
idUnfoldingVars :: Id -> VarSet
idFreeVars :: Id -> VarSet
dIdFreeVars :: Id -> DVarSet
bndrRuleAndUnfoldingVarsDSet :: Id -> DVarSet
bndrRuleAndUnfoldingIds :: Id -> IdSet
idFVs :: Id -> FV
idRuleVars :: Id -> VarSet
stableUnfoldingVars :: Unfolding -> Maybe VarSet

-- | Those variables free in the both the left right hand sides of a rule
--   returned as a non-deterministic set
ruleFreeVars :: CoreRule -> VarSet

-- | Those variables free in both the left right hand sides of several
--   rules
rulesFreeVars :: [CoreRule] -> VarSet

-- | Those variables free in the both the left right hand sides of rules
--   returned as a deterministic set
rulesFreeVarsDSet :: [CoreRule] -> DVarSet

-- | Make a <a>RuleInfo</a> containing a number of <a>CoreRule</a>s,
--   suitable for putting into an <a>IdInfo</a>
mkRuleInfo :: [CoreRule] -> RuleInfo

-- | This finds all locally-defined free Ids on the left hand side of a
--   rule and returns them as a non-deterministic set
ruleLhsFreeIds :: CoreRule -> VarSet

-- | This finds all locally-defined free Ids on the left hand side of a
--   rule and returns them as a deterministically ordered list
ruleLhsFreeIdsList :: CoreRule -> [Var]

-- | Those variables free in the right hand side of a rule returned as a
--   non-deterministic set
ruleRhsFreeVars :: CoreRule -> VarSet

-- | Those locally-defined free <a>Id</a>s in the right hand side of
--   several rules returned as a non-deterministic set
rulesRhsFreeIds :: [CoreRule] -> VarSet

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a composable FV computation. See Note [FV naming
--   conventions] in <a>GHC.Utils.FV</a> for why export it.
exprFVs :: CoreExpr -> FV
orphNamesOfType :: Type -> NameSet
orphNamesOfTypes :: [Type] -> NameSet
orphNamesOfCo :: Coercion -> NameSet
orphNamesOfCoCon :: CoAxiom br -> NameSet

-- | <a>orphNamesOfAxiomLHS</a> collects the names of the concrete types
--   and type constructors that make up the LHS of a type family instance,
--   including the family name itself.
--   
--   For instance, given `type family Foo a b`: `type instance Foo (F (G (H
--   a))) b = ...` would yield [Foo,F,G,H]
--   
--   Used (via orphNamesOfFamInst) in the implementation of ":info" in
--   GHCi. and when determining orphan-hood for a FamInst or module
orphNamesOfAxiomLHS :: CoAxiom br -> NameSet

-- | Finds the free <i>external</i> names of several expressions: see
--   <a>exprOrphNames</a> for details
exprsOrphNames :: [CoreExpr] -> NameSet
type FVAnn = DVarSet

-- | Every node in an expression annotated with its (non-global) free
--   variables, both Ids and TyVars, and type. NB: see Note [The FVAnn
--   invariant]
type CoreExprWithFVs = AnnExpr Id FVAnn
type CoreExprWithFVs' = AnnExpr' Id FVAnn

-- | Every node in a binding group annotated with its (non-global) free
--   variables, both Ids and TyVars, and type.
type CoreBindWithFVs = AnnBind Id FVAnn

-- | Every node in an expression annotated with its (non-global) free
--   variables, both Ids and TyVars, and type.
type CoreAltWithFVs = AnnAlt Id FVAnn

-- | Annotate a <a>CoreExpr</a> with its (non-global) free type and value
--   variables at every tree node.
freeVars :: CoreExpr -> CoreExprWithFVs
freeVarsBind :: CoreBind -> DVarSet -> (CoreBindWithFVs, DVarSet)

-- | Inverse function to <a>freeVars</a>
freeVarsOf :: CoreExprWithFVs -> DIdSet

-- | Extract the vars reported in a FVAnn
freeVarsOfAnn :: FVAnn -> DIdSet

module GHC.Core.FamInstEnv
data FamInst
FamInst :: CoAxiom Unbranched -> FamFlavor -> Name -> [RoughMatchTc] -> [TyVar] -> [CoVar] -> [Type] -> Type -> FamInst
[fi_axiom] :: FamInst -> CoAxiom Unbranched
[fi_flavor] :: FamInst -> FamFlavor
[fi_fam] :: FamInst -> Name
[fi_tcs] :: FamInst -> [RoughMatchTc]
[fi_tvs] :: FamInst -> [TyVar]
[fi_cvs] :: FamInst -> [CoVar]
[fi_tys] :: FamInst -> [Type]
[fi_rhs] :: FamInst -> Type
data FamFlavor
SynFamilyInst :: FamFlavor
DataFamilyInst :: TyCon -> FamFlavor
famInstAxiom :: FamInst -> CoAxiom Unbranched
famInstTyCon :: FamInst -> TyCon
famInstRHS :: FamInst -> Type
famInstsRepTyCons :: [FamInst] -> [TyCon]
famInstRepTyCon_maybe :: FamInst -> Maybe TyCon
dataFamInstRepTyCon :: FamInst -> TyCon
pprFamInst :: FamInst -> SDoc
pprFamInsts :: [FamInst] -> SDoc
orphNamesOfFamInst :: FamInst -> NameSet
mkImportedFamInst :: Name -> [RoughMatchTc] -> CoAxiom Unbranched -> FamInst
type FamInstEnvs = (FamInstEnv, FamInstEnv)
data FamInstEnv
emptyFamInstEnv :: FamInstEnv

-- | Create a <a>FamInstEnv</a> from <a>Name</a> indices. INVARIANTS: * The
--   fs_tvs are distinct in each FamInst of a range value of the map (so we
--   can safely unify them)
emptyFamInstEnvs :: (FamInstEnv, FamInstEnv)

-- | Makes no particular effort to detect conflicts.
unionFamInstEnv :: FamInstEnv -> FamInstEnv -> FamInstEnv
extendFamInstEnv :: FamInstEnv -> FamInst -> FamInstEnv
extendFamInstEnvList :: FamInstEnv -> [FamInst] -> FamInstEnv
famInstEnvElts :: FamInstEnv -> [FamInst]
famInstEnvSize :: FamInstEnv -> Int
familyInstances :: (FamInstEnv, FamInstEnv) -> TyCon -> [FamInst]
familyNameInstances :: (FamInstEnv, FamInstEnv) -> Name -> [FamInst]
mkCoAxBranch :: [TyVar] -> [TyVar] -> [CoVar] -> [Type] -> Type -> [Role] -> SrcSpan -> CoAxBranch
mkBranchedCoAxiom :: Name -> TyCon -> [CoAxBranch] -> CoAxiom Branched
mkUnbranchedCoAxiom :: Name -> TyCon -> CoAxBranch -> CoAxiom Unbranched
mkSingleCoAxiom :: Role -> Name -> [TyVar] -> [TyVar] -> [CoVar] -> TyCon -> [Type] -> Type -> CoAxiom Unbranched

-- | Create a coercion constructor (axiom) suitable for the given newtype
--   <a>TyCon</a>. The <a>Name</a> should be that of a new coercion
--   <a>CoAxiom</a>, the <a>TyVar</a>s the arguments expected by the
--   <tt>newtype</tt> and the type the appropriate right hand side of the
--   <tt>newtype</tt>, with the free variables a subset of those
--   <a>TyVar</a>s.
mkNewTypeCoAxiom :: Name -> TyCon -> [TyVar] -> [Role] -> Type -> CoAxiom Unbranched
data FamInstMatch
FamInstMatch :: FamInst -> [Type] -> [Coercion] -> FamInstMatch
[fim_instance] :: FamInstMatch -> FamInst
[fim_tys] :: FamInstMatch -> [Type]
[fim_cos] :: FamInstMatch -> [Coercion]
lookupFamInstEnv :: FamInstEnvs -> TyCon -> [Type] -> [FamInstMatch]
lookupFamInstEnvConflicts :: FamInstEnvs -> FamInst -> [FamInst]
lookupFamInstEnvByTyCon :: FamInstEnvs -> TyCon -> [FamInst]
isDominatedBy :: CoAxBranch -> [CoAxBranch] -> Bool

-- | Do an apartness check, as described in the "Closed Type Families"
--   paper (POPL '14). This should be used when determining if an equation
--   (<a>CoAxBranch</a>) of a closed type family can be used to reduce a
--   certain target type family application.
apartnessCheck :: [Type] -> CoAxBranch -> Bool
compatibleBranches :: CoAxBranch -> CoAxBranch -> Bool

-- | Result of testing two type family equations for injectiviy.
data InjectivityCheckResult

-- | Either RHSs are distinct or unification of RHSs leads to unification
--   of LHSs
InjectivityAccepted :: InjectivityCheckResult

-- | RHSs unify but LHSs don't unify under that substitution. Relevant for
--   closed type families where equation after unification might be
--   overlapped (in which case it is OK if they don't unify). Constructor
--   stores axioms after unification.
InjectivityUnified :: CoAxBranch -> CoAxBranch -> InjectivityCheckResult

-- | Check whether an open type family equation can be added to already
--   existing instance environment without causing conflicts with supplied
--   injectivity annotations. Returns list of conflicting axioms (type
--   instance declarations).
lookupFamInstEnvInjectivityConflicts :: [Bool] -> FamInstEnvs -> FamInst -> [CoAxBranch]

-- | Check whether two type family axioms don't violate injectivity
--   annotation.
injectiveBranches :: [Bool] -> CoAxBranch -> CoAxBranch -> InjectivityCheckResult
topNormaliseType :: FamInstEnvs -> Type -> Type

-- | Get rid of *outermost* (or toplevel) * type function redex * data
--   family redex * newtypes returning an appropriate Representational
--   coercion. Specifically, if topNormaliseType_maybe env ty = Just (co,
--   ty') then (a) co :: ty ~R ty' (b) ty' is not a newtype, and is not a
--   type-family or data-family redex
--   
--   However, ty' can be something like (Maybe (F ty)), where (F ty) is a
--   redex.
--   
--   Always operates homogeneously: the returned type has the same kind as
--   the original type, and the returned coercion is always homogeneous.
topNormaliseType_maybe :: FamInstEnvs -> Type -> Maybe Reduction
normaliseType :: FamInstEnvs -> Role -> Type -> Reduction
normaliseTcApp :: FamInstEnvs -> Role -> TyCon -> [Type] -> Reduction

-- | Try to simplify a type-family application, by *one* step If
--   topReduceTyFamApp_maybe env r F tys = Just (HetReduction (Reduction co
--   rhs) res_co) then co :: F tys ~R# rhs res_co :: typeKind(F tys) ~
--   typeKind(rhs) Type families and data families; always Representational
--   role
topReduceTyFamApp_maybe :: FamInstEnvs -> TyCon -> [Type] -> Maybe HetReduction
reduceTyFamApp_maybe :: FamInstEnvs -> Role -> TyCon -> [Type] -> Maybe Reduction
instance GHC.Base.Functor GHC.Core.FamInstEnv.NormM
instance GHC.Base.Monad GHC.Core.FamInstEnv.NormM
instance GHC.Base.Applicative GHC.Core.FamInstEnv.NormM
instance GHC.Utils.Outputable.Outputable GHC.Core.FamInstEnv.FamInstMatch
instance GHC.Utils.Outputable.Outputable GHC.Core.FamInstEnv.FamInstEnv
instance GHC.Types.Name.NamedThing GHC.Core.FamInstEnv.FamInst
instance GHC.Utils.Outputable.Outputable GHC.Core.FamInstEnv.FamInst

module GHC.Types.TypeEnv

-- | A map from <a>Name</a>s to <a>TyThing</a>s, constructed by
--   typechecking local declarations or interface files
type TypeEnv = NameEnv TyThing
emptyTypeEnv :: TypeEnv
lookupTypeEnv :: TypeEnv -> Name -> Maybe TyThing
mkTypeEnv :: [TyThing] -> TypeEnv
typeEnvFromEntities :: [Id] -> [TyCon] -> [PatSyn] -> [FamInst] -> TypeEnv
mkTypeEnvWithImplicits :: [TyThing] -> TypeEnv
extendTypeEnv :: TypeEnv -> TyThing -> TypeEnv
extendTypeEnvList :: TypeEnv -> [TyThing] -> TypeEnv
extendTypeEnvWithIds :: TypeEnv -> [Id] -> TypeEnv
plusTypeEnv :: TypeEnv -> TypeEnv -> TypeEnv
typeEnvElts :: TypeEnv -> [TyThing]
typeEnvTyCons :: TypeEnv -> [TyCon]
typeEnvIds :: TypeEnv -> [Id]
typeEnvPatSyns :: TypeEnv -> [PatSyn]
typeEnvDataCons :: TypeEnv -> [DataCon]
typeEnvCoAxioms :: TypeEnv -> [CoAxiom Branched]
typeEnvClasses :: TypeEnv -> [Class]

module GHC.Builtin.PrimOps
data PrimOp
CharGtOp :: PrimOp
CharGeOp :: PrimOp
CharEqOp :: PrimOp
CharNeOp :: PrimOp
CharLtOp :: PrimOp
CharLeOp :: PrimOp
OrdOp :: PrimOp
Int8ToIntOp :: PrimOp
IntToInt8Op :: PrimOp
Int8NegOp :: PrimOp
Int8AddOp :: PrimOp
Int8SubOp :: PrimOp
Int8MulOp :: PrimOp
Int8QuotOp :: PrimOp
Int8RemOp :: PrimOp
Int8QuotRemOp :: PrimOp
Int8SllOp :: PrimOp
Int8SraOp :: PrimOp
Int8SrlOp :: PrimOp
Int8ToWord8Op :: PrimOp
Int8EqOp :: PrimOp
Int8GeOp :: PrimOp
Int8GtOp :: PrimOp
Int8LeOp :: PrimOp
Int8LtOp :: PrimOp
Int8NeOp :: PrimOp
Word8ToWordOp :: PrimOp
WordToWord8Op :: PrimOp
Word8AddOp :: PrimOp
Word8SubOp :: PrimOp
Word8MulOp :: PrimOp
Word8QuotOp :: PrimOp
Word8RemOp :: PrimOp
Word8QuotRemOp :: PrimOp
Word8AndOp :: PrimOp
Word8OrOp :: PrimOp
Word8XorOp :: PrimOp
Word8NotOp :: PrimOp
Word8SllOp :: PrimOp
Word8SrlOp :: PrimOp
Word8ToInt8Op :: PrimOp
Word8EqOp :: PrimOp
Word8GeOp :: PrimOp
Word8GtOp :: PrimOp
Word8LeOp :: PrimOp
Word8LtOp :: PrimOp
Word8NeOp :: PrimOp
Int16ToIntOp :: PrimOp
IntToInt16Op :: PrimOp
Int16NegOp :: PrimOp
Int16AddOp :: PrimOp
Int16SubOp :: PrimOp
Int16MulOp :: PrimOp
Int16QuotOp :: PrimOp
Int16RemOp :: PrimOp
Int16QuotRemOp :: PrimOp
Int16SllOp :: PrimOp
Int16SraOp :: PrimOp
Int16SrlOp :: PrimOp
Int16ToWord16Op :: PrimOp
Int16EqOp :: PrimOp
Int16GeOp :: PrimOp
Int16GtOp :: PrimOp
Int16LeOp :: PrimOp
Int16LtOp :: PrimOp
Int16NeOp :: PrimOp
Word16ToWordOp :: PrimOp
WordToWord16Op :: PrimOp
Word16AddOp :: PrimOp
Word16SubOp :: PrimOp
Word16MulOp :: PrimOp
Word16QuotOp :: PrimOp
Word16RemOp :: PrimOp
Word16QuotRemOp :: PrimOp
Word16AndOp :: PrimOp
Word16OrOp :: PrimOp
Word16XorOp :: PrimOp
Word16NotOp :: PrimOp
Word16SllOp :: PrimOp
Word16SrlOp :: PrimOp
Word16ToInt16Op :: PrimOp
Word16EqOp :: PrimOp
Word16GeOp :: PrimOp
Word16GtOp :: PrimOp
Word16LeOp :: PrimOp
Word16LtOp :: PrimOp
Word16NeOp :: PrimOp
Int32ToIntOp :: PrimOp
IntToInt32Op :: PrimOp
Int32NegOp :: PrimOp
Int32AddOp :: PrimOp
Int32SubOp :: PrimOp
Int32MulOp :: PrimOp
Int32QuotOp :: PrimOp
Int32RemOp :: PrimOp
Int32QuotRemOp :: PrimOp
Int32SllOp :: PrimOp
Int32SraOp :: PrimOp
Int32SrlOp :: PrimOp
Int32ToWord32Op :: PrimOp
Int32EqOp :: PrimOp
Int32GeOp :: PrimOp
Int32GtOp :: PrimOp
Int32LeOp :: PrimOp
Int32LtOp :: PrimOp
Int32NeOp :: PrimOp
Word32ToWordOp :: PrimOp
WordToWord32Op :: PrimOp
Word32AddOp :: PrimOp
Word32SubOp :: PrimOp
Word32MulOp :: PrimOp
Word32QuotOp :: PrimOp
Word32RemOp :: PrimOp
Word32QuotRemOp :: PrimOp
Word32AndOp :: PrimOp
Word32OrOp :: PrimOp
Word32XorOp :: PrimOp
Word32NotOp :: PrimOp
Word32SllOp :: PrimOp
Word32SrlOp :: PrimOp
Word32ToInt32Op :: PrimOp
Word32EqOp :: PrimOp
Word32GeOp :: PrimOp
Word32GtOp :: PrimOp
Word32LeOp :: PrimOp
Word32LtOp :: PrimOp
Word32NeOp :: PrimOp
Int64ToIntOp :: PrimOp
IntToInt64Op :: PrimOp
Int64NegOp :: PrimOp
Int64AddOp :: PrimOp
Int64SubOp :: PrimOp
Int64MulOp :: PrimOp
Int64QuotOp :: PrimOp
Int64RemOp :: PrimOp
Int64SllOp :: PrimOp
Int64SraOp :: PrimOp
Int64SrlOp :: PrimOp
Int64ToWord64Op :: PrimOp
Int64EqOp :: PrimOp
Int64GeOp :: PrimOp
Int64GtOp :: PrimOp
Int64LeOp :: PrimOp
Int64LtOp :: PrimOp
Int64NeOp :: PrimOp
Word64ToWordOp :: PrimOp
WordToWord64Op :: PrimOp
Word64AddOp :: PrimOp
Word64SubOp :: PrimOp
Word64MulOp :: PrimOp
Word64QuotOp :: PrimOp
Word64RemOp :: PrimOp
Word64AndOp :: PrimOp
Word64OrOp :: PrimOp
Word64XorOp :: PrimOp
Word64NotOp :: PrimOp
Word64SllOp :: PrimOp
Word64SrlOp :: PrimOp
Word64ToInt64Op :: PrimOp
Word64EqOp :: PrimOp
Word64GeOp :: PrimOp
Word64GtOp :: PrimOp
Word64LeOp :: PrimOp
Word64LtOp :: PrimOp
Word64NeOp :: PrimOp
IntAddOp :: PrimOp
IntSubOp :: PrimOp
IntMulOp :: PrimOp
IntMul2Op :: PrimOp
IntMulMayOfloOp :: PrimOp
IntQuotOp :: PrimOp
IntRemOp :: PrimOp
IntQuotRemOp :: PrimOp
IntAndOp :: PrimOp
IntOrOp :: PrimOp
IntXorOp :: PrimOp
IntNotOp :: PrimOp
IntNegOp :: PrimOp
IntAddCOp :: PrimOp
IntSubCOp :: PrimOp
IntGtOp :: PrimOp
IntGeOp :: PrimOp
IntEqOp :: PrimOp
IntNeOp :: PrimOp
IntLtOp :: PrimOp
IntLeOp :: PrimOp
ChrOp :: PrimOp
IntToWordOp :: PrimOp
IntToFloatOp :: PrimOp
IntToDoubleOp :: PrimOp
WordToFloatOp :: PrimOp
WordToDoubleOp :: PrimOp
IntSllOp :: PrimOp
IntSraOp :: PrimOp
IntSrlOp :: PrimOp
WordAddOp :: PrimOp
WordAddCOp :: PrimOp
WordSubCOp :: PrimOp
WordAdd2Op :: PrimOp
WordSubOp :: PrimOp
WordMulOp :: PrimOp
WordMul2Op :: PrimOp
WordQuotOp :: PrimOp
WordRemOp :: PrimOp
WordQuotRemOp :: PrimOp
WordQuotRem2Op :: PrimOp
WordAndOp :: PrimOp
WordOrOp :: PrimOp
WordXorOp :: PrimOp
WordNotOp :: PrimOp
WordSllOp :: PrimOp
WordSrlOp :: PrimOp
WordToIntOp :: PrimOp
WordGtOp :: PrimOp
WordGeOp :: PrimOp
WordEqOp :: PrimOp
WordNeOp :: PrimOp
WordLtOp :: PrimOp
WordLeOp :: PrimOp
PopCnt8Op :: PrimOp
PopCnt16Op :: PrimOp
PopCnt32Op :: PrimOp
PopCnt64Op :: PrimOp
PopCntOp :: PrimOp
Pdep8Op :: PrimOp
Pdep16Op :: PrimOp
Pdep32Op :: PrimOp
Pdep64Op :: PrimOp
PdepOp :: PrimOp
Pext8Op :: PrimOp
Pext16Op :: PrimOp
Pext32Op :: PrimOp
Pext64Op :: PrimOp
PextOp :: PrimOp
Clz8Op :: PrimOp
Clz16Op :: PrimOp
Clz32Op :: PrimOp
Clz64Op :: PrimOp
ClzOp :: PrimOp
Ctz8Op :: PrimOp
Ctz16Op :: PrimOp
Ctz32Op :: PrimOp
Ctz64Op :: PrimOp
CtzOp :: PrimOp
BSwap16Op :: PrimOp
BSwap32Op :: PrimOp
BSwap64Op :: PrimOp
BSwapOp :: PrimOp
BRev8Op :: PrimOp
BRev16Op :: PrimOp
BRev32Op :: PrimOp
BRev64Op :: PrimOp
BRevOp :: PrimOp
Narrow8IntOp :: PrimOp
Narrow16IntOp :: PrimOp
Narrow32IntOp :: PrimOp
Narrow8WordOp :: PrimOp
Narrow16WordOp :: PrimOp
Narrow32WordOp :: PrimOp
DoubleGtOp :: PrimOp
DoubleGeOp :: PrimOp
DoubleEqOp :: PrimOp
DoubleNeOp :: PrimOp
DoubleLtOp :: PrimOp
DoubleLeOp :: PrimOp
DoubleAddOp :: PrimOp
DoubleSubOp :: PrimOp
DoubleMulOp :: PrimOp
DoubleDivOp :: PrimOp
DoubleNegOp :: PrimOp
DoubleFabsOp :: PrimOp
DoubleToIntOp :: PrimOp
DoubleToFloatOp :: PrimOp
DoubleExpOp :: PrimOp
DoubleExpM1Op :: PrimOp
DoubleLogOp :: PrimOp
DoubleLog1POp :: PrimOp
DoubleSqrtOp :: PrimOp
DoubleSinOp :: PrimOp
DoubleCosOp :: PrimOp
DoubleTanOp :: PrimOp
DoubleAsinOp :: PrimOp
DoubleAcosOp :: PrimOp
DoubleAtanOp :: PrimOp
DoubleSinhOp :: PrimOp
DoubleCoshOp :: PrimOp
DoubleTanhOp :: PrimOp
DoubleAsinhOp :: PrimOp
DoubleAcoshOp :: PrimOp
DoubleAtanhOp :: PrimOp
DoublePowerOp :: PrimOp
DoubleDecode_2IntOp :: PrimOp
DoubleDecode_Int64Op :: PrimOp
FloatGtOp :: PrimOp
FloatGeOp :: PrimOp
FloatEqOp :: PrimOp
FloatNeOp :: PrimOp
FloatLtOp :: PrimOp
FloatLeOp :: PrimOp
FloatAddOp :: PrimOp
FloatSubOp :: PrimOp
FloatMulOp :: PrimOp
FloatDivOp :: PrimOp
FloatNegOp :: PrimOp
FloatFabsOp :: PrimOp
FloatToIntOp :: PrimOp
FloatExpOp :: PrimOp
FloatExpM1Op :: PrimOp
FloatLogOp :: PrimOp
FloatLog1POp :: PrimOp
FloatSqrtOp :: PrimOp
FloatSinOp :: PrimOp
FloatCosOp :: PrimOp
FloatTanOp :: PrimOp
FloatAsinOp :: PrimOp
FloatAcosOp :: PrimOp
FloatAtanOp :: PrimOp
FloatSinhOp :: PrimOp
FloatCoshOp :: PrimOp
FloatTanhOp :: PrimOp
FloatAsinhOp :: PrimOp
FloatAcoshOp :: PrimOp
FloatAtanhOp :: PrimOp
FloatPowerOp :: PrimOp
FloatToDoubleOp :: PrimOp
FloatDecode_IntOp :: PrimOp
NewArrayOp :: PrimOp
ReadArrayOp :: PrimOp
WriteArrayOp :: PrimOp
SizeofArrayOp :: PrimOp
SizeofMutableArrayOp :: PrimOp
IndexArrayOp :: PrimOp
UnsafeFreezeArrayOp :: PrimOp
UnsafeThawArrayOp :: PrimOp
CopyArrayOp :: PrimOp
CopyMutableArrayOp :: PrimOp
CloneArrayOp :: PrimOp
CloneMutableArrayOp :: PrimOp
FreezeArrayOp :: PrimOp
ThawArrayOp :: PrimOp
CasArrayOp :: PrimOp
NewSmallArrayOp :: PrimOp
ShrinkSmallMutableArrayOp_Char :: PrimOp
ReadSmallArrayOp :: PrimOp
WriteSmallArrayOp :: PrimOp
SizeofSmallArrayOp :: PrimOp
SizeofSmallMutableArrayOp :: PrimOp
GetSizeofSmallMutableArrayOp :: PrimOp
IndexSmallArrayOp :: PrimOp
UnsafeFreezeSmallArrayOp :: PrimOp
UnsafeThawSmallArrayOp :: PrimOp
CopySmallArrayOp :: PrimOp
CopySmallMutableArrayOp :: PrimOp
CloneSmallArrayOp :: PrimOp
CloneSmallMutableArrayOp :: PrimOp
FreezeSmallArrayOp :: PrimOp
ThawSmallArrayOp :: PrimOp
CasSmallArrayOp :: PrimOp
NewByteArrayOp_Char :: PrimOp
NewPinnedByteArrayOp_Char :: PrimOp
NewAlignedPinnedByteArrayOp_Char :: PrimOp
MutableByteArrayIsPinnedOp :: PrimOp
ByteArrayIsPinnedOp :: PrimOp
ByteArrayContents_Char :: PrimOp
MutableByteArrayContents_Char :: PrimOp
ShrinkMutableByteArrayOp_Char :: PrimOp
ResizeMutableByteArrayOp_Char :: PrimOp
UnsafeFreezeByteArrayOp :: PrimOp
SizeofByteArrayOp :: PrimOp
SizeofMutableByteArrayOp :: PrimOp
GetSizeofMutableByteArrayOp :: PrimOp
IndexByteArrayOp_Char :: PrimOp
IndexByteArrayOp_WideChar :: PrimOp
IndexByteArrayOp_Int :: PrimOp
IndexByteArrayOp_Word :: PrimOp
IndexByteArrayOp_Addr :: PrimOp
IndexByteArrayOp_Float :: PrimOp
IndexByteArrayOp_Double :: PrimOp
IndexByteArrayOp_StablePtr :: PrimOp
IndexByteArrayOp_Int8 :: PrimOp
IndexByteArrayOp_Int16 :: PrimOp
IndexByteArrayOp_Int32 :: PrimOp
IndexByteArrayOp_Int64 :: PrimOp
IndexByteArrayOp_Word8 :: PrimOp
IndexByteArrayOp_Word16 :: PrimOp
IndexByteArrayOp_Word32 :: PrimOp
IndexByteArrayOp_Word64 :: PrimOp
IndexByteArrayOp_Word8AsChar :: PrimOp
IndexByteArrayOp_Word8AsWideChar :: PrimOp
IndexByteArrayOp_Word8AsInt :: PrimOp
IndexByteArrayOp_Word8AsWord :: PrimOp
IndexByteArrayOp_Word8AsAddr :: PrimOp
IndexByteArrayOp_Word8AsFloat :: PrimOp
IndexByteArrayOp_Word8AsDouble :: PrimOp
IndexByteArrayOp_Word8AsStablePtr :: PrimOp
IndexByteArrayOp_Word8AsInt16 :: PrimOp
IndexByteArrayOp_Word8AsInt32 :: PrimOp
IndexByteArrayOp_Word8AsInt64 :: PrimOp
IndexByteArrayOp_Word8AsWord16 :: PrimOp
IndexByteArrayOp_Word8AsWord32 :: PrimOp
IndexByteArrayOp_Word8AsWord64 :: PrimOp
ReadByteArrayOp_Char :: PrimOp
ReadByteArrayOp_WideChar :: PrimOp
ReadByteArrayOp_Int :: PrimOp
ReadByteArrayOp_Word :: PrimOp
ReadByteArrayOp_Addr :: PrimOp
ReadByteArrayOp_Float :: PrimOp
ReadByteArrayOp_Double :: PrimOp
ReadByteArrayOp_StablePtr :: PrimOp
ReadByteArrayOp_Int8 :: PrimOp
ReadByteArrayOp_Int16 :: PrimOp
ReadByteArrayOp_Int32 :: PrimOp
ReadByteArrayOp_Int64 :: PrimOp
ReadByteArrayOp_Word8 :: PrimOp
ReadByteArrayOp_Word16 :: PrimOp
ReadByteArrayOp_Word32 :: PrimOp
ReadByteArrayOp_Word64 :: PrimOp
ReadByteArrayOp_Word8AsChar :: PrimOp
ReadByteArrayOp_Word8AsWideChar :: PrimOp
ReadByteArrayOp_Word8AsInt :: PrimOp
ReadByteArrayOp_Word8AsWord :: PrimOp
ReadByteArrayOp_Word8AsAddr :: PrimOp
ReadByteArrayOp_Word8AsFloat :: PrimOp
ReadByteArrayOp_Word8AsDouble :: PrimOp
ReadByteArrayOp_Word8AsStablePtr :: PrimOp
ReadByteArrayOp_Word8AsInt16 :: PrimOp
ReadByteArrayOp_Word8AsInt32 :: PrimOp
ReadByteArrayOp_Word8AsInt64 :: PrimOp
ReadByteArrayOp_Word8AsWord16 :: PrimOp
ReadByteArrayOp_Word8AsWord32 :: PrimOp
ReadByteArrayOp_Word8AsWord64 :: PrimOp
WriteByteArrayOp_Char :: PrimOp
WriteByteArrayOp_WideChar :: PrimOp
WriteByteArrayOp_Int :: PrimOp
WriteByteArrayOp_Word :: PrimOp
WriteByteArrayOp_Addr :: PrimOp
WriteByteArrayOp_Float :: PrimOp
WriteByteArrayOp_Double :: PrimOp
WriteByteArrayOp_StablePtr :: PrimOp
WriteByteArrayOp_Int8 :: PrimOp
WriteByteArrayOp_Int16 :: PrimOp
WriteByteArrayOp_Int32 :: PrimOp
WriteByteArrayOp_Int64 :: PrimOp
WriteByteArrayOp_Word8 :: PrimOp
WriteByteArrayOp_Word16 :: PrimOp
WriteByteArrayOp_Word32 :: PrimOp
WriteByteArrayOp_Word64 :: PrimOp
WriteByteArrayOp_Word8AsChar :: PrimOp
WriteByteArrayOp_Word8AsWideChar :: PrimOp
WriteByteArrayOp_Word8AsInt :: PrimOp
WriteByteArrayOp_Word8AsWord :: PrimOp
WriteByteArrayOp_Word8AsAddr :: PrimOp
WriteByteArrayOp_Word8AsFloat :: PrimOp
WriteByteArrayOp_Word8AsDouble :: PrimOp
WriteByteArrayOp_Word8AsStablePtr :: PrimOp
WriteByteArrayOp_Word8AsInt16 :: PrimOp
WriteByteArrayOp_Word8AsInt32 :: PrimOp
WriteByteArrayOp_Word8AsInt64 :: PrimOp
WriteByteArrayOp_Word8AsWord16 :: PrimOp
WriteByteArrayOp_Word8AsWord32 :: PrimOp
WriteByteArrayOp_Word8AsWord64 :: PrimOp
CompareByteArraysOp :: PrimOp
CopyByteArrayOp :: PrimOp
CopyMutableByteArrayOp :: PrimOp
CopyByteArrayToAddrOp :: PrimOp
CopyMutableByteArrayToAddrOp :: PrimOp
CopyAddrToByteArrayOp :: PrimOp
SetByteArrayOp :: PrimOp
AtomicReadByteArrayOp_Int :: PrimOp
AtomicWriteByteArrayOp_Int :: PrimOp
CasByteArrayOp_Int :: PrimOp
CasByteArrayOp_Int8 :: PrimOp
CasByteArrayOp_Int16 :: PrimOp
CasByteArrayOp_Int32 :: PrimOp
CasByteArrayOp_Int64 :: PrimOp
FetchAddByteArrayOp_Int :: PrimOp
FetchSubByteArrayOp_Int :: PrimOp
FetchAndByteArrayOp_Int :: PrimOp
FetchNandByteArrayOp_Int :: PrimOp
FetchOrByteArrayOp_Int :: PrimOp
FetchXorByteArrayOp_Int :: PrimOp
AddrAddOp :: PrimOp
AddrSubOp :: PrimOp
AddrRemOp :: PrimOp
AddrToIntOp :: PrimOp
IntToAddrOp :: PrimOp
AddrGtOp :: PrimOp
AddrGeOp :: PrimOp
AddrEqOp :: PrimOp
AddrNeOp :: PrimOp
AddrLtOp :: PrimOp
AddrLeOp :: PrimOp
IndexOffAddrOp_Char :: PrimOp
IndexOffAddrOp_WideChar :: PrimOp
IndexOffAddrOp_Int :: PrimOp
IndexOffAddrOp_Word :: PrimOp
IndexOffAddrOp_Addr :: PrimOp
IndexOffAddrOp_Float :: PrimOp
IndexOffAddrOp_Double :: PrimOp
IndexOffAddrOp_StablePtr :: PrimOp
IndexOffAddrOp_Int8 :: PrimOp
IndexOffAddrOp_Int16 :: PrimOp
IndexOffAddrOp_Int32 :: PrimOp
IndexOffAddrOp_Int64 :: PrimOp
IndexOffAddrOp_Word8 :: PrimOp
IndexOffAddrOp_Word16 :: PrimOp
IndexOffAddrOp_Word32 :: PrimOp
IndexOffAddrOp_Word64 :: PrimOp
ReadOffAddrOp_Char :: PrimOp
ReadOffAddrOp_WideChar :: PrimOp
ReadOffAddrOp_Int :: PrimOp
ReadOffAddrOp_Word :: PrimOp
ReadOffAddrOp_Addr :: PrimOp
ReadOffAddrOp_Float :: PrimOp
ReadOffAddrOp_Double :: PrimOp
ReadOffAddrOp_StablePtr :: PrimOp
ReadOffAddrOp_Int8 :: PrimOp
ReadOffAddrOp_Int16 :: PrimOp
ReadOffAddrOp_Int32 :: PrimOp
ReadOffAddrOp_Int64 :: PrimOp
ReadOffAddrOp_Word8 :: PrimOp
ReadOffAddrOp_Word16 :: PrimOp
ReadOffAddrOp_Word32 :: PrimOp
ReadOffAddrOp_Word64 :: PrimOp
WriteOffAddrOp_Char :: PrimOp
WriteOffAddrOp_WideChar :: PrimOp
WriteOffAddrOp_Int :: PrimOp
WriteOffAddrOp_Word :: PrimOp
WriteOffAddrOp_Addr :: PrimOp
WriteOffAddrOp_Float :: PrimOp
WriteOffAddrOp_Double :: PrimOp
WriteOffAddrOp_StablePtr :: PrimOp
WriteOffAddrOp_Int8 :: PrimOp
WriteOffAddrOp_Int16 :: PrimOp
WriteOffAddrOp_Int32 :: PrimOp
WriteOffAddrOp_Int64 :: PrimOp
WriteOffAddrOp_Word8 :: PrimOp
WriteOffAddrOp_Word16 :: PrimOp
WriteOffAddrOp_Word32 :: PrimOp
WriteOffAddrOp_Word64 :: PrimOp
InterlockedExchange_Addr :: PrimOp
InterlockedExchange_Word :: PrimOp
CasAddrOp_Addr :: PrimOp
CasAddrOp_Word :: PrimOp
CasAddrOp_Word8 :: PrimOp
CasAddrOp_Word16 :: PrimOp
CasAddrOp_Word32 :: PrimOp
CasAddrOp_Word64 :: PrimOp
FetchAddAddrOp_Word :: PrimOp
FetchSubAddrOp_Word :: PrimOp
FetchAndAddrOp_Word :: PrimOp
FetchNandAddrOp_Word :: PrimOp
FetchOrAddrOp_Word :: PrimOp
FetchXorAddrOp_Word :: PrimOp
AtomicReadAddrOp_Word :: PrimOp
AtomicWriteAddrOp_Word :: PrimOp
NewMutVarOp :: PrimOp
ReadMutVarOp :: PrimOp
WriteMutVarOp :: PrimOp
AtomicModifyMutVar2Op :: PrimOp
AtomicModifyMutVar_Op :: PrimOp
CasMutVarOp :: PrimOp
CatchOp :: PrimOp
RaiseOp :: PrimOp
RaiseUnderflowOp :: PrimOp
RaiseOverflowOp :: PrimOp
RaiseDivZeroOp :: PrimOp
RaiseIOOp :: PrimOp
MaskAsyncExceptionsOp :: PrimOp
MaskUninterruptibleOp :: PrimOp
UnmaskAsyncExceptionsOp :: PrimOp
MaskStatus :: PrimOp
NewPromptTagOp :: PrimOp
PromptOp :: PrimOp
Control0Op :: PrimOp
AtomicallyOp :: PrimOp
RetryOp :: PrimOp
CatchRetryOp :: PrimOp
CatchSTMOp :: PrimOp
NewTVarOp :: PrimOp
ReadTVarOp :: PrimOp
ReadTVarIOOp :: PrimOp
WriteTVarOp :: PrimOp
NewMVarOp :: PrimOp
TakeMVarOp :: PrimOp
TryTakeMVarOp :: PrimOp
PutMVarOp :: PrimOp
TryPutMVarOp :: PrimOp
ReadMVarOp :: PrimOp
TryReadMVarOp :: PrimOp
IsEmptyMVarOp :: PrimOp
NewIOPortOp :: PrimOp
ReadIOPortOp :: PrimOp
WriteIOPortOp :: PrimOp
DelayOp :: PrimOp
WaitReadOp :: PrimOp
WaitWriteOp :: PrimOp
ForkOp :: PrimOp
ForkOnOp :: PrimOp
KillThreadOp :: PrimOp
YieldOp :: PrimOp
MyThreadIdOp :: PrimOp
LabelThreadOp :: PrimOp
IsCurrentThreadBoundOp :: PrimOp
NoDuplicateOp :: PrimOp
GetThreadLabelOp :: PrimOp
ThreadStatusOp :: PrimOp
ListThreadsOp :: PrimOp
MkWeakOp :: PrimOp
MkWeakNoFinalizerOp :: PrimOp
AddCFinalizerToWeakOp :: PrimOp
DeRefWeakOp :: PrimOp
FinalizeWeakOp :: PrimOp
TouchOp :: PrimOp
MakeStablePtrOp :: PrimOp
DeRefStablePtrOp :: PrimOp
EqStablePtrOp :: PrimOp
MakeStableNameOp :: PrimOp
StableNameToIntOp :: PrimOp
CompactNewOp :: PrimOp
CompactResizeOp :: PrimOp
CompactContainsOp :: PrimOp
CompactContainsAnyOp :: PrimOp
CompactGetFirstBlockOp :: PrimOp
CompactGetNextBlockOp :: PrimOp
CompactAllocateBlockOp :: PrimOp
CompactFixupPointersOp :: PrimOp
CompactAdd :: PrimOp
CompactAddWithSharing :: PrimOp
CompactSize :: PrimOp
ReallyUnsafePtrEqualityOp :: PrimOp
ParOp :: PrimOp
SparkOp :: PrimOp
SeqOp :: PrimOp
GetSparkOp :: PrimOp
NumSparks :: PrimOp
KeepAliveOp :: PrimOp
DataToTagOp :: PrimOp
TagToEnumOp :: PrimOp
AddrToAnyOp :: PrimOp
AnyToAddrOp :: PrimOp
MkApUpd0_Op :: PrimOp
NewBCOOp :: PrimOp
UnpackClosureOp :: PrimOp
ClosureSizeOp :: PrimOp
GetApStackValOp :: PrimOp
GetCCSOfOp :: PrimOp
GetCurrentCCSOp :: PrimOp
ClearCCSOp :: PrimOp
WhereFromOp :: PrimOp
TraceEventOp :: PrimOp
TraceEventBinaryOp :: PrimOp
TraceMarkerOp :: PrimOp
SetThreadAllocationCounter :: PrimOp
VecBroadcastOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecPackOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecUnpackOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecInsertOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecAddOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecSubOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecMulOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecDivOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecQuotOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecRemOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecNegOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
PrefetchByteArrayOp3 :: PrimOp
PrefetchMutableByteArrayOp3 :: PrimOp
PrefetchAddrOp3 :: PrimOp
PrefetchValueOp3 :: PrimOp
PrefetchByteArrayOp2 :: PrimOp
PrefetchMutableByteArrayOp2 :: PrimOp
PrefetchAddrOp2 :: PrimOp
PrefetchValueOp2 :: PrimOp
PrefetchByteArrayOp1 :: PrimOp
PrefetchMutableByteArrayOp1 :: PrimOp
PrefetchAddrOp1 :: PrimOp
PrefetchValueOp1 :: PrimOp
PrefetchByteArrayOp0 :: PrimOp
PrefetchMutableByteArrayOp0 :: PrimOp
PrefetchAddrOp0 :: PrimOp
PrefetchValueOp0 :: PrimOp
data PrimOpVecCat
IntVec :: PrimOpVecCat
WordVec :: PrimOpVecCat
FloatVec :: PrimOpVecCat
allThePrimOps :: [PrimOp]
primOpType :: PrimOp -> Type
primOpSig :: PrimOp -> ([TyVarBinder], [Type], Type, Arity, DmdSig)
primOpResultType :: PrimOp -> Type
primOpTag :: PrimOp -> Int
maxPrimOpTag :: Int
primOpOcc :: PrimOp -> OccName

-- | Returns the <a>Id</a> of the wrapper associated with the given
--   <a>PrimOp</a>. See Note [Primop wrappers].
primOpWrapperId :: PrimOp -> Id
pprPrimOp :: IsLine doc => PrimOp -> doc
tagToEnumKey :: Unique
primOpOutOfLine :: PrimOp -> Bool
primOpCodeSize :: PrimOp -> Int
primOpOkForSpeculation :: PrimOp -> Bool
primOpOkForSideEffects :: PrimOp -> Bool
primOpIsCheap :: PrimOp -> Bool
primOpFixity :: PrimOp -> Maybe Fixity
primOpDocs :: [(String, String)]

-- | True of dyadic operators that can fail only if the second arg is zero!
--   
--   This function probably belongs in an automagically generated file..
--   but it's such a special case I thought I'd leave it here for now.
primOpIsDiv :: PrimOp -> Bool

-- | Indicate if a primop is really inline: that is, it isn't out-of-line
--   and it isn't SeqOp/DataToTagOp which are two primops that evaluate
--   their argument hence induce thread<i>stack</i>heap changes.
primOpIsReallyInline :: PrimOp -> Bool
getPrimOpResultInfo :: PrimOp -> PrimOpResultInfo
isComparisonPrimOp :: PrimOp -> Bool
data PrimOpResultInfo
ReturnsPrim :: PrimRep -> PrimOpResultInfo
ReturnsAlg :: TyCon -> PrimOpResultInfo
data PrimCall
PrimCall :: CLabelString -> Unit -> PrimCall
instance GHC.Utils.Outputable.Outputable GHC.Builtin.PrimOps.PrimCall
instance GHC.Classes.Eq GHC.Builtin.PrimOps.PrimOp
instance GHC.Classes.Ord GHC.Builtin.PrimOps.PrimOp
instance GHC.Utils.Outputable.Outputable GHC.Builtin.PrimOps.PrimOp

module GHC.Stg.Syntax
data StgArg
StgVarArg :: Id -> StgArg
StgLitArg :: Literal -> StgArg

-- | A top-level binding.
data GenStgTopBinding pass
StgTopLifted :: GenStgBinding pass -> GenStgTopBinding pass
StgTopStringLit :: Id -> ByteString -> GenStgTopBinding pass
data GenStgBinding pass
StgNonRec :: BinderP pass -> GenStgRhs pass -> GenStgBinding pass
StgRec :: [(BinderP pass, GenStgRhs pass)] -> GenStgBinding pass
data GenStgExpr pass
StgApp :: Id -> [StgArg] -> GenStgExpr pass
StgLit :: Literal -> GenStgExpr pass
StgConApp :: DataCon -> ConstructorNumber -> [StgArg] -> [Type] -> GenStgExpr pass
StgOpApp :: StgOp -> [StgArg] -> Type -> GenStgExpr pass
StgCase :: GenStgExpr pass -> BinderP pass -> AltType -> [GenStgAlt pass] -> GenStgExpr pass
StgLet :: XLet pass -> GenStgBinding pass -> GenStgExpr pass -> GenStgExpr pass
StgLetNoEscape :: XLetNoEscape pass -> GenStgBinding pass -> GenStgExpr pass -> GenStgExpr pass
StgTick :: StgTickish -> GenStgExpr pass -> GenStgExpr pass
data GenStgRhs pass
StgRhsClosure :: XRhsClosure pass -> CostCentreStack -> !UpdateFlag -> [BinderP pass] -> GenStgExpr pass -> GenStgRhs pass
StgRhsCon :: CostCentreStack -> DataCon -> ConstructorNumber -> [StgTickish] -> [StgArg] -> GenStgRhs pass
data GenStgAlt pass
GenStgAlt :: !AltCon -> ![BinderP pass] -> !GenStgExpr pass -> GenStgAlt pass
[alt_con] :: GenStgAlt pass -> !AltCon
[alt_bndrs] :: GenStgAlt pass -> ![BinderP pass]
[alt_rhs] :: GenStgAlt pass -> !GenStgExpr pass
data AltType
PolyAlt :: AltType
MultiValAlt :: Int -> AltType
AlgAlt :: TyCon -> AltType
PrimAlt :: PrimRep -> AltType

-- | Used as a data type index for the stgSyn AST
data StgPass
Vanilla :: StgPass

-- | Use internally by the lambda lifting pass
LiftLams :: StgPass

-- | Tag inference information on binders. See Note [Tag inference passes]
--   in GHC.Stg.InferTags
InferTaggedBinders :: StgPass

-- | Tag inference information put on relevant StgApp nodes See Note [Tag
--   inference passes] in GHC.Stg.InferTags
InferTagged :: StgPass
CodeGen :: StgPass
type family BinderP (pass :: StgPass)
type family XRhsClosure (pass :: StgPass)
type family XLet (pass :: StgPass)
type family XLetNoEscape (pass :: StgPass)

-- | Like <a>NoExtField</a>, but with an <a>Outputable</a> instance that
--   returns <a>empty</a>.
data NoExtFieldSilent

-- | Used when constructing a term with an unused extension point that
--   should not appear in pretty-printed output at all.
noExtFieldSilent :: NoExtFieldSilent
type OutputablePass pass = (Outputable (XLet pass), Outputable (XLetNoEscape pass), Outputable (XRhsClosure pass), OutputableBndr (BinderP pass))
data UpdateFlag
ReEntrant :: UpdateFlag
Updatable :: UpdateFlag
SingleEntry :: UpdateFlag
isUpdatable :: UpdateFlag -> Bool

-- | When `-fdistinct-constructor-tables` is turned on then each usage of a
--   constructor is given an unique number and an info table is generated
--   for each different constructor.
data ConstructorNumber
NoNumber :: ConstructorNumber
Numbered :: Int -> ConstructorNumber
type StgTopBinding = GenStgTopBinding 'Vanilla
type StgBinding = GenStgBinding 'Vanilla
type StgExpr = GenStgExpr 'Vanilla
type StgRhs = GenStgRhs 'Vanilla
type StgAlt = GenStgAlt 'Vanilla
type CgStgTopBinding = GenStgTopBinding 'CodeGen
type CgStgBinding = GenStgBinding 'CodeGen
type CgStgExpr = GenStgExpr 'CodeGen
type CgStgRhs = GenStgRhs 'CodeGen
type CgStgAlt = GenStgAlt 'CodeGen
type TgStgTopBinding = GenStgTopBinding 'CodeGen
type TgStgBinding = GenStgBinding 'CodeGen
type TgStgExpr = GenStgExpr 'CodeGen
type TgStgRhs = GenStgRhs 'CodeGen
type TgStgAlt = GenStgAlt 'CodeGen
type LlStgTopBinding = GenStgTopBinding 'LiftLams
type LlStgBinding = GenStgBinding 'LiftLams
type LlStgExpr = GenStgExpr 'LiftLams
type LlStgRhs = GenStgRhs 'LiftLams
type LlStgAlt = GenStgAlt 'LiftLams
type InStgArg = StgArg
type InStgTopBinding = StgTopBinding
type InStgBinding = StgBinding
type InStgExpr = StgExpr
type InStgRhs = StgRhs
type InStgAlt = StgAlt
type OutStgArg = StgArg
type OutStgTopBinding = StgTopBinding
type OutStgBinding = StgBinding
type OutStgExpr = StgExpr
type OutStgRhs = StgRhs
type OutStgAlt = StgAlt
data StgOp
StgPrimOp :: PrimOp -> StgOp
StgPrimCallOp :: PrimCall -> StgOp
StgFCallOp :: ForeignCall -> Type -> StgOp
stgRhsArity :: StgRhs -> Int
freeVarsOfRhs :: XRhsClosure pass ~ DIdSet => GenStgRhs pass -> DIdSet

-- | Does this constructor application refer to anything in a different
--   *Windows* DLL? If so, we can't allocate it statically
isDllConApp :: Platform -> Bool -> Module -> DataCon -> [StgArg] -> Bool

-- | Type of an <tt>StgArg</tt>
--   
--   Very half baked because we have lost the type arguments.
stgArgType :: StgArg -> Type

-- | Given an alt type and whether the program is unarised, return whether
--   the case binder is in scope.
--   
--   Case binders of unboxed tuple or unboxed sum type always dead after
--   the unariser has run. See Note [Post-unarisation invariants].
stgCaseBndrInScope :: AltType -> Bool -> Bool

-- | STG pretty-printing options
data StgPprOpts
StgPprOpts :: !Bool -> StgPprOpts

-- | Enable cost-centres
[stgSccEnabled] :: StgPprOpts -> !Bool

-- | STG pretty-printing options used for panic messages
panicStgPprOpts :: StgPprOpts

-- | STG pretty-printing options used for short messages
shortStgPprOpts :: StgPprOpts
pprStgArg :: StgArg -> SDoc
pprStgExpr :: OutputablePass pass => StgPprOpts -> GenStgExpr pass -> SDoc
pprStgRhs :: OutputablePass pass => StgPprOpts -> GenStgRhs pass -> SDoc
pprStgBinding :: OutputablePass pass => StgPprOpts -> GenStgBinding pass -> SDoc
pprStgAlt :: OutputablePass pass => StgPprOpts -> Bool -> GenStgAlt pass -> SDoc
pprGenStgTopBinding :: OutputablePass pass => StgPprOpts -> GenStgTopBinding pass -> SDoc
pprStgTopBinding :: OutputablePass pass => StgPprOpts -> GenStgTopBinding pass -> SDoc
pprGenStgTopBindings :: OutputablePass pass => StgPprOpts -> [GenStgTopBinding pass] -> SDoc
pprStgTopBindings :: OutputablePass pass => StgPprOpts -> [GenStgTopBinding pass] -> SDoc
instance GHC.Classes.Ord GHC.Stg.Syntax.NoExtFieldSilent
instance GHC.Classes.Eq GHC.Stg.Syntax.NoExtFieldSilent
instance Data.Data.Data GHC.Stg.Syntax.NoExtFieldSilent
instance GHC.Stg.Syntax.OutputablePass pass => GHC.Utils.Outputable.Outputable (GHC.Stg.Syntax.GenStgBinding pass)
instance GHC.Stg.Syntax.OutputablePass pass => GHC.Utils.Outputable.Outputable (GHC.Stg.Syntax.GenStgExpr pass)
instance GHC.Stg.Syntax.OutputablePass pass => GHC.Utils.Outputable.Outputable (GHC.Stg.Syntax.GenStgRhs pass)
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.StgOp
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.UpdateFlag
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.ConstructorNumber
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.AltType
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.NoExtFieldSilent
instance GHC.Utils.Outputable.Outputable GHC.Stg.Syntax.StgArg


-- | Module that holds the Types required for the StgToJS pass
module GHC.StgToJS.Types

-- | A State monad over IO holding the generator state.
type G = StateT GenState IO

-- | The JS code generator state
data GenState
GenState :: !StgToJSConfig -> !Module -> {-# UNPACK #-} !FastMutInt -> !IdCache -> !UniqFM Id CgStgExpr -> GenGroupState -> [JStat] -> GenState

-- | codegen settings, read-only
[gsSettings] :: GenState -> !StgToJSConfig

-- | current module
[gsModule] :: GenState -> !Module

-- | unique number for the id generator
[gsId] :: GenState -> {-# UNPACK #-} !FastMutInt

-- | hash consing for identifiers from a Unique
[gsIdents] :: GenState -> !IdCache

-- | unfloated arguments
[gsUnfloated] :: GenState -> !UniqFM Id CgStgExpr

-- | state for the current binding group
[gsGroup] :: GenState -> GenGroupState

-- | global (per module) statements (gets included when anything else from
--   the module is used)
[gsGlobal] :: GenState -> [JStat]

-- | The JS code generator state relevant for the current binding group
data GenGroupState
GenGroupState :: [JStat] -> [ClosureInfo] -> [StaticInfo] -> [StackSlot] -> Int -> Set OtherSymb -> GlobalIdCache -> [ForeignJSRef] -> GenGroupState

-- | extra toplevel statements for the binding group
[ggsToplevelStats] :: GenGroupState -> [JStat]

-- | closure metadata (info tables) for the binding group
[ggsClosureInfo] :: GenGroupState -> [ClosureInfo]

-- | static (CAF) data in our binding group
[ggsStatic] :: GenGroupState -> [StaticInfo]

-- | stack info for the current expression
[ggsStack] :: GenGroupState -> [StackSlot]

-- | current stack depth
[ggsStackDepth] :: GenGroupState -> Int

-- | extra dependencies for the linkable unit that contains this group
[ggsExtraDeps] :: GenGroupState -> Set OtherSymb
[ggsGlobalIdCache] :: GenGroupState -> GlobalIdCache
[ggsForeignRefs] :: GenGroupState -> [ForeignJSRef]

-- | The Configuration record for the StgToJS pass
data StgToJSConfig
StgToJSConfig :: !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !SDocContext -> StgToJSConfig
[csInlinePush] :: StgToJSConfig -> !Bool
[csInlineBlackhole] :: StgToJSConfig -> !Bool
[csInlineLoadRegs] :: StgToJSConfig -> !Bool
[csInlineEnter] :: StgToJSConfig -> !Bool
[csInlineAlloc] :: StgToJSConfig -> !Bool
[csTraceRts] :: StgToJSConfig -> !Bool
[csAssertRts] :: StgToJSConfig -> !Bool
[csBoundsCheck] :: StgToJSConfig -> !Bool
[csDebugAlloc] :: StgToJSConfig -> !Bool
[csTraceForeign] :: StgToJSConfig -> !Bool

-- | Profiling enabled
[csProf] :: StgToJSConfig -> !Bool

-- | Enable runtime assertions settings
[csRuntimeAssert] :: StgToJSConfig -> !Bool
[csContext] :: StgToJSConfig -> !SDocContext

-- | Information relevenat to code generation for closures.
data ClosureInfo
ClosureInfo :: Ident -> CIRegs -> FastString -> CILayout -> CIType -> CIStatic -> ClosureInfo

-- | object being infod
[ciVar] :: ClosureInfo -> Ident

-- | size of the payload (in number of JS values)
[ciRegs] :: ClosureInfo -> CIRegs

-- | friendly name for printing
[ciName] :: ClosureInfo -> FastString

-- | heap/stack layout of the object
[ciLayout] :: ClosureInfo -> CILayout

-- | type of the object, with extra info where required
[ciType] :: ClosureInfo -> CIType

-- | static references of this object
[ciStatic] :: ClosureInfo -> CIStatic

-- | Closure information, <a>ClosureInfo</a>, registers
data CIRegs

-- | A value witnessing a state of unknown registers
CIRegsUnknown :: CIRegs
CIRegs :: Int -> [VarType] -> CIRegs

-- | unused registers before actual args start
[ciRegsSkip] :: CIRegs -> Int

-- | args
[ciRegsTypes] :: CIRegs -> [VarType]

-- | Closure Information, <a>ClosureInfo</a>, layout
data CILayout

-- | layout stored in object itself, first position from the start
CILayoutVariable :: CILayout

-- | fixed size, but content unknown (for example stack apply frame)
CILayoutUnknown :: !Int -> CILayout

-- | closure size in array positions, including entry
[layoutSize] :: CILayout -> !Int

-- | whole layout known
CILayoutFixed :: !Int -> [VarType] -> CILayout

-- | closure size in array positions, including entry
[layoutSize] :: CILayout -> !Int

-- | The set of sized Types to layout
[layout] :: CILayout -> [VarType]

-- | The type of <a>ClosureInfo</a>
data CIType
CIFun :: !Int -> !Int -> CIType

-- | function arity
[citArity] :: CIType -> !Int

-- | number of registers for the args
[citRegs] :: CIType -> !Int

-- | The closure is a THUNK
CIThunk :: CIType

-- | The closure is a Constructor
CICon :: !Int -> CIType
[citConstructor] :: CIType -> !Int

-- | The closure is a Partial Application
CIPap :: CIType

-- | The closure is a black hole
CIBlackhole :: CIType

-- | The closure is a stack frame
CIStackFrame :: CIType

-- | Static references that must be kept alive
newtype CIStatic
CIStaticRefs :: [FastString] -> CIStatic
[staticRefs] :: CIStatic -> [FastString]

-- | Free variable types
data VarType

-- | pointer = reference to heap object (closure object)
PtrV :: VarType

-- | no fields
VoidV :: VarType

-- | A Double: one field
DoubleV :: VarType

-- | An Int (32bit because JS): one field
IntV :: VarType

-- | A Long: two fields one for the upper 32bits, one for the lower (NB: JS
--   is little endian)
LongV :: VarType

-- | a pointer not to the heap: two fields, array + index
AddrV :: VarType

-- | some RTS object from GHCJS (for example TVar#, MVar#, MutVar#, Weak#)
RtsObjV :: VarType

-- | some JS object, user supplied, be careful around these, can be
--   anything
ObjV :: VarType

-- | boxed array
ArrV :: VarType

-- | The type of identifiers. These determine the suffix of generated
--   functions in JS Land. For example, the entry function for the
--   <a>Just</a> constructor is a <a>IdConEntry</a> which compiles to: <tt>
--   function h$baseZCGHCziMaybeziJust_con_e() { return h$rs() }; </tt>
--   which just returns whatever the stack point is pointing to. Whereas
--   the entry function to <a>Just</a> is an <a>IdEntry</a> and does the
--   work. It compiles to: <tt> function h$baseZCGHCziMaybeziJust_e() { var
--   h$$baseZCGHCziMaybezieta_8KXnScrCjF5 = h$r2; h$r1 =
--   h$c1(h$baseZCGHCziMaybeziJust_con_e,
--   h$$baseZCGHCziMaybezieta_8KXnScrCjF5); return h$rs(); }; </tt> Which
--   loads some payload from register 2, and applies the Constructor Entry
--   function for the Just to the payload, returns the result in register 1
--   and returns whatever is on top of the stack
data IdType

-- | A plain identifier for values, no suffix added
IdPlain :: IdType

-- | An entry function, suffix = "_e" in <a>makeIdentForId</a>
IdEntry :: IdType

-- | A Constructor entry function, suffix = "_con_e" in
--   <a>makeIdentForId</a>
IdConEntry :: IdType

-- | Keys to differentiate Ident's in the ID Cache
data IdKey
IdKey :: !Word64 -> !Int -> !IdType -> IdKey

-- | Some other symbol
data OtherSymb
OtherSymb :: !Module -> !FastString -> OtherSymb

-- | The identifier cache indexed on <a>IdKey</a> local to a module
newtype IdCache
IdCache :: Map IdKey Ident -> IdCache

-- | The global Identifier Cache
newtype GlobalIdCache
GlobalIdCache :: UniqFM Ident (IdKey, Id) -> GlobalIdCache

-- | A Stack Slot is either known or unknown. We avoid maybe here for more
--   strictness.
data StackSlot
SlotId :: !Id -> !Int -> StackSlot
SlotUnknown :: StackSlot
data StaticInfo
StaticInfo :: !FastString -> !StaticVal -> !Maybe Ident -> StaticInfo

-- | global object
[siVar] :: StaticInfo -> !FastString

-- | static initialization
[siVal] :: StaticInfo -> !StaticVal

-- | optional CCS name
[siCC] :: StaticInfo -> !Maybe Ident
data StaticVal

-- | heap object for function
StaticFun :: !FastString -> [StaticArg] -> StaticVal

-- | heap object for CAF (field is Nothing when thunk is initialized in an
--   alternative way, like string thunks through h$str)
StaticThunk :: !Maybe (FastString, [StaticArg]) -> StaticVal

-- | unboxed constructor (Bool, Int, Double etc)
StaticUnboxed :: !StaticUnboxed -> StaticVal

-- | regular datacon app
StaticData :: !FastString -> [StaticArg] -> StaticVal

-- | list initializer (with optional tail)
StaticList :: [StaticArg] -> Maybe FastString -> StaticVal
data StaticUnboxed
StaticUnboxedBool :: !Bool -> StaticUnboxed
StaticUnboxedInt :: !Integer -> StaticUnboxed
StaticUnboxedDouble :: !SaneDouble -> StaticUnboxed
StaticUnboxedString :: !ByteString -> StaticUnboxed
StaticUnboxedStringOffset :: !ByteString -> StaticUnboxed

-- | Static Arguments. Static Arguments are things that are statically
--   allocated, i.e., they exist at program startup. These are static heap
--   objects or literals or things that have been floated to the top level
--   binding by ghc.
data StaticArg

-- | reference to a heap object
StaticObjArg :: !FastString -> StaticArg

-- | literal
StaticLitArg :: !StaticLit -> StaticArg

-- | unfloated constructor
StaticConArg :: !FastString -> [StaticArg] -> StaticArg

-- | A Static literal value
data StaticLit
BoolLit :: !Bool -> StaticLit
IntLit :: !Integer -> StaticLit
NullLit :: StaticLit
DoubleLit :: !SaneDouble -> StaticLit
StringLit :: !FastString -> StaticLit
BinLit :: !ByteString -> StaticLit

-- | is function pointer, label (also used for string / binary init)
LabelLit :: !Bool -> !FastString -> StaticLit

-- | A foreign reference to some JS code
data ForeignJSRef
ForeignJSRef :: !FastString -> !FastString -> !Safety -> !CCallConv -> ![FastString] -> !FastString -> ForeignJSRef
[foreignRefSrcSpan] :: ForeignJSRef -> !FastString
[foreignRefPattern] :: ForeignJSRef -> !FastString
[foreignRefSafety] :: ForeignJSRef -> !Safety
[foreignRefCConv] :: ForeignJSRef -> !CCallConv
[foreignRefArgs] :: ForeignJSRef -> ![FastString]
[foreignRefResult] :: ForeignJSRef -> !FastString

-- | data used to generate one ObjUnit in our object file
data LinkableUnit
LinkableUnit :: ObjUnit -> [Id] -> [FastString] -> [Id] -> [Unique] -> [OtherSymb] -> Bool -> [ForeignJSRef] -> LinkableUnit

-- | serializable unit info
[luObjUnit] :: LinkableUnit -> ObjUnit

-- | exported names from haskell identifiers
[luIdExports] :: LinkableUnit -> [Id]

-- | other exports
[luOtherExports] :: LinkableUnit -> [FastString]

-- | identifiers this unit depends on
[luIdDeps] :: LinkableUnit -> [Id]

-- | pseudo-id identifiers this unit depends on (fixme)
[luPseudoIdDeps] :: LinkableUnit -> [Unique]

-- | symbols not from a haskell id that this unit depends on
[luOtherDeps] :: LinkableUnit -> [OtherSymb]

-- | always link this unit
[luRequired] :: LinkableUnit -> Bool
[luForeignRefs] :: LinkableUnit -> [ForeignJSRef]

-- | one toplevel block in the object file
data ObjUnit
ObjUnit :: ![FastString] -> ![ClosureInfo] -> ![StaticInfo] -> JStat -> !ByteString -> ![ExpFun] -> ![ForeignJSRef] -> ObjUnit

-- | toplevel symbols (stored in index)
[oiSymbols] :: ObjUnit -> ![FastString]

-- | closure information of all closures in block
[oiClInfo] :: ObjUnit -> ![ClosureInfo]

-- | static closure data
[oiStatic] :: ObjUnit -> ![StaticInfo]

-- | the code
[oiStat] :: ObjUnit -> JStat

-- | raw JS code
[oiRaw] :: ObjUnit -> !ByteString
[oiFExports] :: ObjUnit -> ![ExpFun]
[oiFImports] :: ObjUnit -> ![ForeignJSRef]
data ExpFun
ExpFun :: !Bool -> [JSFFIType] -> !JSFFIType -> ExpFun
[isIO] :: ExpFun -> !Bool
[args] :: ExpFun -> [JSFFIType]
[result] :: ExpFun -> !JSFFIType

-- | Types of FFI values
data JSFFIType
Int8Type :: JSFFIType
Int16Type :: JSFFIType
Int32Type :: JSFFIType
Int64Type :: JSFFIType
Word8Type :: JSFFIType
Word16Type :: JSFFIType
Word32Type :: JSFFIType
Word64Type :: JSFFIType
DoubleType :: JSFFIType
ByteArrayType :: JSFFIType
PtrType :: JSFFIType
RefType :: JSFFIType

-- | Typed expression
data TypedExpr
TypedExpr :: !PrimRep -> [JExpr] -> TypedExpr
[typex_typ] :: TypedExpr -> !PrimRep
[typex_expr] :: TypedExpr -> [JExpr]

-- | A Primop result is either an inlining of some JS payload, or a
--   primitive call to a JS function defined in Shim files in base.
data PrimRes

-- | primop is inline, result is assigned directly
PrimInline :: JStat -> PrimRes

-- | primop is async call, primop returns the next function to run. result
--   returned to stack top in registers
PRPrimCall :: JStat -> PrimRes
data ExprResult
ExprCont :: ExprResult
ExprInline :: Maybe [JExpr] -> ExprResult
newtype ExprValData
ExprValData :: [JExpr] -> ExprValData

-- | A Closure is one of six types
data ClosureType

-- | The closure is a THUNK
Thunk :: ClosureType

-- | The closure is a Function
Fun :: ClosureType

-- | The closure is a Partial Application
Pap :: ClosureType

-- | The closure is a Constructor
Con :: ClosureType

-- | The closure is a Blackhole
Blackhole :: ClosureType

-- | The closure is a stack frame
StackFrame :: ClosureType

-- | Convert <a>ClosureType</a> to an Int
ctNum :: ClosureType -> Int

-- | Convert <a>ClosureType</a> to a String
ctJsName :: ClosureType -> String

-- | A thread is in one of 4 states
data ThreadStatus

-- | The thread is running
Running :: ThreadStatus

-- | The thread is blocked
Blocked :: ThreadStatus

-- | The thread is done
Finished :: ThreadStatus

-- | The thread has died
Died :: ThreadStatus

-- | Convert the status of a thread in JS land to an Int
threadStatusNum :: ThreadStatus -> Int

-- | convert the status of a thread in JS land to a string
threadStatusJsName :: ThreadStatus -> String
instance GHC.Generics.Generic GHC.StgToJS.Types.CIType
instance GHC.Show.Show GHC.StgToJS.Types.CIType
instance GHC.Classes.Ord GHC.StgToJS.Types.CIType
instance GHC.Classes.Eq GHC.StgToJS.Types.CIType
instance GHC.Show.Show GHC.StgToJS.Types.CIStatic
instance GHC.Base.Monoid GHC.StgToJS.Types.CIStatic
instance GHC.Base.Semigroup GHC.StgToJS.Types.CIStatic
instance GHC.Generics.Generic GHC.StgToJS.Types.CIStatic
instance GHC.Classes.Eq GHC.StgToJS.Types.CIStatic
instance GHC.Generics.Generic GHC.StgToJS.Types.VarType
instance GHC.Show.Show GHC.StgToJS.Types.VarType
instance GHC.Enum.Bounded GHC.StgToJS.Types.VarType
instance GHC.Enum.Enum GHC.StgToJS.Types.VarType
instance GHC.Classes.Ord GHC.StgToJS.Types.VarType
instance GHC.Classes.Eq GHC.StgToJS.Types.VarType
instance GHC.Generics.Generic GHC.StgToJS.Types.CILayout
instance GHC.Show.Show GHC.StgToJS.Types.CILayout
instance GHC.Classes.Ord GHC.StgToJS.Types.CILayout
instance GHC.Classes.Eq GHC.StgToJS.Types.CILayout
instance GHC.Generics.Generic GHC.StgToJS.Types.CIRegs
instance GHC.Show.Show GHC.StgToJS.Types.CIRegs
instance GHC.Classes.Ord GHC.StgToJS.Types.CIRegs
instance GHC.Classes.Eq GHC.StgToJS.Types.CIRegs
instance GHC.Generics.Generic GHC.StgToJS.Types.ClosureInfo
instance GHC.Show.Show GHC.StgToJS.Types.ClosureInfo
instance GHC.Classes.Eq GHC.StgToJS.Types.ClosureInfo
instance GHC.Classes.Ord GHC.StgToJS.Types.IdType
instance GHC.Classes.Eq GHC.StgToJS.Types.IdType
instance GHC.Enum.Enum GHC.StgToJS.Types.IdType
instance GHC.Classes.Ord GHC.StgToJS.Types.IdKey
instance GHC.Classes.Eq GHC.StgToJS.Types.IdKey
instance GHC.Classes.Eq GHC.StgToJS.Types.OtherSymb
instance GHC.Classes.Ord GHC.StgToJS.Types.StackSlot
instance GHC.Classes.Eq GHC.StgToJS.Types.StackSlot
instance GHC.Generics.Generic GHC.StgToJS.Types.StaticUnboxed
instance GHC.Show.Show GHC.StgToJS.Types.StaticUnboxed
instance GHC.Classes.Ord GHC.StgToJS.Types.StaticUnboxed
instance GHC.Classes.Eq GHC.StgToJS.Types.StaticUnboxed
instance GHC.Generics.Generic GHC.StgToJS.Types.StaticLit
instance GHC.Show.Show GHC.StgToJS.Types.StaticLit
instance GHC.Classes.Eq GHC.StgToJS.Types.StaticLit
instance GHC.Generics.Generic GHC.StgToJS.Types.StaticArg
instance GHC.Show.Show GHC.StgToJS.Types.StaticArg
instance GHC.Classes.Eq GHC.StgToJS.Types.StaticArg
instance GHC.Generics.Generic GHC.StgToJS.Types.StaticVal
instance GHC.Show.Show GHC.StgToJS.Types.StaticVal
instance GHC.Classes.Eq GHC.StgToJS.Types.StaticVal
instance GHC.Generics.Generic GHC.StgToJS.Types.StaticInfo
instance GHC.Show.Show GHC.StgToJS.Types.StaticInfo
instance GHC.Classes.Eq GHC.StgToJS.Types.StaticInfo
instance GHC.Generics.Generic GHC.StgToJS.Types.ForeignJSRef
instance GHC.Enum.Enum GHC.StgToJS.Types.JSFFIType
instance GHC.Classes.Eq GHC.StgToJS.Types.JSFFIType
instance GHC.Classes.Ord GHC.StgToJS.Types.JSFFIType
instance GHC.Show.Show GHC.StgToJS.Types.JSFFIType
instance GHC.Show.Show GHC.StgToJS.Types.ExpFun
instance GHC.Classes.Ord GHC.StgToJS.Types.ExpFun
instance GHC.Classes.Eq GHC.StgToJS.Types.ExpFun
instance GHC.Classes.Eq GHC.StgToJS.Types.ExprResult
instance GHC.Classes.Eq GHC.StgToJS.Types.ExprValData
instance GHC.Enum.Bounded GHC.StgToJS.Types.ClosureType
instance GHC.Enum.Enum GHC.StgToJS.Types.ClosureType
instance GHC.Classes.Ord GHC.StgToJS.Types.ClosureType
instance GHC.Classes.Eq GHC.StgToJS.Types.ClosureType
instance GHC.Show.Show GHC.StgToJS.Types.ClosureType
instance GHC.Enum.Bounded GHC.StgToJS.Types.ThreadStatus
instance GHC.Enum.Enum GHC.StgToJS.Types.ThreadStatus
instance GHC.Classes.Ord GHC.StgToJS.Types.ThreadStatus
instance GHC.Classes.Eq GHC.StgToJS.Types.ThreadStatus
instance GHC.Show.Show GHC.StgToJS.Types.ThreadStatus
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Types.ClosureType
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Types.TypedExpr
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Types.StaticArg
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Types.StaticLit
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Types.StaticLit
instance Control.DeepSeq.NFData GHC.StgToJS.Types.StaticUnboxed
instance GHC.Classes.Ord GHC.StgToJS.Types.OtherSymb
instance Control.DeepSeq.NFData GHC.StgToJS.Types.CIRegs
instance Control.DeepSeq.NFData GHC.StgToJS.Types.CILayout
instance Control.DeepSeq.NFData GHC.StgToJS.Types.VarType
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Types.VarType
instance GHC.JS.Make.ToJExpr GHC.StgToJS.Types.CIStatic
instance Control.DeepSeq.NFData GHC.StgToJS.Types.CIType


-- | Types and utility functions used in the JS RTS.
module GHC.StgToJS.Rts.Types

-- | Syntactic sugar, i.e., a Haskell function which generates useful JS
--   code. Given a <tt>JExpr</tt>, <tt>ex</tt>, inject a trace statement on
--   <tt>ex</tt> in the compiled JS program
traceRts :: StgToJSConfig -> JExpr -> JStat

-- | Syntactic sugar. Given a <tt>JExpr</tt>, <tt>ex</tt> which is assumed
--   to be a predicate, and a message <tt>m</tt>, assert that 'not ex' is
--   True, if not throw an exception in JS land with message <tt>m</tt>.
assertRts :: ToJExpr a => StgToJSConfig -> JExpr -> a -> JStat

-- | name of the closure <tt>c</tt>
clName :: JExpr -> JExpr

-- | Type name of the closure <tt>c</tt>
clTypeName :: JExpr -> JExpr
stackFrameSize :: JExpr -> JExpr -> JStat

-- | Perform the computation <tt>f</tt>, on the range of registers bounded
--   by <tt>start</tt> and <tt>end</tt>.
withRegs :: StgReg -> StgReg -> (StgReg -> JStat) -> JStat


module GHC.StgToJS.Object

-- | Given a handle to a Binary payload, add the module, <tt>mod_name</tt>,
--   its dependencies, <tt>deps</tt>, and its linkable units to the
--   payload.
putObject :: BinHandle -> ModuleName -> Deps -> [ObjUnit] -> IO ()

-- | Parse object header
getObjectHeader :: BinHandle -> IO (Either String ModuleName)

-- | Parse object body. Must be called after a sucessful getObjectHeader
getObjectBody :: BinHandle -> ModuleName -> IO Object

-- | Parse object
getObject :: BinHandle -> IO (Maybe Object)

-- | Read object from file
--   
--   The object is still in memory after this (see objHandle).
readObject :: FilePath -> IO (Maybe Object)

-- | Get units in the object file, using the given filtering function
getObjectUnits :: Object -> (Word -> IndexEntry -> Bool) -> IO [ObjUnit]

-- | Read units in the object file, using the given filtering function
readObjectUnits :: FilePath -> (Word -> IndexEntry -> Bool) -> IO [ObjUnit]

-- | Reads only the part necessary to get the dependencies
readObjectDeps :: FilePath -> IO (Maybe Deps)

-- | we use the convention that the first unit (0) is a module-global unit
--   that's always included when something from the module is loaded.
--   everything in a module implicitly depends on the global block. the
--   global unit itself can't have dependencies
isGlobalUnit :: Int -> Bool

-- | Test if the object file is a JS object
isJsObjectFile :: FilePath -> IO Bool

-- | An object file
data Object
Object :: !ModuleName -> !BinHandle -> !Bin ObjUnit -> !Deps -> !Index -> Object

-- | name of the module
[objModuleName] :: Object -> !ModuleName

-- | BinHandle that can be used to read the ObjUnits
[objHandle] :: Object -> !BinHandle

-- | Offset of the payload (units)
[objPayloadOffset] :: Object -> !Bin ObjUnit

-- | Dependencies
[objDeps] :: Object -> !Deps

-- | The Index, serialed unit indices and their linkable units
[objIndex] :: Object -> !Index
data IndexEntry
IndexEntry :: ![FastString] -> !Bin ObjUnit -> IndexEntry

-- | Symbols exported by a unit
[idxSymbols] :: IndexEntry -> ![FastString]

-- | Offset of the unit in the object file
[idxOffset] :: IndexEntry -> !Bin ObjUnit

-- | dependencies for a single module
data Deps
Deps :: !Module -> !BlockIds -> !Map ExportedFun BlockId -> !Array BlockId BlockDeps -> Deps

-- | module
[depsModule] :: Deps -> !Module

-- | blocks that always need to be linked when this object is loaded (e.g.
--   everything that contains initializer code or foreign exports)
[depsRequired] :: Deps -> !BlockIds

-- | exported Haskell functions -&gt; block
[depsHaskellExported] :: Deps -> !Map ExportedFun BlockId

-- | info about each block
[depsBlocks] :: Deps -> !Array BlockId BlockDeps
data BlockDeps
BlockDeps :: [Int] -> [ExportedFun] -> BlockDeps

-- | dependencies on blocks in this object
[blockBlockDeps] :: BlockDeps -> [Int]

-- | dependencies on exported symbols in other objects ,
--   blockForeignExported :: [ExpFun] , blockForeignImported ::
--   [ForeignRef]
[blockFunDeps] :: BlockDeps -> [ExportedFun]

-- | Where are the dependencies
data DepsLocation

-- | In an object file at path
ObjectFile :: FilePath -> DepsLocation

-- | In a Ar file at path
ArchiveFile :: FilePath -> DepsLocation

-- | In memory
InMemory :: String -> Object -> DepsLocation

-- | Exported Functions
data ExportedFun
ExportedFun :: !Module -> !LexicalFastString -> ExportedFun

-- | The module containing the function
[funModule] :: ExportedFun -> !Module

-- | The function
[funSymbol] :: ExportedFun -> !LexicalFastString
instance GHC.Classes.Ord GHC.StgToJS.Object.ExportedFun
instance GHC.Classes.Eq GHC.StgToJS.Object.ExportedFun
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Object.DepsLocation
instance GHC.Utils.Binary.Binary GHC.StgToJS.Object.IndexEntry
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Object.Deps
instance GHC.Utils.Binary.Binary GHC.StgToJS.Object.Deps
instance GHC.Utils.Binary.Binary GHC.StgToJS.Object.BlockDeps
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Object.ExportedFun
instance GHC.Utils.Binary.Binary GHC.StgToJS.Object.ExportedFun
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.ForeignJSRef
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.ExpFun
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.JStat
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.JExpr
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.JVal
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.Ident
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.SaneDouble
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.ClosureInfo
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.JSFFIType
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.VarType
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.CIRegs
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.JOp
instance GHC.Utils.Binary.Binary GHC.JS.Syntax.JUOp
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.CILayout
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.CIStatic
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.CIType
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.StaticInfo
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.StaticVal
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.StaticUnboxed
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.StaticArg
instance GHC.Utils.Binary.Binary GHC.StgToJS.Types.StaticLit


module GHC.StgToJS.Linker.Types
data GhcjsEnv
GhcjsEnv :: MVar (Map (Set FilePath) (Map Module (Deps, DepsLocation), [LinkableUnit])) -> GhcjsEnv
[linkerArchiveDeps] :: GhcjsEnv -> MVar (Map (Set FilePath) (Map Module (Deps, DepsLocation), [LinkableUnit]))

-- | return a fresh <tt>GhcjsEnv</tt>
newGhcjsEnv :: IO GhcjsEnv
data JSLinkConfig
JSLinkConfig :: Bool -> Bool -> Bool -> Bool -> Bool -> JSLinkConfig
[lcNoJSExecutables] :: JSLinkConfig -> Bool
[lcNoHsMain] :: JSLinkConfig -> Bool
[lcOnlyOut] :: JSLinkConfig -> Bool
[lcNoRts] :: JSLinkConfig -> Bool
[lcNoStats] :: JSLinkConfig -> Bool
defaultJSLinkConfig :: JSLinkConfig

-- | we generate a runnable all.js only if we link a complete application,
--   no incremental linking and no skipped parts
generateAllJs :: JSLinkConfig -> Bool

-- | An object file that's either already in memory (with name) or on disk
data LinkedObj

-- | load from this file
ObjFile :: FilePath -> LinkedObj

-- | already loaded: description and payload
ObjLoaded :: String -> Object -> LinkedObj

-- | A <tt>LinkableUnit</tt> is a pair of a module and the index of the
--   block in the object file
type LinkableUnit = (Module, Int)
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.Linker.Types.LinkedObj

module GHC.StgToJS.Heap
closureType :: JExpr -> JExpr
entryClosureType :: JExpr -> JExpr
isObject :: JExpr -> JExpr
isThunk :: JExpr -> JExpr
isThunk' :: JExpr -> JExpr
isBlackhole :: JExpr -> JExpr
isFun :: JExpr -> JExpr
isFun' :: JExpr -> JExpr
isPap :: JExpr -> JExpr
isPap' :: JExpr -> JExpr
isCon :: JExpr -> JExpr
isCon' :: JExpr -> JExpr
conTag :: JExpr -> JExpr
conTag' :: JExpr -> JExpr

-- | Get closure entry function
closureEntry :: JExpr -> JExpr

-- | Get closure metadata
closureMeta :: JExpr -> JExpr

-- | Get closure extra field 1
closureField1 :: JExpr -> JExpr

-- | Get closure extra field 2
closureField2 :: JExpr -> JExpr

-- | Get closure cost-center
closureCC :: JExpr -> JExpr
funArity :: JExpr -> JExpr
funArity' :: JExpr -> JExpr
papArity :: JExpr -> JExpr
funOrPapArity :: JExpr -> Maybe JExpr -> JExpr
closureEntry_ :: FastString
closureMeta_ :: FastString
closureCC_ :: FastString
closureField1_ :: FastString
closureField2_ :: FastString
jTyObject :: JExpr


module GHC.StgToJS.ExprCtx

-- | Context into which an expression is evaluated
data ExprCtx

-- | Initialize an expression context in the context of the given top-level
--   binding Id
initExprCtx :: Id -> ExprCtx

-- | Add an Id to the known-evaluated set
ctxAssertEvaluated :: Id -> ExprCtx -> ExprCtx

-- | Predicate: do we know for sure that the given Id is evaluated?
ctxIsEvaluated :: ExprCtx -> Id -> Bool

-- | Set source location
ctxSetSrcSpan :: RealSrcSpan -> ExprCtx -> ExprCtx

-- | Source location
ctxSrcSpan :: ExprCtx -> Maybe RealSrcSpan

-- | Set top-level binding Id
ctxSetTop :: Id -> ExprCtx -> ExprCtx

-- | Target variables for the evaluated expression
ctxTarget :: ExprCtx -> [TypedExpr]

-- | Set target
ctxSetTarget :: [TypedExpr] -> ExprCtx -> ExprCtx

-- | Ids that we know to be evaluated (e.g. case binders when the
--   expression to evaluate is in an alternative)
ctxEvaluatedIds :: ExprCtx -> UniqSet Id

-- | Remove information about the current LNE frame
ctxClearLneFrame :: ExprCtx -> ExprCtx

-- | Update let-no-escape frame
ctxUpdateLneFrame :: [(Id, Int)] -> [Id] -> ExprCtx -> ExprCtx

-- | Contents of current LNE frame
--   
--   Variables and their index on the stack
ctxLneFrameVars :: ExprCtx -> [(Id, Int)]

-- | Cache the length of <a>ctxLneFrameVars</a>
ctxLneFrameSize :: ExprCtx -> Int

-- | Does the given Id correspond to a LNE binding
ctxIsLneBinding :: ExprCtx -> Id -> Bool

-- | Does the given Id correspond to a LNE live var on the stack
ctxIsLneLiveVar :: ExprCtx -> Id -> Bool

-- | Return the LNE stack size associated to the given Id. Return Nothing
--   when the Id doesn't correspond to a LNE binding.
ctxLneBindingStackSize :: ExprCtx -> Id -> Maybe Int

-- | Shrink the LNE stack to the given size
ctxLneShrinkStack :: ExprCtx -> Int -> ExprCtx

module GHC.StgToJS.Utils
assignToTypedExprs :: HasDebugCallStack => [TypedExpr] -> [JExpr] -> JStat

-- | Assign first expr only (if it exists), performing coercions between
--   some PrimReps (e.g. StablePtr# and Addr#).
assignCoerce1 :: HasDebugCallStack => [TypedExpr] -> [TypedExpr] -> JStat
assignToExprCtx :: HasDebugCallStack => ExprCtx -> [JExpr] -> JStat

module GHC.StgToJS.StgUtils

-- | collect Ids that this binding refers to (does not include the bindees
--   themselves) first argument is Id -&gt; StgExpr map for unfloated
--   arguments
bindingRefs :: UniqFM Id CgStgExpr -> CgStgBinding -> Set Id
hasExport :: CgStgBinding -> Bool
collectTopIds :: CgStgBinding -> [Id]
collectIds :: UniqFM Id CgStgExpr -> CgStgBinding -> [Id]
removeTick :: CgStgExpr -> CgStgExpr
isUpdatableRhs :: CgStgRhs -> Bool

-- | returns True if the expression is definitely inline
isInlineExpr :: UniqSet Id -> CgStgExpr -> (UniqSet Id, Bool)
exprRefs :: UniqFM Id CgStgExpr -> CgStgExpr -> Set Id
type LiveVars = DVarSet
liveVars :: LiveVars -> LiveVars
liveStatic :: LiveVars -> LiveVars
stgRhsLive :: CgStgRhs -> LiveVars
stgExprLive :: Bool -> CgStgExpr -> LiveVars
stgTopBindLive :: CgStgTopBinding -> [(Id, LiveVars)]
stgLetNoEscapeLive :: Bool -> StgBinding -> StgExpr -> LiveVars
stgLneLiveExpr :: CgStgRhs -> [Id]
stgLneLive :: CgStgBinding -> [Id]
stgLneLive' :: CgStgBinding -> [Id]


-- | JS codegen state monad
module GHC.StgToJS.Monad
runG :: StgToJSConfig -> Module -> UniqFM Id CgStgExpr -> G a -> IO a

-- | emit a global (for the current module) toplevel statement
emitGlobal :: JStat -> G ()

-- | add a dependency on a particular symbol to the current group
addDependency :: OtherSymb -> G ()

-- | emit a top-level statement for the current binding group
emitToplevel :: JStat -> G ()

-- | emit static data for the binding group
emitStatic :: FastString -> StaticVal -> Maybe Ident -> G ()

-- | add closure info in our binding group. all heap objects must have
--   closure info
emitClosureInfo :: ClosureInfo -> G ()
emitForeign :: Maybe RealSrcSpan -> FastString -> Safety -> CCallConv -> [FastString] -> FastString -> G ()
assertRtsStat :: G JStat -> G JStat
getSettings :: G StgToJSConfig

-- | Return number of occurrences of every global id used in the given
--   JStat. Sort by increasing occurrence count.
globalOccs :: JStat -> G [GlobalOcc]
setGlobalIdCache :: GlobalIdCache -> G ()
getGlobalIdCache :: G GlobalIdCache
data GlobalOcc
GlobalOcc :: !Ident -> !Id -> !Word -> GlobalOcc
[global_ident] :: GlobalOcc -> !Ident
[global_id] :: GlobalOcc -> !Id
[global_count] :: GlobalOcc -> !Word
modifyGroup :: (GenGroupState -> GenGroupState) -> G ()

-- | start with a new binding group
resetGroup :: G ()

module GHC.StgToJS.Profiling
initCostCentres :: CollectedCCs -> G ()
emitCostCentreDecl :: CostCentre -> G ()
emitCostCentreStackDecl :: CostCentreStack -> G ()
enterCostCentreFun :: CostCentreStack -> JStat
enterCostCentreThunk :: JStat
setCC :: CostCentre -> Bool -> Bool -> G JStat
pushRestoreCCS :: JStat
jCurrentCCS :: JExpr
jCafCCS :: JExpr
jSystemCCS :: JExpr
costCentreLbl :: CostCentre -> G Ident
costCentreStackLbl :: CostCentreStack -> G (Maybe Ident)
singletonCCSLbl :: CostCentre -> G Ident
ccsVarJ :: CostCentreStack -> G (Maybe JExpr)
profiling :: G Bool
ifProfiling :: Monoid m => m -> G m
ifProfilingM :: Monoid m => G m -> G m

-- | If profiling is enabled, then use input JStat, else ignore
profStat :: StgToJSConfig -> JStat -> JStat

module GHC.Stg.Utils
mkStgAltTypeFromStgAlts :: forall p. Id -> [GenStgAlt p] -> AltType
bindersOf :: BinderP a ~ Id => GenStgBinding a -> [Id]
bindersOfX :: GenStgBinding a -> [BinderP a]
bindersOfTop :: BinderP a ~ Id => GenStgTopBinding a -> [Id]
bindersOfTopBinds :: BinderP a ~ Id => [GenStgTopBinding a] -> [Id]

-- | Strip ticks of a given type from an STG expression.
stripStgTicksTop :: (StgTickish -> Bool) -> GenStgExpr p -> ([StgTickish], GenStgExpr p)

-- | Strip ticks of a given type from an STG expression returning only the
--   expression.
stripStgTicksTopE :: (StgTickish -> Bool) -> GenStgExpr p -> GenStgExpr p
idArgs :: [StgArg] -> [Id]
mkUnarisedId :: MonadUnique m => FastString -> UnaryType -> m Id
mkUnarisedIds :: MonadUnique m => FastString -> [UnaryType] -> m [Id]

module GHC.Stg.Stats
showStgStats :: [StgTopBinding] -> String
instance GHC.Classes.Ord GHC.Stg.Stats.CounterType
instance GHC.Classes.Eq GHC.Stg.Stats.CounterType


-- | (c) The GRASP/AQUA Project, Glasgow University, 1993-1998
--   
--   A lint pass to check basic STG invariants:
--   
--   <ul>
--   <li>Variables should be defined before used.</li>
--   <li>Let bindings should not have unboxed types (unboxed bindings
--   should only appear in case), except when they're join points (see Note
--   [Core let-can-float invariant] and #14117).</li>
--   <li>If linting after unarisation, invariants listed in Note
--   [Post-unarisation invariants].</li>
--   </ul>
--   
--   Because we don't have types and coercions in STG we can't really check
--   types here.
--   
--   Some history:
--   
--   StgLint used to check types, but it never worked and so it was
--   disabled in 2000 with this note:
--   
--   WARNING: ~~~~~~~~
--   
--   This module has suffered bit-rot; it is likely to yield lint errors
--   for Stg code that is currently perfectly acceptable for code
--   generation. Solution: don't use it! (KSW 2000-05).
--   
--   Since then there were some attempts at enabling it again, as
--   summarised in #14787. It's finally decided that we remove all type
--   checking and only look for basic properties listed above.
--   
--   Note [Linting StgApp] ~~~~~~~~~~~~~~~~~~~~~ To lint an application of
--   the form `f a_1 ... a_n`, we check that the representations of the
--   arguments <tt>a_1</tt>, ..., <tt>a_n</tt> match those that the
--   function expects.
--   
--   More precisely, suppose the types in the application `f a_1 ... a_n`
--   are as follows:
--   
--   f :: t_1 -&gt; ... -&gt; t_n -&gt; res a_1 :: s_1, ..., a_n :: s_n
--   
--   t_1 :: TYPE r_1, ..., t_n :: TYPE r_n s_1 :: TYPE p_1, ..., a_n ::
--   TYPE p_n
--   
--   Before unarisation, we must check that each r_i is compatible with
--   s_i. Compatibility is weaker than on-the-nose equality: for example,
--   IntRep and WordRep are compatible. See Note [Bad unsafe coercion] in
--   GHC.Core.Lint.
--   
--   After unarisation, a single type might correspond to multiple
--   arguments, e.g.
--   
--   (# Int# | Bool #) :: TYPE (SumRep '[ IntRep, LiftedRep ])
--   
--   will result in two arguments: [Int# :: TYPE 'IntRep, Bool :: TYPE
--   LiftedRep] This means post unarise we potentially have to match up
--   multiple arguments with the reps of a single argument in the type's
--   definition, because the type of the function is *not* in unarised
--   form.
--   
--   Wrinkle: it can sometimes happen that an argument type in the type of
--   the function does not have a fixed runtime representation, i.e. there
--   is an r_i such that runtimeRepPrimRep r_i crashes. See
--   <a>https://gitlab.haskell.org/ghc/ghc/-/issues/21399</a> for an
--   example. Fixing this issue would require significant changes to the
--   type system of STG, so for now we simply skip the Lint check when we
--   detect such representation-polymorphic situations.
--   
--   Note [Typing the STG language] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ In Core,
--   programs must be <i>well-typed</i>. So if f :: ty1 -&gt; ty2, then in
--   the application (f e), we must have e :: ty1
--   
--   STG is still a statically typed language, but the type system is much
--   coarser. In particular, STG programs must be <i>well-kinded</i>. More
--   precisely, if f :: ty1 -&gt; ty2, then in the application (f e) where
--   e :: ty1', we must have kind(ty1) = kind(ty1').
--   
--   So the STG type system does not distinguish between Int and Bool, but
--   it <i>does</i> distinguish between Int and Int#, because they have
--   different kinds. Actually, since all terms have kind (TYPE rep), we
--   might say that the STG language is well-runtime-rep'd.
--   
--   This coarser type system makes fewer distinctions, and that allows
--   many nonsensical programs (such as (<tt>x</tt> &amp;&amp; "foo")) --
--   but all type systems accept buggy programs! But the coarseness also
--   permits some optimisations that are ill-typed in Core. For example,
--   see the module STG.CSE, which is all about doing CSE in STG that would
--   be ill-typed in Core. But it must still be well-kinded!
module GHC.Stg.Lint
lintStgTopBindings :: forall a. (OutputablePass a, BinderP a ~ Id) => Platform -> Logger -> DiagOpts -> StgPprOpts -> [Var] -> Module -> Bool -> String -> [GenStgTopBinding a] -> IO ()
instance GHC.Base.Functor GHC.Stg.Lint.LintM
instance GHC.Base.Applicative GHC.Stg.Lint.LintM
instance GHC.Base.Monad GHC.Stg.Lint.LintM

module GHC.Stg.InferTags.Types
type InferStgTopBinding = GenStgTopBinding 'InferTaggedBinders
type InferStgBinding = GenStgBinding 'InferTaggedBinders
type InferStgExpr = GenStgExpr 'InferTaggedBinders
type InferStgRhs = GenStgRhs 'InferTaggedBinders
type InferStgAlt = GenStgAlt 'InferTaggedBinders
type TagSigEnv = IdEnv TagSig
data TagEnv p
TE :: TagSigEnv -> (BinderP p -> Id) -> !Bool -> TagEnv p
[te_env] :: TagEnv p -> TagSigEnv
[te_get] :: TagEnv p -> BinderP p -> Id
[te_bytecode] :: TagEnv p -> !Bool
noSig :: TagEnv p -> BinderP p -> (Id, TagSig)
extendSigEnv :: TagEnv p -> [(Id, TagSig)] -> TagEnv p
initEnv :: Bool -> TagEnv 'CodeGen
combineAltInfo :: TagInfo -> TagInfo -> TagInfo
getBinderId :: TagEnv p -> BinderP p -> Id

-- | Simple convert env to a env of the 'InferTaggedBinders pass with no
--   other changes.
makeTagged :: TagEnv p -> TagEnv 'InferTaggedBinders

-- | Look up a sig in the given env
lookupSig :: TagEnv p -> Id -> Maybe TagSig

-- | Look up a sig in the env or derive it from information in the arg
--   itself.
lookupInfo :: TagEnv p -> StgArg -> TagInfo
isDunnoSig :: TagSig -> Bool
isTaggedInfo :: TagInfo -> Bool
instance GHC.Utils.Outputable.Outputable (GHC.Stg.InferTags.Types.TagEnv p)


-- | Non-global free variable analysis on STG terms. This pass annotates
--   non-top-level closure bindings with captured variables. Global
--   variables are not captured. For example, in a top-level binding like
--   (pseudo-STG)
--   
--   f = [x,y] . let g = [p] . reverse (x ++ p) in g y
--   
--   In g, <a>reverse</a> and <a>(++)</a> are global variables so they're
--   not considered free. <tt>p</tt> is an argument, so <tt>x</tt> is the
--   only actual free variable here. The annotated version is thus:
--   
--   f = [x,y] . let g = [x] [p] . reverse (x ++ p) in g y
--   
--   Note that non-top-level recursive bindings are also considered free
--   within the group:
--   
--   map = {} r [f xs0] let { Rec { go = {f, go} r [xs1] case xs1 of { []
--   -&gt; [] []; : x xs2 -&gt; let { xs' = {go, xs2} u [] go xs2; } in let
--   { x' = {f, x} u [] f x; } in : [x' xs']; }; end Rec } } in go xs0;
--   
--   Here go is free in its RHS.
--   
--   Top-level closure bindings never capture variables as all of their
--   free variables are global.
module GHC.Stg.FVs

-- | Dependency sort a STG program, and annotate it with free variables The
--   returned bindings: * Are in dependency order * Each StgRhsClosure is
--   correctly annotated (in its extension field) with the free variables
--   needed in the closure * Each StgCase is correctly annotated (in its
--   extension field) with the variables that must be saved across the case
depSortWithAnnotStgPgm :: Module -> [StgTopBinding] -> [CgStgTopBinding]

-- | Dependency analysis on STG terms.
--   
--   Dependencies of a binding are just free variables in the binding. This
--   includes imported ids and ids in the current module. For recursive
--   groups we just return one set of free variables which is just the
--   union of dependencies of all bindings in the group.
--   
--   Implementation: pass bound variables (NestedIds) to recursive calls,
--   get free variables (TopFVs) back. We ignore imported TopFVs as they do
--   not change the ordering but it improves performance (see
--   <tt>nameIsExternalFrom</tt> call in <tt>vars_fvs</tt>).
annBindingFreeVars :: Module -> StgBinding -> CgStgBinding


-- | Note [CSE for Stg] ~~~~~~~~~~~~~~~~~~
--   
--   This module implements a simple common subexpression elimination pass
--   for STG. This is useful because there are expressions that we want to
--   common up (because they are operationally equivalent), but that we
--   cannot common up in Core, because their types differ. This was
--   originally reported as #9291.
--   
--   There are two types of common code occurrences that we aim for, see
--   Note [Case 1: CSEing allocated closures] and Note [Case 2: CSEing case
--   binders] below.
--   
--   Note [Case 1: CSEing allocated closures]
--   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   The first kind of CSE opportunity we aim for is generated by this
--   Haskell code:
--   
--   bar :: a -&gt; (Either Int a, Either Bool a) bar x = (Right x, Right
--   x)
--   
--   which produces this Core:
--   
--   bar :: forall a. a -&gt; (Either Int a, Either Bool a) bar <tt>a x =
--   (Right </tt>Int <tt>a x, Right </tt>Bool @a x)
--   
--   where the two components of the tuple are different terms, and cannot
--   be commoned up (easily). On the STG level we have
--   
--   bar [x] = let c1 = Right [x] c2 = Right [x] in (c1,c2)
--   
--   and now it is obvious that we can write
--   
--   bar [x] = let c1 = Right [x] in (c1,c1)
--   
--   instead.
--   
--   Note [Case 2: CSEing case binders] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   The second kind of CSE opportunity we aim for is more interesting, and
--   came up in #9291 and #5344: The Haskell code
--   
--   foo :: Either Int a -&gt; Either Bool a foo (Right x) = Right x foo _
--   = Left False
--   
--   produces this Core
--   
--   foo :: forall a. Either Int a -&gt; Either Bool a foo <tt>a e = case e
--   of b { Left n -&gt; … , Right x -&gt; Right </tt>Bool @a x }
--   
--   where we cannot CSE `Right <tt>Bool </tt>a x` with the case binder
--   <tt>b</tt> as they have different types. But in STG we have
--   
--   foo [e] = case e of b { Left [n] -&gt; … , Right [x] -&gt; Right [x] }
--   
--   and nothing stops us from transforming that to
--   
--   foo [e] = case e of b { Left [n] -&gt; … , Right [x] -&gt; b}
--   
--   Note [StgCse after unarisation] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   Consider two unboxed sum terms:
--   
--   (# 1 | #) :: (# Int | Int# #) (# 1 | #) :: (# Int | Int #)
--   
--   These two terms are not equal as they unarise to different unboxed
--   tuples. However if we run StgCse before Unarise, it'll think the two
--   terms (# 1 | #) are equal, and replace one of these with a binder to
--   the other. That's bad -- #15300.
--   
--   Solution: do unarise first.
module GHC.Stg.CSE
stgCse :: [InStgTopBinding] -> [OutStgTopBinding]
instance GHC.Base.Functor GHC.Stg.CSE.ConAppMap
instance GHC.Data.TrieMap.TrieMap GHC.Stg.CSE.ConAppMap
instance GHC.Base.Functor GHC.Stg.CSE.StgArgMap
instance GHC.Data.TrieMap.TrieMap GHC.Stg.CSE.StgArgMap


-- | Commonly useful utilities for manipulating the Core language
module GHC.Core.Utils

-- | Wrap the given expression in the coercion safely, dropping identity
--   coercions and coalescing nested coercions
mkCast :: HasDebugCallStack => CoreExpr -> CoercionR -> CoreExpr
mkCastMCo :: CoreExpr -> MCoercionR -> CoreExpr
mkPiMCo :: Var -> MCoercionR -> MCoercionR

-- | Wraps the given expression in the source annotation, dropping the
--   annotation if possible.
mkTick :: CoreTickish -> CoreExpr -> CoreExpr
mkTicks :: [CoreTickish] -> CoreExpr -> CoreExpr
mkTickNoHNF :: CoreTickish -> CoreExpr -> CoreExpr
tickHNFArgs :: CoreTickish -> CoreExpr -> CoreExpr

-- | <tt>bindNonRec x r b</tt> produces either:
--   
--   <pre>
--   let x = r in b
--   </pre>
--   
--   or:
--   
--   <pre>
--   case r of x { _DEFAULT_ -&gt; b }
--   </pre>
--   
--   depending on whether we have to use a <tt>case</tt> or <tt>let</tt>
--   binding for the expression (see <a>needsCaseBinding</a>). It's used by
--   the desugarer to avoid building bindings that give Core Lint a heart
--   attack, although actually the simplifier deals with them perfectly
--   well. See also <a>mkCoreLet</a>
bindNonRec :: HasDebugCallStack => Id -> CoreExpr -> CoreExpr -> CoreExpr

-- | Tests whether we have to use a <tt>case</tt> rather than <tt>let</tt>
--   binding for this expression as per the invariants of <a>CoreExpr</a>:
--   see <a>GHC.Core#let_can_float_invariant</a>
needsCaseBinding :: Type -> CoreExpr -> Bool

-- | This guy constructs the value that the scrutinee must have given that
--   you are in one particular branch of a case
mkAltExpr :: AltCon -> [CoreBndr] -> [Type] -> CoreExpr
mkDefaultCase :: CoreExpr -> Id -> CoreExpr -> CoreExpr
mkSingleAltCase :: CoreExpr -> Id -> AltCon -> [Var] -> CoreExpr -> CoreExpr

-- | Extract the default case alternative
findDefault :: [Alt b] -> ([Alt b], Maybe (Expr b))
addDefault :: [Alt b] -> Maybe (Expr b) -> [Alt b]

-- | Find the case alternative corresponding to a particular constructor:
--   panics if no such constructor exists
findAlt :: AltCon -> [Alt b] -> Maybe (Alt b)
isDefaultAlt :: Alt b -> Bool

-- | Merge alternatives preserving order; alternatives in the first
--   argument shadow ones in the second
mergeAlts :: [Alt a] -> [Alt a] -> [Alt a]

-- | Given:
--   
--   <pre>
--   case (C a b x y) of
--          C b x y -&gt; ...
--   </pre>
--   
--   We want to drop the leading type argument of the scrutinee leaving the
--   arguments to match against the pattern
trimConArgs :: AltCon -> [CoreArg] -> [CoreArg]
filterAlts :: TyCon -> [Type] -> [AltCon] -> [Alt b] -> ([AltCon], [Alt b])
combineIdenticalAlts :: [AltCon] -> [CoreAlt] -> (Bool, [AltCon], [CoreAlt])

-- | Refine the default alternative to a <a>DataAlt</a>, if there is a
--   unique way to do so. See Note [Refine DEFAULT case alternatives]
refineDefaultAlt :: [Unique] -> Mult -> TyCon -> [Type] -> [AltCon] -> [CoreAlt] -> (Bool, [CoreAlt])
scaleAltsBy :: Mult -> [CoreAlt] -> [CoreAlt]

-- | Recover the type of a well-typed Core expression. Fails when applied
--   to the actual <a>Type</a> expression as it cannot really be said to
--   have a type
exprType :: HasDebugCallStack => CoreExpr -> Type

-- | Returns the type of the alternatives right hand side
coreAltType :: CoreAlt -> Type

-- | Returns the type of the first alternative, which should be the same as
--   for all alternatives
coreAltsType :: [CoreAlt] -> Type

-- | Makes a <tt>(-&gt;)</tt> type or an implicit forall type, depending on
--   whether it is given a type variable or a term variable. This is used,
--   for example, when producing the type of a lambda. Always uses Inferred
--   binders.
mkLamType :: HasDebugCallStack => Var -> Type -> Type

-- | <a>mkLamType</a> for multiple type or value arguments
mkLamTypes :: [Var] -> Type -> Type

-- | This one works out the FunTyFlag from the argument type See
--   GHC.Types.Var Note [FunTyFlag]
mkFunctionType :: HasDebugCallStack => Mult -> Type -> Type -> Type
exprIsTrivial :: CoreExpr -> Bool
getIdFromTrivialExpr :: HasDebugCallStack => CoreExpr -> Id
getIdFromTrivialExpr_maybe :: CoreExpr -> Maybe Id

-- | The worker function for Note [exprIsTrivial] and Note
--   [getIdFromTrivialExpr] This is meant to have the code of both
--   functions in one place and make it easy to derive custom predicates.
--   
--   (trivial_expr_fold k_id k_triv k_not_triv e) * returns (k_id x) if
--   <tt>e</tt> is a variable <tt>x</tt> (with trivial wrapping) * returns
--   (k_lit x) if <tt>e</tt> is a trivial literal <tt>l</tt> (with trivial
--   wrapping) * returns k_triv if <tt>e</tt> is a literal, type, or
--   coercion (with trivial wrapping) * returns k_not_triv otherwise
--   
--   where "trivial wrapping" is * Type application or abstraction * Ticks
--   other than <a>tickishIsCode</a> * `case e of {}` an empty case
trivial_expr_fold :: (Id -> r) -> (Literal -> r) -> r -> r -> CoreExpr -> r
exprIsDupable :: Platform -> CoreExpr -> Bool
exprIsCheap :: CoreExpr -> Bool
exprIsExpandable :: CoreExpr -> Bool
exprIsCheapX :: CheapAppFun -> CoreExpr -> Bool
type CheapAppFun = Id -> Arity -> Bool

-- | exprIsHNF returns true for expressions that are certainly
--   <i>already</i> evaluated to <i>head</i> normal form. This is used to
--   decide whether it's ok to change:
--   
--   <pre>
--   case x of _ -&gt; e
--   </pre>
--   
--   into:
--   
--   <pre>
--   e
--   </pre>
--   
--   and to decide whether it's safe to discard a <a>seq</a>.
--   
--   So, it does <i>not</i> treat variables as evaluated, unless they say
--   they are. However, it <i>does</i> treat partial applications and
--   constructor applications as values, even if their arguments are
--   non-trivial, provided the argument type is lifted. For example, both
--   of these are values:
--   
--   <pre>
--   (:) (f x) (map f xs)
--   map (...redex...)
--   </pre>
--   
--   because <a>seq</a> on such things completes immediately.
--   
--   For unlifted argument types, we have to be careful:
--   
--   <pre>
--   C (f x :: Int#)
--   </pre>
--   
--   Suppose <tt>f x</tt> diverges; then <tt>C (f x)</tt> is not a value.
--   We check for this using needsCaseBinding below
exprIsHNF :: CoreExpr -> Bool

-- | <a>exprOkForSpeculation</a> returns True of an expression that is:
--   
--   <ul>
--   <li>Safe to evaluate even if normal order eval might not evaluate the
--   expression at all, or</li>
--   <li>Safe <i>not</i> to evaluate even if normal order would do so</li>
--   </ul>
--   
--   It is usually called on arguments of unlifted type, but not always In
--   particular, Simplify.rebuildCase calls it on lifted types when a
--   'case' is a plain <a>seq</a>. See the example in Note
--   [exprOkForSpeculation: case expressions] below
--   
--   Precisely, it returns <tt>True</tt> iff: a) The expression guarantees
--   to terminate, b) soon, c) without causing a write side effect (e.g.
--   writing a mutable variable) d) without throwing a Haskell exception e)
--   without risking an unchecked runtime exception (array out of bounds,
--   divide by zero)
--   
--   For <tt>exprOkForSideEffects</tt> the list is the same, but omitting
--   (e).
--   
--   Note that exprIsHNF implies exprOkForSpeculation exprOkForSpeculation
--   implies exprOkForSideEffects
--   
--   See Note [PrimOp can_fail and has_side_effects] in
--   <a>GHC.Builtin.PrimOps</a> and Note [Transformations affected by
--   can_fail and has_side_effects]
--   
--   As an example of the considerations in this test, consider:
--   
--   <pre>
--   let x = case y# +# 1# of { r# -&gt; I# r# }
--   in E
--   </pre>
--   
--   being translated to:
--   
--   <pre>
--   case y# +# 1# of { r# -&gt;
--      let x = I# r#
--      in E
--   }
--   </pre>
--   
--   We can only do this if the <tt>y + 1</tt> is ok for speculation: it
--   has no side effects, and can't diverge or raise an exception.
exprOkForSpeculation :: CoreExpr -> Bool

-- | <a>exprOkForSpeculation</a> returns True of an expression that is:
--   
--   <ul>
--   <li>Safe to evaluate even if normal order eval might not evaluate the
--   expression at all, or</li>
--   <li>Safe <i>not</i> to evaluate even if normal order would do so</li>
--   </ul>
--   
--   It is usually called on arguments of unlifted type, but not always In
--   particular, Simplify.rebuildCase calls it on lifted types when a
--   'case' is a plain <a>seq</a>. See the example in Note
--   [exprOkForSpeculation: case expressions] below
--   
--   Precisely, it returns <tt>True</tt> iff: a) The expression guarantees
--   to terminate, b) soon, c) without causing a write side effect (e.g.
--   writing a mutable variable) d) without throwing a Haskell exception e)
--   without risking an unchecked runtime exception (array out of bounds,
--   divide by zero)
--   
--   For <tt>exprOkForSideEffects</tt> the list is the same, but omitting
--   (e).
--   
--   Note that exprIsHNF implies exprOkForSpeculation exprOkForSpeculation
--   implies exprOkForSideEffects
--   
--   See Note [PrimOp can_fail and has_side_effects] in
--   <a>GHC.Builtin.PrimOps</a> and Note [Transformations affected by
--   can_fail and has_side_effects]
--   
--   As an example of the considerations in this test, consider:
--   
--   <pre>
--   let x = case y# +# 1# of { r# -&gt; I# r# }
--   in E
--   </pre>
--   
--   being translated to:
--   
--   <pre>
--   case y# +# 1# of { r# -&gt;
--      let x = I# r#
--      in E
--   }
--   </pre>
--   
--   We can only do this if the <tt>y + 1</tt> is ok for speculation: it
--   has no side effects, and can't diverge or raise an exception.
exprOkForSideEffects :: CoreExpr -> Bool

-- | A special version of <a>exprOkForSpeculation</a> used during Note
--   [Speculative evaluation]. When the predicate arg <tt>fun_ok</tt>
--   returns False for <tt>b</tt>, then <tt>b</tt> is never considered
--   ok-for-spec.
exprOkForSpecEval :: (Id -> Bool) -> CoreExpr -> Bool
exprIsWorkFree :: CoreExpr -> Bool

-- | Similar to <a>exprIsHNF</a> but includes CONLIKE functions as well as
--   data constructors. Conlike arguments are considered interesting by the
--   inliner.
exprIsConLike :: CoreExpr -> Bool
isCheapApp :: CheapAppFun
isExpandableApp :: CheapAppFun
isSaturatedConApp :: CoreExpr -> Bool

-- | Check if the expression is zero or more Ticks wrapped around a literal
--   string.
exprIsTickedString :: CoreExpr -> Bool

-- | Extract a literal string from an expression that is zero or more Ticks
--   wrapped around a literal string. Returns Nothing if the expression has
--   a different shape. Used to "look through" Ticks in places that need to
--   handle literal strings.
exprIsTickedString_maybe :: CoreExpr -> Maybe ByteString

-- | Can we bind this <a>CoreExpr</a> at the top level?
exprIsTopLevelBindable :: CoreExpr -> Type -> Bool
altsAreExhaustive :: [Alt b] -> Bool

-- | Should we look past this tick when eta-expanding the given function?
--   
--   See Note [Ticks and mandatory eta expansion] Takes the function we are
--   applying as argument.
etaExpansionTick :: Id -> GenTickish pass -> Bool

-- | A cheap equality test which bales out fast! If it returns
--   <tt>True</tt> the arguments are definitely equal, otherwise, they may
--   or may not be equal.
cheapEqExpr :: Expr b -> Expr b -> Bool

-- | Cheap expression equality test, can ignore ticks by type.
cheapEqExpr' :: (CoreTickish -> Bool) -> Expr b -> Expr b -> Bool

-- | Finds differences between core bindings, see <tt>diffExpr</tt>.
--   
--   The main problem here is that while we expect the binds to have the
--   same order in both lists, this is not guaranteed. To do this properly
--   we'd either have to do some sort of unification or check all possible
--   mappings, which would be seriously expensive. So instead we simply
--   match single bindings as far as we can. This leaves us just with
--   mutually recursive and/or mismatching bindings, which we then
--   speculatively match by ordering them. It's by no means perfect, but
--   gets the job done well enough.
--   
--   Only used in GHC.Core.Lint.lintAnnots
diffBinds :: Bool -> RnEnv2 -> [(Var, CoreExpr)] -> [(Var, CoreExpr)] -> ([SDoc], RnEnv2)

-- | If the expression is a <a>Type</a>, converts. Otherwise, panics. NB:
--   This does <i>not</i> convert <a>Coercion</a> to <tt>CoercionTy</tt>.
exprToType :: CoreExpr -> Type

-- | Determines the type resulting from applying an expression with given
--   type
applyTypeToArgs :: HasDebugCallStack => SDoc -> Type -> [CoreExpr] -> Type
dataConRepInstPat :: [Unique] -> Mult -> DataCon -> [Type] -> ([TyCoVar], [Id])
dataConRepFSInstPat :: [FastString] -> [Unique] -> Mult -> DataCon -> [Type] -> ([TyCoVar], [Id])

-- | True if the type has no non-bottom elements, e.g. when it is an empty
--   datatype, or a GADT with non-satisfiable type parameters, e.g. Int :~:
--   Bool. See Note [Bottoming expressions]
--   
--   See Note [No alternatives lint check] for another use of this
--   function.
isEmptyTy :: Type -> Bool

-- | If <tt>normSplitTyConApp_maybe _ ty = Just (tc, tys, co)</tt> then
--   <tt>ty |&gt; co = tc tys</tt>. It's <a>splitTyConApp_maybe</a>, but
--   looks through coercions via <a>topNormaliseType_maybe</a>. Hence the
--   "norm" prefix.
normSplitTyConApp_maybe :: FamInstEnvs -> Type -> Maybe (TyCon, [Type], Coercion)

-- | Strip ticks satisfying a predicate from top of an expression
stripTicksTop :: (CoreTickish -> Bool) -> Expr b -> ([CoreTickish], Expr b)

-- | Strip ticks satisfying a predicate from top of an expression,
--   returning the remaining expression
stripTicksTopE :: (CoreTickish -> Bool) -> Expr b -> Expr b

-- | Strip ticks satisfying a predicate from top of an expression,
--   returning the ticks
stripTicksTopT :: (CoreTickish -> Bool) -> Expr b -> [CoreTickish]

-- | Completely strip ticks satisfying a predicate from an expression. Note
--   this is O(n) in the size of the expression!
stripTicksE :: (CoreTickish -> Bool) -> Expr b -> Expr b
stripTicksT :: (CoreTickish -> Bool) -> Expr b -> [CoreTickish]
mkInScopeSetBndrs :: [CoreBind] -> InScopeSet
extendInScopeSetBind :: InScopeSet -> CoreBind -> InScopeSet
extendInScopeSetBndrs :: InScopeSet -> [CoreBind] -> InScopeSet

-- | <tt>collectMakeStaticArgs (makeStatic t srcLoc e)</tt> yields <tt>Just
--   (makeStatic, t, srcLoc, e)</tt>.
--   
--   Returns <tt>Nothing</tt> for every other expression.
collectMakeStaticArgs :: CoreExpr -> Maybe (CoreExpr, Type, CoreExpr, CoreExpr)

-- | Does this binding bind a join point (or a recursive group of join
--   points)?
isJoinBind :: CoreBind -> Bool
mkStrictFieldSeqs :: [(Id, StrictnessMark)] -> CoreExpr -> CoreExpr

-- | Do we expect there to be any benefit if we make this var strict in
--   order for it to get treated as as cbv argument? See Note [Which Ids
--   should be strictified] See Note [CBV Function Ids] for more
--   background.
shouldStrictifyIdForCbv :: Var -> Bool
shouldUseCbvForId :: Var -> Bool
isUnsafeEqualityProof :: CoreExpr -> Bool
dumpIdInfoOfProgram :: Bool -> (IdInfo -> SDoc) -> CoreProgram -> SDoc


-- | Hides away distracting bookkeeping while lambda lifting into a
--   <a>LiftM</a> monad.
module GHC.Stg.Lift.Monad

-- | <pre>
--   uncurry <a>mkStgBinding</a> . <a>decomposeStgBinding</a> = id
--   </pre>
decomposeStgBinding :: GenStgBinding pass -> (RecFlag, [(BinderP pass, GenStgRhs pass)])
mkStgBinding :: RecFlag -> [(BinderP pass, GenStgRhs pass)] -> GenStgBinding pass

-- | Environment threaded around in a scoped, <tt>Reader</tt>-like fashion.
data Env
Env :: StgLiftConfig -> !Subst -> !IdEnv DIdSet -> Env

-- | Read-only.
[e_config] :: Env -> StgLiftConfig

-- | We need to track the renamings of local <a>InId</a>s to their lifted
--   <a>OutId</a>, because shadowing might make a closure's free variables
--   unavailable at its call sites. Consider: <tt> let f y = x + y in let x
--   = 4 in f x </tt> Here, <tt>f</tt> can't be lifted to top-level,
--   because its free variable <tt>x</tt> isn't available at its call site.
[e_subst] :: Env -> !Subst

-- | Lifted <a>Id</a>s don't occur as free variables in any closure
--   anymore, because they are bound at the top-level. Every occurrence
--   must supply the formerly free variables of the lifted <a>Id</a>, so
--   they in turn become free variables of the call sites. This environment
--   tracks this expansion from lifted <a>Id</a>s to their free variables.
--   
--   <a>InId</a>s to <a>OutId</a>s.
--   
--   Invariant: <a>Id</a>s not present in this map won't be substituted.
[e_expansions] :: Env -> !IdEnv DIdSet

-- | We need to detect when we are lifting something out of the RHS of a
--   recursive binding (c.f. <a>GHC.Stg.Lift.Monad#floats</a>), in which
--   case that binding needs to be added to the same top-level recursive
--   group. This requires we detect a certain nesting structure, which is
--   encoded by <a>StartBindingGroup</a> and <a>EndBindingGroup</a>.
--   
--   Although <a>collectFloats</a> will only ever care if the current
--   binding to be lifted (through <a>LiftedBinding</a>) will occur inside
--   such a binding group or not, e.g. doesn't care about the nesting level
--   as long as its greater than 0.
data FloatLang
StartBindingGroup :: FloatLang
EndBindingGroup :: FloatLang
PlainTopBinding :: OutStgTopBinding -> FloatLang
LiftedBinding :: OutStgBinding -> FloatLang

-- | Flattens an expression in <tt>[<a>FloatLang</a>]</tt> into an STG
--   program, see <a>GHC.Stg.Lift.Monad#floats</a>. Important
--   pre-conditions: The nesting of opening <tt>StartBindinGroup</tt>s and
--   closing <tt>EndBindinGroup</tt>s is balanced. Also, it is crucial that
--   every binding group has at least one recursive binding inside.
--   Otherwise there's no point in announcing the binding group in the
--   first place and an <tt>ASSERT</tt> will trigger.
collectFloats :: [FloatLang] -> [OutStgTopBinding]

-- | The analysis monad consists of the following <a>RWST</a> components:
--   
--   <ul>
--   <li><a>Env</a>: Reader-like context. Contains a substitution, info
--   about how how lifted identifiers are to be expanded into applications
--   and configuration options.</li>
--   <li><tt><a>OrdList</a> <a>FloatLang</a></tt>: Writer output for the
--   resulting STG program.</li>
--   <li>No pure state component</li>
--   <li>But wrapping around <a>UniqSM</a> for generating fresh lifted
--   binders. (The <tt>uniqAway</tt> approach could give the same name to
--   two different lifted binders, so this is necessary.)</li>
--   </ul>
data LiftM a
runLiftM :: StgLiftConfig -> UniqSupply -> LiftM () -> [OutStgTopBinding]
getConfig :: LiftM StgLiftConfig

-- | Starts a recursive binding group. See <a>GHC.Stg.Lift.Monad#floats</a>
--   and <a>collectFloats</a>.
startBindingGroup :: LiftM ()

-- | Ends a recursive binding group. See <a>GHC.Stg.Lift.Monad#floats</a>
--   and <a>collectFloats</a>.
endBindingGroup :: LiftM ()

-- | Writes a plain <a>StgTopStringLit</a> to the output.
addTopStringLit :: OutId -> ByteString -> LiftM ()

-- | Lifts a binding to top-level. Depending on whether it's declared
--   inside a recursive RHS (see <a>GHC.Stg.Lift.Monad#floats</a> and
--   <a>collectFloats</a>), this might be added to an existing recursive
--   top-level binding group.
addLiftedBinding :: OutStgBinding -> LiftM ()

-- | Takes a binder and a continuation which is called with the substituted
--   binder. The continuation will be evaluated in a <a>LiftM</a> context
--   in which that binder is deemed in scope. Think of it as a <a>local</a>
--   computation: After the continuation finishes, the new binding won't be
--   in scope anymore.
withSubstBndr :: Id -> (Id -> LiftM a) -> LiftM a

-- | See <a>withSubstBndr</a>.
withSubstBndrs :: Traversable f => f Id -> (f Id -> LiftM a) -> LiftM a

-- | Similarly to <a>withSubstBndr</a>, this function takes a set of
--   variables to abstract over, the binder to lift (and generate a fresh,
--   substituted name for) and a continuation in which that fresh, lifted
--   binder is in scope.
--   
--   It takes care of all the details involved with copying and adjusting
--   the binder and fresh name generation.
withLiftedBndr :: DIdSet -> Id -> (Id -> LiftM a) -> LiftM a

-- | See <a>withLiftedBndr</a>.
withLiftedBndrs :: Traversable f => DIdSet -> f Id -> (f Id -> LiftM a) -> LiftM a

-- | Substitutes a binder <i>occurrence</i>, which was brought in scope
--   earlier by <a>withSubstBndr</a> / <a>withLiftedBndr</a>.
substOcc :: Id -> LiftM Id

-- | Whether the given binding was decided to be lambda lifted.
isLifted :: InId -> LiftM Bool

-- | Returns an empty list for a binding that was not lifted and the list
--   of all local variables the binding abstracts over (so, exactly the
--   additional arguments at adjusted call sites) otherwise.
formerFreeVars :: InId -> LiftM [OutId]

-- | Creates an <i>expander function</i> for the current set of lifted
--   binders. This expander function will replace any <a>InId</a> by their
--   corresponding <a>OutId</a> and, in addition, will expand any lifted
--   binders by the former free variables it abstracts over.
liftedIdsExpander :: LiftM (DIdSet -> DIdSet)
instance GHC.Base.Monad GHC.Stg.Lift.Monad.LiftM
instance GHC.Base.Applicative GHC.Stg.Lift.Monad.LiftM
instance GHC.Base.Functor GHC.Stg.Lift.Monad.LiftM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Stg.Lift.Monad.LiftM
instance GHC.Utils.Outputable.Outputable GHC.Stg.Lift.Monad.FloatLang

module GHC.Core.Tidy
tidyExpr :: TidyEnv -> CoreExpr -> CoreExpr
tidyRules :: TidyEnv -> [CoreRule] -> [CoreRule]
tidyCbvInfoTop :: HasDebugCallStack => NameSet -> Id -> CoreExpr -> Id
tidyBndrs :: TidyEnv -> [Var] -> (TidyEnv, [Var])

module GHC.Core.Subst

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A substitution of <tt>Expr</tt>s for non-coercion <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | A set of variables that are in scope at some point.
--   
--   Note that this is a <i>superset</i> of the variables that are
--   currently in scope. See Note [The InScopeSet invariant].
--   
--   "Secrets of the Glasgow Haskell Compiler inliner" Section 3.2 provides
--   the motivation for this abstraction.
data InScopeSet

-- | De-shadowing the program is sometimes a useful pre-pass. It can be
--   done simply by running over the bindings with an empty substitution,
--   because substitution returns a result that has no-shadowing
--   guaranteed.
--   
--   (Actually, within a single <i>type</i> there might still be shadowing,
--   because <tt>substTy</tt> is a no-op for the empty substitution, but
--   that's probably OK.)
--   
--   <ul>
--   <li><i>Aug 09</i> This function is not used in GHC at the moment, but
--   seems so short and simple that I'm going to leave it here</li>
--   </ul>
deShadowBinds :: CoreProgram -> CoreProgram

-- | Substitutes for the <a>Id</a>s within the <a>RuleInfo</a> given the
--   new function <a>Id</a>
substRuleInfo :: Subst -> Id -> RuleInfo -> RuleInfo
substRulesForImportedIds :: Subst -> [CoreRule] -> [CoreRule]

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | substExpr applies a substitution to an entire <a>CoreExpr</a>.
--   Remember, you may only apply the substitution <i>once</i>: See Note
--   [Substitutions apply only once] in <a>GHC.Core.TyCo.Subst</a>
--   
--   Do *not* attempt to short-cut in the case of an empty substitution!
--   See Note [Extending the IdSubstEnv]
substExpr :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr
substExprSC :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBind :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBindSC :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfolding :: Subst -> Unfolding -> Unfolding

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfoldingSC :: Subst -> Unfolding -> Unfolding

-- | Find the substitution for an <a>Id</a> in the <a>Subst</a> The Id
--   should not be a CoVar
lookupIdSubst :: HasDebugCallStack => Subst -> Id -> CoreExpr
lookupIdSubst_maybe :: HasDebugCallStack => Subst -> Id -> Maybe CoreExpr
substIdType :: Subst -> Id -> Id
substIdOcc :: Subst -> Id -> Id
substTickish :: Subst -> CoreTickish -> CoreTickish
substDVarSet :: HasDebugCallStack => Subst -> DVarSet -> DVarSet

-- | Substitute into some <a>IdInfo</a> with regard to the supplied new
--   <a>Id</a>. Discards unfoldings, unless they are Stable
substIdInfo :: Subst -> Id -> IdInfo -> Maybe IdInfo
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst
mkSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> IdSubstEnv -> Subst

-- | Simultaneously substitute for a bunch of variables No left-right
--   shadowing ie the substitution for (x y. e) a1 a2 so neither x nor y
--   scope over a1 a2
mkOpenSubst :: InScopeSet -> [(Var, CoreArg)] -> Subst
isEmptySubst :: Subst -> Bool

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that TyCoSubst Note [The
--   substitution invariant] holds after extending the substitution like
--   this
extendIdSubst :: Subst -> Id -> CoreExpr -> Subst

-- | Adds multiple <a>Id</a> substitutions to the <a>Subst</a>: see also
--   <a>extendIdSubst</a>
extendIdSubstList :: Subst -> [(Id, CoreExpr)] -> Subst
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst
extendIdSubstWithClone :: Subst -> Id -> Id -> Subst

-- | Add a substitution appropriate to the thing being substituted (whether
--   an expression, type, or coercion). See also <a>extendIdSubst</a>,
--   <a>extendTvSubst</a>, <a>extendCvSubst</a>
extendSubst :: Subst -> Var -> CoreArg -> Subst

-- | Add a substitution as appropriate to each of the terms being
--   substituted (whether expressions, types, or coercions). See also
--   <a>extendSubst</a>.
extendSubstList :: Subst -> [(Var, CoreArg)] -> Subst
extendSubstWithVar :: Subst -> Var -> Var -> Subst

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeSet :: Subst -> VarSet -> Subst
isInScope :: Var -> Subst -> Bool
setInScope :: Subst -> InScopeSet -> Subst

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that Note [The substitution invariant]
--   holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst

-- | Add a substitution from a <a>CoVar</a> to a <a>Coercion</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set satisfies Note
--   [The substitution invariant] after extending the substitution like
--   this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst
delBndr :: Subst -> Var -> Subst
delBndrs :: Subst -> [Var] -> Subst

-- | Remove all substitutions that might have been built up while
--   preserving the in-scope set originally called zapSubstEnv
zapSubst :: Subst -> Subst

-- | Substitutes a <a>Expr</a> for another one according to the
--   <a>Subst</a> given, returning the result and an updated <a>Subst</a>
--   that should be used by subsequent substitutions. <a>IdInfo</a> is
--   preserved by this process, although it is substituted into
--   appropriately.
substBndr :: Subst -> Var -> (Subst, Var)

-- | Applies <a>substBndr</a> to a number of <a>Expr</a>s, accumulating a
--   new <a>Subst</a> left-to-right
substBndrs :: Traversable f => Subst -> f Var -> (Subst, f Var)

-- | Substitute in a mutually recursive group of <a>Id</a>s
substRecBndrs :: Traversable f => Subst -> f Id -> (Subst, f Id)
substTyVarBndr :: HasDebugCallStack => Subst -> TyVar -> (Subst, TyVar)
substCoVarBndr :: HasDebugCallStack => Subst -> CoVar -> (Subst, CoVar)
cloneBndr :: Subst -> Unique -> Var -> (Subst, Var)
cloneBndrs :: Subst -> UniqSupply -> [Var] -> (Subst, [Var])

-- | Very similar to <a>substBndr</a>, but it always allocates a new
--   <a>Unique</a> for each variable in its output. It substitutes the
--   IdInfo though. Discards non-Stable unfoldings
cloneIdBndr :: Subst -> UniqSupply -> Id -> (Subst, Id)

-- | Applies <a>cloneIdBndr</a> to a number of <a>Id</a>s, accumulating a
--   final substitution from left to right Discards non-Stable unfoldings
cloneIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])

-- | Clone a mutually recursive group of <a>Id</a>s
cloneRecIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])

module GHC.Core.Opt.StaticArgs
doStaticArgs :: UniqSupply -> CoreProgram -> CoreProgram

module GHC.Core.Opt.Exitify

-- | Traverses the AST, simply to find all joinrecs and call
--   <tt>exitify</tt> on them. The really interesting function is
--   exitifyRec
exitifyProgram :: CoreProgram -> CoreProgram

module GHC.Core.Opt.CSE
cseProgram :: CoreProgram -> CoreProgram

-- | Runs CSE on a single expression.
--   
--   This entry point is not used in the compiler itself, but is provided
--   as a convenient entry point for users of the GHC API.
cseOneExpr :: InExpr -> OutExpr


-- | Arity and eta expansion
module GHC.Core.Opt.Arity

-- | manifestArity sees how many leading value lambdas there are, after
--   looking through casts
manifestArity :: CoreExpr -> Arity
joinRhsArity :: CoreExpr -> JoinArity

-- | An approximate, even faster, version of <a>cheapArityType</a> Roughly
--   exprArity e = arityTypeArity (cheapArityType e) But it's a bit less
--   clever about bottoms
--   
--   We do <i>not</i> guarantee that exprArity e &lt;= typeArity e You may
--   need to do arity trimming after calling exprArity See Note [Arity
--   trimming] Reason: if we do arity trimming here we have take exprType
--   and that can be expensive if there is a large cast
exprArity :: CoreExpr -> Arity
findRhsArity :: ArityOpts -> RecFlag -> Id -> CoreExpr -> (Bool, SafeArityType)
cheapArityType :: HasDebugCallStack => CoreExpr -> ArityType
data ArityOpts
ArityOpts :: !Bool -> !Bool -> ArityOpts
[ao_ped_bot] :: ArityOpts -> !Bool
[ao_dicts_cheap] :: ArityOpts -> !Bool

-- | The Arity returned is the number of value args the expression can be
--   applied to without doing much work
exprEtaExpandArity :: HasDebugCallStack => ArityOpts -> CoreExpr -> Maybe SafeArityType

-- | <tt>etaExpand n e</tt> returns an expression with the same meaning as
--   <tt>e</tt>, but with arity <tt>n</tt>.
--   
--   Given:
--   
--   <pre>
--   e' = etaExpand n e
--   </pre>
--   
--   We should have that:
--   
--   <pre>
--   ty = exprType e = exprType e'
--   </pre>
etaExpand :: Arity -> CoreExpr -> CoreExpr
etaExpandAT :: InScopeSet -> SafeArityType -> CoreExpr -> CoreExpr

-- | `tryEtaReduce [x,y,z] e sd` returns `Just e'` if `x y z -&gt; e` is
--   evaluated according to <tt>sd</tt> and can soundly and gainfully be
--   eta-reduced to <tt>e'</tt>. See Note [Eta reduction soundness] and
--   Note [Eta reduction makes sense] when that is the case.
tryEtaReduce :: UnVarSet -> [Var] -> CoreExpr -> SubDemand -> Maybe CoreExpr

-- | The analysis lattice of arity analysis. It is isomorphic to
--   
--   <pre>
--   data ArityType'
--     = AEnd Divergence
--     | ALam OneShotInfo ArityType'
--   </pre>
--   
--   Which is easier to display the Hasse diagram for:
--   
--   <pre>
--   ALam OneShotLam at
--           |
--       AEnd topDiv
--           |
--   ALam NoOneShotInfo at
--           |
--       AEnd exnDiv
--           |
--       AEnd botDiv
--   </pre>
--   
--   where the <tt>at</tt> fields of <tt>ALam</tt> are inductively subject
--   to the same order. That is, <tt>ALam os at1 &lt; ALam os at2</tt> iff
--   <tt>at1 &lt; at2</tt>.
--   
--   Why the strange Top element? See Note [Combining case branches:
--   optimistic one-shot-ness]
--   
--   We rely on this lattice structure for fixed-point iteration in
--   <a>findRhsArity</a>. For the semantics of <a>ArityType</a>, see Note
--   [ArityType].
data ArityType
mkBotArityType :: [OneShotInfo] -> ArityType

-- | The number of value args for the arity type
arityTypeArity :: SafeArityType -> Arity
idArityType :: Id -> ArityType
exprIsDeadEnd :: CoreExpr -> Bool
exprBotStrictness_maybe :: CoreExpr -> Maybe (Arity, DmdSig, CprSig)
arityTypeBotSigs_maybe :: ArityType -> Maybe (Arity, DmdSig, CprSig)

-- | (typeArity ty) says how many arrows GHC can expose in <tt>ty</tt>,
--   after looking through newtypes. More generally, (typeOneShots ty)
--   returns ty's [OneShotInfo], based only on the type itself, using
--   typeOneShot on the argument type to access the "state hack".
typeArity :: Type -> Arity
typeOneShots :: Type -> [OneShotInfo]
typeOneShot :: Type -> OneShotInfo

-- | Returns whether the lambda associated with the <a>Id</a> is certainly
--   applied at most once This one is the "business end", called
--   externally. It works on type variables as well as Ids, returning True
--   Its main purpose is to encapsulate the Horrible State Hack See Note
--   [The state-transformer hack] in <a>GHC.Core.Opt.Arity</a>
isOneShotBndr :: Var -> Bool
isStateHackType :: Type -> Bool
zapLamBndrs :: FullArgCount -> [Var] -> [Var]

-- | Split an expression into the given number of binders and a body,
--   eta-expanding if necessary. Counts value *and* type binders.
etaExpandToJoinPoint :: JoinArity -> CoreExpr -> ([CoreBndr], CoreExpr)
etaExpandToJoinPointRule :: JoinArity -> CoreRule -> CoreRule
pushCoArg :: CoercionR -> CoreArg -> Maybe (CoreArg, MCoercion)
pushCoArgs :: CoercionR -> [CoreArg] -> Maybe ([CoreArg], MCoercion)

-- | If <tt>pushCoValArg co = Just (co_arg, co_res)</tt>, then
--   
--   <pre>
--   (\x.body) |&gt; co  =  (\y. let { x = y |&gt; co_arg } in body) |&gt; co_res)
--   </pre>
--   
--   or, equivalently
--   
--   <pre>
--   (fun |&gt; co) arg  =  (fun (arg |&gt; co_arg)) |&gt; co_res
--   </pre>
--   
--   If the LHS is well-typed, then so is the RHS. In particular, the
--   argument <tt>arg |&gt; co_arg</tt> is guaranteed to have a fixed
--   <tt>RuntimeRep</tt>, in the sense of Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete.
pushCoValArg :: CoercionR -> Maybe (MCoercionR, MCoercionR)
pushCoTyArg :: CoercionR -> Type -> Maybe (Type, MCoercionR)
pushCoercionIntoLambda :: HasDebugCallStack => InScopeSet -> Var -> CoreExpr -> CoercionR -> Maybe (Var, CoreExpr)
pushCoDataCon :: DataCon -> [CoreExpr] -> Coercion -> Maybe (DataCon, [Type], [CoreExpr])
collectBindersPushingCo :: CoreExpr -> ([Var], CoreExpr)
instance GHC.Classes.Eq GHC.Core.Opt.Arity.Cost
instance GHC.Classes.Eq GHC.Core.Opt.Arity.ArityType
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Arity.EtaInfo
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Arity.ArityEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Arity.ArityType

module GHC.Core.Opt.OccurAnal
occurAnalysePgm :: Module -> (Id -> Bool) -> (Activation -> Bool) -> [CoreRule] -> CoreProgram -> CoreProgram

-- | Do occurrence analysis, and discard occurrence info returned
occurAnalyseExpr :: CoreExpr -> CoreExpr
zapLambdaBndrs :: CoreExpr -> FullArgCount -> CoreExpr
scrutBinderSwap_maybe :: OutExpr -> Maybe (OutVar, MCoercion)
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.Details
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.UsageDetails
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.OccurAnal.OccEncl

module GHC.Core.Opt.CallArity
callArityAnalProgram :: CoreProgram -> CoreProgram
callArityRHS :: CoreExpr -> CoreExpr


-- | Handy functions for creating much Core syntax
module GHC.Core.Make

-- | Bind a binding group over an expression, using a <tt>let</tt> or
--   <tt>case</tt> as appropriate (see
--   <a>GHC.Core#let_can_float_invariant</a>)
mkCoreLet :: CoreBind -> CoreExpr -> CoreExpr

-- | Bind a list of binding groups over an expression. The leftmost binding
--   group becomes the outermost group in the resulting expression
mkCoreLets :: [CoreBind] -> CoreExpr -> CoreExpr

-- | Construct an expression which represents the application of one
--   expression to the other
mkCoreApp :: SDoc -> CoreExpr -> CoreExpr -> CoreExpr
infixl 4 `mkCoreApp`

-- | Construct an expression which represents the application of a number
--   of expressions to another. The leftmost expression in the list is
--   applied first
mkCoreApps :: CoreExpr -> [CoreExpr] -> CoreExpr
infixl 4 `mkCoreApps`

-- | Construct an expression which represents the application of a number
--   of expressions to that of a data constructor expression. The leftmost
--   expression in the list is applied first
mkCoreConApps :: DataCon -> [CoreExpr] -> CoreExpr

-- | Create a lambda where the given expression has a number of variables
--   bound over it. The leftmost binder is that bound by the outermost
--   lambda in the result
mkCoreLams :: [CoreBndr] -> CoreExpr -> CoreExpr

-- | Make a case expression whose case binder is unused The alts and res_ty
--   should not have any occurrences of WildId
mkWildCase :: CoreExpr -> Scaled Type -> Type -> [CoreAlt] -> CoreExpr
mkIfThenElse :: CoreExpr -> CoreExpr -> CoreExpr -> CoreExpr

-- | Make a <i>wildcard binder</i>. This is typically used when you need a
--   binder that you expect to use only at a *binding* site. Do not use it
--   at occurrence sites because it has a single, fixed unique, and it's
--   very easy to get into difficulties with shadowing. That's why it is
--   used so little.
--   
--   See Note [WildCard binders] in <a>GHC.Core.Opt.Simplify.Env</a>
mkWildValBinder :: Mult -> Type -> Id
mkWildEvBinder :: PredType -> EvVar
mkSingleAltCase :: CoreExpr -> Id -> AltCon -> [Var] -> CoreExpr -> CoreExpr

-- | Sort the variables, putting type and covars first, in scoped order,
--   and then other Ids
--   
--   It is a deterministic sort, meaning it doesn't look at the values of
--   Uniques. For explanation why it's important See Note [Unique
--   Determinism] in GHC.Types.Unique.
sortQuantVars :: [Var] -> [Var]
castBottomExpr :: CoreExpr -> Type -> CoreExpr
mkLitRubbish :: Type -> Maybe CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to a <tt>Word</tt> with
--   the given value
mkWordExpr :: Platform -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given <tt>Int</tt>
mkIntExpr :: Platform -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given <tt>Int</tt>
mkIntExprInt :: Platform -> Int -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Int</tt>. Don't check that the number is in the range of the
--   target platform <tt>Int</tt>
mkUncheckedIntExpr :: Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Integer</tt>
mkIntegerExpr :: Platform -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Natural</tt>
mkNaturalExpr :: Platform -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Float</tt>
mkFloatExpr :: Float -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Double</tt>
mkDoubleExpr :: Double -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Char</tt>
mkCharExpr :: Char -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>String</tt>
mkStringExpr :: MonadThings m => String -> m CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to a string morally
--   equivalent to the given <tt>FastString</tt>
mkStringExprFS :: MonadThings m => FastString -> m CoreExpr
mkStringExprFSWith :: MkStringIds -> FastString -> CoreExpr
data MkStringIds
MkStringIds :: !Id -> !Id -> MkStringIds
[unpackCStringId] :: MkStringIds -> !Id
[unpackCStringUtf8Id] :: MkStringIds -> !Id
getMkStringIds :: Applicative m => (Name -> m Id) -> m MkStringIds
data FloatBind
FloatLet :: CoreBind -> FloatBind
FloatCase :: CoreExpr -> Id -> AltCon -> [Var] -> FloatBind
wrapFloat :: FloatBind -> CoreExpr -> CoreExpr

-- | Applies the floats from right to left. That is <tt>wrapFloats [b1, b2,
--   …, bn] u = let b1 in let b2 in … in let bn in u</tt>
wrapFloats :: [FloatBind] -> CoreExpr -> CoreExpr
floatBindings :: FloatBind -> [Var]

-- | Build the type of a small tuple that holds the specified variables
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkCoreVarTupTy :: [Id] -> Type

-- | Build a small tuple holding the specified expressions One-tuples are
--   flattened; see Note [Flattening one-tuples]
mkCoreTup :: [CoreExpr] -> CoreExpr

-- | Build a small unboxed tuple holding the specified expressions. Do not
--   include the RuntimeRep specifiers; this function calculates them for
--   you. Does <i>not</i> flatten one-tuples; see Note [Flattening
--   one-tuples]
mkCoreUnboxedTuple :: [CoreExpr] -> CoreExpr

-- | Build an unboxed sum.
--   
--   Alternative number ("alt") starts from 1.
mkCoreUnboxedSum :: Int -> Int -> [Type] -> CoreExpr -> CoreExpr

-- | Make a core tuple of the given boxity; don't flatten 1-tuples
mkCoreTupBoxity :: Boxity -> [CoreExpr] -> CoreExpr

-- | The unit expression
unitExpr :: CoreExpr

-- | Lifts a "small" constructor into a "big" constructor by recursive
--   decomposition
mkChunkified :: ([a] -> a) -> [a] -> a

-- | Split a list into lists that are small enough to have a corresponding
--   tuple arity. The sub-lists of the result all have length &lt;=
--   <a>mAX_TUPLE_SIZE</a> But there may be more than <a>mAX_TUPLE_SIZE</a>
--   sub-lists
chunkify :: [a] -> [[a]]

-- | Build a big tuple holding the specified variables One-tuples are
--   flattened; see Note [Flattening one-tuples] Arguments don't have to
--   have kind Type
mkBigCoreVarTup :: [Id] -> CoreExpr
mkBigCoreVarTupSolo :: [Id] -> CoreExpr

-- | Build the type of a big tuple that holds the specified variables
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkBigCoreVarTupTy :: [Id] -> Type

-- | Build the type of a big tuple that holds the specified type of thing
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkBigCoreTupTy :: [Type] -> Type

-- | Build a "big" tuple holding the specified expressions One-tuples are
--   flattened; see Note [Flattening one-tuples] Arguments don't have to
--   have kind Type; ones that do not are boxed This function crashes (in
--   wrapBox) if given a non-Type argument that it doesn't know how to box.
mkBigCoreTup :: [CoreExpr] -> CoreExpr

-- | <a>mkBigTupleSelectorSolo</a> is like <a>mkBigTupleSelector</a> but
--   one-tuples are NOT flattened (see Note [Flattening one-tuples])
--   
--   Builds a selector which scrutinises the given expression and extracts
--   the one name from the list given. If you want the no-shadowing rule to
--   apply, the caller is responsible for making sure that none of these
--   names are in scope.
--   
--   If there is just one <a>Id</a> in the tuple, then the selector is just
--   the identity.
--   
--   If necessary, we pattern match on a "big" tuple.
--   
--   A tuple selector is not linear in its argument. Consequently, the case
--   expression built by <a>mkBigTupleSelector</a> must consume its
--   scrutinee <tt>Many</tt> times. And all the argument variables must
--   have multiplicity <tt>Many</tt>.
mkBigTupleSelector :: [Id] -> Id -> Id -> CoreExpr -> CoreExpr

-- | Builds a selector which scrutinises the given expression and extracts
--   the one name from the list given. If you want the no-shadowing rule to
--   apply, the caller is responsible for making sure that none of these
--   names are in scope.
--   
--   If there is just one <a>Id</a> in the tuple, then the selector is just
--   the identity.
--   
--   If necessary, we pattern match on a "big" tuple.
--   
--   A tuple selector is not linear in its argument. Consequently, the case
--   expression built by <a>mkBigTupleSelector</a> must consume its
--   scrutinee <tt>Many</tt> times. And all the argument variables must
--   have multiplicity <tt>Many</tt>.
mkBigTupleSelectorSolo :: [Id] -> Id -> Id -> CoreExpr -> CoreExpr

-- | A generalization of <a>mkBigTupleSelector</a>, allowing the body of
--   the case to be an arbitrary expression.
--   
--   To avoid shadowing, we use uniques to invent new variables.
--   
--   If necessary we pattern match on a "big" tuple.
mkBigTupleCase :: UniqSupply -> [Id] -> CoreExpr -> CoreExpr -> CoreExpr

-- | Makes a list <tt>[]</tt> for lists of the specified type
mkNilExpr :: Type -> CoreExpr

-- | Makes a list <tt>(:)</tt> for lists of the specified type
mkConsExpr :: Type -> CoreExpr -> CoreExpr -> CoreExpr

-- | Make a list containing the given expressions, where the list has the
--   given type
mkListExpr :: Type -> [CoreExpr] -> CoreExpr

-- | Make a fully applied <a>foldr</a> expression
mkFoldrExpr :: MonadThings m => Type -> Type -> CoreExpr -> CoreExpr -> CoreExpr -> m CoreExpr

-- | Make a <tt>build</tt> expression applied to a locally-bound worker
--   function
mkBuildExpr :: (MonadFail m, MonadThings m, MonadUnique m) => Type -> ((Id, Type) -> (Id, Type) -> m CoreExpr) -> m CoreExpr

-- | Makes a Nothing for the specified type
mkNothingExpr :: Type -> CoreExpr

-- | Makes a Just from a value of the specified type
mkJustExpr :: Type -> CoreExpr -> CoreExpr
mkRuntimeErrorApp :: Id -> Type -> String -> CoreExpr
mkImpossibleExpr :: Type -> String -> CoreExpr
mkAbsentErrorApp :: Type -> String -> CoreExpr
errorIds :: [Id]
rEC_CON_ERROR_ID :: Id
nON_EXHAUSTIVE_GUARDS_ERROR_ID :: Id
nO_METHOD_BINDING_ERROR_ID :: Id
pAT_ERROR_ID :: Id
rEC_SEL_ERROR_ID :: Id
tYPE_ERROR_ID :: Id
aBSENT_SUM_FIELD_ERROR_ID :: Id
instance GHC.Utils.Outputable.Outputable GHC.Core.Make.FloatBind

module GHC.Core.Opt.FloatIn
floatInwards :: Platform -> CoreProgram -> CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.FloatIn.FloatInBind

module GHC.Core.Unfold

-- | Records the <i>unfolding</i> of an identifier, which is approximately
--   the form the identifier would have if we substituted its definition in
--   for the identifier. This type should be treated as abstract everywhere
--   except in <a>GHC.Core.Unfold</a>
data Unfolding

-- | <a>UnfoldingGuidance</a> says when unfolding should take place
data UnfoldingGuidance

-- | Unfolding options
data UnfoldingOpts
UnfoldingOpts :: !Int -> !Int -> !Int -> !Int -> !Bool -> !Int -> !Int -> !Maybe String -> UnfoldingOpts

-- | Threshold above which unfoldings are not *created*
[unfoldingCreationThreshold] :: UnfoldingOpts -> !Int

-- | Threshold above which unfoldings are not *inlined*
[unfoldingUseThreshold] :: UnfoldingOpts -> !Int

-- | Discount for lambdas that are used (applied)
[unfoldingFunAppDiscount] :: UnfoldingOpts -> !Int

-- | Discount for dictionaries
[unfoldingDictDiscount] :: UnfoldingOpts -> !Int

-- | Force inlining in many more cases
[unfoldingVeryAggressive] :: UnfoldingOpts -> !Bool

-- | Don't consider depth up to x
[unfoldingCaseThreshold] :: UnfoldingOpts -> !Int

-- | Penalize depth with 1/x
[unfoldingCaseScaling] :: UnfoldingOpts -> !Int

-- | Only report inlining decisions for names with this prefix
[unfoldingReportPrefix] :: UnfoldingOpts -> !Maybe String
defaultUnfoldingOpts :: UnfoldingOpts
updateCreationThreshold :: Int -> UnfoldingOpts -> UnfoldingOpts
updateUseThreshold :: Int -> UnfoldingOpts -> UnfoldingOpts
updateFunAppDiscount :: Int -> UnfoldingOpts -> UnfoldingOpts
updateDictDiscount :: Int -> UnfoldingOpts -> UnfoldingOpts
updateVeryAggressive :: Bool -> UnfoldingOpts -> UnfoldingOpts
updateCaseScaling :: Int -> UnfoldingOpts -> UnfoldingOpts
updateCaseThreshold :: Int -> UnfoldingOpts -> UnfoldingOpts
updateReportPrefix :: Maybe String -> UnfoldingOpts -> UnfoldingOpts
data ArgSummary
TrivArg :: ArgSummary
NonTrivArg :: ArgSummary
ValueArg :: ArgSummary
couldBeSmallEnoughToInline :: UnfoldingOpts -> Int -> CoreExpr -> Bool
inlineBoringOk :: CoreExpr -> Bool
smallEnoughToInline :: UnfoldingOpts -> Unfolding -> Bool
callSiteInline :: Logger -> UnfoldingOpts -> Int -> Id -> Bool -> Bool -> [ArgSummary] -> CallCtxt -> Maybe CoreExpr
data CallCtxt
BoringCtxt :: CallCtxt
RhsCtxt :: RecFlag -> CallCtxt
DiscArgCtxt :: CallCtxt
RuleArgCtxt :: CallCtxt
ValAppCtxt :: CallCtxt
CaseCtxt :: CallCtxt
calcUnfoldingGuidance :: UnfoldingOpts -> Bool -> CoreExpr -> UnfoldingGuidance
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfold.CallCtxt
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfold.ArgSummary
instance GHC.Utils.Outputable.Outputable GHC.Core.Unfold.ExprSize


-- | Dynamic flags
--   
--   Most flags are dynamic flags, which means they can change from
--   compilation to compilation using <tt>OPTIONS_GHC</tt> pragmas, and in
--   a multi-session GHC each session can be using different dynamic flags.
--   Dynamic flags can also be set at the prompt in GHCi.
--   
--   (c) The University of Glasgow 2005
module GHC.Driver.Session

-- | Debugging flags
data DumpFlag
Opt_D_dump_cmm :: DumpFlag
Opt_D_dump_cmm_from_stg :: DumpFlag
Opt_D_dump_cmm_raw :: DumpFlag
Opt_D_dump_cmm_verbose_by_proc :: DumpFlag
Opt_D_dump_cmm_verbose :: DumpFlag
Opt_D_dump_cmm_cfg :: DumpFlag
Opt_D_dump_cmm_cbe :: DumpFlag
Opt_D_dump_cmm_switch :: DumpFlag
Opt_D_dump_cmm_proc :: DumpFlag
Opt_D_dump_cmm_sp :: DumpFlag
Opt_D_dump_cmm_sink :: DumpFlag
Opt_D_dump_cmm_caf :: DumpFlag
Opt_D_dump_cmm_procmap :: DumpFlag
Opt_D_dump_cmm_split :: DumpFlag
Opt_D_dump_cmm_info :: DumpFlag
Opt_D_dump_cmm_cps :: DumpFlag
Opt_D_dump_cmm_thread_sanitizer :: DumpFlag

-- | Dump the cfg used for block layout.
Opt_D_dump_cfg_weights :: DumpFlag
Opt_D_dump_asm :: DumpFlag
Opt_D_dump_asm_native :: DumpFlag
Opt_D_dump_asm_liveness :: DumpFlag
Opt_D_dump_asm_regalloc :: DumpFlag
Opt_D_dump_asm_regalloc_stages :: DumpFlag
Opt_D_dump_asm_conflicts :: DumpFlag
Opt_D_dump_asm_stats :: DumpFlag
Opt_D_dump_c_backend :: DumpFlag
Opt_D_dump_llvm :: DumpFlag
Opt_D_dump_js :: DumpFlag
Opt_D_dump_core_stats :: DumpFlag
Opt_D_dump_deriv :: DumpFlag
Opt_D_dump_ds :: DumpFlag
Opt_D_dump_ds_preopt :: DumpFlag
Opt_D_dump_foreign :: DumpFlag
Opt_D_dump_inlinings :: DumpFlag
Opt_D_dump_verbose_inlinings :: DumpFlag
Opt_D_dump_rule_firings :: DumpFlag
Opt_D_dump_rule_rewrites :: DumpFlag
Opt_D_dump_simpl_trace :: DumpFlag
Opt_D_dump_occur_anal :: DumpFlag
Opt_D_dump_parsed :: DumpFlag
Opt_D_dump_parsed_ast :: DumpFlag
Opt_D_dump_rn :: DumpFlag
Opt_D_dump_rn_ast :: DumpFlag
Opt_D_dump_simpl :: DumpFlag
Opt_D_dump_simpl_iterations :: DumpFlag
Opt_D_dump_spec :: DumpFlag
Opt_D_dump_prep :: DumpFlag
Opt_D_dump_late_cc :: DumpFlag

-- | Initial STG (CoreToStg output)
Opt_D_dump_stg_from_core :: DumpFlag

-- | STG after unarise
Opt_D_dump_stg_unarised :: DumpFlag

-- | STG (after stg2stg)
Opt_D_dump_stg_cg :: DumpFlag

-- | Result of tag inference analysis.
Opt_D_dump_stg_tags :: DumpFlag

-- | Final STG (before cmm gen)
Opt_D_dump_stg_final :: DumpFlag
Opt_D_dump_call_arity :: DumpFlag
Opt_D_dump_exitify :: DumpFlag
Opt_D_dump_stranal :: DumpFlag
Opt_D_dump_str_signatures :: DumpFlag
Opt_D_dump_cpranal :: DumpFlag
Opt_D_dump_cpr_signatures :: DumpFlag
Opt_D_dump_tc :: DumpFlag
Opt_D_dump_tc_ast :: DumpFlag
Opt_D_dump_hie :: DumpFlag
Opt_D_dump_types :: DumpFlag
Opt_D_dump_rules :: DumpFlag
Opt_D_dump_cse :: DumpFlag
Opt_D_dump_worker_wrapper :: DumpFlag
Opt_D_dump_rn_trace :: DumpFlag
Opt_D_dump_rn_stats :: DumpFlag
Opt_D_dump_opt_cmm :: DumpFlag
Opt_D_dump_simpl_stats :: DumpFlag
Opt_D_dump_cs_trace :: DumpFlag
Opt_D_dump_tc_trace :: DumpFlag
Opt_D_dump_ec_trace :: DumpFlag
Opt_D_dump_if_trace :: DumpFlag
Opt_D_dump_splices :: DumpFlag
Opt_D_th_dec_file :: DumpFlag
Opt_D_dump_BCOs :: DumpFlag
Opt_D_dump_ticked :: DumpFlag
Opt_D_dump_rtti :: DumpFlag
Opt_D_source_stats :: DumpFlag
Opt_D_verbose_stg2stg :: DumpFlag
Opt_D_dump_hi :: DumpFlag
Opt_D_dump_hi_diffs :: DumpFlag
Opt_D_dump_mod_cycles :: DumpFlag
Opt_D_dump_mod_map :: DumpFlag
Opt_D_dump_timings :: DumpFlag
Opt_D_dump_view_pattern_commoning :: DumpFlag
Opt_D_verbose_core2core :: DumpFlag
Opt_D_dump_debug :: DumpFlag
Opt_D_dump_json :: DumpFlag
Opt_D_ppr_debug :: DumpFlag
Opt_D_no_debug_output :: DumpFlag
Opt_D_dump_faststrings :: DumpFlag
Opt_D_faststring_stats :: DumpFlag
Opt_D_ipe_stats :: DumpFlag

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag

-- | Use foo.ways.<a>dumpFlag</a> instead of foo.<a>dumpFlag</a>
Opt_DumpWithWays :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoLinearCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_DoBoundsChecking :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_NoTypeableBinds :: GeneralFlag
Opt_DistinctConstructorTables :: GeneralFlag
Opt_InfoTableMap :: GeneralFlag
Opt_InfoTableMapWithFallback :: GeneralFlag
Opt_InfoTableMapWithStack :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintAxiomIncomps :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintRedundantPromotionTicks :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag

-- | Enable floating out of let-bindings in the simplifier
Opt_LocalFloatOut :: GeneralFlag

-- | Enable floating out of let-bindings at the top level in the simplifier
--   N.B. See Note [RHS Floating]
Opt_LocalFloatOutTopLevel :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_PolymorphicSpecialisation :: GeneralFlag
Opt_InlineGenerics :: GeneralFlag
Opt_InlineGenericsAggressively :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_EnableThSpliceWarnings :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmTBAA :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmStaticPred :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_CmmControlFlow :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag

-- | deprecated, no effect and behaviour is now default. Allowed switching
--   of a special demand transformer for dictionary selectors
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag

-- | Do W/W split for unlifting even if we won't unbox anything.
Opt_WorkerWrapperUnlift :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchNonexhaustiveCases :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_CoreConstantFolding :: GeneralFlag
Opt_FastPAPCalls :: GeneralFlag
Opt_SpecEval :: GeneralFlag
Opt_SpecEvalDictFun :: GeneralFlag
Opt_DoTagInferenceChecks :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_ProfLateInlineCcs :: GeneralFlag
Opt_ProfLateCcs :: GeneralFlag

-- | Ignore manual SCC annotations
Opt_ProfManualCcs :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_Ticky_Tag :: GeneralFlag

-- | Use regular thunks even when we could use std ap thunks in order to
--   get entry counts
Opt_Ticky_AP :: GeneralFlag
Opt_CmmThreadSanitizer :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag

-- | <pre>
--   -fcompact-unwind
--   </pre>
Opt_CompactUnwind :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FamAppCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_ExposeInternalSymbols :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_KeepGoing :: GeneralFlag
Opt_ByteCode :: GeneralFlag
Opt_ByteCodeAndObjectCode :: GeneralFlag
Opt_LinkRts :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DeferDiagnostics :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressCoercionTypes :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressStgReps :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag

-- | Suppress per binding Core size stats in dumps
Opt_SuppressCoreSizes :: GeneralFlag
Opt_ShowErrorContext :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_WriteIfSimplifiedCore :: GeneralFlag
Opt_UseBytecodeRatherThanObjects :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_PluginTrustworthy :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag
data WarningFlag
Opt_WarnDuplicateExports :: WarningFlag
Opt_WarnDuplicateConstraints :: WarningFlag
Opt_WarnRedundantConstraints :: WarningFlag
Opt_WarnHiShadows :: WarningFlag
Opt_WarnImplicitPrelude :: WarningFlag
Opt_WarnIncompletePatterns :: WarningFlag
Opt_WarnIncompleteUniPatterns :: WarningFlag
Opt_WarnIncompletePatternsRecUpd :: WarningFlag
Opt_WarnOverflowedLiterals :: WarningFlag
Opt_WarnEmptyEnumerations :: WarningFlag
Opt_WarnMissingFields :: WarningFlag
Opt_WarnMissingImportList :: WarningFlag
Opt_WarnMissingMethods :: WarningFlag
Opt_WarnMissingSignatures :: WarningFlag
Opt_WarnMissingLocalSignatures :: WarningFlag
Opt_WarnNameShadowing :: WarningFlag
Opt_WarnOverlappingPatterns :: WarningFlag
Opt_WarnTypeDefaults :: WarningFlag
Opt_WarnMonomorphism :: WarningFlag
Opt_WarnUnusedTopBinds :: WarningFlag
Opt_WarnUnusedLocalBinds :: WarningFlag
Opt_WarnUnusedPatternBinds :: WarningFlag
Opt_WarnUnusedImports :: WarningFlag
Opt_WarnUnusedMatches :: WarningFlag
Opt_WarnUnusedTypePatterns :: WarningFlag
Opt_WarnUnusedForalls :: WarningFlag
Opt_WarnUnusedRecordWildcards :: WarningFlag
Opt_WarnRedundantBangPatterns :: WarningFlag
Opt_WarnRedundantRecordWildcards :: WarningFlag
Opt_WarnWarningsDeprecations :: WarningFlag
Opt_WarnDeprecatedFlags :: WarningFlag
Opt_WarnMissingMonadFailInstances :: WarningFlag
Opt_WarnSemigroup :: WarningFlag
Opt_WarnDodgyExports :: WarningFlag
Opt_WarnDodgyImports :: WarningFlag
Opt_WarnOrphans :: WarningFlag
Opt_WarnAutoOrphans :: WarningFlag
Opt_WarnIdentities :: WarningFlag
Opt_WarnTabs :: WarningFlag
Opt_WarnUnrecognisedPragmas :: WarningFlag
Opt_WarnMisplacedPragmas :: WarningFlag
Opt_WarnDodgyForeignImports :: WarningFlag
Opt_WarnUnusedDoBind :: WarningFlag
Opt_WarnWrongDoBind :: WarningFlag
Opt_WarnAlternativeLayoutRuleTransitional :: WarningFlag
Opt_WarnUnsafe :: WarningFlag
Opt_WarnSafe :: WarningFlag
Opt_WarnTrustworthySafe :: WarningFlag
Opt_WarnMissedSpecs :: WarningFlag
Opt_WarnAllMissedSpecs :: WarningFlag
Opt_WarnUnsupportedCallingConventions :: WarningFlag
Opt_WarnUnsupportedLlvmVersion :: WarningFlag
Opt_WarnMissedExtraSharedLib :: WarningFlag
Opt_WarnInlineRuleShadowing :: WarningFlag
Opt_WarnTypedHoles :: WarningFlag
Opt_WarnPartialTypeSignatures :: WarningFlag
Opt_WarnMissingExportedSignatures :: WarningFlag
Opt_WarnUntickedPromotedConstructors :: WarningFlag
Opt_WarnDerivingTypeable :: WarningFlag
Opt_WarnDeferredTypeErrors :: WarningFlag
Opt_WarnDeferredOutOfScopeVariables :: WarningFlag
Opt_WarnNonCanonicalMonadInstances :: WarningFlag
Opt_WarnNonCanonicalMonadFailInstances :: WarningFlag
Opt_WarnNonCanonicalMonoidInstances :: WarningFlag
Opt_WarnMissingPatternSynonymSignatures :: WarningFlag
Opt_WarnUnrecognisedWarningFlags :: WarningFlag
Opt_WarnSimplifiableClassConstraints :: WarningFlag
Opt_WarnCPPUndef :: WarningFlag
Opt_WarnUnbangedStrictPatterns :: WarningFlag
Opt_WarnMissingHomeModules :: WarningFlag
Opt_WarnPartialFields :: WarningFlag
Opt_WarnMissingExportList :: WarningFlag
Opt_WarnInaccessibleCode :: WarningFlag
Opt_WarnStarIsType :: WarningFlag
Opt_WarnStarBinder :: WarningFlag
Opt_WarnImplicitKindVars :: WarningFlag
Opt_WarnSpaceAfterBang :: WarningFlag
Opt_WarnMissingDerivingStrategies :: WarningFlag
Opt_WarnPrepositiveQualifiedModule :: WarningFlag
Opt_WarnUnusedPackages :: WarningFlag
Opt_WarnInferredSafeImports :: WarningFlag
Opt_WarnMissingSafeHaskellMode :: WarningFlag
Opt_WarnCompatUnqualifiedImports :: WarningFlag
Opt_WarnDerivingDefaults :: WarningFlag
Opt_WarnInvalidHaddock :: WarningFlag
Opt_WarnOperatorWhitespaceExtConflict :: WarningFlag
Opt_WarnOperatorWhitespace :: WarningFlag
Opt_WarnAmbiguousFields :: WarningFlag
Opt_WarnImplicitLift :: WarningFlag
Opt_WarnMissingKindSignatures :: WarningFlag
Opt_WarnMissingExportedPatternSynonymSignatures :: WarningFlag
Opt_WarnRedundantStrictnessFlags :: WarningFlag
Opt_WarnForallIdentifier :: WarningFlag
Opt_WarnUnicodeBidirectionalFormatCharacters :: WarningFlag
Opt_WarnGADTMonoLocalBinds :: WarningFlag
Opt_WarnTypeEqualityOutOfScope :: WarningFlag
Opt_WarnTypeEqualityRequiresOperators :: WarningFlag
Opt_WarnLoopySuperclassSolve :: WarningFlag

-- | The reason <i>why</i> a <a>Diagnostic</a> was emitted in the first
--   place. Diagnostic messages are born within GHC with a very precise
--   reason, which can be completely statically-computed (i.e. this is an
--   error or a warning no matter what), or influenced by the specific
--   state of the <tt>DynFlags</tt> at the moment of the creation of a new
--   <a>Diagnostic</a>. For example, a parsing error is <i>always</i> going
--   to be an error, whereas a 'WarningWithoutFlag Opt_WarnUnusedImports'
--   might turn into an error due to '-Werror' or
--   '-Werror=warn-unused-imports'. Interpreting a <a>DiagnosticReason</a>
--   together with its associated <a>Severity</a> gives us the full
--   picture.
data DiagnosticReason

-- | Born as a warning.
WarningWithoutFlag :: DiagnosticReason

-- | Warning was enabled with the flag.
WarningWithFlag :: !WarningFlag -> DiagnosticReason

-- | Born as an error.
ErrorWithoutFlag :: DiagnosticReason
data Language
Haskell98 :: Language
Haskell2010 :: Language
GHC2021 :: Language
type FatalMessager = String -> IO ()
newtype FlushOut
FlushOut :: IO () -> FlushOut

-- | What kind of {-# SCC #-} to add automatically
data ProfAuto

-- | no SCC annotations added
NoProfAuto :: ProfAuto

-- | top-level and nested functions are annotated
ProfAutoAll :: ProfAuto

-- | top-level functions annotated only
ProfAutoTop :: ProfAuto

-- | exported functions annotated only
ProfAutoExports :: ProfAuto

-- | annotate call-sites
ProfAutoCalls :: ProfAuto
glasgowExtsFlags :: [Extension]
hasPprDebug :: DynFlags -> Bool
hasNoDebugOutput :: DynFlags -> Bool
hasNoStateHack :: DynFlags -> Bool
hasNoOptCoercion :: DynFlags -> Bool

-- | Test whether a <a>DumpFlag</a> is set
dopt :: DumpFlag -> DynFlags -> Bool

-- | Set a <a>DumpFlag</a>
dopt_set :: DynFlags -> DumpFlag -> DynFlags

-- | Unset a <a>DumpFlag</a>
dopt_unset :: DynFlags -> DumpFlag -> DynFlags

-- | Test whether a <a>GeneralFlag</a> is set
--   
--   Note that <a>dynamicNow</a> (i.e., dynamic objects built with
--   `-dynamic-too`) always implicitly enables Opt_PIC,
--   Opt_ExternalDynamicRefs, and disables Opt_SplitSections.
gopt :: GeneralFlag -> DynFlags -> Bool

-- | Set a <a>GeneralFlag</a>
gopt_set :: DynFlags -> GeneralFlag -> DynFlags

-- | Unset a <a>GeneralFlag</a>
gopt_unset :: DynFlags -> GeneralFlag -> DynFlags
setGeneralFlag' :: GeneralFlag -> DynFlags -> DynFlags
unSetGeneralFlag' :: GeneralFlag -> DynFlags -> DynFlags

-- | Test whether a <a>WarningFlag</a> is set
wopt :: WarningFlag -> DynFlags -> Bool

-- | Set a <a>WarningFlag</a>
wopt_set :: DynFlags -> WarningFlag -> DynFlags

-- | Unset a <a>WarningFlag</a>
wopt_unset :: DynFlags -> WarningFlag -> DynFlags

-- | Test whether a <a>WarningFlag</a> is set as fatal
wopt_fatal :: WarningFlag -> DynFlags -> Bool

-- | Mark a <a>WarningFlag</a> as fatal (do not set the flag)
wopt_set_fatal :: DynFlags -> WarningFlag -> DynFlags

-- | Mark a <a>WarningFlag</a> as not fatal
wopt_unset_fatal :: DynFlags -> WarningFlag -> DynFlags

-- | Test whether a <a>Extension</a> is set
xopt :: Extension -> DynFlags -> Bool

-- | Set a <a>Extension</a>
xopt_set :: DynFlags -> Extension -> DynFlags

-- | Unset a <a>Extension</a>
xopt_unset :: DynFlags -> Extension -> DynFlags

-- | Set or unset a <a>Extension</a>, unless it has been explicitly set or
--   unset before.
xopt_set_unlessExplSpec :: Extension -> (DynFlags -> Extension -> DynFlags) -> DynFlags -> DynFlags
xopt_DuplicateRecordFields :: DynFlags -> DuplicateRecordFields
xopt_FieldSelectors :: DynFlags -> FieldSelectors
lang_set :: DynFlags -> Maybe Language -> DynFlags
data DynamicTooState

-- | Don't try to build dynamic objects too
DT_Dont :: DynamicTooState

-- | Will still try to generate dynamic objects
DT_OK :: DynamicTooState

-- | Currently generating dynamic objects (in the backend)
DT_Dyn :: DynamicTooState
dynamicTooState :: DynFlags -> DynamicTooState
setDynamicNow :: DynFlags -> DynFlags

-- | Indicate if cost-centre profiling is enabled
sccProfilingEnabled :: DynFlags -> Bool

-- | Indicate whether we need to generate source notes
needSourceNotes :: DynFlags -> Bool
data OnOff a
On :: a -> OnOff a
Off :: a -> OnOff a

-- | Contains not only a collection of <a>GeneralFlag</a>s but also a
--   plethora of information relating to the compilation of a single file
--   or GHC session
data DynFlags
DynFlags :: GhcMode -> GhcLink -> !Backend -> {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> TempDir -> Int -> Int -> Int -> Int -> Int -> Maybe String -> [Int] -> Maybe Int -> Bool -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Int -> Int -> Int -> !Int -> Maybe Int -> Maybe Int -> Int -> Maybe Word -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> Maybe Int -> Int -> [FilePath] -> ModuleName -> Maybe String -> IntWithInf -> IntWithInf -> UnitId -> Maybe UnitId -> [(ModuleName, Module)] -> Maybe FilePath -> Maybe String -> Set ModuleName -> Set ModuleName -> Ways -> Maybe (String, Int) -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> String -> String -> String -> String -> String -> String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> DynLibLoader -> !Bool -> FilePath -> Maybe FilePath -> [Option] -> IncludeSpecs -> [String] -> [String] -> [String] -> Maybe String -> RtsOptsEnabled -> Bool -> String -> [ModuleName] -> [(ModuleName, String)] -> [String] -> [ExternalPluginSpec] -> FilePath -> Bool -> Bool -> [ModuleName] -> [String] -> [PackageDBFlag] -> [IgnorePackageFlag] -> [PackageFlag] -> [PackageFlag] -> [TrustFlag] -> Maybe FilePath -> EnumSet DumpFlag -> EnumSet GeneralFlag -> EnumSet WarningFlag -> EnumSet WarningFlag -> Maybe Language -> SafeHaskellMode -> Bool -> Bool -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> [OnOff Extension] -> EnumSet Extension -> !UnfoldingOpts -> Int -> Int -> FlushOut -> Maybe FilePath -> Maybe String -> [String] -> Int -> Int -> Bool -> OverridingBool -> Bool -> Scheme -> ProfAuto -> [CallerCcFilter] -> Maybe String -> Maybe SseVersion -> Maybe BmiVersion -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> IORef (Maybe LinkerInfo) -> IORef (Maybe CompilerInfo) -> IORef (Maybe CompilerInfo) -> Int -> Int -> Int -> Bool -> Maybe Int -> Word64 -> Int -> Weights -> DynFlags
[ghcMode] :: DynFlags -> GhcMode
[ghcLink] :: DynFlags -> GhcLink

-- | The backend to use (if any).
--   
--   Whenever you change the backend, also make sure to set <a>ghcLink</a>
--   to something sensible.
--   
--   <tt>NoBackend</tt> can be used to avoid generating any output,
--   however, note that:
--   
--   <ul>
--   <li>If a program uses Template Haskell the typechecker may need to run
--   code from an imported module. To facilitate this, code generation is
--   enabled for modules imported by modules that use template haskell,
--   using the default backend for the platform. See Note [-fno-code
--   mode].</li>
--   </ul>
[backend] :: DynFlags -> !Backend
[ghcNameVersion] :: DynFlags -> {-# UNPACK #-} !GhcNameVersion
[fileSettings] :: DynFlags -> {-# UNPACK #-} !FileSettings
[targetPlatform] :: DynFlags -> Platform
[toolSettings] :: DynFlags -> {-# UNPACK #-} !ToolSettings
[platformMisc] :: DynFlags -> {-# UNPACK #-} !PlatformMisc
[rawSettings] :: DynFlags -> [(String, String)]
[tmpDir] :: DynFlags -> TempDir

-- | LLVM optimisation level
[llvmOptLevel] :: DynFlags -> Int

-- | Verbosity level: see Note [Verbosity levels]
[verbosity] :: DynFlags -> Int

-- | How much debug information to produce
[debugLevel] :: DynFlags -> Int

-- | Number of simplifier phases
[simplPhases] :: DynFlags -> Int

-- | Max simplifier iterations
[maxSimplIterations] :: DynFlags -> Int
[ruleCheck] :: DynFlags -> Maybe String

-- | Additional demand analysis
[strictnessBefore] :: DynFlags -> [Int]

-- | The number of modules to compile in parallel in --make mode, where
--   Nothing ==&gt; compile as many in parallel as there are CPUs.
[parMakeCount] :: DynFlags -> Maybe Int

-- | Enable RTS timing statistics?
[enableTimeStats] :: DynFlags -> Bool

-- | The heap size to set.
[ghcHeapSize] :: DynFlags -> Maybe Int

-- | Maximum number of bindings from the type envt to show in type error
--   messages
[maxRelevantBinds] :: DynFlags -> Maybe Int

-- | Maximum number of hole fits to show in typed hole error messages
[maxValidHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of refinement hole fits to show in typed hole error
--   messages
[maxRefHoleFits] :: DynFlags -> Maybe Int

-- | Maximum level of refinement for refinement hole fits in typed hole
--   error messages
[refLevelHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of unmatched patterns to show in non-exhaustiveness
--   warnings
[maxUncoveredPatterns] :: DynFlags -> Int

-- | Soft limit on the number of models the pattern match checker checks a
--   pattern against. A safe guard against exponential blow-up.
[maxPmCheckModels] :: DynFlags -> Int

-- | Multiplier for simplifier ticks
[simplTickFactor] :: DynFlags -> Int

-- | Whether DmdAnal should optimistically put an Unboxed demand on
--   returned products with at most this number of fields
[dmdUnboxWidth] :: DynFlags -> !Int

-- | Threshold for SpecConstr
[specConstrThreshold] :: DynFlags -> Maybe Int

-- | Max number of specialisations for any one function
[specConstrCount] :: DynFlags -> Maybe Int

-- | Max number of specialisations for recursive types Not optional;
--   otherwise ForceSpecConstr can diverge.
[specConstrRecursive] :: DynFlags -> Int

-- | Binary literals (e.g. strings) whose size is above this threshold will
--   be dumped in a binary file by the assembler code generator. 0 and
--   Nothing disables this feature. See <a>Config</a>.
[binBlobThreshold] :: DynFlags -> Maybe Word

-- | Threshold for LiberateCase
[liberateCaseThreshold] :: DynFlags -> Maybe Int

-- | Arg count for lambda floating See <a>FloatOutSwitches</a>
[floatLamArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a recursive function.
[liftLamsRecArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a non-recursive
--   function.
[liftLamsNonRecArgs] :: DynFlags -> Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[liftLamsKnown] :: DynFlags -> Bool

-- | Align Cmm functions at this boundary or use default.
[cmmProcAlignment] :: DynFlags -> Maybe Int

-- | Simplification history size
[historySize] :: DynFlags -> Int
[importPaths] :: DynFlags -> [FilePath]
[mainModuleNameIs] :: DynFlags -> ModuleName
[mainFunIs] :: DynFlags -> Maybe String

-- | Typechecker maximum stack depth
[reductionDepth] :: DynFlags -> IntWithInf

-- | Number of iterations in the constraints solver Typically only 1 is
--   needed
[solverIterations] :: DynFlags -> IntWithInf

-- | Target home unit-id
[homeUnitId_] :: DynFlags -> UnitId

-- | Id of the unit to instantiate
[homeUnitInstanceOf_] :: DynFlags -> Maybe UnitId

-- | Module instantiations
[homeUnitInstantiations_] :: DynFlags -> [(ModuleName, Module)]
[workingDirectory] :: DynFlags -> Maybe FilePath

-- | What the package is called, use with multiple home units
[thisPackageName] :: DynFlags -> Maybe String
[hiddenModules] :: DynFlags -> Set ModuleName
[reexportedModules] :: DynFlags -> Set ModuleName

-- | Target way flags from the command line
[targetWays_] :: DynFlags -> Ways
[splitInfo] :: DynFlags -> Maybe (String, Int)
[objectDir] :: DynFlags -> Maybe String
[dylibInstallName] :: DynFlags -> Maybe String
[hiDir] :: DynFlags -> Maybe String
[hieDir] :: DynFlags -> Maybe String
[stubDir] :: DynFlags -> Maybe String
[dumpDir] :: DynFlags -> Maybe String
[objectSuf_] :: DynFlags -> String
[hcSuf] :: DynFlags -> String
[hiSuf_] :: DynFlags -> String
[hieSuf] :: DynFlags -> String
[dynObjectSuf_] :: DynFlags -> String
[dynHiSuf_] :: DynFlags -> String
[outputFile_] :: DynFlags -> Maybe String
[dynOutputFile_] :: DynFlags -> Maybe String
[outputHi] :: DynFlags -> Maybe String
[dynOutputHi] :: DynFlags -> Maybe String
[dynLibLoader] :: DynFlags -> DynLibLoader

-- | Indicate if we are now generating dynamic output because of
--   -dynamic-too. This predicate is used to query the appropriate fields
--   (outputFile/dynOutputFile, ways, etc.)
[dynamicNow] :: DynFlags -> !Bool

-- | This defaults to 'non-module'. It can be set by <a>setDumpPrefix</a>
--   or 'ghc.GHCi.UI.runStmt' based on where its output is going.
[dumpPrefix] :: DynFlags -> FilePath

-- | Override the <a>dumpPrefix</a> set by <a>setDumpPrefix</a> or
--   'ghc.GHCi.UI.runStmt'. Set by <tt>-ddump-file-prefix</tt>
[dumpPrefixForce] :: DynFlags -> Maybe FilePath
[ldInputs] :: DynFlags -> [Option]
[includePaths] :: DynFlags -> IncludeSpecs
[libraryPaths] :: DynFlags -> [String]
[frameworkPaths] :: DynFlags -> [String]
[cmdlineFrameworks] :: DynFlags -> [String]
[rtsOpts] :: DynFlags -> Maybe String
[rtsOptsEnabled] :: DynFlags -> RtsOptsEnabled
[rtsOptsSuggestions] :: DynFlags -> Bool

-- | Path to store the .mix files
[hpcDir] :: DynFlags -> String

-- | the <tt>-fplugin</tt> flags given on the command line, in *reverse*
--   order that they're specified on the command line.
[pluginModNames] :: DynFlags -> [ModuleName]
[pluginModNameOpts] :: DynFlags -> [(ModuleName, String)]

-- | the <tt>-ffrontend-opt</tt> flags given on the command line, in
--   *reverse* order that they're specified on the command line.
[frontendPluginOpts] :: DynFlags -> [String]

-- | External plugins loaded from shared libraries
[externalPluginSpecs] :: DynFlags -> [ExternalPluginSpec]
[depMakefile] :: DynFlags -> FilePath
[depIncludePkgDeps] :: DynFlags -> Bool
[depIncludeCppDeps] :: DynFlags -> Bool
[depExcludeMods] :: DynFlags -> [ModuleName]
[depSuffixes] :: DynFlags -> [String]

-- | The <tt>-package-db</tt> flags given on the command line, In *reverse*
--   order that they're specified on the command line. This is intended to
--   be applied with the list of "initial" package databases derived from
--   <tt>GHC_PACKAGE_PATH</tt>; see <tt>getUnitDbRefs</tt>.
[packageDBFlags] :: DynFlags -> [PackageDBFlag]

-- | The <tt>-ignore-package</tt> flags from the command line. In *reverse*
--   order that they're specified on the command line.
[ignorePackageFlags] :: DynFlags -> [IgnorePackageFlag]

-- | The <tt>-package</tt> and <tt>-hide-package</tt> flags from the
--   command-line. In *reverse* order that they're specified on the command
--   line.
[packageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-plugin-package-id</tt> flags from command line. In *reverse*
--   order that they're specified on the command line.
[pluginPackageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-trust</tt> and <tt>-distrust</tt> flags. In *reverse* order
--   that they're specified on the command line.
[trustFlags] :: DynFlags -> [TrustFlag]

-- | Filepath to the package environment file (if overriding default)
[packageEnv] :: DynFlags -> Maybe FilePath
[dumpFlags] :: DynFlags -> EnumSet DumpFlag
[generalFlags] :: DynFlags -> EnumSet GeneralFlag
[warningFlags] :: DynFlags -> EnumSet WarningFlag
[fatalWarningFlags] :: DynFlags -> EnumSet WarningFlag
[language] :: DynFlags -> Maybe Language

-- | Safe Haskell mode
[safeHaskell] :: DynFlags -> SafeHaskellMode
[safeInfer] :: DynFlags -> Bool
[safeInferred] :: DynFlags -> Bool
[thOnLoc] :: DynFlags -> SrcSpan
[newDerivOnLoc] :: DynFlags -> SrcSpan
[deriveViaOnLoc] :: DynFlags -> SrcSpan
[overlapInstLoc] :: DynFlags -> SrcSpan
[incoherentOnLoc] :: DynFlags -> SrcSpan
[pkgTrustOnLoc] :: DynFlags -> SrcSpan
[warnSafeOnLoc] :: DynFlags -> SrcSpan
[warnUnsafeOnLoc] :: DynFlags -> SrcSpan
[trustworthyOnLoc] :: DynFlags -> SrcSpan
[extensions] :: DynFlags -> [OnOff Extension]
[extensionFlags] :: DynFlags -> EnumSet Extension

-- | Unfolding control See Note [Discounts and thresholds] in
--   GHC.Core.Unfold
[unfoldingOpts] :: DynFlags -> !UnfoldingOpts
[maxWorkerArgs] :: DynFlags -> Int
[ghciHistSize] :: DynFlags -> Int
[flushOut] :: DynFlags -> FlushOut
[ghcVersionFile] :: DynFlags -> Maybe FilePath
[haddockOptions] :: DynFlags -> Maybe String

-- | GHCi scripts specified by -ghci-script, in reverse order
[ghciScripts] :: DynFlags -> [String]
[pprUserLength] :: DynFlags -> Int
[pprCols] :: DynFlags -> Int
[useUnicode] :: DynFlags -> Bool
[useColor] :: DynFlags -> OverridingBool
[canUseColor] :: DynFlags -> Bool
[colScheme] :: DynFlags -> Scheme

-- | what kind of {-# SCC #-} to add automatically
[profAuto] :: DynFlags -> ProfAuto
[callerCcFilters] :: DynFlags -> [CallerCcFilter]
[interactivePrint] :: DynFlags -> Maybe String

-- | Machine dependent flags (-m&lt;blah&gt; stuff)
[sseVersion] :: DynFlags -> Maybe SseVersion
[bmiVersion] :: DynFlags -> Maybe BmiVersion
[avx] :: DynFlags -> Bool
[avx2] :: DynFlags -> Bool
[avx512cd] :: DynFlags -> Bool
[avx512er] :: DynFlags -> Bool
[avx512f] :: DynFlags -> Bool
[avx512pf] :: DynFlags -> Bool

-- | Run-time linker information (what options we need, etc.)
[rtldInfo] :: DynFlags -> IORef (Maybe LinkerInfo)

-- | Run-time C compiler information
[rtccInfo] :: DynFlags -> IORef (Maybe CompilerInfo)

-- | Run-time assembler information
[rtasmInfo] :: DynFlags -> IORef (Maybe CompilerInfo)

-- | Max size, in bytes, of inline array allocations.
[maxInlineAllocSize] :: DynFlags -> Int

-- | Only inline memcpy if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemcpyInsns] :: DynFlags -> Int

-- | Only inline memset if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemsetInsns] :: DynFlags -> Int

-- | Reverse the order of error messages in GHC/GHCi
[reverseErrors] :: DynFlags -> Bool

-- | Limit the maximum number of errors to show
[maxErrors] :: DynFlags -> Maybe Int

-- | Unique supply configuration for testing build determinism
[initialUnique] :: DynFlags -> Word64
[uniqueIncrement] :: DynFlags -> Int

-- | Temporary: CFG Edge weights for fast iterations
[cfgWeights] :: DynFlags -> Weights
outputFile :: DynFlags -> Maybe String
objectSuf :: DynFlags -> String
ways :: DynFlags -> Ways
data FlagSpec flag
FlagSpec :: String -> flag -> (TurnOnFlag -> DynP ()) -> GhcFlagMode -> FlagSpec flag

-- | Flag in string form
[flagSpecName] :: FlagSpec flag -> String

-- | Flag in internal form
[flagSpecFlag] :: FlagSpec flag -> flag

-- | Extra action to run when the flag is found Typically, emit a warning
--   or error
[flagSpecAction] :: FlagSpec flag -> TurnOnFlag -> DynP ()

-- | In which ghc mode the flag has effect
[flagSpecGhcMode] :: FlagSpec flag -> GhcFlagMode
class HasDynFlags m
getDynFlags :: HasDynFlags m => m DynFlags
class ContainsDynFlags t
extractDynFlags :: ContainsDynFlags t => t -> DynFlags
data RtsOptsEnabled
RtsOptsNone :: RtsOptsEnabled
RtsOptsIgnore :: RtsOptsEnabled
RtsOptsIgnoreAll :: RtsOptsEnabled
RtsOptsSafeOnly :: RtsOptsEnabled
RtsOptsAll :: RtsOptsEnabled

-- | The <a>GhcMode</a> tells us whether we're doing multi-module
--   compilation (controlled via the <a>GHC</a> API) or one-shot
--   (single-module) compilation. This makes a difference primarily to the
--   <a>GHC.Unit.Finder</a>: in one-shot mode we look for interface files
--   for imported modules, but in multi-module mode we look for source
--   files in order to check whether they need to be recompiled.
data GhcMode

-- | <tt>--make</tt>, GHCi, etc.
CompManager :: GhcMode

-- | <pre>
--   ghc -c Foo.hs
--   </pre>
OneShot :: GhcMode

-- | <tt>ghc -M</tt>, see <a>GHC.Unit.Finder</a> for why we need this
MkDepend :: GhcMode
isOneShot :: GhcMode -> Bool

-- | What to do in the link step, if there is one.
data GhcLink

-- | Don't link at all
NoLink :: GhcLink

-- | Link object code into a binary
LinkBinary :: GhcLink

-- | Use the in-memory dynamic linker (works for both bytecode and object
--   code).
LinkInMemory :: GhcLink

-- | Link objects into a dynamic lib (DLL on Windows, DSO on ELF platforms)
LinkDynLib :: GhcLink

-- | Link objects into a static lib
LinkStaticLib :: GhcLink

-- | Link objects into a merged "GHCi object"
LinkMergedObj :: GhcLink
isNoLink :: GhcLink -> Bool

-- | Flags for manipulating packages visibility.
data PackageFlag

-- | <tt>-package</tt>, <tt>-package-id</tt>
ExposePackage :: String -> PackageArg -> ModRenaming -> PackageFlag

-- | <pre>
--   -hide-package
--   </pre>
HidePackage :: String -> PackageFlag

-- | We accept flags which make packages visible, but how they select the
--   package varies; this data type reflects what selection criterion is
--   used.
data PackageArg

-- | <tt>-package</tt>, by <tt>PackageName</tt>
PackageArg :: String -> PackageArg

-- | <tt>-package-id</tt>, by <a>Unit</a>
UnitIdArg :: Unit -> PackageArg

-- | Represents the renaming that may be associated with an exposed
--   package, e.g. the <tt>rns</tt> part of <tt>-package "foo (rns)"</tt>.
--   
--   Here are some example parsings of the package flags (where a string
--   literal is punned to be a <a>ModuleName</a>:
--   
--   <ul>
--   <li><tt>-package foo</tt> is <tt>ModRenaming True []</tt></li>
--   <li><tt>-package foo ()</tt> is <tt>ModRenaming False []</tt></li>
--   <li><tt>-package foo (A)</tt> is <tt>ModRenaming False [(<a>A</a>,
--   <a>A</a>)]</tt></li>
--   <li><tt>-package foo (A as B)</tt> is <tt>ModRenaming False
--   [(<a>A</a>, <a>B</a>)]</tt></li>
--   <li><tt>-package foo with (A as B)</tt> is <tt>ModRenaming True
--   [(<a>A</a>, <a>B</a>)]</tt></li>
--   </ul>
data ModRenaming
ModRenaming :: Bool -> [(ModuleName, ModuleName)] -> ModRenaming

-- | Bring all exposed modules into scope?
[modRenamingWithImplicit] :: ModRenaming -> Bool

-- | Bring module <tt>m</tt> into scope under name <tt>n</tt>.
[modRenamings] :: ModRenaming -> [(ModuleName, ModuleName)]
packageFlagsChanged :: DynFlags -> DynFlags -> Bool

-- | Flags for manipulating the set of non-broken packages.
newtype IgnorePackageFlag

-- | <pre>
--   -ignore-package
--   </pre>
IgnorePackage :: String -> IgnorePackageFlag

-- | Flags for manipulating package trust.
data TrustFlag

-- | <pre>
--   -trust
--   </pre>
TrustPackage :: String -> TrustFlag

-- | <pre>
--   -distrust
--   </pre>
DistrustPackage :: String -> TrustFlag
data PackageDBFlag
PackageDB :: PkgDbRef -> PackageDBFlag
NoUserPackageDB :: PackageDBFlag
NoGlobalPackageDB :: PackageDBFlag
ClearPackageDBs :: PackageDBFlag
data PkgDbRef
GlobalPkgDb :: PkgDbRef
UserPkgDb :: PkgDbRef
PkgDbPath :: FilePath -> PkgDbRef

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option
showOpt :: Option -> String
data DynLibLoader
Deployable :: DynLibLoader
SystemDependent :: DynLibLoader

-- | These <tt>-f&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-fno-&lt;blah&gt;</tt>
fFlags :: [FlagSpec GeneralFlag]

-- | These <tt>-f&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-fno-&lt;blah&gt;</tt>
fLangFlags :: [FlagSpec Extension]

-- | These -X<a>blah</a> flags can all be reversed with -XNo<a>blah</a>
xFlags :: [FlagSpec Extension]

-- | These <tt>-W&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-Wno-&lt;blah&gt;</tt>
wWarningFlags :: [FlagSpec WarningFlag]

-- | Resolve any internal inconsistencies in a set of <a>DynFlags</a>.
--   Returns the consistent <a>DynFlags</a> as well as a list of warnings
--   to report to the user.
makeDynFlagsConsistent :: DynFlags -> (DynFlags, [Located String])

-- | Are we building with <tt>-fPIE</tt> or <tt>-fPIC</tt> enabled?
positionIndependent :: DynFlags -> Bool

-- | The set of flags which affect optimisation for the purposes of
--   recompilation avoidance. Specifically, these include flags which
--   affect code generation but not the semantics of the program.
--   
--   See Note [Ignoring some flag changes] in GHC.Iface.Recomp.Flags)
optimisationFlags :: EnumSet GeneralFlag

-- | The set of flags which affect code generation and can change a
--   program's runtime behavior (other than performance). These include
--   flags which affect:
--   
--   <ul>
--   <li>user visible debugging information (e.g. info table
--   provenance)</li>
--   <li>the ability to catch runtime errors (e.g. -fignore-asserts)</li>
--   <li>the runtime result of the program (e.g. -fomit-yields)</li>
--   <li>which code or interface file declarations are emitted</li>
--   </ul>
--   
--   We also considered placing flags which affect asympototic space
--   behavior (e.g. -ffull-laziness) however this would mean that changing
--   optimisation levels would trigger recompilation even with
--   -fignore-optim-changes, regressing #13604.
--   
--   Also, arguably Opt_IgnoreAsserts should be here as well; however, we
--   place it instead in <a>optimisationFlags</a> since it is implied by
--   <tt>-O[12]</tt> and therefore would also break #13604.
--   
--   See #23369.
codeGenFlags :: EnumSet GeneralFlag
setFlagsFromEnvFile :: FilePath -> String -> DynP ()

-- | Pretty-print the difference between 2 DynFlags.
--   
--   For now only their general flags but it could be extended. Useful
--   mostly for debugging.
pprDynFlagsDiff :: DynFlags -> DynFlags -> SDoc

-- | Find the <a>FlagSpec</a> for a <a>WarningFlag</a>.
flagSpecOf :: WarningFlag -> Maybe (FlagSpec WarningFlag)

-- | Get target profile
targetProfile :: DynFlags -> Profile

-- | Is Safe Haskell on in some way (including inference mode)
safeHaskellOn :: DynFlags -> Bool
safeHaskellModeEnabled :: DynFlags -> Bool

-- | Test if Safe Imports are on in some form
safeImportsOn :: DynFlags -> Bool

-- | Is the Safe Haskell safe language in use
safeLanguageOn :: DynFlags -> Bool

-- | Is the Safe Haskell safe inference mode active
safeInferOn :: DynFlags -> Bool

-- | Is the -fpackage-trust mode on
packageTrustOn :: DynFlags -> Bool

-- | Are all direct imports required to be safe for this Safe Haskell mode?
--   Direct imports are when the code explicitly imports a module
safeDirectImpsReq :: DynFlags -> Bool

-- | Are all implicit imports required to be safe for this Safe Haskell
--   mode? Implicit imports are things in the prelude. e.g System.IO when
--   print is used.
safeImplicitImpsReq :: DynFlags -> Bool

-- | A list of unsafe flags under Safe Haskell. Tuple elements are: * name
--   of the flag * function to get srcspan that enabled the flag * function
--   to test if the flag is on * function to turn the flag off
unsafeFlags :: [(String, DynFlags -> SrcSpan, DynFlags -> Bool, DynFlags -> DynFlags)]

-- | A list of unsafe flags under Safe Haskell. Tuple elements are: * name
--   of the flag * function to get srcspan that enabled the flag * function
--   to test if the flag is on * function to turn the flag off
unsafeFlagsForInfer :: [(String, DynFlags -> SrcSpan, DynFlags -> Bool, DynFlags -> DynFlags)]
data Settings
Settings :: {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> Settings
[sGhcNameVersion] :: Settings -> {-# UNPACK #-} !GhcNameVersion
[sFileSettings] :: Settings -> {-# UNPACK #-} !FileSettings
[sTargetPlatform] :: Settings -> Platform
[sToolSettings] :: Settings -> {-# UNPACK #-} !ToolSettings
[sPlatformMisc] :: Settings -> {-# UNPACK #-} !PlatformMisc
[sRawSettings] :: Settings -> [(String, String)]
sProgramName :: Settings -> String
sProjectVersion :: Settings -> String
sGhcUsagePath :: Settings -> FilePath
sGhciUsagePath :: Settings -> FilePath
sToolDir :: Settings -> Maybe FilePath
sTopDir :: Settings -> FilePath
sGlobalPackageDatabasePath :: Settings -> FilePath
sLdSupportsCompactUnwind :: Settings -> Bool
sLdSupportsFilelist :: Settings -> Bool
sLdIsGnuLd :: Settings -> Bool
sGccSupportsNoPie :: Settings -> Bool
sPgm_L :: Settings -> String
sPgm_P :: Settings -> (String, [Option])
sPgm_F :: Settings -> String
sPgm_c :: Settings -> String
sPgm_cxx :: Settings -> String
sPgm_a :: Settings -> (String, [Option])
sPgm_l :: Settings -> (String, [Option])
sPgm_lm :: Settings -> Maybe (String, [Option])
sPgm_dll :: Settings -> (String, [Option])
sPgm_T :: Settings -> String
sPgm_windres :: Settings -> String
sPgm_ar :: Settings -> String
sPgm_ranlib :: Settings -> String
sPgm_lo :: Settings -> (String, [Option])
sPgm_lc :: Settings -> (String, [Option])
sPgm_lcc :: Settings -> (String, [Option])
sPgm_i :: Settings -> String
sOpt_L :: Settings -> [String]
sOpt_P :: Settings -> [String]
sOpt_P_fingerprint :: Settings -> Fingerprint
sOpt_F :: Settings -> [String]
sOpt_c :: Settings -> [String]
sOpt_cxx :: Settings -> [String]
sOpt_a :: Settings -> [String]
sOpt_l :: Settings -> [String]
sOpt_lm :: Settings -> [String]
sOpt_windres :: Settings -> [String]
sOpt_lo :: Settings -> [String]
sOpt_lc :: Settings -> [String]
sOpt_lcc :: Settings -> [String]
sOpt_i :: Settings -> [String]
sExtraGccViaCFlags :: Settings -> [String]
sTargetPlatformString :: Settings -> String
sGhcWithInterpreter :: Settings -> Bool
sLibFFI :: Settings -> Bool

-- | Settings for what GHC this is.
data GhcNameVersion
GhcNameVersion :: String -> String -> GhcNameVersion
[ghcNameVersion_programName] :: GhcNameVersion -> String
[ghcNameVersion_projectVersion] :: GhcNameVersion -> String

-- | Paths to various files and directories used by GHC, including those
--   that provide more settings.
data FileSettings
FileSettings :: FilePath -> FilePath -> Maybe FilePath -> FilePath -> FilePath -> FileSettings
[fileSettings_ghcUsagePath] :: FileSettings -> FilePath
[fileSettings_ghciUsagePath] :: FileSettings -> FilePath
[fileSettings_toolDir] :: FileSettings -> Maybe FilePath
[fileSettings_topDir] :: FileSettings -> FilePath
[fileSettings_globalPackageDatabase] :: FileSettings -> FilePath

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> Bool -> Bool -> String -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String

-- | "unbuild" a <a>Settings</a> from a <a>DynFlags</a>. This shouldn't be
--   needed in the vast majority of code. But GHCi questionably uses this
--   to produce a default <a>DynFlags</a> from which to compute a flags
--   diff for printing.
settings :: DynFlags -> Settings
programName :: DynFlags -> String
projectVersion :: DynFlags -> String
ghcUsagePath :: DynFlags -> FilePath
ghciUsagePath :: DynFlags -> FilePath
topDir :: DynFlags -> FilePath

-- | The directory for this version of ghc in the user's app directory The
--   appdir used to be in ~/.ghc but to respect the XDG specification we
--   want to move it under $XDG_DATA_HOME/ However, old tooling (like
--   cabal) might still write package environments to the old directory, so
--   we prefer that if a subdirectory of ~/.ghc with the correct target and
--   GHC version suffix exists.
--   
--   i.e. if ~<i>.ghc</i>$UNIQUE_SUBDIR exists we use that otherwise we use
--   $XDG_DATA_HOME/$UNIQUE_SUBDIR
--   
--   UNIQUE_SUBDIR is typically a combination of the target platform and
--   GHC version
versionedAppDir :: String -> ArchOS -> MaybeT IO FilePath
versionedFilePath :: ArchOS -> FilePath
extraGccViaCFlags :: DynFlags -> [String]
globalPackageDatabasePath :: DynFlags -> FilePath
pgm_L :: DynFlags -> String
pgm_P :: DynFlags -> (String, [Option])
pgm_F :: DynFlags -> String
pgm_c :: DynFlags -> String
pgm_cxx :: DynFlags -> String
pgm_a :: DynFlags -> (String, [Option])
pgm_l :: DynFlags -> (String, [Option])
pgm_lm :: DynFlags -> Maybe (String, [Option])
pgm_dll :: DynFlags -> (String, [Option])
pgm_T :: DynFlags -> String
pgm_windres :: DynFlags -> String
pgm_ar :: DynFlags -> String
pgm_ranlib :: DynFlags -> String
pgm_lo :: DynFlags -> (String, [Option])
pgm_lc :: DynFlags -> (String, [Option])
pgm_lcc :: DynFlags -> (String, [Option])
pgm_i :: DynFlags -> String
opt_L :: DynFlags -> [String]
opt_P :: DynFlags -> [String]
opt_F :: DynFlags -> [String]
opt_c :: DynFlags -> [String]
opt_cxx :: DynFlags -> [String]
opt_a :: DynFlags -> [String]
opt_l :: DynFlags -> [String]
opt_lm :: DynFlags -> [String]
opt_i :: DynFlags -> [String]
opt_P_signature :: DynFlags -> ([String], Fingerprint)
opt_windres :: DynFlags -> [String]
opt_lo :: DynFlags -> [String]
opt_lc :: DynFlags -> [String]
opt_lcc :: DynFlags -> [String]
updatePlatformConstants :: DynFlags -> Maybe PlatformConstants -> IO DynFlags
addPluginModuleName :: String -> DynFlags -> DynFlags

-- | The normal <a>DynFlags</a>. Note that they are not suitable for use in
--   this form and must be fully initialized by <a>runGhc</a> first.
defaultDynFlags :: Settings -> DynFlags

-- | Used by <a>runGhc</a> to partially initialize a new <a>DynFlags</a>
--   value
initDynFlags :: DynFlags -> IO DynFlags
defaultFatalMessager :: FatalMessager
defaultFlushOut :: FlushOut
setOutputFile :: Maybe String -> DynFlags -> DynFlags
setDynOutputFile :: Maybe String -> DynFlags -> DynFlags
setOutputHi :: Maybe String -> DynFlags -> DynFlags
setDynOutputHi :: Maybe String -> DynFlags -> DynFlags
augmentByWorkingDirectory :: DynFlags -> FilePath -> FilePath

-- | Retrieve the options corresponding to a particular <tt>opt_*</tt>
--   field in the correct order
getOpts :: DynFlags -> (DynFlags -> [a]) -> [a]

-- | Gets the verbosity flag for the current verbosity level. This is fed
--   to other tools, so GHC-specific verbosity flags like
--   <tt>-ddump-most</tt> are not included
getVerbFlags :: DynFlags -> [String]

-- | Sets the <a>DynFlags</a> to be appropriate to the optimisation level
updOptLevel :: Int -> DynFlags -> DynFlags
setTmpDir :: FilePath -> DynFlags -> DynFlags
setUnitId :: String -> DynFlags -> DynFlags
type TurnOnFlag = Bool
turnOn :: TurnOnFlag
turnOff :: TurnOnFlag
impliedGFlags :: [(GeneralFlag, TurnOnFlag, GeneralFlag)]
impliedOffGFlags :: [(GeneralFlag, TurnOnFlag, GeneralFlag)]
impliedXFlags :: [(Extension, TurnOnFlag, Extension)]
newtype CmdLineP s a
CmdLineP :: (forall m. Monad m => StateT s m a) -> CmdLineP s a
runCmdLineP :: CmdLineP s a -> s -> (a, s)
getCmdLineState :: CmdLineP s s
putCmdLineState :: s -> CmdLineP s ()

-- | A helper to parse a set of flags from a list of command-line
--   arguments, handling response files.
processCmdLineP :: forall s m. MonadIO m => [Flag (CmdLineP s)] -> s -> [Located String] -> m (([Located String], [Err], [Warn]), s)

-- | Parse dynamic flags from a list of command line arguments. Returns the
--   parsed <a>DynFlags</a>, the left-over arguments, and a list of
--   warnings. Throws a <a>UsageError</a> if errors occurred during parsing
--   (such as unknown flags or missing arguments).
parseDynamicFlagsCmdLine :: MonadIO m => DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | Like <a>parseDynamicFlagsCmdLine</a> but does not allow the package
--   flags (-package, -hide-package, -ignore-package, -hide-all-packages,
--   -package-db). Used to parse flags set in a modules pragma.
parseDynamicFilePragma :: MonadIO m => DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | Parses the dynamically set flags for GHC. This is the most general
--   form of the dynamic flag parser that the other methods simply wrap. It
--   allows saying which flags are valid flags and indicating if we are
--   parsing arguments from the command line or from a file pragma.
parseDynamicFlagsFull :: forall m. MonadIO m => [Flag (CmdLineP DynFlags)] -> Bool -> DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | All dynamic flags option strings without the deprecated ones. These
--   are the user facing strings for enabling and disabling options.
allNonDeprecatedFlags :: [String]
flagsAll :: [Flag (CmdLineP DynFlags)]
flagsDynamic :: [Flag (CmdLineP DynFlags)]
flagsPackage :: [Flag (CmdLineP DynFlags)]

-- | Make a list of flags for shell completion. Filter all available flags
--   into two groups, for interactive GHC vs all other.
flagsForCompletion :: Bool -> [String]
supportedLanguagesAndExtensions :: ArchOS -> [String]

-- | The language extensions implied by the various language variants. When
--   updating this be sure to update the flag documentation in
--   <tt>docs<i>users_guide</i>exts</tt>.
languageExtensions :: Maybe Language -> [Extension]
picCCOpts :: DynFlags -> [String]
picPOpts :: DynFlags -> [String]
pieCCLDOpts :: DynFlags -> [String]
compilerInfo :: DynFlags -> [(String, String)]
wordAlignment :: Platform -> Alignment
setUnsafeGlobalDynFlags :: DynFlags -> IO ()
isSse4_2Enabled :: DynFlags -> Bool
isBmiEnabled :: DynFlags -> Bool
isBmi2Enabled :: DynFlags -> Bool
isAvxEnabled :: DynFlags -> Bool
isAvx2Enabled :: DynFlags -> Bool
isAvx512cdEnabled :: DynFlags -> Bool
isAvx512erEnabled :: DynFlags -> Bool
isAvx512fEnabled :: DynFlags -> Bool
isAvx512pfEnabled :: DynFlags -> Bool
data LinkerInfo
GnuLD :: [Option] -> LinkerInfo
GnuGold :: [Option] -> LinkerInfo
LlvmLLD :: [Option] -> LinkerInfo
DarwinLD :: [Option] -> LinkerInfo
SolarisLD :: [Option] -> LinkerInfo
AixLD :: [Option] -> LinkerInfo
UnknownLD :: LinkerInfo
data CompilerInfo
GCC :: CompilerInfo
Clang :: CompilerInfo
AppleClang :: CompilerInfo
AppleClang51 :: CompilerInfo
Emscripten :: CompilerInfo
UnknownCC :: CompilerInfo

-- | Should we use `-XLinker -rpath` when linking or not? See Note
--   [-fno-use-rpaths]
useXLinkerRPath :: DynFlags -> OS -> Bool

-- | Used to differentiate the scope an include needs to apply to. We have
--   to split the include paths to avoid accidentally forcing recursive
--   includes since -I overrides the system search paths. See #14312.
data IncludeSpecs
IncludeSpecs :: [String] -> [String] -> [String] -> IncludeSpecs
[includePathsQuote] :: IncludeSpecs -> [String]
[includePathsGlobal] :: IncludeSpecs -> [String]

-- | See Note [Implicit include paths]
[includePathsQuoteImplicit] :: IncludeSpecs -> [String]

-- | Append to the list of includes a path that shall be included using
--   `-I` when the C compiler is called. These paths override system search
--   paths.
addGlobalInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Append to the list of includes a path that shall be included using
--   `-iquote` when the C compiler is called. These paths only apply when
--   quoted includes are used. e.g. #include "foo.h"
addQuoteInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Concatenate and flatten the list of global and quoted includes
--   returning just a flat list of paths.
flattenIncludes :: IncludeSpecs -> [String]

-- | These includes are not considered while fingerprinting the flags for
--   iface | See Note [Implicit include paths]
addImplicitQuoteInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Initialize the pretty-printing options
initSDocContext :: DynFlags -> PprStyle -> SDocContext

-- | Initialize the pretty-printing options using the default user style
initDefaultSDocContext :: DynFlags -> SDocContext
initPromotionTickContext :: DynFlags -> PromotionTickContext
instance GHC.Show.Show GHC.Driver.Session.IncludeSpecs
instance GHC.Classes.Eq GHC.Driver.Session.GhcMode
instance GHC.Show.Show GHC.Driver.Session.GhcLink
instance GHC.Classes.Eq GHC.Driver.Session.GhcLink
instance GHC.Show.Show GHC.Driver.Session.PackageArg
instance GHC.Classes.Eq GHC.Driver.Session.PackageArg
instance GHC.Classes.Eq GHC.Driver.Session.ModRenaming
instance GHC.Classes.Eq GHC.Driver.Session.IgnorePackageFlag
instance GHC.Classes.Eq GHC.Driver.Session.TrustFlag
instance GHC.Classes.Eq GHC.Driver.Session.PackageFlag
instance GHC.Classes.Eq GHC.Driver.Session.DynLibLoader
instance GHC.Show.Show GHC.Driver.Session.RtsOptsEnabled
instance GHC.Classes.Ord GHC.Driver.Session.DynamicTooState
instance GHC.Show.Show GHC.Driver.Session.DynamicTooState
instance GHC.Classes.Eq GHC.Driver.Session.DynamicTooState
instance GHC.Show.Show a => GHC.Show.Show (GHC.Driver.Session.OnOff a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Driver.Session.OnOff a)
instance GHC.Base.Functor (GHC.Driver.Session.CmdLineP s)
instance GHC.Classes.Ord GHC.Driver.Session.Deprecation
instance GHC.Classes.Eq GHC.Driver.Session.Deprecation
instance GHC.Classes.Eq GHC.Driver.Session.PkgDbRef
instance GHC.Classes.Eq GHC.Driver.Session.PackageDBFlag
instance GHC.Classes.Eq GHC.Driver.Session.LinkerInfo
instance GHC.Classes.Eq GHC.Driver.Session.CompilerInfo
instance (GHC.Base.Monoid a, GHC.Base.Monad m, GHC.Driver.Session.HasDynFlags m) => GHC.Driver.Session.HasDynFlags (Control.Monad.Trans.Writer.Lazy.WriterT a m)
instance (GHC.Base.Monad m, GHC.Driver.Session.HasDynFlags m) => GHC.Driver.Session.HasDynFlags (Control.Monad.Trans.Reader.ReaderT a m)
instance (GHC.Base.Monad m, GHC.Driver.Session.HasDynFlags m) => GHC.Driver.Session.HasDynFlags (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Base.Monad m, GHC.Driver.Session.HasDynFlags m) => GHC.Driver.Session.HasDynFlags (Control.Monad.Trans.Except.ExceptT e m)
instance GHC.Base.Monad (GHC.Driver.Session.CmdLineP s)
instance GHC.Base.Applicative (GHC.Driver.Session.CmdLineP s)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Driver.Session.OnOff a)
instance GHC.Utils.Outputable.Outputable GHC.Driver.Session.PackageFlag
instance GHC.Utils.Outputable.Outputable GHC.Driver.Session.ModRenaming
instance GHC.Utils.Outputable.Outputable GHC.Driver.Session.PackageArg
instance GHC.Utils.Outputable.Outputable GHC.Driver.Session.GhcMode


-- | Unit manipulation
module GHC.Unit.State
data UnitState
UnitState :: UnitInfoMap -> PreloadUnitClosure -> UniqFM PackageName UnitId -> Map UnitId UnitId -> Map UnitId UnitId -> [UnitId] -> [(Unit, Maybe PackageArg)] -> [UnitId] -> !ModuleNameProvidersMap -> !ModuleNameProvidersMap -> Map ModuleName [InstantiatedModule] -> !Bool -> UnitState

-- | A mapping of <a>Unit</a> to <a>UnitInfo</a>. This list is adjusted so
--   that only valid units are here. <a>UnitInfo</a> reflects what was
--   stored *on disk*, except for the <tt>trusted</tt> flag, which is
--   adjusted at runtime. (In particular, some units in this map may have
--   the <tt>exposed</tt> flag be <a>False</a>.)
[unitInfoMap] :: UnitState -> UnitInfoMap

-- | The set of transitively reachable units according to the explicitly
--   provided command line arguments. A fully instantiated VirtUnit may
--   only be replaced by a RealUnit from this set. See Note [VirtUnit to
--   RealUnit improvement]
[preloadClosure] :: UnitState -> PreloadUnitClosure

-- | A mapping of <a>PackageName</a> to <a>UnitId</a>. If several units
--   have the same package name (e.g. different instantiations), then we
--   return one of them... This is used when users refer to packages in
--   Backpack includes. And also to resolve package qualifiers with the
--   PackageImports extension.
[packageNameMap] :: UnitState -> UniqFM PackageName UnitId

-- | A mapping from database unit keys to wired in unit ids.
[wireMap] :: UnitState -> Map UnitId UnitId

-- | A mapping from wired in unit ids to unit keys from the database.
[unwireMap] :: UnitState -> Map UnitId UnitId

-- | The units we're going to link in eagerly. This list should be in
--   reverse dependency order; that is, a unit is always mentioned before
--   the units it depends on.
[preloadUnits] :: UnitState -> [UnitId]

-- | Units which we explicitly depend on (from a command line flag). We'll
--   use this to generate version macros and the unused packages warning.
--   The original flag which was used to bring the unit into scope is
--   recorded for the -Wunused-packages warning.
[explicitUnits] :: UnitState -> [(Unit, Maybe PackageArg)]
[homeUnitDepends] :: UnitState -> [UnitId]

-- | This is a full map from <a>ModuleName</a> to all modules which may
--   possibly be providing it. These providers may be hidden (but we'll
--   still want to report them in error messages), or it may be an
--   ambiguous import.
[moduleNameProvidersMap] :: UnitState -> !ModuleNameProvidersMap

-- | A map, like <a>moduleNameProvidersMap</a>, but controlling plugin
--   visibility.
[pluginModuleNameProvidersMap] :: UnitState -> !ModuleNameProvidersMap

-- | A map saying, for each requirement, what interfaces must be merged
--   together when we use them. For example, if our dependencies are
--   <tt>p[A=&lt;A&gt;]</tt> and
--   <tt>q[A=&lt;A&gt;,B=r[C=&lt;A&gt;]:B]</tt>, then the interfaces to
--   merge for A are <tt>p[A=&lt;A&gt;]:A</tt>,
--   <tt>q[A=&lt;A&gt;,B=r[C=&lt;A&gt;]:B]:A</tt> and
--   <tt>r[C=&lt;A&gt;]:C</tt>.
--   
--   There's an entry in this map for each hole in our home library.
[requirementContext] :: UnitState -> Map ModuleName [InstantiatedModule]

-- | Indicate if we can instantiate units on-the-fly.
--   
--   This should only be true when we are type-checking an indefinite unit.
--   See Note [About units] in GHC.Unit.
[allowVirtualUnits] :: UnitState -> !Bool
type PreloadUnitClosure = UniqSet UnitId

-- | Unit database
data UnitDatabase unit
UnitDatabase :: FilePath -> [GenUnitInfo unit] -> UnitDatabase unit
[unitDatabasePath] :: UnitDatabase unit -> FilePath
[unitDatabaseUnits] :: UnitDatabase unit -> [GenUnitInfo unit]
data UnitErr
CloseUnitErr :: !UnitId -> !Maybe UnitId -> UnitErr
PackageFlagErr :: !PackageFlag -> ![(UnitInfo, UnusableUnitReason)] -> UnitErr
TrustFlagErr :: !TrustFlag -> ![(UnitInfo, UnusableUnitReason)] -> UnitErr
emptyUnitState :: UnitState

-- | Read the unit database files, and sets up various internal tables of
--   unit information, according to the unit-related flags on the
--   command-line (<tt>-package</tt>, <tt>-hide-package</tt> etc.)
--   
--   <a>initUnits</a> can be called again subsequently after updating the
--   <a>packageFlags</a> field of the <a>DynFlags</a>, and it will update
--   the <tt>unitState</tt> in <a>DynFlags</a>.
initUnits :: Logger -> DynFlags -> Maybe [UnitDatabase UnitId] -> Set UnitId -> IO ([UnitDatabase UnitId], UnitState, HomeUnit, Maybe PlatformConstants)
readUnitDatabases :: Logger -> UnitConfig -> IO [UnitDatabase UnitId]
readUnitDatabase :: Logger -> UnitConfig -> FilePath -> IO (UnitDatabase UnitId)
getUnitDbRefs :: UnitConfig -> IO [PkgDbRef]

-- | Return the path of a package database from a <a>PkgDbRef</a>. Return
--   <a>Nothing</a> when the user database filepath is expected but the
--   latter doesn't exist.
--   
--   NB: This logic is reimplemented in Cabal, so if you change it, make
--   sure you update Cabal. (Or, better yet, dump it in the compiler info
--   so Cabal can use the info.)
resolveUnitDatabase :: UnitConfig -> PkgDbRef -> IO (Maybe FilePath)

-- | Get a list of entries from the unit database. NB: be careful with this
--   function, although all units in this map are "visible", this does not
--   imply that the exposed-modules of the unit are available (they may
--   have been thinned or renamed).
listUnitInfo :: UnitState -> [UnitInfo]
type UnitInfoMap = Map UnitId UnitInfo

-- | Find the unit we know about with the given unit, if any
lookupUnit :: UnitState -> Unit -> Maybe UnitInfo

-- | A more specialized interface, which doesn't require a <a>UnitState</a>
--   (so it can be used while we're initializing <a>DynFlags</a>)
--   
--   Parameters: * a boolean specifying whether or not to look for
--   on-the-fly renamed interfaces * a <a>UnitInfoMap</a> * a
--   <a>PreloadUnitClosure</a>
lookupUnit' :: Bool -> UnitInfoMap -> PreloadUnitClosure -> Unit -> Maybe UnitInfo

-- | Looks up the given unit in the unit state, panicking if it is not
--   found
unsafeLookupUnit :: HasDebugCallStack => UnitState -> Unit -> UnitInfo

-- | Find the unit we know about with the given unit id, if any
lookupUnitId :: UnitState -> UnitId -> Maybe UnitInfo

-- | Find the unit we know about with the given unit id, if any
lookupUnitId' :: UnitInfoMap -> UnitId -> Maybe UnitInfo

-- | Looks up the given unit id in the unit state, panicking if it is not
--   found
unsafeLookupUnitId :: HasDebugCallStack => UnitState -> UnitId -> UnitInfo

-- | Find the unit we know about with the given package name (e.g.
--   <tt>foo</tt>), if any (NB: there might be a locally defined unit name
--   which overrides this) This function is unsafe to use in general
--   because it doesn't respect package visibility.
lookupPackageName :: UnitState -> PackageName -> Maybe UnitId

-- | Find the UnitId which an import qualified by a package import comes
--   from. Compared to <a>lookupPackageName</a>, this function correctly
--   accounts for visibility, renaming and thinning.
resolvePackageImport :: UnitState -> ModuleName -> PackageName -> Maybe UnitId

-- | Given a fully instantiated <a>GenInstantiatedUnit</a>, improve it into
--   a <a>RealUnit</a> if we can find it in the package database.
improveUnit :: UnitState -> Unit -> Unit

-- | Search for units with a given package ID (e.g. "foo-0.1")
searchPackageId :: UnitState -> PackageId -> [UnitInfo]
listVisibleModuleNames :: UnitState -> [ModuleName]

-- | Takes a <a>ModuleName</a>, and if the module is in any package returns
--   list of modules which take that name.
lookupModuleInAllUnits :: UnitState -> ModuleName -> [(Module, UnitInfo)]
lookupModuleWithSuggestions :: UnitState -> ModuleName -> PkgQual -> LookupResult

-- | The package which the module **appears** to come from, this could be
--   the one which reexports the module from it's original package. This
--   function is currently only used for -Wunused-packages
lookupModulePackage :: UnitState -> ModuleName -> PkgQual -> Maybe [UnitInfo]
lookupPluginModuleWithSuggestions :: UnitState -> ModuleName -> PkgQual -> LookupResult

-- | Return this list of requirement interfaces that need to be merged to
--   form <tt>mod_name</tt>, or <tt>[]</tt> if this is not a requirement.
requirementMerges :: UnitState -> ModuleName -> [InstantiatedModule]

-- | The result of performing a lookup
data LookupResult

-- | Found the module uniquely, nothing else to do
LookupFound :: Module -> (UnitInfo, ModuleOrigin) -> LookupResult

-- | Multiple modules with the same name in scope
LookupMultiple :: [(Module, ModuleOrigin)] -> LookupResult

-- | No modules found, but there were some hidden ones with an exact name
--   match. First is due to package hidden, second is due to module being
--   hidden
LookupHidden :: [(Module, ModuleOrigin)] -> [(Module, ModuleOrigin)] -> LookupResult

-- | No modules found, but there were some unusable ones with an exact name
--   match
LookupUnusable :: [(Module, ModuleOrigin)] -> LookupResult

-- | Nothing found, here are some suggested different names
LookupNotFound :: [ModuleSuggestion] -> LookupResult
data ModuleSuggestion
SuggestVisible :: ModuleName -> Module -> ModuleOrigin -> ModuleSuggestion
SuggestHidden :: ModuleName -> Module -> ModuleOrigin -> ModuleSuggestion

-- | Given a module name, there may be multiple ways it came into scope,
--   possibly simultaneously. This data type tracks all the possible ways
--   it could have come into scope. Warning: don't use the record
--   functions, they're partial!
data ModuleOrigin

-- | Module is hidden, and thus never will be available for import. (But
--   maybe the user didn't realize), so we'll still keep track of these
--   modules.)
ModHidden :: ModuleOrigin

-- | Module is unavailable because the unit is unusable.
ModUnusable :: !UnusableUnit -> ModuleOrigin

-- | Module is public, and could have come from some places.
ModOrigin :: Maybe Bool -> [UnitInfo] -> [UnitInfo] -> Bool -> ModuleOrigin

-- | <tt>Just False</tt> means that this module is in someone's
--   <tt>exported-modules</tt> list, but that package is hidden; <tt>Just
--   True</tt> means that it is available; <tt>Nothing</tt> means neither
--   applies.
[fromOrigUnit] :: ModuleOrigin -> Maybe Bool

-- | Is the module available from a reexport of an exposed package? There
--   could be multiple.
[fromExposedReexport] :: ModuleOrigin -> [UnitInfo]

-- | Is the module available from a reexport of a hidden package?
[fromHiddenReexport] :: ModuleOrigin -> [UnitInfo]

-- | Did the module export come from a package flag? (ToDo: track more
--   information.
[fromPackageFlag] :: ModuleOrigin -> Bool

-- | A unusable unit module origin
data UnusableUnit
UnusableUnit :: !Unit -> !UnusableUnitReason -> !Bool -> UnusableUnit

-- | Unusable unit
[uuUnit] :: UnusableUnit -> !Unit

-- | Reason
[uuReason] :: UnusableUnit -> !UnusableUnitReason

-- | Is the "module" a reexport?
[uuIsReexport] :: UnusableUnit -> !Bool

-- | The reason why a unit is unusable.
data UnusableUnitReason

-- | We ignored it explicitly using <tt>-ignore-package</tt>.
IgnoredWithFlag :: UnusableUnitReason

-- | This unit transitively depends on a unit that was never present in any
--   of the provided databases.
BrokenDependencies :: [UnitId] -> UnusableUnitReason

-- | This unit transitively depends on a unit involved in a cycle. Note
--   that the list of <a>UnitId</a> reports the direct dependencies of this
--   unit that (transitively) depended on the cycle, and not the actual
--   cycle itself (which we report separately at high verbosity.)
CyclicDependencies :: [UnitId] -> UnusableUnitReason

-- | This unit transitively depends on a unit which was ignored.
IgnoredDependencies :: [UnitId] -> UnusableUnitReason

-- | This unit transitively depends on a unit which was shadowed by an
--   ABI-incompatible unit.
ShadowedDependencies :: [UnitId] -> UnusableUnitReason
pprReason :: SDoc -> UnusableUnitReason -> SDoc

-- | Takes a list of UnitIds (and their "parent" dependency, used for error
--   messages), and returns the list with dependencies included, in reverse
--   dependency order (a units appears before those it depends on).
closeUnitDeps :: UnitInfoMap -> [(UnitId, Maybe UnitId)] -> MaybeErr UnitErr [UnitId]

-- | Similar to closeUnitDeps but takes a list of already loaded units as
--   an additional argument.
closeUnitDeps' :: UnitInfoMap -> [UnitId] -> [(UnitId, Maybe UnitId)] -> MaybeErr UnitErr [UnitId]
mayThrowUnitErr :: MaybeErr UnitErr a -> IO a

-- | Substitution on module variables, mapping module names to module
--   identifiers.
type ShHoleSubst = ModuleNameEnv Module

-- | Substitutes holes in a <a>Unit</a>, suitable for renaming when an
--   include occurs; see Note [Representation of module/name variables].
--   
--   <tt>p[A=&lt;A&gt;]</tt> maps to <tt>p[A=&lt;B&gt;]</tt> with
--   <tt>A=&lt;B&gt;</tt>.
renameHoleUnit :: UnitState -> ShHoleSubst -> Unit -> Unit

-- | Substitutes holes in a <a>GenModule</a>. NOT suitable for being called
--   directly on a <tt>nameModule</tt>, see Note [Representation of
--   module/name variables]. <tt>p[A=&lt;A&gt;]:B</tt> maps to
--   <tt>p[A=q():A]:B</tt> with <tt>A=q():A</tt>; similarly,
--   <tt>&lt;A&gt;</tt> maps to <tt>q():A</tt>.
renameHoleModule :: UnitState -> ShHoleSubst -> Module -> Module

-- | Like 'renameHoleUnit, but requires only <tt>ClosureUnitInfoMap</tt> so
--   it can be used by <a>GHC.Unit.State</a>.
renameHoleUnit' :: UnitInfoMap -> PreloadUnitClosure -> ShHoleSubst -> Unit -> Unit

-- | Like <a>renameHoleModule</a>, but requires only
--   <tt>ClosureUnitInfoMap</tt> so it can be used by
--   <a>GHC.Unit.State</a>.
renameHoleModule' :: UnitInfoMap -> PreloadUnitClosure -> ShHoleSubst -> Module -> Module

-- | Check the database to see if we already have an installed unit that
--   corresponds to the given <a>GenInstantiatedUnit</a>.
--   
--   Return a <a>UnitId</a> which either wraps the
--   <a>GenInstantiatedUnit</a> unchanged or references a matching
--   installed unit.
--   
--   See Note [VirtUnit to RealUnit improvement]
instUnitToUnit :: UnitState -> InstantiatedUnit -> Unit

-- | Injects an <a>InstantiatedModule</a> to <a>GenModule</a> (see also
--   <a>instUnitToUnit</a>.
instModuleToModule :: UnitState -> InstantiatedModule -> Module
pprFlag :: PackageFlag -> SDoc

-- | Show (very verbose) package info
pprUnits :: UnitState -> SDoc

-- | Show simplified unit info.
--   
--   The idea is to only print package id, and any information that might
--   be different from the package databases (exposure, trust)
pprUnitsSimple :: UnitState -> SDoc

-- | Pretty-print a UnitId for the user.
--   
--   Cabal packages may contain several components (programs, libraries,
--   etc.). As far as GHC is concerned, installed package components
--   ("units") are identified by an opaque UnitId string provided by Cabal.
--   As the string contains a hash, we don't want to display it to users so
--   GHC queries the database to retrieve some infos about the original
--   source package (name, version, component name).
--   
--   Instead we want to display: packagename-version[:componentname]
--   
--   Component name is only displayed if it isn't the default library
--   
--   To do this we need to query a unit database.
pprUnitIdForUser :: UnitState -> UnitId -> SDoc
pprUnitInfoForUser :: UnitInfo -> SDoc

-- | Show the mapping of modules to where they come from.
pprModuleMap :: ModuleNameProvidersMap -> SDoc

-- | Print unit-ids with UnitInfo found in the given UnitState
pprWithUnitState :: UnitState -> SDoc -> SDoc

-- | Given a wired-in <a>Unit</a>, "unwire" it into the <a>Unit</a> that it
--   was recorded as in the package database.
unwireUnit :: UnitState -> Unit -> Unit

-- | Add package dependencies on the wired-in packages we use
implicitPackageDeps :: DynFlags -> [UnitId]
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.UnitErr
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.ModuleOrigin
instance GHC.Base.Semigroup GHC.Unit.State.ModuleOrigin
instance GHC.Base.Monoid GHC.Unit.State.ModuleOrigin
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.UnusableUnitReason
instance GHC.Utils.Outputable.Outputable u => GHC.Utils.Outputable.Outputable (GHC.Unit.State.UnitDatabase u)
instance GHC.Utils.Outputable.Outputable GHC.Unit.State.UnitVisibility
instance GHC.Base.Semigroup GHC.Unit.State.UnitVisibility
instance GHC.Base.Monoid GHC.Unit.State.UnitVisibility


-- | Dependencies and Usage of a module
module GHC.Unit.Module.Deps

-- | Dependency information about ALL modules and packages below this one
--   in the import hierarchy. This is the serialisable version of
--   <a>ImportAvails</a>.
--   
--   Invariant: the dependencies of a module <tt>M</tt> never includes
--   <tt>M</tt>.
--   
--   Invariant: none of the lists contain duplicates.
--   
--   Invariant: lists are ordered canonically (e.g. using stableModuleCmp)
--   
--   See Note [Transitive Information in Dependencies]
data Dependencies

-- | Extract information from the rename and typecheck phases to produce a
--   dependencies information for the module being compiled.
--   
--   The fourth argument is a list of plugin modules.
mkDependencies :: HomeUnit -> Module -> ImportAvails -> [Module] -> Dependencies
noDependencies :: Dependencies

-- | All home-package modules which are directly imported by this one. This
--   may include modules from other units when using multiple home units
dep_direct_mods :: Dependencies -> Set (UnitId, ModuleNameWithIsBoot)

-- | All packages directly imported by this module I.e. packages to which
--   this module's direct imports belong. Does not include other home units
--   when using multiple home units. Modules from these units will go in
--   <a>dep_direct_mods</a>
dep_direct_pkgs :: Dependencies -> Set UnitId

-- | Transitive closure of hsig files in the home package
dep_sig_mods :: Dependencies -> [ModuleName]
dep_trusted_pkgs :: Dependencies -> Set UnitId

-- | Transitive closure of orphan modules (whether home or external pkg).
--   
--   (Possible optimization: don't include family instance orphans as they
--   are anyway included in <a>dep_finsts</a>. But then be careful about
--   code which relies on dep_orphs having the complete list!) This does
--   NOT include us, unlike <a>imp_orphs</a>.
dep_orphs :: Dependencies -> [Module]

-- | All units needed for plugins
dep_plugin_pkgs :: Dependencies -> Set UnitId

-- | Transitive closure of depended upon modules which contain family
--   instances (whether home or external). This is used by
--   <tt>checkFamInstConsistency</tt>. This does NOT include us, unlike
--   <a>imp_finsts</a>. See Note [The type family instance consistency
--   story].
dep_finsts :: Dependencies -> [Module]

-- | All modules which have boot files below this one, and whether we
--   should use the boot file or not. This information is only used to
--   populate the eps_is_boot field. See Note [Structure of dep_boot_mods]
dep_boot_mods :: Dependencies -> Set (UnitId, ModuleNameWithIsBoot)

-- | Update module dependencies containing orphans (used by Backpack)
dep_orphs_update :: Monad m => Dependencies -> ([Module] -> m [Module]) -> m Dependencies

-- | Update module dependencies containing family instances (used by
--   Backpack)
dep_finsts_update :: Monad m => Dependencies -> ([Module] -> m [Module]) -> m Dependencies

-- | Pretty-print unit dependencies
pprDeps :: UnitState -> Dependencies -> SDoc

-- | Records modules for which changes may force recompilation of this
--   module See wiki:
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/recompilation-avoidance</a>
--   
--   This differs from Dependencies. A module X may be in the dep_mods of
--   this module (via an import chain) but if we don't use anything from X
--   it won't appear in our Usage
data Usage

-- | Module from another package
UsagePackageModule :: Module -> Fingerprint -> IsSafeImport -> Usage

-- | External package module depended on
[usg_mod] :: Usage -> Module

-- | Cached module ABI fingerprint (corresponds to mi_mod_hash)
[usg_mod_hash] :: Usage -> Fingerprint

-- | Was this module imported as a safe import
[usg_safe] :: Usage -> IsSafeImport

-- | Module from the current package
UsageHomeModule :: ModuleName -> UnitId -> Fingerprint -> [(OccName, Fingerprint)] -> Maybe Fingerprint -> IsSafeImport -> Usage

-- | Name of the module
[usg_mod_name] :: Usage -> ModuleName

-- | UnitId of the HomeUnit the module is from
[usg_unit_id] :: Usage -> UnitId

-- | Cached module ABI fingerprint (corresponds to mi_mod_hash)
[usg_mod_hash] :: Usage -> Fingerprint

-- | Entities we depend on, sorted by occurrence name and fingerprinted.
--   NB: usages are for parent names only, e.g. type constructors but not
--   the associated data constructors.
[usg_entities] :: Usage -> [(OccName, Fingerprint)]

-- | Fingerprint for the export list of this module, if we directly
--   imported it (and hence we depend on its export list)
[usg_exports] :: Usage -> Maybe Fingerprint

-- | Was this module imported as a safe import
[usg_safe] :: Usage -> IsSafeImport

-- | A file upon which the module depends, e.g. a CPP #include, or using
--   TH's <tt>addDependentFile</tt>
UsageFile :: FilePath -> Fingerprint -> Maybe String -> Usage

-- | External file dependency. From a CPP #include or TH addDependentFile.
--   Should be absolute.
[usg_file_path] :: Usage -> FilePath

-- | <a>Fingerprint</a> of the file contents.
[usg_file_hash] :: Usage -> Fingerprint

-- | An optional string which is used in recompilation messages if file in
--   question has changed.
[usg_file_label] :: Usage -> Maybe String
UsageHomeModuleInterface :: ModuleName -> UnitId -> Fingerprint -> Usage

-- | Name of the module
[usg_mod_name] :: Usage -> ModuleName

-- | UnitId of the HomeUnit the module is from
[usg_unit_id] :: Usage -> UnitId

-- | The *interface* hash of the module, not the ABI hash. This changes
--   when anything about the interface (and hence the module) has changed.
[usg_iface_hash] :: Usage -> Fingerprint

-- | A requirement which was merged into this one.
UsageMergedRequirement :: Module -> Fingerprint -> Usage

-- | External package module depended on
[usg_mod] :: Usage -> Module

-- | Cached module ABI fingerprint (corresponds to mi_mod_hash)
[usg_mod_hash] :: Usage -> Fingerprint

-- | <a>ImportAvails</a> summarises what was imported from where,
--   irrespective of whether the imported things are actually used or not.
--   It is used:
--   
--   <ul>
--   <li>when processing the export list,</li>
--   <li>when constructing usage info for the interface file,</li>
--   <li>to identify the list of directly imported modules for
--   initialisation purposes and for optimised overlap checking of family
--   instances,</li>
--   <li>when figuring out what things are really unused</li>
--   </ul>
data ImportAvails
ImportAvails :: ImportedMods -> InstalledModuleEnv ModuleNameWithIsBoot -> Set UnitId -> Bool -> Set UnitId -> InstalledModuleEnv ModuleNameWithIsBoot -> [ModuleName] -> [Module] -> [Module] -> ImportAvails

-- | Domain is all directly-imported modules
--   
--   See the documentation on ImportedModsVal in
--   <a>GHC.Unit.Module.Imported</a> for the meaning of the fields.
--   
--   We need a full ModuleEnv rather than a ModuleNameEnv here, because we
--   might be importing modules of the same name from different packages.
--   (currently not the case, but might be in the future).
[imp_mods] :: ImportAvails -> ImportedMods

-- | Home-package modules directly imported by the module being compiled.
[imp_direct_dep_mods] :: ImportAvails -> InstalledModuleEnv ModuleNameWithIsBoot

-- | Packages directly needed by the module being compiled
[imp_dep_direct_pkgs] :: ImportAvails -> Set UnitId

-- | Do we require that our own package is trusted? This is to handle
--   efficiently the case where a Safe module imports a Trustworthy module
--   that resides in the same package as it. See Note [Trust Own Package]
--   in <a>GHC.Rename.Names</a>
[imp_trust_own_pkg] :: ImportAvails -> Bool

-- | This records the packages the current module needs to trust for Safe
--   Haskell compilation to succeed. A package is required to be trusted if
--   we are dependent on a trustworthy module in that package. See Note
--   [Tracking Trust Transitively] in <a>GHC.Rename.Names</a>
[imp_trust_pkgs] :: ImportAvails -> Set UnitId

-- | Domain is all modules which have hs-boot files, and whether we should
--   import the boot version of interface file. Only used in one-shot mode
--   to populate eps_is_boot.
[imp_boot_mods] :: ImportAvails -> InstalledModuleEnv ModuleNameWithIsBoot

-- | Signature modules below this one
[imp_sig_mods] :: ImportAvails -> [ModuleName]

-- | Orphan modules below us in the import tree (and maybe including us for
--   imported modules)
[imp_orphs] :: ImportAvails -> [Module]

-- | Family instance modules below us in the import tree (and maybe
--   including us for imported modules)
[imp_finsts] :: ImportAvails -> [Module]
instance GHC.Classes.Eq GHC.Unit.Module.Deps.Dependencies
instance GHC.Classes.Eq GHC.Unit.Module.Deps.Usage
instance GHC.Utils.Binary.Binary GHC.Unit.Module.Deps.Usage
instance GHC.Utils.Binary.Binary GHC.Unit.Module.Deps.Dependencies


-- | Units are library components from Cabal packages compiled and
--   installed in a database
module GHC.Unit

module GHC.Unit.Finder.Types
data FinderCache
FinderCache :: IORef FinderCacheState -> IORef FileCacheState -> FinderCache
[fcModuleCache] :: FinderCache -> IORef FinderCacheState
[fcFileCache] :: FinderCache -> IORef FileCacheState

-- | The <a>FinderCache</a> maps modules to the result of searching for
--   that module. It records the results of searching for modules along the
--   search path. On <tt>:load</tt>, we flush the entire contents of this
--   cache.
type FinderCacheState = InstalledModuleEnv InstalledFindResult

-- | The result of searching for an imported module.
--   
--   NB: FindResult manages both user source-import lookups (which can
--   result in <a>GenModule</a>) as well as direct imports for interfaces
--   (which always result in <a>InstalledModule</a>).
data FindResult

-- | The module was found
Found :: ModLocation -> Module -> FindResult

-- | The requested unit was not found
NoPackage :: Unit -> FindResult

-- | _Error_: both in multiple packages
FoundMultiple :: [(Module, ModuleOrigin)] -> FindResult

-- | Not found
NotFound :: [FilePath] -> Maybe Unit -> [Unit] -> [Unit] -> [UnusableUnit] -> [ModuleSuggestion] -> FindResult

-- | Places where I looked
[fr_paths] :: FindResult -> [FilePath]

-- | Just p =&gt; module is in this unit's manifest, but couldn't find the
--   .hi file
[fr_pkg] :: FindResult -> Maybe Unit

-- | Module is in these units, but the *module* is hidden
[fr_mods_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but the *unit* is hidden
[fr_pkgs_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but it is unusable
[fr_unusables] :: FindResult -> [UnusableUnit]

-- | Possible mis-spelled modules
[fr_suggestions] :: FindResult -> [ModuleSuggestion]
data InstalledFindResult
InstalledFound :: ModLocation -> InstalledModule -> InstalledFindResult
InstalledNoPackage :: UnitId -> InstalledFindResult
InstalledNotFound :: [FilePath] -> Maybe UnitId -> InstalledFindResult

-- | Locations and information the finder cares about.
--   
--   Should be taken from <tt>DynFlags</tt> via <tt>initFinderOpts</tt>.
data FinderOpts
FinderOpts :: [FilePath] -> Bool -> Bool -> Ways -> Bool -> Maybe FilePath -> Maybe FastString -> Set ModuleName -> Set ModuleName -> Maybe FilePath -> String -> Maybe FilePath -> String -> String -> Maybe FilePath -> String -> String -> Maybe FilePath -> FinderOpts

-- | Where are we allowed to look for Modules and Source files
[finder_importPaths] :: FinderOpts -> [FilePath]

-- | When looking up a home module:
--   
--   <ul>
--   <li><a>True</a>: search interface files (e.g. in '-c' mode)</li>
--   <li><a>False</a>: search source files (e.g. in '--make' mode)</li>
--   </ul>
[finder_lookupHomeInterfaces] :: FinderOpts -> Bool

-- | Don't check that an imported interface file actually exists if it can
--   only be at one location. The interface will be reported as
--   <a>InstalledFound</a> even if the file doesn't exist, so this is only
--   useful in specific cases (e.g. to generate dependencies with `ghc -M`)
[finder_bypassHiFileCheck] :: FinderOpts -> Bool
[finder_ways] :: FinderOpts -> Ways

-- | If we encounter unknown modules, should we suggest modules that have a
--   similar name.
[finder_enableSuggestions] :: FinderOpts -> Bool
[finder_workingDirectory] :: FinderOpts -> Maybe FilePath
[finder_thisPackageName] :: FinderOpts -> Maybe FastString
[finder_hiddenModules] :: FinderOpts -> Set ModuleName
[finder_reexportedModules] :: FinderOpts -> Set ModuleName
[finder_hieDir] :: FinderOpts -> Maybe FilePath
[finder_hieSuf] :: FinderOpts -> String
[finder_hiDir] :: FinderOpts -> Maybe FilePath
[finder_hiSuf] :: FinderOpts -> String
[finder_dynHiSuf] :: FinderOpts -> String
[finder_objectDir] :: FinderOpts -> Maybe FilePath
[finder_objectSuf] :: FinderOpts -> String
[finder_dynObjectSuf] :: FinderOpts -> String
[finder_stubDir] :: FinderOpts -> Maybe FilePath
instance GHC.Show.Show GHC.Unit.Finder.Types.FinderOpts

module GHC.Types.Target

-- | A compilation target.
--   
--   A target may be supplied with the actual text of the module. If so,
--   use this instead of the file contents (this is for use in an IDE where
--   the file hasn't been saved by the user yet).
--   
--   These fields are strict because Targets are long lived.
data Target
Target :: !TargetId -> !Bool -> !UnitId -> !Maybe (InputFileBuffer, UTCTime) -> Target

-- | module or filename
[targetId] :: Target -> !TargetId

-- | object code allowed?
[targetAllowObjCode] :: Target -> !Bool

-- | id of the unit this target is part of
[targetUnitId] :: Target -> !UnitId

-- | Optional in-memory buffer containing the source code GHC should use
--   for this target instead of reading it from disk.
--   
--   Since GHC version 8.10 modules which require preprocessors such as
--   Literate Haskell or CPP to run are also supported.
--   
--   If a corresponding source file does not exist on disk this will result
--   in a <tt>SourceError</tt> exception if <tt>targetId = TargetModule
--   _</tt> is used. However together with <tt>targetId = TargetFile _</tt>
--   GHC will not complain about the file missing.
[targetContents] :: Target -> !Maybe (InputFileBuffer, UTCTime)
data TargetId

-- | A module name: search for the file
TargetModule :: !ModuleName -> TargetId

-- | A filename: preprocess &amp; parse it to find the module name. If
--   specified, the Phase indicates how to compile this file (which phase
--   to start from). Nothing indicates the starting phase should be
--   determined from the suffix of the filename.
TargetFile :: !FilePath -> !Maybe Phase -> TargetId
type InputFileBuffer = StringBuffer
pprTarget :: Target -> SDoc
pprTargetId :: TargetId -> SDoc
instance GHC.Classes.Eq GHC.Types.Target.TargetId
instance GHC.Utils.Outputable.Outputable GHC.Types.Target.Target
instance GHC.Utils.Outputable.Outputable GHC.Types.Target.TargetId


-- | Types used in the typechecker
--   
--   This module provides the Type interface for front-end parts of the
--   compiler. These parts
--   
--   <ul>
--   <li>treat "source types" as opaque: newtypes, and predicates are
--   meaningful.</li>
--   <li>look through usage types</li>
--   </ul>
module GHC.Tc.Utils.TcType
type TcType = Type
type TcSigmaType = TcType

-- | A type which has a syntactically fixed RuntimeRep as per Note [Fixed
--   RuntimeRep] in GHC.Tc.Utils.Concrete.
type TcTypeFRR = TcType

-- | A <a>TcSigmaTypeFRR</a> is a <a>TcSigmaType</a> which has a
--   syntactically fixed <a>RuntimeRep</a> in the sense of Note [Fixed
--   RuntimeRep] in GHC.Tc.Utils.Concrete.
--   
--   In particular, this means that:
--   
--   <ul>
--   <li><a>typePrimRep</a> does not panic,</li>
--   <li><a>typeLevity_maybe</a> does not return <a>Nothing</a>.</li>
--   </ul>
--   
--   This property is important in functions such as
--   <tt>matchExpectedFunTys</tt>, where we want to provide argument types
--   which have a known runtime representation. See Note [Return arguments
--   with a fixed RuntimeRep.
type TcSigmaTypeFRR = TcSigmaType
type TcRhoType = TcType
type TcTauType = TcType
type TcPredType = PredType
type TcThetaType = ThetaType

-- | Type variable that might be a metavariable
type TcTyVar = Var
type TcTyVarSet = TyVarSet
type TcDTyVarSet = DTyVarSet
type TcTyCoVarSet = TyCoVarSet
type TcDTyCoVarSet = DTyCoVarSet
type TcKind = Kind
type TcCoVar = CoVar
type TcTyCoVar = Var
type TcTyVarBinder = TyVarBinder
type TcInvisTVBinder = InvisTVBinder
type TcReqTVBinder = ReqTVBinder
type TcTyCon = TyCon
type MonoTcTyCon = TcTyCon
type PolyTcTyCon = TcTyCon
type TcTyConBinder = TyConBinder

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied ty = ty

-- | An expected type to check against during type-checking. See Note
--   [ExpType] in <a>GHC.Tc.Utils.TcMType</a>, where you'll also find
--   manipulators.
data ExpType
Check :: TcType -> ExpType
Infer :: !InferResult -> ExpType
data InferResult
IR :: Unique -> TcLevel -> Maybe FixedRuntimeRepContext -> IORef (Maybe TcType) -> InferResult

-- | This <a>Unique</a> is for debugging only
[ir_uniq] :: InferResult -> Unique

-- | See Note [TcLevel of ExpType] in GHC.Tc.Utils.TcMType
[ir_lvl] :: InferResult -> TcLevel

-- | See Note [FixedRuntimeRep context in ExpType] in GHC.Tc.Utils.TcMType
[ir_frr] :: InferResult -> Maybe FixedRuntimeRepContext

-- | The type that fills in this hole should be a <tt>Type</tt>, that is,
--   its kind should be <tt>TYPE rr</tt> for some <tt>rr ::
--   RuntimeRep</tt>.
--   
--   Additionally, if the <a>ir_frr</a> field is <tt>Just frr_orig</tt>
--   then <tt>rr</tt> must be concrete, in the sense of Note [Concrete
--   types] in GHC.Tc.Utils.Concrete.
[ir_ref] :: InferResult -> IORef (Maybe TcType)

-- | An <a>ExpType</a> which has a fixed RuntimeRep.
--   
--   For a <a>Check</a> <a>ExpType</a>, the stored <a>TcType</a> must have
--   a fixed RuntimeRep. For an <a>Infer</a> <a>ExpType</a>, the
--   <a>ir_frr</a> field must be of the form <tt>Just frr_orig</tt>.
type ExpTypeFRR = ExpType
type ExpSigmaType = ExpType

-- | Like <a>TcSigmaTypeFRR</a>, but for an expected type.
--   
--   See <a>ExpTypeFRR</a>.
type ExpSigmaTypeFRR = ExpTypeFRR
type ExpRhoType = ExpType

-- | Make an <a>ExpType</a> suitable for checking.
mkCheckExpType :: TcType -> ExpType

-- | What to expect for an argument to a rebindable-syntax operator. Quite
--   like <a>Type</a>, but allows for holes to be filled in by tcSyntaxOp.
--   The callback called from tcSyntaxOp gets a list of types; the meaning
--   of these types is determined by a left-to-right depth-first traversal
--   of the <a>SyntaxOpType</a> tree. So if you pass in
--   
--   <pre>
--   SynAny `SynFun` (SynList `SynFun` SynType Int) `SynFun` SynAny
--   </pre>
--   
--   you'll get three types back: one for the first <a>SynAny</a>, the
--   <i>element</i> type of the list, and one for the last <a>SynAny</a>.
--   You don't get anything for the <a>SynType</a>, because you've said
--   positively that it should be an Int, and so it shall be.
--   
--   You'll also get three multiplicities back: one for each function
--   arrow. See also Note [Linear types] in Multiplicity.
--   
--   This is defined here to avoid defining it in <a>GHC.Tc.Gen.Expr</a>
--   boot file.
data SyntaxOpType

-- | Any type
SynAny :: SyntaxOpType

-- | A rho type, skolemised or instantiated as appropriate
SynRho :: SyntaxOpType

-- | A list type. You get back the element type of the list
SynList :: SyntaxOpType

-- | A function.
SynFun :: SyntaxOpType -> SyntaxOpType -> SyntaxOpType

-- | A known type.
SynType :: ExpType -> SyntaxOpType
infixr 0 `SynFun`

-- | Like <a>SynType</a> but accepts a regular TcType
synKnownType :: TcType -> SyntaxOpType

-- | Like <tt>mkFunTys</tt> but for <a>SyntaxOpType</a>
mkSynFunTys :: [SyntaxOpType] -> ExpType -> SyntaxOpType
newtype TcLevel
TcLevel :: Int -> TcLevel
topTcLevel :: TcLevel
pushTcLevel :: TcLevel -> TcLevel
isTopTcLevel :: TcLevel -> Bool
strictlyDeeperThan :: TcLevel -> TcLevel -> Bool
deeperThanOrSame :: TcLevel -> TcLevel -> Bool
sameDepthAs :: TcLevel -> TcLevel -> Bool
tcTypeLevel :: TcType -> TcLevel
tcTyVarLevel :: TcTyVar -> TcLevel
maxTcLevel :: TcLevel -> TcLevel -> TcLevel
data TcTyVarDetails
SkolemTv :: SkolemInfo -> TcLevel -> Bool -> TcTyVarDetails
RuntimeUnk :: TcTyVarDetails
MetaTv :: MetaInfo -> IORef MetaDetails -> TcLevel -> TcTyVarDetails
[mtv_info] :: TcTyVarDetails -> MetaInfo
[mtv_ref] :: TcTyVarDetails -> IORef MetaDetails
[mtv_tclvl] :: TcTyVarDetails -> TcLevel
pprTcTyVarDetails :: TcTyVarDetails -> SDoc
vanillaSkolemTvUnk :: HasCallStack => TcTyVarDetails
data MetaDetails
Flexi :: MetaDetails
Indirect :: TcType -> MetaDetails

-- | What restrictions are on this metavariable around unification? These
--   are checked in GHC.Tc.Utils.Unify.startSolvingByUnification.
data MetaInfo

-- | This MetaTv is an ordinary unification variable A TauTv is always
--   filled in with a tau-type, which never contains any ForAlls.
TauTv :: MetaInfo

-- | A variant of TauTv, except that it should not be unified with a type,
--   only with a type variable See Note [TyVarTv] in GHC.Tc.Utils.TcMType
TyVarTv :: MetaInfo

-- | A unification variable used in the GHCi debugger. It <i>is</i> allowed
--   to unify with a polytype, unlike TauTv
RuntimeUnkTv :: MetaInfo
CycleBreakerTv :: MetaInfo

-- | A unification variable that can only be unified with a concrete type,
--   in the sense of Note [Concrete types] in GHC.Tc.Utils.Concrete. See
--   Note [ConcreteTv] in GHC.Tc.Utils.Concrete. See also Note [The
--   Concrete mechanism] in GHC.Tc.Utils.Concrete for an overview of how
--   this works in context.
ConcreteTv :: ConcreteTvOrigin -> MetaInfo
skolemSkolInfo :: TcTyVar -> SkolemInfo
isImmutableTyVar :: TyVar -> Bool
isSkolemTyVar :: TcTyVar -> Bool
isMetaTyVar :: TcTyVar -> Bool
isMetaTyVarTy :: TcType -> Bool
isTyVarTy :: Type -> Bool
tcIsTcTyVar :: TcTyVar -> Bool
isTyVarTyVar :: Var -> Bool
isOverlappableTyVar :: TcTyVar -> Bool
isTyConableTyVar :: TcTyVar -> Bool

-- | What caused us to create a <a>ConcreteTv</a> metavariable? See Note
--   [ConcreteTv] in GHC.Tc.Utils.Concrete.
data ConcreteTvOrigin

-- | A <a>ConcreteTv</a> used to enforce the representation-polymorphism
--   invariants.
--   
--   See <a>FixedRuntimeRepOrigin</a> for more information.
ConcreteFRR :: FixedRuntimeRepOrigin -> ConcreteTvOrigin

-- | Is this type variable a concrete type variable, i.e. it is a
--   metavariable with <a>ConcreteTv</a> <a>MetaInfo</a>?
--   
--   Returns the <a>ConcreteTvOrigin</a> stored in the type variable if so,
--   or <a>Nothing</a> otherwise.
isConcreteTyVar_maybe :: TcTyVar -> Maybe ConcreteTvOrigin

-- | Is this type variable a concrete type variable, i.e. it is a
--   metavariable with <a>ConcreteTv</a> <a>MetaInfo</a>?
isConcreteTyVar :: TcTyVar -> Bool

-- | Is this type concrete type variable, i.e. a metavariable with
--   <a>ConcreteTv</a> <a>MetaInfo</a>?
isConcreteTyVarTy :: TcType -> Bool

-- | Is this type a concrete type variable? If so, return the associated
--   <a>TcTyVar</a> and <a>ConcreteTvOrigin</a>.
isConcreteTyVarTy_maybe :: TcType -> Maybe (TcTyVar, ConcreteTvOrigin)
isAmbiguousTyVar :: TcTyVar -> Bool
isCycleBreakerTyVar :: TcTyVar -> Bool
metaTyVarRef :: TyVar -> IORef MetaDetails
metaTyVarInfo :: TcTyVar -> MetaInfo
isFlexi :: MetaDetails -> Bool
isIndirect :: MetaDetails -> Bool
isRuntimeUnkSkol :: TyVar -> Bool
metaTyVarTcLevel :: TcTyVar -> TcLevel
setMetaTyVarTcLevel :: TcTyVar -> TcLevel -> TcTyVar
metaTyVarTcLevel_maybe :: TcTyVar -> Maybe TcLevel
isTouchableMetaTyVar :: TcLevel -> TcTyVar -> Bool
isPromotableMetaTyVar :: TcTyVar -> Bool
findDupTyVarTvs :: [(Name, TcTyVar)] -> [(Name, Name)]
mkTyVarNamePairs :: [TyVar] -> [(Name, TyVar)]

-- | Make a sigma ty where all type variables are <a>Inferred</a>. That is,
--   they cannot be used with visible type application.
mkInfSigmaTy :: HasDebugCallStack => [TyCoVar] -> [PredType] -> Type -> Type

-- | Make a sigma ty where all type variables are "specified". That is,
--   they can be used with visible type application
mkSpecSigmaTy :: HasDebugCallStack => [TyVar] -> [PredType] -> Type -> Type
mkSigmaTy :: HasDebugCallStack => [ForAllTyBinder] -> [PredType] -> Type -> Type
mkPhiTy :: HasDebugCallStack => [PredType] -> Type -> Type
tcMkPhiTy :: HasDebugCallStack => [PredType] -> Type -> Type
tcMkDFunSigmaTy :: [TyVar] -> ThetaType -> Type -> Type
tcMkDFunPhiTy :: HasDebugCallStack => [PredType] -> Type -> Type

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: HasDebugCallStack => Type -> TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>
getTyVar_maybe :: Type -> Maybe TyVar

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind ty
getCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)
tcSplitForAllTyVarBinder_maybe :: Type -> Maybe (TyVarBinder, Type)

-- | Like <a>tcSplitPiTys</a>, but splits off only named binders, returning
--   just the tyvars.
tcSplitForAllTyVars :: Type -> ([TyVar], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders.
tcSplitForAllInvisTyVars :: Type -> ([TyVar], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits a <a>ForAllTy</a> if
--   <tt>argf_pred argf</tt> is <a>True</a>, where <tt>argf</tt> is the
--   visibility of the <tt>ForAllTy</tt>'s binder and <tt>argf_pred</tt> is
--   a predicate over visibilities provided as an argument to this
--   function.
tcSplitSomeForAllTyVars :: (ForAllTyFlag -> Bool) -> Type -> ([TyVar], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Required</a> type variable binders. All split tyvars are annotated
--   with <tt>()</tt>.
tcSplitForAllReqTVBinders :: Type -> ([TcReqTVBinder], Type)

-- | Like <a>tcSplitForAllTyVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders. All split tyvars are annotated
--   with their <a>Specificity</a>.
tcSplitForAllInvisTVBinders :: Type -> ([TcInvisTVBinder], Type)

-- | Splits a forall type into a list of <a>PiTyVarBinder</a>s and the
--   inner type. Always succeeds, even if it returns an empty list.
tcSplitPiTys :: Type -> ([PiTyVarBinder], Type)

-- | Splits a type into a PiTyVarBinder and a body, if possible.
tcSplitPiTy_maybe :: Type -> Maybe (PiTyVarBinder, Type)

-- | Like <a>tcSplitForAllTyVars</a>, but splits off only named binders.
tcSplitForAllTyVarBinders :: Type -> ([TyVarBinder], Type)
tcSplitPhiTy :: Type -> (ThetaType, Type)
tcSplitPredFunTy_maybe :: Type -> Maybe (PredType, Type)
tcSplitFunTy_maybe :: Type -> Maybe (Scaled Type, Type)
tcSplitFunTys :: Type -> ([Scaled Type], Type)
tcFunArgTy :: Type -> Scaled Type
tcFunResultTy :: Type -> Type

-- | Strips off n *visible* arguments and returns the resulting type
tcFunResultTyN :: HasDebugCallStack => Arity -> Type -> Type

-- | Split off exactly the specified number argument types Returns (Left m)
--   if there are <tt>m</tt> missing arrows in the type (Right (tys,res))
--   if the type looks like t1 -&gt; ... -&gt; tn -&gt; res
tcSplitFunTysN :: Arity -> TcRhoType -> Either Arity ([Scaled TcSigmaType], TcSigmaType)
tcSplitTyConApp :: Type -> (TyCon, [Type])

-- | tcSplitTyConApp_maybe splits a type constructor application into its
--   type constructor and applied types.
--   
--   Differs from splitTyConApp_maybe in that it does *not* split types
--   headed with (=&gt;), as that's not a TyCon in the type-checker.
--   
--   Note that this may fail (in funTyConAppTy_maybe) in the case of a
--   <a>FunTy</a> with an argument of unknown kind <a>FunTy</a> (e.g.
--   `FunTy (a :: k) Int`, since the kind of <tt>a</tt> isn't of the form
--   `TYPE rep`. This isn't usually a problem but may be temporarily the
--   cas during canonicalization: see Note [Decomposing FunTy] in
--   GHC.Tc.Solver.Canonical and Note [The Purely Kinded Type Invariant
--   (PKTI)] in GHC.Tc.Gen.HsType, Wrinkle around FunTy
--   
--   Consequently, you may need to zonk your type before using this
--   function.
tcSplitTyConApp_maybe :: HasCallStack => Type -> Maybe (TyCon, [Type])
tcTyConAppTyCon :: Type -> TyCon

-- | Like <tt>tcRepSplitTyConApp_maybe</tt>, but only returns the
--   <a>TyCon</a>.
tcTyConAppTyCon_maybe :: Type -> Maybe TyCon
tcTyConAppArgs :: Type -> [Type]
tcSplitAppTy_maybe :: Type -> Maybe (Type, Type)
tcSplitAppTy :: Type -> (Type, Type)
tcSplitAppTys :: Type -> (Type, [Type])

-- | Just like splitAppTyNoView_maybe, but does not split (c =&gt; t) See
--   Note [Decomposing fat arrow c=&gt;t]
tcSplitAppTyNoView_maybe :: Type -> Maybe (Type, Type)

-- | Split a sigma type into its parts. This only splits <i>invisible</i>
--   type variable binders, as these are the only forms of binder that the
--   typechecker will implicitly instantiate.
tcSplitSigmaTy :: Type -> ([TyVar], ThetaType, Type)

-- | Split a sigma type into its parts, going underneath as many arrows and
--   foralls as possible. See Note [tcSplitNestedSigmaTys]
tcSplitNestedSigmaTys :: Type -> ([TyVar], ThetaType, Type)
isSigmaTy :: TcType -> Bool
isRhoTy :: TcType -> Bool

-- | Like <a>isRhoTy</a>, but also says <a>True</a> for <a>Infer</a> types
isRhoExpTy :: ExpType -> Bool
isOverloadedTy :: Type -> Bool

-- | Is the type inhabited by machine floating-point numbers?
--   
--   Used to check that we don't use floating-point literal patterns in
--   Core.
--   
--   See #9238 and Note [Rules for floating-point comparisons] in
--   GHC.Core.Opt.ConstantFold.
isFloatingPrimTy :: Type -> Bool
isDoubleTy :: Type -> Bool
isFloatTy :: Type -> Bool
isIntTy :: Type -> Bool
isWordTy :: Type -> Bool

-- | Is a type <a>String</a>?
isStringTy :: Type -> Bool
isIntegerTy :: Type -> Bool
isNaturalTy :: Type -> Bool
isBoolTy :: Type -> Bool
isUnitTy :: Type -> Bool
isCharTy :: Type -> Bool
isTauTy :: Type -> Bool
isTauTyCon :: TyCon -> Bool
tcIsTyVarTy :: Type -> Bool
isPredTy :: HasDebugCallStack => Type -> Bool
isTyVarClassPred :: PredType -> Bool
checkValidClsArgs :: Bool -> Class -> [KindOrType] -> Bool
hasTyVarHead :: Type -> Bool
isRigidTy :: TcType -> Bool

-- | Type equality on source types. Does not look through
--   <tt>newtypes</tt>, <a>PredType</a>s or type families, but it does look
--   through type synonyms. This first checks that the kinds of the types
--   are equal and then checks whether the types are equal, ignoring casts
--   and coercions. (The kind check is a recursive call, but since all
--   kinds have type <tt>Type</tt>, there is no need to check the types of
--   kinds.) See also Note [Non-trivial definitional equality] in
--   <a>GHC.Core.TyCo.Rep</a>.
eqType :: Type -> Type -> Bool

-- | Type equality on lists of types, looking through type synonyms but not
--   newtypes.
eqTypes :: [Type] -> [Type] -> Bool
nonDetCmpType :: Type -> Type -> Ordering
nonDetCmpTypes :: [Type] -> [Type] -> Ordering

-- | Compare types with respect to a (presumably) non-empty <a>RnEnv2</a>.
eqTypeX :: RnEnv2 -> Type -> Type -> Bool

-- | Like <tt>pickyEqTypeVis</tt>, but returns a Bool for convenience
pickyEqType :: Type -> Type -> Bool

-- | tcEqType implements typechecker equality It behaves just like eqType,
--   but is implemented differently (for now)
tcEqType :: HasDebugCallStack => Type -> Type -> Bool
tcEqKind :: HasDebugCallStack => Kind -> Kind -> Bool

-- | Just like <a>tcEqType</a>, but will return True for types of different
--   kinds as long as their non-coercion structure is identical.
tcEqTypeNoKindCheck :: Type -> Type -> Bool

-- | Like <a>tcEqType</a>, but returns True if the <i>visible</i> part of
--   the types are equal, even if they are really unequal (in the invisible
--   bits)
tcEqTypeVis :: Type -> Type -> Bool

-- | Check whether two TyConApps are the same; if the number of arguments
--   are different, just checks the common prefix of arguments.
tcEqTyConApps :: TyCon -> [Type] -> TyCon -> [Type] -> Bool

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
eqForAllVis :: ForAllTyFlag -> ForAllTyFlag -> Bool
eqVarBndrs :: RnEnv2 -> [Var] -> [Var] -> Maybe RnEnv2
deNoteType :: Type -> Type
orphNamesOfType :: Type -> NameSet
orphNamesOfCo :: Coercion -> NameSet
orphNamesOfTypes :: [Type] -> NameSet
orphNamesOfCoCon :: CoAxiom br -> NameSet
getDFunTyKey :: Type -> OccName
evVarPred :: EvVar -> PredType

-- | Returns the (kind, type) variables in a type that are as-yet-unknown:
--   metavariables and RuntimeUnks
ambigTkvsOfTy :: TcType -> ([Var], [Var])
mkMinimalBySCs :: forall a. (a -> PredType) -> [a] -> [a]
transSuperClasses :: PredType -> [PredType]
pickCapturedPreds :: TyVarSet -> TcThetaType -> TcThetaType
immSuperClasses :: Class -> [Type] -> [PredType]
boxEqPred :: EqRel -> Type -> Type -> Maybe (Class, [Type])
isImprovementPred :: PredType -> Bool

-- | Finds outermost type-family applications occurring in a type, after
--   expanding synonyms. In the list (F, tys) that is returned we guarantee
--   that tys matches F's arity. For example, given type family F a :: *
--   -&gt; * (arity 1) calling tcTyFamInsts on (Maybe (F Int Bool) will
--   return (F, [Int]), not (F, [Int,Bool])
--   
--   This is important for its use in deciding termination of type
--   instances (see #11581). E.g. type instance G [Int] = ...(F Int &lt;big
--   type&gt;)... we don't need to take &lt;big type&gt; into account when
--   asking if the calls on the RHS are smaller than the LHS
tcTyFamInsts :: Type -> [(TyCon, [Type])]

-- | Like <a>tcTyFamInsts</a>, except that the output records whether the
--   type family and its arguments occur as an <i>invisible</i> argument in
--   some type application. This information is useful because it helps GHC
--   know when to turn on <tt>-fprint-explicit-kinds</tt> during error
--   reporting so that users can actually see the type family being
--   mentioned.
--   
--   As an example, consider:
--   
--   <pre>
--   class C a
--   data T (a :: k)
--   type family F a :: k
--   instance C (T @(F Int) (F Bool))
--   </pre>
--   
--   There are two occurrences of the type family <tt>F</tt> in that
--   <tt>C</tt> instance, so <tt><a>tcTyFamInstsAndVis</a> (C (T @(F Int)
--   (F Bool)))</tt> will return:
--   
--   <pre>
--   [ (<a>True</a>,  F, [Int])
--   , (<a>False</a>, F, [Bool]) ]
--   </pre>
--   
--   <tt>F Int</tt> is paired with <a>True</a> since it appears as an
--   <i>invisible</i> argument to <tt>C</tt>, whereas <tt>F Bool</tt> is
--   paired with <a>False</a> since it appears an a <i>visible</i> argument
--   to <tt>C</tt>.
--   
--   See also <tt>Note [Kind arguments in error messages]</tt> in
--   <a>GHC.Tc.Errors</a>.
tcTyFamInstsAndVis :: Type -> [(Bool, TyCon, [Type])]

-- | In an application of a <a>TyCon</a> to some arguments, find the
--   outermost occurrences of type family applications within the
--   arguments. This function will not consider the <a>TyCon</a> itself
--   when checking for type family applications.
--   
--   See <a>tcTyFamInstsAndVis</a> for more details on how this works (as
--   this function is called inside of <a>tcTyFamInstsAndVis</a>).
tcTyConAppTyFamInstsAndVis :: TyCon -> [Type] -> [(Bool, TyCon, [Type])]

-- | Check that a type does not contain any type family applications.
isTyFamFree :: Type -> Bool
exactTyCoVarsOfType :: Type -> TyCoVarSet
exactTyCoVarsOfTypes :: [Type] -> TyCoVarSet
anyRewritableTyVar :: EqRel -> (EqRel -> TcTyVar -> Bool) -> TcType -> Bool
anyRewritableTyFamApp :: EqRel -> (EqRel -> TyCon -> [TcType] -> Bool) -> TcType -> Bool

-- | Reason why a type in an FFI signature is invalid
data IllegalForeignTypeReason
TypeCannotBeMarshaled :: !Type -> TypeCannotBeMarshaledReason -> IllegalForeignTypeReason
ForeignDynNotPtr :: !Type -> !Type -> IllegalForeignTypeReason
SafeHaskellMustBeInIO :: IllegalForeignTypeReason
IOResultExpected :: IllegalForeignTypeReason
UnexpectedNestedForall :: IllegalForeignTypeReason
LinearTypesNotAllowed :: IllegalForeignTypeReason
OneArgExpected :: IllegalForeignTypeReason
AtLeastOneArgExpected :: IllegalForeignTypeReason

-- | Reason why a type cannot be marshalled through the FFI.
data TypeCannotBeMarshaledReason
NotADataType :: TypeCannotBeMarshaledReason
NewtypeDataConNotInScope :: !Maybe TyCon -> TypeCannotBeMarshaledReason
UnliftedFFITypesNeeded :: TypeCannotBeMarshaledReason
NotABoxedMarshalableTyCon :: TypeCannotBeMarshaledReason
ForeignLabelNotAPtr :: TypeCannotBeMarshaledReason
NotSimpleUnliftedType :: TypeCannotBeMarshaledReason
NotBoxedKindAny :: TypeCannotBeMarshaledReason
isFFIArgumentTy :: DynFlags -> Safety -> Type -> Validity' IllegalForeignTypeReason
isFFIImportResultTy :: DynFlags -> Type -> Validity' IllegalForeignTypeReason
isFFIExportResultTy :: Type -> Validity' IllegalForeignTypeReason
isFFIExternalTy :: Type -> Validity' IllegalForeignTypeReason
isFFIDynTy :: Type -> Type -> Validity' IllegalForeignTypeReason
isFFIPrimArgumentTy :: DynFlags -> Type -> Validity' IllegalForeignTypeReason
isFFIPrimResultTy :: DynFlags -> Type -> Validity' IllegalForeignTypeReason
isFFILabelTy :: Type -> Validity' IllegalForeignTypeReason
isFunPtrTy :: Type -> Bool
tcSplitIOType_maybe :: Type -> Maybe (TyCon, Type)

-- | The Paterson size of a given type, in the sense of Note [Paterson
--   conditions] in GHC.Tc.Validity
--   
--   <ul>
--   <li>after expanding synonyms,</li>
--   <li>ignoring coercions (as they are not user written).</li>
--   </ul>
data PatersonSize

-- | The type mentions a type family, so the size could be anything.
PS_TyFam :: TyCon -> PatersonSize

-- | The type does not mention a type family.
PS_Vanilla :: [TyVar] -> Int -> PatersonSize

-- | free tyvars, including repetitions;
[ps_tvs] :: PatersonSize -> [TyVar]

-- | number of type constructors and variables
[ps_size] :: PatersonSize -> Int

-- | Why was the LHS <a>PatersonSize</a> not strictly smaller than the RHS
--   <a>PatersonSize</a>?
--   
--   See Note [Paterson conditions] in GHC.Tc.Validity.
data PatersonSizeFailure

-- | Either side contains a type family.
PSF_TyFam :: TyCon -> PatersonSizeFailure

-- | The size of the LHS is not strictly less than the size of the RHS.
PSF_Size :: PatersonSizeFailure

-- | These type variables appear more often in the LHS than in the RHS.
PSF_TyVar :: [TyVar] -> PatersonSizeFailure

-- | <tt>ltPatersonSize ps1 ps2</tt> returns:
--   
--   <ul>
--   <li><tt>Nothing</tt> iff <tt>ps1</tt> is definitely strictly smaller
--   than <tt>ps2</tt>,</li>
--   <li><tt>Just ps_fail</tt> otherwise; <tt>ps_fail</tt> says what went
--   wrong.</li>
--   </ul>
ltPatersonSize :: PatersonSize -> PatersonSize -> Maybe PatersonSizeFailure
pSizeZero :: PatersonSize
pSizeOne :: PatersonSize
pSizeType :: Type -> PatersonSize
pSizeTypeX :: VarSet -> Type -> PatersonSize
pSizeTypes :: [Type] -> PatersonSize
pSizeClassPred :: Class -> [Type] -> PatersonSize
pSizeClassPredX :: VarSet -> Class -> [Type] -> PatersonSize
pSizeTyConApp :: TyCon -> [Type] -> PatersonSize
noMoreTyVars :: [TyVar] -> [TyVar] -> [TyVar]
allDistinctTyVars :: TyVarSet -> [KindOrType] -> Bool
type TypeSize = IntWithInf
sizeType :: Type -> TypeSize
sizeTypes :: [Type] -> TypeSize

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | When this says <a>True</a>, ignore this class constraint during a
--   termination check See (PS1) in Note [The PatersonSize of a type]
isTerminatingClass :: Class -> Bool
isStuckTypeFamily :: TyCon -> Bool

-- | The key type representing kinds in the compiler.
type Kind = Type
liftedTypeKind :: Type
constraintKind :: Kind

-- | Returns True if the argument is (lifted) Type or Constraint See Note
--   [TYPE and CONSTRAINT] in GHC.Builtin.Types.Prim
isLiftedTypeKind :: Kind -> Bool

-- | Returns True if the kind classifies unlifted types (like 'Int#') and
--   False otherwise. Note that this returns False for
--   representation-polymorphic kinds, which may be specialized to a kind
--   that classifies unlifted types.
isUnliftedTypeKind :: Kind -> Bool

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, TYPE Lifted, TYPE IntRep, TYPE v, Constraint.
--   
--   True of a kind `TYPE _` or `CONSTRAINT _`
isTYPEorCONSTRAINT :: Kind -> Bool
data Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]

-- | A <a>PiTyBinder</a> represents an argument to a function. PiTyBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [PiTyBinders]
data PiTyBinder

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Specified :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: ForAllTyBinder -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [ForAllTyBinder] -> Type -> Type

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Inferred</a>, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type

-- | Make a dependent forall over an <a>Inferred</a> variable
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTy</a>, but tv should be a tyvar
mkInfForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInfForAllTys :: [TyVar] -> Type -> Type
mkVisFunTy :: HasDebugCallStack => Mult -> Type -> Type -> Type

-- | Make nested arrow types | Special, common, case: Arrow type with mult
--   Many
mkVisFunTyMany :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
mkVisFunTysMany :: [Type] -> Type -> Type
mkScaledFunTys :: HasDebugCallStack => [Scaled Type] -> Type -> Type
mkInvisFunTy :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkInvisFunTy`
mkInvisFunTys :: HasDebugCallStack => [Type] -> Type -> Type

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type
mkAppTys :: Type -> [Type] -> Type

-- | (mkTyConTy tc) returns (TyConApp tc []) but arranges to share that
--   TyConApp among all calls See Note [Sharing nullary TyConApps] So it's
--   just an alias for tyConNullaryTy!
mkTyConTy :: TyCon -> Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkTyCoVarTy :: TyCoVar -> Type
mkTyCoVarTys :: [TyCoVar] -> [Type]
isClassPred :: PredType -> Bool
isEqPrimPred :: PredType -> Bool
isIPLikePred :: Type -> Bool
isEqPred :: PredType -> Bool
isEqPredClass :: Class -> Bool
mkClassPred :: Class -> [Type] -> PredType
tcSplitQuantPredTy :: Type -> ([TyVar], [Type], PredType)
tcSplitDFunTy :: Type -> ([TyVar], [Type], Class, [Type])
tcSplitDFunHead :: Type -> (Class, [Type])
tcSplitMethodTy :: Type -> ([TyVar], PredType, Type)

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Checks that a kind of the form <a>Type</a>, <tt>Constraint</tt> or
--   <tt>'TYPE r</tt> is concrete. See <a>isConcrete</a>.
--   
--   <b>Precondition:</b> The type has kind `TYPE blah` or `CONSTRAINT
--   blah`
isFixedRuntimeRepKind :: HasDebugCallStack => Kind -> Bool

-- | Does this binder bind a visible argument?
isVisiblePiTyBinder :: PiTyBinder -> Bool

-- | Does this binder bind an invisible argument?
isInvisiblePiTyBinder :: PiTyBinder -> Bool

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst

-- | Generates the in-scope set for the <a>Subst</a> from the types in the
--   incoming environment. No CoVars or Ids, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> Subst

-- | Generates the in-scope set for the <tt>TCvSubst</tt> from the types in
--   the incoming environment. No CoVars, please! The InScopeSet is just a
--   thunk so with a bit of luck it'll never be evaluated
mkTvSubstPrs :: [(TyVar, Type)] -> Subst
notElemSubst :: Var -> Subst -> Bool
unionSubst :: Subst -> Subst -> Subst
getTvSubstEnv :: Subst -> TvSubstEnv

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeSet :: Subst -> VarSet -> Subst
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
lookupTyVar :: Subst -> TyVar -> Maybe Type
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst
substTyVarBndr :: HasDebugCallStack => Subst -> TyVar -> (Subst, TyVar)

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that Note [The substitution invariant]
--   holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst
isInScope :: Var -> Subst -> Bool
mkSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> IdSubstEnv -> Subst

-- | Make a TCvSubst with specified tyvar subst and empty covar subst
mkTvSubst :: InScopeSet -> TvSubstEnv -> Subst

-- | The InScopeSet is just a thunk so with a bit of luck it'll never be
--   evaluated
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasDebugCallStack => Subst -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasDebugCallStack => Subst -> [Type] -> [Type]
substScaledTys :: HasDebugCallStack => Subst -> [Scaled Type] -> [Scaled Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasDebugCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Substitute covars within a type
substTyWithCoVars :: [CoVar] -> [Coercion] -> Type -> Type

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: Subst -> Type -> Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: Subst -> [Type] -> [Type]
substScaledTyUnchecked :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: Subst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: Subst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasDebugCallStack => Subst -> ThetaType -> ThetaType

-- | Is the given type definitely unlifted? See
--   <a>Type#type_classification</a> for what an unlifted type is.
--   
--   Panics on representation-polymorphic types; See
--   <a>mightBeUnliftedType</a> for a more approximate predicate that
--   behaves better in the presence of representation polymorphism.
isUnliftedType :: HasDebugCallStack => Type -> Bool
isUnboxedTupleType :: Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | This function strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   <a>Nothing</a> if there is nothing to look through.
--   
--   This function does not look through type family applications.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV
tyCoFVsOfTypes :: [Type] -> FV

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet

-- | Returns free variables of types, including kind variables as a
--   deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
tyCoVarsOfTypesDSet :: [Type] -> DTyCoVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in
--   deterministic order. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeList :: Type -> [TyCoVar]

-- | Returns free variables of types, including kind variables as a
--   deterministically ordered list. For type synonyms it does <i>not</i>
--   expand the synonym.
tyCoVarsOfTypesList :: [Type] -> [TyCoVar]
noFreeVarsOfType :: Type -> Bool
pprKind :: Kind -> SDoc
pprParendKind :: Kind -> SDoc
pprSigmaType :: Type -> SDoc
pprType :: Type -> SDoc
pprParendType :: Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc
pprTheta :: ThetaType -> SDoc
pprParendTheta :: ThetaType -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
pprClassPred :: Class -> [Type] -> SDoc
pprTCvBndr :: ForAllTyBinder -> SDoc
pprTCvBndrs :: [ForAllTyBinder] -> SDoc

-- | For every arg a tycon can take, the returned list says True if the
--   argument is taken visibly, and False otherwise. Ends with an infinite
--   tail of Trues to allow for oversaturation.
tcTyConVisibilities :: TyCon -> [Bool]

-- | If the tycon is applied to the types, is the next argument visible?
isNextTyConArgVisible :: TyCon -> [Type] -> Bool

-- | Should this type be applied to a visible argument?
isNextArgVisible :: TcType -> Bool
instance GHC.Classes.Ord GHC.Tc.Utils.TcType.TcLevel
instance GHC.Classes.Eq GHC.Tc.Utils.TcType.TcLevel
instance GHC.Generics.Generic GHC.Tc.Utils.TcType.TypeCannotBeMarshaledReason
instance GHC.Generics.Generic GHC.Tc.Utils.TcType.IllegalForeignTypeReason
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.PatersonSize
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.ExpType
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.InferResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.TcTyVarDetails
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.TcLevel
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.MetaInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcType.MetaDetails

module GHC.Tc.Types.Evidence
data HsWrapper
WpHole :: HsWrapper
WpCompose :: HsWrapper -> HsWrapper -> HsWrapper
WpFun :: HsWrapper -> HsWrapper -> Scaled TcTypeFRR -> HsWrapper
WpCast :: TcCoercionR -> HsWrapper
WpEvLam :: EvVar -> HsWrapper
WpEvApp :: EvTerm -> HsWrapper
WpTyLam :: TyVar -> HsWrapper
WpTyApp :: KindOrType -> HsWrapper
WpLet :: TcEvBinds -> HsWrapper
WpMultCoercion :: Coercion -> HsWrapper
(<.>) :: HsWrapper -> HsWrapper -> HsWrapper
mkWpTyApps :: [Type] -> HsWrapper
mkWpEvApps :: [EvTerm] -> HsWrapper
mkWpEvVarApps :: [EvVar] -> HsWrapper
mkWpTyLams :: [TyVar] -> HsWrapper
mkWpEvLams :: [Var] -> HsWrapper
mkWpLet :: TcEvBinds -> HsWrapper

-- | Smart constructor to create a <a>WpFun</a> <a>HsWrapper</a>.
--   
--   PRECONDITION: the "from" type of the first wrapper must have a
--   syntactically fixed RuntimeRep (see Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete).
mkWpFun :: HsWrapper -> HsWrapper -> Scaled TcTypeFRR -> TcType -> HsWrapper
mkWpCastN :: TcCoercionN -> HsWrapper
mkWpCastR :: TcCoercionR -> HsWrapper
mkWpEta :: [Id] -> HsWrapper -> HsWrapper
collectHsWrapBinders :: HsWrapper -> ([Var], HsWrapper)
idHsWrapper :: HsWrapper
isIdHsWrapper :: HsWrapper -> Bool
pprHsWrapper :: HsWrapper -> (Bool -> SDoc) -> SDoc

-- | Identifies the <i>lambda-bound</i> dictionaries of an
--   <a>HsWrapper</a>. This is used (only) to allow the pattern-match
--   overlap checker to know what Given dictionaries are in scope.
--   
--   We specifically do not collect dictionaries bound in a <a>WpLet</a>.
--   These are either superclasses of lambda-bound ones, or (extremely
--   numerous) results of binding Wanted dictionaries. We definitely don't
--   want all those cluttering up the Given dictionaries for pattern-match
--   overlap checking!
hsWrapDictBinders :: HsWrapper -> Bag DictId
data TcEvBinds
TcEvBinds :: EvBindsVar -> TcEvBinds
EvBinds :: Bag EvBind -> TcEvBinds
data EvBindsVar
EvBindsVar :: Unique -> IORef EvBindMap -> IORef CoVarSet -> EvBindsVar
[ebv_uniq] :: EvBindsVar -> Unique
[ebv_binds] :: EvBindsVar -> IORef EvBindMap
[ebv_tcvs] :: EvBindsVar -> IORef CoVarSet
CoEvBindsVar :: Unique -> IORef CoVarSet -> EvBindsVar
[ebv_uniq] :: EvBindsVar -> Unique
[ebv_tcvs] :: EvBindsVar -> IORef CoVarSet
newtype EvBindMap
EvBindMap :: DVarEnv EvBind -> EvBindMap
[ev_bind_varenv] :: EvBindMap -> DVarEnv EvBind
emptyEvBindMap :: EvBindMap
extendEvBinds :: EvBindMap -> EvBind -> EvBindMap
lookupEvBind :: EvBindMap -> EvVar -> Maybe EvBind
evBindMapBinds :: EvBindMap -> Bag EvBind
foldEvBindMap :: (EvBind -> a -> a) -> a -> EvBindMap -> a
nonDetStrictFoldEvBindMap :: (EvBind -> a -> a) -> a -> EvBindMap -> a
filterEvBindMap :: (EvBind -> Bool) -> EvBindMap -> EvBindMap
isEmptyEvBindMap :: EvBindMap -> Bool
evBindMapToVarSet :: EvBindMap -> VarSet
varSetMinusEvBindMap :: VarSet -> EvBindMap -> VarSet
data EvBind
EvBind :: EvVar -> EvTerm -> Bool -> EvBind
[eb_lhs] :: EvBind -> EvVar
[eb_rhs] :: EvBind -> EvTerm
[eb_is_given] :: EvBind -> Bool
emptyTcEvBinds :: TcEvBinds
isEmptyTcEvBinds :: TcEvBinds -> Bool
mkGivenEvBind :: EvVar -> EvTerm -> EvBind
mkWantedEvBind :: EvVar -> EvTerm -> EvBind
evBindVar :: EvBind -> EvVar
isCoEvBindsVar :: EvBindsVar -> Bool
data EvTerm
EvExpr :: EvExpr -> EvTerm
EvTypeable :: Type -> EvTypeable -> EvTerm
EvFun :: [TyVar] -> [EvVar] -> TcEvBinds -> EvVar -> EvTerm
[et_tvs] :: EvTerm -> [TyVar]
[et_given] :: EvTerm -> [EvVar]
[et_binds] :: EvTerm -> TcEvBinds
[et_body] :: EvTerm -> EvVar
type EvExpr = CoreExpr

-- | Any sort of evidence Id, including coercions
evId :: EvId -> EvExpr
evCoercion :: TcCoercion -> EvTerm

-- | d |&gt; co
evCast :: EvExpr -> TcCoercion -> EvTerm
evDFunApp :: DFunId -> [Type] -> [EvExpr] -> EvTerm
evDataConApp :: DataCon -> [Type] -> [EvExpr] -> EvTerm
evSelector :: Id -> [Type] -> [EvExpr] -> EvExpr
mkEvCast :: EvExpr -> TcCoercion -> EvTerm
evVarsOfTerm :: EvTerm -> VarSet
mkEvScSelectors :: Class -> [TcType] -> [(TcPredType, EvExpr)]
evTypeable :: Type -> EvTypeable -> EvTerm
findNeededEvVars :: EvBindMap -> VarSet -> VarSet
evTermCoercion :: EvTerm -> TcCoercion
evTermCoercion_maybe :: EvTerm -> Maybe TcCoercion

-- | Evidence for <tt>CallStack</tt> implicit parameters.
data EvCallStack
EvCsEmpty :: EvCallStack

-- | <tt>EvCsPushCall origin loc stk</tt> represents a call from
--   <tt>origin</tt>, occurring at <tt>loc</tt>, in a calling context
--   <tt>stk</tt>.
EvCsPushCall :: FastString -> RealSrcSpan -> EvExpr -> EvCallStack

-- | Instructions on how to make a <tt>Typeable</tt> dictionary. See Note
--   [Typeable evidence terms]
data EvTypeable

-- | Dictionary for <tt>Typeable T</tt> where <tt>T</tt> is a type
--   constructor with all of its kind variables saturated. The
--   <tt>[EvTerm]</tt> is <tt>Typeable</tt> evidence for the applied
--   kinds..
EvTypeableTyCon :: TyCon -> [EvTerm] -> EvTypeable

-- | Dictionary for <tt>Typeable (s t)</tt>, given a dictionaries for
--   <tt>s</tt> and <tt>t</tt>.
EvTypeableTyApp :: EvTerm -> EvTerm -> EvTypeable

-- | Dictionary for <tt>Typeable (s % w -&gt; t)</tt>, given a dictionaries
--   for <tt>w</tt>, <tt>s</tt>, and <tt>t</tt>.
EvTypeableTrFun :: EvTerm -> EvTerm -> EvTerm -> EvTypeable

-- | Dictionary for a type literal, e.g. <tt>Typeable "foo"</tt> or
--   <tt>Typeable 3</tt> The <a>EvTerm</a> is evidence of, e.g.,
--   <tt>KnownNat 3</tt> (see #10348)
EvTypeableTyLit :: EvTerm -> EvTypeable

-- | Where to store evidence for expression holes See Note [Holes] in
--   GHC.Tc.Types.Constraint
data HoleExprRef
HER :: IORef EvTerm -> TcType -> Unique -> HoleExprRef
type TcCoercion = Coercion
type TcCoercionR = CoercionR
type TcCoercionN = CoercionN
type TcCoercionP = CoercionP

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
type TcMCoercion = MCoercion
type TcMCoercionN = MCoercionN
type TcMCoercionR = MCoercionR

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight
pickLR :: LeftOrRight -> (a, a) -> a

-- | If a <a>SwapFlag</a> is <a>IsSwapped</a>, flip the orientation of a
--   coercion
maybeSymCo :: SwapFlag -> TcCoercion -> TcCoercion

-- | Create a <a>Coercion</a> that unwraps an implicit-parameter dictionary
--   to expose the underlying value. We expect the <a>Type</a> to have the
--   form `IP sym ty`, and return a <a>Coercion</a> `co :: IP sym ty ~ ty`
unwrapIP :: Type -> CoercionR

-- | Create a <a>Coercion</a> that wraps a value in an implicit-parameter
--   dictionary. See <a>unwrapIP</a>.
wrapIP :: Type -> CoercionR
data QuoteWrapper
QuoteWrapper :: EvVar -> Type -> QuoteWrapper

-- | Convert the QuoteWrapper into a normal HsWrapper which can be used to
--   apply its contents.
applyQuoteWrapper :: QuoteWrapper -> HsWrapper
quoteWrapperTyVarTy :: QuoteWrapper -> Type
instance Data.Data.Data GHC.Tc.Types.Evidence.EvTerm
instance Data.Data.Data GHC.Tc.Types.Evidence.EvTypeable
instance Data.Data.Data GHC.Tc.Types.Evidence.HsWrapper
instance Data.Data.Data GHC.Tc.Types.Evidence.EvCallStack
instance Data.Data.Data GHC.Tc.Types.Evidence.QuoteWrapper
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.HoleExprRef
instance Data.Data.Data GHC.Tc.Types.Evidence.HoleExprRef
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvCallStack
instance GHC.Base.Semigroup GHC.Tc.Types.Evidence.HsWrapper
instance GHC.Base.Monoid GHC.Tc.Types.Evidence.HsWrapper
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.HsWrapper
instance Data.Data.Data GHC.Tc.Types.Evidence.TcEvBinds
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvBindMap
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.TcEvBinds
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvBindsVar
instance GHC.Types.Unique.Uniquable GHC.Tc.Types.Evidence.EvBindsVar
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvBind
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvTerm
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Evidence.EvTypeable

module GHC.Hs.Binds
data NHsValBindsLR idL
NValBinds :: [(RecFlag, LHsBinds idL)] -> [LSig GhcRn] -> NHsValBindsLR idL

-- | Typechecked, generalised bindings, used in the output to the type
--   checker. See Note [AbsBinds].
data AbsBinds
AbsBinds :: [TyVar] -> [EvVar] -> [ABExport] -> [TcEvBinds] -> LHsBinds GhcTc -> Bool -> AbsBinds
[abs_tvs] :: AbsBinds -> [TyVar]

-- | Includes equality constraints
[abs_ev_vars] :: AbsBinds -> [EvVar]

-- | AbsBinds only gets used when idL = idR after renaming, but these need
--   to be idL's for the collect... code in HsUtil to have the right type
[abs_exports] :: AbsBinds -> [ABExport]

-- | Evidence bindings Why a list? See <a>GHC.Tc.TyCl.Instance</a> Note
--   [Typechecking plan for instance declarations]
[abs_ev_binds] :: AbsBinds -> [TcEvBinds]

-- | Typechecked user bindings
[abs_binds] :: AbsBinds -> LHsBinds GhcTc
[abs_sig] :: AbsBinds -> Bool

-- | Abstraction Bindings Export
data ABExport
ABE :: Id -> Id -> HsWrapper -> TcSpecPrags -> ABExport

-- | Any INLINE pragma is attached to this Id
[abe_poly] :: ABExport -> Id
[abe_mono] :: ABExport -> Id

-- | See Note [ABExport wrapper] Shape: (forall abs_tvs. abs_ev_vars =&gt;
--   abe_mono) ~ abe_poly
[abe_wrap] :: ABExport -> HsWrapper

-- | SPECIALISE pragmas
[abe_prags] :: ABExport -> TcSpecPrags

-- | Type checker Specialisation Pragmas
--   
--   <a>TcSpecPrags</a> conveys <tt>SPECIALISE</tt> pragmas from the type
--   checker to the desugarer
data TcSpecPrags

-- | Super-specialised: a default method should be macro-expanded at every
--   call site
IsDefaultMethod :: TcSpecPrags
SpecPrags :: [LTcSpecPrag] -> TcSpecPrags
data AnnSig
AnnSig :: AddEpAnn -> [AddEpAnn] -> AnnSig
[asDcolon] :: AnnSig -> AddEpAnn
[asRest] :: AnnSig -> [AddEpAnn]

-- | A type signature in generated code, notably the code generated for
--   record selectors. We simply record the desired Id itself, replete with
--   its name, type and IdDetails. Otherwise it's just like a type
--   signature: there should be an accompanying binding
newtype IdSig
IdSig :: Id -> IdSig
[unIdSig] :: IdSig -> Id

-- | Located Type checker Specification Pragmas
type LTcSpecPrag = Located TcSpecPrag

-- | Type checker Specification Pragma
data TcSpecPrag

-- | The Id to be specialised, a wrapper that specialises the polymorphic
--   function, and inlining spec for the specialised function
SpecPrag :: Id -> HsWrapper -> InlinePragma -> TcSpecPrag
ppr_sig :: forall p. OutputableBndrId p => Sig (GhcPass p) -> SDoc
pprDeclList :: [SDoc] -> SDoc
pprLHsBindsForUser :: (OutputableBndrId idL, OutputableBndrId idR, OutputableBndrId id2) => LHsBindsLR (GhcPass idL) (GhcPass idR) -> [LSig (GhcPass id2)] -> [SDoc]
pprLHsBinds :: (OutputableBndrId idL, OutputableBndrId idR) => LHsBindsLR (GhcPass idL) (GhcPass idR) -> SDoc
isEmptyLHsBinds :: LHsBindsLR (GhcPass idL) idR -> Bool
emptyLocalBinds :: HsLocalBindsLR (GhcPass a) (GhcPass b)
eqEmptyLocalBinds :: HsLocalBindsLR a b -> Bool
isEmptyValBinds :: HsValBindsLR (GhcPass a) (GhcPass b) -> Bool
emptyValBindsIn :: HsValBindsLR (GhcPass a) (GhcPass b)
emptyValBindsOut :: HsValBindsLR (GhcPass a) (GhcPass b)
emptyLHsBinds :: LHsBindsLR (GhcPass idL) idR
plusHsValBinds :: HsValBinds (GhcPass a) -> HsValBinds (GhcPass a) -> HsValBinds (GhcPass a)
ppr_monobind :: forall idL idR. (OutputableBndrId idL, OutputableBndrId idR) => HsBindLR (GhcPass idL) (GhcPass idR) -> SDoc
pprTicks :: SDoc -> SDoc -> SDoc
pprTcSpecPrags :: TcSpecPrags -> SDoc
isEmptyIPBindsPR :: HsIPBinds (GhcPass p) -> Bool
isEmptyIPBindsTc :: HsIPBinds GhcTc -> Bool
noSpecPrags :: TcSpecPrags
hasSpecPrags :: TcSpecPrags -> Bool
isDefaultMethod :: TcSpecPrags -> Bool
pprVarSig :: OutputableBndr id => [id] -> SDoc -> SDoc

-- | Using SourceText in case the pragma was spelled differently or used
--   mixed case
pragSrcBrackets :: SourceText -> String -> SDoc -> SDoc
pprSpec :: OutputableBndr id => id -> SDoc -> InlinePragma -> SDoc

-- | Extracts the name for a SPECIALIZE instance pragma. In
--   <a>hsSigDoc</a>, the src field of <a>SpecInstSig</a> signature
--   contains the SourceText for a SPECIALIZE instance pragma of the form:
--   "SourceText {-# SPECIALIZE"
--   
--   Extraction ensures that all variants of the pragma name (with a
--   <tt>Z</tt> or an <tt>S</tt>) are output exactly as used in the pragma.
extractSpecPragName :: SourceText -> String
pprMinimalSig :: OutputableBndr name => LBooleanFormula (GenLocated l name) -> SDoc
hsSigDoc :: forall p. IsPass p => Sig (GhcPass p) -> SDoc
pragBrackets :: SDoc -> SDoc
instance Data.Data.Data GHC.Hs.Binds.IdSig
instance Data.Data.Data GHC.Hs.Binds.AnnSig
instance Data.Data.Data GHC.Hs.Binds.TcSpecPrag
instance Data.Data.Data GHC.Hs.Binds.TcSpecPrags
instance GHC.Utils.Outputable.Outputable GHC.Hs.Binds.ABExport
instance GHC.Utils.Outputable.Outputable GHC.Hs.Binds.TcSpecPrag
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsValBindsLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr))
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsLocalBindsLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr))
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsBindLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr))
instance (GHC.Hs.Extension.OutputableBndrId l, GHC.Hs.Extension.OutputableBndrId r) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.PatSynBind (GHC.Hs.Extension.GhcPass l) (GHC.Hs.Extension.GhcPass r))
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec a GHC.Types.Name.Reader.RdrName) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.RecordPatSynField a)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.HsIPBinds (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.IPBind (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.Sig (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Binds.FixitySig (GHC.Hs.Extension.GhcPass p))


-- | Abstract syntax of global declarations.
--   
--   Definitions for: <tt>SynDecl</tt> and <tt>ConDecl</tt>,
--   <tt>ClassDecl</tt>, <tt>InstDecl</tt>, <tt>DefaultDecl</tt> and
--   <tt>ForeignDecl</tt>.
module GHC.Hs.Decls

-- | A Haskell Declaration
data HsDecl p

-- | Type or Class Declaration
TyClD :: XTyClD p -> TyClDecl p -> HsDecl p

-- | Instance declaration
InstD :: XInstD p -> InstDecl p -> HsDecl p

-- | Deriving declaration
DerivD :: XDerivD p -> DerivDecl p -> HsDecl p

-- | Value declaration
ValD :: XValD p -> HsBind p -> HsDecl p

-- | Signature declaration
SigD :: XSigD p -> Sig p -> HsDecl p

-- | Standalone kind signature
KindSigD :: XKindSigD p -> StandaloneKindSig p -> HsDecl p

-- | 'default' declaration
DefD :: XDefD p -> DefaultDecl p -> HsDecl p

-- | Foreign declaration
ForD :: XForD p -> ForeignDecl p -> HsDecl p

-- | Warning declaration
WarningD :: XWarningD p -> WarnDecls p -> HsDecl p

-- | Annotation declaration
AnnD :: XAnnD p -> AnnDecl p -> HsDecl p

-- | Rule declaration
RuleD :: XRuleD p -> RuleDecls p -> HsDecl p

-- | Splice declaration (Includes quasi-quotes)
SpliceD :: XSpliceD p -> SpliceDecl p -> HsDecl p

-- | Documentation comment declaration
DocD :: XDocD p -> DocDecl p -> HsDecl p

-- | Role annotation declaration
RoleAnnotD :: XRoleAnnotD p -> RoleAnnotDecl p -> HsDecl p
XHsDecl :: !XXHsDecl p -> HsDecl p
type LHsDecl p = -- | When in a list this may have -- --  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' -- XRec p (HsDecl p)

-- | Haskell Data type Definition
data HsDataDefn pass

-- | Declares a data type or newtype, giving its constructors <tt>
--   data/newtype T a = <a>constrs</a> data/newtype instance T [a] =
--   <a>constrs</a> </tt>
HsDataDefn :: XCHsDataDefn pass -> Maybe (LHsContext pass) -> Maybe (XRec pass CType) -> Maybe (LHsKind pass) -> DataDefnCons (LConDecl pass) -> HsDeriving pass -> HsDataDefn pass
[dd_ext] :: HsDataDefn pass -> XCHsDataDefn pass

-- | Context
[dd_ctxt] :: HsDataDefn pass -> Maybe (LHsContext pass)
[dd_cType] :: HsDataDefn pass -> Maybe (XRec pass CType)

-- | Optional kind signature.
--   
--   <tt>(Just k)</tt> for a GADT-style <tt>data</tt>, or <tt>data
--   instance</tt> decl, with explicit kind sig
--   
--   Always <tt>Nothing</tt> for H98-syntax decls
[dd_kindSig] :: HsDataDefn pass -> Maybe (LHsKind pass)

-- | Data constructors
--   
--   For <tt>data T a = T1 | T2 a</tt> the <a>LConDecl</a>s all have
--   <a>ConDeclH98</a>. For <tt>data T a where { T1 :: T a }</tt> the
--   <tt>LConDecls</tt> all have <a>ConDeclGADT</a>.
[dd_cons] :: HsDataDefn pass -> DataDefnCons (LConDecl pass)

-- | Optional 'deriving' clause
[dd_derivs] :: HsDataDefn pass -> HsDeriving pass
XHsDataDefn :: !XXHsDataDefn pass -> HsDataDefn pass

-- | Haskell Deriving clause
type HsDeriving pass = -- | The optional @deriving@ clauses of a data declaration. "Clauses" is -- plural because one can specify multiple deriving clauses using the -- @-XDerivingStrategies@ language extension. -- -- The list of 'LHsDerivingClause's corresponds to exactly what the user -- requested to derive, in order. If no deriving clauses were specified, -- the list is empty. [LHsDerivingClause pass]
type LHsFunDep pass = XRec pass (FunDep pass)

-- | A single <tt>deriving</tt> clause of a data declaration.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDeriving</a>, <a>AnnStock</a>,
--   <a>AnnAnyClass</a>, <a>AnnNewtype</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
data HsDerivingClause pass
HsDerivingClause :: XCHsDerivingClause pass -> Maybe (LDerivStrategy pass) -> LDerivClauseTys pass -> HsDerivingClause pass
[deriv_clause_ext] :: HsDerivingClause pass -> XCHsDerivingClause pass

-- | The user-specified strategy (if any) to use when deriving
--   <a>deriv_clause_tys</a>.
[deriv_clause_strategy] :: HsDerivingClause pass -> Maybe (LDerivStrategy pass)

-- | The types to derive.
[deriv_clause_tys] :: HsDerivingClause pass -> LDerivClauseTys pass
XHsDerivingClause :: !XXHsDerivingClause pass -> HsDerivingClause pass
type LHsDerivingClause pass = XRec pass (HsDerivingClause pass)

-- | The types mentioned in a single <tt>deriving</tt> clause. This can
--   come in two forms, <a>DctSingle</a> or <a>DctMulti</a>, depending on
--   whether the types are surrounded by enclosing parentheses or not.
--   These parentheses are semantically different than <a>HsParTy</a>. For
--   example, <tt>deriving ()</tt> means "derive zero classes" rather than
--   "derive an instance of the 0-tuple".
--   
--   <a>DerivClauseTys</a> use <a>LHsSigType</a> because <tt>deriving</tt>
--   clauses can mention type variables that aren't bound by the datatype,
--   e.g.
--   
--   <pre>
--   data T b = ... deriving (C [a])
--   </pre>
--   
--   should produce a derived instance for <tt>C [a] (T b)</tt>.
data DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a single type. Moreover, that type can
--   only be a type constructor without any arguments.
--   
--   Example: <tt>deriving Eq</tt>
DctSingle :: XDctSingle pass -> LHsSigType pass -> DerivClauseTys pass

-- | A <tt>deriving</tt> clause with a comma-separated list of types,
--   surrounded by enclosing parentheses.
--   
--   Example: <tt>deriving (Eq, C a)</tt>
DctMulti :: XDctMulti pass -> [LHsSigType pass] -> DerivClauseTys pass
XDerivClauseTys :: !XXDerivClauseTys pass -> DerivClauseTys pass
type LDerivClauseTys pass = XRec pass (DerivClauseTys pass)

-- | When we only care whether a data-type declaration is `data` or
--   `newtype`, but not what constructors it has
data NewOrData

-- | Convert a <a>NewOrData</a> to a <a>TyConFlavour</a>
newOrDataToFlavour :: NewOrData -> TyConFlavour
anyLConIsGadt :: Foldable f => f (GenLocated l (ConDecl pass)) -> Bool
data StandaloneKindSig pass
StandaloneKindSig :: XStandaloneKindSig pass -> LIdP pass -> LHsSigType pass -> StandaloneKindSig pass
XStandaloneKindSig :: !XXStandaloneKindSig pass -> StandaloneKindSig pass

-- | Located Standalone Kind Signature
type LStandaloneKindSig pass = XRec pass (StandaloneKindSig pass)
standaloneKindSigName :: StandaloneKindSig (GhcPass p) -> IdP (GhcPass p)

-- | A type or class declaration.
data TyClDecl pass

-- | <pre>
--   type/data family T :: *-&gt;*
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnData</a>,
--   <a>AnnFamily</a>,<a>AnnDcolon</a>, <a>AnnWhere</a>,<a>AnnOpenP</a>,
--   <a>AnnDcolon</a>,<a>AnnCloseP</a>, <a>AnnEqual</a>,<a>AnnRarrow</a>,
--   <a>AnnVbar</a></li>
--   </ul>
FamDecl :: XFamDecl pass -> FamilyDecl pass -> TyClDecl pass
[tcdFExt] :: TyClDecl pass -> XFamDecl pass
[tcdFam] :: TyClDecl pass -> FamilyDecl pass

-- | <tt>type</tt> declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnEqual</a>,</li>
--   </ul>
SynDecl :: XSynDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LHsType pass -> TyClDecl pass

-- | Post renamer, FVs
[tcdSExt] :: TyClDecl pass -> XSynDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | RHS of type declaration
[tcdRhs] :: TyClDecl pass -> LHsType pass

-- | <tt>data</tt> declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnData</a>, <a>AnnFamily</a>,
--   <a>AnnNewType</a>, <a>AnnNewType</a>,<a>AnnDcolon</a>
--   <a>AnnWhere</a>,</li>
--   </ul>
DataDecl :: XDataDecl pass -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> HsDataDefn pass -> TyClDecl pass

-- | Post renamer, CUSK flag, FVs
[tcdDExt] :: TyClDecl pass -> XDataDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity
[tcdDataDefn] :: TyClDecl pass -> HsDataDefn pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnClass</a>,
--   <a>AnnWhere</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   <li>The tcdFDs will have <a>AnnVbar</a>, <a>AnnComma</a>
--   <a>AnnRarrow</a> For details on above see Note [exact print
--   annotations] in GHC.Parser.Annotation</li>
--   </ul>
ClassDecl :: XClassDecl pass -> !LayoutInfo pass -> Maybe (LHsContext pass) -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> [LHsFunDep pass] -> [LSig pass] -> LHsBinds pass -> [LFamilyDecl pass] -> [LTyFamDefltDecl pass] -> [LDocDecl pass] -> TyClDecl pass

-- | Post renamer, FVs
[tcdCExt] :: TyClDecl pass -> XClassDecl pass

-- | Explicit or virtual braces See Note [Class LayoutInfo]
[tcdLayout] :: TyClDecl pass -> !LayoutInfo pass

-- | Context...
[tcdCtxt] :: TyClDecl pass -> Maybe (LHsContext pass)

-- | Type constructor
[tcdLName] :: TyClDecl pass -> LIdP pass

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | Functional deps
[tcdFDs] :: TyClDecl pass -> [LHsFunDep pass]

-- | Methods' signatures
[tcdSigs] :: TyClDecl pass -> [LSig pass]

-- | Default methods
[tcdMeths] :: TyClDecl pass -> LHsBinds pass

-- | Associated types;
[tcdATs] :: TyClDecl pass -> [LFamilyDecl pass]

-- | Associated type defaults
[tcdATDefs] :: TyClDecl pass -> [LTyFamDefltDecl pass]

-- | Haddock docs
[tcdDocs] :: TyClDecl pass -> [LDocDecl pass]
XTyClDecl :: !XXTyClDecl pass -> TyClDecl pass

-- | Located Declaration of a Type or Class
type LTyClDecl pass = XRec pass (TyClDecl pass)
data DataDeclRn
DataDeclRn :: Bool -> NameSet -> DataDeclRn

-- | does this have a CUSK? See Note [CUSKs: complete user-supplied kind
--   signatures]
[tcdDataCusk] :: DataDeclRn -> Bool
[tcdFVs] :: DataDeclRn -> NameSet

-- | Type or Class Group
data TyClGroup pass
TyClGroup :: XCTyClGroup pass -> [LTyClDecl pass] -> [LRoleAnnotDecl pass] -> [LStandaloneKindSig pass] -> [LInstDecl pass] -> TyClGroup pass
[group_ext] :: TyClGroup pass -> XCTyClGroup pass
[group_tyclds] :: TyClGroup pass -> [LTyClDecl pass]
[group_roles] :: TyClGroup pass -> [LRoleAnnotDecl pass]
[group_kisigs] :: TyClGroup pass -> [LStandaloneKindSig pass]
[group_instds] :: TyClGroup pass -> [LInstDecl pass]
XTyClGroup :: !XXTyClGroup pass -> TyClGroup pass
tyClGroupTyClDecls :: [TyClGroup pass] -> [LTyClDecl pass]
tyClGroupInstDecls :: [TyClGroup pass] -> [LInstDecl pass]
tyClGroupRoleDecls :: [TyClGroup pass] -> [LRoleAnnotDecl pass]
tyClGroupKindSigs :: [TyClGroup pass] -> [LStandaloneKindSig pass]

-- | type class
isClassDecl :: TyClDecl pass -> Bool

-- | <tt>True</tt> <a>=</a> argument is a <tt>data</tt>/<tt>newtype</tt>
--   declaration.
isDataDecl :: TyClDecl pass -> Bool

-- | type or type instance declaration
isSynDecl :: TyClDecl pass -> Bool
tcdName :: Anno (IdGhcP p) ~ SrcSpanAnnN => TyClDecl (GhcPass p) -> IdP (GhcPass p)

-- | type/data family declaration
isFamilyDecl :: TyClDecl pass -> Bool

-- | type family declaration
isTypeFamilyDecl :: TyClDecl pass -> Bool

-- | data family declaration
isDataFamilyDecl :: TyClDecl pass -> Bool

-- | open type family info
isOpenTypeFamilyInfo :: FamilyInfo pass -> Bool

-- | closed type family info
isClosedTypeFamilyInfo :: FamilyInfo pass -> Bool
tyFamInstDeclName :: Anno (IdGhcP p) ~ SrcSpanAnnN => TyFamInstDecl (GhcPass p) -> IdP (GhcPass p)
tyFamInstDeclLName :: Anno (IdGhcP p) ~ SrcSpanAnnN => TyFamInstDecl (GhcPass p) -> LocatedN (IdP (GhcPass p))
countTyClDecls :: [TyClDecl pass] -> (Int, Int, Int, Int, Int)
pprTyClDeclFlavour :: TyClDecl (GhcPass p) -> SDoc
tyClDeclLName :: Anno (IdGhcP p) ~ SrcSpanAnnN => TyClDecl (GhcPass p) -> LocatedN (IdP (GhcPass p))
tyClDeclTyVars :: TyClDecl pass -> LHsQTyVars pass

-- | Does this declaration have a complete, user-supplied kind signature?
--   See Note [CUSKs: complete user-supplied kind signatures]
hsDeclHasCusk :: TyClDecl GhcRn -> Bool
famResultKindSignature :: FamilyResultSig (GhcPass p) -> Maybe (LHsKind (GhcPass p))

-- | type Family Declaration
data FamilyDecl pass
FamilyDecl :: XCFamilyDecl pass -> FamilyInfo pass -> TopLevelFlag -> LIdP pass -> LHsQTyVars pass -> LexicalFixity -> LFamilyResultSig pass -> Maybe (LInjectivityAnn pass) -> FamilyDecl pass
[fdExt] :: FamilyDecl pass -> XCFamilyDecl pass
[fdInfo] :: FamilyDecl pass -> FamilyInfo pass
[fdTopLevel] :: FamilyDecl pass -> TopLevelFlag
[fdLName] :: FamilyDecl pass -> LIdP pass
[fdTyVars] :: FamilyDecl pass -> LHsQTyVars pass
[fdFixity] :: FamilyDecl pass -> LexicalFixity
[fdResultSig] :: FamilyDecl pass -> LFamilyResultSig pass
[fdInjectivityAnn] :: FamilyDecl pass -> Maybe (LInjectivityAnn pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnData</a>,
--   <a>AnnFamily</a>, <a>AnnWhere</a>, <a>AnnOpenP</a>, <a>AnnDcolon</a>,
--   <a>AnnCloseP</a>, <a>AnnEqual</a>, <a>AnnRarrow</a>,
--   <a>AnnVbar</a></li>
--   </ul>
XFamilyDecl :: !XXFamilyDecl pass -> FamilyDecl pass

-- | Located type Family Declaration
type LFamilyDecl pass = XRec pass (FamilyDecl pass)
data FunDep pass
FunDep :: XCFunDep pass -> [LIdP pass] -> [LIdP pass] -> FunDep pass
XFunDep :: !XXFunDep pass -> FunDep pass
ppDataDefnHeader :: OutputableBndrId p => (Maybe (LHsContext (GhcPass p)) -> SDoc) -> HsDataDefn (GhcPass p) -> SDoc
pp_vanilla_decl_head :: OutputableBndrId p => XRec (GhcPass p) (IdP (GhcPass p)) -> LHsQTyVars (GhcPass p) -> LexicalFixity -> Maybe (LHsContext (GhcPass p)) -> SDoc

-- | Instance Declaration
data InstDecl pass
ClsInstD :: XClsInstD pass -> ClsInstDecl pass -> InstDecl pass
[cid_d_ext] :: InstDecl pass -> XClsInstD pass
[cid_inst] :: InstDecl pass -> ClsInstDecl pass
DataFamInstD :: XDataFamInstD pass -> DataFamInstDecl pass -> InstDecl pass
[dfid_ext] :: InstDecl pass -> XDataFamInstD pass
[dfid_inst] :: InstDecl pass -> DataFamInstDecl pass
TyFamInstD :: XTyFamInstD pass -> TyFamInstDecl pass -> InstDecl pass
[tfid_ext] :: InstDecl pass -> XTyFamInstD pass
[tfid_inst] :: InstDecl pass -> TyFamInstDecl pass
XInstDecl :: !XXInstDecl pass -> InstDecl pass

-- | Located Instance Declaration
type LInstDecl pass = XRec pass (InstDecl pass)
data FamilyInfo pass
DataFamily :: FamilyInfo pass
OpenTypeFamily :: FamilyInfo pass

-- | <a>Nothing</a> if we're in an hs-boot file and the user said "type
--   family Foo x where .."
ClosedTypeFamily :: Maybe [LTyFamInstEqn pass] -> FamilyInfo pass

-- | Type Family Instance Declaration
data TyFamInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnInstance</a>,</li>
--   </ul>
TyFamInstDecl :: XCTyFamInstDecl pass -> TyFamInstEqn pass -> TyFamInstDecl pass
[tfid_xtn] :: TyFamInstDecl pass -> XCTyFamInstDecl pass
[tfid_eqn] :: TyFamInstDecl pass -> TyFamInstEqn pass
XTyFamInstDecl :: !XXTyFamInstDecl pass -> TyFamInstDecl pass

-- | Located Type Family Instance Declaration
type LTyFamInstDecl pass = XRec pass (TyFamInstDecl pass)
instDeclDataFamInsts :: [LInstDecl (GhcPass p)] -> [DataFamInstDecl (GhcPass p)]

-- | Type family default declarations. A convenient synonym for
--   <a>TyFamInstDecl</a>. See <tt>Note [Type family instance declarations
--   in HsSyn]</tt>.
type TyFamDefltDecl = TyFamInstDecl

-- | Located type family default declarations.
type LTyFamDefltDecl pass = XRec pass (TyFamDefltDecl pass)

-- | Data Family Instance Declaration
newtype DataFamInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnData</a>,
--   <a>AnnNewType</a>,<a>AnnInstance</a>, <a>AnnDcolon</a>
--   <a>AnnWhere</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
DataFamInstDecl :: FamEqn pass (HsDataDefn pass) -> DataFamInstDecl pass
[dfid_eqn] :: DataFamInstDecl pass -> FamEqn pass (HsDataDefn pass)

-- | Located Data Family Instance Declaration
type LDataFamInstDecl pass = XRec pass (DataFamInstDecl pass)
pprDataFamInstFlavour :: DataFamInstDecl (GhcPass p) -> SDoc
pprTyFamInstDecl :: OutputableBndrId p => TopLevelFlag -> TyFamInstDecl (GhcPass p) -> SDoc
pprHsFamInstLHS :: OutputableBndrId p => IdP (GhcPass p) -> HsOuterFamEqnTyVarBndrs (GhcPass p) -> HsTyPats (GhcPass p) -> LexicalFixity -> Maybe (LHsContext (GhcPass p)) -> SDoc

-- | Family Equation
--   
--   One equation in a type family instance declaration, data family
--   instance declaration, or type family default. See Note [Type family
--   instance declarations in HsSyn] See Note [Family instance declaration
--   binders]
data FamEqn pass rhs
FamEqn :: XCFamEqn pass rhs -> LIdP pass -> HsOuterFamEqnTyVarBndrs pass -> HsTyPats pass -> LexicalFixity -> rhs -> FamEqn pass rhs
[feqn_ext] :: FamEqn pass rhs -> XCFamEqn pass rhs
[feqn_tycon] :: FamEqn pass rhs -> LIdP pass

-- | Optional quantified type vars
[feqn_bndrs] :: FamEqn pass rhs -> HsOuterFamEqnTyVarBndrs pass
[feqn_pats] :: FamEqn pass rhs -> HsTyPats pass

-- | Fixity used in the declaration
[feqn_fixity] :: FamEqn pass rhs -> LexicalFixity

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a></li>
--   </ul>
[feqn_rhs] :: FamEqn pass rhs -> rhs
XFamEqn :: !XXFamEqn pass rhs -> FamEqn pass rhs

-- | Type Family Instance Equation
type TyFamInstEqn pass = FamEqn pass (LHsType pass)

-- | Located Type Family Instance Equation
type LTyFamInstEqn pass = -- | May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' --   when in a list XRec pass (TyFamInstEqn pass)

-- | Haskell Type Patterns
type HsTyPats pass = [LHsTypeArg pass]

-- | Located Class Instance Declaration
type LClsInstDecl pass = XRec pass (ClsInstDecl pass)

-- | Class Instance Declaration - <a>AnnKeywordId</a> : <a>AnnInstance</a>,
--   <a>AnnWhere</a>, <a>AnnOpen</a>,<a>AnnClose</a>, For details on above
--   see Note [exact print annotations] in GHC.Parser.Annotation
data ClsInstDecl pass
ClsInstDecl :: XCClsInstDecl pass -> LHsSigType pass -> LHsBinds pass -> [LSig pass] -> [LTyFamInstDecl pass] -> [LDataFamInstDecl pass] -> Maybe (XRec pass OverlapMode) -> ClsInstDecl pass
[cid_ext] :: ClsInstDecl pass -> XCClsInstDecl pass
[cid_poly_ty] :: ClsInstDecl pass -> LHsSigType pass
[cid_binds] :: ClsInstDecl pass -> LHsBinds pass
[cid_sigs] :: ClsInstDecl pass -> [LSig pass]
[cid_tyfam_insts] :: ClsInstDecl pass -> [LTyFamInstDecl pass]
[cid_datafam_insts] :: ClsInstDecl pass -> [LDataFamInstDecl pass]

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a>,</li>
--   </ul>
[cid_overlap_mode] :: ClsInstDecl pass -> Maybe (XRec pass OverlapMode)
XClsInstDecl :: !XXClsInstDecl pass -> ClsInstDecl pass

-- | Stand-alone 'deriving instance' declaration
data DerivDecl pass
DerivDecl :: XCDerivDecl pass -> LHsSigWcType pass -> Maybe (LDerivStrategy pass) -> Maybe (XRec pass OverlapMode) -> DerivDecl pass
[deriv_ext] :: DerivDecl pass -> XCDerivDecl pass

-- | The instance type to derive.
--   
--   It uses an <a>LHsSigWcType</a> because the context is allowed to be a
--   single wildcard:
--   
--   <pre>
--   deriving instance _ =&gt; Eq (Foo a)
--   </pre>
--   
--   Which signifies that the context should be inferred.
[deriv_type] :: DerivDecl pass -> LHsSigWcType pass
[deriv_strategy] :: DerivDecl pass -> Maybe (LDerivStrategy pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDeriving</a>, <a>AnnInstance</a>,
--   <a>AnnStock</a>, <a>AnnAnyClass</a>, <a>AnnNewtype</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
[deriv_overlap_mode] :: DerivDecl pass -> Maybe (XRec pass OverlapMode)
XDerivDecl :: !XXDerivDecl pass -> DerivDecl pass

-- | Located stand-alone 'deriving instance' declaration
type LDerivDecl pass = XRec pass (DerivDecl pass)

-- | Which technique the user explicitly requested when deriving an
--   instance.
data DerivStrategy pass

-- | GHC's "standard" strategy, which is to implement a custom instance for
--   the data type. This only works for certain types that GHC knows about
--   (e.g., <a>Eq</a>, <a>Show</a>, <a>Functor</a> when
--   <tt>-XDeriveFunctor</tt> is enabled, etc.)
StockStrategy :: XStockStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: XAnyClassStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: XNewtypeStrategy pass -> DerivStrategy pass

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: XViaStrategy pass -> DerivStrategy pass

-- | A <tt>Located</tt> <a>DerivStrategy</a>.
type LDerivStrategy pass = XRec pass (DerivStrategy pass)

-- | A short description of a <tt>DerivStrategy'</tt>.
derivStrategyName :: DerivStrategy a -> SDoc

-- | Eliminate a <a>DerivStrategy</a>.
foldDerivStrategy :: p ~ GhcPass pass => r -> (XViaStrategy p -> r) -> DerivStrategy p -> r

-- | Map over the <tt>via</tt> type if dealing with <a>ViaStrategy</a>.
--   Otherwise, return the <a>DerivStrategy</a> unchanged.
mapDerivStrategy :: p ~ GhcPass pass => (XViaStrategy p -> XViaStrategy p) -> DerivStrategy p -> DerivStrategy p
data XViaStrategyPs
XViaStrategyPs :: EpAnn [AddEpAnn] -> LHsSigType GhcPs -> XViaStrategyPs

-- | Located Rule Declarations
type LRuleDecls pass = XRec pass (RuleDecls pass)

-- | Rule Declarations
data RuleDecls pass
HsRules :: XCRuleDecls pass -> [LRuleDecl pass] -> RuleDecls pass
[rds_ext] :: RuleDecls pass -> XCRuleDecls pass
[rds_rules] :: RuleDecls pass -> [LRuleDecl pass]
XRuleDecls :: !XXRuleDecls pass -> RuleDecls pass

-- | Rule Declaration
data RuleDecl pass
HsRule :: XHsRule pass -> XRec pass RuleName -> Activation -> Maybe [LHsTyVarBndr () (NoGhcTc pass)] -> [LRuleBndr pass] -> XRec pass (HsExpr pass) -> XRec pass (HsExpr pass) -> RuleDecl pass

-- | After renamer, free-vars from the LHS and RHS
[rd_ext] :: RuleDecl pass -> XHsRule pass

-- | Note [Pragma source text] in <a>GHC.Types.Basic</a>
[rd_name] :: RuleDecl pass -> XRec pass RuleName
[rd_act] :: RuleDecl pass -> Activation

-- | Forall'd type vars
[rd_tyvs] :: RuleDecl pass -> Maybe [LHsTyVarBndr () (NoGhcTc pass)]

-- | Forall'd term vars, before typechecking; after typechecking this
--   includes all forall'd vars
[rd_tmvs] :: RuleDecl pass -> [LRuleBndr pass]
[rd_lhs] :: RuleDecl pass -> XRec pass (HsExpr pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,<a>AnnTilde</a>,
--   <a>AnnVal</a>, <a>AnnClose</a>, <a>AnnForall</a>,<a>AnnDot</a>,
--   <a>AnnEqual</a>,</li>
--   </ul>
[rd_rhs] :: RuleDecl pass -> XRec pass (HsExpr pass)
XRuleDecl :: !XXRuleDecl pass -> RuleDecl pass

-- | Located Rule Declaration
type LRuleDecl pass = XRec pass (RuleDecl pass)
data HsRuleRn
HsRuleRn :: NameSet -> NameSet -> HsRuleRn
data HsRuleAnn
HsRuleAnn :: Maybe (AddEpAnn, AddEpAnn) -> Maybe (AddEpAnn, AddEpAnn) -> [AddEpAnn] -> HsRuleAnn

-- | The locations of <tt>forall</tt> and <a>.</a> for forall'd type vars
--   Using AddEpAnn to capture possible unicode variants
[ra_tyanns] :: HsRuleAnn -> Maybe (AddEpAnn, AddEpAnn)

-- | The locations of <tt>forall</tt> and <a>.</a> for forall'd term vars
--   Using AddEpAnn to capture possible unicode variants
[ra_tmanns] :: HsRuleAnn -> Maybe (AddEpAnn, AddEpAnn)
[ra_rest] :: HsRuleAnn -> [AddEpAnn]

-- | Rule Binder
data RuleBndr pass
RuleBndr :: XCRuleBndr pass -> LIdP pass -> RuleBndr pass
RuleBndrSig :: XRuleBndrSig pass -> LIdP pass -> HsPatSigType pass -> RuleBndr pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnDcolon</a>,<a>AnnClose</a></li>
--   </ul>
XRuleBndr :: !XXRuleBndr pass -> RuleBndr pass

-- | Located Rule Binder
type LRuleBndr pass = XRec pass (RuleBndr pass)
collectRuleBndrSigTys :: [RuleBndr pass] -> [HsPatSigType pass]
flattenRuleDecls :: [LRuleDecls (GhcPass p)] -> [LRuleDecl (GhcPass p)]
pprFullRuleName :: SourceText -> GenLocated a RuleName -> SDoc

-- | Default Declaration
data DefaultDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnDefault</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
DefaultDecl :: XCDefaultDecl pass -> [LHsType pass] -> DefaultDecl pass
XDefaultDecl :: !XXDefaultDecl pass -> DefaultDecl pass

-- | Located Default Declaration
type LDefaultDecl pass = XRec pass (DefaultDecl pass)

-- | A splice can appear with various decorations wrapped around it. This
--   data type captures explicitly how it was originally written, for use
--   in the pretty printer.
data SpliceDecoration

-- | $splice
DollarSplice :: SpliceDecoration

-- | bare splice
BareSplice :: SpliceDecoration

-- | Splice Declaration
data SpliceDecl p
SpliceDecl :: XSpliceDecl p -> XRec p (HsUntypedSplice p) -> SpliceDecoration -> SpliceDecl p
XSpliceDecl :: !XXSpliceDecl p -> SpliceDecl p

-- | Located Splice Declaration
type LSpliceDecl pass = XRec pass (SpliceDecl pass)

-- | Foreign Declaration
data ForeignDecl pass
ForeignImport :: XForeignImport pass -> LIdP pass -> LHsSigType pass -> ForeignImport pass -> ForeignDecl pass
[fd_i_ext] :: ForeignDecl pass -> XForeignImport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fi] :: ForeignDecl pass -> ForeignImport pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnForeign</a>,
--   <a>AnnImport</a>,<a>AnnExport</a>, <a>AnnDcolon</a></li>
--   </ul>
ForeignExport :: XForeignExport pass -> LIdP pass -> LHsSigType pass -> ForeignExport pass -> ForeignDecl pass
[fd_e_ext] :: ForeignDecl pass -> XForeignExport pass
[fd_name] :: ForeignDecl pass -> LIdP pass
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fe] :: ForeignDecl pass -> ForeignExport pass
XForeignDecl :: !XXForeignDecl pass -> ForeignDecl pass

-- | Located Foreign Declaration
type LForeignDecl pass = XRec pass (ForeignDecl pass)
data ForeignImport pass
CImport :: XCImport pass -> XRec pass CCallConv -> XRec pass Safety -> Maybe Header -> CImportSpec -> ForeignImport pass
XForeignImport :: !XXForeignImport pass -> ForeignImport pass
data ForeignExport pass
CExport :: XCExport pass -> XRec pass CExportSpec -> ForeignExport pass
XForeignExport :: !XXForeignExport pass -> ForeignExport pass
data CImportSpec
CLabel :: CLabelString -> CImportSpec
CFunction :: CCallTarget -> CImportSpec
CWrapper :: CImportSpec

-- | <pre>
--   data T b = forall a. Eq a =&gt; MkT a b
--     MkT :: forall b a. Eq a =&gt; MkT a b
--   
--   data T b where
--        MkT1 :: Int -&gt; T Int
--   
--   data T = Int <tt>MkT</tt> Int
--          | MkT2
--   
--   data T a where
--        Int <tt>MkT</tt> Int :: T Int
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a>,
--   <a>AnnDotdot</a>,<a>AnnCLose</a>, <a>AnnEqual</a>,<a>AnnVbar</a>,
--   <a>AnnDarrow</a>,<a>AnnDarrow</a>, <a>AnnForall</a>,<a>AnnDot</a></li>
--   </ul>
--   
--   data Constructor Declaration
data ConDecl pass
ConDeclGADT :: XConDeclGADT pass -> NonEmpty (LIdP pass) -> !LHsUniToken "::" "∷" pass -> XRec pass (HsOuterSigTyVarBndrs pass) -> Maybe (LHsContext pass) -> HsConDeclGADTDetails pass -> LHsType pass -> Maybe (LHsDoc pass) -> ConDecl pass
[con_g_ext] :: ConDecl pass -> XConDeclGADT pass
[con_names] :: ConDecl pass -> NonEmpty (LIdP pass)
[con_dcolon] :: ConDecl pass -> !LHsUniToken "::" "∷" pass

-- | The outermost type variable binders, be they explicit or implicit. The
--   <a>XRec</a> is used to anchor exact print annotations, AnnForall and
--   AnnDot.
[con_bndrs] :: ConDecl pass -> XRec pass (HsOuterSigTyVarBndrs pass)

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; never infix
[con_g_args] :: ConDecl pass -> HsConDeclGADTDetails pass

-- | Result type
[con_res_ty] :: ConDecl pass -> LHsType pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe (LHsDoc pass)
ConDeclH98 :: XConDeclH98 pass -> LIdP pass -> Bool -> [LHsTyVarBndr Specificity pass] -> Maybe (LHsContext pass) -> HsConDeclH98Details pass -> Maybe (LHsDoc pass) -> ConDecl pass
[con_ext] :: ConDecl pass -> XConDeclH98 pass
[con_name] :: ConDecl pass -> LIdP pass

-- | True <a>=</a> explicit user-written forall e.g. data T a = forall b.
--   MkT b (b-&gt;a) con_ex_tvs = {b} False =&gt; con_ex_tvs is empty
[con_forall] :: ConDecl pass -> Bool

-- | Existentials only
[con_ex_tvs] :: ConDecl pass -> [LHsTyVarBndr Specificity pass]

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; can be infix
[con_args] :: ConDecl pass -> HsConDeclH98Details pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe (LHsDoc pass)
XConDecl :: !XXConDecl pass -> ConDecl pass

-- | Located data Constructor Declaration
type LConDecl pass = -- | May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when --   in a GADT constructor list XRec pass (ConDecl pass)

-- | The arguments in a Haskell98-style data constructor.
type HsConDeclH98Details pass = HsConDetails Void (HsScaled pass (LBangType pass)) (XRec pass [LConDeclField pass])

-- | The arguments in a GADT constructor. Unlike Haskell98-style
--   constructors, GADT constructors cannot be declared with infix syntax.
--   As a result, we do not use <a>HsConDetails</a> here, as
--   <a>InfixCon</a> would be an unrepresentable state. (There is a notion
--   of infix GADT constructors for the purposes of derived Show
--   instances—see Note [Infix GADT constructors] in GHC.Tc.TyCl—but that
--   is an orthogonal concern.)
data HsConDeclGADTDetails pass
PrefixConGADT :: [HsScaled pass (LBangType pass)] -> HsConDeclGADTDetails pass
RecConGADT :: XRec pass [LConDeclField pass] -> LHsUniToken "->" "→" pass -> HsConDeclGADTDetails pass
hsConDeclTheta :: Maybe (LHsContext (GhcPass p)) -> [LHsType (GhcPass p)]
getConNames :: ConDecl GhcRn -> [LocatedN Name]

-- | Return <tt><a>Just</a> fields</tt> if a data constructor declaration
--   uses record syntax (i.e., <a>RecCon</a>), where <tt>fields</tt> are
--   the field selectors. Otherwise, return <a>Nothing</a>.
getRecConArgs_maybe :: ConDecl GhcRn -> Maybe (LocatedL [LConDeclField GhcRn])

-- | Documentation comment Declaration
data DocDecl pass
DocCommentNext :: LHsDoc pass -> DocDecl pass
DocCommentPrev :: LHsDoc pass -> DocDecl pass
DocCommentNamed :: String -> LHsDoc pass -> DocDecl pass
DocGroup :: Int -> LHsDoc pass -> DocDecl pass

-- | Located Documentation comment Declaration
type LDocDecl pass = XRec pass (DocDecl pass)
docDeclDoc :: DocDecl pass -> LHsDoc pass

-- | Warning pragma Declaration
data WarnDecl pass
Warning :: XWarning pass -> [LIdP pass] -> WarningTxt pass -> WarnDecl pass
XWarnDecl :: !XXWarnDecl pass -> WarnDecl pass

-- | Located Warning pragma Declaration
type LWarnDecl pass = XRec pass (WarnDecl pass)

-- | Warning pragma Declarations
data WarnDecls pass
Warnings :: XWarnings pass -> [LWarnDecl pass] -> WarnDecls pass
[wd_ext] :: WarnDecls pass -> XWarnings pass
[wd_warnings] :: WarnDecls pass -> [LWarnDecl pass]
XWarnDecls :: !XXWarnDecls pass -> WarnDecls pass

-- | Located Warning Declarations
type LWarnDecls pass = XRec pass (WarnDecls pass)

-- | Annotation Declaration
data AnnDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnType</a>
--   <a>AnnModule</a> <a>AnnClose</a></li>
--   </ul>
HsAnnotation :: XHsAnnotation pass -> AnnProvenance pass -> XRec pass (HsExpr pass) -> AnnDecl pass
XAnnDecl :: !XXAnnDecl pass -> AnnDecl pass

-- | Located Annotation Declaration
type LAnnDecl pass = XRec pass (AnnDecl pass)

-- | Annotation Provenance
data AnnProvenance pass
ValueAnnProvenance :: LIdP pass -> AnnProvenance pass
TypeAnnProvenance :: LIdP pass -> AnnProvenance pass
ModuleAnnProvenance :: AnnProvenance pass
annProvenanceName_maybe :: forall p. UnXRec p => AnnProvenance p -> Maybe (IdP p)

-- | Role Annotation Declaration
data RoleAnnotDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnRole</a></li>
--   </ul>
RoleAnnotDecl :: XCRoleAnnotDecl pass -> LIdP pass -> [XRec pass (Maybe Role)] -> RoleAnnotDecl pass
XRoleAnnotDecl :: !XXRoleAnnotDecl pass -> RoleAnnotDecl pass

-- | Located Role Annotation Declaration
type LRoleAnnotDecl pass = XRec pass (RoleAnnotDecl pass)
roleAnnotDeclName :: RoleAnnotDecl (GhcPass p) -> IdP (GhcPass p)

-- | type Family Result Signature
data FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> :</li>
--   </ul>
NoSig :: XNoSig pass -> FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a>,<a>AnnDcolon</a>,
--   <a>AnnCloseP</a></li>
--   </ul>
KindSig :: XCKindSig pass -> LHsKind pass -> FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a>,<a>AnnDcolon</a>,
--   <a>AnnCloseP</a>, <a>AnnEqual</a></li>
--   </ul>
TyVarSig :: XTyVarSig pass -> LHsTyVarBndr () pass -> FamilyResultSig pass
XFamilyResultSig :: !XXFamilyResultSig pass -> FamilyResultSig pass

-- | Located type Family Result Signature
type LFamilyResultSig pass = XRec pass (FamilyResultSig pass)

-- | If the user supplied an injectivity annotation it is represented using
--   InjectivityAnn. At the moment this is a single injectivity condition -
--   see Note [Injectivity annotation]. `Located name` stores the LHS of
--   injectivity condition. `[Located name]` stores the RHS of injectivity
--   condition. Example:
--   
--   type family Foo a b c = r | r -&gt; a c where ...
--   
--   This will be represented as "InjectivityAnn <tt>r</tt> [<tt>a</tt>,
--   <tt>c</tt>]"
data InjectivityAnn pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a>, <a>AnnVbar</a></li>
--   </ul>
InjectivityAnn :: XCInjectivityAnn pass -> LIdP pass -> [LIdP pass] -> InjectivityAnn pass
XInjectivityAnn :: !XXInjectivityAnn pass -> InjectivityAnn pass

-- | Located Injectivity Annotation
type LInjectivityAnn pass = XRec pass (InjectivityAnn pass)

-- | Maybe return name of the result type variable
resultVariableName :: FamilyResultSig (GhcPass a) -> Maybe (IdP (GhcPass a))
familyDeclLName :: FamilyDecl (GhcPass p) -> XRec (GhcPass p) (IdP (GhcPass p))
familyDeclName :: FamilyDecl (GhcPass p) -> IdP (GhcPass p)

-- | Haskell Group
--   
--   A <a>HsDecl</a> is categorised into a <a>HsGroup</a> before being fed
--   to the renamer.
data HsGroup p
HsGroup :: XCHsGroup p -> HsValBinds p -> [LSpliceDecl p] -> [TyClGroup p] -> [LDerivDecl p] -> [LFixitySig p] -> [LDefaultDecl p] -> [LForeignDecl p] -> [LWarnDecls p] -> [LAnnDecl p] -> [LRuleDecls p] -> [LDocDecl p] -> HsGroup p
[hs_ext] :: HsGroup p -> XCHsGroup p
[hs_valds] :: HsGroup p -> HsValBinds p
[hs_splcds] :: HsGroup p -> [LSpliceDecl p]
[hs_tyclds] :: HsGroup p -> [TyClGroup p]
[hs_derivds] :: HsGroup p -> [LDerivDecl p]
[hs_fixds] :: HsGroup p -> [LFixitySig p]
[hs_defds] :: HsGroup p -> [LDefaultDecl p]
[hs_fords] :: HsGroup p -> [LForeignDecl p]
[hs_warnds] :: HsGroup p -> [LWarnDecls p]
[hs_annds] :: HsGroup p -> [LAnnDecl p]
[hs_ruleds] :: HsGroup p -> [LRuleDecls p]
[hs_docs] :: HsGroup p -> [LDocDecl p]
XHsGroup :: !XXHsGroup p -> HsGroup p
emptyRdrGroup :: HsGroup (GhcPass p)
emptyRnGroup :: HsGroup (GhcPass p)
appendGroups :: HsGroup (GhcPass p) -> HsGroup (GhcPass p) -> HsGroup (GhcPass p)
hsGroupInstDecls :: HsGroup id -> [LInstDecl id]

-- | The fixity signatures for each top-level declaration and class method
--   in an <a>HsGroup</a>. See Note [Top-level fixity signatures in an
--   HsGroup]
hsGroupTopLevelFixitySigs :: HsGroup (GhcPass p) -> [LFixitySig (GhcPass p)]

-- | Partition a list of HsDecls into function/pattern bindings,
--   signatures, type family declarations, type family instances, and
--   documentation comments.
--   
--   Panics when given a declaration that cannot be put into any of the
--   output groups.
--   
--   The primary use of this function is to implement
--   <a>cvBindsAndSigs</a>.
partitionBindsAndSigs :: [LHsDecl GhcPs] -> (LHsBinds GhcPs, [LSig GhcPs], [LFamilyDecl GhcPs], [LTyFamInstDecl GhcPs], [LDataFamInstDecl GhcPs], [LDocDecl GhcPs])
instance Data.Data.Data GHC.Hs.Decls.DataDeclRn
instance Data.Data.Data GHC.Hs.Decls.HsRuleRn
instance GHC.Classes.Eq GHC.Hs.Decls.HsRuleAnn
instance Data.Data.Data GHC.Hs.Decls.HsRuleAnn
instance GHC.Utils.Outputable.Outputable GHC.Hs.Decls.XViaStrategyPs
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DocDecl name)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsGroup (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.SpliceDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Decls.SpliceDecoration
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.FamilyInfo pass)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.TyClDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.TyClGroup (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.FunDep (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.FamilyDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsDerivingClause (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DerivClauseTys (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.HsDataDefn (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.StandaloneKindSig (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ConDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.TyFamInstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DataFamInstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ClsInstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.InstDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Decls.NewOrData
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DerivDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DerivStrategy (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.DefaultDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ForeignDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ForeignImport (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.ForeignExport (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RuleDecls (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RuleDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RuleBndr (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.WarnDecls (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.WarnDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.AnnDecl (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Extension.IdP (GHC.Hs.Extension.GhcPass p)) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Decls.RoleAnnotDecl (GHC.Hs.Extension.GhcPass p))

module GHC.StgToJS.Prim
genPrim :: Bool -> Bool -> Type -> PrimOp -> [JExpr] -> [JExpr] -> PrimRes


-- | Core utils
module GHC.StgToJS.CoreUtils

-- | can we unbox C x to x, only if x is represented as a Number
isUnboxableCon :: DataCon -> Bool

-- | one-constructor types with one primitive field represented as a JS
--   Number can be unboxed
isUnboxable :: VarType -> Bool

-- | Number of slots occupied by a PrimRep
data SlotCount
NoSlot :: SlotCount
OneSlot :: SlotCount
TwoSlots :: SlotCount

-- | Return SlotCount as an Int
slotCount :: SlotCount -> Int

-- | Number of slots occupied by a value with the given VarType
varSize :: VarType -> Int
varSlotCount :: VarType -> SlotCount
typeSize :: Type -> Int
isVoid :: VarType -> Bool
isPtr :: VarType -> Bool
isSingleVar :: VarType -> Bool
isMultiVar :: VarType -> Bool

-- | can we pattern match on these values in a case?
isMatchable :: [VarType] -> Bool
tyConVt :: HasDebugCallStack => TyCon -> [VarType]
idVt :: HasDebugCallStack => Id -> [VarType]
typeVt :: HasDebugCallStack => Type -> [VarType]
uTypeVt :: HasDebugCallStack => UnaryType -> VarType
primRepVt :: HasDebugCallStack => PrimRep -> VarType
typePrimRep' :: HasDebugCallStack => UnaryType -> [PrimRep]

-- | Find the primitive representation of a <a>TyCon</a>. Defined here to
--   avoid module loops. Call this only on unlifted tycons.
tyConPrimRep' :: HasDebugCallStack => TyCon -> [PrimRep]

-- | Take a kind (of shape <tt>TYPE rr</tt>) and produce the
--   <a>PrimRep</a>s of values of types of this kind.
kindPrimRep' :: HasDebugCallStack => SDoc -> Kind -> [PrimRep]
primTypeVt :: HasDebugCallStack => Type -> VarType
argVt :: StgArg -> VarType
dataConType :: DataCon -> Type
isBoolDataCon :: DataCon -> Bool
fixedLayout :: [VarType] -> CILayout
stackSlotType :: Id -> VarType
idPrimReps :: Id -> [PrimRep]
typePrimReps :: Type -> [PrimRep]
primRepSize :: PrimRep -> SlotCount

-- | Associate the given values to each RrimRep in the given order, taking
--   into account the number of slots per PrimRep
assocPrimReps :: Outputable a => [PrimRep] -> [a] -> [(PrimRep, [a])]

-- | Associate the given values to the Id's PrimReps, taking into account
--   the number of slots per PrimRep
assocIdPrimReps :: Outputable a => Id -> [a] -> [(PrimRep, [a])]

-- | Associate the given JExpr to the Id's PrimReps, taking into account
--   the number of slots per PrimRep
assocIdExprs :: Id -> [JExpr] -> [TypedExpr]

-- | Return False only if we are *sure* it's a data type Look through
--   newtypes etc as much as possible
might_be_a_function :: HasDebugCallStack => Type -> Bool
mkArityTag :: Int -> Int -> Int
toTypeList :: [VarType] -> [Int]
instance GHC.Classes.Ord GHC.StgToJS.CoreUtils.SlotCount
instance GHC.Classes.Eq GHC.StgToJS.CoreUtils.SlotCount
instance GHC.Show.Show GHC.StgToJS.CoreUtils.SlotCount
instance GHC.Utils.Outputable.Outputable GHC.StgToJS.CoreUtils.SlotCount

module GHC.StgToJS.Sinker

-- | Unfloat some top-level unexported things
--   
--   GHC floats constants to the top level. This is fine in native code,
--   but with JS they occupy some global variable name. We can unfloat some
--   unexported things:
--   
--   <ul>
--   <li>global constructors, as long as they're referenced only once by
--   another global constructor and are not in a recursive binding
--   group</li>
--   <li>literals (small literals may also be sunk if they are used more
--   than once)</li>
--   </ul>
sinkPgm :: Module -> [CgStgTopBinding] -> (UniqFM Id CgStgExpr, [CgStgTopBinding])


module GHC.StgToJS.Ids

-- | Get fresh unique number
freshUnique :: G Int

-- | Get fresh local Ident of the form: h$$unit:module_uniq
freshIdent :: G Ident

-- | Generate unique Ident for the given ID (uncached!)
--   
--   The ident has the following forms:
--   
--   global Id: h$unit:module.name[_num][_type_suffix] local Id:
--   h$$unit:module.name[_num][_type_suffix]_uniq
--   
--   Note that the string is z-encoded except for "_" delimiters.
--   
--   Optional "_type_suffix" can be: - "_e" for IdEntry - "_con_e" for
--   IdConEntry
--   
--   Optional "_num" is passed as an argument to this function. It is used
--   for Haskell Ids that require several JS variables: e.g. 64-bit numbers
--   (Word64#, Int64#), Addr#, StablePtr#, unboxed tuples, etc.
makeIdentForId :: Id -> Maybe Int -> IdType -> Module -> Ident

-- | Retrieve the cached Ident for the given Id if there is one. Otherwise
--   make a new one with <a>makeIdentForId</a> and cache it.
cachedIdentForId :: Id -> Maybe Int -> IdType -> G Ident

-- | Retrieve default Ident for the given Id
identForId :: Id -> G Ident

-- | Retrieve default Ident for the given Id with sub index
--   
--   Some types, Word64, Addr#, unboxed tuple have more than one
--   corresponding JS var, hence we use the sub index to identify each
--   subpart / JS variable.
identForIdN :: Id -> Int -> G Ident

-- | Retrieve all the idents for the given Id.
identsForId :: Id -> G [Ident]

-- | Retrieve entry Ident for the given Id
identForEntryId :: Id -> G Ident

-- | Retrieve datacon entry Ident for the given Id
--   
--   Different name than the datacon wrapper.
identForDataConEntryId :: Id -> G Ident

-- | Retrieve datacon worker entry variable name for the given datacon
identForDataConWorker :: DataCon -> G Ident

-- | Retrieve default variable name for the given Id
varForId :: Id -> G JExpr

-- | Retrieve default variable name for the given Id with sub index
varForIdN :: Id -> Int -> G JExpr

-- | Retrieve all the JS vars for the given Id
varsForId :: Id -> G [JExpr]

-- | Retrieve entry variable name for the given Id
varForEntryId :: Id -> G JExpr

-- | Retrieve datacon entry variable name for the given Id
varForDataConEntryId :: Id -> G JExpr

-- | Retrieve datacon worker entry variable name for the given datacon
varForDataConWorker :: DataCon -> G JExpr

-- | Declare all js vars for the id
declVarsForId :: Id -> G JStat


-- | Utilities and wrappers for Stack manipulation in JS Land.
--   
--   In general, functions suffixed with a tick do the actual work,
--   functions suffixed with an <a>I</a> are identical to the non-I
--   versions but work on <a>Ident</a>s
--   
--   The stack in JS land is held in the special JS array 'h$stack' and the
--   stack pointer is held in 'h$sp'. The top of the stack thus exists at
--   'h$stack[h$sp]'. h$stack[h$sp + i] where i &gt; 0, moves deeper into
--   the stack into older entries, whereas h$stack[h$sp - i] moves towards
--   the top of the stack.
--   
--   The stack layout algorithm is slightly peculiar. It makes an effort to
--   remember recently popped things so that if these values need to be
--   pushed then they can be quickly. The implementation for this is
--   storing these values above the stack pointer, and the pushing will
--   skip slots that we know we will use and fill in slots marked as
--   unknown. Thus, you may find that our push and pop functions do some
--   non-traditional stack manipulation such as adding slots in pop or
--   removing slots in push.
module GHC.StgToJS.Stack

-- | Run the action, <tt>m</tt>, with no stack info
resetSlots :: G a -> G a

-- | run the action, <tt>m</tt>, with current stack info, but don't let
--   modifications propagate
isolateSlots :: G a -> G a

-- | overwrite our stack knowledge
setSlots :: [StackSlot] -> G ()

-- | retrieve our current stack knowledge
getSlots :: G [StackSlot]

-- | add knowledge about the stack slots
addSlots :: [StackSlot] -> G ()

-- | drop <tt>n</tt> slots from our stack knowledge
dropSlots :: Int -> G ()

-- | add <tt>n</tt> unknown slots to our stack knowledge
addUnknownSlots :: Int -> G ()
push :: [JExpr] -> G JStat
push' :: StgToJSConfig -> [JExpr] -> JStat

-- | Shrink the stack and stack pointer. NB: This function is unsafe when
--   the input <tt>n</tt>, is negative. This function wraps around
--   <a>adjSpN</a> which actually performs the work.
adjSpN :: Int -> G JStat

-- | Shrink the stack pointer by <tt>n</tt>. The stack grows downward so
--   substract
adjSpN' :: Int -> JStat

-- | Grow the stack pointer by <tt>n</tt> without modifying the stack
--   depth. The stack is just a JS array so we add to grow (instead of the
--   traditional subtract)
adjSp' :: Int -> JStat

-- | Wrapper which adjusts the stack pointer <i>and</i> modifies the stack
--   depth tracked in <a>G</a>. See also <a>adjSp'</a> which actually does
--   the stack pointer manipulation.
adjSp :: Int -> G JStat

-- | Partial Push functions. Like <a>pushN</a> except these push functions
--   skip slots. For example, <tt> function h$pp33(x1, x2) { h$sp += 6;
--   h$stack[(h$sp - 5)] = x1; h$stack[(h$sp - 0)] = x2; }; </tt>
--   
--   The 33rd entry skips slots 1-4 to bind the top of the stack and the
--   6th slot. See <a>pushOptimized</a> and <a>pushOptimized'</a> for use
--   cases.
pushNN :: Array Integer Ident

-- | Like <a>pushN'</a> but for the partial push functions
pushNN' :: Array Integer JExpr

-- | Convert all function symbols in <a>pushN</a> to global top-level
--   functions. This is a hack which converts the function symbols to
--   variables. This hack is caught in <a>prettyBlock'</a> to turn these
--   into global functions.
pushN' :: Array Int JExpr

-- | A constant array that holds global function symbols which do N pushes
--   onto the stack. For example: <tt> function h$p1(x1) { ++h$sp;
--   h$stack[(h$sp - 0)] = x1; }; function h$p2(x1, x2) { h$sp += 2;
--   h$stack[(h$sp - 1)] = x1; h$stack[(h$sp - 0)] = x2; }; </tt>
--   
--   and so on up to 32.
pushN :: Array Int Ident
pushOptimized' :: [(Id, Int)] -> G JStat

-- | optimized push that reuses existing values on stack automatically
--   chooses an optimized partial push (h$ppN) function when possible.
pushOptimized :: [(JExpr, Bool)] -> G JStat

-- | push a let-no-escape frame onto the stack
pushLneFrame :: HasDebugCallStack => Int -> ExprCtx -> G JStat

-- | Blindly pop N slots
popN :: Int -> G JStat

-- | Pop things, don't update the stack knowledge in <a>G</a>
popSkip :: Int -> [JExpr] -> JStat

-- | Pop but preserve the first N slots
popSkipI :: Int -> [(Ident, StackSlot)] -> G JStat

-- | Load 'length (xs :: [JExpr])' things from the stack at offset 'n ::
--   Int'. This function does no stack pointer manipulation, it merely
--   indexes into the stack and loads payloads into <tt>xs</tt>.
loadSkip :: Int -> [JExpr] -> JStat

-- | Wrapper around <a>updateThunk'</a>, performs the stack manipulation
--   before updating the Thunk.
updateThunk :: G JStat

-- | Update a thunk by checking <a>StgToJSConfig</a>. If the config inlines
--   black holes then update inline, else make an explicit call to the
--   black hole handler.
updateThunk' :: StgToJSConfig -> JStat

-- | Generate statements to update the current node with a blackhole
bhStats :: StgToJSConfig -> Bool -> JStat

module GHC.StgToJS.Literal

-- | Generate JS expressions for a Literal
--   
--   Literals represented with 2 values: * Addr# (Null and Strings): array
--   and offset * 64-bit values: high 32-bit, low 32-bit * labels: call to
--   h$mkFunctionPtr and 0, or function name and 0
genLit :: HasDebugCallStack => Literal -> G [JExpr]

-- | generate a literal for the static init tables
genStaticLit :: Literal -> G [StaticLit]


-- | Module to calculate the transitive dependencies of a module
module GHC.StgToJS.Deps

-- | Generate module dependency data
--   
--   Generate the object's dependency data, taking care that package and
--   module names are only stored once
genDependencyData :: HasDebugCallStack => Module -> [LinkableUnit] -> G Deps

module GHC.StgToJS.Closure
closureInfoStat :: Bool -> ClosureInfo -> JStat
closure :: ClosureInfo -> JStat -> JStat
conClosure :: Ident -> FastString -> CILayout -> Int -> JStat

-- | Used to pass arguments to newClosure with some safety
data Closure
Closure :: JExpr -> JExpr -> JExpr -> JExpr -> Maybe JExpr -> Closure
[clEntry] :: Closure -> JExpr
[clField1] :: Closure -> JExpr
[clField2] :: Closure -> JExpr
[clMeta] :: Closure -> JExpr
[clCC] :: Closure -> Maybe JExpr
newClosure :: Closure -> JExpr
assignClosure :: JExpr -> Closure -> JStat
data CopyCC
CopyCC :: CopyCC
DontCopyCC :: CopyCC
copyClosure :: CopyCC -> JExpr -> JExpr -> JStat


module GHC.StgToJS.DataCon

-- | Generate a data constructor. Special handling for unboxed tuples
genCon :: ExprCtx -> DataCon -> [JExpr] -> G JStat

-- | Allocate a data constructor. Allocate in this context means bind the
--   data constructor to <tt>to</tt>
allocCon :: Ident -> DataCon -> CostCentreStack -> [JExpr] -> G JStat

-- | Allocate an unboxed data constructor. If we have a bool we calculate
--   the right value. If not then we expect a singleton list and unbox by
--   converting ''C x' to <tt>x</tt>. NB. This function may panic.
allocUnboxedCon :: DataCon -> [JExpr] -> JExpr

-- | Allocate an entry function. See <a>hs</a> for the object layout.
allocDynamicE :: Bool -> JExpr -> [JExpr] -> Maybe JExpr -> JExpr

-- | Allocate a dynamic object
allocDynamic :: StgToJSConfig -> Bool -> Ident -> JExpr -> [JExpr] -> Maybe JExpr -> JStat


module GHC.StgToJS.Arg

-- | Generate JS code for an StgArg
genArg :: HasDebugCallStack => StgArg -> G [JExpr]

-- | Generate a Var as JExpr
genIdArg :: HasDebugCallStack => Id -> G [JExpr]

-- | Generate an Id as an Ident
genIdArgI :: HasDebugCallStack => Id -> G [Ident]

-- | Generate IDs for stack arguments. See <a>loadRetArgs</a> for use case
genIdStackArgI :: HasDebugCallStack => Id -> G [(Ident, StackSlot)]

-- | Allocate Static Constructors
allocConStatic :: HasDebugCallStack => Ident -> CostCentreStack -> DataCon -> [StgArg] -> G ()

-- | Allocate unboxed constructors
allocUnboxedConStatic :: DataCon -> [StaticArg] -> StaticArg

-- | Allocate Static list
allocateStaticList :: [StgArg] -> StgArg -> G StaticVal

-- | Generate JS code corresponding to a static arg
jsStaticArg :: StaticArg -> JExpr

-- | Generate JS code corresponding to a list of static args
jsStaticArgs :: [StaticArg] -> JExpr

module GHC.StgToJS.FFI
genPrimCall :: ExprCtx -> PrimCall -> [StgArg] -> Type -> G (JStat, ExprResult)
genForeignCall :: HasDebugCallStack => ExprCtx -> ForeignCall -> Type -> [JExpr] -> [StgArg] -> G (JStat, ExprResult)
saturateFFI :: JMacro a => Int -> a -> a


-- | Module that deals with expression application in JavaScript. In some
--   cases we rely on pre-generated functions that are bundled with the RTS
--   (see rtsApply).
module GHC.StgToJS.Apply

-- | Generate an application of some args to an Id.
--   
--   The case where args is null is common as it's used to generate the
--   evaluation code for an Id.
genApp :: HasDebugCallStack => ExprCtx -> Id -> [StgArg] -> G (JStat, ExprResult)

-- | Pre-generated functions for fast Apply. These are bundled with the
--   RTS.
rtsApply :: StgToJSConfig -> JStat
instance GHC.Classes.Ord GHC.StgToJS.Apply.ApplyConv
instance GHC.Classes.Eq GHC.StgToJS.Apply.ApplyConv
instance GHC.Show.Show GHC.StgToJS.Apply.ApplyConv
instance GHC.Classes.Ord GHC.StgToJS.Apply.ApplySpec
instance GHC.Classes.Eq GHC.StgToJS.Apply.ApplySpec
instance GHC.Show.Show GHC.StgToJS.Apply.ApplySpec


-- | Top level driver of the JavaScript Backend RTS. This file is an
--   implementation of the JS RTS for the JS backend written as an EDSL in
--   Haskell. It assumes the existence of pre-generated JS functions,
--   included as js-sources in base. These functions are similarly assumed
--   for non-inline Primops, See <a>Prim</a>. Most of the elements in this
--   module are constants in Haskell Land which define pieces of the JS
--   RTS.
module GHC.StgToJS.Rts.Rts

-- | The garbageCollector resets registers and result variables.
garbageCollector :: JStat

-- | Reset the register <tt>r</tt> in JS Land. Note that this "resets" by
--   setting the register to a dummy variable called "null", <i>not</i> by
--   setting to JS's nil value.
resetRegister :: StgReg -> JStat

-- | Reset the return variable <tt>r</tt> in JS Land. Note that this
--   "resets" by setting the register to a dummy variable called "null",
--   <i>not</i> by setting to JS's nil value.
resetResultVar :: StgRet -> JStat

-- | Define closures based on size, these functions are syntactic sugar,
--   e.g., a Haskell function which generates some useful JS. Each Closure
--   constructor follows the naming convention h$cN, where N is a natural
--   number. For example, h$c (with the nat omitted) is a JS Land
--   Constructor for a closure in JS land which has a single entry function
--   <tt>f</tt>, and no fields; identical to h$c0. h$c1 is a JS Land
--   Constructor for a closure with an entry function <tt>f</tt>, and a
--   <i>single</i> field <tt>x1</tt>, 'Just foo' is an example of this kind
--   of closure. h$c2 is a JS Land Constructor for a closure with an entry
--   function and two data fields: <tt>x1</tt> and <tt>x2</tt>. And so on.
--   Note that this has JIT performance implications; you should use h$c1,
--   h$c2, h$c3, ... h$c24 instead of making objects manually so layouts
--   and fields can be changed more easily and so the JIT can optimize
--   better.
closureConstructors :: StgToJSConfig -> JStat

-- | JS Payload to perform stack manipulation in the RTS
stackManip :: JStat
bitsIdx :: Integer -> [Int]
bhLneStats :: StgToJSConfig -> JExpr -> JExpr -> JStat

-- | JS payload to declare the registers
declRegs :: JStat

-- | JS payload to define getters and setters on the registers.
regGettersSetters :: JStat

-- | JS payload that defines the functions to load each register
loadRegs :: JStat

-- | Assign registers R1 ... Rn in descending order, that is assign Rn
--   first. This function uses the <a>assignRegs'</a> array to construct
--   functions which set the registers.
assignRegs :: StgToJSConfig -> [JExpr] -> JStat

-- | JS payload which defines an array of function symbols that set N
--   registers from M parameters. For example, h$l2 compiles to: <tt>
--   function h$l4(x1, x2, x3, x4) { h$r4 = x1; h$r3 = x2; h$r2 = x3; h$r1
--   = x4; }; </tt>
assignRegs' :: Array Int Ident

-- | JS payload to declare return variables.
declRets :: JStat

-- | JS payload defining the types closures.
closureTypes :: JStat

-- | JS payload declaring the RTS functions.
rtsDecls :: JStat

-- | print the embedded RTS to a String
rtsText :: StgToJSConfig -> String

-- | print the RTS declarations to a String.
rtsDeclsText :: String

-- | Wrapper over the RTS to guarentee saturation, see <a>Transform</a>
rts :: StgToJSConfig -> JStat

-- | JS Payload which defines the embedded RTS.
rts' :: StgToJSConfig -> JStat


module GHC.StgToJS.Expr

-- | Evaluate an expression in the given expression context (continuation)
genExpr :: HasDebugCallStack => ExprCtx -> CgStgExpr -> G (JStat, ExprResult)

-- | Generate the entry function types for identifiers. Note that this only
--   returns either <a>CIThunk</a> or <a>CIFun</a>. Everything else (PAP
--   Blackhole etc.) is filtered as not a RuntimeRepKinded type.
genEntryType :: HasDebugCallStack => [Id] -> G CIType

-- | Given a set of <a>Id</a>s, bind each <a>Id</a> to the appropriate data
--   fields in N registers. This assumes these data fields have already
--   been populated in the registers. For the empty, singleton, and binary
--   case use register 1, for any more use as many registers as necessary.
loadLiveFun :: [Id] -> G JStat
genStaticRefsRhs :: CgStgRhs -> G CIStatic
genStaticRefs :: LiveVars -> G CIStatic

-- | Generate the body of an object
genBody :: HasDebugCallStack => ExprCtx -> Id -> StgReg -> [Id] -> CgStgExpr -> G JStat
instance GHC.Base.Functor GHC.StgToJS.Expr.Branch
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.StgToJS.Expr.Branch a)

module GHC.HsToCore.Foreign.Utils
type Binding = (Id, CoreExpr)
getPrimTyOf :: Type -> UnaryType
primTyDescChar :: Platform -> Type -> Char

-- | Printed C Type to be used with CAPI calling convention
ppPrimTyConStgType :: TyCon -> Maybe String

module GHC.Core.InstEnv

-- | Dictionary Function Identifier
type DFunId = Id
type InstMatch = (ClsInst, [DFunInstType])
type ClsInstLookupResult = ([InstMatch], PotentialUnifiers, [InstMatch])
data PotentialUnifiers
NoUnifiers :: PotentialUnifiers
OneOrMoreUnifiers :: [ClsInst] -> PotentialUnifiers
getPotentialUnifiers :: PotentialUnifiers -> [ClsInst]
nullUnifiers :: PotentialUnifiers -> Bool

-- | The semantics allowed for overlapping instances for a particular
--   instance. See Note [Safe Haskell isSafeOverlap] in GHC.Core.InstEnv
--   for a explanation of the <a>isSafeOverlap</a> field.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# OVERLAPPABLE'</tt>
--   or <tt>'{-# OVERLAPPING'</tt> or <tt>'{-# OVERLAPS'</tt> or <tt>'{-#
--   INCOHERENT'</tt>, <a>AnnClose</a> <tt>`#-}`</tt>,</li>
--   </ul>
data OverlapFlag
OverlapFlag :: OverlapMode -> Bool -> OverlapFlag
[overlapMode] :: OverlapFlag -> OverlapMode
[isSafeOverlap] :: OverlapFlag -> Bool
data OverlapMode

-- | This instance must not overlap another <a>NoOverlap</a> instance.
--   However, it may be overlapped by <a>Overlapping</a> instances, and it
--   may overlap <a>Overlappable</a> instances.
NoOverlap :: SourceText -> OverlapMode

-- | Silently ignore this instance if you find a more specific one that
--   matches the constraint you are trying to resolve
--   
--   Example: constraint (Foo [Int]) instance Foo [Int] instance {-#
--   OVERLAPPABLE #-} Foo [a]
--   
--   Since the second instance has the Overlappable flag, the first
--   instance will be chosen (otherwise its ambiguous which to choose)
Overlappable :: SourceText -> OverlapMode

-- | Silently ignore any more general instances that may be used to solve
--   the constraint.
--   
--   Example: constraint (Foo [Int]) instance {-# OVERLAPPING #-} Foo [Int]
--   instance Foo [a]
--   
--   Since the first instance has the Overlapping flag, the second---more
--   general---instance will be ignored (otherwise it is ambiguous which to
--   choose)
Overlapping :: SourceText -> OverlapMode

-- | Equivalent to having both <a>Overlapping</a> and <a>Overlappable</a>
--   flags.
Overlaps :: SourceText -> OverlapMode

-- | Behave like Overlappable and Overlapping, and in addition pick an
--   arbitrary one if there are multiple matching candidates, and don't
--   worry about later instantiation
--   
--   Example: constraint (Foo [b]) instance {-# INCOHERENT -} Foo [Int]
--   instance Foo [a] Without the Incoherent flag, we'd complain that
--   instantiating <tt>b</tt> would change which instance was chosen. See
--   also Note [Incoherent instances] in <a>GHC.Core.InstEnv</a>
Incoherent :: SourceText -> OverlapMode
setOverlapModeMaybe :: OverlapFlag -> Maybe OverlapMode -> OverlapFlag

-- | A type-class instance. Note that there is some tricky laziness at work
--   here. See Note [ClsInst laziness and the rough-match fields] for more
--   details.
data ClsInst
ClsInst :: Name -> [RoughMatchTc] -> Name -> [TyVar] -> Class -> [Type] -> DFunId -> OverlapFlag -> IsOrphan -> ClsInst

-- | Class name
[is_cls_nm] :: ClsInst -> Name

-- | Top of type args The class itself is always the first element of this
--   list
[is_tcs] :: ClsInst -> [RoughMatchTc]

-- | <tt>is_dfun_name = idName . is_dfun</tt>.
--   
--   We use <a>is_dfun_name</a> for the visibility check,
--   <a>instIsVisible</a>, which needs to know the <a>GenModule</a> which
--   the dictionary is defined in. However, we cannot use the
--   <a>GenModule</a> attached to <a>is_dfun</a> since doing so would mean
--   we would potentially pull in an entire interface file unnecessarily.
--   This was the cause of #12367.
[is_dfun_name] :: ClsInst -> Name
[is_tvs] :: ClsInst -> [TyVar]
[is_cls] :: ClsInst -> Class
[is_tys] :: ClsInst -> [Type]
[is_dfun] :: ClsInst -> DFunId
[is_flag] :: ClsInst -> OverlapFlag
[is_orphan] :: ClsInst -> IsOrphan
type DFunInstType = Maybe Type
pprInstance :: ClsInst -> SDoc
pprInstanceHdr :: ClsInst -> SDoc
pprInstances :: [ClsInst] -> SDoc
instanceHead :: ClsInst -> ([TyVar], Class, [Type])
instanceSig :: ClsInst -> ([TyVar], [Type], Class, [Type])
mkLocalInstance :: DFunId -> OverlapFlag -> [TyVar] -> Class -> [Type] -> ClsInst
mkImportedInstance :: Name -> [RoughMatchTc] -> Name -> DFunId -> OverlapFlag -> IsOrphan -> ClsInst
instanceDFunId :: ClsInst -> DFunId
updateClsInstDFuns :: (DFunId -> DFunId) -> InstEnv -> InstEnv
updateClsInstDFun :: (DFunId -> DFunId) -> ClsInst -> ClsInst

-- | A fuzzy comparison function for class instances, intended for sorting
--   instances before displaying them to the user.
fuzzyClsInstCmp :: ClsInst -> ClsInst -> Ordering

-- | Collects the names of concrete types and type constructors that make
--   up the head of a class instance. For instance, given `class Foo a b`:
--   
--   `instance Foo (Either (Maybe Int) a) Bool` would yield [Either, Maybe,
--   Int, Bool]
--   
--   Used in the implementation of ":info" in GHCi.
--   
--   The <a>tcSplitSigmaTy</a> is because of instance Foo a =&gt; Baz T
--   where ... The decl is an orphan if Baz and T are both not locally
--   defined, even if Foo *is* locally defined
orphNamesOfClsInst :: ClsInst -> NameSet

-- | <a>InstEnvs</a> represents the combination of the global type class
--   instance environment, the local type class instance environment, and
--   the set of transitively reachable orphan modules (according to what
--   modules have been directly imported) used to test orphan instance
--   visibility.
data InstEnvs
InstEnvs :: InstEnv -> InstEnv -> VisibleOrphanModules -> InstEnvs
[ie_global] :: InstEnvs -> InstEnv
[ie_local] :: InstEnvs -> InstEnv
[ie_visible] :: InstEnvs -> VisibleOrphanModules

-- | Set of visible orphan modules, according to what modules have been
--   directly imported. This is based off of the dep_orphs field, which
--   records transitively reachable orphan modules (modules that define
--   orphan instances).
type VisibleOrphanModules = ModuleSet
data InstEnv
mkInstEnv :: [ClsInst] -> InstEnv
emptyInstEnv :: InstEnv

-- | Makes no particular effort to detect conflicts.
unionInstEnv :: InstEnv -> InstEnv -> InstEnv
extendInstEnv :: InstEnv -> ClsInst -> InstEnv
filterInstEnv :: (ClsInst -> Bool) -> InstEnv -> InstEnv
deleteFromInstEnv :: InstEnv -> ClsInst -> InstEnv
deleteDFunFromInstEnv :: InstEnv -> DFunId -> InstEnv
anyInstEnv :: (ClsInst -> Bool) -> InstEnv -> Bool

-- | True when when the instance heads are the same e.g. both are Eq
--   [(a,b)] Used for overriding in GHCi Obviously should be insensitive to
--   alpha-renaming
identicalClsInstHead :: ClsInst -> ClsInst -> Bool
extendInstEnvList :: InstEnv -> [ClsInst] -> InstEnv

-- | Look up an instance in the given instance environment. The given class
--   application must match exactly one instance and the match may not
--   contain any flexi type variables. If the lookup is unsuccessful, yield
--   'Left errorMessage'.
lookupUniqueInstEnv :: InstEnvs -> Class -> [Type] -> Either SDoc (ClsInst, [Type])

-- | See Note [Rules for instance lookup] ^ See Note [Safe Haskell
--   Overlapping Instances] in <a>GHC.Tc.Solver</a> ^ See Note [Safe
--   Haskell Overlapping Instances Implementation] in <a>GHC.Tc.Solver</a>
lookupInstEnv :: Bool -> InstEnvs -> Class -> [Type] -> ClsInstLookupResult
instEnvElts :: InstEnv -> [ClsInst]
instEnvClasses :: InstEnv -> UniqDSet Class
mapInstEnv :: (ClsInst -> ClsInst) -> InstEnv -> InstEnv

-- | Checks for an exact match of ClsInst in the instance environment. We
--   use this when we do signature checking in <a>GHC.Tc.Module</a>
memberInstEnv :: InstEnv -> ClsInst -> Bool

-- | Test if an instance is visible, by checking that its origin module is
--   in <a>VisibleOrphanModules</a>. See Note [Instance lookup and orphan
--   instances]
instIsVisible :: VisibleOrphanModules -> ClsInst -> Bool
classInstances :: InstEnvs -> Class -> [ClsInst]
instanceBindFun :: BindFun
classNameInstances :: InstEnvs -> Name -> [ClsInst]
instanceCantMatch :: [RoughMatchTc] -> [RoughMatchTc] -> Bool
roughMatchTcs :: [Type] -> [RoughMatchTc]
isOverlappable :: ClsInst -> Bool
isOverlapping :: ClsInst -> Bool
isIncoherent :: ClsInst -> Bool
instance Data.Data.Data GHC.Core.InstEnv.ClsInst
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.InstMatches
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.PotentialUnifiers
instance GHC.Base.Semigroup GHC.Core.InstEnv.PotentialUnifiers
instance GHC.Base.Monoid GHC.Core.InstEnv.PotentialUnifiers
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.InstEnv
instance GHC.Types.Name.NamedThing GHC.Core.InstEnv.ClsInst
instance GHC.Utils.Outputable.Outputable GHC.Core.InstEnv.ClsInst

module GHC.Unit.Module.ModDetails

-- | The <a>ModDetails</a> is essentially a cache for information in the
--   <tt>ModIface</tt> for home modules only. Information relating to
--   packages will be loaded into global environments in
--   <tt>ExternalPackageState</tt>.
data ModDetails
ModDetails :: [AvailInfo] -> !TypeEnv -> InstEnv -> ![FamInst] -> ![CoreRule] -> ![Annotation] -> [CompleteMatch] -> ModDetails
[md_exports] :: ModDetails -> [AvailInfo]

-- | Local type environment for this particular module Includes Ids,
--   TyCons, PatSyns
[md_types] :: ModDetails -> !TypeEnv

-- | <tt>DFunId</tt>s for the instances in this module
[md_insts] :: ModDetails -> InstEnv
[md_fam_insts] :: ModDetails -> ![FamInst]

-- | Domain may include <tt>Id</tt>s from other modules
[md_rules] :: ModDetails -> ![CoreRule]

-- | Annotations present in this module: currently they only annotate
--   things also declared in this module
[md_anns] :: ModDetails -> ![Annotation]

-- | Complete match pragmas for this module
[md_complete_matches] :: ModDetails -> [CompleteMatch]

-- | Constructs an empty ModDetails
emptyModDetails :: ModDetails


-- | Functional dependencies
--   
--   It's better to read it as: "if we know these, then we're going to know
--   these"
module GHC.Tc.Instance.FunDeps
data FunDepEqn loc
FDEqn :: [TyVar] -> [TypeEqn] -> PredType -> PredType -> loc -> FunDepEqn loc
[fd_qtvs] :: FunDepEqn loc -> [TyVar]
[fd_eqs] :: FunDepEqn loc -> [TypeEqn]
[fd_pred1] :: FunDepEqn loc -> PredType
[fd_pred2] :: FunDepEqn loc -> PredType
[fd_loc] :: FunDepEqn loc -> loc
pprEquation :: FunDepEqn a -> SDoc
improveFromInstEnv :: InstEnvs -> (PredType -> SrcSpan -> loc) -> Class -> [Type] -> [FunDepEqn loc]
improveFromAnother :: loc -> PredType -> PredType -> [FunDepEqn loc]
checkInstCoverage :: Bool -> Class -> [PredType] -> [Type] -> Validity
checkFunDeps :: InstEnvs -> ClsInst -> [ClsInst]
pprFundeps :: Outputable a => [FunDep a] -> SDoc
instFD :: FunDep TyVar -> [TyVar] -> [Type] -> FunDep Type
closeWrtFunDeps :: [PredType] -> TyCoVarSet -> TyCoVarSet
instance GHC.Base.Functor GHC.Tc.Instance.FunDeps.FunDepEqn
instance GHC.Utils.Outputable.Outputable (GHC.Tc.Instance.FunDeps.FunDepEqn a)

module GHC.Core.Coercion.Opt

-- | optCoercion applies a substitution to a coercion, *and* optimises it
--   to reduce its size
optCoercion :: OptCoercionOpts -> Subst -> Coercion -> NormalCo

-- | Check to make sure that an AxInstCo is internally consistent. Returns
--   the conflicting branch, if it exists See Note [Conflict checking with
--   AxiomInstCo]
checkAxInstCo :: Coercion -> Maybe CoAxBranch

-- | Coercion optimisation options
newtype OptCoercionOpts
OptCoercionOpts :: Bool -> OptCoercionOpts

-- | Enable coercion optimisation (reduce its size)
[optCoercionEnabled] :: OptCoercionOpts -> Bool

module GHC.Tc.Types.EvTerm
evDelayedError :: Type -> String -> EvTerm
evCallStack :: (MonadThings m, HasModule m, HasDynFlags m) => EvCallStack -> m EvExpr

module GHC.SysTools.Process

-- | Enable process jobs support on Windows if it can be expected to work
--   (e.g. <tt>process &gt;= 1.6.9.0</tt>).
enableProcessJobs :: CreateProcess -> CreateProcess
readCreateProcessWithExitCode' :: CreateProcess -> IO (ExitCode, String)
replaceVar :: (String, String) -> [(String, String)] -> [(String, String)]

-- | Version of <tt>System.Process.readProcessWithExitCode</tt> that takes
--   a key-value tuple to insert into the environment.
readProcessEnvWithExitCode :: String -> [String] -> (String, String) -> IO (ExitCode, String, String)
c_locale_env :: (String, String)
getGccEnv :: [Option] -> IO (Maybe [(String, String)])
runSomething :: Logger -> String -> String -> [Option] -> IO ()

-- | Run a command, placing the arguments in an external response file.
--   
--   This command is used in order to avoid overlong command line arguments
--   on Windows. The command line arguments are first written to an
--   external, temporary response file, and then passed to the linker via
--   @filepath. response files for passing them in. See:
--   
--   <a>https://gcc.gnu.org/wiki/Response_Files</a>
--   <a>https://gitlab.haskell.org/ghc/ghc/issues/10777</a>
runSomethingResponseFile :: Logger -> TmpFs -> DynFlags -> (String -> String) -> String -> String -> [Option] -> Maybe [(String, String)] -> IO ()
runSomethingFiltered :: Logger -> (String -> String) -> String -> String -> [Option] -> Maybe FilePath -> Maybe [(String, String)] -> IO ()
runSomethingWith :: Logger -> String -> String -> [Option] -> ([String] -> IO (ExitCode, a)) -> IO a
handleProc :: String -> String -> IO (ExitCode, r) -> IO r
builderMainLoop :: Logger -> (String -> String) -> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO ExitCode
readerProc :: Chan BuildMessage -> Handle -> (String -> String) -> IO ()
parseError :: String -> Maybe (String, Int, Int, String)

-- | Break a line of an error message into a filename and the rest of the
--   line, taking care to ignore colons in Windows drive letters (as noted
--   in #17786). For instance,
--   
--   <ul>
--   <li><tt>"hi.c: ABCD"</tt> is mapped to <tt>Just ("hi.c",
--   "ABCD")</tt></li>
--   <li><tt>"C:\hi.c: ABCD"</tt> is mapped to <tt>Just ("C:\hi.c",
--   "ABCD")</tt></li>
--   </ul>
breakColon :: String -> Maybe (String, String)
breakIntColon :: String -> Maybe (Int, String)
data BuildMessage
BuildMsg :: !SDoc -> BuildMessage
BuildError :: !SrcLoc -> !SDoc -> BuildMessage
EOF :: BuildMessage
linesPlatform :: String -> [String]

module GHC.SysTools.Info
neededLinkArgs :: LinkerInfo -> [Option]
getLinkerInfo :: Logger -> DynFlags -> IO LinkerInfo
getLinkerInfo' :: Logger -> DynFlags -> IO LinkerInfo

-- | Grab compiler info and cache it in DynFlags.
getCompilerInfo :: Logger -> DynFlags -> IO CompilerInfo

-- | Grab assembler info and cache it in DynFlags.
getAssemblerInfo :: Logger -> DynFlags -> IO CompilerInfo
getCompilerInfo' :: Logger -> String -> IO CompilerInfo

module GHC.SysTools.Tasks
runUnlit :: Logger -> DynFlags -> [Option] -> IO ()

-- | Prepend the working directory to the search path. Note [Filepaths and
--   Multiple Home Units]
augmentImports :: DynFlags -> [FilePath] -> [FilePath]
runCpp :: Logger -> DynFlags -> [Option] -> IO ()
runPp :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run compiler of C-like languages and raw objects (such as gcc or
--   clang).
runCc :: Maybe ForeignSrcLang -> Logger -> TmpFs -> DynFlags -> [Option] -> IO ()
isContainedIn :: String -> String -> Bool

-- | Run the linker with some arguments and return the output
askLd :: Logger -> DynFlags -> [Option] -> IO String
runAs :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run the LLVM Optimiser
runLlvmOpt :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run the LLVM Compiler
runLlvmLlc :: Logger -> DynFlags -> [Option] -> IO ()

-- | Run the clang compiler (used as an assembler for the LLVM backend on
--   OS X as LLVM doesn't support the OS X system assembler)
runClang :: Logger -> DynFlags -> [Option] -> IO ()
runEmscripten :: Logger -> DynFlags -> [Option] -> IO ()

-- | Figure out which version of LLVM we are running this session
figureLlvmVersion :: Logger -> DynFlags -> IO (Maybe LlvmVersion)
runLink :: Logger -> TmpFs -> DynFlags -> [Option] -> IO ()
runMergeObjects :: Logger -> TmpFs -> DynFlags -> [Option] -> IO ()
runAr :: Logger -> DynFlags -> Maybe FilePath -> [Option] -> IO ()
askOtool :: Logger -> ToolSettings -> Maybe FilePath -> [Option] -> IO String
runInstallNameTool :: Logger -> ToolSettings -> [Option] -> IO ()
runRanlib :: Logger -> DynFlags -> [Option] -> IO ()
runWindres :: Logger -> DynFlags -> [Option] -> IO ()
touch :: Logger -> DynFlags -> String -> String -> IO ()


-- | Various utilies used in the JS Linker
module GHC.StgToJS.Linker.Utils

-- | Parse option pragma in JS file
getOptionsFromJsFile :: FilePath -> IO [JSOption]
data JSOption
CPP :: JSOption

-- | Construct the Filename for the "binary" of Haskell code compiled to
--   JavaScript.
jsExeFileName :: DynFlags -> FilePath

-- | Retrieve library directories provided by the <tt>UnitId</tt> in
--   <tt>UnitState</tt>
getInstalledPackageLibDirs :: UnitState -> UnitId -> [ShortText]

-- | Retrieve the names of the libraries provided by <tt>UnitId</tt>
getInstalledPackageHsLibs :: UnitState -> UnitId -> [ShortText]

-- | CPP definitions that are inserted into every .pp file
commonCppDefs :: Bool -> ByteString
instance GHC.Classes.Ord GHC.StgToJS.Linker.Utils.JSOption
instance GHC.Classes.Eq GHC.StgToJS.Linker.Utils.JSOption

module GHC.Hs.Pat

-- | Pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnBang</a></li>
--   </ul>
data Pat p

-- | Wildcard Pattern The sole reason for a type on a WildPat is to support
--   hsPatType :: Pat Id -&gt; Type
WildPat :: XWildPat p -> Pat p

-- | Variable Pattern
VarPat :: XVarPat p -> LIdP p -> Pat p

-- | Lazy Pattern ^ - <a>AnnKeywordId</a> : <a>AnnTilde</a>
LazyPat :: XLazyPat p -> LPat p -> Pat p

-- | As pattern ^ - <a>AnnKeywordId</a> : <a>AnnAt</a>
AsPat :: XAsPat p -> LIdP p -> !LHsToken "@" p -> LPat p -> Pat p
ParPat :: XParPat p -> !LHsToken "(" p -> LPat p -> !LHsToken ")" p -> Pat p

-- | Bang pattern ^ - <a>AnnKeywordId</a> : <a>AnnBang</a>
BangPat :: XBangPat p -> LPat p -> Pat p

-- | Syntactic List
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
ListPat :: XListPat p -> [LPat p] -> Pat p

-- | Tuple sub-patterns
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt> or
--   <tt>'(#'</tt>, <a>AnnClose</a> <tt>')'</tt> or <tt>'#)'</tt></li>
--   </ul>
TuplePat :: XTuplePat p -> [LPat p] -> Boxity -> Pat p

-- | Anonymous sum pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnClose</a> <tt>'#)'</tt></li>
--   </ul>
SumPat :: XSumPat p -> LPat p -> ConTag -> SumWidth -> Pat p

-- | Constructor Pattern
ConPat :: XConPat p -> XRec p (ConLikeP p) -> HsConPatDetails p -> Pat p
[pat_con_ext] :: Pat p -> XConPat p
[pat_con] :: Pat p -> XRec p (ConLikeP p)
[pat_args] :: Pat p -> HsConPatDetails p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a></li>
--   </ul>
ViewPat :: XViewPat p -> LHsExpr p -> LPat p -> Pat p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'$('</tt> <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
SplicePat :: XSplicePat p -> HsUntypedSplice p -> Pat p

-- | Literal Pattern Used for *non-overloaded* literal patterns: Int#,
--   Char#, Int, Char, String, etc.
LitPat :: XLitPat p -> HsLit p -> Pat p

-- | Natural Pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnVal</a> <tt><tt>+</tt></tt></li>
--   </ul>
NPat :: XNPat p -> XRec p (HsOverLit p) -> Maybe (SyntaxExpr p) -> SyntaxExpr p -> Pat p

-- | n+k pattern
NPlusKPat :: XNPlusKPat p -> LIdP p -> XRec p (HsOverLit p) -> HsOverLit p -> SyntaxExpr p -> SyntaxExpr p -> Pat p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
SigPat :: XSigPat p -> LPat p -> HsPatSigType (NoGhcTc p) -> Pat p
XPat :: !XXPat p -> Pat p
type LPat p = XRec p (Pat p)
data EpAnnSumPat
EpAnnSumPat :: [AddEpAnn] -> [EpaLocation] -> [EpaLocation] -> EpAnnSumPat
[sumPatParens] :: EpAnnSumPat -> [AddEpAnn]
[sumPatVbarsBefore] :: EpAnnSumPat -> [EpaLocation]
[sumPatVbarsAfter] :: EpAnnSumPat -> [EpaLocation]

-- | This is the extension field for ConPat, added after typechecking It
--   adds quite a few extra fields, to support elaboration of pattern
--   matching.
data ConPatTc
ConPatTc :: [Type] -> [TyVar] -> [EvVar] -> TcEvBinds -> HsWrapper -> ConPatTc

-- | The universal arg types 1-1 with the universal tyvars of the
--   constructor/pattern synonym Use (conLikeResTy pat_con cpt_arg_tys) to
--   get the type of the pattern
[cpt_arg_tys] :: ConPatTc -> [Type]

-- | Existentially bound type variables in correctly-scoped order e.g. [k:*
--   x:k]
[cpt_tvs] :: ConPatTc -> [TyVar]

-- | Ditto *coercion variables* and *dictionaries* One reason for putting
--   coercion variable here I think is to ensure their kinds are zonked
[cpt_dicts] :: ConPatTc -> [EvVar]

-- | Bindings involving those dictionaries
[cpt_binds] :: ConPatTc -> TcEvBinds

-- | Extra wrapper to pass to the matcher Only relevant for
--   pattern-synonyms; ignored for data cons
[cpt_wrap] :: ConPatTc -> HsWrapper
type family ConLikeP x
data HsPatExpansion a b
HsPatExpanded :: a -> b -> HsPatExpansion a b

-- | Extension constructor for Pat, added after typechecking.
data XXPatGhcTc

-- | Coercion Pattern (translation only)
--   
--   During desugaring a (CoPat co pat) turns into a cast with <tt>co</tt>
--   on the scrutinee, followed by a match on <tt>pat</tt>.
CoPat :: HsWrapper -> Pat GhcTc -> Type -> XXPatGhcTc

-- | Coercion Pattern If co :: t1 ~ t2, p :: t2, then (CoPat co p) :: t1
[co_cpt_wrap] :: XXPatGhcTc -> HsWrapper

-- | Why not LPat? Ans: existing locn will do
[co_pat_inner] :: XXPatGhcTc -> Pat GhcTc

-- | Type of whole pattern, t1
[co_pat_ty] :: XXPatGhcTc -> Type

-- | Pattern expansion: original pattern, and desugared pattern, for
--   RebindableSyntax and other overloaded syntax such as OverloadedLists.
--   See Note [Rebindable syntax and HsExpansion].
ExpansionPat :: Pat GhcRn -> Pat GhcTc -> XXPatGhcTc

-- | Haskell Constructor Pattern Details
type HsConPatDetails p = HsConDetails (HsConPatTyArg (NoGhcTc p)) (LPat p) (HsRecFields p (LPat p))
hsConPatArgs :: forall p. UnXRec p => HsConPatDetails p -> [LPat p]

-- | Type argument in a data constructor pattern, e.g. the <tt>@a</tt> in
--   <tt>f (Just @a x) = ...</tt>.
data HsConPatTyArg p
HsConPatTyArg :: !LHsToken "@" p -> HsPatSigType p -> HsConPatTyArg p

-- | Haskell Record Fields
--   
--   HsRecFields is used only for patterns and expressions (not data type
--   declarations)
data HsRecFields p arg
HsRecFields :: [LHsRecField p arg] -> Maybe (XRec p RecFieldsDotDot) -> HsRecFields p arg
[rec_flds] :: HsRecFields p arg -> [LHsRecField p arg]
[rec_dotdot] :: HsRecFields p arg -> Maybe (XRec p RecFieldsDotDot)

-- | Haskell Field Binding
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a>,</li>
--   </ul>
--   
--   For details on above see Note [exact print annotations] in
--   GHC.Parser.Annotation
data HsFieldBind lhs rhs
HsFieldBind :: XHsFieldBind lhs -> lhs -> rhs -> Bool -> HsFieldBind lhs rhs
[hfbAnn] :: HsFieldBind lhs rhs -> XHsFieldBind lhs
[hfbLHS] :: HsFieldBind lhs rhs -> lhs

-- | Filled in by renamer when punning
[hfbRHS] :: HsFieldBind lhs rhs -> rhs

-- | Note [Punning]
[hfbPun] :: HsFieldBind lhs rhs -> Bool

-- | Located Haskell Record Field
type LHsFieldBind p id arg = XRec p (HsFieldBind id arg)

-- | Haskell Record Field
type HsRecField p arg = HsFieldBind (LFieldOcc p) arg

-- | Located Haskell Record Field
type LHsRecField p arg = XRec p (HsRecField p arg)

-- | Haskell Record Update Field
type HsRecUpdField p = HsFieldBind (LAmbiguousFieldOcc p) (LHsExpr p)

-- | Located Haskell Record Update Field
type LHsRecUpdField p = XRec p (HsRecUpdField p)

-- | Newtype to be able to have a specific XRec instance for the Int in
--   <a>rec_dotdot</a>
newtype RecFieldsDotDot
RecFieldsDotDot :: Int -> RecFieldsDotDot
[unRecFieldsDotDot] :: RecFieldsDotDot -> Int
hsRecFields :: forall p arg. UnXRec p => HsRecFields p arg -> [XCFieldOcc p]
hsRecFieldSel :: forall p arg. UnXRec p => HsRecField p arg -> XCFieldOcc p
hsRecFieldId :: HsRecField GhcTc arg -> Id
hsRecFieldsArgs :: forall p arg. UnXRec p => HsRecFields p arg -> [arg]
hsRecUpdFieldId :: HsFieldBind (LAmbiguousFieldOcc GhcTc) arg -> Located Id
hsRecUpdFieldOcc :: HsFieldBind (LAmbiguousFieldOcc GhcTc) arg -> LFieldOcc GhcTc
hsRecUpdFieldRdr :: HsRecUpdField (GhcPass p) -> Located RdrName
mkPrefixConPat :: DataCon -> [LPat GhcTc] -> [Type] -> LPat GhcTc
mkCharLitPat :: SourceText -> Char -> LPat GhcTc
mkNilPat :: Type -> LPat GhcTc

-- | Is the pattern any of combination of:
--   
--   <ul>
--   <li>(pat)</li>
--   <li>pat :: Type</li>
--   <li>~pat</li>
--   <li>!pat</li>
--   <li>x (variable)</li>
--   </ul>
isSimplePat :: LPat (GhcPass x) -> Maybe (IdP (GhcPass x))
looksLazyPatBind :: HsBind GhcTc -> Bool
isBangedLPat :: LPat (GhcPass p) -> Bool

-- | Parenthesize a pattern without token information
gParPat :: LPat (GhcPass pass) -> Pat (GhcPass pass)

-- | <tt><a>patNeedsParens</a> p pat</tt> returns <a>True</a> if the
--   pattern <tt>pat</tt> needs parentheses under precedence <tt>p</tt>.
patNeedsParens :: forall p. IsPass p => PprPrec -> Pat (GhcPass p) -> Bool

-- | <tt><a>parenthesizePat</a> p pat</tt> checks if
--   <tt><a>patNeedsParens</a> p pat</tt> is true, and if so, surrounds
--   <tt>pat</tt> with a <a>ParPat</a>. Otherwise, it simply returns
--   <tt>pat</tt>.
parenthesizePat :: IsPass p => PprPrec -> LPat (GhcPass p) -> LPat (GhcPass p)
isIrrefutableHsPat :: forall p. OutputableBndrId p => DynFlags -> LPat (GhcPass p) -> Bool
collectEvVarsPat :: Pat GhcTc -> Bag EvVar
collectEvVarsPats :: [Pat GhcTc] -> Bag EvVar
pprParendLPat :: OutputableBndrId p => PprPrec -> LPat (GhcPass p) -> SDoc
pprConArgs :: (OutputableBndrId p, Outputable (Anno (IdGhcP p))) => HsConPatDetails (GhcPass p) -> SDoc
pprLPat :: OutputableBndrId p => LPat (GhcPass p) -> SDoc
instance Data.Data.Data GHC.Hs.Pat.EpAnnSumPat
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (GHC.Hs.Pat.HsPatExpansion a b)
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Hs.Pat.HsPatExpansion a b)
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Type.HsPatSigType p) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.HsConPatTyArg p)
instance (GHC.Utils.Outputable.Outputable arg, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec p (Language.Haskell.Syntax.Pat.HsRecField p arg)), Language.Haskell.Syntax.Extension.XRec p Language.Haskell.Syntax.Pat.RecFieldsDotDot GHC.Types.~ GHC.Types.SrcLoc.Located Language.Haskell.Syntax.Pat.RecFieldsDotDot) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.HsRecFields p arg)
instance (GHC.Utils.Outputable.Outputable p, GHC.Utils.Outputable.OutputableBndr p, GHC.Utils.Outputable.Outputable arg) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.HsFieldBind p arg)
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Pat.Pat (GHC.Hs.Extension.GhcPass p))

module GHC.Parser.Types
data SumOrTuple b

-- | Last two are the locations of the '|' before and after the payload
Sum :: ConTag -> Arity -> LocatedA b -> [EpaLocation] -> [EpaLocation] -> SumOrTuple b
Tuple :: [Either (EpAnn EpaLocation) (LocatedA b)] -> SumOrTuple b
pprSumOrTuple :: Outputable b => Boxity -> SumOrTuple b -> SDoc

-- | See Note [Ambiguous syntactic categories] and Note [PatBuilder]
data PatBuilder p
PatBuilderPat :: Pat p -> PatBuilder p
PatBuilderPar :: LHsToken "(" p -> LocatedA (PatBuilder p) -> LHsToken ")" p -> PatBuilder p
PatBuilderApp :: LocatedA (PatBuilder p) -> LocatedA (PatBuilder p) -> PatBuilder p
PatBuilderAppType :: LocatedA (PatBuilder p) -> LHsToken "@" p -> HsPatSigType GhcPs -> PatBuilder p
PatBuilderOpApp :: LocatedA (PatBuilder p) -> LocatedN RdrName -> LocatedA (PatBuilder p) -> EpAnn [AddEpAnn] -> PatBuilder p
PatBuilderVar :: LocatedN RdrName -> PatBuilder p
PatBuilderOverLit :: HsOverLit GhcPs -> PatBuilder p

-- | An accumulator to build a prefix data constructor, e.g. when parsing
--   <tt>MkT A B C</tt>, the accumulator will evolve as follows:
--   
--   <pre>
--   1. PrefixDataConBuilder []        MkT
--   2. PrefixDataConBuilder [A]       MkT
--   3. PrefixDataConBuilder [A, B]    MkT
--   4. PrefixDataConBuilder [A, B, C] MkT
--   
--   </pre>
--   
--   There are two reasons we have a separate builder type instead of using
--   <tt>HsConDeclDetails GhcPs</tt> directly:
--   
--   <ol>
--   <li>It's faster, because <a>OrdList</a> gives us constant-time
--   snoc.</li>
--   <li>Having a separate type helps ensure that we don't forget to
--   finalize a <tt>RecTy</tt> into a <a>RecCon</a> (we do that in
--   <tt>dataConBuilderDetails</tt>).</li>
--   </ol>
--   
--   See Note [PatBuilder] for another builder type used in the parser.
--   Here the technique is similar, but the motivation is different.
data DataConBuilder
PrefixDataConBuilder :: OrdList (LHsType GhcPs) -> LocatedN RdrName -> DataConBuilder
InfixDataConBuilder :: LHsType GhcPs -> LocatedN RdrName -> LHsType GhcPs -> DataConBuilder
instance GHC.Utils.Outputable.Outputable GHC.Parser.Types.DataConBuilder
instance GHC.Utils.Outputable.Outputable (GHC.Parser.Types.PatBuilder GHC.Hs.Extension.GhcPs)


-- | Abstract Haskell syntax for expressions.
module GHC.Hs.Expr
data HsUntypedSpliceResult thing
HsUntypedSpliceTop :: ThModFinalizers -> thing -> HsUntypedSpliceResult thing

-- | TH finalizers produced by the splice.
[utsplice_result_finalizers] :: HsUntypedSpliceResult thing -> ThModFinalizers

-- | The result of splicing; See Note [Lifecycle of a splice]
[utsplice_result] :: HsUntypedSpliceResult thing -> thing
HsUntypedSpliceNested :: SplicePointName -> HsUntypedSpliceResult thing
type SplicePointName = Name

-- | Pending Renamer Splice
data PendingRnSplice
PendingRnSplice :: UntypedSpliceFlavour -> SplicePointName -> LHsExpr GhcRn -> PendingRnSplice
data DelayedSplice
DelayedSplice :: TcLclEnv -> LHsExpr GhcRn -> TcType -> LHsExpr GhcTc -> DelayedSplice

-- | Finalizers produced by a splice with <a>addModFinalizer</a>
--   
--   See Note [Delaying modFinalizers in untyped splices] in
--   GHC.Rename.Splice. For how this is used.
newtype ThModFinalizers
ThModFinalizers :: [ForeignRef (Q ())] -> ThModFinalizers

-- | The function to use in rebindable syntax. See Note [NoSyntaxExpr].
data SyntaxExprRn
SyntaxExprRn :: HsExpr GhcRn -> SyntaxExprRn
NoSyntaxExprRn :: SyntaxExprRn

-- | An expression with wrappers, used for rebindable syntax
--   
--   This should desugar to
--   
--   <pre>
--   syn_res_wrap $ syn_expr (syn_arg_wraps[0] arg0)
--                           (syn_arg_wraps[1] arg1) ...
--   </pre>
--   
--   where the actual arguments come from elsewhere in the AST.
data SyntaxExprTc
SyntaxExprTc :: HsExpr GhcTc -> [HsWrapper] -> HsWrapper -> SyntaxExprTc
[syn_expr] :: SyntaxExprTc -> HsExpr GhcTc
[syn_arg_wraps] :: SyntaxExprTc -> [HsWrapper]
[syn_res_wrap] :: SyntaxExprTc -> HsWrapper
NoSyntaxExprTc :: SyntaxExprTc

-- | Post-Type checking Expression
--   
--   PostTcExpr is an evidence expression attached to the syntax tree by
--   the type checker (c.f. postTcType).
type PostTcExpr = HsExpr GhcTc

-- | Post-Type checking Table
--   
--   We use a PostTcTable where there are a bunch of pieces of evidence,
--   more than is convenient to keep individually.
type PostTcTable = [(Name, PostTcExpr)]
type family SyntaxExprGhc (p :: Pass) = (r :: Type) | r -> p

-- | HsWrap appears only in typechecker output
data HsWrap hs_syn
HsWrap :: HsWrapper -> hs_syn GhcTc -> HsWrap hs_syn
data HsBracketTc
HsBracketTc :: HsQuote GhcRn -> Type -> Maybe QuoteWrapper -> [PendingTcSplice] -> HsBracketTc
[hsb_quote] :: HsBracketTc -> HsQuote GhcRn
[hsb_ty] :: HsBracketTc -> Type
[hsb_wrap] :: HsBracketTc -> Maybe QuoteWrapper
[hsb_splices] :: HsBracketTc -> [PendingTcSplice]

-- | Pending Type-checker Splice
data PendingTcSplice
PendingTcSplice :: SplicePointName -> LHsExpr GhcTc -> PendingTcSplice
data EpAnnHsCase
EpAnnHsCase :: EpaLocation -> EpaLocation -> [AddEpAnn] -> EpAnnHsCase
[hsCaseAnnCase] :: EpAnnHsCase -> EpaLocation
[hsCaseAnnOf] :: EpAnnHsCase -> EpaLocation
[hsCaseAnnsRest] :: EpAnnHsCase -> [AddEpAnn]
data EpAnnUnboundVar
EpAnnUnboundVar :: (EpaLocation, EpaLocation) -> EpaLocation -> EpAnnUnboundVar
[hsUnboundBackquotes] :: EpAnnUnboundVar -> (EpaLocation, EpaLocation)
[hsUnboundHole] :: EpAnnUnboundVar -> EpaLocation
data AnnExplicitSum
AnnExplicitSum :: EpaLocation -> [EpaLocation] -> [EpaLocation] -> EpaLocation -> AnnExplicitSum
[aesOpen] :: AnnExplicitSum -> EpaLocation
[aesBarsBefore] :: AnnExplicitSum -> [EpaLocation]
[aesBarsAfter] :: AnnExplicitSum -> [EpaLocation]
[aesClose] :: AnnExplicitSum -> EpaLocation
data AnnsIf
AnnsIf :: EpaLocation -> EpaLocation -> EpaLocation -> Maybe EpaLocation -> Maybe EpaLocation -> AnnsIf
[aiIf] :: AnnsIf -> EpaLocation
[aiThen] :: AnnsIf -> EpaLocation
[aiElse] :: AnnsIf -> EpaLocation
[aiThenSemi] :: AnnsIf -> Maybe EpaLocation
[aiElseSemi] :: AnnsIf -> Maybe EpaLocation
data AnnProjection
AnnProjection :: EpaLocation -> EpaLocation -> AnnProjection

-- | '('
[apOpen] :: AnnProjection -> EpaLocation

-- | ')'
[apClose] :: AnnProjection -> EpaLocation
data AnnFieldLabel
AnnFieldLabel :: Maybe EpaLocation -> AnnFieldLabel
[afDot] :: AnnFieldLabel -> Maybe EpaLocation
data HsExpansion orig expanded
HsExpanded :: orig -> expanded -> HsExpansion orig expanded
data XXExprGhcTc
WrapExpr :: {-# UNPACK #-} !HsWrap HsExpr -> XXExprGhcTc
ExpansionExpr :: {-# UNPACK #-} !HsExpansion (HsExpr GhcRn) (HsExpr GhcTc) -> XXExprGhcTc
ConLikeTc :: ConLike -> [TcTyVar] -> [Scaled TcType] -> XXExprGhcTc
HsTick :: CoreTickish -> LHsExpr GhcTc -> XXExprGhcTc
HsBinTick :: Int -> Int -> LHsExpr GhcTc -> XXExprGhcTc

-- | Command Syntax Table (for Arrow syntax)
type CmdSyntaxTable p = [(Name, HsExpr p)]
data CmdTopTc
CmdTopTc :: Type -> Type -> CmdSyntaxTable GhcTc -> CmdTopTc
data MatchGroupTc
MatchGroupTc :: [Scaled Type] -> Type -> Origin -> MatchGroupTc
[mg_arg_tys] :: MatchGroupTc -> [Scaled Type]
[mg_res_ty] :: MatchGroupTc -> Type
[mg_origin] :: MatchGroupTc -> Origin
data GrhsAnn
GrhsAnn :: Maybe EpaLocation -> AddEpAnn -> GrhsAnn
[ga_vbar] :: GrhsAnn -> Maybe EpaLocation

-- | Match separator location
[ga_sep] :: GrhsAnn -> AddEpAnn
data RecStmtTc
RecStmtTc :: Type -> [PostTcExpr] -> [PostTcExpr] -> Type -> RecStmtTc
[recS_bind_ty] :: RecStmtTc -> Type
[recS_later_rets] :: RecStmtTc -> [PostTcExpr]
[recS_rec_rets] :: RecStmtTc -> [PostTcExpr]
[recS_ret_ty] :: RecStmtTc -> Type
data XBindStmtRn
XBindStmtRn :: SyntaxExpr GhcRn -> FailOperator GhcRn -> XBindStmtRn
[xbsrn_bindOp] :: XBindStmtRn -> SyntaxExpr GhcRn
[xbsrn_failOp] :: XBindStmtRn -> FailOperator GhcRn
data XBindStmtTc
XBindStmtTc :: SyntaxExpr GhcTc -> Type -> Mult -> FailOperator GhcTc -> XBindStmtTc
[xbstc_bindOp] :: XBindStmtTc -> SyntaxExpr GhcTc
[xbstc_boundResultType] :: XBindStmtTc -> Type
[xbstc_boundResultMult] :: XBindStmtTc -> Mult
[xbstc_failOp] :: XBindStmtTc -> FailOperator GhcTc
data UntypedSpliceFlavour
UntypedExpSplice :: UntypedSpliceFlavour
UntypedPatSplice :: UntypedSpliceFlavour
UntypedTypeSplice :: UntypedSpliceFlavour
UntypedDeclSplice :: UntypedSpliceFlavour
pprParendExpr :: OutputableBndrId p => PprPrec -> HsExpr (GhcPass p) -> SDoc
pprExpr :: OutputableBndrId p => HsExpr (GhcPass p) -> SDoc
pprFunBind :: OutputableBndrId idR => MatchGroup (GhcPass idR) (LHsExpr (GhcPass idR)) -> SDoc
pprPatBind :: forall bndr p. (OutputableBndrId bndr, OutputableBndrId p) => LPat (GhcPass bndr) -> GRHSs (GhcPass p) (LHsExpr (GhcPass p)) -> SDoc
pprUntypedSplice :: forall p. OutputableBndrId p => Bool -> Maybe SplicePointName -> HsUntypedSplice (GhcPass p) -> SDoc
pprLExpr :: OutputableBndrId p => LHsExpr (GhcPass p) -> SDoc
prependQualified :: Maybe ModuleName -> SDoc -> SDoc
lamCaseKeyword :: LamCaseVariant -> SDoc
pp_rhs :: Outputable body => HsMatchContext passL -> body -> SDoc
pprTypedSplice :: OutputableBndrId p => Maybe SplicePointName -> LHsExpr (GhcPass p) -> SDoc
ppr_expr :: forall p. OutputableBndrId p => HsExpr (GhcPass p) -> SDoc
pprArg :: forall idL. OutputableBndrId idL => ApplicativeArg (GhcPass idL) -> SDoc

-- | This is used for rebindable-syntax pieces that are too polymorphic for
--   tcSyntaxOp (trS_fmap and the mzip in ParStmt)
noExpr :: HsExpr (GhcPass p)
noSyntaxExpr :: forall p. IsPass p => SyntaxExpr (GhcPass p)

-- | Make a 'SyntaxExpr GhcRn' from an expression Used only in
--   getMonadFailOp. See Note [Monad fail : Rebindable syntax, overloaded
--   strings] in <a>GHC.Rename.Expr</a>
mkSyntaxExpr :: HsExpr GhcRn -> SyntaxExprRn

-- | Make a <a>SyntaxExpr</a> from a <a>Name</a> (the "rn" is because this
--   is used in the renamer).
mkRnSyntaxExpr :: Name -> SyntaxExprRn
tupArgPresent :: HsTupArg (GhcPass p) -> Bool
isAtomicHsExpr :: forall p. IsPass p => HsExpr (GhcPass p) -> Bool
isQuietHsExpr :: HsExpr id -> Bool
pprBinds :: (OutputableBndrId idL, OutputableBndrId idR) => HsLocalBindsLR (GhcPass idL) (GhcPass idR) -> SDoc
ppr_lexpr :: OutputableBndrId p => LHsExpr (GhcPass p) -> SDoc
ppr_apps :: OutputableBndrId p => HsExpr (GhcPass p) -> [Either (LHsExpr (GhcPass p)) (LHsWcType (NoGhcTc (GhcPass p)))] -> SDoc
ppr_infix_expr :: forall p. OutputableBndrId p => HsExpr (GhcPass p) -> Maybe SDoc
pprDebugParendExpr :: OutputableBndrId p => PprPrec -> LHsExpr (GhcPass p) -> SDoc
pprMatches :: (OutputableBndrId idR, Outputable body) => MatchGroup (GhcPass idR) body -> SDoc
pprDo :: (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => HsDoFlavour -> [LStmt (GhcPass p) body] -> SDoc
thTyBrackets :: SDoc -> SDoc
ppr_with_pending_tc_splices :: SDoc -> [PendingTcSplice] -> SDoc
ppr_infix_expr_rn :: HsExpansion (HsExpr GhcRn) (HsExpr GhcRn) -> Maybe SDoc
ppr_infix_expr_tc :: XXExprGhcTc -> Maybe SDoc
pprParendLExpr :: OutputableBndrId p => PprPrec -> LHsExpr (GhcPass p) -> SDoc

-- | <tt><a>hsExprNeedsParens</a> p e</tt> returns <a>True</a> if the
--   expression <tt>e</tt> needs parentheses under precedence <tt>p</tt>.
hsExprNeedsParens :: forall p. IsPass p => PprPrec -> HsExpr (GhcPass p) -> Bool

-- | Parenthesize an expression without token information
gHsPar :: LHsExpr (GhcPass id) -> HsExpr (GhcPass id)

-- | <tt><a>parenthesizeHsExpr</a> p e</tt> checks if
--   <tt><a>hsExprNeedsParens</a> p e</tt> is true, and if so, surrounds
--   <tt>e</tt> with an <a>HsPar</a>. Otherwise, it simply returns
--   <tt>e</tt>.
parenthesizeHsExpr :: IsPass p => PprPrec -> LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
stripParensLHsExpr :: LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
stripParensHsExpr :: HsExpr (GhcPass p) -> HsExpr (GhcPass p)
pprCmd :: OutputableBndrId p => HsCmd (GhcPass p) -> SDoc
pprLCmd :: OutputableBndrId p => LHsCmd (GhcPass p) -> SDoc
isQuietHsCmd :: HsCmd id -> Bool
ppr_cmd :: forall p. OutputableBndrId p => HsCmd (GhcPass p) -> SDoc
ppr_lcmd :: OutputableBndrId p => LHsCmd (GhcPass p) -> SDoc
pprArrowExpr :: (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => [LStmt (GhcPass p) body] -> SDoc
pprCmdArg :: OutputableBndrId p => HsCmdTop (GhcPass p) -> SDoc
pprMatch :: (OutputableBndrId idR, Outputable body) => Match (GhcPass idR) body -> SDoc
isEmptyMatchGroup :: MatchGroup (GhcPass p) body -> Bool

-- | Is there only one RHS in this list of matches?
isSingletonMatchGroup :: [LMatch (GhcPass p) body] -> Bool
matchGroupArity :: MatchGroup (GhcPass id) body -> Arity
hsLMatchPats :: LMatch (GhcPass id) body -> [LPat (GhcPass id)]
pprGRHSs :: (OutputableBndrId idR, Outputable body) => HsMatchContext passL -> GRHSs (GhcPass idR) body -> SDoc
pprGRHS :: (OutputableBndrId idR, Outputable body) => HsMatchContext passL -> GRHS (GhcPass idR) body -> SDoc
matchSeparator :: HsMatchContext p -> SDoc
pprStmt :: forall idL idR body. (OutputableBndrId idL, OutputableBndrId idR, Anno (StmtLR (GhcPass idL) (GhcPass idR) body) ~ SrcSpanAnnA, Outputable body) => StmtLR (GhcPass idL) (GhcPass idR) body -> SDoc
pprBindStmt :: (Outputable pat, Outputable expr) => pat -> expr -> SDoc
pprTransStmt :: Outputable body => Maybe body -> body -> TransForm -> SDoc
ppr_do_stmts :: (OutputableBndrId idL, OutputableBndrId idR, Anno (StmtLR (GhcPass idL) (GhcPass idR) body) ~ SrcSpanAnnA, Outputable body) => [LStmtLR (GhcPass idL) (GhcPass idR) body] -> SDoc
pprTransformStmt :: OutputableBndrId p => [IdP (GhcPass p)] -> LHsExpr (GhcPass p) -> Maybe (LHsExpr (GhcPass p)) -> SDoc
pprBy :: Outputable body => Maybe body -> SDoc
ppr_module_name_prefix :: Maybe ModuleName -> SDoc
pprComp :: (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => [LStmt (GhcPass p) body] -> SDoc
pprQuals :: (OutputableBndrId p, Outputable body, Anno (StmtLR (GhcPass p) (GhcPass p) body) ~ SrcSpanAnnA) => [LStmt (GhcPass p) body] -> SDoc
pprPendingSplice :: OutputableBndrId p => SplicePointName -> LHsExpr (GhcPass p) -> SDoc
ppr_splice :: OutputableBndrId p => SDoc -> Maybe SplicePointName -> LHsExpr (GhcPass p) -> SDoc
ppr_quasi :: OutputableBndr p => p -> FastString -> SDoc
thBrackets :: SDoc -> SDoc -> SDoc
pp_dotdot :: SDoc
pprExternalSrcLoc :: (StringLiteral, (Int, Int), (Int, Int)) -> SDoc
pprHsArrType :: HsArrAppType -> SDoc
pprStmtContext :: (Outputable (IdP (NoGhcTc p)), UnXRec (NoGhcTc p)) => HsStmtContext p -> SDoc
matchContextErrString :: OutputableBndrId p => HsMatchContext (GhcPass p) -> SDoc
matchArrowContextErrString :: HsArrowMatchContext -> SDoc
matchDoContextErrString :: HsDoFlavour -> SDoc
pprMatchInCtxt :: (OutputableBndrId idR, Outputable body) => Match (GhcPass idR) body -> SDoc
pprMatchContext :: (Outputable (IdP (NoGhcTc p)), UnXRec (NoGhcTc p)) => HsMatchContext p -> SDoc
pprStmtInCtxt :: (OutputableBndrId idL, OutputableBndrId idR, OutputableBndrId ctx, Outputable body, Anno (StmtLR (GhcPass idL) (GhcPass idR) body) ~ SrcSpanAnnA) => HsStmtContext (GhcPass ctx) -> StmtLR (GhcPass idL) (GhcPass idR) body -> SDoc
pprAStmtContext :: (Outputable (IdP (NoGhcTc p)), UnXRec (NoGhcTc p)) => HsStmtContext p -> SDoc
pprMatchContextNoun :: forall p. (Outputable (IdP (NoGhcTc p)), UnXRec (NoGhcTc p)) => HsMatchContext p -> SDoc
pprArrowMatchContextNoun :: HsArrowMatchContext -> SDoc
pprMatchContextNouns :: forall p. (Outputable (IdP (NoGhcTc p)), UnXRec (NoGhcTc p)) => HsMatchContext p -> SDoc
pprArrowMatchContextNouns :: HsArrowMatchContext -> SDoc
pprAHsDoFlavour :: HsDoFlavour -> SDoc
pprHsDoFlavour :: HsDoFlavour -> SDoc
pprStmtCat :: Stmt (GhcPass p) body -> SDoc
pprFieldLabelStrings :: forall p. (UnXRec p, Outputable (XRec p FieldLabelString)) => FieldLabelStrings p -> SDoc
pprPrefixFastString :: FastString -> SDoc
instance Data.Data.Data GHC.Hs.Expr.EpAnnHsCase
instance Data.Data.Data GHC.Hs.Expr.EpAnnUnboundVar
instance Data.Data.Data GHC.Hs.Expr.AnnExplicitSum
instance Data.Data.Data GHC.Hs.Expr.AnnFieldLabel
instance Data.Data.Data GHC.Hs.Expr.AnnProjection
instance Data.Data.Data GHC.Hs.Expr.AnnsIf
instance (Data.Data.Data orig, Data.Data.Data expanded) => Data.Data.Data (GHC.Hs.Expr.HsExpansion orig expanded)
instance Data.Data.Data GHC.Hs.Expr.MatchGroupTc
instance Data.Data.Data GHC.Hs.Expr.GrhsAnn
instance Data.Data.Data GHC.Hs.Expr.UntypedSpliceFlavour
instance (Data.Data.Data (hs_syn GHC.Hs.Extension.GhcTc), Data.Typeable.Internal.Typeable hs_syn) => Data.Data.Data (GHC.Hs.Expr.HsWrap hs_syn)
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.PendingTcSplice
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.PendingRnSplice
instance Data.Data.Data GHC.Hs.Expr.DelayedSplice
instance Data.Data.Data GHC.Hs.Expr.ThModFinalizers
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.GrhsAnn
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.XXExprGhcTc
instance (GHC.Utils.Outputable.Outputable a, GHC.Utils.Outputable.Outputable b) => GHC.Utils.Outputable.Outputable (GHC.Hs.Expr.HsExpansion a b)
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.SyntaxExprTc
instance GHC.Utils.Outputable.Outputable GHC.Hs.Expr.SyntaxExprRn
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsExpr (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsPragE (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsCmd (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsCmdTop (GHC.Hs.Extension.GhcPass p))
instance (GHC.Hs.Extension.OutputableBndrId pr, GHC.Utils.Outputable.Outputable body) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.Match (GHC.Hs.Extension.GhcPass pr) body)
instance (GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.StmtLR (GHC.Hs.Extension.GhcPass idL) (GHC.Hs.Extension.GhcPass idL) (Language.Haskell.Syntax.Expr.LHsExpr (GHC.Hs.Extension.GhcPass idL))), GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XXParStmtBlock (GHC.Hs.Extension.GhcPass idL) (GHC.Hs.Extension.GhcPass idR))) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.ParStmtBlock (GHC.Hs.Extension.GhcPass idL) (GHC.Hs.Extension.GhcPass idR))
instance (GHC.Hs.Extension.OutputableBndrId pl, GHC.Hs.Extension.OutputableBndrId pr, Language.Haskell.Syntax.Extension.Anno (Language.Haskell.Syntax.Expr.StmtLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr) body) GHC.Types.~ GHC.Parser.Annotation.SrcSpanAnnA, GHC.Utils.Outputable.Outputable body) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.StmtLR (GHC.Hs.Extension.GhcPass pl) (GHC.Hs.Extension.GhcPass pr) body)
instance GHC.Hs.Extension.OutputableBndrId idL => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.ApplicativeArg (GHC.Hs.Extension.GhcPass idL))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsQuote (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.ArithSeqInfo (GHC.Hs.Extension.GhcPass p))
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsMatchContext (GHC.Hs.Extension.GhcPass p))
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Expr.LamCaseVariant
instance GHC.Utils.Outputable.Outputable Language.Haskell.Syntax.Expr.HsArrowMatchContext
instance GHC.Hs.Extension.OutputableBndrId p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.HsStmtContext (GHC.Hs.Extension.GhcPass p))
instance (Language.Haskell.Syntax.Extension.UnXRec p, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec p Language.Haskell.Syntax.Basic.FieldLabelString)) => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.FieldLabelStrings p)
instance (Language.Haskell.Syntax.Extension.UnXRec p, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec p Language.Haskell.Syntax.Basic.FieldLabelString)) => GHC.Utils.Outputable.OutputableBndr (Language.Haskell.Syntax.Expr.FieldLabelStrings p)
instance (Language.Haskell.Syntax.Extension.UnXRec p, GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Extension.XRec p Language.Haskell.Syntax.Basic.FieldLabelString)) => GHC.Utils.Outputable.OutputableBndr (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Expr.FieldLabelStrings p))
instance Language.Haskell.Syntax.Extension.UnXRec p => GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.Expr.DotFieldOcc p)
instance (Language.Haskell.Syntax.Extension.Anno a GHC.Types.~ GHC.Parser.Annotation.SrcSpanAnn' (GHC.Parser.Annotation.EpAnn an)) => Language.Haskell.Syntax.Extension.WrapXRec (GHC.Hs.Extension.GhcPass p) a

module GHC.Types.Hint.Ppr
perhapsAsPat :: SDoc
instance GHC.Utils.Outputable.Outputable GHC.Types.Hint.GhcHint


-- | Here we collect a variety of helper functions that construct or
--   analyse HsSyn. All these functions deal with generic HsSyn; functions
--   which deal with the instantiated versions are located elsewhere:
--   
--   Parameterised by Module ---------------- ------------- GhcPs/RdrName
--   GHC.Parser.PostProcess GhcRn/Name GHC.Rename.* GhcTc/Id
--   GHC.Tc.Utils.Zonk
--   
--   The <tt>mk*</tt> functions attempt to construct a
--   not-completely-useless SrcSpan from their components, compared with
--   the <tt>nl*</tt> functions which just attach noSrcSpan to everything.
module GHC.Hs.Utils

-- | <pre>
--   e =&gt; (e)
--   </pre>
mkHsPar :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsApp :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsAppWith :: (LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> HsExpr (GhcPass id) -> LHsExpr (GhcPass id)) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsApps :: LHsExpr (GhcPass id) -> [LHsExpr (GhcPass id)] -> LHsExpr (GhcPass id)
mkHsAppsWith :: (LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> HsExpr (GhcPass id) -> LHsExpr (GhcPass id)) -> LHsExpr (GhcPass id) -> [LHsExpr (GhcPass id)] -> LHsExpr (GhcPass id)
mkHsAppType :: LHsExpr GhcRn -> LHsWcType GhcRn -> LHsExpr GhcRn
mkHsAppTypes :: LHsExpr GhcRn -> [LHsWcType GhcRn] -> LHsExpr GhcRn

-- | A simple case alternative with a single pattern, no binds, no guards;
--   pre-typechecking
mkHsCaseAlt :: (Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcAnn NoEpAnns, Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA) => LPat (GhcPass p) -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
mkSimpleMatch :: (Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA, Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcAnn NoEpAnns) => HsMatchContext (GhcPass p) -> [LPat (GhcPass p)] -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
unguardedGRHSs :: Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcAnn NoEpAnns => SrcSpan -> LocatedA (body (GhcPass p)) -> EpAnn GrhsAnn -> GRHSs (GhcPass p) (LocatedA (body (GhcPass p)))
unguardedRHS :: Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcAnn NoEpAnns => EpAnn GrhsAnn -> SrcSpan -> LocatedA (body (GhcPass p)) -> [LGRHS (GhcPass p) (LocatedA (body (GhcPass p)))]
mkMatchGroup :: AnnoBody p body => Origin -> LocatedL [LocatedA (Match (GhcPass p) (LocatedA (body (GhcPass p))))] -> MatchGroup (GhcPass p) (LocatedA (body (GhcPass p)))
mkLamCaseMatchGroup :: AnnoBody p body => Origin -> LamCaseVariant -> LocatedL [LocatedA (Match (GhcPass p) (LocatedA (body (GhcPass p))))] -> MatchGroup (GhcPass p) (LocatedA (body (GhcPass p)))
mkMatch :: forall p. IsPass p => HsMatchContext (GhcPass p) -> [LPat (GhcPass p)] -> LHsExpr (GhcPass p) -> HsLocalBinds (GhcPass p) -> LMatch (GhcPass p) (LHsExpr (GhcPass p))

-- | Make a prefix, non-strict function <a>HsMatchContext</a>
mkPrefixFunRhs :: LIdP (NoGhcTc p) -> HsMatchContext p
mkHsLam :: (IsPass p, XMG (GhcPass p) (LHsExpr (GhcPass p)) ~ Origin) => [LPat (GhcPass p)] -> LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
mkHsIf :: LHsExpr GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs -> EpAnn AnnsIf -> HsExpr GhcPs
mkHsWrap :: HsWrapper -> HsExpr GhcTc -> HsExpr GhcTc
mkLHsWrap :: HsWrapper -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsWrapCo :: TcCoercionN -> HsExpr GhcTc -> HsExpr GhcTc
mkHsWrapCoR :: TcCoercionR -> HsExpr GhcTc -> HsExpr GhcTc
mkLHsWrapCo :: TcCoercionN -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsDictLet :: TcEvBinds -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsLams :: [TyVar] -> [EvVar] -> LHsExpr GhcTc -> LHsExpr GhcTc

-- | A useful function for building <tt>OpApps</tt>. The operator is always
--   a variable, and we don't know the fixity yet.
mkHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsDo :: HsDoFlavour -> LocatedL [ExprLStmt GhcPs] -> HsExpr GhcPs
mkHsDoAnns :: HsDoFlavour -> LocatedL [ExprLStmt GhcPs] -> EpAnn AnnList -> HsExpr GhcPs
mkHsComp :: HsDoFlavour -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsCompAnns :: HsDoFlavour -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> EpAnn AnnList -> HsExpr GhcPs
mkHsWrapPat :: HsWrapper -> Pat GhcTc -> Type -> Pat GhcTc
mkHsWrapPatCo :: TcCoercionN -> Pat GhcTc -> Type -> Pat GhcTc

-- | Wrap in parens if <tt><a>hsExprNeedsParens</a> appPrec</tt> says it
--   needs them So <tt>f x</tt> becomes <tt>(f x)</tt>, but <tt>3</tt>
--   stays as <tt>3</tt>.
mkLHsPar :: IsPass id => LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsCmdWrap :: HsWrapper -> HsCmd GhcTc -> HsCmd GhcTc
mkLHsCmdWrap :: HsWrapper -> LHsCmd GhcTc -> LHsCmd GhcTc
mkHsCmdIf :: LHsExpr GhcPs -> LHsCmd GhcPs -> LHsCmd GhcPs -> EpAnn AnnsIf -> HsCmd GhcPs
mkConLikeTc :: ConLike -> HsExpr GhcTc
nlHsTyApp :: Id -> [Type] -> LHsExpr GhcTc
nlHsTyApps :: Id -> [Type] -> [LHsExpr GhcTc] -> LHsExpr GhcTc
nlHsVar :: IsSrcSpanAnn p a => IdP (GhcPass p) -> LHsExpr (GhcPass p)
nl_HsVar :: IsSrcSpanAnn p a => IdP (GhcPass p) -> HsExpr (GhcPass p)

-- | NB: Only for <a>LHsExpr</a> <a>Id</a>.
nlHsDataCon :: DataCon -> LHsExpr GhcTc
nlHsLit :: HsLit (GhcPass p) -> LHsExpr (GhcPass p)
nlHsApp :: IsPass id => LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
nlHsApps :: IsSrcSpanAnn p a => IdP (GhcPass p) -> [LHsExpr (GhcPass p)] -> LHsExpr (GhcPass p)
nlHsSyntaxApps :: SyntaxExprTc -> [LHsExpr GhcTc] -> LHsExpr GhcTc
nlHsIntLit :: Integer -> LHsExpr (GhcPass p)
nlHsVarApps :: IsSrcSpanAnn p a => IdP (GhcPass p) -> [IdP (GhcPass p)] -> LHsExpr (GhcPass p)
nlHsDo :: HsDoFlavour -> [LStmt GhcPs (LHsExpr GhcPs)] -> LHsExpr GhcPs
nlHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs
nlHsLam :: LMatch GhcPs (LHsExpr GhcPs) -> LHsExpr GhcPs
nlHsPar :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
nlHsIf :: LHsExpr GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs
nlHsCase :: LHsExpr GhcPs -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsExpr GhcPs
nlList :: [LHsExpr GhcPs] -> LHsExpr GhcPs
mkLHsTupleExpr :: [LHsExpr (GhcPass p)] -> XExplicitTuple (GhcPass p) -> LHsExpr (GhcPass p)
mkLHsVarTuple :: IsSrcSpanAnn p a => [IdP (GhcPass p)] -> XExplicitTuple (GhcPass p) -> LHsExpr (GhcPass p)
missingTupArg :: EpAnn EpaLocation -> HsTupArg GhcPs
mkLocatedList :: Semigroup a => [GenLocated (SrcAnn a) e2] -> LocatedAn an [GenLocated (SrcAnn a) e2]

-- | Not infix, with place holders for coercion and free vars
mkFunBind :: Origin -> LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> HsBind GhcPs
mkVarBind :: IdP (GhcPass p) -> LHsExpr (GhcPass p) -> LHsBind (GhcPass p)
mkHsVarBind :: SrcSpan -> RdrName -> LHsExpr GhcPs -> LHsBind GhcPs

-- | Convenience function using <a>mkFunBind</a>. This is for generated
--   bindings only, do not use for user-written code.
mkSimpleGeneratedFunBind :: SrcSpan -> RdrName -> [LPat GhcPs] -> LHsExpr GhcPs -> LHsBind GhcPs

-- | In Name-land, with empty bind_fvs
mkTopFunBind :: Origin -> LocatedN Name -> [LMatch GhcRn (LHsExpr GhcRn)] -> HsBind GhcRn
mkPatSynBind :: LocatedN RdrName -> HsPatSynDetails GhcPs -> LPat GhcPs -> HsPatSynDir GhcPs -> EpAnn [AddEpAnn] -> HsBind GhcPs

-- | If any of the matches in the <a>FunBind</a> are infix, the
--   <a>FunBind</a> is considered infix.
isInfixFunBind :: forall id1 id2. UnXRec id2 => HsBindLR id1 id2 -> Bool

-- | Return the <a>SrcSpan</a> encompassing the contents of any enclosed
--   binds
spanHsLocaLBinds :: HsLocalBinds (GhcPass p) -> SrcSpan
mkHsIntegral :: IntegralLit -> HsOverLit GhcPs
mkHsFractional :: FractionalLit -> HsOverLit GhcPs
mkHsIsString :: SourceText -> FastString -> HsOverLit GhcPs
mkHsString :: String -> HsLit (GhcPass p)
mkHsStringFS :: FastString -> HsLit (GhcPass p)
mkHsStringPrimLit :: FastString -> HsLit (GhcPass p)
mkHsCharPrimLit :: Char -> HsLit (GhcPass p)
mkNPat :: LocatedAn NoEpAnns (HsOverLit GhcPs) -> Maybe (SyntaxExpr GhcPs) -> EpAnn [AddEpAnn] -> Pat GhcPs
mkNPlusKPat :: LocatedN RdrName -> LocatedAn NoEpAnns (HsOverLit GhcPs) -> EpAnn EpaLocation -> Pat GhcPs
nlVarPat :: IsSrcSpanAnn p a => IdP (GhcPass p) -> LPat (GhcPass p)
nlLitPat :: HsLit GhcPs -> LPat GhcPs
nlConVarPat :: RdrName -> [RdrName] -> LPat GhcPs
nlConVarPatName :: Name -> [Name] -> LPat GhcRn
nlConPat :: RdrName -> [LPat GhcPs] -> LPat GhcPs
nlConPatName :: Name -> [LPat GhcRn] -> LPat GhcRn
nlInfixConPat :: RdrName -> LPat GhcPs -> LPat GhcPs -> LPat GhcPs
nlNullaryConPat :: RdrName -> LPat GhcPs
nlWildConPat :: DataCon -> LPat GhcPs

-- | Wildcard pattern - after parsing
nlWildPat :: LPat GhcPs

-- | Wildcard pattern - after renaming
nlWildPatName :: LPat GhcRn
nlTuplePat :: [LPat GhcPs] -> Boxity -> LPat GhcPs
mkParPat :: IsPass p => LPat (GhcPass p) -> LPat (GhcPass p)
nlParPat :: LPat (GhcPass name) -> LPat (GhcPass name)

-- | The Big equivalents for the source tuple expressions
mkBigLHsVarTup :: IsSrcSpanAnn p a => [IdP (GhcPass p)] -> XExplicitTuple (GhcPass p) -> LHsExpr (GhcPass p)
mkBigLHsTup :: [LHsExpr (GhcPass id)] -> XExplicitTuple (GhcPass id) -> LHsExpr (GhcPass id)

-- | The Big equivalents for the source tuple patterns
mkBigLHsVarPatTup :: [IdP GhcRn] -> LPat GhcRn
mkBigLHsPatTup :: [LPat GhcRn] -> LPat GhcRn
mkHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
mkHsAppKindTy :: XAppKindTy (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)

-- | Convert an <a>LHsType</a> to an <a>LHsSigType</a>.
hsTypeToHsSigType :: LHsType GhcPs -> LHsSigType GhcPs

-- | Convert an <a>LHsType</a> to an <a>LHsSigWcType</a>.
hsTypeToHsSigWcType :: LHsType GhcPs -> LHsSigWcType GhcPs

-- | Convert <a>TypeSig</a> to <a>ClassOpSig</a>. The former is what is
--   parsed, but the latter is what we need in class/instance declarations
mkClassOpSigs :: [LSig GhcPs] -> [LSig GhcPs]
mkHsSigEnv :: forall a. (LSig GhcRn -> Maybe ([LocatedN Name], a)) -> [LSig GhcRn] -> NameEnv a
nlHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsAppKindTy :: LHsType (GhcPass p) -> LHsKind (GhcPass p) -> LHsType (GhcPass p)
nlHsTyVar :: IsSrcSpanAnn p a => PromotionFlag -> IdP (GhcPass p) -> LHsType (GhcPass p)
nlHsFunTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsParTy :: LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsTyConApp :: IsSrcSpanAnn p a => PromotionFlag -> LexicalFixity -> IdP (GhcPass p) -> [LHsTypeArg (GhcPass p)] -> LHsType (GhcPass p)
mkTransformStmt :: EpAnn [AddEpAnn] -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkTransformByStmt :: EpAnn [AddEpAnn] -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkBodyStmt :: LocatedA (bodyR GhcPs) -> StmtLR (GhcPass idL) GhcPs (LocatedA (bodyR GhcPs))
mkPsBindStmt :: EpAnn [AddEpAnn] -> LPat GhcPs -> LocatedA (bodyR GhcPs) -> StmtLR GhcPs GhcPs (LocatedA (bodyR GhcPs))
mkRnBindStmt :: LPat GhcRn -> LocatedA (bodyR GhcRn) -> StmtLR GhcRn GhcRn (LocatedA (bodyR GhcRn))
mkTcBindStmt :: LPat GhcTc -> LocatedA (bodyR GhcTc) -> StmtLR GhcTc GhcTc (LocatedA (bodyR GhcTc))
mkLastStmt :: IsPass idR => LocatedA (bodyR (GhcPass idR)) -> StmtLR (GhcPass idL) (GhcPass idR) (LocatedA (bodyR (GhcPass idR)))
emptyTransStmt :: EpAnn [AddEpAnn] -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkGroupUsingStmt :: EpAnn [AddEpAnn] -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkGroupByUsingStmt :: EpAnn [AddEpAnn] -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
emptyRecStmt :: Anno [GenLocated (Anno (StmtLR (GhcPass idL) GhcPs bodyR)) (StmtLR (GhcPass idL) GhcPs bodyR)] ~ SrcSpanAnnL => StmtLR (GhcPass idL) GhcPs bodyR
emptyRecStmtName :: Anno [GenLocated (Anno (StmtLR GhcRn GhcRn bodyR)) (StmtLR GhcRn GhcRn bodyR)] ~ SrcSpanAnnL => StmtLR GhcRn GhcRn bodyR
emptyRecStmtId :: Stmt GhcTc (LocatedA (HsCmd GhcTc))
mkRecStmt :: forall (idL :: Pass) bodyR. Anno [GenLocated (Anno (StmtLR (GhcPass idL) GhcPs bodyR)) (StmtLR (GhcPass idL) GhcPs bodyR)] ~ SrcSpanAnnL => EpAnn AnnList -> LocatedL [LStmtLR (GhcPass idL) GhcPs bodyR] -> StmtLR (GhcPass idL) GhcPs bodyR
unitRecStmtTc :: RecStmtTc
mkLetStmt :: EpAnn [AddEpAnn] -> HsLocalBinds GhcPs -> StmtLR GhcPs GhcPs (LocatedA b)

-- | Should we treat this as an unlifted bind? This will be true for any
--   bind that binds an unlifted variable, but we must be careful around
--   AbsBinds. See Note [Unlifted id check in isUnliftedHsBind]. For usage
--   information, see Note [Strict binds checks] is GHC.HsToCore.Binds.
isUnliftedHsBind :: HsBind GhcTc -> Bool

-- | Is a binding a strict variable or pattern bind (e.g. <tt>!x =
--   ...</tt>)?
isBangedHsBind :: HsBind GhcTc -> Bool
collectLocalBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> HsLocalBindsLR (GhcPass idL) (GhcPass idR) -> [IdP (GhcPass idL)]
collectHsValBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> HsValBindsLR (GhcPass idL) idR -> [IdP (GhcPass idL)]

-- | Same as <a>collectHsBindsBinders</a>, but works over a list of
--   bindings
collectHsBindListBinders :: forall p idR. CollectPass p => CollectFlag p -> [LHsBindLR p idR] -> [IdP p]

-- | Collect <a>Id</a> binders only, or <a>Id</a>s + pattern synonyms,
--   respectively
collectHsIdBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> HsValBindsLR (GhcPass idL) (GhcPass idR) -> [IdP (GhcPass idL)]
collectHsBindsBinders :: CollectPass p => CollectFlag p -> LHsBindsLR p idR -> [IdP p]

-- | Collect both <a>Id</a>s and pattern-synonym binders
collectHsBindBinders :: CollectPass p => CollectFlag p -> HsBindLR p idR -> [IdP p]

-- | Used exclusively for the bindings of an instance decl which are all
--   <tt>FunBinds</tt>
collectMethodBinders :: forall idL idR. UnXRec idL => LHsBindsLR idL idR -> [LIdP idL]
collectPatBinders :: CollectPass p => CollectFlag p -> LPat p -> [IdP p]
collectPatsBinders :: CollectPass p => CollectFlag p -> [LPat p] -> [IdP p]
collectLStmtsBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> [LStmtLR (GhcPass idL) (GhcPass idR) body] -> [IdP (GhcPass idL)]
collectStmtsBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> [StmtLR (GhcPass idL) (GhcPass idR) body] -> [IdP (GhcPass idL)]
collectLStmtBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> LStmtLR (GhcPass idL) (GhcPass idR) body -> [IdP (GhcPass idL)]
collectStmtBinders :: CollectPass (GhcPass idL) => CollectFlag (GhcPass idL) -> StmtLR (GhcPass idL) (GhcPass idR) body -> [IdP (GhcPass idL)]

-- | This class specifies how to collect variable identifiers from
--   extension patterns in the given pass. Consumers of the GHC API that
--   define their own passes should feel free to implement instances in
--   order to make use of functions which depend on it.
--   
--   In particular, Haddock already makes use of this, with an instance for
--   its <tt>DocNameI</tt> pass so that it can reuse the code in GHC for
--   collecting binders.
class UnXRec p => CollectPass p
collectXXPat :: CollectPass p => CollectFlag p -> XXPat p -> [IdP p] -> [IdP p]
collectXXHsBindsLR :: forall pR. CollectPass p => XXHsBindsLR p pR -> [IdP p] -> [IdP p]
collectXSplicePat :: CollectPass p => CollectFlag p -> XSplicePat p -> [IdP p] -> [IdP p]

-- | Indicate if evidence binders have to be collected.
--   
--   This type is used as a boolean (should we collect evidence binders or
--   not?) but also to pass an evidence that the AST has been typechecked
--   when we do want to collect evidence binders, otherwise these binders
--   are not available.
--   
--   See Note [Dictionary binders in ConPatOut]
data CollectFlag p

-- | Don't collect evidence binders
[CollNoDictBinders] :: CollectFlag p

-- | Collect evidence binders
[CollWithDictBinders] :: CollectFlag GhcTc

-- | Returns all the <i>binding</i> names of the decl. The first one is
--   guaranteed to be the name of the decl. The first component represents
--   all binding names except record fields; the second represents field
--   occurrences. For record fields mentioned in multiple constructors, the
--   SrcLoc will be from the first occurrence.
--   
--   Each returned (Located name) has a SrcSpan for the <i>whole</i>
--   declaration. See Note [SrcSpan for binders]
hsLTyClDeclBinders :: IsPass p => LocatedA (TyClDecl (GhcPass p)) -> ([LocatedA (IdP (GhcPass p))], [LFieldOcc (GhcPass p)])
hsTyClForeignBinders :: [TyClGroup GhcRn] -> [LForeignDecl GhcRn] -> [Name]

-- | Collects record pattern-synonym selectors only; the pattern synonym
--   names are collected by <a>collectHsValBinders</a>.
hsPatSynSelectors :: IsPass p => HsValBinds (GhcPass p) -> [FieldOcc (GhcPass p)]
getPatSynBinds :: forall id. UnXRec id => [(RecFlag, LHsBinds id)] -> [PatSynBind id id]

-- | See Note [SrcSpan for binders]
hsForeignDeclsBinders :: forall p a. (UnXRec (GhcPass p), IsSrcSpanAnn p a) => [LForeignDecl (GhcPass p)] -> [LIdP (GhcPass p)]
hsGroupBinders :: HsGroup GhcRn -> [Name]

-- | the <a>SrcLoc</a> returned are for the whole declarations, not just
--   the names
hsDataFamInstBinders :: IsPass p => DataFamInstDecl (GhcPass p) -> ([LocatedA (IdP (GhcPass p))], [LFieldOcc (GhcPass p)])
lStmtsImplicits :: [LStmtLR GhcRn (GhcPass idR) (LocatedA (body (GhcPass idR)))] -> [(SrcSpan, [Name])]
hsValBindsImplicits :: HsValBindsLR GhcRn (GhcPass idR) -> [(SrcSpan, [Name])]
lPatImplicits :: LPat GhcRn -> [(SrcSpan, [Name])]
instance GHC.Hs.Extension.IsPass p => GHC.Hs.Utils.CollectPass (GHC.Hs.Extension.GhcPass p)

module GHC.Hs.Instances
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsLocalBindsLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsValBindsLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (GHC.Hs.Binds.NHsValBindsLR GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (GHC.Hs.Binds.NHsValBindsLR GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (GHC.Hs.Binds.NHsValBindsLR GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsBindLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data GHC.Hs.Binds.AbsBinds
instance Data.Data.Data GHC.Hs.Binds.ABExport
instance Data.Data.Data (Language.Haskell.Syntax.Binds.RecordPatSynField GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.RecordPatSynField GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.RecordPatSynField GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.PatSynBind GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsIPBinds GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsIPBinds GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsIPBinds GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.IPBind GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.IPBind GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.IPBind GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.Sig GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.Sig GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.Sig GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsPatSynDir GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsPatSynDir GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Binds.HsPatSynDir GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsGroup GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsGroup GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsGroup GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data rhs => Data.Data.Data (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcPs rhs)
instance Data.Data.Data rhs => Data.Data.Data (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn rhs)
instance Data.Data.Data rhs => Data.Data.Data (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcTc rhs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignImport GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignImport GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignImport GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignExport GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignExport GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.ForeignExport GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.FieldLabelStrings GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.FieldLabelStrings GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.FieldLabelStrings GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.DotFieldOcc GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.DotFieldOcc GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.DotFieldOcc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsPragE GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsPragE GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsPragE GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsTupArg GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsTupArg GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsTupArg GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmdTop GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmdTop GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsCmdTop GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.MatchGroup GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.Match GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHSs GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.GRHS GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data (Language.Haskell.Syntax.Expr.StmtLR GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcTc)))
instance Data.Data.Data GHC.Hs.Expr.RecStmtTc
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcPs GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcRn GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ParStmtBlock GHC.Hs.Extension.GhcTc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ApplicativeArg GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ApplicativeArg GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ApplicativeArg GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsStmtContext GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsStmtContext GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsStmtContext GHC.Hs.Extension.GhcTc)
instance Data.Data.Data Language.Haskell.Syntax.Expr.HsArrowMatchContext
instance Data.Data.Data Language.Haskell.Syntax.Expr.HsDoFlavour
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsMatchContext GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsMatchContext GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsMatchContext GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsUntypedSplice GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsUntypedSplice GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsUntypedSplice GHC.Hs.Extension.GhcTc)
instance Data.Data.Data a => Data.Data.Data (GHC.Hs.Expr.HsUntypedSpliceResult a)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsQuote GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsQuote GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.HsQuote GHC.Hs.Extension.GhcTc)
instance Data.Data.Data GHC.Hs.Expr.HsBracketTc
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ArithSeqInfo GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ArithSeqInfo GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Expr.ArithSeqInfo GHC.Hs.Extension.GhcTc)
instance Data.Data.Data GHC.Hs.Expr.CmdTopTc
instance Data.Data.Data GHC.Hs.Expr.PendingRnSplice
instance Data.Data.Data GHC.Hs.Expr.PendingTcSplice
instance Data.Data.Data GHC.Hs.Expr.SyntaxExprRn
instance Data.Data.Data GHC.Hs.Expr.SyntaxExprTc
instance Data.Data.Data GHC.Hs.Expr.XBindStmtRn
instance Data.Data.Data GHC.Hs.Expr.XBindStmtTc
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsLit GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsLit GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsLit GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsOverLit GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsOverLit GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Lit.HsOverLit GHC.Hs.Extension.GhcTc)
instance Data.Data.Data GHC.Hs.Lit.OverLitRn
instance Data.Data.Data GHC.Hs.Lit.OverLitTc
instance Data.Data.Data (Language.Haskell.Syntax.Pat.Pat GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Pat.Pat GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Pat.Pat GHC.Hs.Extension.GhcTc)
instance Data.Data.Data GHC.Hs.Pat.ConPatTc
instance Data.Data.Data (Language.Haskell.Syntax.Pat.HsConPatTyArg GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Pat.HsConPatTyArg GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Pat.HsConPatTyArg GHC.Hs.Extension.GhcTc)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Language.Haskell.Syntax.Pat.HsFieldBind a b)
instance Data.Data.Data body => Data.Data.Data (Language.Haskell.Syntax.Pat.HsRecFields GHC.Hs.Extension.GhcPs body)
instance Data.Data.Data body => Data.Data.Data (Language.Haskell.Syntax.Pat.HsRecFields GHC.Hs.Extension.GhcRn body)
instance Data.Data.Data body => Data.Data.Data (Language.Haskell.Syntax.Pat.HsRecFields GHC.Hs.Extension.GhcTc body)
instance Data.Data.Data (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcTc)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcPs)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcRn)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcTc)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcPs thing)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcRn thing)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcTc thing)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsForAllTelescope GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsForAllTelescope GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsForAllTelescope GHC.Hs.Extension.GhcTc)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcPs)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcRn)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsTyLit GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsTyLit GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsTyLit GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsLinearArrowTokens GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsLinearArrowTokens GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsLinearArrowTokens GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsArrow GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsArrow GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.HsArrow GHC.Hs.Extension.GhcTc)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcPs thing)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcRn thing)
instance Data.Data.Data thing => Data.Data.Data (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcTc thing)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Language.Haskell.Syntax.Type.HsArg a b)
instance Data.Data.Data (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.FieldOcc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.Type.AmbiguousFieldOcc GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.Type.AmbiguousFieldOcc GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.Type.AmbiguousFieldOcc GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.ImpExp.ImportDecl GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.ImpExp.ImportDecl GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.ImpExp.ImportDecl GHC.Hs.Extension.GhcTc)
instance Data.Data.Data (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcPs)
instance Data.Data.Data (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcRn)
instance Data.Data.Data (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcTc)
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcPs)
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcRn)
instance GHC.Classes.Eq (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcTc)
instance Data.Data.Data GHC.Hs.Expr.XXExprGhcTc
instance Data.Data.Data GHC.Hs.Pat.XXPatGhcTc
instance Data.Data.Data GHC.Hs.Decls.XViaStrategyPs

module GHC.Hs
data Fixity

-- | Haskell Module
--   
--   All we actually declare here is the top-level structure for a module.
data HsModule p

-- | <a>AnnKeywordId</a>s
--   
--   <ul>
--   <li><a>AnnModule</a>,<a>AnnWhere</a></li>
--   <li><a>AnnOpen</a>,<a>AnnSemi</a>, <a>AnnClose</a> for explicit braces
--   and semi around hsmodImports,hsmodDecls if this style is used.</li>
--   </ul>
HsModule :: XCModule p -> Maybe (XRec p ModuleName) -> Maybe (XRec p [LIE p]) -> [LImportDecl p] -> [LHsDecl p] -> HsModule p

-- | HsModule extension point
[hsmodExt] :: HsModule p -> XCModule p

-- | <tt>Nothing</tt>: "module X where" is omitted (in which case the next
--   field is Nothing too)
[hsmodName] :: HsModule p -> Maybe (XRec p ModuleName)

-- | Export list
--   
--   <ul>
--   <li><tt>Nothing</tt>: export list omitted, so export everything</li>
--   <li><tt>Just []</tt>: export <i>nothing</i></li>
--   <li><tt>Just [...]</tt>: as you would expect...</li>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a> ,<a>AnnClose</a></li>
--   </ul>
[hsmodExports] :: HsModule p -> Maybe (XRec p [LIE p])
[hsmodImports] :: HsModule p -> [LImportDecl p]

-- | Type, class, value, and interface signature decls
[hsmodDecls] :: HsModule p -> [LHsDecl p]
XModule :: !XXModule p -> HsModule p
data AnnsModule
AnnsModule :: [AddEpAnn] -> AnnList -> AnnsModule
[am_main] :: AnnsModule -> [AddEpAnn]
[am_decls] :: AnnsModule -> AnnList
data HsParsedModule
HsParsedModule :: Located (HsModule GhcPs) -> [FilePath] -> HsParsedModule
[hpm_module] :: HsParsedModule -> Located (HsModule GhcPs)

-- | extra source files (e.g. from #includes). The lexer collects these
--   from '# <a>file</a> <a>line</a>' pragmas, which the C preprocessor
--   leaves behind. These files and their timestamps are stored in the .hi
--   file, so that we can force recompilation if any of them change (#3589)
[hpm_src_files] :: HsParsedModule -> [FilePath]

-- | Haskell Module extension point: GHC specific
data XModulePs
XModulePs :: EpAnn AnnsModule -> LayoutInfo GhcPs -> Maybe (LocatedP (WarningTxt GhcPs)) -> Maybe (LHsDoc GhcPs) -> XModulePs
[hsmodAnn] :: XModulePs -> EpAnn AnnsModule

-- | Layout info for the module. For incomplete modules (e.g. the output of
--   parseHeader), it is NoLayoutInfo.
[hsmodLayout] :: XModulePs -> LayoutInfo GhcPs

-- | reason/explanation for warning/deprecation of this module
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a> ,<a>AnnClose</a></li>
--   </ul>
[hsmodDeprecMessage] :: XModulePs -> Maybe (LocatedP (WarningTxt GhcPs))

-- | Haddock module info and description, unparsed
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a> ,<a>AnnClose</a></li>
--   </ul>
[hsmodHaddockModHeader] :: XModulePs -> Maybe (LHsDoc GhcPs)
instance GHC.Classes.Eq GHC.Hs.AnnsModule
instance Data.Data.Data GHC.Hs.AnnsModule
instance Data.Data.Data GHC.Hs.XModulePs
instance Data.Data.Data (Language.Haskell.Syntax.HsModule GHC.Hs.Extension.GhcPs)
instance GHC.Utils.Outputable.Outputable (Language.Haskell.Syntax.HsModule GHC.Hs.Extension.GhcPs)


-- | A ModSummary is a node in the compilation manager's dependency graph
--   (ModuleGraph)
module GHC.Unit.Module.ModSummary

-- | Data for a module node in a <tt>ModuleGraph</tt>. Module nodes of the
--   module graph are one of:
--   
--   <ul>
--   <li>A regular Haskell source module</li>
--   <li>A hi-boot source module</li>
--   </ul>
data ModSummary
ModSummary :: Module -> HscSource -> ModLocation -> Fingerprint -> Maybe UTCTime -> !Maybe UTCTime -> Maybe UTCTime -> Maybe UTCTime -> [(PkgQual, Located ModuleName)] -> [(PkgQual, Located ModuleName)] -> !Bool -> Maybe HsParsedModule -> FilePath -> DynFlags -> Maybe StringBuffer -> ModSummary

-- | Identity of the module
[ms_mod] :: ModSummary -> Module

-- | The module source either plain Haskell, hs-boot, or hsig
[ms_hsc_src] :: ModSummary -> HscSource

-- | Location of the various files belonging to the module
[ms_location] :: ModSummary -> ModLocation

-- | Content hash of source file
[ms_hs_hash] :: ModSummary -> Fingerprint

-- | Timestamp of object, if we have one
[ms_obj_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of dynamic object, if we have one
[ms_dyn_obj_date] :: ModSummary -> !Maybe UTCTime

-- | Timestamp of hi file, if we have one See Note [When source is
--   considered modified] and #9243
[ms_iface_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of hie file, if we have one
[ms_hie_date] :: ModSummary -> Maybe UTCTime

-- | Source imports of the module
[ms_srcimps] :: ModSummary -> [(PkgQual, Located ModuleName)]

-- | Non-source imports of the module from the module *text*
[ms_textual_imps] :: ModSummary -> [(PkgQual, Located ModuleName)]

-- | Whether the special module GHC.Prim was imported explicitly
[ms_ghc_prim_import] :: ModSummary -> !Bool

-- | The parsed, nonrenamed source, if we have it. This is also used to
--   support "inline module syntax" in Backpack files.
[ms_parsed_mod] :: ModSummary -> Maybe HsParsedModule

-- | Filename of preprocessed source file
[ms_hspp_file] :: ModSummary -> FilePath

-- | Cached flags from <tt>OPTIONS</tt>, <tt>INCLUDE</tt> and
--   <tt>LANGUAGE</tt> pragmas in the modules source code
[ms_hspp_opts] :: ModSummary -> DynFlags

-- | The actual preprocessed source, if we have it
[ms_hspp_buf] :: ModSummary -> Maybe StringBuffer
ms_unitid :: ModSummary -> UnitId
ms_installed_mod :: ModSummary -> InstalledModule
ms_mod_name :: ModSummary -> ModuleName

-- | Textual imports, plus plugin imports but not SOURCE imports.
ms_imps :: ModSummary -> [(PkgQual, Located ModuleName)]

-- | Plugin imports
ms_plugin_imps :: ModSummary -> [(PkgQual, Located ModuleName)]
ms_mnwib :: ModSummary -> ModuleNameWithIsBoot

-- | Like <a>ms_home_imps</a>, but for SOURCE imports.
ms_home_srcimps :: ModSummary -> [Located ModuleName]

-- | All of the (possibly) home module imports from a <a>ModSummary</a>;
--   that is to say, each of these module names could be a home import if
--   an appropriately named file existed. (This is in contrast to package
--   qualified imports, which are guaranteed not to be home imports.)
ms_home_imps :: ModSummary -> [(PkgQual, Located ModuleName)]
msHiFilePath :: ModSummary -> FilePath
msDynHiFilePath :: ModSummary -> FilePath
msHsFilePath :: ModSummary -> FilePath
msObjFilePath :: ModSummary -> FilePath
msDynObjFilePath :: ModSummary -> FilePath

-- | Returns the dependencies of the ModSummary s.
msDeps :: ModSummary -> [(PkgQual, GenWithIsBoot (Located ModuleName))]

-- | Did this <a>ModSummary</a> originate from a hs-boot file?
isBootSummary :: ModSummary -> IsBootInterface

-- | Find the first target in the provided list which matches the specified
--   <a>ModSummary</a>.
findTarget :: ModSummary -> [Target] -> Maybe Target
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.ModSummary.ModSummary

module GHC.Unit.Module.Graph

-- | A '<tt>ModuleGraph</tt>' contains all the nodes from the home package
--   (only). See '<tt>ModuleGraphNode</tt>' for information about the
--   nodes.
--   
--   Modules need to be compiled. hs-boots need to be typechecked before
--   the associated "real" module so modules with {-# SOURCE #-} imports
--   can be built. Instantiations also need to be typechecked to ensure
--   that the module fits the signature. Substantiation typechecking is
--   roughly comparable to the check that the module and its hs-boot agree.
--   
--   The graph is not necessarily stored in topologically-sorted order. Use
--   <a>topSortModuleGraph</a> and <a>flattenSCC</a> to achieve this.
data ModuleGraph

-- | A '<tt>ModuleGraphNode</tt>' is a node in the '<tt>ModuleGraph</tt>'.
--   Edges between nodes mark dependencies arising from module imports and
--   dependencies arising from backpack instantiations.
data ModuleGraphNode

-- | Instantiation nodes track the instantiation of other units (backpack
--   dependencies) with the holes (signatures) of the current package.
InstantiationNode :: UnitId -> InstantiatedUnit -> ModuleGraphNode

-- | There is a module summary node for each module, signature, and boot
--   module being built.
ModuleNode :: [NodeKey] -> ModSummary -> ModuleGraphNode

-- | Link nodes are whether are are creating a linked product (ie
--   executable/shared object etc) for a unit.
LinkNode :: [NodeKey] -> UnitId -> ModuleGraphNode

-- | Collect the immediate dependencies of a ModuleGraphNode, optionally
--   avoiding hs-boot dependencies. If the drop_hs_boot_nodes flag is
--   False, and if this is a .hs and there is an equivalent .hs-boot, add a
--   link from the former to the latter. This has the effect of detecting
--   bogus cases where the .hs-boot depends on the .hs, by introducing a
--   cycle. Additionally, it ensures that we will always process the
--   .hs-boot before the .hs, and so the HomePackageTable will always have
--   the most up to date information.
nodeDependencies :: Bool -> ModuleGraphNode -> [NodeKey]
emptyMG :: ModuleGraph
mkModuleGraph :: [ModuleGraphNode] -> ModuleGraph

-- | Add an ExtendedModSummary to ModuleGraph. Assumes that the new
--   ModSummary is not an element of the ModuleGraph.
extendMG :: ModuleGraph -> [NodeKey] -> ModSummary -> ModuleGraph
extendMGInst :: ModuleGraph -> UnitId -> InstantiatedUnit -> ModuleGraph
extendMG' :: ModuleGraph -> ModuleGraphNode -> ModuleGraph
unionMG :: ModuleGraph -> ModuleGraph -> ModuleGraph
isTemplateHaskellOrQQNonBoot :: ModSummary -> Bool

-- | This function filters out all the instantiation nodes from each SCC of
--   a topological sort. Use this with care, as the resulting "strongly
--   connected components" may not really be strongly connected in a direct
--   way, as instantiations have been removed. It would probably be best to
--   eliminate uses of this function where possible.
filterToposortToModules :: [SCC ModuleGraphNode] -> [SCC ModSummary]

-- | Map a function <tt>f</tt> over all the <tt>ModSummaries</tt>. To
--   preserve invariants <tt>f</tt> can't change the isBoot status.
mapMG :: (ModSummary -> ModSummary) -> ModuleGraph -> ModuleGraph
mgModSummaries :: ModuleGraph -> [ModSummary]
mgModSummaries' :: ModuleGraph -> [ModuleGraphNode]

-- | Look up a ModSummary in the ModuleGraph Looks up the non-boot
--   ModSummary Linear in the size of the module graph
mgLookupModule :: ModuleGraph -> Module -> Maybe ModSummary
mgTransDeps :: ModuleGraph -> Map NodeKey (Set NodeKey)
showModMsg :: DynFlags -> Bool -> ModuleGraphNode -> SDoc
moduleGraphNodeModule :: ModuleGraphNode -> Maybe ModuleName
moduleGraphNodeModSum :: ModuleGraphNode -> Maybe ModSummary

-- | Turn a list of graph nodes into an efficient queriable graph. The
--   first boolean parameter indicates whether nodes corresponding to
--   hs-boot files should be collapsed into their relevant hs nodes.
moduleGraphNodes :: Bool -> [ModuleGraphNode] -> (Graph SummaryNode, NodeKey -> Maybe SummaryNode)
type SummaryNode = Node Int ModuleGraphNode
summaryNodeSummary :: SummaryNode -> ModuleGraphNode
data NodeKey
NodeKey_Unit :: {-# UNPACK #-} !InstantiatedUnit -> NodeKey
NodeKey_Module :: {-# UNPACK #-} !ModNodeKeyWithUid -> NodeKey
NodeKey_Link :: !UnitId -> NodeKey
nodeKeyUnitId :: NodeKey -> UnitId
nodeKeyModName :: NodeKey -> Maybe ModuleName
type ModNodeKey = ModuleNameWithIsBoot
mkNodeKey :: ModuleGraphNode -> NodeKey
msKey :: ModSummary -> ModNodeKeyWithUid
moduleGraphNodeUnitId :: ModuleGraphNode -> UnitId
data ModNodeKeyWithUid
ModNodeKeyWithUid :: !ModuleNameWithIsBoot -> !UnitId -> ModNodeKeyWithUid
[mnkModuleName] :: ModNodeKeyWithUid -> !ModuleNameWithIsBoot
[mnkUnitId] :: ModNodeKeyWithUid -> !UnitId
instance GHC.Classes.Ord GHC.Unit.Module.Graph.ModNodeKeyWithUid
instance GHC.Classes.Eq GHC.Unit.Module.Graph.ModNodeKeyWithUid
instance GHC.Classes.Ord GHC.Unit.Module.Graph.NodeKey
instance GHC.Classes.Eq GHC.Unit.Module.Graph.NodeKey
instance Data.Foldable.Foldable GHC.Unit.Module.Graph.NodeMap
instance Data.Traversable.Traversable GHC.Unit.Module.Graph.NodeMap
instance GHC.Base.Functor GHC.Unit.Module.Graph.NodeMap
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Graph.ModuleGraphNode
instance GHC.Classes.Eq GHC.Unit.Module.Graph.ModuleGraphNode
instance GHC.Classes.Ord GHC.Unit.Module.Graph.ModuleGraphNode
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Graph.NodeKey
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Graph.ModNodeKeyWithUid

module GHC.Unit.Module.ModIface
type ModIface = ModIface_ 'ModIfaceFinal

-- | A <a>ModIface</a> plus a <tt>ModDetails</tt> summarises everything we
--   know about a compiled module. The <a>ModIface</a> is the stuff
--   *before* linking, and can be written out to an interface file. The
--   'ModDetails is after linking and can be completely recovered from just
--   the <a>ModIface</a>.
--   
--   When we read an interface file, we also construct a <a>ModIface</a>
--   from it, except that we explicitly make the <a>mi_decls</a> and a few
--   other fields empty; as when reading we consolidate the declarations
--   etc. into a number of indexed maps and environments in the
--   <tt>ExternalPackageState</tt>.
--   
--   See Note [Strictness in ModIface] to learn about why some fields are
--   strict and others are not.
data ModIface_ (phase :: ModIfacePhase)
ModIface :: !Module -> !Maybe Module -> !HscSource -> Dependencies -> [Usage] -> ![IfaceExport] -> !Bool -> [(OccName, Fixity)] -> Warnings GhcRn -> [IfaceAnnotation] -> [IfaceDeclExts phase] -> Maybe [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo] -> !Maybe GlobalRdrEnv -> [IfaceClsInst] -> [IfaceFamInst] -> [IfaceRule] -> !AnyHpcUsage -> !IfaceTrustInfo -> !Bool -> ![IfaceCompleteMatch] -> !Maybe Docs -> !IfaceBackendExts phase -> !ExtensibleFields -> !Fingerprint -> ModIface_ (phase :: ModIfacePhase)

-- | Name of the module we are for
[mi_module] :: ModIface_ (phase :: ModIfacePhase) -> !Module

-- | Are we a sig of another mod?
[mi_sig_of] :: ModIface_ (phase :: ModIfacePhase) -> !Maybe Module

-- | Boot? Signature?
[mi_hsc_src] :: ModIface_ (phase :: ModIfacePhase) -> !HscSource

-- | The dependencies of the module. This is consulted for
--   directly-imported modules, but not for anything else (hence lazy)
[mi_deps] :: ModIface_ (phase :: ModIfacePhase) -> Dependencies

-- | Usages; kept sorted so that it's easy to decide whether to write a new
--   iface file (changing usages doesn't affect the hash of this module)
--   NOT STRICT! we read this field lazily from the interface file It is
--   *only* consulted by the recompilation checker
[mi_usages] :: ModIface_ (phase :: ModIfacePhase) -> [Usage]

-- | Exports Kept sorted by (mod,occ), to make version comparisons easier
--   Records the modules that are the declaration points for things
--   exported by this module, and the <a>OccName</a>s of those things
[mi_exports] :: ModIface_ (phase :: ModIfacePhase) -> ![IfaceExport]

-- | Module required TH splices when it was compiled. This disables
--   recompilation avoidance (see #481).
[mi_used_th] :: ModIface_ (phase :: ModIfacePhase) -> !Bool

-- | Fixities NOT STRICT! we read this field lazily from the interface file
[mi_fixities] :: ModIface_ (phase :: ModIfacePhase) -> [(OccName, Fixity)]

-- | Warnings NOT STRICT! we read this field lazily from the interface file
[mi_warns] :: ModIface_ (phase :: ModIfacePhase) -> Warnings GhcRn

-- | Annotations NOT STRICT! we read this field lazily from the interface
--   file
[mi_anns] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceAnnotation]

-- | Type, class and variable declarations The hash of an Id changes if its
--   fixity or deprecations change (as well as its type of course) Ditto
--   data constructors, class operations, except that the hash of the
--   parent class/tycon changes
[mi_decls] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceDeclExts phase]

-- | Extra variable definitions which are **NOT** exposed but when combined
--   with mi_decls allows us to restart code generation. See Note
--   [Interface Files with Core Definitions] and Note [Interface File with
--   Core: Sharing RHSs]
[mi_extra_decls] :: ModIface_ (phase :: ModIfacePhase) -> Maybe [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo]

-- | Binds all the things defined at the top level in the <i>original
--   source</i> code for this module. which is NOT the same as mi_exports,
--   nor mi_decls (which may contains declarations for things not actually
--   defined by the user). Used for GHCi and for inspecting the contents of
--   modules via the GHC API only.
--   
--   (We need the source file to figure out the top-level environment, if
--   we didn't compile this module from source then this field contains
--   <tt>Nothing</tt>).
--   
--   Strictly speaking this field should live in the <tt>HomeModInfo</tt>,
--   but that leads to more plumbing.
[mi_globals] :: ModIface_ (phase :: ModIfacePhase) -> !Maybe GlobalRdrEnv

-- | Sorted class instance
[mi_insts] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceClsInst]

-- | Sorted family instances
[mi_fam_insts] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceFamInst]

-- | Sorted rules
[mi_rules] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceRule]

-- | True if this program uses Hpc at any point in the program.
[mi_hpc] :: ModIface_ (phase :: ModIfacePhase) -> !AnyHpcUsage

-- | Safe Haskell Trust information for this module.
[mi_trust] :: ModIface_ (phase :: ModIfacePhase) -> !IfaceTrustInfo

-- | Do we require the package this module resides in be trusted to trust
--   this module? This is used for the situation where a module is Safe (so
--   doesn't require the package be trusted itself) but imports some
--   trustworthy modules from its own package (which does require its own
--   package be trusted). See Note [Trust Own Package] in GHC.Rename.Names
[mi_trust_pkg] :: ModIface_ (phase :: ModIfacePhase) -> !Bool
[mi_complete_matches] :: ModIface_ (phase :: ModIfacePhase) -> ![IfaceCompleteMatch]

-- | Docstrings and related data for use by haddock, the ghci <tt>:doc</tt>
--   command, and other tools.
--   
--   <tt>Just _</tt> <tt><a>=</a></tt> the module was built with
--   <tt>-haddock</tt>.
[mi_docs] :: ModIface_ (phase :: ModIfacePhase) -> !Maybe Docs

-- | Either <tt>()</tt> or <a>ModIfaceBackend</a> for a fully instantiated
--   interface.
[mi_final_exts] :: ModIface_ (phase :: ModIfacePhase) -> !IfaceBackendExts phase

-- | Additional optional fields, where the Map key represents the field
--   name, resulting in a (size, serialized data) pair. Because the data is
--   intended to be serialized through the internal <a>Binary</a> class
--   (increasing compatibility with types using <a>Name</a> and
--   <tt>FastString</tt>, such as HIE), this format is chosen over
--   <tt>ByteString</tt>s.
[mi_ext_fields] :: ModIface_ (phase :: ModIfacePhase) -> !ExtensibleFields

-- | Hash of the .hs source, used for recompilation checking.
[mi_src_hash] :: ModIface_ (phase :: ModIfacePhase) -> !Fingerprint
type PartialModIface = ModIface_ 'ModIfaceCore

-- | Extends a PartialModIface with information which is either: * Computed
--   after codegen * Or computed just before writing the iface to disk.
--   (Hashes) In order to fully instantiate it.
data ModIfaceBackend
ModIfaceBackend :: !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !WhetherHasOrphans -> !WhetherHasFamInst -> !Fingerprint -> !Fingerprint -> !OccName -> Maybe (WarningTxt GhcRn) -> !OccName -> Maybe Fixity -> !OccName -> Maybe (OccName, Fingerprint) -> ModIfaceBackend

-- | Hash of the whole interface
[mi_iface_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of the ABI only
[mi_mod_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of the important flags used when compiling the module, excluding
--   optimisation flags
[mi_flag_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of optimisation flags
[mi_opt_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of hpc flags
[mi_hpc_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash of plugins
[mi_plugin_hash] :: ModIfaceBackend -> !Fingerprint

-- | Whether this module has orphans
[mi_orphan] :: ModIfaceBackend -> !WhetherHasOrphans

-- | Whether this module has family instances. See Note [The type family
--   instance consistency story].
[mi_finsts] :: ModIfaceBackend -> !WhetherHasFamInst

-- | Hash of export list
[mi_exp_hash] :: ModIfaceBackend -> !Fingerprint

-- | Hash for orphan rules, class and family instances combined
[mi_orphan_hash] :: ModIfaceBackend -> !Fingerprint

-- | Cached lookup for <a>mi_warns</a>
[mi_warn_fn] :: ModIfaceBackend -> !OccName -> Maybe (WarningTxt GhcRn)

-- | Cached lookup for <a>mi_fixities</a>
[mi_fix_fn] :: ModIfaceBackend -> !OccName -> Maybe Fixity

-- | Cached lookup for <a>mi_decls</a>. The <tt>Nothing</tt> in
--   <a>mi_hash_fn</a> means that the thing isn't in decls. It's useful to
--   know that when seeing if we are up to date wrt. the old interface. The
--   <a>OccName</a> is the parent of the name, if it has one.
[mi_hash_fn] :: ModIfaceBackend -> !OccName -> Maybe (OccName, Fingerprint)

-- | Selects a IfaceDecl representation. For fully instantiated interfaces
--   we also maintain a fingerprint, which is used for recompilation
--   checks.
type family IfaceDeclExts (phase :: ModIfacePhase) = decl | decl -> phase
type family IfaceBackendExts (phase :: ModIfacePhase) = bk | bk -> phase

-- | The original names declared of a certain module that are exported
type IfaceExport = AvailInfo

-- | Records whether a module has orphans. An "orphan" is one of:
--   
--   <ul>
--   <li>An instance declaration in a module other than the definition
--   module for one of the type constructors or classes in the instance
--   head</li>
--   <li>A rewrite rule in a module other than the one defining the
--   function in the head of the rule</li>
--   </ul>
type WhetherHasOrphans = Bool

-- | Does this module define family instances?
type WhetherHasFamInst = Bool

-- | Old-style accessor for whether or not the ModIface came from an
--   hs-boot file.
mi_boot :: ModIface -> IsBootInterface

-- | Lookups up a (possibly cached) fixity from a <a>ModIface</a>. If one
--   cannot be found, <a>defaultFixity</a> is returned instead.
mi_fix :: ModIface -> OccName -> Fixity

-- | The semantic module for this interface; e.g., if it's a interface for
--   a signature, if <a>mi_module</a> is <tt>p[A=<a>A</a>]:A</tt>,
--   <a>mi_semantic_module</a> will be <tt><a>A</a></tt>.
mi_semantic_module :: ModIface_ a -> Module

-- | The "precise" free holes, e.g., the signatures that this
--   <a>ModIface</a> depends on.
mi_free_holes :: ModIface -> UniqDSet ModuleName
mi_mnwib :: ModIface -> ModuleNameWithIsBoot

-- | Given a set of free holes, and a unit identifier, rename the free
--   holes according to the instantiation of the unit identifier. For
--   example, if we have A and B free, and our unit identity is
--   <tt>p[A=<a>C</a>,B=impl:B]</tt>, the renamed free holes are just C.
renameFreeHoles :: UniqDSet ModuleName -> [(ModuleName, Module)] -> UniqDSet ModuleName
emptyPartialModIface :: Module -> PartialModIface
emptyFullModIface :: Module -> ModIface

-- | Constructs cache for the <a>mi_hash_fn</a> field of a <a>ModIface</a>
mkIfaceHashCache :: [(Fingerprint, IfaceDecl)] -> OccName -> Maybe (OccName, Fingerprint)
emptyIfaceHashCache :: OccName -> Maybe (OccName, Fingerprint)
forceModIface :: ModIface -> IO ()
instance GHC.Utils.Binary.Binary GHC.Unit.Module.ModIface.ModIface
instance (Control.DeepSeq.NFData (GHC.Unit.Module.ModIface.IfaceBackendExts phase), Control.DeepSeq.NFData (GHC.Unit.Module.ModIface.IfaceDeclExts phase)) => Control.DeepSeq.NFData (GHC.Unit.Module.ModIface.ModIface_ phase)
instance Control.DeepSeq.NFData GHC.Unit.Module.ModIface.ModIfaceBackend


-- | Metaprogramming types
module GHC.Types.Meta

-- | The supported metaprogramming result types
data MetaRequest
MetaE :: (LHsExpr GhcPs -> MetaResult) -> MetaRequest
MetaP :: (LPat GhcPs -> MetaResult) -> MetaRequest
MetaT :: (LHsType GhcPs -> MetaResult) -> MetaRequest
MetaD :: ([LHsDecl GhcPs] -> MetaResult) -> MetaRequest
MetaAW :: (Serialized -> MetaResult) -> MetaRequest
type MetaHook f = MetaRequest -> LHsExpr GhcTc -> f MetaResult

-- | data constructors not exported to ensure correct result type
data MetaResult
metaRequestE :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LHsExpr GhcPs)
metaRequestP :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LPat GhcPs)
metaRequestT :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LHsType GhcPs)
metaRequestD :: Functor f => MetaHook f -> LHsExpr GhcTc -> f [LHsDecl GhcPs]
metaRequestAW :: Functor f => MetaHook f -> LHsExpr GhcTc -> f Serialized


-- | Describes the provenance of types as they flow through the
--   type-checker. The datatypes here are mainly used for error message
--   generation.
module GHC.Tc.Types.Origin

-- | UserTypeCtxt describes the origin of the polymorphic type in the
--   places where we need an expression to have that type
data UserTypeCtxt
FunSigCtxt :: Name -> ReportRedundantConstraints -> UserTypeCtxt
InfSigCtxt :: Name -> UserTypeCtxt
ExprSigCtxt :: ReportRedundantConstraints -> UserTypeCtxt
KindSigCtxt :: UserTypeCtxt
StandaloneKindSigCtxt :: Name -> UserTypeCtxt
TypeAppCtxt :: UserTypeCtxt
ConArgCtxt :: Name -> UserTypeCtxt
TySynCtxt :: Name -> UserTypeCtxt
PatSynCtxt :: Name -> UserTypeCtxt
PatSigCtxt :: UserTypeCtxt
RuleSigCtxt :: FastString -> Name -> UserTypeCtxt
ForSigCtxt :: Name -> UserTypeCtxt
DefaultDeclCtxt :: UserTypeCtxt
InstDeclCtxt :: Bool -> UserTypeCtxt
SpecInstCtxt :: UserTypeCtxt
GenSigCtxt :: UserTypeCtxt
GhciCtxt :: Bool -> UserTypeCtxt
ClassSCCtxt :: Name -> UserTypeCtxt
SigmaCtxt :: UserTypeCtxt
DataTyCtxt :: Name -> UserTypeCtxt
DerivClauseCtxt :: UserTypeCtxt
TyVarBndrKindCtxt :: Name -> UserTypeCtxt
DataKindCtxt :: Name -> UserTypeCtxt
TySynKindCtxt :: Name -> UserTypeCtxt
TyFamResKindCtxt :: Name -> UserTypeCtxt
pprUserTypeCtxt :: UserTypeCtxt -> SDoc
isSigMaybe :: UserTypeCtxt -> Maybe Name

-- | Report Redundant Constraints.
data ReportRedundantConstraints

-- | Don't report redundant constraints
NoRRC :: ReportRedundantConstraints

-- | Report redundant constraints, and here is the SrcSpan for the
--   constraints E.g. f :: (Eq a, Ord b) =&gt; blah The span is for the (Eq
--   a, Ord b)
WantRRC :: SrcSpan -> ReportRedundantConstraints
reportRedundantConstraints :: ReportRedundantConstraints -> Bool
redundantConstraintsSpan :: UserTypeCtxt -> SrcSpan

-- | <a>SkolemInfo</a> stores the origin of a skolem type variable, so that
--   we can display this information to the user in case of a type error.
--   
--   The <a>Unique</a> field allows us to report all skolem type variables
--   bound in the same place in a single report.
data SkolemInfo
SkolemInfo :: Unique -> SkolemInfoAnon -> SkolemInfo

-- | <a>SkolemInfoAnon</a> stores the origin of a skolem type variable
--   (e.g. bound by a user-written forall, the header of a data
--   declaration, a deriving clause, ...).
--   
--   This information is displayed when reporting an error message, such as
--   
--   <pre>
--   "Couldn't match <tt>k</tt> with <tt>l</tt>"
--   </pre>
--   
--   This allows us to explain where the type variable came from.
--   
--   When several skolem type variables are bound at once, prefer using
--   <a>SkolemInfo</a>, which stores a <a>Unique</a> which allows these
--   type variables to be reported
data SkolemInfoAnon
SigSkol :: UserTypeCtxt -> TcType -> [(Name, TcTyVar)] -> SkolemInfoAnon
SigTypeSkol :: UserTypeCtxt -> SkolemInfoAnon
ForAllSkol :: TyVarBndrs -> SkolemInfoAnon
DerivSkol :: Type -> SkolemInfoAnon
InstSkol :: ClsInstOrQC -> PatersonSize -> SkolemInfoAnon
FamInstSkol :: SkolemInfoAnon
PatSkol :: ConLike -> HsMatchContext GhcTc -> SkolemInfoAnon
IPSkol :: [HsIPName] -> SkolemInfoAnon
RuleSkol :: RuleName -> SkolemInfoAnon
InferSkol :: [(Name, TcType)] -> SkolemInfoAnon
BracketSkol :: SkolemInfoAnon
UnifyForAllSkol :: TcType -> SkolemInfoAnon
TyConSkol :: TyConFlavour -> Name -> SkolemInfoAnon
DataConSkol :: Name -> SkolemInfoAnon
ReifySkol :: SkolemInfoAnon
RuntimeUnkSkol :: SkolemInfoAnon
ArrowReboundIfSkol :: SkolemInfoAnon
UnkSkol :: CallStack -> SkolemInfoAnon

-- | Wrap up the origin of a skolem type variable with a new <a>Unique</a>,
--   so that we can common up skolem type variables whose <a>SkolemInfo</a>
--   shares a certain <a>Unique</a>.
mkSkolemInfo :: MonadIO m => SkolemInfoAnon -> m SkolemInfo
getSkolemInfo :: SkolemInfo -> SkolemInfoAnon
pprSigSkolInfo :: UserTypeCtxt -> TcType -> SDoc
pprSkolInfo :: SkolemInfoAnon -> SDoc

-- | Use this when you can't specify a helpful origin for some skolem type
--   variable.
--   
--   We're hoping to be able to get rid of this entirely, but for the
--   moment it's still needed.
unkSkol :: HasCallStack => SkolemInfo
unkSkolAnon :: HasCallStack => SkolemInfoAnon
mkClsInstSkol :: Class -> [Type] -> SkolemInfoAnon
data CtOrigin

-- | A given constraint from a user-written type signature. The
--   <a>SkolemInfo</a> inside gives more information.
GivenOrigin :: SkolemInfoAnon -> CtOrigin

-- | <a>GivenSCOrigin</a> is used for a Given constraint obtained by
--   superclass selection from the context of an instance declaration. E.g.
--   instance <tt>(Foo a, Bar a) =&gt; C [a]</tt> where ... When
--   typechecking the instance decl itself, including producing evidence
--   for the superclasses of <tt>C</tt>, the superclasses of <tt>(Foo
--   a)</tt> and <tt>(Bar a)</tt> will have <a>GivenSCOrigin</a> origin.
GivenSCOrigin :: SkolemInfoAnon -> ScDepth -> Bool -> CtOrigin
OccurrenceOf :: Name -> CtOrigin
OccurrenceOfRecSel :: RdrName -> CtOrigin
AppOrigin :: CtOrigin
SpecPragOrigin :: UserTypeCtxt -> CtOrigin
TypeEqOrigin :: TcType -> TcType -> Maybe TypedThing -> Bool -> CtOrigin
[uo_actual] :: CtOrigin -> TcType
[uo_expected] :: CtOrigin -> TcType

-- | The thing that has type "actual"
[uo_thing] :: CtOrigin -> Maybe TypedThing

-- | Is at least one of the three elements above visible? (Errors from the
--   polymorphic subsumption check are considered visible.) Only used for
--   prioritizing error messages.
[uo_visible] :: CtOrigin -> Bool
KindEqOrigin :: TcType -> TcType -> CtOrigin -> Maybe TypeOrKind -> CtOrigin
IPOccOrigin :: HsIPName -> CtOrigin
OverLabelOrigin :: FastString -> CtOrigin
LiteralOrigin :: HsOverLit GhcRn -> CtOrigin
NegateOrigin :: CtOrigin
ArithSeqOrigin :: ArithSeqInfo GhcRn -> CtOrigin
AssocFamPatOrigin :: CtOrigin
SectionOrigin :: CtOrigin
HasFieldOrigin :: FastString -> CtOrigin
TupleOrigin :: CtOrigin
ExprSigOrigin :: CtOrigin
PatSigOrigin :: CtOrigin
PatOrigin :: CtOrigin
ProvCtxtOrigin :: PatSynBind GhcRn GhcRn -> CtOrigin
RecordUpdOrigin :: CtOrigin
ViewPatOrigin :: CtOrigin

-- | <a>ScOrigin</a> is used only for the Wanted constraints for the
--   superclasses of an instance declaration.
ScOrigin :: ClsInstOrQC -> NakedScFlag -> CtOrigin
DerivClauseOrigin :: CtOrigin
DerivOriginDC :: DataCon -> Int -> Bool -> CtOrigin
DerivOriginCoerce :: Id -> Type -> Type -> Bool -> CtOrigin
StandAloneDerivOrigin :: CtOrigin
DefaultOrigin :: CtOrigin
DoOrigin :: CtOrigin
DoPatOrigin :: LPat GhcRn -> CtOrigin
MCompOrigin :: CtOrigin
MCompPatOrigin :: LPat GhcRn -> CtOrigin
ProcOrigin :: CtOrigin
ArrowCmdOrigin :: CtOrigin
AnnOrigin :: CtOrigin
FunDepOrigin1 :: PredType -> CtOrigin -> RealSrcSpan -> PredType -> CtOrigin -> RealSrcSpan -> CtOrigin
FunDepOrigin2 :: PredType -> CtOrigin -> PredType -> SrcSpan -> CtOrigin
InjTFOrigin1 :: PredType -> CtOrigin -> RealSrcSpan -> PredType -> CtOrigin -> RealSrcSpan -> CtOrigin
ExprHoleOrigin :: Maybe RdrName -> CtOrigin
TypeHoleOrigin :: OccName -> CtOrigin
PatCheckOrigin :: CtOrigin
ListOrigin :: CtOrigin
IfThenElseOrigin :: CtOrigin
BracketOrigin :: CtOrigin
StaticOrigin :: CtOrigin
Shouldn'tHappenOrigin :: String -> CtOrigin
GhcBug20076 :: CtOrigin

-- | Testing whether the constraint associated with an instance declaration
--   in a signature file is satisfied upon instantiation.
--   
--   Test cases: backpack<i>should_fail</i>bkpfail{11,43}.bkp
InstProvidedOrigin :: Module -> ClsInst -> CtOrigin
NonLinearPatternOrigin :: CtOrigin
UsageEnvironmentOf :: Name -> CtOrigin
CycleBreakerOrigin :: CtOrigin -> CtOrigin
FRROrigin :: FixedRuntimeRepOrigin -> CtOrigin
WantedSuperclassOrigin :: PredType -> CtOrigin -> CtOrigin
InstanceSigOrigin :: Name -> Type -> Type -> CtOrigin
AmbiguityCheckOrigin :: UserTypeCtxt -> CtOrigin
exprCtOrigin :: HsExpr GhcRn -> CtOrigin

-- | Extract a suitable CtOrigin from a HsExpr
lexprCtOrigin :: LHsExpr GhcRn -> CtOrigin

-- | Extract a suitable CtOrigin from a MatchGroup
matchesCtOrigin :: MatchGroup GhcRn (LHsExpr GhcRn) -> CtOrigin

-- | Extract a suitable CtOrigin from guarded RHSs
grhssCtOrigin :: GRHSs GhcRn (LHsExpr GhcRn) -> CtOrigin
isVisibleOrigin :: CtOrigin -> Bool
toInvisibleOrigin :: CtOrigin -> CtOrigin
pprCtOrigin :: CtOrigin -> SDoc
isGivenOrigin :: CtOrigin -> Bool
isWantedWantedFunDepOrigin :: CtOrigin -> Bool

-- | Did a constraint arise from expanding a Wanted constraint to look at
--   superclasses?
isWantedSuperclassOrigin :: CtOrigin -> Bool

-- | Some thing which has a type.
--   
--   This datatype is used when we want to report to the user that
--   something has an unexpected type.
data TypedThing
HsTypeRnThing :: HsType GhcRn -> TypedThing
TypeThing :: Type -> TypedThing
HsExprRnThing :: HsExpr GhcRn -> TypedThing
NameThing :: Name -> TypedThing

-- | Some kind of type variable binder.
--   
--   Used for reporting errors, in <a>SkolemInfo</a> and
--   <tt>TcSolverReportMsg</tt>.
data TyVarBndrs
HsTyVarBndrsRn :: [HsTyVarBndr flag GhcRn] -> TyVarBndrs
isPushCallStackOrigin :: CtOrigin -> Bool
callStackOriginFS :: CtOrigin -> FastString

-- | The context for a representation-polymorphism check.
--   
--   For example, when typechecking <tt> (a :: k) -&gt; ...</tt>, we are
--   checking the type <tt>a</tt> because it's the type of a term variable
--   bound in a lambda, so we use <a>FRRBinder</a>.
data FixedRuntimeRepOrigin
FixedRuntimeRepOrigin :: Type -> FixedRuntimeRepContext -> FixedRuntimeRepOrigin

-- | What type are we checking? For example, `a[tau]` in `a[tau] :: TYPE
--   rr[tau]`.
[frr_type] :: FixedRuntimeRepOrigin -> Type

-- | What context requires a fixed runtime representation?
[frr_context] :: FixedRuntimeRepOrigin -> FixedRuntimeRepContext

-- | The context in which a representation-polymorphism check was
--   performed.
--   
--   Does not include the type on which the check was performed; see
--   <a>FixedRuntimeRepOrigin</a> for that.
data FixedRuntimeRepContext

-- | Record fields in record construction must have a fixed runtime
--   representation.
FRRRecordCon :: !RdrName -> !HsExpr GhcTc -> FixedRuntimeRepContext

-- | Record fields in record updates must have a fixed runtime
--   representation.
--   
--   Test case: RepPolyRecordUpdate.
FRRRecordUpdate :: !Name -> !HsExpr GhcRn -> FixedRuntimeRepContext

-- | Variable binders must have a fixed runtime representation.
--   
--   Test cases: LevPolyLet, RepPolyPatBind.
FRRBinder :: !Name -> FixedRuntimeRepContext

-- | Pattern binds must have a fixed runtime representation.
--   
--   Test case: RepPolyInferPatBind.
FRRPatBind :: FixedRuntimeRepContext

-- | Pattern synonym arguments must have a fixed runtime representation.
--   
--   Test case: RepPolyInferPatSyn.
FRRPatSynArg :: FixedRuntimeRepContext

-- | The type of the scrutinee in a case statement must have a fixed
--   runtime representation.
--   
--   Test cases: RepPolyCase{1,2}.
FRRCase :: FixedRuntimeRepContext

-- | An instantiation of a newtype/data constructor pattern in which an
--   argument type does not have a fixed runtime representation.
--   
--   Test case: T20363.
FRRDataConPatArg :: !DataCon -> !Int -> FixedRuntimeRepContext

-- | An instantiation of a function with no binding (e.g. <tt>coerce</tt>,
--   `unsafeCoerce#`, an unboxed tuple <a>DataCon</a>) in which one of the
--   remaining arguments types does not have a fixed runtime
--   representation.
--   
--   Test cases: RepPolyWrappedVar, T14561, UnliftedNewtypesLevityBinder,
--   UnliftedNewtypesCoerceFail.
FRRNoBindingResArg :: !RepPolyFun -> !ArgPos -> FixedRuntimeRepContext

-- | Arguments to unboxed tuples must have fixed runtime representations.
--   
--   Test case: RepPolyTuple.
FRRTupleArg :: !Int -> FixedRuntimeRepContext

-- | Tuple sections must have a fixed runtime representation.
--   
--   Test case: RepPolyTupleSection.
FRRTupleSection :: !Int -> FixedRuntimeRepContext

-- | Unboxed sums must have a fixed runtime representation.
--   
--   Test cases: RepPolySum.
FRRUnboxedSum :: FixedRuntimeRepContext

-- | The body of a <tt>do</tt> expression or a monad comprehension must
--   have a fixed runtime representation.
--   
--   Test cases: RepPolyDoBody{1,2}, RepPolyMcBody.
FRRBodyStmt :: !StmtOrigin -> !Int -> FixedRuntimeRepContext

-- | Arguments to a guard in a monad comprehension must have a fixed
--   runtime representation.
--   
--   Test case: RepPolyMcGuard.
FRRBodyStmtGuard :: FixedRuntimeRepContext

-- | Arguments to <a>(&gt;&gt;=)</a> arising from a <tt>do</tt> expression
--   or a monad comprehension must have a fixed runtime representation.
--   
--   Test cases: RepPolyDoBind, RepPolyMcBind.
FRRBindStmt :: !StmtOrigin -> FixedRuntimeRepContext

-- | A value bound by a pattern guard must have a fixed runtime
--   representation.
--   
--   Test cases: none.
FRRBindStmtGuard :: FixedRuntimeRepContext

-- | A representation-polymorphism check arising from arrow notation.
--   
--   See <a>FRRArrowContext</a> for more details.
FRRArrow :: !FRRArrowContext -> FixedRuntimeRepContext

-- | A representation-polymorphic check arising from a call to
--   <tt>matchExpectedFunTys</tt> or <tt>matchActualFunTySigma</tt>.
--   
--   See <a>ExpectedFunTyOrigin</a> for more details.
FRRExpectedFunTy :: !ExpectedFunTyOrigin -> !Int -> FixedRuntimeRepContext

-- | Print the context for a <tt>FixedRuntimeRep</tt>
--   representation-polymorphism check.
--   
--   Note that this function does not include the specific
--   <a>RuntimeRep</a> which is not fixed. That information is stored in
--   <a>FixedRuntimeRepOrigin</a> and is reported separately.
pprFixedRuntimeRepContext :: FixedRuntimeRepContext -> SDoc

-- | Are we in a <tt>do</tt> expression or a monad comprehension?
--   
--   This datatype is only used to report this context to the user in error
--   messages.
data StmtOrigin
MonadComprehension :: StmtOrigin
DoNotation :: StmtOrigin

-- | A function with representation-polymorphic arguments, such as
--   <tt>coerce</tt> or <tt>(#, #)</tt>.
--   
--   Used for reporting partial applications of representation-polymorphic
--   functions in error messages.
data RepPolyFun

-- | A wired-in function with representation-polymorphic arguments, such as
--   <tt>coerce</tt>.
RepPolyWiredIn :: !Id -> RepPolyFun

-- | A data constructor with representation-polymorphic arguments, such as
--   an unboxed tuple or a newtype constructor with
--   <tt>-XUnliftedNewtypes</tt>.
RepPolyDataCon :: !DataCon -> RepPolyFun

-- | The position of an argument (to be reported in an error message).
data ArgPos

-- | Invisible argument: don't report its position to the user.
ArgPosInvis :: ArgPos

-- | Visible argument in i-th position.
ArgPosVis :: !Int -> ArgPos
data ClsInstOrQC
IsClsInst :: ClsInstOrQC
IsQC :: CtOrigin -> ClsInstOrQC
data NakedScFlag
NakedSc :: NakedScFlag
NotNakedSc :: NakedScFlag

-- | While typechecking arrow notation, in which context did a
--   representation polymorphism check arise?
--   
--   See <a>FixedRuntimeRepContext</a> for more general origins of
--   representation polymorphism checks.
data FRRArrowContext

-- | The result of an arrow command does not have a fixed runtime
--   representation.
--   
--   Test case: RepPolyArrowCmd.
ArrowCmdResTy :: !HsCmd GhcRn -> FRRArrowContext

-- | The argument to an arrow in an arrow command application does not have
--   a fixed runtime representation.
--   
--   Test cases: none.
ArrowCmdApp :: !HsCmd GhcRn -> !HsExpr GhcRn -> FRRArrowContext

-- | A function in an arrow application does not have a fixed runtime
--   representation.
--   
--   Test cases: none.
ArrowCmdArrApp :: !HsExpr GhcRn -> !HsExpr GhcRn -> !HsArrAppType -> FRRArrowContext

-- | The scrutinee type in an arrow command case statement does not have a
--   fixed runtime representation.
--   
--   Test cases: none.
ArrowCmdCase :: FRRArrowContext

-- | The overall type of an arrow proc expression does not have a fixed
--   runtime representation.
--   
--   Test case: RepPolyArrowFun.
ArrowFun :: !HsExpr GhcRn -> FRRArrowContext
pprFRRArrowContext :: FRRArrowContext -> SDoc

-- | In what context are we calling <tt>matchExpectedFunTys</tt> or
--   <tt>matchActualFunTySigma</tt>?
--   
--   Used for two things:
--   
--   <ol>
--   <li>Reporting error messages which explain that a function has been
--   given an unexpected number of arguments. Uses
--   <a>pprExpectedFunTyHerald</a>. See Note [Herald for
--   matchExpectedFunTys] in GHC.Tc.Utils.Unify.</li>
--   <li>Reporting representation-polymorphism errors when a function
--   argument doesn't have a fixed RuntimeRep as per Note [Fixed
--   RuntimeRep] in GHC.Tc.Utils.Concrete. Uses
--   <a>pprExpectedFunTyOrigin</a>. See <a>FixedRuntimeRepContext</a> for
--   the situations in which representation-polymorphism checks are
--   performed.</li>
--   </ol>
data ExpectedFunTyOrigin

-- | A rebindable syntax operator is expected to have a function type.
--   
--   Test cases for representation-polymorphism checks: RepPolyDoBind,
--   RepPolyDoBody{1,2}, RepPolyMc{Bind,Body,Guard}, RepPolyNPlusK
ExpectedFunTySyntaxOp :: !CtOrigin -> !HsExpr GhcRn -> ExpectedFunTyOrigin

-- | A view pattern must have a function type.
--   
--   Test cases for representation-polymorphism checks: RepPolyBinder
ExpectedFunTyViewPat :: !HsExpr GhcRn -> ExpectedFunTyOrigin

-- | Need to be able to extract an argument type from a function type.
--   
--   Test cases for representation-polymorphism checks: RepPolyApp
ExpectedFunTyArg :: !TypedThing -> !HsExpr (GhcPass p) -> ExpectedFunTyOrigin

-- | Ensure that a function defined by equations indeed has a function type
--   with the appropriate number of arguments.
--   
--   Test cases for representation-polymorphism checks: RepPolyBinder,
--   RepPolyRecordPattern, RepPolyWildcardPattern
ExpectedFunTyMatches :: !TypedThing -> !MatchGroup GhcRn (LHsExpr GhcRn) -> ExpectedFunTyOrigin

-- | Ensure that a lambda abstraction has a function type.
--   
--   Test cases for representation-polymorphism checks: RepPolyLambda
ExpectedFunTyLam :: !MatchGroup GhcRn (LHsExpr GhcRn) -> ExpectedFunTyOrigin

-- | Ensure that a lambda case expression has a function type.
--   
--   Test cases for representation-polymorphism checks: RepPolyMatch
ExpectedFunTyLamCase :: LamCaseVariant -> !HsExpr GhcRn -> ExpectedFunTyOrigin
pprExpectedFunTyOrigin :: ExpectedFunTyOrigin -> Int -> SDoc
pprExpectedFunTyHerald :: ExpectedFunTyOrigin -> SDoc
instance GHC.Classes.Eq GHC.Tc.Types.Origin.ReportRedundantConstraints
instance GHC.Classes.Eq GHC.Tc.Types.Origin.UserTypeCtxt
instance GHC.Types.Unique.Uniquable GHC.Tc.Types.Origin.SkolemInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.SkolemInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.SkolemInfoAnon
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.CtOrigin
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.FixedRuntimeRepContext
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.FRRArrowContext
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.RepPolyFun
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.StmtOrigin
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.NakedScFlag
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.TyVarBndrs
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Origin.TypedThing


-- | This module defines types and simple operations over constraints, as
--   used in the type-checker and constraint solver.
module GHC.Tc.Types.Constraint
data QCInst
QCI :: CtEvidence -> [TcTyVar] -> TcPredType -> Bool -> QCInst
[qci_ev] :: QCInst -> CtEvidence
[qci_tvs] :: QCInst -> [TcTyVar]
[qci_pred] :: QCInst -> TcPredType
[qci_pend_sc] :: QCInst -> Bool
pendingScInst_maybe :: QCInst -> Maybe QCInst

-- | A <a>Xi</a>-type is one that has been fully rewritten with respect to
--   the inert set; that is, it has been rewritten by the algorithm in
--   GHC.Tc.Solver.Rewrite. (Historical note: <a>Xi</a>, for years and
--   years, meant that a type was type-family-free. It does *not* mean this
--   any more.)
type Xi = TcType
data Ct
CDictCan :: CtEvidence -> Class -> [Xi] -> Bool -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_class] :: Ct -> Class
[cc_tyargs] :: Ct -> [Xi]
[cc_pend_sc] :: Ct -> Bool
CIrredCan :: CtEvidence -> CtIrredReason -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_reason] :: Ct -> CtIrredReason
CEqCan :: CtEvidence -> CanEqLHS -> Xi -> EqRel -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_lhs] :: Ct -> CanEqLHS
[cc_rhs] :: Ct -> Xi
[cc_eq_rel] :: Ct -> EqRel
CNonCanonical :: CtEvidence -> Ct
[cc_ev] :: Ct -> CtEvidence
CQuantCan :: QCInst -> Ct
type Cts = Bag Ct
emptyCts :: Cts
andCts :: Cts -> Cts -> Cts
andManyCts :: [Cts] -> Cts
pprCts :: Cts -> SDoc
singleCt :: Ct -> Cts
listToCts :: [Ct] -> Cts
ctsElts :: Cts -> [Ct]
consCts :: Ct -> Cts -> Cts
snocCts :: Cts -> Ct -> Cts
extendCtsList :: Cts -> [Ct] -> Cts
isEmptyCts :: Cts -> Bool
isPendingScDict :: Ct -> Bool
pendingScDict_maybe :: Ct -> Maybe Ct

-- | True if taking superclasses of givens, or of wanteds (to perhaps
--   expose more equalities or functional dependencies) might help to solve
--   this constraint. See Note [When superclasses help]
superClassesMightHelp :: WantedConstraints -> Bool
getPendingWantedScs :: Cts -> ([Ct], Cts)
isWantedCt :: Ct -> Bool
isGivenCt :: Ct -> Bool
isUserTypeError :: PredType -> Bool

-- | A constraint is considered to be a custom type error, if it contains
--   custom type errors anywhere in it. See Note [Custom type errors in
--   constraints]
getUserTypeErrorMsg :: PredType -> Maybe Type
ctEvidence :: Ct -> CtEvidence
ctLoc :: Ct -> CtLoc
ctPred :: Ct -> PredType

-- | Get the flavour of the given <a>Ct</a>
ctFlavour :: Ct -> CtFlavour

-- | Get the equality relation for the given <a>Ct</a>
ctEqRel :: Ct -> EqRel
ctOrigin :: Ct -> CtOrigin
ctRewriters :: Ct -> RewriterSet
ctEvId :: HasDebugCallStack => Ct -> EvVar

-- | Returns the evidence <a>Id</a> for the argument <a>Ct</a> when this
--   <a>Ct</a> is a <a>Wanted</a>.
--   
--   Returns <a>Nothing</a> otherwise.
wantedEvId_maybe :: Ct -> Maybe EvVar

-- | Makes a new equality predicate with the same role as the given
--   evidence.
mkTcEqPredLikeEv :: CtEvidence -> TcType -> TcType -> TcType
mkNonCanonical :: CtEvidence -> Ct
mkNonCanonicalCt :: Ct -> Ct
mkGivens :: CtLoc -> [EvId] -> [Ct]
mkIrredCt :: CtIrredReason -> CtEvidence -> Ct
ctEvPred :: CtEvidence -> TcPredType
ctEvLoc :: CtEvidence -> CtLoc
ctEvOrigin :: CtEvidence -> CtOrigin

-- | Get the equality relation relevant for a <a>CtEvidence</a>
ctEvEqRel :: CtEvidence -> EqRel
ctEvExpr :: HasDebugCallStack => CtEvidence -> EvExpr
ctEvTerm :: CtEvidence -> EvTerm
ctEvCoercion :: HasDebugCallStack => CtEvidence -> TcCoercion
ctEvEvId :: CtEvidence -> EvVar

-- | Extract the set of rewriters from a <a>CtEvidence</a> See Note
--   [Wanteds rewrite Wanteds] If the provided CtEvidence is not for a
--   Wanted, just return an empty set.
ctEvRewriters :: CtEvidence -> RewriterSet

-- | Returns free variables of constraints as a non-deterministic set
tyCoVarsOfCt :: Ct -> TcTyCoVarSet

-- | Returns free variables of a bag of constraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfCts :: Cts -> TcTyCoVarSet

-- | Returns free variables of constraints as a deterministically ordered
--   list. See Note [Deterministic FV] in GHC.Utils.FV.
tyCoVarsOfCtList :: Ct -> [TcTyCoVar]

-- | Returns free variables of a bag of constraints as a deterministically
--   ordered list. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfCtsList :: Cts -> [TcTyCoVar]

-- | Used to indicate extra information about why a CIrredCan is
--   irreducible
data CtIrredReason

-- | this constraint has a non-canonical shape (e.g. <tt>c Int</tt>, for a
--   variable <tt>c</tt>)
IrredShapeReason :: CtIrredReason

-- | an equality where some invariant other than (TyEq:H) of <a>CEqCan</a>
--   is not satisfied; the <a>CheckTyEqResult</a> states exactly why
NonCanonicalReason :: CheckTyEqResult -> CtIrredReason

-- | an equality that cannot be decomposed because it is representational.
--   Example: <tt>a b ~R# Int</tt>. These might still be solved later.
--   INVARIANT: The constraint is a representational equality constraint
ReprEqReason :: CtIrredReason

-- | a nominal equality that relates two wholly different types, like
--   <tt>Int ~# Bool</tt> or <tt>a b ~# 3</tt>. INVARIANT: The constraint
--   is a nominal equality constraint
ShapeMismatchReason :: CtIrredReason

-- | an equality like <tt>T a b c ~ Q d e</tt> where either <tt>T</tt> or
--   <tt>Q</tt> is an abstract type constructor. See Note [Skolem abstract
--   data] in GHC.Core.TyCon. INVARIANT: The constraint is an equality
--   constraint between two TyConApps
AbstractTyConReason :: CtIrredReason

-- | Are we sure that more solving will never solve this constraint?
isInsolubleReason :: CtIrredReason -> Bool

-- | A set of problems in checking the validity of a type equality. See
--   <tt>checkTypeEq</tt>.
data CheckTyEqResult

-- | An individual problem that might be logged in a <a>CheckTyEqResult</a>
data CheckTyEqProblem
cteProblem :: CheckTyEqProblem -> CheckTyEqResult
cterClearOccursCheck :: CheckTyEqResult -> CheckTyEqResult

-- | No problems in checking the validity of a type equality.
cteOK :: CheckTyEqResult
cteImpredicative :: CheckTyEqProblem
cteTypeFamily :: CheckTyEqProblem
cteInsolubleOccurs :: CheckTyEqProblem
cteSolubleOccurs :: CheckTyEqProblem

-- | Mark a <a>CheckTyEqResult</a> as not having an insoluble occurs-check:
--   any occurs check under a type family or in a representation equality
--   is soluble.
cterSetOccursCheckSoluble :: CheckTyEqResult -> CheckTyEqResult

-- | Check whether a <a>CheckTyEqResult</a> is marked successful.
cterHasNoProblem :: CheckTyEqResult -> Bool

-- | Check whether a <a>CheckTyEqResult</a> has a <a>CheckTyEqProblem</a>
cterHasProblem :: CheckTyEqResult -> CheckTyEqProblem -> Bool

-- | Check whether a <a>CheckTyEqResult</a> has one <a>CheckTyEqProblem</a>
--   and no other
cterHasOnlyProblem :: CheckTyEqResult -> CheckTyEqProblem -> Bool
cterRemoveProblem :: CheckTyEqResult -> CheckTyEqProblem -> CheckTyEqResult
cterHasOccursCheck :: CheckTyEqResult -> Bool

-- | Retain only information about occurs-check failures, because only that
--   matters after recurring into a kind.
cterFromKind :: CheckTyEqResult -> CheckTyEqResult

-- | A <a>CanEqLHS</a> is a type that can appear on the left of a canonical
--   equality: a type variable or exactly-saturated type family
--   application.
data CanEqLHS
TyVarLHS :: TcTyVar -> CanEqLHS
TyFamLHS :: TyCon -> [Xi] -> CanEqLHS

-- | Is a type a canonical LHS? That is, is it a tyvar or an
--   exactly-saturated type family application? Does not look through type
--   synonyms.
canEqLHS_maybe :: Xi -> Maybe CanEqLHS

-- | Retrieve the kind of a <a>CanEqLHS</a>
canEqLHSKind :: CanEqLHS -> TcKind

-- | Convert a <a>CanEqLHS</a> back into a <a>Type</a>
canEqLHSType :: CanEqLHS -> TcType

-- | Are two <a>CanEqLHS</a>s equal?
eqCanEqLHS :: CanEqLHS -> CanEqLHS -> Bool

-- | A hole stores the information needed to report diagnostics about holes
--   in terms (unbound identifiers or underscores) or in types (also called
--   wildcards, as used in partial type signatures). See Note [Holes].
data Hole
Hole :: HoleSort -> RdrName -> TcType -> CtLoc -> Hole

-- | What flavour of hole is this?
[hole_sort] :: Hole -> HoleSort

-- | The name of this hole
[hole_occ] :: Hole -> RdrName

-- | Type to be printed to the user For expression holes: type of expr For
--   type holes: the missing type
[hole_ty] :: Hole -> TcType

-- | Where hole was written
[hole_loc] :: Hole -> CtLoc

-- | Used to indicate which sort of hole we have.
data HoleSort

-- | Either an out-of-scope variable or a "true" hole in an expression
--   (TypedHoles). The HoleExprRef says where to write the the erroring
--   expression for -fdefer-type-errors.
ExprHole :: HoleExprRef -> HoleSort

-- | A hole in a type (PartialTypeSignatures)
TypeHole :: HoleSort

-- | A hole in a constraint, like @f :: (_, Eq a) =&gt; ... Differentiated
--   from TypeHole because a ConstraintHole is simplified differently. See
--   Note [Do not simplify ConstraintHoles] in GHC.Tc.Solver.
ConstraintHole :: HoleSort

-- | Returns True of equality constraints that are definitely insoluble, as
--   well as TypeError constraints. Can return <a>True</a> for Given
--   constraints, unlike <a>insolubleWantedCt</a>.
--   
--   This function is critical for accurate pattern-match overlap warnings.
--   See Note [Pattern match warnings with insoluble Givens] in
--   GHC.Tc.Solver
--   
--   Note that this does not traverse through the constraint to find nested
--   custom type errors: it only detects <tt>TypeError msg ::
--   Constraint</tt>, and not e.g. <tt>Eq (TypeError msg)</tt>.
--   
--   Does this hole represent an "out of scope" error? See Note [Insoluble
--   holes]
isOutOfScopeHole :: Hole -> Bool

-- | A delayed error, to be reported after constraint solving, in order to
--   benefit from deferred unifications.
data DelayedError

-- | A hole (in a type or in a term).
--   
--   See Note [Holes].
DE_Hole :: Hole -> DelayedError

-- | A type could not be ensured to be concrete.
--   
--   See Note [The Concrete mechanism] in GHC.Tc.Utils.Concrete.
DE_NotConcrete :: NotConcreteError -> DelayedError

-- | Why did we require that a certain type be concrete?
data NotConcreteError

-- | Concreteness was required by a representation-polymorphism check.
--   
--   See Note [The Concrete mechanism] in GHC.Tc.Utils.Concrete.
NCE_FRR :: CtLoc -> FixedRuntimeRepOrigin -> NonEmpty NotConcreteReason -> NotConcreteError

-- | Where did this check take place?
[nce_loc] :: NotConcreteError -> CtLoc

-- | Which representation-polymorphism check did we perform?
[nce_frr_origin] :: NotConcreteError -> FixedRuntimeRepOrigin

-- | Why did the check fail?
[nce_reasons] :: NotConcreteError -> NonEmpty NotConcreteReason

-- | Why did we decide that a type was not concrete?
data NotConcreteReason

-- | The type contains a <tt>TyConApp</tt> of a non-concrete <a>TyCon</a>.
--   
--   See Note [Concrete types] in GHC.Tc.Utils.Concrete.
NonConcreteTyCon :: TyCon -> [TcType] -> NotConcreteReason

-- | The type contains a type variable that could not be made concrete
--   (e.g. a skolem type variable).
NonConcretisableTyVar :: TyVar -> NotConcreteReason

-- | The type contains a cast.
ContainsCast :: TcType -> TcCoercionN -> NotConcreteReason

-- | The type contains a forall.
ContainsForall :: ForAllTyBinder -> TcType -> NotConcreteReason

-- | The type contains a <tt>CoercionTy</tt>.
ContainsCoercionTy :: TcCoercion -> NotConcreteReason
data WantedConstraints
WC :: Cts -> Bag Implication -> Bag DelayedError -> WantedConstraints
[wc_simple] :: WantedConstraints -> Cts
[wc_impl] :: WantedConstraints -> Bag Implication
[wc_errors] :: WantedConstraints -> Bag DelayedError
insolubleWC :: WantedConstraints -> Bool
emptyWC :: WantedConstraints
isEmptyWC :: WantedConstraints -> Bool

-- | Checks whether a the given wanted constraints are solved, i.e. that
--   there are no simple constraints left and all the implications are
--   solved.
isSolvedWC :: WantedConstraints -> Bool
andWC :: WantedConstraints -> WantedConstraints -> WantedConstraints
unionsWC :: [WantedConstraints] -> WantedConstraints
mkSimpleWC :: [CtEvidence] -> WantedConstraints
mkImplicWC :: Bag Implication -> WantedConstraints
addInsols :: WantedConstraints -> Bag Ct -> WantedConstraints
dropMisleading :: WantedConstraints -> WantedConstraints
addSimples :: WantedConstraints -> Bag Ct -> WantedConstraints
addImplics :: WantedConstraints -> Bag Implication -> WantedConstraints
addHoles :: WantedConstraints -> Bag Hole -> WantedConstraints
addNotConcreteError :: WantedConstraints -> NotConcreteError -> WantedConstraints
addDelayedErrors :: WantedConstraints -> Bag DelayedError -> WantedConstraints

-- | Returns free variables of WantedConstraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfWC :: WantedConstraints -> TyCoVarSet

-- | Returns free variables of WantedConstraints as a deterministically
--   ordered list. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfWCList :: WantedConstraints -> [TyCoVar]
insolubleWantedCt :: Ct -> Bool
insolubleEqCt :: Ct -> Bool

-- | Returns True of constraints that are definitely insoluble, as well as
--   TypeError constraints. Can return <a>True</a> for Given constraints,
--   unlike <a>insolubleWantedCt</a>.
--   
--   The function is tuned for application <i>after</i> constraint solving
--   i.e. assuming canonicalisation has been done That's why it looks only
--   for IrredCt; all insoluble constraints are put into CIrredCan
insolubleCt :: Ct -> Bool
insolubleImplic :: Implication -> Bool

-- | Gather all the type variables from <a>WantedConstraints</a> that it
--   would be unhelpful to default. For the moment, these are only
--   <a>ConcreteTv</a> metavariables participating in a nominal equality
--   whose other side is not concrete; it's usually better to report those
--   as errors instead of defaulting.
nonDefaultableTyVarsOfWC :: WantedConstraints -> TyCoVarSet
data Implication
Implic :: TcLevel -> SkolemInfoAnon -> [TcTyVar] -> [EvVar] -> HasGivenEqs -> Bool -> TcLclEnv -> WantedConstraints -> EvBindsVar -> VarSet -> VarSet -> ImplicStatus -> Implication
[ic_tclvl] :: Implication -> TcLevel
[ic_info] :: Implication -> SkolemInfoAnon
[ic_skols] :: Implication -> [TcTyVar]
[ic_given] :: Implication -> [EvVar]
[ic_given_eqs] :: Implication -> HasGivenEqs
[ic_warn_inaccessible] :: Implication -> Bool
[ic_env] :: Implication -> TcLclEnv
[ic_wanted] :: Implication -> WantedConstraints
[ic_binds] :: Implication -> EvBindsVar
[ic_need_inner] :: Implication -> VarSet
[ic_need_outer] :: Implication -> VarSet
[ic_status] :: Implication -> ImplicStatus
implicationPrototype :: Implication
checkTelescopeSkol :: SkolemInfoAnon -> Bool
data ImplicStatus
IC_Solved :: [EvVar] -> ImplicStatus
[ics_dead] :: ImplicStatus -> [EvVar]
IC_Insoluble :: ImplicStatus
IC_BadTelescope :: ImplicStatus
IC_Unsolved :: ImplicStatus
isInsolubleStatus :: ImplicStatus -> Bool
isSolvedStatus :: ImplicStatus -> Bool
type UserGiven = Implication
getUserGivensFromImplics :: [Implication] -> [UserGiven]
data HasGivenEqs
NoGivenEqs :: HasGivenEqs
LocalGivenEqs :: HasGivenEqs
MaybeGivenEqs :: HasGivenEqs
checkImplicationInvariants :: (HasCallStack, Applicative m) => Implication -> m ()

-- | See Note [SubGoalDepth]
data SubGoalDepth
initialSubGoalDepth :: SubGoalDepth
maxSubGoalDepth :: SubGoalDepth -> SubGoalDepth -> SubGoalDepth
bumpSubGoalDepth :: SubGoalDepth -> SubGoalDepth
subGoalDepthExceeded :: DynFlags -> SubGoalDepth -> Bool
data CtLoc
CtLoc :: CtOrigin -> TcLclEnv -> Maybe TypeOrKind -> !SubGoalDepth -> CtLoc
[ctl_origin] :: CtLoc -> CtOrigin
[ctl_env] :: CtLoc -> TcLclEnv
[ctl_t_or_k] :: CtLoc -> Maybe TypeOrKind
[ctl_depth] :: CtLoc -> !SubGoalDepth
ctLocSpan :: CtLoc -> RealSrcSpan
ctLocEnv :: CtLoc -> TcLclEnv
ctLocLevel :: CtLoc -> TcLevel
ctLocOrigin :: CtLoc -> CtOrigin
ctLocTypeOrKind_maybe :: CtLoc -> Maybe TypeOrKind
ctLocDepth :: CtLoc -> SubGoalDepth
bumpCtLocDepth :: CtLoc -> CtLoc
isGivenLoc :: CtLoc -> Bool
setCtLocOrigin :: CtLoc -> CtOrigin -> CtLoc
updateCtLocOrigin :: CtLoc -> (CtOrigin -> CtOrigin) -> CtLoc
setCtLocEnv :: CtLoc -> TcLclEnv -> CtLoc
setCtLocSpan :: CtLoc -> RealSrcSpan -> CtLoc
pprCtLoc :: CtLoc -> SDoc
data CtEvidence
CtGiven :: TcPredType -> EvVar -> CtLoc -> CtEvidence
[ctev_pred] :: CtEvidence -> TcPredType
[ctev_evar] :: CtEvidence -> EvVar
[ctev_loc] :: CtEvidence -> CtLoc
CtWanted :: TcPredType -> TcEvDest -> CtLoc -> RewriterSet -> CtEvidence
[ctev_pred] :: CtEvidence -> TcPredType
[ctev_dest] :: CtEvidence -> TcEvDest
[ctev_loc] :: CtEvidence -> CtLoc
[ctev_rewriters] :: CtEvidence -> RewriterSet

-- | A place for type-checking evidence to go after it is generated.
--   
--   <ul>
--   <li>Wanted equalities use HoleDest,</li>
--   <li>other Wanteds use EvVarDest.</li>
--   </ul>
data TcEvDest

-- | bind this var to the evidence EvVarDest is always used for
--   non-type-equalities e.g. class constraints
EvVarDest :: EvVar -> TcEvDest

-- | fill in this hole with the evidence HoleDest is always used for
--   type-equalities See Note [Coercion holes] in GHC.Core.TyCo.Rep
HoleDest :: CoercionHole -> TcEvDest
mkKindLoc :: TcType -> TcType -> CtLoc -> CtLoc

-- | Take a CtLoc and moves it to the kind level
toKindLoc :: CtLoc -> CtLoc
mkGivenLoc :: TcLevel -> SkolemInfoAnon -> TcLclEnv -> CtLoc
isWanted :: CtEvidence -> Bool
isGiven :: CtEvidence -> Bool

-- | Get the role relevant for a <a>CtEvidence</a>
ctEvRole :: CtEvidence -> Role

-- | Set the type of CtEvidence.
--   
--   This function ensures that the invariants on <a>CtEvidence</a> hold,
--   by updating the evidence and the ctev_pred in sync with each other.
--   See Note [CtEvidence invariants].
setCtEvPredType :: HasDebugCallStack => CtEvidence -> Type -> CtEvidence
setCtEvLoc :: CtEvidence -> CtLoc -> CtEvidence

-- | Returns free variables of constraints as a deterministically ordered
--   list. See Note [Deterministic FV] in GHC.Utils.FV.
tyCoVarsOfCtEvList :: CtEvidence -> [TcTyCoVar]

-- | Returns free variables of constraints as a non-deterministic set
tyCoVarsOfCtEv :: CtEvidence -> TcTyCoVarSet

-- | Returns free variables of a bag of constraints as a deterministically
--   ordered list. See Note [Deterministic FV] in GHC.Utils.FV.
tyCoVarsOfCtEvsList :: [CtEvidence] -> [TcTyCoVar]
ctEvUnique :: CtEvidence -> Unique
tcEvDestUnique :: TcEvDest -> Unique

-- | Stores a set of CoercionHoles that have been used to rewrite a
--   constraint. See Note [Wanteds rewrite Wanteds].
newtype RewriterSet
RewriterSet :: UniqSet CoercionHole -> RewriterSet
emptyRewriterSet :: RewriterSet
isEmptyRewriterSet :: RewriterSet -> Bool

-- | Makes a <a>RewriterSet</a> from all the coercion holes that occur in
--   the given type.
rewriterSetFromType :: Type -> RewriterSet

-- | Makes a <a>RewriterSet</a> from all the coercion holes that occur in
--   the given types.
rewriterSetFromTypes :: [Type] -> RewriterSet

-- | Makes a <a>RewriterSet</a> from all the coercion holes that occur in
--   the given coercion.
rewriterSetFromCo :: Coercion -> RewriterSet
addRewriterSet :: RewriterSet -> CoercionHole -> RewriterSet
wrapType :: Type -> [TyVar] -> [PredType] -> Type
data CtFlavour
Given :: CtFlavour
Wanted :: CtFlavour
ctEvFlavour :: CtEvidence -> CtFlavour

-- | Whether or not one <a>Ct</a> can rewrite another is determined by its
--   flavour and its equality relation. See also Note [Flavours with roles]
--   in GHC.Tc.Solver.InertSet
type CtFlavourRole = (CtFlavour, EqRel)

-- | Extract the flavour, role, and boxity from a <a>CtEvidence</a>
ctEvFlavourRole :: CtEvidence -> CtFlavourRole

-- | Extract the flavour and role from a <a>Ct</a>
ctFlavourRole :: Ct -> CtFlavourRole
eqCanRewrite :: EqRel -> EqRel -> Bool
eqCanRewriteFR :: CtFlavourRole -> CtFlavourRole -> Bool
pprEvVarTheta :: [EvVar] -> SDoc
pprEvVars :: [EvVar] -> SDoc
pprEvVarWithType :: EvVar -> SDoc
instance GHC.Classes.Eq GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Base.Monoid GHC.Tc.Types.Constraint.RewriterSet
instance GHC.Base.Semigroup GHC.Tc.Types.Constraint.RewriterSet
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.RewriterSet
instance GHC.Classes.Eq GHC.Tc.Types.Constraint.CtFlavour
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.SubGoalDepth
instance GHC.Classes.Ord GHC.Tc.Types.Constraint.SubGoalDepth
instance GHC.Classes.Eq GHC.Tc.Types.Constraint.SubGoalDepth
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.WantedConstraints
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.Implication
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.DelayedError
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.Hole
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.NotConcreteError
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.Ct
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.QCInst
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CtEvidence
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CtFlavour
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.TcEvDest
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Base.Semigroup GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Base.Monoid GHC.Tc.Types.Constraint.HasGivenEqs
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.ImplicStatus
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CtIrredReason
instance GHC.Base.Semigroup GHC.Tc.Types.Constraint.CheckTyEqResult
instance GHC.Base.Monoid GHC.Tc.Types.Constraint.CheckTyEqResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CheckTyEqResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.HoleSort
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.Constraint.CanEqLHS

module GHC.Builtin.Types.Literals
typeNatTyCons :: [TyCon]
typeNatCoAxiomRules :: UniqFM FastString CoAxiomRule
data BuiltInSynFamily
BuiltInSynFamily :: ([Type] -> Maybe (CoAxiomRule, [Type], Type)) -> ([Type] -> Type -> [TypeEqn]) -> ([Type] -> Type -> [Type] -> Type -> [TypeEqn]) -> BuiltInSynFamily
[sfMatchFam] :: BuiltInSynFamily -> [Type] -> Maybe (CoAxiomRule, [Type], Type)
[sfInteractTop] :: BuiltInSynFamily -> [Type] -> Type -> [TypeEqn]
[sfInteractInert] :: BuiltInSynFamily -> [Type] -> Type -> [Type] -> Type -> [TypeEqn]
typeNatAddTyCon :: TyCon
typeNatMulTyCon :: TyCon
typeNatExpTyCon :: TyCon
typeNatSubTyCon :: TyCon
typeNatDivTyCon :: TyCon
typeNatModTyCon :: TyCon
typeNatLogTyCon :: TyCon
typeNatCmpTyCon :: TyCon
typeSymbolCmpTyCon :: TyCon
typeSymbolAppendTyCon :: TyCon
typeCharCmpTyCon :: TyCon
typeConsSymbolTyCon :: TyCon
typeUnconsSymbolTyCon :: TyCon
typeCharToNatTyCon :: TyCon
typeNatToCharTyCon :: TyCon


-- | Utility types used within the constraint solver
module GHC.Tc.Solver.Types
type DictMap a = TcAppMap a
emptyDictMap :: DictMap a
findDictsByClass :: DictMap a -> Class -> Bag a
addDict :: DictMap a -> Class -> [Type] -> a -> DictMap a
addDictsByClass :: DictMap Ct -> Class -> Bag Ct -> DictMap Ct
delDict :: DictMap a -> Class -> [Type] -> DictMap a
foldDicts :: (a -> b -> b) -> DictMap a -> b -> b
filterDicts :: (Ct -> Bool) -> DictMap Ct -> DictMap Ct
findDict :: DictMap a -> CtLoc -> Class -> [Type] -> Maybe a
dictsToBag :: DictMap a -> Bag a
partitionDicts :: (Ct -> Bool) -> DictMap Ct -> (Bag Ct, DictMap Ct)
type FunEqMap a = TcAppMap a
emptyFunEqs :: TcAppMap a
foldFunEqs :: (a -> b -> b) -> FunEqMap a -> b -> b
findFunEq :: FunEqMap a -> TyCon -> [Type] -> Maybe a
insertFunEq :: FunEqMap a -> TyCon -> [Type] -> a -> FunEqMap a
findFunEqsByTyCon :: FunEqMap a -> TyCon -> [a]
type TcAppMap a = DTyConEnv (ListMap LooseTypeMap a)
emptyTcAppMap :: TcAppMap a
isEmptyTcAppMap :: TcAppMap a -> Bool
insertTcApp :: TcAppMap a -> TyCon -> [Type] -> a -> TcAppMap a
alterTcApp :: forall a. TcAppMap a -> TyCon -> [Type] -> XT a -> TcAppMap a
filterTcAppMap :: forall a. (a -> Bool) -> TcAppMap a -> TcAppMap a
tcAppMapToBag :: TcAppMap a -> Bag a
foldTcAppMap :: (a -> b -> b) -> TcAppMap a -> b -> b
type EqualCtList = [Ct]
filterEqualCtList :: (Ct -> Bool) -> EqualCtList -> Maybe EqualCtList
addToEqualCtList :: Ct -> EqualCtList -> EqualCtList

module GHC.Tc.Solver.InertSet
data WorkList
WL :: [Ct] -> [Ct] -> Bag Implication -> WorkList
[wl_eqs] :: WorkList -> [Ct]
[wl_rest] :: WorkList -> [Ct]
[wl_implics] :: WorkList -> Bag Implication
isEmptyWorkList :: WorkList -> Bool
emptyWorkList :: WorkList
extendWorkListNonEq :: Ct -> WorkList -> WorkList
extendWorkListCt :: Ct -> WorkList -> WorkList
extendWorkListCts :: [Ct] -> WorkList -> WorkList
extendWorkListEq :: Ct -> WorkList -> WorkList
appendWorkList :: WorkList -> WorkList -> WorkList
extendWorkListImplic :: Implication -> WorkList -> WorkList
workListSize :: WorkList -> Int
selectWorkItem :: WorkList -> Maybe (Ct, WorkList)
data InertSet
IS :: InertCans -> CycleBreakerVarStack -> FunEqMap Reduction -> DictMap CtEvidence -> InertSet
[inert_cans] :: InertSet -> InertCans
[inert_cycle_breakers] :: InertSet -> CycleBreakerVarStack
[inert_famapp_cache] :: InertSet -> FunEqMap Reduction
[inert_solved_dicts] :: InertSet -> DictMap CtEvidence
data InertCans
IC :: InertEqs -> FunEqMap EqualCtList -> DictMap Ct -> [QCInst] -> DictMap Ct -> Cts -> TcLevel -> Bool -> InertCans
[inert_eqs] :: InertCans -> InertEqs
[inert_funeqs] :: InertCans -> FunEqMap EqualCtList
[inert_dicts] :: InertCans -> DictMap Ct
[inert_insts] :: InertCans -> [QCInst]

-- | See Note [Safe Haskell Overlapping Instances Implementation] in
--   GHC.Tc.Solver
[inert_safehask] :: InertCans -> DictMap Ct
[inert_irreds] :: InertCans -> Cts
[inert_given_eq_lvl] :: InertCans -> TcLevel
[inert_given_eqs] :: InertCans -> Bool
type InertEqs = DTyVarEnv EqualCtList
emptyInert :: InertSet
addInertItem :: TcLevel -> InertCans -> Ct -> InertCans

-- | Returns True iff there are no Given constraints that might,
--   potentially, match the given class consraint. This is used when
--   checking to see if a Given might overlap with an instance. See Note
--   [Instance and Given overlap] in <a>GHC.Tc.Solver.Interact</a>
noMatchableGivenDicts :: InertSet -> CtLoc -> Class -> [TcType] -> Bool
noGivenNewtypeReprEqs :: TyCon -> InertSet -> Bool
mightEqualLater :: InertSet -> TcPredType -> CtLoc -> TcPredType -> CtLoc -> Maybe Subst

-- | Is it (potentially) loopy to use the first <tt>ct1</tt> to solve
--   <tt>ct2</tt>?
--   
--   Necessary (but not sufficient) conditions for this function to return
--   <tt>True</tt>:
--   
--   <ul>
--   <li><tt>ct1</tt> and <tt>ct2</tt> both arise from superclass
--   expansion,</li>
--   <li><tt>ct1</tt> is a Given and <tt>ct2</tt> is a Wanted.</li>
--   </ul>
--   
--   See Note [Solving superclass constraints] in GHC.Tc.TyCl.Instance,
--   (sc2).
prohibitedSuperClassSolve :: CtLoc -> CtLoc -> Bool
foldTyEqs :: (Ct -> b -> b) -> InertEqs -> b -> b
delEq :: InertCans -> CanEqLHS -> TcType -> InertCans
findEq :: InertCans -> CanEqLHS -> [Ct]
partitionInertEqs :: (Ct -> Bool) -> InertEqs -> ([Ct], InertEqs)
partitionFunEqs :: (Ct -> Bool) -> FunEqMap EqualCtList -> ([Ct], FunEqMap EqualCtList)
kickOutRewritableLHS :: CtFlavourRole -> CanEqLHS -> InertCans -> (WorkList, InertCans)
type CycleBreakerVarStack = -- | a stack of (CycleBreakerTv, original family applications) lists -- first element in the stack corresponds to current implication; --   later elements correspond to outer implications -- used to undo the cycle-breaking needed to handle -- Note [Type equality cycles] in GHC.Tc.Solver.Canonical -- Why store the outer implications? For the use in mightEqualLater (only) NonEmpty [(TcTyVar, TcType)]

-- | Push a fresh environment onto the cycle-breaker var stack. Useful when
--   entering a nested implication.
pushCycleBreakerVarStack :: CycleBreakerVarStack -> CycleBreakerVarStack

-- | Add a new cycle-breaker binding to the top environment on the stack.
insertCycleBreakerBinding :: TcTyVar -> TcType -> CycleBreakerVarStack -> CycleBreakerVarStack

-- | Perform a monadic operation on all pairs in the top environment in the
--   stack.
forAllCycleBreakerBindings_ :: Monad m => CycleBreakerVarStack -> (TcTyVar -> TcType -> m ()) -> m ()
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InertSet.InertSet
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InertSet.InertCans
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InertSet.WorkList


-- | Domain types used in <a>GHC.HsToCore.Pmc.Solver</a>. The ultimate goal
--   is to define <a>Nabla</a>, which models normalised refinement types
--   from the paper <a>Lower Your Guards: A Compositional Pattern-Match
--   Coverage Checker"</a>.
module GHC.HsToCore.Pmc.Solver.Types

-- | See <a>vi_bot</a>.
data BotInfo
IsBot :: BotInfo
IsNotBot :: BotInfo
MaybeBot :: BotInfo
data PmAltConApp
PACA :: !PmAltCon -> ![TyVar] -> ![Id] -> PmAltConApp
[paca_con] :: PmAltConApp -> !PmAltCon
[paca_tvs] :: PmAltConApp -> ![TyVar]
[paca_ids] :: PmAltConApp -> ![Id]

-- | Information about an <a>Id</a>. Stores positive (<a>vi_pos</a>) facts,
--   like <tt>x ~ Just 42</tt>, and negative (<a>vi_neg</a>) facts, like "x
--   is not (:)". Also caches the type (<tt>vi_ty</tt>), the
--   <a>ResidualCompleteMatches</a> of a COMPLETE set (<a>vi_rcm</a>).
--   
--   Subject to Note [The Pos/Neg invariant] in
--   <a>GHC.HsToCore.Pmc.Solver</a>.
data VarInfo
VI :: !Id -> ![PmAltConApp] -> !PmAltConSet -> BotInfo -> !ResidualCompleteMatches -> VarInfo

-- | The <a>Id</a> in question. Important for adding new constraints
--   relative to this <a>VarInfo</a> when we don't easily have the
--   <a>Id</a> available.
[vi_id] :: VarInfo -> !Id

-- | Positive info: <a>PmAltCon</a> apps it is (i.e. <tt>x ~ [Just y,
--   PatSyn z]</tt>), all at the same time (i.e. conjunctive). We need a
--   list because of nested pattern matches involving pattern synonym case
--   x of { Just y -&gt; case x of PatSyn z -&gt; ... } However, no more
--   than one RealDataCon in the list, otherwise contradiction because of
--   generativity.
[vi_pos] :: VarInfo -> ![PmAltConApp]

-- | Negative info: A list of <a>PmAltCon</a>s that it cannot match.
--   Example, assuming
--   
--   <pre>
--   data T = Leaf Int | Branch T T | Node Int T
--   </pre>
--   
--   then <tt>x ≁ [Leaf, Node]</tt> means that <tt>x</tt> cannot match a
--   <tt>Leaf</tt> or <tt>Node</tt>, and hence can only match
--   <tt>Branch</tt>. Is orthogonal to anything from <a>vi_pos</a>, in the
--   sense that <a>eqPmAltCon</a> returns <tt>PossiblyOverlap</tt> for any
--   pairing between <a>vi_pos</a> and <a>vi_neg</a>.
[vi_neg] :: VarInfo -> !PmAltConSet

-- | Can this variable be ⊥? Models (mutually contradicting) <tt>x ~ ⊥</tt>
--   and <tt>x ≁ ⊥</tt> constraints. E.g. * <a>MaybeBot</a>: Don't know;
--   Neither <tt>x ~ ⊥</tt> nor <tt>x ≁ ⊥</tt>. * <a>IsBot</a>: <tt>x ~
--   ⊥</tt> * <a>IsNotBot</a>: <tt>x ≁ ⊥</tt>
[vi_bot] :: VarInfo -> BotInfo

-- | A cache of the associated COMPLETE sets. At any time a superset of
--   possible constructors of each COMPLETE set. So, if it's not in here,
--   we can't possibly match on it. Complementary to <a>vi_neg</a>. We
--   still need it to recognise completion of a COMPLETE set efficiently
--   for large enums.
[vi_rcm] :: VarInfo -> !ResidualCompleteMatches

-- | The term oracle state. Stores <a>VarInfo</a> for encountered
--   <a>Id</a>s. These entries are possibly shared when we figure out that
--   two variables must be equal, thus represent the same set of values.
--   
--   See Note [TmState invariants] in <a>GHC.HsToCore.Pmc.Solver</a>.
data TmState
TmSt :: !UniqSDFM Id VarInfo -> !CoreMap Id -> !DIdSet -> TmState

-- | Facts about term variables. Deterministic env, so that we generate
--   deterministic error messages.
[ts_facts] :: TmState -> !UniqSDFM Id VarInfo

-- | An environment for looking up whether we already encountered
--   semantically equivalent expressions that we want to represent by the
--   same <a>Id</a> representative.
[ts_reps] :: TmState -> !CoreMap Id

-- | Which <a>VarInfo</a> needs to be checked for inhabitants because of
--   new negative constraints (e.g. <tt>x ≁ ⊥</tt> or <tt>x ≁ K</tt>).
[ts_dirty] :: TmState -> !DIdSet

-- | The type oracle state. An <a>InertSet</a> that we incrementally add
--   local type constraints to, together with a sequence number that counts
--   the number of times we extended it with new facts.
data TyState
TySt :: !Int -> !InertSet -> TyState
[ty_st_n] :: TyState -> !Int
[ty_st_inert] :: TyState -> !InertSet

-- | A normalised refinement type ∇ ("nabla"), comprised of an inert set of
--   canonical (i.e. mutually compatible) term and type constraints that
--   form the refinement type's predicate.
data Nabla
MkNabla :: !TyState -> !TmState -> Nabla

-- | Type oracle; things like a~Int
[nabla_ty_st] :: Nabla -> !TyState

-- | Term oracle; things like x~Nothing
[nabla_tm_st] :: Nabla -> !TmState

-- | A disjunctive bag of <a>Nabla</a>s, representing a refinement type.
newtype Nablas
MkNablas :: Bag Nabla -> Nablas
initNablas :: Nablas
lookupRefuts :: Nabla -> Id -> [PmAltCon]
lookupSolution :: Nabla -> Id -> Maybe PmAltConApp
lookupVarInfo :: TmState -> Id -> VarInfo

-- | Like <tt>lookupVarInfo ts x</tt>, but <tt>lookupVarInfo ts x = (y,
--   vi)</tt> also looks through newtype constructors. We have <tt>x ~ N1
--   (... (Nk y))</tt> such that the returned <tt>y</tt> doesn't have a
--   positive newtype constructor constraint associated with it (yet). The
--   <a>VarInfo</a> returned is that of <tt>y</tt>'s representative.
--   
--   Careful, this means that <tt>idType x</tt> might be different to
--   <tt>idType y</tt>, even modulo type normalisation!
--   
--   See also Note [Coverage checking Newtype matches] in
--   GHC.HsToCore.Pmc.Solver.
lookupVarInfoNT :: TmState -> Id -> (Id, VarInfo)
trvVarInfo :: Functor f => (VarInfo -> f (a, VarInfo)) -> Nabla -> Id -> f (a, Nabla)

-- | A list of conlikes which represents a complete pattern match. These
--   arise from <tt>COMPLETE</tt> signatures. See also Note [Implementation
--   of COMPLETE pragmas].
data CompleteMatch

-- | A data type that caches for the <a>VarInfo</a> of <tt>x</tt> the
--   results of querying <tt>dsGetCompleteMatches</tt> and then striking
--   out all occurrences of <tt>K</tt> for which we already know <tt>x ≁
--   K</tt> from these sets.
--   
--   For motivation, see Section 5.3 in Lower Your Guards. See also Note
--   [Implementation of COMPLETE pragmas]
data ResidualCompleteMatches
RCM :: !Maybe CompleteMatch -> !Maybe [CompleteMatch] -> ResidualCompleteMatches

-- | The residual set for the vanilla COMPLETE set from the data defn.
--   Tracked separately from <a>rcm_pragmas</a>, because it might only be
--   known much later (when we have enough type information to see the
--   <a>TyCon</a> of the match), or not at all even. Until that happens, it
--   is <a>Nothing</a>.
[rcm_vanilla] :: ResidualCompleteMatches -> !Maybe CompleteMatch

-- | The residual sets for <i>all</i> COMPLETE sets from pragmas that are
--   visible when compiling this module. Querying that set with
--   <tt>dsGetCompleteMatches</tt> requires <tt>DsM</tt>, so we initialise
--   it with <a>Nothing</a> until first needed in a <tt>DsM</tt> context.
[rcm_pragmas] :: ResidualCompleteMatches -> !Maybe [CompleteMatch]
getRcm :: ResidualCompleteMatches -> [CompleteMatch]
isRcmInitialised :: ResidualCompleteMatches -> Bool

-- | Literals (simple and overloaded ones) for pattern match checking.
--   
--   See Note [Undecidable Equality for PmAltCons]
data PmLit
PmLit :: Type -> PmLitValue -> PmLit
[pm_lit_ty] :: PmLit -> Type
[pm_lit_val] :: PmLit -> PmLitValue
data PmLitValue
PmLitInt :: Integer -> PmLitValue
PmLitRat :: Rational -> PmLitValue
PmLitChar :: Char -> PmLitValue
PmLitString :: FastString -> PmLitValue
PmLitOverInt :: Int -> Integer -> PmLitValue
PmLitOverRat :: Int -> FractionalLit -> PmLitValue
PmLitOverString :: FastString -> PmLitValue

-- | Represents the head of a match against a <a>ConLike</a> or literal.
--   Really similar to <a>AltCon</a>.
data PmAltCon
PmAltConLike :: ConLike -> PmAltCon
PmAltLit :: PmLit -> PmAltCon

-- | Type of a <a>PmLit</a>
pmLitType :: PmLit -> Type

-- | Type of a <a>PmAltCon</a>
pmAltConType :: PmAltCon -> [Type] -> Type

-- | Is a match on this constructor forcing the match variable? True of
--   data constructors, literals and pattern synonyms (#17357), but not of
--   newtypes. See Note [Coverage checking Newtype matches] in
--   GHC.HsToCore.Pmc.Solver.
isPmAltConMatchStrict :: PmAltCon -> Bool
pmAltConImplBangs :: PmAltCon -> [HsImplBang]
data PmAltConSet
emptyPmAltConSet :: PmAltConSet
isEmptyPmAltConSet :: PmAltConSet -> Bool

-- | Whether there is a <a>PmAltCon</a> in the <a>PmAltConSet</a> that
--   compares <a>Equal</a> to the given <a>PmAltCon</a> according to
--   <a>eqPmAltCon</a>.
elemPmAltConSet :: PmAltCon -> PmAltConSet -> Bool
extendPmAltConSet :: PmAltConSet -> PmAltCon -> PmAltConSet
pmAltConSetElems :: PmAltConSet -> [PmAltCon]

-- | Undecidable semantic equality result. See Note [Undecidable Equality
--   for PmAltCons]
data PmEquality
Equal :: PmEquality
Disjoint :: PmEquality
PossiblyOverlap :: PmEquality

-- | We can't in general decide whether two <a>PmAltCon</a>s match the same
--   set of values. In addition to the reasons in <a>eqPmLit</a> and
--   <a>eqConLike</a>, a <a>PmAltConLike</a> might or might not represent
--   the same value as a <a>PmAltLit</a>. See Note [Undecidable Equality
--   for PmAltCons].
--   
--   <ul>
--   <li><tt>Just True</tt> ==&gt; Surely equal</li>
--   <li><tt>Just False</tt> ==&gt; Surely different (non-overlapping,
--   even!)</li>
--   <li><tt>Nothing</tt> ==&gt; Equality relation undecidable</li>
--   </ul>
--   
--   Examples (omitting some constructor wrapping):
--   
--   <ul>
--   <li><tt>eqPmAltCon (LitInt 42) (LitInt 1) == Just False</tt>: Lit
--   equality is decidable</li>
--   <li><tt>eqPmAltCon (DataCon A) (DataCon B) == Just False</tt>: DataCon
--   equality is decidable</li>
--   <li><tt>eqPmAltCon (LitOverInt 42) (LitOverInt 1) == Nothing</tt>:
--   OverLit equality is undecidable</li>
--   <li><tt>eqPmAltCon (PatSyn PA) (PatSyn PB) == Nothing</tt>: PatSyn
--   equality is undecidable</li>
--   <li><tt>eqPmAltCon (DataCon I#) (LitInt 1) == Nothing</tt>: DataCon to
--   Lit comparisons are undecidable without reasoning about the wrapped
--   <tt>Int#</tt></li>
--   <li><tt>eqPmAltCon (LitOverInt 1) (LitOverInt 1) == Just True</tt>: We
--   assume reflexivity for overloaded literals</li>
--   <li><tt>eqPmAltCon (PatSyn PA) (PatSyn PA) == Just True</tt>: We
--   assume reflexivity for Pattern Synonyms</li>
--   </ul>
eqPmAltCon :: PmAltCon -> PmAltCon -> PmEquality
literalToPmLit :: Type -> Literal -> Maybe PmLit
negatePmLit :: PmLit -> Maybe PmLit
overloadPmLit :: Type -> PmLit -> Maybe PmLit
pmLitAsStringLit :: PmLit -> Maybe FastString
coreExprAsPmLit :: CoreExpr -> Maybe PmLit
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.BotInfo
instance GHC.Show.Show GHC.HsToCore.Pmc.Solver.Types.PmEquality
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.PmEquality
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.Nablas
instance GHC.Base.Semigroup GHC.HsToCore.Pmc.Solver.Types.Nablas
instance GHC.Base.Monoid GHC.HsToCore.Pmc.Solver.Types.Nablas
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.Nabla
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.TmState
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.VarInfo
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmAltConSet
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmAltConApp
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.PmAltCon
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmAltCon
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.Types.PmLit
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmEquality
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmLit
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.PmLitValue
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.ResidualCompleteMatches
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.BotInfo
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.Types.TyState


-- | Types used through-out pattern match checking. This module is mostly
--   there to be imported from <a>GHC.HsToCore.Types</a>. The exposed API
--   is that of <a>GHC.HsToCore.Pmc</a>.
--   
--   These types model the paper <a>Lower Your Guards: A Compositional
--   Pattern-Match Coverage Checker"</a>.
module GHC.HsToCore.Pmc.Types

-- | Means by which we identify a source construct for later
--   pretty-printing in a warning message. <a>SDoc</a> for the equation to
--   show, <a>Located</a> for the location.
newtype SrcInfo
SrcInfo :: Located SDoc -> SrcInfo

-- | A very simple language for pattern guards. Let bindings, bang
--   patterns, and matching variables against flat constructor patterns.
--   The LYG guard language.
data PmGrd

-- | <tt>PmCon x K dicts args</tt> corresponds to a <tt>K dicts args &lt;-
--   x</tt> guard. The <tt>args</tt> are bound in this construct, the
--   <tt>x</tt> is just a use. For the arguments' meaning see
--   <a>ConPatOut</a>.
PmCon :: !Id -> !PmAltCon -> ![TyVar] -> ![EvVar] -> ![Id] -> PmGrd
[pm_id] :: PmGrd -> !Id
[pm_con_con] :: PmGrd -> !PmAltCon
[pm_con_tvs] :: PmGrd -> ![TyVar]
[pm_con_dicts] :: PmGrd -> ![EvVar]
[pm_con_args] :: PmGrd -> ![Id]

-- | <tt>PmBang x</tt> corresponds to a <tt>seq x True</tt> guard. If the
--   extra <a>SrcInfo</a> is present, the bang guard came from a source
--   bang pattern, in which case we might want to report it as redundant.
--   See Note [Dead bang patterns] in GHC.HsToCore.Pmc.Check.
PmBang :: !Id -> !Maybe SrcInfo -> PmGrd
[pm_id] :: PmGrd -> !Id
[_pm_loc] :: PmGrd -> !Maybe SrcInfo

-- | <tt>PmLet x expr</tt> corresponds to a <tt>let x = expr</tt> guard.
--   This actually <i>binds</i> <tt>x</tt>.
PmLet :: !Id -> !CoreExpr -> PmGrd
[pm_id] :: PmGrd -> !Id
[_pm_let_expr] :: PmGrd -> !CoreExpr

-- | A sequence of <a>PmGrd</a>s.
newtype GrdVec
GrdVec :: [PmGrd] -> GrdVec

-- | A guard tree denoting <tt>MatchGroup</tt>.
newtype PmMatchGroup p
PmMatchGroup :: NonEmpty (PmMatch p) -> PmMatchGroup p

-- | A guard tree denoting <tt>Match</tt>: A payload describing the pats
--   and a bunch of GRHS.
data PmMatch p
PmMatch :: !p -> !PmGRHSs p -> PmMatch p
[pm_pats] :: PmMatch p -> !p
[pm_grhss] :: PmMatch p -> !PmGRHSs p

-- | A guard tree denoting <tt>GRHSs</tt>: A bunch of <a>PmLet</a> guards
--   for local bindings from the <tt>GRHSs</tt>s <tt>where</tt> clauses and
--   the actual list of <tt>GRHS</tt>. See Note [Long-distance information
--   for HsLocalBinds] in <a>GHC.HsToCore.Pmc.Desugar</a>.
data PmGRHSs p
PmGRHSs :: !p -> !NonEmpty (PmGRHS p) -> PmGRHSs p
[pgs_lcls] :: PmGRHSs p -> !p
[pgs_grhss] :: PmGRHSs p -> !NonEmpty (PmGRHS p)

-- | A guard tree denoting <tt>GRHS</tt>: A payload describing the grds and
--   a <a>SrcInfo</a> useful for printing out in warnings messages.
data PmGRHS p
PmGRHS :: !p -> !SrcInfo -> PmGRHS p
[pg_grds] :: PmGRHS p -> !p
[pg_rhs] :: PmGRHS p -> !SrcInfo

-- | A guard tree denoting a pattern binding.
newtype PmPatBind p
PmPatBind :: PmGRHS p -> PmPatBind p

-- | A guard tree denoting an -XEmptyCase.
newtype PmEmptyCase
PmEmptyCase :: Id -> PmEmptyCase
[pe_var] :: PmEmptyCase -> Id

-- | Redundancy sets, used to determine redundancy of RHSs and bang
--   patterns (later digested into a <tt>CIRB</tt>).
data RedSets
RedSets :: !Nablas -> !Nablas -> !OrdList (Nablas, SrcInfo) -> RedSets

-- | The <i>Covered</i> set; the set of values reaching a particular
--   program point.
[rs_cov] :: RedSets -> !Nablas

-- | The <i>Diverging</i> set; empty if no match can lead to divergence. If
--   it wasn't empty, we have to turn redundancy warnings into
--   inaccessibility warnings for any subclauses.
[rs_div] :: RedSets -> !Nablas

-- | If any of the <a>Nablas</a> is empty, the corresponding <a>SrcInfo</a>
--   pin-points a bang pattern in source that is redundant. See Note [Dead
--   bang patterns].
[rs_bangs] :: RedSets -> !OrdList (Nablas, SrcInfo)
data Precision
Approximate :: Precision
Precise :: Precision

-- | Pattern-match coverage check result
data CheckResult a
CheckResult :: !a -> !Nablas -> !Precision -> CheckResult a

-- | A hole for redundancy info and covered sets.
[cr_ret] :: CheckResult a -> !a

-- | The set of uncovered values falling out at the bottom. (for
--   -Wincomplete-patterns, but also important state for the algorithm)
[cr_uncov] :: CheckResult a -> !Nablas

-- | A flag saying whether we ran into the <tt>maxPmCheckModels</tt> limit
--   for the purpose of suggesting to crank it up in the warning message.
--   Writer state.
[cr_approx] :: CheckResult a -> !Precision

-- | Used as tree payload pre-checking. The LYG guards to check.
type Pre = GrdVec

-- | Used as tree payload post-checking. The redundancy info we elaborated.
type Post = RedSets
instance GHC.Show.Show GHC.HsToCore.Pmc.Types.Precision
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Types.Precision
instance GHC.Base.Functor GHC.HsToCore.Pmc.Types.CheckResult
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.CheckResult a)
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.RedSets
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.Precision
instance GHC.Base.Semigroup GHC.HsToCore.Pmc.Types.Precision
instance GHC.Base.Monoid GHC.HsToCore.Pmc.Types.Precision
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmPatBind p)
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.PmEmptyCase
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmMatchGroup p)
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmMatch p)
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmGRHSs p)
instance GHC.Utils.Outputable.Outputable p => GHC.Utils.Outputable.Outputable (GHC.HsToCore.Pmc.Types.PmGRHS p)
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.GrdVec
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.PmGrd
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Types.SrcInfo


-- | Provides facilities for pretty-printing <a>Nabla</a>s in a way
--   appropriate for user facing pattern match warnings.
module GHC.HsToCore.Pmc.Ppr

-- | Pretty-print the guts of an uncovered value vector abstraction, i.e.,
--   its components and refutable shapes associated to any mentioned
--   variables.
--   
--   Example for <tt>([Just p, q], [p :-&gt; [3,4], q :-&gt; [0,5]])</tt>:
--   
--   <pre>
--   (Just p) q
--       where p is not one of {3, 4}
--             q is not one of {0, 5}
--   </pre>
--   
--   When the set of refutable shapes contains more than 3 elements, the
--   additional elements are indicated by "...".
pprUncovered :: Nabla -> [Id] -> SDoc

module GHC.Tc.Errors.Types

-- | An error which might arise during typechecking/renaming.
data TcRnMessage

-- | Simply wraps an unknown <a>Diagnostic</a> message <tt>a</tt>. It can
--   be used by plugins to provide custom diagnostic messages originated
--   during typechecking/renaming.
[TcRnUnknownMessage] :: UnknownDiagnostic -> TcRnMessage

-- | TcRnMessageWithInfo is a constructor which is used when extra
--   information is needed to be provided in order to qualify a diagnostic
--   and where it was originated (and why). It carries an extra
--   <a>UnitState</a> which can be used to pretty-print some names and it
--   wraps a <a>TcRnMessageDetailed</a>, which includes any extra context
--   associated with this diagnostic.
[TcRnMessageWithInfo] :: !UnitState -> !TcRnMessageDetailed -> TcRnMessage

-- | TcRnWithHsDocContext annotates an error message with the context in
--   which it originated.
[TcRnWithHsDocContext] :: !HsDocContext -> !TcRnMessage -> TcRnMessage

-- | TcRnSolverReport is the constructor used to report unsolved
--   constraints after constraint solving, as well as other errors such as
--   hole fit errors.
--   
--   See the documentation of the <a>TcSolverReportMsg</a> datatype for an
--   overview of the different errors.
[TcRnSolverReport] :: SolverReportWithCtxt -> DiagnosticReason -> [GhcHint] -> TcRnMessage

-- | TcRnRedundantConstraints is a warning that is emitted when a binding
--   has a user-written type signature which contains superfluous
--   constraints.
--   
--   Example:
--   
--   f :: (Eq a, Ord a) =&gt; a -&gt; a -&gt; a f x y = (x &lt; y) || x ==
--   y -- `Eq a` is superfluous: the `Ord a` constraint suffices.
--   
--   Test cases: T9939, T10632, T18036a, T20602, PluralS, T19296.
[TcRnRedundantConstraints] :: [Id] -> (SkolemInfoAnon, Bool) -> TcRnMessage

-- | TcRnInaccessibleCode is a warning that is emitted when the RHS of a
--   pattern match is inaccessible, because the constraint solver has
--   detected a contradiction.
--   
--   Example:
--   
--   data B a where { MkTrue :: B True; MkFalse :: B False }
--   
--   foo :: B False -&gt; Bool foo MkFalse = False foo MkTrue = True --
--   Inaccessible: requires True ~ False
--   
--   Test cases: T7293, T7294, T15558, T17646, T18572, T18610, tcfail167.
[TcRnInaccessibleCode] :: Implication -> SolverReportWithCtxt -> TcRnMessage

-- | A type which was expected to have a fixed runtime representation does
--   not have a fixed runtime representation.
--   
--   Example:
--   
--   data D (a :: TYPE r) = MkD a
--   
--   Test cases: T11724, T18534, RepPolyPatSynArg,
--   RepPolyPatSynUnliftedNewtype, RepPolyPatSynRes, T20423
[TcRnTypeDoesNotHaveFixedRuntimeRep] :: !Type -> !FixedRuntimeRepProvenance -> !ErrInfo -> TcRnMessage

-- | TcRnImplicitLift is a warning (controlled with -Wimplicit-lift) that
--   occurs when a Template Haskell quote implicitly uses <tt>lift</tt>.
--   
--   Example: warning1 :: Lift t =&gt; t -&gt; Q Exp warning1 x = [| x |]
--   
--   Test cases: th/T17804
[TcRnImplicitLift] :: Name -> !ErrInfo -> TcRnMessage

-- | TcRnUnusedPatternBinds is a warning (controlled with
--   -Wunused-pattern-binds) that occurs if a pattern binding binds no
--   variables at all, unless it is a lone wild-card pattern, or a banged
--   pattern.
--   
--   Example: Just _ = rhs3 -- Warning: unused pattern binding (_, _) =
--   rhs4 -- Warning: unused pattern binding _ = rhs3 -- No warning: lone
--   wild-card pattern !() = rhs4 -- No warning: banged pattern; behaves
--   like seq
--   
--   Test cases: rename/{T13646,T17c,T17e,T7085}
[TcRnUnusedPatternBinds] :: HsBind GhcRn -> TcRnMessage

-- | TcRnDodgyImports is a warning (controlled with -Wdodgy-imports) that
--   occurs when a datatype <tt>T</tt> is imported with all constructors,
--   i.e. 'T(..)', but has been exported abstractly, i.e. <tt>T</tt>.
--   
--   Test cases: rename<i>should_compile</i>T7167
[TcRnDodgyImports] :: RdrName -> TcRnMessage

-- | TcRnDodgyExports is a warning (controlled by -Wdodgy-exports) that
--   occurs when a datatype <tt>T</tt> is exported with all constructors,
--   i.e. 'T(..)', but is it just a type synonym or a type/data family.
--   
--   Example: module Foo ( T(..) -- Warning: T is a type synonym , A(..) --
--   Warning: A is a type family , C(..) -- Warning: C is a data family )
--   where
--   
--   type T = Int type family A :: * -&gt; * data family C :: * -&gt; *
--   
--   Test cases: warnings<i>should_compile</i>DodgyExports01
[TcRnDodgyExports] :: Name -> TcRnMessage

-- | TcRnMissingImportList is a warning (controlled by
--   -Wmissing-import-lists) that occurs when an import declaration does
--   not explicitly list all the names brought into scope.
--   
--   Test cases: rename<i>should_compile</i>T4489
[TcRnMissingImportList] :: IE GhcPs -> TcRnMessage

-- | When a module marked trustworthy or unsafe (using -XTrustworthy or
--   -XUnsafe) is compiled with a plugin, the TcRnUnsafeDueToPlugin warning
--   (controlled by -Wunsafe) is used as the reason the module was inferred
--   to be unsafe. This warning is not raised if the -fplugin-trustworthy
--   flag is passed.
--   
--   Test cases: plugins/T19926
[TcRnUnsafeDueToPlugin] :: TcRnMessage

-- | TcRnModMissingRealSrcSpan is an error that occurs when compiling a
--   module that lacks an associated <a>RealSrcSpan</a>.
--   
--   Test cases: None
[TcRnModMissingRealSrcSpan] :: Module -> TcRnMessage

-- | TcRnIdNotExportedFromModuleSig is an error pertaining to backpack that
--   occurs when an identifier required by a signature is not exported by
--   the module or signature that is being used as a substitution for that
--   signature.
--   
--   Example(s): None
--   
--   Test cases: backpack<i>should_fail</i>bkpfail36
[TcRnIdNotExportedFromModuleSig] :: Name -> Module -> TcRnMessage

-- | TcRnIdNotExportedFromLocalSig is an error pertaining to backpack that
--   occurs when an identifier which is necessary for implementing a module
--   signature is not exported from that signature.
--   
--   Example(s): None
--   
--   Test cases: backpack<i>should_fail</i>bkpfail30
--   backpack<i>should_fail</i>bkpfail31
--   backpack<i>should_fail</i>bkpfail34
[TcRnIdNotExportedFromLocalSig] :: Name -> TcRnMessage

-- | TcRnShadowedName is a warning (controlled by -Wname-shadowing) that
--   occurs whenever an inner-scope value has the same name as an
--   outer-scope value, i.e. the inner value shadows the outer one. This
--   can catch typographical errors that turn into hard-to-find bugs. The
--   warning is suppressed for names beginning with an underscore.
--   
--   Examples(s): f = ... let f = id in ... f ... -- NOT OK, <tt>f</tt> is
--   shadowed f x = do { _ignore &lt;- this; _ignore &lt;- that; return
--   (the other) } -- suppressed via underscore
--   
--   Test cases: typecheck<i>should_compile</i>T10971a
--   rename<i>should_compile</i>rn039 rename<i>should_compile</i>rn064
--   rename<i>should_compile</i>T1972 rename<i>should_fail</i>T2723
--   rename<i>should_compile</i>T3262 driver/werror
[TcRnShadowedName] :: OccName -> ShadowedNameProvenance -> TcRnMessage

-- | TcRnDuplicateWarningDecls is an error that occurs whenever a warning
--   is declared twice.
--   
--   Examples(s): None.
--   
--   Test cases: None.
[TcRnDuplicateWarningDecls] :: !LocatedN RdrName -> !RdrName -> TcRnMessage

-- | TcRnDuplicateWarningDecls is an error that occurs whenever the
--   constraint solver in the simplifier hits the iterations' limit.
--   
--   Examples(s): None.
--   
--   Test cases: None.
[TcRnSimplifierTooManyIterations] :: Cts -> !IntWithInf -> WantedConstraints -> TcRnMessage

-- | TcRnIllegalPatSynDecl is an error that occurs whenever there is an
--   illegal pattern synonym declaration.
--   
--   Examples(s):
--   
--   varWithLocalPatSyn x = case x of P -&gt; () where pattern P = () --
--   not valid, it can't be local, it must be defined at top-level.
--   
--   Test cases: patsyn<i>should_fail</i>local
[TcRnIllegalPatSynDecl] :: !LIdP GhcPs -> TcRnMessage

-- | TcRnLinearPatSyn is an error that occurs whenever a pattern synonym
--   signature uses a field that is not unrestricted.
--   
--   Example(s): None
--   
--   Test cases: linear<i>should_fail</i>LinearPatSyn2
[TcRnLinearPatSyn] :: !Type -> TcRnMessage

-- | TcRnEmptyRecordUpdate is an error that occurs whenever a record is
--   updated without specifying any field.
--   
--   Examples(s):
--   
--   $(deriveJSON defaultOptions{} ''Bad) -- not ok, no fields selected for
--   update of defaultOptions
--   
--   Test cases: th/T12788
[TcRnEmptyRecordUpdate] :: TcRnMessage

-- | TcRnIllegalFieldPunning is an error that occurs whenever field punning
--   is used without the <tt>NamedFieldPuns</tt> extension enabled.
--   
--   Examples(s):
--   
--   data Foo = Foo { a :: Int }
--   
--   foo :: Foo -&gt; Int foo Foo{a} = a -- Not ok, punning used without
--   extension.
--   
--   Test cases: parser<i>should_fail</i>RecordDotSyntaxFail12
[TcRnIllegalFieldPunning] :: !Located RdrName -> TcRnMessage

-- | TcRnIllegalWildcardsInRecord is an error that occurs whenever
--   wildcards (..) are used in a record without the relevant extension
--   being enabled.
--   
--   Examples(s):
--   
--   data Foo = Foo { a :: Int }
--   
--   foo :: Foo -&gt; Int foo Foo{..} = a -- Not ok, wildcards used without
--   extension.
--   
--   Test cases: parser<i>should_fail</i>RecordWildCardsFail
[TcRnIllegalWildcardsInRecord] :: !RecordFieldPart -> TcRnMessage

-- | TcRnIllegalWildcardInType is an error that occurs when a wildcard
--   appears in a type in a location in which wildcards aren't allowed.
--   
--   Examples:
--   
--   Type synonyms:
--   
--   type T = _
--   
--   Class declarations and instances:
--   
--   class C _ instance C _
--   
--   Standalone kind signatures:
--   
--   type D :: _ data D
--   
--   Test cases: ExtraConstraintsWildcardInTypeSplice2
--   ExtraConstraintsWildcardInTypeSpliceUsed
--   ExtraConstraintsWildcardNotLast ExtraConstraintsWildcardTwice
--   NestedExtraConstraintsWildcard NestedNamedExtraConstraintsWildcard
--   PartialClassMethodSignature PartialClassMethodSignature2 T12039
--   T13324_fail1 UnnamedConstraintWildcard1 UnnamedConstraintWildcard2
--   WildcardInADT1 WildcardInADT2 WildcardInADT3 WildcardInADTContext1
--   WildcardInDefault WildcardInDefaultSignature WildcardInDeriving
--   WildcardInForeignExport WildcardInForeignImport WildcardInGADT1
--   WildcardInGADT2 WildcardInInstanceHead WildcardInInstanceSig
--   WildcardInNewtype WildcardInPatSynSig WildcardInStandaloneDeriving
--   WildcardInTypeFamilyInstanceRHS WildcardInTypeSynonymRHS saks_fail003
--   T15433a
[TcRnIllegalWildcardInType] :: Maybe Name -> !BadAnonWildcardContext -> TcRnMessage

-- | TcRnDuplicateFieldName is an error that occurs whenever there are
--   duplicate field names in a record.
--   
--   Examples(s): None.
--   
--   Test cases: None.
[TcRnDuplicateFieldName] :: !RecordFieldPart -> NonEmpty RdrName -> TcRnMessage

-- | TcRnIllegalViewPattern is an error that occurs whenever the
--   ViewPatterns syntax is used but the ViewPatterns language extension is
--   not enabled.
--   
--   Examples(s): data Foo = Foo { a :: Int }
--   
--   foo :: Foo -&gt; Int foo (a -&gt; l) = l -- not OK, the
--   <tt>ViewPattern</tt> extension is not enabled.
--   
--   Test cases: parser<i>should_fail</i>ViewPatternsFail
[TcRnIllegalViewPattern] :: !Pat GhcPs -> TcRnMessage

-- | TcRnCharLiteralOutOfRange is an error that occurs whenever a character
--   is out of range.
--   
--   Examples(s): None
--   
--   Test cases: None
[TcRnCharLiteralOutOfRange] :: !Char -> TcRnMessage

-- | TcRnIllegalWildcardsInConstructor is an error that occurs whenever the
--   record wildcards '..' are used inside a constructor without labeled
--   fields.
--   
--   Examples(s): None
--   
--   Test cases: None
[TcRnIllegalWildcardsInConstructor] :: !Name -> TcRnMessage

-- | TcRnIgnoringAnnotations is a warning that occurs when the source code
--   contains annotation pragmas but the platform in use does not support
--   an external interpreter such as GHCi and therefore the annotations are
--   ignored.
--   
--   Example(s): None
--   
--   Test cases: None
[TcRnIgnoringAnnotations] :: [LAnnDecl GhcRn] -> TcRnMessage

-- | TcRnAnnotationInSafeHaskell is an error that occurs if annotation
--   pragmas are used in conjunction with Safe Haskell.
--   
--   Example(s): None
--   
--   Test cases: annotations<i>should_fail</i>T10826
[TcRnAnnotationInSafeHaskell] :: TcRnMessage

-- | TcRnInvalidTypeApplication is an error that occurs when a visible type
--   application is used with an expression that does not accept
--   "specified" type arguments.
--   
--   Example(s): foo :: forall {a}. a -&gt; a foo x = x bar :: () bar = let
--   x = foo @Int 42 in ()
--   
--   Test cases: overloadedrecflds<i>should_fail</i>overloadedlabelsfail03
--   typecheck<i>should_fail</i>ExplicitSpecificity1
--   typecheck<i>should_fail</i>ExplicitSpecificity10
--   typecheck<i>should_fail</i>ExplicitSpecificity2
--   typecheck<i>should_fail</i>T17173 typecheck<i>should_fail</i>VtaFail
[TcRnInvalidTypeApplication] :: Type -> LHsWcType GhcRn -> TcRnMessage

-- | TcRnTagToEnumMissingValArg is an error that occurs when the
--   'tagToEnum#' function is not applied to a single value argument.
--   
--   Example(s): tagToEnum# 1 2
--   
--   Test cases: None
[TcRnTagToEnumMissingValArg] :: TcRnMessage

-- | TcRnTagToEnumUnspecifiedResTy is an error that occurs when the
--   'tagToEnum#' function is not given a concrete result type.
--   
--   Example(s): foo :: forall a. a foo = tagToEnum# 0#
--   
--   Test cases: typecheck<i>should_fail</i>tcfail164
[TcRnTagToEnumUnspecifiedResTy] :: Type -> TcRnMessage

-- | TcRnTagToEnumResTyNotAnEnum is an error that occurs when the
--   'tagToEnum#' function is given a result type that is not an
--   enumeration type.
--   
--   Example(s): foo :: Int -- not an enumeration TyCon foo = tagToEnum# 0#
--   
--   Test cases: typecheck<i>should_fail</i>tcfail164
[TcRnTagToEnumResTyNotAnEnum] :: Type -> TcRnMessage

-- | TcRnTagToEnumResTyTypeData is an error that occurs when the
--   'tagToEnum#' function is given a result type that is headed by a
--   <tt>type data</tt> type, as the data constructors of a <tt>type
--   data</tt> do not exist at the term level.
--   
--   Example(s): type data Letter = A | B | C
--   
--   foo :: Letter foo = tagToEnum# 0#
--   
--   Test cases: type-data<i>should_fail</i>TDTagToEnum.hs
[TcRnTagToEnumResTyTypeData] :: Type -> TcRnMessage

-- | TcRnArrowIfThenElsePredDependsOnResultTy is an error that occurs when
--   the predicate type of an ifThenElse expression in arrow notation
--   depends on the type of the result.
--   
--   Example(s): None
--   
--   Test cases: None
[TcRnArrowIfThenElsePredDependsOnResultTy] :: TcRnMessage

-- | TcRnIllegalHsBootFileDecl is an error that occurs when an hs-boot file
--   contains declarations that are not allowed, such as bindings.
--   
--   Example(s): None
--   
--   Test cases: None
[TcRnIllegalHsBootFileDecl] :: TcRnMessage

-- | TcRnRecursivePatternSynonym is an error that occurs when a pattern
--   synonym is defined in terms of itself, either directly or indirectly.
--   
--   Example(s): pattern A = B pattern B = A
--   
--   Test cases: patsyn<i>should_fail</i>T16900
[TcRnRecursivePatternSynonym] :: LHsBinds GhcRn -> TcRnMessage

-- | TcRnPartialTypeSigTyVarMismatch is an error that occurs when a partial
--   type signature attempts to unify two different types.
--   
--   Example(s): f :: a -&gt; b -&gt; _ f x y = [x, y]
--   
--   Test cases: partial-sigs<i>should_fail</i>T14449
[TcRnPartialTypeSigTyVarMismatch] :: Name -> Name -> Name -> LHsSigWcType GhcRn -> TcRnMessage

-- | TcRnPartialTypeSigBadQuantifier is an error that occurs when a type
--   variable being quantified over in the partial type signature of a
--   function gets unified with a type that is free in that function's
--   context.
--   
--   Example(s): foo :: Num a =&gt; a -&gt; a foo xxx = g xxx where g ::
--   forall b. Num b =&gt; _ -&gt; b g y = xxx + y
--   
--   Test cases: partial-sig<i>should_fail</i>T14479
[TcRnPartialTypeSigBadQuantifier] :: Name -> Name -> Maybe Type -> LHsSigWcType GhcRn -> TcRnMessage

-- | TcRnMissingSignature is a warning that occurs when a top-level binding
--   or a pattern synonym does not have a type signature.
--   
--   Controlled by the flags: -Wmissing-signatures
--   -Wmissing-exported-signatures -Wmissing-pattern-synonym-signatures
--   -Wmissing-exported-pattern-synonym-signatures
--   -Wmissing-kind-signatures
--   
--   Test cases: T11077 (top-level bindings) T12484 (pattern synonyms)
--   T19564 (kind signatures)
[TcRnMissingSignature] :: MissingSignature -> Exported -> Bool -> TcRnMessage

-- | TcRnPolymorphicBinderMissingSig is a warning controlled by
--   -Wmissing-local-signatures that occurs when a local polymorphic
--   binding lacks a type signature.
--   
--   Example(s): id a = a
--   
--   Test cases: warnings<i>should_compile</i>T12574
[TcRnPolymorphicBinderMissingSig] :: Name -> Type -> TcRnMessage

-- | TcRnOverloadedSig is an error that occurs when a binding group
--   conflicts with the monomorphism restriction.
--   
--   Example(s): data T a = T a mono = ... where x :: Applicative f =&gt; f
--   a T x = ...
--   
--   Test cases: typecheck<i>should_compile</i>T11339
[TcRnOverloadedSig] :: TcIdSigInfo -> TcRnMessage

-- | TcRnTupleConstraintInst is an error that occurs whenever an instance
--   for a tuple constraint is specified.
--   
--   Examples(s): class C m a class D m a f :: (forall a. Eq a =&gt; (C m
--   a, D m a)) =&gt; m a f = undefined
--   
--   Test cases: quantified-constraints/T15334
[TcRnTupleConstraintInst] :: !Class -> TcRnMessage

-- | TcRnAbstractClassInst is an error that occurs whenever an instance of
--   an abstract class is specified.
--   
--   Examples(s): -- A.hs-boot module A where class C a
--   
--   <ul>
--   <li>- B.hs module B where import {-# SOURCE #-} A instance C Int
--   where</li>
--   <li>- A.hs module A where import B class C a where f :: a</li>
--   <li>- Main.hs import A main = print (f :: Int)</li>
--   </ul>
--   
--   Test cases: typecheck<i>should_fail</i>T13068
[TcRnAbstractClassInst] :: !Class -> TcRnMessage

-- | TcRnNoClassInstHead is an error that occurs whenever an instance head
--   is not headed by a class.
--   
--   Examples(s): instance c
--   
--   Test cases: typecheck<i>rename</i>T5513 typecheck<i>rename</i>T16385
[TcRnNoClassInstHead] :: !Type -> TcRnMessage

-- | TcRnUserTypeError is an error that occurs due to a user's custom type
--   error, which can be triggered by adding a <tt>TypeError</tt>
--   constraint in a type signature or typeclass instance.
--   
--   Examples(s): f :: TypeError (Text "This is a type error") f =
--   undefined
--   
--   Test cases: typecheck<i>should_fail</i>CustomTypeErrors02
--   typecheck<i>should_fail</i>CustomTypeErrors03
[TcRnUserTypeError] :: !Type -> TcRnMessage

-- | TcRnConstraintInKind is an error that occurs whenever a constraint is
--   specified in a kind.
--   
--   Examples(s): data Q :: Eq a =&gt; Type where {}
--   
--   Test cases: dependent<i>should_fail</i>T13895 polykinds/T16263
--   saks<i>should_fail</i>saks_fail004 typecheck<i>should_fail</i>T16059a
--   typecheck<i>should_fail</i>T18714
[TcRnConstraintInKind] :: !Type -> TcRnMessage

-- | TcRnUnboxedTupleTypeFuncArg is an error that occurs whenever an
--   unboxed tuple or unboxed sum type is specified as a function argument,
--   when the appropriate extension (`-XUnboxedTuples` or `-XUnboxedSums`)
--   isn't enabled.
--   
--   Examples(s): -- T15073.hs import T15073a newtype Foo a = MkFoo a
--   deriving P
--   
--   <ul>
--   <li>- T15073a.hs class P a where p :: a -&gt; (# a #)</li>
--   </ul>
--   
--   Test cases: deriving<i>should_fail</i>T15073.hs
--   deriving<i>should_fail</i>T15073a.hs
--   typecheck<i>should_fail</i>T16059d
[TcRnUnboxedTupleOrSumTypeFuncArg] :: UnboxedTupleOrSum -> !Type -> TcRnMessage

-- | TcRnLinearFuncInKind is an error that occurs whenever a linear
--   function is specified in a kind.
--   
--   Examples(s): data A :: * %1 -&gt; *
--   
--   Test cases: linear<i>should_fail</i>LinearKind
--   linear<i>should_fail</i>LinearKind2
--   linear<i>should_fail</i>LinearKind3
[TcRnLinearFuncInKind] :: !Type -> TcRnMessage

-- | TcRnForAllEscapeError is an error that occurs whenever a quantified
--   type's kind mentions quantified type variable.
--   
--   Examples(s): type T :: TYPE (BoxedRep l) data T = MkT
--   
--   Test cases: unlifted-datatypes<i>should_fail</i>UnlDataNullaryPoly
[TcRnForAllEscapeError] :: !Type -> !Kind -> TcRnMessage

-- | TcRnVDQInTermType is an error that occurs whenever a visible dependent
--   quantification is specified in the type of a term.
--   
--   Examples(s): a = (undefined :: forall k -&gt; k -&gt; Type) @Int
--   
--   Test cases: dependent<i>should_fail</i>T15859
--   dependent<i>should_fail</i>T16326_Fail1
--   dependent<i>should_fail</i>T16326_Fail2
--   dependent<i>should_fail</i>T16326_Fail3
--   dependent<i>should_fail</i>T16326_Fail4
--   dependent<i>should_fail</i>T16326_Fail5
--   dependent<i>should_fail</i>T16326_Fail6
--   dependent<i>should_fail</i>T16326_Fail7
--   dependent<i>should_fail</i>T16326_Fail8
--   dependent<i>should_fail</i>T16326_Fail9
--   dependent<i>should_fail</i>T16326_Fail10
--   dependent<i>should_fail</i>T16326_Fail11
--   dependent<i>should_fail</i>T16326_Fail12
--   dependent<i>should_fail</i>T17687 dependent<i>should_fail</i>T18271
[TcRnVDQInTermType] :: !Maybe Type -> TcRnMessage

-- | TcRnBadQuantPredHead is an error that occurs whenever a quantified
--   predicate lacks a class or type variable head.
--   
--   Examples(s): class (forall a. A t a =&gt; A t [a]) =&gt; B t where
--   type A t a :: Constraint
--   
--   Test cases: quantified-constraints/T16474
[TcRnBadQuantPredHead] :: !Type -> TcRnMessage

-- | TcRnIllegalTupleConstraint is an error that occurs whenever an illegal
--   tuple constraint is specified.
--   
--   Examples(s): g :: ((Show a, Num a), Eq a) =&gt; a -&gt; a g =
--   undefined
--   
--   Test cases: typecheck<i>should_fail</i>tcfail209a
[TcRnIllegalTupleConstraint] :: !Type -> TcRnMessage

-- | TcRnNonTypeVarArgInConstraint is an error that occurs whenever a non
--   type-variable argument is specified in a constraint.
--   
--   Examples(s): data T instance Eq Int =&gt; Eq T
--   
--   Test cases: ghci<i>scripts</i>T13202 ghci<i>scripts</i>T13202a
--   polykinds/T12055a typecheck<i>should_fail</i>T10351
--   typecheck<i>should_fail</i>T19187 typecheck<i>should_fail</i>T6022
--   typecheck<i>should_fail</i>T8883
[TcRnNonTypeVarArgInConstraint] :: !Type -> TcRnMessage

-- | TcRnIllegalImplicitParam is an error that occurs whenever an illegal
--   implicit parameter is specified.
--   
--   Examples(s): type Bla = ?x::Int data T = T instance Bla =&gt; Eq T
--   
--   Test cases: polykinds/T11466 typecheck<i>should_fail</i>T8912
--   typecheck<i>should_fail</i>tcfail041
--   typecheck<i>should_fail</i>tcfail211
--   typecheck<i>should_fail</i>tcrun045
[TcRnIllegalImplicitParam] :: !Type -> TcRnMessage

-- | TcRnIllegalConstraintSynonymOfKind is an error that occurs whenever an
--   illegal constraint synonym of kind is specified.
--   
--   Examples(s): type Showish = Show f :: (Showish a) =&gt; a -&gt; a f =
--   undefined
--   
--   Test cases: typecheck<i>should_fail</i>tcfail209
[TcRnIllegalConstraintSynonymOfKind] :: !Type -> TcRnMessage

-- | TcRnIllegalClassInst is an error that occurs whenever a class instance
--   is specified for a non-class.
--   
--   Examples(s): type C1 a = (Show (a -&gt; Bool)) instance C1 Int where
--   
--   Test cases: polykinds/T13267
[TcRnIllegalClassInst] :: !TyConFlavour -> TcRnMessage

-- | TcRnOversaturatedVisibleKindArg is an error that occurs whenever an
--   illegal oversaturated visible kind argument is specified.
--   
--   Examples(s): type family F2 :: forall (a :: Type). Type where F2 @a =
--   Maybe a
--   
--   Test cases: typecheck<i>should_fail</i>T15793
--   typecheck<i>should_fail</i>T16255
[TcRnOversaturatedVisibleKindArg] :: !Type -> TcRnMessage

-- | TcRnBadAssociatedType is an error that occurs whenever a class doesn't
--   have an associated type.
--   
--   Examples(s): $(do d &lt;- instanceD (cxt []) (conT ''Eq <tt>appT</tt>
--   conT ''Foo) [tySynInstD $ tySynEqn Nothing (conT ''Rep <tt>appT</tt>
--   conT ''Foo) (conT ''Maybe)] return [d]) ======&gt; instance Eq Foo
--   where type Rep Foo = Maybe
--   
--   Test cases: th/T12387a
[TcRnBadAssociatedType] :: !Name -> !Name -> TcRnMessage

-- | TcRnForAllRankErr is an error that occurs whenever an illegal ranked
--   type is specified.
--   
--   Examples(s): foo :: (a,b) -&gt; (a~b =&gt; t) -&gt; (a,b) foo p x = p
--   
--   Test cases: - ghci<i>should_run</i>T15806 -
--   indexed-types<i>should_fail</i>SimpleFail15 -
--   typecheck<i>should_fail</i>T11355 - typecheck<i>should_fail</i>T12083a
--   - typecheck<i>should_fail</i>T12083b -
--   typecheck<i>should_fail</i>T16059c -
--   typecheck<i>should_fail</i>T16059e - typecheck<i>should_fail</i>T17213
--   - typecheck<i>should_fail</i>T18939_Fail -
--   typecheck<i>should_fail</i>T2538 - typecheck<i>should_fail</i>T5957 -
--   typecheck<i>should_fail</i>T7019 - typecheck<i>should_fail</i>T7019a -
--   typecheck<i>should_fail</i>T7809 - typecheck<i>should_fail</i>T9196 -
--   typecheck<i>should_fail</i>tcfail127 -
--   typecheck<i>should_fail</i>tcfail184 -
--   typecheck<i>should_fail</i>tcfail196 -
--   typecheck<i>should_fail</i>tcfail197
[TcRnForAllRankErr] :: !Rank -> !Type -> TcRnMessage

-- | TcRnMonomorphicBindings is a warning (controlled by
--   -Wmonomorphism-restriction) that arise when the monomorphism
--   restriction applies to the given bindings.
--   
--   Examples(s): {-# OPTIONS_GHC -Wmonomorphism-restriction #-}
--   
--   bar = 10
--   
--   foo :: Int foo = bar
--   
--   main :: IO () main = print foo
--   
--   The example above emits the warning (for <tt>bar</tt>), because
--   without monomorphism restriction the inferred type for <tt>bar</tt> is
--   'bar :: Num p =&gt; p'. This warning tells us that <i>if</i> we were
--   to enable '-XMonomorphismRestriction' we would make <tt>bar</tt> less
--   polymorphic, as its type would become 'bar :: Int', so GHC warns us
--   about that.
--   
--   Test cases: typecheck<i>should_compile</i>T13785
[TcRnMonomorphicBindings] :: [Name] -> TcRnMessage

-- | TcRnOrphanInstance is a warning (controlled by -Wwarn-orphans) that
--   arises when a typeclass instance is an "orphan", i.e. if it appears in
--   a module in which neither the class nor the type being instanced are
--   declared in the same module.
--   
--   Examples(s): None
--   
--   Test cases: warnings<i>should_compile</i>T9178
--   typecheck<i>should_compile</i>T4912
[TcRnOrphanInstance] :: ClsInst -> TcRnMessage

-- | TcRnFunDepConflict is an error that occurs when there are functional
--   dependencies conflicts between instance declarations.
--   
--   Examples(s): None
--   
--   Test cases: typecheck<i>should_fail</i>T2307
--   typecheck<i>should_fail</i>tcfail096
--   typecheck<i>should_fail</i>tcfail202
[TcRnFunDepConflict] :: !UnitState -> NonEmpty ClsInst -> TcRnMessage

-- | TcRnDupInstanceDecls is an error that occurs when there are duplicate
--   instance declarations.
--   
--   Examples(s): class Foo a where foo :: a -&gt; Int
--   
--   instance Foo Int where foo = id
--   
--   instance Foo Int where foo = const 42
--   
--   Test cases: cabal<i>T12733</i>T12733
--   typecheck<i>should_fail</i>tcfail035
--   typecheck<i>should_fail</i>tcfail023
--   backpack<i>should_fail</i>bkpfail18
--   typecheck<i>should_fail</i>TcNullaryTCFail
--   typecheck<i>should_fail</i>tcfail036
--   typecheck<i>should_fail</i>tcfail073 module/mod51 module/mod52
--   module/mod44
[TcRnDupInstanceDecls] :: !UnitState -> NonEmpty ClsInst -> TcRnMessage

-- | TcRnConflictingFamInstDecls is an error that occurs when there are
--   conflicting family instance declarations.
--   
--   Examples(s): None.
--   
--   Test cases: indexed-types<i>should_fail</i>ExplicitForAllFams4b
--   indexed-types<i>should_fail</i>NoGood
--   indexed-types<i>should_fail</i>Over
--   indexed-types<i>should_fail</i>OverDirectThisMod
--   indexed-types<i>should_fail</i>OverIndirectThisMod
--   indexed-types<i>should_fail</i>SimpleFail11a
--   indexed-types<i>should_fail</i>SimpleFail11b
--   indexed-types<i>should_fail</i>SimpleFail11c
--   indexed-types<i>should_fail</i>SimpleFail11d
--   indexed-types<i>should_fail</i>SimpleFail2a
--   indexed-types<i>should_fail</i>SimpleFail2b
--   indexed-types<i>should_fail</i>T13092/T13092
--   indexed-types<i>should_fail</i>T13092c/T13092c
--   indexed-types<i>should_fail</i>T14179
--   indexed-types<i>should_fail</i>T2334A
--   indexed-types<i>should_fail</i>T2677
--   indexed-types<i>should_fail</i>T3330b
--   indexed-types<i>should_fail</i>T4246
--   indexed-types<i>should_fail</i>T7102a
--   indexed-types<i>should_fail</i>T9371 polykinds/T7524
--   typecheck<i>should_fail</i>UnliftedNewtypesOverlap
[TcRnConflictingFamInstDecls] :: NonEmpty FamInst -> TcRnMessage
[TcRnFamInstNotInjective] :: InjectivityErrReason -> TyCon -> NonEmpty CoAxBranch -> TcRnMessage

-- | TcRnBangOnUnliftedType is a warning (controlled by
--   -Wredundant-strictness-flags) that occurs when a strictness annotation
--   is applied to an unlifted type.
--   
--   Example(s): data T = MkT !Int# -- Strictness flag has no effect on
--   unlifted types
--   
--   Test cases: typecheck<i>should_compile</i>T20187a
--   typecheck<i>should_compile</i>T20187b
[TcRnBangOnUnliftedType] :: !Type -> TcRnMessage

-- | TcRnLazyBangOnUnliftedType is a warning (controlled by
--   -Wredundant-strictness-flags) that occurs when a lazy annotation is
--   applied to an unlifted type.
--   
--   Example(s): data T = MkT ~Int# -- Lazy flag has no effect on unlifted
--   types
--   
--   Test cases: typecheck<i>should_compile</i>T21951a
--   typecheck<i>should_compile</i>T21951b
[TcRnLazyBangOnUnliftedType] :: !Type -> TcRnMessage

-- | TcRnMultipleDefaultDeclarations is an error that occurs when a module
--   has more than one default declaration.
--   
--   Example: default (Integer, Int) default (Double, Float) -- 2nd default
--   declaration not allowed
--   
--   Text cases: module/mod58
[TcRnMultipleDefaultDeclarations] :: [LDefaultDecl GhcRn] -> TcRnMessage

-- | TcRnBadDefaultType is an error that occurs when a type used in a
--   default declaration does not have an instance for any of the
--   applicable classes.
--   
--   Example(s): data Foo default (Foo)
--   
--   Test cases: typecheck<i>should_fail</i>T11974b
[TcRnBadDefaultType] :: Type -> [Class] -> TcRnMessage

-- | TcRnPatSynBundledWithNonDataCon is an error that occurs when a
--   module's export list bundles a pattern synonym with a type that is not
--   a proper `data` or `newtype` construction.
--   
--   Example(s): module Foo (MyClass(.., P)) where pattern P = Nothing
--   class MyClass a where foo :: a -&gt; Int
--   
--   Test cases: patsyn<i>should_fail</i>export-class
[TcRnPatSynBundledWithNonDataCon] :: TcRnMessage

-- | TcRnPatSynBundledWithWrongType is an error that occurs when the export
--   list of a module has a pattern synonym bundled with a type that does
--   not match the type of the pattern synonym.
--   
--   Example(s): module Foo (R(P,x)) where data Q = Q Int data R = R
--   pattern P{x} = Q x
--   
--   Text cases: patsyn<i>should_fail</i>export-ps-rec-sel
--   patsyn<i>should_fail</i>export-type-synonym
--   patsyn<i>should_fail</i>export-type
[TcRnPatSynBundledWithWrongType] :: Type -> Type -> TcRnMessage

-- | TcRnDupeModuleExport is a warning controlled by
--   <tt>-Wduplicate-exports</tt> that occurs when a module appears more
--   than once in an export list.
--   
--   Example(s): module Foo (module Bar, module Bar) import Bar
--   
--   Text cases: None
[TcRnDupeModuleExport] :: ModuleName -> TcRnMessage

-- | TcRnExportedModNotImported is an error that occurs when an export list
--   contains a module that is not imported.
--   
--   Example(s): None
--   
--   Text cases: module/mod135 module/mod8
--   rename<i>should_fail</i>rnfail028 backpack<i>should_fail</i>bkpfail48
[TcRnExportedModNotImported] :: ModuleName -> TcRnMessage

-- | TcRnNullExportedModule is a warning controlled by -Wdodgy-exports that
--   occurs when an export list contains a module that has no exports.
--   
--   Example(s): module Foo (module Bar) where import Bar ()
--   
--   Test cases: None
[TcRnNullExportedModule] :: ModuleName -> TcRnMessage

-- | TcRnMissingExportList is a warning controlled by
--   -Wmissing-export-lists that occurs when a module does not have an
--   explicit export list.
--   
--   Example(s): None
--   
--   Test cases: typecheck<i>should_fail</i>MissingExportList03
[TcRnMissingExportList] :: ModuleName -> TcRnMessage

-- | TcRnExportHiddenComponents is an error that occurs when an export
--   contains constructor or class methods that are not visible.
--   
--   Example(s): None
--   
--   Test cases: None
[TcRnExportHiddenComponents] :: IE GhcPs -> TcRnMessage

-- | TcRnDuplicateExport is a warning (controlled by -Wduplicate-exports)
--   that occurs when an identifier appears in an export list more than
--   once.
--   
--   Example(s): None
--   
--   Test cases: module/MultiExport module/mod128 module/mod14 module/mod5
--   overloadedrecflds<i>should_fail</i>DuplicateExports
--   patsyn<i>should_compile</i>T11959
[TcRnDuplicateExport] :: GreName -> IE GhcPs -> IE GhcPs -> TcRnMessage

-- | TcRnExportedParentChildMismatch is an error that occurs when an export
--   is bundled with a parent that it does not belong to
--   
--   Example(s): module Foo (T(a)) where data T a = True
--   
--   Test cases: module/T11970 module/T11970B module/mod17 module/mod3
--   overloadedrecflds<i>should_fail</i>NoParent
[TcRnExportedParentChildMismatch] :: Name -> TyThing -> GreName -> [Name] -> TcRnMessage

-- | TcRnConflictingExports is an error that occurs when different
--   identifiers that have the same name are being exported by a module.
--   
--   Example(s): module Foo (Bar.f, module Baz) where import qualified Bar
--   (f) import Baz (f)
--   
--   Test cases: module/mod131 module/mod142 module/mod143 module/mod144
--   module/mod145 module/mod146 module/mod150 module/mod155
--   overloadedrecflds<i>should_fail</i>T14953
--   overloadedrecflds<i>should_fail</i>overloadedrecfldsfail10
--   rename<i>should_fail</i>rnfail029 rename<i>should_fail</i>rnfail040
--   typecheck<i>should_fail</i>T16453E2
--   typecheck<i>should_fail</i>tcfail025
--   typecheck<i>should_fail</i>tcfail026
[TcRnConflictingExports] :: OccName -> GreName -> GlobalRdrElt -> IE GhcPs -> GreName -> GlobalRdrElt -> IE GhcPs -> TcRnMessage

-- | TcRnAmbiguousField is a warning controlled by -Wambiguous-fields
--   occurring when a record update's type cannot be precisely determined.
--   This will not be supported by -XDuplicateRecordFields in future
--   releases.
--   
--   Example(s): data Person = MkPerson { personId :: Int, name :: String }
--   data Address = MkAddress { personId :: Int, address :: String } bad1 x
--   = x { personId = 4 } :: Person -- ambiguous bad2 (x :: Person) = x {
--   personId = 4 } -- ambiguous good x = (x :: Person) { personId = 4 } --
--   not ambiguous
--   
--   Test cases: overloadedrecflds<i>should_fail</i>overloadedrecfldsfail06
[TcRnAmbiguousField] :: HsExpr GhcRn -> TyCon -> TcRnMessage

-- | TcRnMissingFields is a warning controlled by -Wmissing-fields
--   occurring when the intialisation of a record is missing one or more
--   (lazy) fields.
--   
--   Example(s): data Rec = Rec { a :: Int, b :: String, c :: Bool } x =
--   Rec { a = 1, b = "two" } -- missing field <tt>c</tt>
--   
--   Test cases: deSugar<i>should_compile</i>T13870
--   deSugar<i>should_compile</i>ds041 patsyn<i>should_compile</i>T11283
--   rename<i>should_compile</i>T5334 rename<i>should_compile</i>T12229
--   rename<i>should_compile</i>T5892a
--   warnings<i>should_fail</i>WerrorFail2
[TcRnMissingFields] :: ConLike -> [(FieldLabelString, TcType)] -> TcRnMessage

-- | TcRnFieldUpdateInvalidType is an error occurring when an updated
--   field's type mentions something that is outside the universally
--   quantified variables of the data constructor, such as an existentially
--   quantified type.
--   
--   Example(s): data X = forall a. MkX { f :: a } x = (MkX ()) { f = False
--   }
--   
--   Test cases: patsyn<i>should_fail</i>records-exquant
--   typecheck<i>should_fail</i>T3323
[TcRnFieldUpdateInvalidType] :: [(FieldLabelString, TcType)] -> TcRnMessage

-- | TcRnNoConstructorHasAllFields is an error that occurs when a record
--   update has fields that no single constructor encompasses.
--   
--   Example(s): data Foo = A { x :: Bool } | B { y :: Int } foo = (A
--   False) { x = True, y = 5 }
--   
--   Test cases: overloadedrecflds<i>should_fail</i>overloadedrecfldsfail08
--   patsyn<i>should_fail</i>mixed-pat-syn-record-sels
--   typecheck<i>should_fail</i>T7989
[TcRnNoConstructorHasAllFields] :: [FieldLabelString] -> TcRnMessage
[TcRnMixedSelectors] :: Name -> [Id] -> Name -> [Id] -> TcRnMessage
[TcRnMissingStrictFields] :: ConLike -> [(FieldLabelString, TcType)] -> TcRnMessage
[TcRnNoPossibleParentForFields] :: [LHsRecUpdField GhcRn] -> TcRnMessage
[TcRnBadOverloadedRecordUpdate] :: [LHsRecUpdField GhcRn] -> TcRnMessage
[TcRnStaticFormNotClosed] :: Name -> NotClosedReason -> TcRnMessage

-- | TcRnSpecialClassInst is an error that occurs when a user attempts to
--   define an instance for a built-in typeclass such as
--   <tt>Coercible</tt>, <a>Typeable</a>, or <tt>KnownNat</tt>, outside of
--   a signature file.
--   
--   Test cases: deriving<i>should_fail</i>T9687
--   deriving<i>should_fail</i>T14916 polykinds/T8132
--   typecheck<i>should_fail</i>TcCoercibleFail2
--   typecheck<i>should_fail</i>T12837 typecheck<i>should_fail</i>T14390
[TcRnSpecialClassInst] :: !Class -> !Bool -> TcRnMessage

-- | TcRnUselessTypeable is a warning (controlled by -Wderiving-typeable)
--   that occurs when trying to derive an instance of the <a>Typeable</a>
--   class. Deriving <a>Typeable</a> is no longer necessary (hence the
--   "useless") as all types automatically derive <a>Typeable</a> in modern
--   GHC versions.
--   
--   Example(s): None.
--   
--   Test cases: warnings<i>should_compile</i>DerivingTypeable
[TcRnUselessTypeable] :: TcRnMessage

-- | TcRnDerivingDefaults is a warning (controlled by -Wderiving-defaults)
--   that occurs when both <tt>DeriveAnyClass</tt> and
--   <tt>GeneralizedNewtypeDeriving</tt> are enabled, and therefore GHC
--   defaults to <tt>DeriveAnyClass</tt>, which might not be what the user
--   wants.
--   
--   Example(s): None.
--   
--   Test cases: typecheck<i>should_compile</i>T15839a
--   deriving<i>should_compile</i>T16179
[TcRnDerivingDefaults] :: !Class -> TcRnMessage

-- | TcRnNonUnaryTypeclassConstraint is an error that occurs when GHC
--   encounters a non-unary constraint when trying to derive a typeclass.
--   
--   Example(s): class A deriving instance A data B deriving A -- We cannot
--   derive A, is not unary (i.e. 'class A a').
--   
--   Test cases: deriving<i>should_fail</i>T7959
--   deriving<i>should_fail</i>drvfail005
--   deriving<i>should_fail</i>drvfail009
--   deriving<i>should_fail</i>drvfail006
[TcRnNonUnaryTypeclassConstraint] :: !LHsSigType GhcRn -> TcRnMessage

-- | TcRnPartialTypeSignatures is a warning (controlled by
--   -Wpartial-type-signatures) that occurs when a wildcard '_' is found in
--   place of a type in a signature or a type class derivation
--   
--   Example(s): foo :: _ -&gt; Int foo = ...
--   
--   deriving instance _ =&gt; Eq (Foo a)
--   
--   Test cases: dependent<i>should_compile</i>T11241
--   dependent<i>should_compile</i>T15076
--   dependent<i>should_compile</i>T14880-2
--   typecheck<i>should_compile</i>T17024
--   typecheck<i>should_compile</i>T10072
--   partial-sigs<i>should_fail</i>TidyClash2
--   partial-sigs<i>should_fail</i>Defaulting1MROff
--   partial-sigs<i>should_fail</i>WildcardsInPatternAndExprSig
--   partial-sigs<i>should_fail</i>T10615
--   partial-sigs<i>should_fail</i>T14584a
--   partial-sigs<i>should_fail</i>TidyClash
--   partial-sigs<i>should_fail</i>T11122
--   partial-sigs<i>should_fail</i>T14584
--   partial-sigs<i>should_fail</i>T10045
--   partial-sigs<i>should_fail</i>PartialTypeSignaturesDisabled
--   partial-sigs<i>should_fail</i>T10999
--   partial-sigs<i>should_fail</i>ExtraConstraintsWildcardInExpressionSignature
--   partial-sigs<i>should_fail</i>ExtraConstraintsWildcardInPatternSplice
--   partial-sigs<i>should_fail</i>WildcardInstantiations
--   partial-sigs<i>should_run</i>T15415
--   partial-sigs<i>should_compile</i>T10463
--   partial-sigs<i>should_compile</i>T15039a
--   partial-sigs<i>should_compile</i>T16728b
--   partial-sigs<i>should_compile</i>T15039c
--   partial-sigs<i>should_compile</i>T10438
--   partial-sigs<i>should_compile</i>SplicesUsed
--   partial-sigs<i>should_compile</i>T18008
--   partial-sigs<i>should_compile</i>ExprSigLocal
--   partial-sigs<i>should_compile</i>T11339a
--   partial-sigs<i>should_compile</i>T11670
--   partial-sigs<i>should_compile</i>WarningWildcardInstantiations
--   partial-sigs<i>should_compile</i>T16728
--   partial-sigs<i>should_compile</i>T12033
--   partial-sigs<i>should_compile</i>T15039b
--   partial-sigs<i>should_compile</i>T10403
--   partial-sigs<i>should_compile</i>T11192
--   partial-sigs<i>should_compile</i>T16728a
--   partial-sigs<i>should_compile</i>TypedSplice
--   partial-sigs<i>should_compile</i>T15039d
--   partial-sigs<i>should_compile</i>T11016
--   partial-sigs<i>should_compile</i>T13324_compile2
--   linear<i>should_fail</i>LinearPartialSig polykinds/T14265
--   polykinds/T14172
[TcRnPartialTypeSignatures] :: !SuggestPartialTypeSignatures -> !ThetaType -> TcRnMessage

-- | TcRnCannotDeriveInstance is an error that occurs every time a
--   typeclass instance can't be derived. The
--   <a>DeriveInstanceErrReason</a> will contain the specific reason this
--   error arose.
--   
--   Example(s): None.
--   
--   Test cases: generics<i>T10604</i>T10604_no_PolyKinds
--   deriving<i>should_fail</i>drvfail009
--   deriving<i>should_fail</i>drvfail-functor2
--   deriving<i>should_fail</i>T10598_fail3
--   deriving<i>should_fail</i>deriving-via-fail2
--   deriving<i>should_fail</i>deriving-via-fail
--   deriving<i>should_fail</i>T16181
[TcRnCannotDeriveInstance] :: !Class -> [Type] -> !Maybe (DerivStrategy GhcTc) -> !UsingGeneralizedNewtypeDeriving -> !DeriveInstanceErrReason -> TcRnMessage

-- | TcRnLazyGADTPattern is an error that occurs when a user writes a
--   nested GADT pattern match inside a lazy (~) pattern.
--   
--   Test case: gadt/lazypat
[TcRnLazyGADTPattern] :: TcRnMessage

-- | TcRnArrowProcGADTPattern is an error that occurs when a user writes a
--   GADT pattern inside arrow proc notation.
--   
--   Test case: arrows<i>should_fail</i>arrowfail004.
[TcRnArrowProcGADTPattern] :: TcRnMessage

-- | TcRnForallIdentifier is a warning (controlled with
--   -Wforall-identifier) that occurs when a definition uses
--   <tt>forall</tt> as an identifier.
--   
--   Example: forall x = () g forall = ()
--   
--   Test cases: T20609 T20609a T20609b T20609c T20609d
[TcRnForallIdentifier] :: RdrName -> TcRnMessage

-- | TcRnTypeEqualityOutOfScope is a warning (controlled by
--   -Wtype-equality-out-of-scope) that occurs when the type equality (a ~
--   b) is not in scope.
--   
--   Test case: T18862b
[TcRnTypeEqualityOutOfScope] :: TcRnMessage

-- | TcRnTypeEqualityRequiresOperators is a warning (controlled by
--   -Wtype-equality-requires-operators) that occurs when the type equality
--   (a ~ b) is used without the TypeOperators extension.
--   
--   Example: {-# LANGUAGE NoTypeOperators #-} f :: (a ~ b) =&gt; a -&gt; b
--   
--   Test case: T18862a
[TcRnTypeEqualityRequiresOperators] :: TcRnMessage

-- | TcRnIllegalTypeOperator is an error that occurs when a type operator
--   is used without the TypeOperators extension.
--   
--   Example: {-# LANGUAGE NoTypeOperators #-} f :: Vec a n -&gt; Vec a m
--   -&gt; Vec a (n + m)
--   
--   Test case: T12811
[TcRnIllegalTypeOperator] :: !SDoc -> !RdrName -> TcRnMessage

-- | TcRnIllegalTypeOperatorDecl is an error that occurs when a type or
--   class operator is declared without the TypeOperators extension.
--   
--   See Note [Type and class operator definitions]
--   
--   Example: {-# LANGUAGE Haskell2010 #-} {-# LANGUAGE
--   MultiParamTypeClasses #-}
--   
--   module T3265 where
--   
--   data a :+: b = Left a | Right b
--   
--   class a :*: b where {}
--   
--   Test cases: T3265, tcfail173
[TcRnIllegalTypeOperatorDecl] :: !RdrName -> TcRnMessage

-- | TcRnGADTMonoLocalBinds is a warning controlled by
--   -Wgadt-mono-local-binds that occurs when pattern matching on a GADT
--   when -XMonoLocalBinds is off.
--   
--   Example(s): None
--   
--   Test cases: T20485, T20485a
[TcRnGADTMonoLocalBinds] :: TcRnMessage

-- | The TcRnNotInScope constructor is used for various not-in-scope
--   errors. See <a>NotInScopeError</a> for more details.
[TcRnNotInScope] :: NotInScopeError -> RdrName -> [ImportError] -> [GhcHint] -> TcRnMessage

-- | TcRnUntickedPromotedThing is a warning (controlled with
--   -Wunticked-promoted-constructors) that is triggered by an unticked
--   occurrence of a promoted data constructor.
--   
--   Examples:
--   
--   data A = MkA type family F (a :: A) where { F MkA = Bool }
--   
--   type B = [ Int, Bool ]
--   
--   Test cases: T9778, T19984.
[TcRnUntickedPromotedThing] :: UntickedPromotedThing -> TcRnMessage

-- | TcRnIllegalBuiltinSyntax is an error that occurs when built-in syntax
--   appears in an unexpected location, e.g. as a data constructor or in a
--   fixity declaration.
--   
--   Examples:
--   
--   infixl 5 :
--   
--   data P = (,)
--   
--   Test cases: rnfail042, T14907b, T15124, T15233.
[TcRnIllegalBuiltinSyntax] :: SDoc -> RdrName -> TcRnMessage

-- | TcRnWarnDefaulting is a warning (controlled by -Wtype-defaults) that
--   is triggered whenever a Wanted typeclass constraint is solving through
--   the defaulting of a type variable.
--   
--   Example:
--   
--   one = show 1 -- We get Wanteds Show a0, Num a0, and default a0 to
--   Integer.
--   
--   Test cases: none (which are really specific to defaulting), but see
--   e.g. tcfail204.
[TcRnWarnDefaulting] :: [Ct] -> Maybe TyVar -> Type -> TcRnMessage

-- | TcRnIncorrectNameSpace is an error that occurs when a <a>Name</a> is
--   used in the incorrect <tt>NameSpace</tt>, e.g. a type constructor or
--   class used in a term, or a term variable used in a type.
--   
--   Example:
--   
--   f x = Int
--   
--   Test cases: T18740a, T20884.
[TcRnIncorrectNameSpace] :: Name -> Bool -> TcRnMessage
[TcRnForeignImportPrimExtNotSet] :: ForeignImport GhcRn -> TcRnMessage
[TcRnForeignImportPrimSafeAnn] :: ForeignImport GhcRn -> TcRnMessage
[TcRnForeignFunctionImportAsValue] :: ForeignImport GhcRn -> TcRnMessage
[TcRnFunPtrImportWithoutAmpersand] :: ForeignImport GhcRn -> TcRnMessage
[TcRnIllegalForeignDeclBackend] :: Either (ForeignExport GhcRn) (ForeignImport GhcRn) -> Backend -> ExpectedBackends -> TcRnMessage
[TcRnUnsupportedCallConv] :: Either (ForeignExport GhcRn) (ForeignImport GhcRn) -> UnsupportedCallConvention -> TcRnMessage
[TcRnIllegalForeignType] :: !Maybe ArgOrResult -> !IllegalForeignTypeReason -> TcRnMessage
[TcRnInvalidCIdentifier] :: !CLabelString -> TcRnMessage
[TcRnExpectedValueId] :: !TcTyThing -> TcRnMessage
[TcRnNotARecordSelector] :: !Name -> TcRnMessage
[TcRnRecSelectorEscapedTyVar] :: !OccName -> TcRnMessage
[TcRnPatSynNotBidirectional] :: !Name -> TcRnMessage
[TcRnSplicePolymorphicLocalVar] :: !Id -> TcRnMessage
[TcRnIllegalDerivingItem] :: !LHsSigType GhcRn -> TcRnMessage
[TcRnUnexpectedAnnotation] :: !HsType GhcRn -> !HsSrcBang -> TcRnMessage
[TcRnIllegalRecordSyntax] :: !HsType GhcRn -> TcRnMessage
[TcRnUnexpectedTypeSplice] :: !HsType GhcRn -> TcRnMessage
[TcRnInvalidVisibleKindArgument] :: !LHsType GhcRn -> !Type -> TcRnMessage
[TcRnTooManyBinders] :: !Kind -> ![LHsTyVarBndr () GhcRn] -> TcRnMessage
[TcRnDifferentNamesForTyVar] :: !Name -> !Name -> TcRnMessage

-- | TcRnDisconnectedTyVar is an error for a data declaration that has a
--   kind signature, where the implicitly-bound type type variables can't
--   be matched up unambiguously with the ones from the signature. See Note
--   [Disconnected type variables] in GHC.Tc.Gen.HsType.
[TcRnDisconnectedTyVar] :: !Name -> TcRnMessage

-- | TcRnInvalidReturnKind is an error for a data declaration that has a
--   kind signature with an invalid result kind.
--   
--   Example(s): data family Foo :: Constraint
--   
--   Test cases: typecheck<i>should_fail</i>T14048b
--   typecheck<i>should_fail</i>UnliftedNewtypesConstraintFamily
--   typecheck<i>should_fail</i>T12729 typecheck<i>should_fail</i>T15883
--   typecheck<i>should_fail</i>T16829a typecheck<i>should_fail</i>T16829b
--   typecheck<i>should_fail</i>UnliftedNewtypesNotEnabled
--   typecheck<i>should_fail</i>tcfail079
[TcRnInvalidReturnKind] :: !DataSort -> !AllowedDataResKind -> !Kind -> !Maybe SuggestUnliftedTypes -> TcRnMessage
[TcRnClassKindNotConstraint] :: !Kind -> TcRnMessage
[TcRnUnpromotableThing] :: !Name -> !PromotionErr -> TcRnMessage
[TcRnMatchesHaveDiffNumArgs] :: !HsMatchContext GhcTc -> !MatchArgBadMatches -> TcRnMessage
[TcRnCannotBindScopedTyVarInPatSig] :: !NonEmpty (Name, TcTyVar) -> TcRnMessage
[TcRnCannotBindTyVarsInPatBind] :: !NonEmpty (Name, TcTyVar) -> TcRnMessage
[TcRnTooManyTyArgsInConPattern] :: !ConLike -> !Int -> !Int -> TcRnMessage
[TcRnMultipleInlinePragmas] :: !Id -> !LocatedA InlinePragma -> !NonEmpty (LocatedA InlinePragma) -> TcRnMessage
[TcRnUnexpectedPragmas] :: !Id -> !NonEmpty (LSig GhcRn) -> TcRnMessage
[TcRnNonOverloadedSpecialisePragma] :: !LIdP GhcRn -> TcRnMessage
[TcRnSpecialiseNotVisible] :: !Name -> TcRnMessage
[TcRnNameByTemplateHaskellQuote] :: !RdrName -> TcRnMessage
[TcRnIllegalBindingOfBuiltIn] :: !OccName -> TcRnMessage
[TcRnPragmaWarning] :: OccName -> WarningTxt GhcRn -> ModuleName -> ModuleName -> TcRnMessage

-- | TcRnIllegalHsigDefaultMethods is an error that occurs when a binding
--   for a class default method is provided in a Backpack signature file.
--   
--   Test case: bkpfail40
[TcRnIllegalHsigDefaultMethods] :: !Name -> NonEmpty (LHsBind GhcRn) -> TcRnMessage

-- | TcRnBadGenericMethod This test ensures that if you provide a "more
--   specific" type signatures for the default method, you must also
--   provide a binding.
--   
--   Example: {-# LANGUAGE DefaultSignatures #-}
--   
--   class C a where meth :: a default meth :: Num a =&gt; a meth = 0
--   
--   Test case:
--   testsuite<i>tests</i>typecheck<i>should_fail</i>MissingDefaultMethodBinding.hs
[TcRnBadGenericMethod] :: !Name -> !Name -> TcRnMessage

-- | TcRnWarningMinimalDefIncomplete is a warning that one must specify
--   which methods must be implemented by all instances.
--   
--   Example: class Cheater a where -- WARNING LINE cheater :: a {-#
--   MINIMAL #-} -- warning!
--   
--   Test case: testsuite<i>tests</i>warnings<i>minimal</i>WarnMinimal.hs:
[TcRnWarningMinimalDefIncomplete] :: ClassMinimalDef -> TcRnMessage

-- | TcRnDefaultMethodForPragmaLacksBinding is an error that occurs when a
--   default method pragma is missing an accompanying binding.
--   
--   Test cases: testsuite<i>tests</i>typecheck<i>should_fail</i>T5084.hs
--   testsuite<i>tests</i>typecheck<i>should_fail</i>T2354.hs
[TcRnDefaultMethodForPragmaLacksBinding] :: Id -> Sig GhcRn -> TcRnMessage

-- | TcRnIgnoreSpecialisePragmaOnDefMethod is a warning that occurs when a
--   specialise pragma is put on a default method.
--   
--   Test cases: none
[TcRnIgnoreSpecialisePragmaOnDefMethod] :: !Name -> TcRnMessage

-- | TcRnBadMethodErr is an error that happens when one attempts to provide
--   a method in a class instance, when the class doesn't have a method by
--   that name.
--   
--   Test case: testsuite<i>tests</i>th/T12387
[TcRnBadMethodErr] :: !Name -> !Name -> TcRnMessage

-- | TcRnNoExplicitAssocTypeOrDefaultDeclaration is an error that occurs
--   when a class instance does not provide an expected associated type or
--   default declaration.
--   
--   Test cases: testsuite<i>tests</i>deriving<i>should_compile</i>T14094
--   testsuite<i>tests</i>indexed-types<i>should_compile</i>Simple2
--   testsuite<i>tests</i>typecheck<i>should_compile</i>tc254
[TcRnNoExplicitAssocTypeOrDefaultDeclaration] :: Name -> TcRnMessage

-- | TcRnIllegalNewtype is an error that occurs when a newtype:
--   
--   <ul>
--   <li>Does not have exactly one field, or</li>
--   <li>is non-linear, or</li>
--   <li>is a GADT, or</li>
--   <li>has a context in its constructor's type, or</li>
--   <li>has existential type variables in its constructor's type, or</li>
--   <li>has strictness annotations.</li>
--   </ul>
--   
--   Test cases: testsuite<i>tests</i>gadt/T14719
--   testsuite<i>tests</i>indexed-types<i>should_fail</i>T14033
--   testsuite<i>tests</i>indexed-types<i>should_fail</i>T2334A
--   testsuite<i>tests</i>linear<i>should_fail</i>LinearGADTNewtype
--   testsuite<i>tests</i>parser<i>should_fail</i>readFail008
--   testsuite<i>tests</i>polykinds/T11459
--   testsuite<i>tests</i>typecheck<i>should_fail</i>T15523
--   testsuite<i>tests</i>typecheck<i>should_fail</i>T15796
--   testsuite<i>tests</i>typecheck<i>should_fail</i>T17955
--   testsuite<i>tests</i>typecheck<i>should_fail</i>T18891a
--   testsuite<i>tests</i>typecheck<i>should_fail</i>T21447
--   testsuite<i>tests</i>typecheck<i>should_fail</i>tcfail156
[TcRnIllegalNewtype] :: DataCon -> Bool -> IllegalNewtypeReason -> TcRnMessage

-- | TcRnIllegalTypeData is an error that occurs when a <tt>type data</tt>
--   declaration occurs without the TypeOperators extension.
--   
--   See Note [Type data declarations]
--   
--   Test case: testsuite<i>tests</i>type-data<i>should_fail</i>TDNoPragma
[TcRnIllegalTypeData] :: TcRnMessage

-- | TcRnTypeDataForbids is an error that occurs when a <tt>type data</tt>
--   declaration contains <tt>data</tt> declaration features that are
--   forbidden in a <tt>type data</tt> declaration.
--   
--   See Note [Type data declarations]
--   
--   Test cases: testsuite<i>tests</i>type-data<i>should_fail</i>TDDeriving
--   testsuite<i>tests</i>type-data<i>should_fail</i>TDRecordsGADT
--   testsuite<i>tests</i>type-data<i>should_fail</i>TDRecordsH98
--   testsuite<i>tests</i>type-data<i>should_fail</i>TDStrictnessGADT
--   testsuite<i>tests</i>type-data<i>should_fail</i>TDStrictnessH98
[TcRnTypeDataForbids] :: !TypeDataForbids -> TcRnMessage

-- | TcRnTypedTHWithPolyType is an error that signifies the illegal use of
--   a polytype in a typed template haskell expression.
--   
--   Example(s): bad :: (forall a. a -&gt; a) -&gt; () bad = $$( [|| _
--   -&gt; () ||] )
--   
--   Test cases: th/T11452
[TcRnTypedTHWithPolyType] :: !TcType -> TcRnMessage

-- | TcRnSpliceThrewException is an error that occurrs when running a
--   template haskell splice throws an exception.
--   
--   Example(s):
--   
--   Test cases: annotations<i>should_fail</i>annfail12
--   perf<i>compiler</i>MultiLayerModulesTH_Make
--   perf<i>compiler</i>MultiLayerModulesTH_OneShot th/T10796b th/T19470
--   th/T19709d th/T5358 th/T5976 th/T7276a th/T8987 th/TH_exn1 th/TH_exn2
--   th/TH_runIO
[TcRnSpliceThrewException] :: !SplicePhase -> !SomeException -> !String -> !LHsExpr GhcTc -> !Bool -> TcRnMessage

-- | TcRnInvalidTopDecl is a template haskell error occurring when one of
--   the <tt>Dec</tt>s passed to <tt>addTopDecls</tt> is not a function,
--   value, annotation, or foreign import declaration.
--   
--   Example(s):
--   
--   Test cases:
[TcRnInvalidTopDecl] :: !HsDecl GhcPs -> TcRnMessage

-- | TcRnNonExactName is a template haskell error for when a declaration
--   being added is bound to a name that is not fully known.
--   
--   Example(s):
--   
--   Test cases:
[TcRnNonExactName] :: !RdrName -> TcRnMessage

-- | TcRnAddInvalidCorePlugin is a template haskell error indicating that a
--   core plugin being added has an invalid module due to being in the
--   current package.
--   
--   Example(s):
--   
--   Test cases:
[TcRnAddInvalidCorePlugin] :: !String -> TcRnMessage

-- | TcRnAddDocToNonLocalDefn is a template haskell error for documentation
--   being added to a definition which is not in the current module.
--   
--   Example(s):
--   
--   Test cases: showIface<i>should_fail</i>THPutDocExternal
[TcRnAddDocToNonLocalDefn] :: !DocLoc -> TcRnMessage

-- | TcRnFailedToLookupThInstName is a template haskell error that occurrs
--   when looking up an instance fails.
--   
--   Example(s):
--   
--   Test cases: showIface<i>should_fail</i>THPutDocNonExistent
[TcRnFailedToLookupThInstName] :: !Type -> !LookupTHInstNameErrReason -> TcRnMessage

-- | TcRnCannotReifyInstance is a template haskell error for when an
--   instance being reified via <tt>reifyInstances</tt> is not a class
--   constraint or type family application.
--   
--   Example(s):
--   
--   Test cases:
[TcRnCannotReifyInstance] :: !Type -> TcRnMessage

-- | TcRnCannotReifyOutOfScopeThing is a template haskell error indicating
--   that the given name is not in scope and therefore cannot be reified.
--   
--   Example(s):
--   
--   Test cases: th/T16976f
[TcRnCannotReifyOutOfScopeThing] :: !Name -> TcRnMessage

-- | TcRnCannotReifyThingNotInTypeEnv is a template haskell error occurring
--   when the given name is not in the type environment and therefore
--   cannot be reified.
--   
--   Example(s):
--   
--   Test cases:
[TcRnCannotReifyThingNotInTypeEnv] :: !Name -> TcRnMessage

-- | TcRnNoRolesAssociatedWithName is a template haskell error for when the
--   user tries to reify the roles of a given name but it is not something
--   that has roles associated with it.
--   
--   Example(s):
--   
--   Test cases:
[TcRnNoRolesAssociatedWithThing] :: !TcTyThing -> TcRnMessage

-- | TcRnCannotRepresentThing is a template haskell error indicating that a
--   type cannot be reified because it does not have a representation in
--   template haskell.
--   
--   Example(s):
--   
--   Test cases:
[TcRnCannotRepresentType] :: !UnrepresentableTypeDescr -> !Type -> TcRnMessage

-- | TcRnRunSpliceFailure is an error indicating that a template haskell
--   splice failed to be converted into a valid expression.
--   
--   Example(s):
--   
--   Test cases: th/T10828a th/T10828b th/T12478_4 th/T15270A th/T15270B
--   th/T16895a th/T16895b th/T16895c th/T16895d th/T16895e th/T17379a
--   th/T17379b th/T18740d th/T2597b th/T2674 th/T3395 th/T7484 th/T7667a
--   th/TH_implicitParamsErr1 th/TH_implicitParamsErr2
--   th/TH_implicitParamsErr3 th/TH_invalid_add_top_decl
[TcRnRunSpliceFailure] :: !Maybe String -> !RunSpliceFailReason -> TcRnMessage

-- | TcRnUserErrReported is an error or warning thrown using
--   <tt>qReport</tt> from the <tt>Quasi</tt> instance of <tt>TcM</tt>.
--   
--   Example(s):
--   
--   Test cases:
[TcRnReportCustomQuasiError] :: !Bool -> !String -> TcRnMessage

-- | TcRnInterfaceLookupError is an error resulting from looking up a name
--   in an interface file.
--   
--   Example(s):
--   
--   Test cases:
[TcRnInterfaceLookupError] :: !Name -> !SDoc -> TcRnMessage

-- | TcRnUnsatisfiedMinimalDef is a warning that occurs when a class
--   instance is missing methods that are required by the minimal
--   definition.
--   
--   Example: class C a where foo :: a -&gt; a instance C () -- | foo needs
--   to be defined here
--   
--   Test cases:
--   testsuite<i>tests</i>typecheck<i>prog001</i>typecheck.prog001
--   testsuite<i>tests</i>typecheck<i>should_compile</i>tc126
--   testsuite<i>tests</i>typecheck<i>should_compile</i>T7903
--   testsuite<i>tests</i>typecheck<i>should_compile</i>tc116
--   testsuite<i>tests</i>typecheck<i>should_compile</i>tc175
--   testsuite<i>tests</i>typecheck<i>should_compile</i>HasKey
--   testsuite<i>tests</i>typecheck<i>should_compile</i>tc125
--   testsuite<i>tests</i>typecheck<i>should_compile</i>tc078
--   testsuite<i>tests</i>typecheck<i>should_compile</i>tc161
--   testsuite<i>tests</i>typecheck<i>should_fail</i>T5051
--   testsuite<i>tests</i>typecheck<i>should_compile</i>T21583
--   testsuite<i>tests</i>backpack<i>should_compile</i>bkp47
--   testsuite<i>tests</i>backpack<i>should_fail</i>bkpfail25
--   testsuite<i>tests</i>parser<i>should_compile</i>T2245
--   testsuite<i>tests</i>parser<i>should_compile</i>read014
--   testsuite<i>tests</i>indexed-types<i>should_compile</i>Class3
--   testsuite<i>tests</i>indexed-types<i>should_compile</i>Simple2
--   testsuite<i>tests</i>indexed-types<i>should_fail</i>T7862
--   testsuite<i>tests</i>deriving<i>should_compile</i>deriving-1935
--   testsuite<i>tests</i>deriving<i>should_compile</i>T9968a
--   testsuite<i>tests</i>deriving<i>should_compile</i>drv003
--   testsuite<i>tests</i>deriving<i>should_compile</i>T4966
--   testsuite<i>tests</i>deriving<i>should_compile</i>T14094
--   testsuite<i>tests</i>perf<i>compiler</i>T15304
--   testsuite<i>tests</i>warnings<i>minimal</i>WarnMinimal
--   testsuite<i>tests</i>simplCore<i>should_compile</i>simpl020
--   testsuite<i>tests</i>deSugar<i>should_compile</i>T14546d
--   testsuite<i>tests</i>ghci<i>scripts</i>T5820
--   testsuite<i>tests</i>ghci<i>scripts</i>ghci019
[TcRnUnsatisfiedMinimalDef] :: ClassMinimalDef -> TcRnMessage

-- | <a>TcRnMisplacedInstSig</a> is an error that happens when a method in
--   a class instance is given a type signature, but the user has not
--   enabled the <tt>InstanceSigs</tt> extension.
--   
--   Test case: testsuite<i>tests</i>module/mod45
[TcRnMisplacedInstSig] :: Name -> LHsSigType GhcRn -> TcRnMessage

-- | <a>TcRnBadBootFamInstDecl</a> is an error that is triggered by a type
--   family instance being declared in an hs-boot file.
--   
--   Test case:
--   testsuite<i>tests</i>indexed-types<i>should_fail</i>HsBootFam
[TcRnBadBootFamInstDecl] :: TcRnMessage

-- | <a>TcRnIllegalFamilyInstance</a> is an error that occurs when an
--   associated type or data family is given a top-level instance.
--   
--   Test case: testsuite<i>tests</i>indexed-types<i>should_fail</i>T3092
[TcRnIllegalFamilyInstance] :: TyCon -> TcRnMessage

-- | <a>TcRnMissingClassAssoc</a> is an error that occurs when a class
--   instance for a class with an associated type or data family is missing
--   a corresponding family instance declaration.
--   
--   Test case:
--   testsuite<i>tests</i>indexed-types<i>should_fail</i>SimpleFail7
[TcRnMissingClassAssoc] :: TyCon -> TcRnMessage

-- | <a>TcRnBadFamInstDecl</a> is an error that is triggered by a type or
--   data family instance without the <tt>TypeFamilies</tt> extension.
--   
--   Test case:
--   testsuite<i>tests</i>indexed-types<i>should_fail</i>BadFamInstDecl
[TcRnBadFamInstDecl] :: TyCon -> TcRnMessage

-- | <a>TcRnNotOpenFamily</a> is an error that is triggered by attempting
--   to give a top-level (open) type family instance for a closed type
--   family.
--   
--   Test cases:
--   testsuite<i>tests</i>indexed-types<i>should_fail</i>Overlap7
--   testsuite<i>tests</i>indexed-types<i>should_fail</i>Overlap3
[TcRnNotOpenFamily] :: TyCon -> TcRnMessage

-- | TcRnNoRebindableSyntaxRecordDot is an error triggered by an overloaded
--   record update without RebindableSyntax enabled.
--   
--   Example(s):
--   
--   Test cases: parser<i>should_fail</i>RecordDotSyntaxFail5
[TcRnNoRebindableSyntaxRecordDot] :: TcRnMessage

-- | TcRnNoFieldPunsRecordDot is an error triggered by the use of record
--   field puns in an overloaded record update without enabling
--   NamedFieldPuns.
--   
--   Example(s): print $ a{ foo.bar.baz.quux }
--   
--   Test cases: parser<i>should_fail</i>RecordDotSyntaxFail12
[TcRnNoFieldPunsRecordDot] :: TcRnMessage

-- | TcRnIllegalStaticExpression is an error thrown when user creates a
--   static pointer via TemplateHaskell without enabling the StaticPointers
--   extension.
--   
--   Example(s):
--   
--   Test cases: th/T14204
[TcRnIllegalStaticExpression] :: HsExpr GhcPs -> TcRnMessage

-- | TcRnIllegalStaticFormInSplice is an error when a user attempts to
--   define a static pointer in a Template Haskell splice.
--   
--   Example(s):
--   
--   Test cases: th/TH_StaticPointers02
[TcRnIllegalStaticFormInSplice] :: HsExpr GhcPs -> TcRnMessage

-- | TcRnListComprehensionDuplicateBinding is an error triggered by
--   duplicate let-bindings in a list comprehension.
--   
--   Example(s): [ () | let a = 13 | let a = 17 ]
--   
--   Test cases: typecheck<i>should_fail</i>tcfail092
[TcRnListComprehensionDuplicateBinding] :: Name -> TcRnMessage

-- | TcRnEmptyStmtsGroup is an error triggered by an empty list of
--   statements in a statement block. For more information, see
--   <a>EmptyStatementGroupErrReason</a>
--   
--   Example(s):
--   
--   <ul>
--   <li><i>() | then ()</i></li>
--   </ul>
--   
--   do
--   
--   proc () -&gt; do
--   
--   Test cases: rename<i>should_fail</i>RnEmptyStatementGroup1
[TcRnEmptyStmtsGroup] :: EmptyStatementGroupErrReason -> TcRnMessage

-- | TcRnLastStmtNotExpr is an error caused by the last statement in a
--   statement block not being an expression.
--   
--   Example(s):
--   
--   do x &lt;- pure ()
--   
--   do let x = 5
--   
--   Test cases: rename<i>should_fail</i>T6060
--   parser<i>should_fail</i>T3811g parser<i>should_fail</i>readFail028
[TcRnLastStmtNotExpr] :: HsStmtContext GhcRn -> UnexpectedStatement -> TcRnMessage

-- | TcRnUnexpectedStatementInContext is an error when a statement appears
--   in an unexpected context (e.g. an arrow statement appears in a list
--   comprehension).
--   
--   Example(s):
--   
--   Test cases: parser<i>should_fail</i>readFail042
--   parser<i>should_fail</i>readFail038
--   parser<i>should_fail</i>readFail043
[TcRnUnexpectedStatementInContext] :: HsStmtContext GhcRn -> UnexpectedStatement -> Maybe Extension -> TcRnMessage

-- | TcRnIllegalTupleSection is an error triggered by usage of a tuple
--   section without enabling the TupleSections extension.
--   
--   Example(s): (5,)
--   
--   Test cases: rename<i>should_fail</i>rnfail056
[TcRnIllegalTupleSection] :: TcRnMessage

-- | TcRnIllegalImplicitParameterBindings is an error triggered by binding
--   an implicit parameter in an mdo block.
--   
--   Example(s): mdo { let { ?x = 5 }; () }
--   
--   Test cases: rename<i>should_fail</i>RnImplicitBindInMdoNotation
[TcRnIllegalImplicitParameterBindings] :: Either (HsLocalBindsLR GhcPs GhcPs) (HsLocalBindsLR GhcRn GhcPs) -> TcRnMessage

-- | TcRnSectionWithoutParentheses is an error triggered by attempting to
--   use an operator section without parentheses.
--   
--   Example(s): (<a>head</a> x, ())
--   
--   Test cases: rename<i>should_fail</i>T2490
--   rename<i>should_fail</i>T5657
[TcRnSectionWithoutParentheses] :: HsExpr GhcPs -> TcRnMessage

-- | TcRnLoopySuperclassSolve is a warning, controlled by
--   <tt>-Wloopy-superclass-solve</tt>, that is triggered when GHC solves a
--   constraint in a possibly-loopy way, violating the class instance
--   termination rules described in the section "Undecidable instances and
--   loopy superclasses" of the user's guide.
--   
--   Example:
--   
--   class Foo f class Foo f =&gt; Bar f g instance Bar f f =&gt; Bar f (h
--   k)
--   
--   Test cases: T20666, T20666{a,b}, T22891, T22912.
[TcRnLoopySuperclassSolve] :: CtLoc -> PredType -> TcRnMessage
[TcRnCannotDefaultConcrete] :: !FixedRuntimeRepOrigin -> TcRnMessage
mkTcRnUnknownMessage :: (Diagnostic a, Typeable a, DiagnosticOpts a ~ NoDiagnosticOpts) => a -> TcRnMessage

-- | <a>TcRnMessageDetailed</a> is an "internal" type (used only inside
--   <a>Monad</a> that wraps a <a>TcRnMessage</a> while also providing any
--   extra info needed to correctly pretty-print this diagnostic later on.
data TcRnMessageDetailed
TcRnMessageDetailed :: !ErrInfo -> !TcRnMessage -> TcRnMessageDetailed

-- | Things forbidden in <tt>type data</tt> declarations. See Note [Type
--   data declarations]
data TypeDataForbids
TypeDataForbidsDatatypeContexts :: TypeDataForbids
TypeDataForbidsLabelledFields :: TypeDataForbids
TypeDataForbidsStrictnessAnnotations :: TypeDataForbids
TypeDataForbidsDerivingClauses :: TypeDataForbids
data ErrInfo
ErrInfo :: !SDoc -> !SDoc -> ErrInfo

-- | Extra context associated to the error.
[errInfoContext] :: ErrInfo -> !SDoc

-- | Extra supplementary info associated to the error.
[errInfoSupplementary] :: ErrInfo -> !SDoc

-- | In what context did we require a type to have a fixed runtime
--   representation?
--   
--   Used by <a>checkTypeHasFixedRuntimeRep</a> for throwing representation
--   polymorphism errors when validity checking.
--   
--   See Note [Representation polymorphism checking] in
--   GHC.Tc.Utils.Concrete
data FixedRuntimeRepProvenance

-- | Data constructor fields must have a fixed runtime representation.
--   
--   Tests: T11734, T18534.
FixedRuntimeRepDataConField :: FixedRuntimeRepProvenance

-- | Pattern synonym signature arguments must have a fixed runtime
--   representation.
--   
--   Test: RepPolyPatSynArg.
FixedRuntimeRepPatSynSigArg :: FixedRuntimeRepProvenance

-- | Pattern synonym signature scrutinee must have a fixed runtime
--   representation.
--   
--   Test: RepPolyPatSynRes.
FixedRuntimeRepPatSynSigRes :: FixedRuntimeRepProvenance
pprFixedRuntimeRepProvenance :: FixedRuntimeRepProvenance -> SDoc

-- | Where a shadowed name comes from
data ShadowedNameProvenance

-- | The shadowed name is local to the module
ShadowedNameProvenanceLocal :: !SrcLoc -> ShadowedNameProvenance

-- | The shadowed name is global, typically imported from elsewhere.
ShadowedNameProvenanceGlobal :: [GlobalRdrElt] -> ShadowedNameProvenance

-- | Which parts of a record field are affected by a particular error or
--   warning.
data RecordFieldPart
RecordFieldConstructor :: !Name -> RecordFieldPart
RecordFieldPattern :: !Name -> RecordFieldPart
RecordFieldUpdate :: RecordFieldPart

-- | Why the particular illegal newtype error arose together with more
--   information, if any.
data IllegalNewtypeReason
DoesNotHaveSingleField :: !Int -> IllegalNewtypeReason
IsNonLinear :: IllegalNewtypeReason
IsGADT :: IllegalNewtypeReason
HasConstructorContext :: IllegalNewtypeReason
HasExistentialTyVar :: IllegalNewtypeReason
HasStrictnessAnnotation :: IllegalNewtypeReason

-- | Why the particular injectivity error arose together with more
--   information, if any.
data InjectivityErrReason
InjErrRhsBareTyVar :: [Type] -> InjectivityErrReason
InjErrRhsCannotBeATypeFam :: InjectivityErrReason
InjErrRhsOverlap :: InjectivityErrReason
InjErrCannotInferFromRhs :: !TyVarSet -> !HasKinds -> !SuggestUndecidableInstances -> InjectivityErrReason
data HasKinds
YesHasKinds :: HasKinds
NoHasKinds :: HasKinds
hasKinds :: Bool -> HasKinds
data SuggestUndecidableInstances
YesSuggestUndecidableInstaces :: SuggestUndecidableInstances
NoSuggestUndecidableInstaces :: SuggestUndecidableInstances
suggestUndecidableInstances :: Bool -> SuggestUndecidableInstances
data SuggestUnliftedTypes
SuggestUnliftedNewtypes :: SuggestUnliftedTypes
SuggestUnliftedDatatypes :: SuggestUnliftedTypes

-- | A description of whether something is a
--   
--   <ul>
--   <li><tt>data</tt> or <tt>newtype</tt> (<a>DataDeclSort</a>)</li>
--   <li><tt>data instance</tt> or <tt>newtype instance</tt>
--   (<a>DataInstanceSort</a>)</li>
--   <li><tt>data family</tt> (<a>DataFamilySort</a>)</li>
--   </ul>
--   
--   At present, this data type is only consumed by
--   <tt>checkDataKindSig</tt>.
data DataSort
DataDeclSort :: NewOrData -> DataSort
DataInstanceSort :: NewOrData -> DataSort
DataFamilySort :: DataSort
ppDataSort :: DataSort -> SDoc

-- | Helper type used in <tt>checkDataKindSig</tt>.
--   
--   Superficially similar to <tt>ContextKind</tt>, but it lacks
--   <tt>AnyKind</tt> and <a>AnyBoxedKind</a>, and instead of
--   <tt><tt>TheKind</tt> liftedTypeKind</tt> provides <a>LiftedKind</a>,
--   which is much simpler to match on and handle in
--   <tt>isAllowedDataResKind</tt>.
data AllowedDataResKind
AnyTYPEKind :: AllowedDataResKind
AnyBoxedKind :: AllowedDataResKind
LiftedKind :: AllowedDataResKind

-- | A data type to describe why a variable is not closed. See Note
--   [Not-closed error messages] in GHC.Tc.Gen.Expr
data NotClosedReason
NotLetBoundReason :: NotClosedReason
NotTypeClosed :: VarSet -> NotClosedReason
NotClosed :: Name -> NotClosedReason -> NotClosedReason
data SuggestPartialTypeSignatures
YesSuggestPartialTypeSignatures :: SuggestPartialTypeSignatures
NoSuggestPartialTypeSignatures :: SuggestPartialTypeSignatures
suggestPartialTypeSignatures :: Bool -> SuggestPartialTypeSignatures

-- | Why a particular typeclass instance couldn't be derived.
data DeriveInstanceErrReason

-- | The typeclass instance is not well-kinded.
DerivErrNotWellKinded :: !TyCon -> !Kind -> !Int -> DeriveInstanceErrReason
DerivErrSafeHaskellGenericInst :: DeriveInstanceErrReason
DerivErrDerivingViaWrongKind :: !Kind -> !Type -> !Kind -> DeriveInstanceErrReason

-- | The instance type | We cannot derive instances in boot files
DerivErrNoEtaReduce :: !Type -> DeriveInstanceErrReason
DerivErrBootFileFound :: DeriveInstanceErrReason
DerivErrDataConsNotAllInScope :: !TyCon -> DeriveInstanceErrReason

-- | We cannot use GND on non-newtype types
DerivErrGNDUsedOnData :: DeriveInstanceErrReason

-- | We cannot derive instances of nullary classes
DerivErrNullaryClasses :: DeriveInstanceErrReason

-- | Last arg must be newtype or data application
DerivErrLastArgMustBeApp :: DeriveInstanceErrReason
DerivErrNoFamilyInstance :: !TyCon -> [Type] -> DeriveInstanceErrReason
DerivErrNotStockDeriveable :: !DeriveAnyClassEnabled -> DeriveInstanceErrReason
DerivErrHasAssociatedDatatypes :: !HasAssociatedDataFamInsts -> !AssociatedTyLastVarInKind -> !AssociatedTyNotParamOverLastTyVar -> DeriveInstanceErrReason
DerivErrNewtypeNonDeriveableClass :: DeriveInstanceErrReason
DerivErrCannotEtaReduceEnough :: !Bool -> DeriveInstanceErrReason
DerivErrOnlyAnyClassDeriveable :: !TyCon -> !DeriveAnyClassEnabled -> DeriveInstanceErrReason
DerivErrNotDeriveable :: !DeriveAnyClassEnabled -> DeriveInstanceErrReason

-- | The given <a>PredType</a> is not a class.
DerivErrNotAClass :: !PredType -> DeriveInstanceErrReason

-- | The given (representation of the) <a>TyCon</a> has no data
--   constructors.
DerivErrNoConstructors :: !TyCon -> DeriveInstanceErrReason
DerivErrLangExtRequired :: !Extension -> DeriveInstanceErrReason

-- | GHC simply doesn't how to how derive the input <a>Class</a> for the
--   given <a>Type</a>.
DerivErrDunnoHowToDeriveForType :: !Type -> DeriveInstanceErrReason

-- | The given <a>TyCon</a> must be an enumeration. See Note [Enumeration
--   types] in GHC.Core.TyCon
DerivErrMustBeEnumType :: !TyCon -> DeriveInstanceErrReason

-- | The given <a>TyCon</a> must have <i>precisely</i> one constructor.
DerivErrMustHaveExactlyOneConstructor :: !TyCon -> DeriveInstanceErrReason

-- | The given data type must have some parameters.
DerivErrMustHaveSomeParameters :: !TyCon -> DeriveInstanceErrReason

-- | The given data type must not have a class context.
DerivErrMustNotHaveClassContext :: !TyCon -> !ThetaType -> DeriveInstanceErrReason

-- | We couldn't derive an instance for a particular data constructor for a
--   variety of reasons.
DerivErrBadConstructor :: !Maybe HasWildcard -> [DeriveInstanceBadConstructor] -> DeriveInstanceErrReason

-- | We couldn't derive a <a>Generic</a> instance for the given type for a
--   variety of reasons
DerivErrGenerics :: [DeriveGenericsErrReason] -> DeriveInstanceErrReason

-- | We couldn't derive an instance either because the type was not an enum
--   type or because it did have more than one constructor.
DerivErrEnumOrProduct :: !DeriveInstanceErrReason -> !DeriveInstanceErrReason -> DeriveInstanceErrReason
data UsingGeneralizedNewtypeDeriving
YesGeneralizedNewtypeDeriving :: UsingGeneralizedNewtypeDeriving
NoGeneralizedNewtypeDeriving :: UsingGeneralizedNewtypeDeriving
usingGeneralizedNewtypeDeriving :: Bool -> UsingGeneralizedNewtypeDeriving
data DeriveAnyClassEnabled
YesDeriveAnyClassEnabled :: DeriveAnyClassEnabled
NoDeriveAnyClassEnabled :: DeriveAnyClassEnabled
deriveAnyClassEnabled :: Bool -> DeriveAnyClassEnabled
data DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> must be truly polymorphic in the last
--   argument of the data type.
DerivErrBadConExistential :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> must not use the type variable in a function
--   argument"
DerivErrBadConCovariant :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> must not contain function types
DerivErrBadConFunTypes :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> must use the type variable only as the last
--   argument of a data type
DerivErrBadConWrongArg :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> is a GADT so we cannot directly derive an
--   istance for it.
DerivErrBadConIsGADT :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> has existentials type vars in its type.
DerivErrBadConHasExistentials :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> has constraints in its type.
DerivErrBadConHasConstraints :: !DataCon -> DeriveInstanceBadConstructor

-- | The given <a>DataCon</a> has a higher-rank type.
DerivErrBadConHasHigherRankType :: !DataCon -> DeriveInstanceBadConstructor
data HasWildcard
YesHasWildcard :: HasWildcard
NoHasWildcard :: HasWildcard
hasWildcard :: Bool -> HasWildcard

-- | A context in which we don't allow anonymous wildcards.
data BadAnonWildcardContext
WildcardNotLastInConstraint :: BadAnonWildcardContext
ExtraConstraintWildcardNotAllowed :: SoleExtraConstraintWildcardAllowed -> BadAnonWildcardContext
WildcardsNotAllowedAtAll :: BadAnonWildcardContext

-- | Whether a sole extra-constraint wildcard is allowed, e.g. <tt>_ =&gt;
--   ..</tt> as opposed to <tt>( .., _ ) =&gt; ..</tt>.
data SoleExtraConstraintWildcardAllowed
SoleExtraConstraintWildcardNotAllowed :: SoleExtraConstraintWildcardAllowed
SoleExtraConstraintWildcardAllowed :: SoleExtraConstraintWildcardAllowed
data DeriveGenericsErrReason

-- | The type must not have some datatype context.
DerivErrGenericsMustNotHaveDatatypeContext :: !TyCon -> DeriveGenericsErrReason

-- | The data constructor must not have exotic unlifted or polymorphic
--   arguments.
DerivErrGenericsMustNotHaveExoticArgs :: !DataCon -> DeriveGenericsErrReason

-- | The data constructor must be a vanilla constructor.
DerivErrGenericsMustBeVanillaDataCon :: !DataCon -> DeriveGenericsErrReason

-- | The type must have some type parameters. check (d) from Note
--   [Requirements for deriving Generic and Rep] in GHC.Tc.Deriv.Generics.
DerivErrGenericsMustHaveSomeTypeParams :: !TyCon -> DeriveGenericsErrReason

-- | The data constructor must not have existential arguments.
DerivErrGenericsMustNotHaveExistentials :: !DataCon -> DeriveGenericsErrReason

-- | The derivation applies a type to an argument involving the last
--   parameter but the applied type is not of kind * -&gt; *.
DerivErrGenericsWrongArgKind :: !DataCon -> DeriveGenericsErrReason

-- | A type representing whether or not the input type has associated data
--   family instances.
data HasAssociatedDataFamInsts
YesHasAdfs :: HasAssociatedDataFamInsts
NoHasAdfs :: HasAssociatedDataFamInsts
hasAssociatedDataFamInsts :: Bool -> HasAssociatedDataFamInsts

-- | If <a>YesAssocTyLastVarInKind</a>, the associated type of a typeclass
--   contains the last type variable of the class in a kind, which is not
--   (yet) allowed by GHC.
data AssociatedTyLastVarInKind

-- | The associated type family of the class
YesAssocTyLastVarInKind :: !TyCon -> AssociatedTyLastVarInKind
NoAssocTyLastVarInKind :: AssociatedTyLastVarInKind
associatedTyLastVarInKind :: Maybe TyCon -> AssociatedTyLastVarInKind

-- | If <a>NoAssociatedTyNotParamOverLastTyVar</a>, the associated type of
--   a typeclass is not parameterized over the last type variable of the
--   class
data AssociatedTyNotParamOverLastTyVar

-- | The associated type family of the class
YesAssociatedTyNotParamOverLastTyVar :: !TyCon -> AssociatedTyNotParamOverLastTyVar
NoAssociatedTyNotParamOverLastTyVar :: AssociatedTyNotParamOverLastTyVar
associatedTyNotParamOverLastTyVar :: Maybe TyCon -> AssociatedTyNotParamOverLastTyVar

-- | What kind of thing is missing a type signature?
--   
--   Used for reporting <tt>"missing signature"</tt> warnings, see
--   <tt>tcRnMissingSignature</tt>.
data MissingSignature
MissingTopLevelBindingSig :: Name -> Type -> MissingSignature
MissingPatSynSig :: PatSyn -> MissingSignature

-- | whether -XCUSKs is enabled
MissingTyConKindSig :: TyCon -> Bool -> MissingSignature

-- | Is the object we are dealing with exported or not?
--   
--   Used for reporting <tt>"missing signature"</tt> warnings, see
--   <a>TcRnMissingSignature</a>.
data Exported
IsNotExported :: Exported
IsExported :: Exported
data HsDocContext
TypeSigCtx :: SDoc -> HsDocContext
StandaloneKindSigCtx :: SDoc -> HsDocContext
PatCtx :: HsDocContext
SpecInstSigCtx :: HsDocContext
DefaultDeclCtx :: HsDocContext
ForeignDeclCtx :: LocatedN RdrName -> HsDocContext
DerivDeclCtx :: HsDocContext
RuleCtx :: FastString -> HsDocContext
TyDataCtx :: LocatedN RdrName -> HsDocContext
TySynCtx :: LocatedN RdrName -> HsDocContext
TyFamilyCtx :: LocatedN RdrName -> HsDocContext
FamPatCtx :: LocatedN RdrName -> HsDocContext
ConDeclCtx :: [LocatedN Name] -> HsDocContext
ClassDeclCtx :: LocatedN RdrName -> HsDocContext
ExprWithTySigCtx :: HsDocContext
TypBrCtx :: HsDocContext
HsTypeCtx :: HsDocContext
HsTypePatCtx :: HsDocContext
GHCiCtx :: HsDocContext
SpliceTypeCtx :: LHsType GhcPs -> HsDocContext
ClassInstanceCtx :: HsDocContext
GenericCtx :: SDoc -> HsDocContext

-- | Stores the information to be reported in a representation-polymorphism
--   error message.
data FixedRuntimeRepErrorInfo
FRR_Info :: FixedRuntimeRepOrigin -> Maybe (TcTyVar, TcType) -> FixedRuntimeRepErrorInfo

-- | What is the original type we checked for representation-polymorphism,
--   and what specific check did we perform?
[frr_info_origin] :: FixedRuntimeRepErrorInfo -> FixedRuntimeRepOrigin

-- | Which non-concrete type did we try to unify this concrete type
--   variable with?
[frr_info_not_concrete] :: FixedRuntimeRepErrorInfo -> Maybe (TcTyVar, TcType)

-- | A predicate with its arising location; used to encapsulate a
--   constraint that will give rise to a diagnostic.
data ErrorItem
EI :: PredType -> Maybe TcEvDest -> CtFlavour -> CtLoc -> Maybe CtIrredReason -> Bool -> ErrorItem
[ei_pred] :: ErrorItem -> PredType

-- | for Wanteds, where to put the evidence for Givens, Nothing
[ei_evdest] :: ErrorItem -> Maybe TcEvDest
[ei_flavour] :: ErrorItem -> CtFlavour
[ei_loc] :: ErrorItem -> CtLoc
[ei_m_reason] :: ErrorItem -> Maybe CtIrredReason
[ei_suppress] :: ErrorItem -> Bool
errorItemOrigin :: ErrorItem -> CtOrigin
errorItemEqRel :: ErrorItem -> EqRel
errorItemPred :: ErrorItem -> PredType
errorItemCtLoc :: ErrorItem -> CtLoc

-- | A collection of main error messages and supplementary information.
--   
--   In practice, we will: - display the important messages first, - then
--   the error context (e.g. by way of a call to <a>mkErrorReport</a>), -
--   then the supplementary information (e.g. relevant bindings, valid hole
--   fits), - then the hints ("Possible fix: ...").
--   
--   So this is mostly just a way of making sure that the error context
--   appears early on rather than at the end of the message.
--   
--   See Note [Error report] for details.
data SolverReport
SolverReport :: SolverReportWithCtxt -> [SolverReportSupplementary] -> [GhcHint] -> SolverReport
[sr_important_msg] :: SolverReport -> SolverReportWithCtxt
[sr_supplementary] :: SolverReport -> [SolverReportSupplementary]
[sr_hints] :: SolverReport -> [GhcHint]

-- | Additional information to print in a <a>SolverReport</a>, after the
--   important messages and after the error context.
--   
--   See Note [Error report].
data SolverReportSupplementary
SupplementaryBindings :: RelevantBindings -> SolverReportSupplementary
SupplementaryHoleFits :: ValidHoleFits -> SolverReportSupplementary
SupplementaryCts :: [(PredType, RealSrcSpan)] -> SolverReportSupplementary

-- | A <a>TcSolverReportMsg</a>, together with context (e.g. enclosing
--   implication constraints) that are needed in order to report it.
data SolverReportWithCtxt
SolverReportWithCtxt :: SolverReportErrCtxt -> TcSolverReportMsg -> SolverReportWithCtxt

-- | Context for what we wish to report. This can change as we enter
--   implications, so is stored alongside the content.
[reportContext] :: SolverReportWithCtxt -> SolverReportErrCtxt

-- | The content of the message to report.
[reportContent] :: SolverReportWithCtxt -> TcSolverReportMsg

-- | Context needed when reporting a <a>TcSolverReportMsg</a>, such as the
--   enclosing implication constraints or whether we are deferring type
--   errors.
data SolverReportErrCtxt
CEC :: [Implication] -> TidyEnv -> EvBindsVar -> DiagnosticReason -> DiagnosticReason -> DiagnosticReason -> DiagnosticReason -> Bool -> Bool -> Bool -> SolverReportErrCtxt

-- | Enclosing implications (innermost first) ic_skols and givens are
--   tidied, rest are not
[cec_encl] :: SolverReportErrCtxt -> [Implication]
[cec_tidy] :: SolverReportErrCtxt -> TidyEnv

-- | We make some errors (depending on cec_defer) into warnings, and emit
--   evidence bindings into <a>cec_binds</a> for unsolved constraints
[cec_binds] :: SolverReportErrCtxt -> EvBindsVar

-- | Whether to defer type errors until runtime
[cec_defer_type_errors] :: SolverReportErrCtxt -> DiagnosticReason

-- | Reason for reporting holes in expressions.
[cec_expr_holes] :: SolverReportErrCtxt -> DiagnosticReason

-- | Reason for reporting holes in types.
[cec_type_holes] :: SolverReportErrCtxt -> DiagnosticReason

-- | Reason for reporting out of scope holes.
[cec_out_of_scope_holes] :: SolverReportErrCtxt -> DiagnosticReason

-- | True <a>=</a> -Wredundant-constraints
[cec_warn_redundant] :: SolverReportErrCtxt -> Bool

-- | True <a>=</a> -fprint-expanded-synonyms
[cec_expand_syns] :: SolverReportErrCtxt -> Bool

-- | True <a>=</a> More important errors have occurred, so create bindings
--   if need be, but don't issue any more errors/warnings See Note
--   [Suppressing error messages]
[cec_suppress] :: SolverReportErrCtxt -> Bool
getUserGivens :: SolverReportErrCtxt -> [UserGiven]
discardProvCtxtGivens :: CtOrigin -> [UserGiven] -> [UserGiven]

-- | An error reported after constraint solving. This is usually, some sort
--   of unsolved constraint error, but we try to be specific about the
--   precise problem we encountered.
data TcSolverReportMsg

-- | Quantified variables appear out of dependency order.
--   
--   Example:
--   
--   forall (a :: k) k. ...
--   
--   Test cases: BadTelescope2, T16418, T16247, T16726, T18451.
BadTelescope :: TyVarBndrs -> [TyCoVar] -> TcSolverReportMsg

-- | We came across a custom type error and we have decided to report it.
--   
--   Example:
--   
--   type family F a where F a = TypeError (Text "error")
--   
--   err :: F () err = ()
--   
--   Test cases: CustomTypeErrors0{1,2,3,4,5}, T12104.
UserTypeError :: Type -> TcSolverReportMsg

-- | We want to report an out of scope variable or a typed hole. See
--   <a>HoleError</a>.
ReportHoleError :: Hole -> HoleError -> TcSolverReportMsg

-- | Trying to unify an untouchable variable, e.g. a variable from an outer
--   scope.
--   
--   Test case: Simple14
UntouchableVariable :: TyVar -> Implication -> TcSolverReportMsg
[untouchableTyVar] :: TcSolverReportMsg -> TyVar
[untouchableTyVarImplication] :: TcSolverReportMsg -> Implication

-- | Cannot unify a variable, because of a type mismatch.
CannotUnifyVariable :: MismatchMsg -> CannotUnifyVariableReason -> TcSolverReportMsg
[mismatchMsg] :: TcSolverReportMsg -> MismatchMsg
[cannotUnifyReason] :: TcSolverReportMsg -> CannotUnifyVariableReason

-- | A mismatch between two types.
Mismatch :: MismatchMsg -> Maybe TyVarInfo -> [AmbiguityInfo] -> Maybe CoercibleMsg -> TcSolverReportMsg
[mismatchMsg] :: TcSolverReportMsg -> MismatchMsg
[mismatchTyVarInfo] :: TcSolverReportMsg -> Maybe TyVarInfo
[mismatchAmbiguityInfo] :: TcSolverReportMsg -> [AmbiguityInfo]
[mismatchCoercibleInfo] :: TcSolverReportMsg -> Maybe CoercibleMsg

-- | A violation of the representation-polymorphism invariants.
--   
--   See <a>FixedRuntimeRepErrorInfo</a> and
--   <tt>FixedRuntimeRepContext</tt> for more information.
FixedRuntimeRepError :: [FixedRuntimeRepErrorInfo] -> TcSolverReportMsg

-- | An equality between two types is blocked on a kind equality between
--   their kinds.
--   
--   Test cases: none.
BlockedEquality :: ErrorItem -> TcSolverReportMsg

-- | Something was not applied to sufficiently many arguments.
--   
--   Example:
--   
--   instance Eq Maybe where {..}
--   
--   Test case: T11563.
ExpectingMoreArguments :: Int -> TypedThing -> TcSolverReportMsg

-- | Trying to use an unbound implicit parameter.
--   
--   Example:
--   
--   foo :: Int foo = ?param
--   
--   Test case: tcfail130.
UnboundImplicitParams :: NonEmpty ErrorItem -> TcSolverReportMsg

-- | A constraint couldn't be solved because it contains ambiguous type
--   variables.
--   
--   Example:
--   
--   class C a b where f :: (a,b)
--   
--   x = fst f
--   
--   Test case: T4921.
AmbiguityPreventsSolvingCt :: ErrorItem -> ([TyVar], [TyVar]) -> TcSolverReportMsg

-- | Could not solve a constraint; there were several unifying candidate
--   instances but no matching instances. This is used to report as much
--   useful information as possible about why we couldn't choose any
--   instance, e.g. because of ambiguous type variables.
CannotResolveInstance :: ErrorItem -> [ClsInst] -> [ClsInst] -> [ImportError] -> [GhcHint] -> RelevantBindings -> TcSolverReportMsg
[cannotResolve_item] :: TcSolverReportMsg -> ErrorItem
[cannotResolve_unifiers] :: TcSolverReportMsg -> [ClsInst]
[cannotResolve_candidates] :: TcSolverReportMsg -> [ClsInst]
[cannotResolve_importErrors] :: TcSolverReportMsg -> [ImportError]
[cannotResolve_suggestions] :: TcSolverReportMsg -> [GhcHint]
[cannotResolve_relevant_bindings] :: TcSolverReportMsg -> RelevantBindings

-- | Could not solve a constraint using available instances because the
--   instances overlap.
--   
--   Test cases: tcfail118, tcfail121, tcfail218.
OverlappingInstances :: ErrorItem -> NonEmpty ClsInst -> [ClsInst] -> TcSolverReportMsg
[overlappingInstances_item] :: TcSolverReportMsg -> ErrorItem
[overlappingInstances_matches] :: TcSolverReportMsg -> NonEmpty ClsInst
[overlappingInstances_unifiers] :: TcSolverReportMsg -> [ClsInst]

-- | Could not solve a constraint from instances because instances declared
--   in a Safe module cannot overlap instances from other modules (with
--   -XSafeHaskell).
--   
--   Test cases: SH_Overlap{1,2,5,6,7,11}.
UnsafeOverlap :: ErrorItem -> ClsInst -> NonEmpty ClsInst -> TcSolverReportMsg
[unsafeOverlap_item] :: TcSolverReportMsg -> ErrorItem
[unsafeOverlap_match] :: TcSolverReportMsg -> ClsInst
[unsafeOverlapped] :: TcSolverReportMsg -> NonEmpty ClsInst
data CannotUnifyVariableReason

-- | A type equality between a type variable and a polytype.
--   
--   Test cases: T12427a, T2846b, T10194, ...
CannotUnifyWithPolytype :: ErrorItem -> TyVar -> Type -> Maybe TyVarInfo -> CannotUnifyVariableReason

-- | An occurs check.
OccursCheck :: [TyVar] -> [AmbiguityInfo] -> CannotUnifyVariableReason
[occursCheckInterestingTyVars] :: CannotUnifyVariableReason -> [TyVar]
[occursCheckAmbiguityInfos] :: CannotUnifyVariableReason -> [AmbiguityInfo]

-- | A skolem type variable escapes its scope.
--   
--   Example:
--   
--   data Ex where { MkEx :: a -&gt; MkEx } foo (MkEx x) = x
--   
--   Test cases: TypeSkolEscape, T11142.
SkolemEscape :: ErrorItem -> Implication -> [TyVar] -> CannotUnifyVariableReason

-- | Can't unify the type variable with the other type due to the kind of
--   type variable it is.
--   
--   For example, trying to unify a <tt>SkolemTv</tt> with the type Int, or
--   with a <tt>TyVarTv</tt>.
DifferentTyVars :: TyVarInfo -> CannotUnifyVariableReason
RepresentationalEq :: TyVarInfo -> Maybe CoercibleMsg -> CannotUnifyVariableReason
data MismatchMsg

-- | Couldn't unify two types or kinds.
--   
--   Example:
--   
--   3 + 3# -- can't match a lifted type with an unlifted type
--   
--   Test cases: T1396, T8263, ...
BasicMismatch :: MismatchEA -> ErrorItem -> Type -> Type -> Maybe WhenMatching -> Maybe SameOccInfo -> MismatchMsg

-- | Should this be phrased in terms of expected vs actual?
[mismatch_ea] :: MismatchMsg -> MismatchEA

-- | The constraint in which the mismatch originated.
[mismatch_item] :: MismatchMsg -> ErrorItem

-- | First type (the expected type if if mismatch_ea is True)
[mismatch_ty1] :: MismatchMsg -> Type

-- | Second type (the actual type if mismatch_ea is True)
[mismatch_ty2] :: MismatchMsg -> Type
[mismatch_whenMatching] :: MismatchMsg -> Maybe WhenMatching
[mismatch_mb_same_occ] :: MismatchMsg -> Maybe SameOccInfo

-- | A type has an unexpected kind.
--   
--   Test cases: T2994, T7609, ...
KindMismatch :: TypedThing -> Type -> Type -> MismatchMsg

-- | What thing is <a>kmismatch_actual</a> the kind of?
[kmismatch_what] :: MismatchMsg -> TypedThing
[kmismatch_expected] :: MismatchMsg -> Type
[kmismatch_actual] :: MismatchMsg -> Type

-- | A mismatch between two types, which arose from a type equality.
--   
--   Test cases: T1470, tcfail212.
TypeEqMismatch :: Bool -> ErrorItem -> Type -> Type -> Type -> Type -> Maybe TypedThing -> Maybe SameOccInfo -> MismatchMsg
[teq_mismatch_ppr_explicit_kinds] :: MismatchMsg -> Bool
[teq_mismatch_item] :: MismatchMsg -> ErrorItem
[teq_mismatch_ty1] :: MismatchMsg -> Type
[teq_mismatch_ty2] :: MismatchMsg -> Type

-- | The overall expected type
[teq_mismatch_expected] :: MismatchMsg -> Type

-- | The overall actual type
[teq_mismatch_actual] :: MismatchMsg -> Type

-- | What thing is <a>teq_mismatch_actual</a> the kind of?
[teq_mismatch_what] :: MismatchMsg -> Maybe TypedThing
[teq_mb_same_occ] :: MismatchMsg -> Maybe SameOccInfo

-- | Couldn't solve some Wanted constraints using the Givens. Used for
--   messages such as <tt>"No instance for ..."</tt> and <tt>"Could not
--   deduce ... from"</tt>.
CouldNotDeduce :: [Implication] -> NonEmpty ErrorItem -> Maybe CND_Extra -> MismatchMsg
[cnd_user_givens] :: MismatchMsg -> [Implication]

-- | The Wanted constraints we couldn't solve.
--   
--   N.B.: the <a>ErrorItem</a> at the head of the list has been tidied,
--   perhaps not the others.
[cnd_wanted] :: MismatchMsg -> NonEmpty ErrorItem

-- | Some additional info consumed by <tt>mk_supplementary_ea_msg</tt>.
[cnd_extra] :: MismatchMsg -> Maybe CND_Extra

-- | Whether to use expected/actual in a type mismatch message.
data MismatchEA

-- | Don't use expected/actual.
NoEA :: MismatchEA

-- | Use expected/actual.
EA :: Maybe ExpectedActualInfo -> MismatchEA

-- | Whether to also mention type synonym expansion.
[mismatch_mbEA] :: MismatchEA -> Maybe ExpectedActualInfo

-- | Report a mismatch error without any extra information.
mkPlainMismatchMsg :: MismatchMsg -> TcSolverReportMsg

-- | Construct a basic mismatch message between two types.
--   
--   See <tt>pprMismatchMsg</tt> for how such a message is displayed to
--   users.
mkBasicMismatchMsg :: MismatchEA -> ErrorItem -> Type -> Type -> MismatchMsg

-- | Explain how a kind equality originated.
data WhenMatching
WhenMatching :: TcType -> TcType -> CtOrigin -> Maybe TypeOrKind -> WhenMatching

-- | Expected/actual information.
data ExpectedActualInfo

-- | Display the expected and actual types.
ExpectedActual :: Type -> ExpectedActualInfo
[ea_expected, ea_actual] :: ExpectedActualInfo -> Type

-- | Display the expected and actual types, after expanding type synonyms.
ExpectedActualAfterTySynExpansion :: Type -> ExpectedActualInfo
[ea_expanded_expected, ea_expanded_actual] :: ExpectedActualInfo -> Type

-- | A cue to print out information about type variables, e.g. where they
--   were bound, when there is a mismatch <tt>tv1 ~ ty2</tt>.
data TyVarInfo
TyVarInfo :: TyVar -> Maybe Implication -> Maybe TyVar -> TyVarInfo
[thisTyVar] :: TyVarInfo -> TyVar
[thisTyVarIsUntouchable] :: TyVarInfo -> Maybe Implication
[otherTy] :: TyVarInfo -> Maybe TyVar

-- | Add some information to disambiguate errors in which two
--   <tt>Names</tt> would otherwise appear to be identical.
--   
--   See Note [Disambiguating (X ~ X) errors].
data SameOccInfo
SameOcc :: Bool -> Name -> Name -> SameOccInfo

-- | Whether the two <a>Name</a>s also came from the same package.
[sameOcc_same_pkg] :: SameOccInfo -> Bool
[sameOcc_lhs] :: SameOccInfo -> Name
[sameOcc_rhs] :: SameOccInfo -> Name

-- | Add some information about ambiguity
data AmbiguityInfo

-- | Some type variables remained ambiguous: print them to the user.
Ambiguity :: Bool -> ([TyVar], [TyVar]) -> AmbiguityInfo

-- | True <a>=</a> start the message with "Ambiguous type variable ..."
--   False <a>=</a> create a message of the form "The type variable is
--   ambiguous."
[lead_with_ambig_msg] :: AmbiguityInfo -> Bool

-- | Ambiguous kind and type variables, respectively. Guaranteed to not
--   both be empty.
[ambig_tyvars] :: AmbiguityInfo -> ([TyVar], [TyVar])

-- | Remind the user that a particular type family is not injective.
NonInjectiveTyFam :: TyCon -> AmbiguityInfo

-- | Additional information to be given in a <a>CouldNotDeduce</a> message,
--   which is then passed on to <tt>mk_supplementary_ea_msg</tt>.
data CND_Extra
CND_Extra :: TypeOrKind -> Type -> Type -> CND_Extra

-- | A collection of valid hole fits or refinement fits, in which some fits
--   might have been suppressed.
data FitsMbSuppressed
Fits :: [HoleFit] -> Bool -> FitsMbSuppressed
[fits] :: FitsMbSuppressed -> [HoleFit]

-- | Whether we have suppressed any fits because there were too many.
[fitsSuppressed] :: FitsMbSuppressed -> Bool

-- | A collection of hole fits and refinement fits.
data ValidHoleFits
ValidHoleFits :: FitsMbSuppressed -> FitsMbSuppressed -> ValidHoleFits
[holeFits] :: ValidHoleFits -> FitsMbSuppressed
[refinementFits] :: ValidHoleFits -> FitsMbSuppressed
noValidHoleFits :: ValidHoleFits

-- | Configuration for pretty-printing valid hole fits.
data HoleFitDispConfig
HFDC :: Bool -> HoleFitDispConfig
[showWrap, showWrapVars, showType, showProv, showMatches] :: HoleFitDispConfig -> Bool
data RelevantBindings
RelevantBindings :: [(Name, Type)] -> Bool -> RelevantBindings
[relevantBindingNamesAndTys] :: RelevantBindings -> [(Name, Type)]

-- | Whether we ran out of fuel generating the bindings.
[ranOutOfFuel] :: RelevantBindings -> Bool

-- | Display some relevant bindings.
pprRelevantBindings :: RelevantBindings -> SDoc
data PromotionErr
TyConPE :: PromotionErr
ClassPE :: PromotionErr
FamDataConPE :: PromotionErr
ConstrainedDataConPE :: PredType -> PromotionErr
PatSynPE :: PromotionErr
RecDataConPE :: PromotionErr
TermVariablePE :: PromotionErr
NoDataKindsDC :: PromotionErr
pprPECategory :: PromotionErr -> SDoc
peCategory :: PromotionErr -> String

-- | Some form of <tt>"not in scope"</tt> error. See also the
--   <a>OutOfScopeHole</a> constructor of <a>HoleError</a>.
data NotInScopeError

-- | A run-of-the-mill <tt>"not in scope"</tt> error.
NotInScope :: NotInScopeError

-- | An exact <a>Name</a> was not in scope.
--   
--   This usually indicates a problem with a Template Haskell splice.
--   
--   Test cases: T5971, T18263.
NoExactName :: Name -> NotInScopeError

-- | always at least 2 elements
SameName :: [GlobalRdrElt] -> NotInScopeError
MissingBinding :: SDoc -> [GhcHint] -> NotInScopeError

-- | Couldn't find a top-level binding.
--   
--   Happens when specifying an annotation for something that is not in
--   scope.
--   
--   Test cases: annfail01, annfail02, annfail11.
NoTopLevelBinding :: NotInScopeError

-- | A class doesn't have a method with this name, or, a class doesn't have
--   an associated type with this name, or, a record doesn't have a record
--   field with this name.
UnknownSubordinate :: SDoc -> NotInScopeError

-- | Create a <tt>"not in scope"</tt> error message for the given
--   <a>RdrName</a>.
mkTcRnNotInScope :: RdrName -> NotInScopeError -> TcRnMessage

-- | Explain a problem with an import.
data ImportError

-- | Couldn't find a module with the requested name.
MissingModule :: ModuleName -> ImportError

-- | The imported modules don't export what we're looking for.
ModulesDoNotExport :: NonEmpty Module -> OccName -> ImportError

-- | Report an error involving a <a>Hole</a>.
--   
--   This could be an out of scope data constructor or variable, a typed
--   hole, or a wildcard in a type.
data HoleError

-- | Report an out-of-scope data constructor or variable masquerading as an
--   expression hole.
--   
--   See Note [Insoluble holes] in GHC.Tc.Types.Constraint. See
--   <a>NotInScopeError</a> for other not-in-scope errors.
--   
--   Test cases: T9177a.
OutOfScopeHole :: [ImportError] -> HoleError

-- | Report a typed hole, or wildcard, with additional information.
HoleError :: HoleSort -> [TcTyVar] -> [(SkolemInfoAnon, [TcTyVar])] -> HoleError

-- | A message that aims to explain why two types couldn't be seen to be
--   representationally equal.
data CoercibleMsg

-- | Not knowing the role of a type constructor prevents us from concluding
--   that two types are representationally equal.
--   
--   Example:
--   
--   foo :: Applicative m =&gt; m (Sum Int) foo = coerce (pure $ 1 :: Int)
--   
--   We don't know what role <tt>m</tt> has, so we can't coerce `m Int` to
--   `m (Sum Int)`.
--   
--   Test cases: T8984, TcCoercibleFail.
UnknownRoles :: Type -> CoercibleMsg

-- | The fact that a <a>TyCon</a> is abstract prevents us from decomposing
--   a <tt>TyConApp</tt> and deducing that two types are representationally
--   equal.
--   
--   Test cases: none.
TyConIsAbstract :: TyCon -> CoercibleMsg

-- | We can't unwrap a newtype whose constructor is not in scope.
--   
--   Example:
--   
--   import Data.Ord (Down) -- NB: not importing the constructor foo :: Int
--   -&gt; Down Int foo = coerce
--   
--   Test cases: TcCoercibleFail.
OutOfScopeNewtypeConstructor :: TyCon -> DataCon -> CoercibleMsg

-- | This datatype collates instances that match or unifier, in order to
--   report an error message for an unsolved typeclass constraint.
data PotentialInstances
PotentialInstances :: [ClsInst] -> [ClsInst] -> PotentialInstances
[matches] :: PotentialInstances -> [ClsInst]
[unifiers] :: PotentialInstances -> [ClsInst]

-- | Specifies which calling convention is unsupported on the current
--   platform
data UnsupportedCallConvention
StdCallConvUnsupported :: UnsupportedCallConvention
PrimCallConvUnsupported :: UnsupportedCallConvention
JavaScriptCallConvUnsupported :: UnsupportedCallConvention

-- | Specifies which back ends can handle a requested foreign import or
--   export
type ExpectedBackends = [Backend]

-- | Whether the error pertains to a function argument or a result.
data ArgOrResult
Arg :: ArgOrResult
Result :: ArgOrResult

-- | Context for a mismatch in the number of arguments
data MatchArgsContext

-- | Name of the function
EquationArgs :: !Name -> MatchArgsContext

-- | Pattern match specifics
PatternArgs :: !HsMatchContext GhcTc -> MatchArgsContext

-- | The information necessary to report mismatched numbers of arguments in
--   a match group.
data MatchArgBadMatches
[MatchArgMatches] :: LocatedA (Match GhcRn body) -> NonEmpty (LocatedA (Match GhcRn body)) -> MatchArgBadMatches

-- | The reason a TH splice could not be converted to a Haskell expression
data ConversionFailReason
IllegalOccName :: !NameSpace -> !String -> ConversionFailReason
SumAltArityExceeded :: !SumAlt -> !SumArity -> ConversionFailReason
IllegalSumAlt :: !SumAlt -> ConversionFailReason
IllegalSumArity :: !SumArity -> ConversionFailReason
MalformedType :: !TypeOrKind -> !Type -> ConversionFailReason
IllegalLastStatement :: !HsDoFlavour -> !LStmt GhcPs (LHsExpr GhcPs) -> ConversionFailReason
KindSigsOnlyAllowedOnGADTs :: ConversionFailReason
IllegalDeclaration :: !THDeclDescriptor -> !IllegalDecls -> ConversionFailReason
CannotMixGADTConsWith98Cons :: ConversionFailReason
EmptyStmtListInDoBlock :: ConversionFailReason
NonVarInInfixExpr :: ConversionFailReason
MultiWayIfWithoutAlts :: ConversionFailReason
CasesExprWithoutAlts :: ConversionFailReason
ImplicitParamsWithOtherBinds :: ConversionFailReason

-- | Source
InvalidCCallImpent :: !String -> ConversionFailReason
RecGadtNoCons :: ConversionFailReason
GadtNoCons :: ConversionFailReason
InvalidTypeInstanceHeader :: !Type -> ConversionFailReason
InvalidTyFamInstLHS :: !Type -> ConversionFailReason
InvalidImplicitParamBinding :: ConversionFailReason
DefaultDataInstDecl :: ![LDataFamInstDecl GhcPs] -> ConversionFailReason
FunBindLacksEquations :: !Name -> ConversionFailReason
data UnrepresentableTypeDescr
LinearInvisibleArgument :: UnrepresentableTypeDescr
CoercionsInTypes :: UnrepresentableTypeDescr
data LookupTHInstNameErrReason
NoMatchesFound :: LookupTHInstNameErrReason
CouldNotDetermineInstance :: LookupTHInstNameErrReason

-- | The phase in which an exception was encountered when dealing with a TH
--   splice
data SplicePhase
SplicePhase_Run :: SplicePhase
SplicePhase_CompileAndLink :: SplicePhase

-- | Label for a TH declaration
data THDeclDescriptor
InstanceDecl :: THDeclDescriptor
WhereClause :: THDeclDescriptor
LetBinding :: THDeclDescriptor
LetExpression :: THDeclDescriptor
ClssDecl :: THDeclDescriptor
data RunSpliceFailReason
ConversionFail :: !ThingBeingConverted -> !ConversionFailReason -> RunSpliceFailReason

-- | Identifies the TH splice attempting to be converted
data ThingBeingConverted
ConvDec :: !Dec -> ThingBeingConverted
ConvExp :: !Exp -> ThingBeingConverted
ConvPat :: !Pat -> ThingBeingConverted
ConvType :: !Type -> ThingBeingConverted
data IllegalDecls
IllegalDecls :: !NonEmpty (LHsDecl GhcPs) -> IllegalDecls
IllegalFamDecls :: !NonEmpty (LFamilyDecl GhcPs) -> IllegalDecls

-- | The context for an "empty statement group" error.
data EmptyStatementGroupErrReason

-- | Empty statement group in a parallel list comprehension
EmptyStmtsGroupInParallelComp :: EmptyStatementGroupErrReason

-- | Empty statement group in a transform list comprehension
--   
--   Example: [() | then ()]
EmptyStmtsGroupInTransformListComp :: EmptyStatementGroupErrReason

-- | Empty statement group in do notation
--   
--   Example: do
EmptyStmtsGroupInDoNotation :: HsDoFlavour -> EmptyStatementGroupErrReason

-- | Empty statement group in arrow notation
--   
--   Example: proc () -&gt; do
EmptyStmtsGroupInArrowNotation :: EmptyStatementGroupErrReason

-- | An existential wrapper around <tt><a>StmtLR</a> GhcPs GhcPs body</tt>.
data UnexpectedStatement
[UnexpectedStatement] :: Outputable (StmtLR GhcPs GhcPs body) => StmtLR GhcPs GhcPs body -> UnexpectedStatement
instance GHC.Generics.Generic GHC.Tc.Errors.Types.TypeDataForbids
instance GHC.Generics.Generic GHC.Tc.Errors.Types.ConversionFailReason
instance GHC.Generics.Generic GHC.Tc.Errors.Types.RunSpliceFailReason
instance GHC.Classes.Eq GHC.Tc.Errors.Types.UnsupportedCallConvention
instance GHC.Generics.Generic GHC.Tc.Errors.Types.IllegalNewtypeReason
instance GHC.Classes.Eq GHC.Tc.Errors.Types.HasKinds
instance GHC.Show.Show GHC.Tc.Errors.Types.HasKinds
instance GHC.Classes.Eq GHC.Tc.Errors.Types.SuggestUndecidableInstances
instance GHC.Show.Show GHC.Tc.Errors.Types.SuggestUndecidableInstances
instance GHC.Classes.Eq GHC.Tc.Errors.Types.SuggestPartialTypeSignatures
instance GHC.Show.Show GHC.Tc.Errors.Types.SuggestPartialTypeSignatures
instance GHC.Classes.Eq GHC.Tc.Errors.Types.UsingGeneralizedNewtypeDeriving
instance GHC.Classes.Eq GHC.Tc.Errors.Types.DeriveAnyClassEnabled
instance GHC.Classes.Eq GHC.Tc.Errors.Types.HasWildcard
instance GHC.Classes.Eq GHC.Tc.Errors.Types.HasAssociatedDataFamInsts
instance GHC.Classes.Eq GHC.Tc.Errors.Types.AssociatedTyLastVarInKind
instance GHC.Classes.Eq GHC.Tc.Errors.Types.AssociatedTyNotParamOverLastTyVar
instance GHC.Generics.Generic GHC.Tc.Errors.Types.DeriveInstanceErrReason
instance GHC.Generics.Generic GHC.Tc.Errors.Types.WhenMatching
instance GHC.Generics.Generic GHC.Tc.Errors.Types.MismatchMsg
instance GHC.Generics.Generic GHC.Tc.Errors.Types.NotInScopeError
instance GHC.Generics.Generic GHC.Tc.Errors.Types.CannotUnifyVariableReason
instance GHC.Generics.Generic GHC.Tc.Errors.Types.TcSolverReportMsg
instance GHC.Generics.Generic GHC.Tc.Errors.Types.SolverReportWithCtxt
instance GHC.Generics.Generic GHC.Tc.Errors.Types.EmptyStatementGroupErrReason
instance GHC.Generics.Generic GHC.Tc.Errors.Types.TcRnMessageDetailed
instance GHC.Generics.Generic GHC.Tc.Errors.Types.TcRnMessage
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.PromotionErr
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.ErrorItem
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.Exported
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.TypeDataForbids

module GHC.Parser.Errors.Types
type PsWarning = PsMessage
type PsError = PsMessage
data PsHeaderMessage
PsErrParseLanguagePragma :: PsHeaderMessage
PsErrUnsupportedExt :: !String -> ![String] -> PsHeaderMessage
PsErrParseOptionsPragma :: !String -> PsHeaderMessage

-- | PsErrUnsupportedOptionsPragma is an error that occurs when an unknown
--   OPTIONS_GHC pragma is supplied is found.
--   
--   Example(s): {-# OPTIONS_GHC foo #-}
--   
--   Test case(s):
--   
--   tests<i>safeHaskell</i>flags/SafeFlags28
--   tests<i>safeHaskell</i>flags/SafeFlags19
--   tests<i>safeHaskell</i>flags/SafeFlags29
--   tests<i>parser</i>should_fail/T19923c
--   tests<i>parser</i>should_fail/T19923b
--   tests<i>parser</i>should_fail/readFail044 tests<i>driver</i>T2499
PsErrUnknownOptionsPragma :: !String -> PsHeaderMessage
data PsMessage

-- | An "unknown" message from the parser. This type constructor allows
--   arbitrary messages to be embedded. The typical use case would be GHC
--   plugins willing to emit custom diagnostics.
PsUnknownMessage :: UnknownDiagnostic -> PsMessage

-- | A group of parser messages emitted in <a>Header</a>. See Note
--   [Messages from GHC.Parser.Header].
PsHeaderMessage :: !PsHeaderMessage -> PsMessage

-- | PsWarnBidirectionalFormatChars is a warning (controlled by the
--   -Wwarn-bidirectional-format-characters flag) that occurs when unicode
--   bi-directional format characters are found within in a file
--   
--   The <a>PsLoc</a> contains the exact position in the buffer the
--   character occurred, and the string contains a description of the
--   character.
PsWarnBidirectionalFormatChars :: NonEmpty (PsLoc, Char, String) -> PsMessage

-- | PsWarnTab is a warning (controlled by the -Wwarn-tabs flag) that
--   occurs when tabulations (tabs) are found within a file.
--   
--   Test case(s): parser<i>should_fail</i>T12610
--   parser<i>should_compile</i>T9723b parser<i>should_compile</i>T9723a
--   parser<i>should_compile</i>read043 parser<i>should_fail</i>T16270
--   warnings<i>should_compile</i>T9230
PsWarnTab :: !Word -> PsMessage

-- | PsWarnTransitionalLayout is a warning (controlled by the
--   -Walternative-layout-rule-transitional flag) that occurs when pipes
--   ('|') or 'where' are at the same depth of an implicit layout block.
--   
--   Example(s):
--   
--   f :: IO () f | True = do let x = () y = () return () | True = return
--   ()
--   
--   Test case(s): layout/layout006 layout/layout003 layout/layout001
PsWarnTransitionalLayout :: !TransLayoutReason -> PsMessage

-- | Unrecognised pragma. First field is the actual pragma name which might
--   be empty. Second field is the set of valid candidate pragmas.
PsWarnUnrecognisedPragma :: !String -> ![String] -> PsMessage
PsWarnMisplacedPragma :: !FileHeaderPragmaType -> PsMessage

-- | Invalid Haddock comment position
PsWarnHaddockInvalidPos :: PsMessage

-- | Multiple Haddock comment for the same entity
PsWarnHaddockIgnoreMulti :: PsMessage

-- | Found binding occurrence of "*" while StarIsType is enabled
PsWarnStarBinder :: PsMessage

-- | Using "*" for <a>Type</a> without StarIsType enabled
PsWarnStarIsType :: PsMessage

-- | Pre qualified import with <tt>WarnPrepositiveQualifiedModule</tt>
--   enabled
PsWarnImportPreQualified :: PsMessage
PsWarnOperatorWhitespaceExtConflict :: !OperatorWhitespaceSymbol -> PsMessage
PsWarnOperatorWhitespace :: !FastString -> !OperatorWhitespaceOccurrence -> PsMessage

-- | LambdaCase syntax used without the extension enabled
PsErrLambdaCase :: PsMessage

-- | A lambda requires at least one parameter
PsErrEmptyLambda :: PsMessage

-- | Underscores in literals without the extension enabled
PsErrNumUnderscores :: !NumUnderscoreReason -> PsMessage

-- | Invalid character in primitive string
PsErrPrimStringInvalidChar :: PsMessage

-- | Missing block
PsErrMissingBlock :: PsMessage

-- | Lexer error
PsErrLexer :: !LexErr -> !LexErrKind -> PsMessage

-- | Suffix occurrence of <tt>@</tt>
PsErrSuffixAT :: PsMessage

-- | Parse errors
PsErrParse :: !String -> !PsErrParseDetails -> PsMessage

-- | Cmm lexer error
PsErrCmmLexer :: PsMessage

-- | Unsupported boxed sum in expression
PsErrUnsupportedBoxedSumExpr :: !SumOrTuple (HsExpr GhcPs) -> PsMessage

-- | Unsupported boxed sum in pattern
PsErrUnsupportedBoxedSumPat :: !SumOrTuple (PatBuilder GhcPs) -> PsMessage

-- | Unexpected qualified constructor
PsErrUnexpectedQualifiedConstructor :: !RdrName -> PsMessage

-- | Tuple section in pattern context
PsErrTupleSectionInPat :: PsMessage

-- | Bang-pattern without BangPattterns enabled
PsErrIllegalBangPattern :: !Pat GhcPs -> PsMessage

-- | Operator applied to too few arguments
PsErrOpFewArgs :: !StarIsType -> !RdrName -> PsMessage

-- | Import: multiple occurrences of <tt>qualified</tt>
PsErrImportQualifiedTwice :: PsMessage

-- | Post qualified import without <tt>ImportQualifiedPost</tt>
PsErrImportPostQualified :: PsMessage

-- | Explicit namespace keyword without <tt>ExplicitNamespaces</tt>
PsErrIllegalExplicitNamespace :: PsMessage

-- | Expecting a type constructor but found a variable
PsErrVarForTyCon :: !RdrName -> PsMessage

-- | Illegal export form allowed by PatternSynonyms
PsErrIllegalPatSynExport :: PsMessage

-- | Malformed entity string
PsErrMalformedEntityString :: PsMessage

-- | Dots used in record update
PsErrDotsInRecordUpdate :: PsMessage

-- | Precedence out of range
PsErrPrecedenceOutOfRange :: !Int -> PsMessage

-- | Invalid use of record dot syntax <a>.</a>
PsErrOverloadedRecordDotInvalid :: PsMessage

-- | <tt>OverloadedRecordUpdate</tt> is not enabled.
PsErrOverloadedRecordUpdateNotEnabled :: PsMessage

-- | Can't use qualified fields when OverloadedRecordUpdate is enabled.
PsErrOverloadedRecordUpdateNoQualifiedFields :: PsMessage

-- | Cannot parse data constructor in a data/newtype declaration
PsErrInvalidDataCon :: !HsType GhcPs -> PsMessage

-- | Cannot parse data constructor in a data/newtype declaration
PsErrInvalidInfixDataCon :: !HsType GhcPs -> !RdrName -> !HsType GhcPs -> PsMessage

-- | Illegal DataKinds quote mark in data/newtype constructor declaration
PsErrIllegalPromotionQuoteDataCon :: !RdrName -> PsMessage

-- | UNPACK applied to a data constructor
PsErrUnpackDataCon :: PsMessage

-- | Unexpected kind application in data/newtype declaration
PsErrUnexpectedKindAppInDataCon :: !DataConBuilder -> !HsType GhcPs -> PsMessage

-- | Not a record constructor
PsErrInvalidRecordCon :: !PatBuilder GhcPs -> PsMessage

-- | Illegal unboxed string literal in pattern
PsErrIllegalUnboxedStringInPat :: !HsLit GhcPs -> PsMessage

-- | Illegal primitive floating point literal in pattern
PsErrIllegalUnboxedFloatingLitInPat :: !HsLit GhcPs -> PsMessage

-- | Do-notation in pattern
PsErrDoNotationInPat :: PsMessage

-- | If-then-else syntax in pattern
PsErrIfThenElseInPat :: PsMessage

-- | Lambda-case in pattern
PsErrLambdaCaseInPat :: LamCaseVariant -> PsMessage

-- | case..of in pattern
PsErrCaseInPat :: PsMessage

-- | let-syntax in pattern
PsErrLetInPat :: PsMessage

-- | Lambda-syntax in pattern
PsErrLambdaInPat :: PsMessage

-- | Arrow expression-syntax in pattern
PsErrArrowExprInPat :: !HsExpr GhcPs -> PsMessage

-- | Arrow command-syntax in pattern
PsErrArrowCmdInPat :: !HsCmd GhcPs -> PsMessage

-- | Arrow command-syntax in expression
PsErrArrowCmdInExpr :: !HsCmd GhcPs -> PsMessage

-- | View-pattern in expression
PsErrViewPatInExpr :: !LHsExpr GhcPs -> !LHsExpr GhcPs -> PsMessage

-- | Type-application without space before <tt>@</tt>
PsErrTypeAppWithoutSpace :: !RdrName -> !LHsExpr GhcPs -> PsMessage

-- | Lazy-pattern (<a>~</a>) without space after it
PsErrLazyPatWithoutSpace :: !LHsExpr GhcPs -> PsMessage

-- | Bang-pattern (<tt>!</tt>) without space after it
PsErrBangPatWithoutSpace :: !LHsExpr GhcPs -> PsMessage

-- | Pragma not allowed in this position
PsErrUnallowedPragma :: !HsPragE GhcPs -> PsMessage

-- | Qualified do block in command
PsErrQualifiedDoInCmd :: !ModuleName -> PsMessage

-- | Invalid infix hole, expected an infix operator
PsErrInvalidInfixHole :: PsMessage

-- | Unexpected semi-colons in conditional expression
PsErrSemiColonsInCondExpr :: !HsExpr GhcPs -> !Bool -> !HsExpr GhcPs -> !Bool -> !HsExpr GhcPs -> PsMessage

-- | Unexpected semi-colons in conditional command
PsErrSemiColonsInCondCmd :: !HsExpr GhcPs -> !Bool -> !HsCmd GhcPs -> !Bool -> !HsCmd GhcPs -> PsMessage

-- | @-operator in a pattern position
PsErrAtInPatPos :: PsMessage

-- | Unexpected lambda command in function application
PsErrLambdaCmdInFunAppCmd :: !LHsCmd GhcPs -> PsMessage

-- | Unexpected case command in function application
PsErrCaseCmdInFunAppCmd :: !LHsCmd GhcPs -> PsMessage

-- | Unexpected case(s) command in function application
PsErrLambdaCaseCmdInFunAppCmd :: !LamCaseVariant -> !LHsCmd GhcPs -> PsMessage

-- | Unexpected if command in function application
PsErrIfCmdInFunAppCmd :: !LHsCmd GhcPs -> PsMessage

-- | Unexpected let command in function application
PsErrLetCmdInFunAppCmd :: !LHsCmd GhcPs -> PsMessage

-- | Unexpected do command in function application
PsErrDoCmdInFunAppCmd :: !LHsCmd GhcPs -> PsMessage

-- | Unexpected do block in function application
PsErrDoInFunAppExpr :: !Maybe ModuleName -> !LHsExpr GhcPs -> PsMessage

-- | Unexpected mdo block in function application
PsErrMDoInFunAppExpr :: !Maybe ModuleName -> !LHsExpr GhcPs -> PsMessage

-- | Unexpected lambda expression in function application
PsErrLambdaInFunAppExpr :: !LHsExpr GhcPs -> PsMessage

-- | Unexpected case expression in function application
PsErrCaseInFunAppExpr :: !LHsExpr GhcPs -> PsMessage

-- | Unexpected case(s) expression in function application
PsErrLambdaCaseInFunAppExpr :: !LamCaseVariant -> !LHsExpr GhcPs -> PsMessage

-- | Unexpected let expression in function application
PsErrLetInFunAppExpr :: !LHsExpr GhcPs -> PsMessage

-- | Unexpected if expression in function application
PsErrIfInFunAppExpr :: !LHsExpr GhcPs -> PsMessage

-- | Unexpected proc expression in function application
PsErrProcInFunAppExpr :: !LHsExpr GhcPs -> PsMessage

-- | Malformed head of type or class declaration
PsErrMalformedTyOrClDecl :: !LHsType GhcPs -> PsMessage

-- | Illegal 'where' keyword in data declaration
PsErrIllegalWhereInDataDecl :: PsMessage

-- | Illegal datatype context
PsErrIllegalDataTypeContext :: !LHsContext GhcPs -> PsMessage

-- | Parse error on input
PsErrParseErrorOnInput :: !OccName -> PsMessage

-- | Malformed ... declaration for ...
PsErrMalformedDecl :: !SDoc -> !RdrName -> PsMessage

-- | Unexpected type application in a declaration
PsErrUnexpectedTypeAppInDecl :: !LHsType GhcPs -> !SDoc -> !RdrName -> PsMessage

-- | Not a data constructor
PsErrNotADataCon :: !RdrName -> PsMessage

-- | Record syntax used in pattern synonym declaration
PsErrRecordSyntaxInPatSynDecl :: !LPat GhcPs -> PsMessage

-- | Empty 'where' clause in pattern-synonym declaration
PsErrEmptyWhereInPatSynDecl :: !RdrName -> PsMessage

-- | Invalid binding name in 'where' clause of pattern-synonym declaration
PsErrInvalidWhereBindInPatSynDecl :: !RdrName -> !HsDecl GhcPs -> PsMessage

-- | Multiple bindings in 'where' clause of pattern-synonym declaration
PsErrNoSingleWhereBindInPatSynDecl :: !RdrName -> !HsDecl GhcPs -> PsMessage

-- | Declaration splice not a top-level
PsErrDeclSpliceNotAtTopLevel :: !SpliceDecl GhcPs -> PsMessage

-- | Inferred type variables not allowed here
PsErrInferredTypeVarNotAllowed :: PsMessage

-- | Multiple names in standalone kind signatures
PsErrMultipleNamesInStandaloneKindSignature :: [LIdP GhcPs] -> PsMessage

-- | Illegal import bundle form
PsErrIllegalImportBundleForm :: PsMessage

-- | Illegal role name
PsErrIllegalRoleName :: !FastString -> [Role] -> PsMessage

-- | Invalid type signature
PsErrInvalidTypeSignature :: !LHsExpr GhcPs -> PsMessage

-- | Unexpected type in declaration
PsErrUnexpectedTypeInDecl :: !LHsType GhcPs -> !SDoc -> !RdrName -> [LHsTypeArg GhcPs] -> !SDoc -> PsMessage

-- | Expected a hyphen
PsErrExpectedHyphen :: PsMessage

-- | Found a space in a SCC
PsErrSpaceInSCC :: PsMessage

-- | Found two single quotes
PsErrEmptyDoubleQuotes :: !Bool -> PsMessage

-- | Invalid package name
PsErrInvalidPackageName :: !FastString -> PsMessage

-- | Invalid rule activation marker
PsErrInvalidRuleActivationMarker :: PsMessage

-- | Linear function found but LinearTypes not enabled
PsErrLinearFunction :: PsMessage

-- | Multi-way if-expression found but MultiWayIf not enabled
PsErrMultiWayIf :: PsMessage

-- | Explicit forall found but no extension allowing it is enabled
PsErrExplicitForall :: !Bool -> PsMessage

-- | Found qualified-do without QualifiedDo enabled
PsErrIllegalQualifiedDo :: !SDoc -> PsMessage

-- | Cmm parser error
PsErrCmmParser :: !CmmParserError -> PsMessage

-- | Illegal traditional record syntax
--   
--   TODO: distinguish errors without using SDoc
PsErrIllegalTraditionalRecordSyntax :: !SDoc -> PsMessage

-- | Parse error in command
--   
--   TODO: distinguish errors without using SDoc
PsErrParseErrorInCmd :: !SDoc -> PsMessage

-- | Parse error in pattern
PsErrInPat :: !PatBuilder GhcPs -> !PsErrInPatDetails -> PsMessage

-- | Parse error in right operator section pattern TODO: embed the proper
--   operator, if possible
PsErrParseRightOpSectionInPat :: !RdrName -> !PatBuilder GhcPs -> PsMessage

-- | Illegal linear arrow or multiplicity annotation in GADT record syntax
PsErrIllegalGadtRecordMultiplicity :: !HsArrow GhcPs -> PsMessage
PsErrInvalidCApiImport :: PsMessage
PsErrMultipleConForNewtype :: !RdrName -> !Int -> PsMessage
PsErrUnicodeCharLooksLike :: Char -> Char -> String -> PsMessage

-- | Extra details about a parse error, which helps us in determining which
--   should be the hints to suggest.
data PsErrParseDetails
PsErrParseDetails :: !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> PsErrParseDetails
[ped_th_enabled] :: PsErrParseDetails -> !Bool

-- | Is there a 'do' in the last 100 characters?
[ped_do_in_last_100] :: PsErrParseDetails -> !Bool

-- | Is there an <tt>mdo</tt> in the last 100 characters?
[ped_mdo_in_last_100] :: PsErrParseDetails -> !Bool

-- | Is <tt>PatternSynonyms</tt> enabled?
[ped_pat_syn_enabled] :: PsErrParseDetails -> !Bool

-- | Did we parse a "pattern" keyword?
[ped_pattern_parsed] :: PsErrParseDetails -> !Bool

-- | Is the parsed pattern recursive?
data PatIsRecursive
YesPatIsRecursive :: PatIsRecursive
NoPatIsRecursive :: PatIsRecursive
data PatIncompleteDoBlock
YesIncompleteDoBlock :: PatIncompleteDoBlock
NoIncompleteDoBlock :: PatIncompleteDoBlock

-- | Extra information for the expression GHC is currently
--   inspecting/parsing. It can be used to generate more informative parser
--   diagnostics and hints.
data ParseContext
ParseContext :: !Maybe RdrName -> !PatIncompleteDoBlock -> ParseContext

-- | If <a>Just</a>, this is an infix pattern with the bound operator name
[is_infix] :: ParseContext -> !Maybe RdrName

-- | Did the parser likely fail due to an incomplete do block?
[incomplete_do_block] :: ParseContext -> !PatIncompleteDoBlock
data PsErrInPatDetails

-- | Negative application pattern?
PEIP_NegApp :: PsErrInPatDetails

-- | The list of type arguments for the pattern
PEIP_TypeArgs :: [HsConPatTyArg GhcPs] -> PsErrInPatDetails
PEIP_RecPattern :: [LPat GhcPs] -> !PatIsRecursive -> !ParseContext -> PsErrInPatDetails
PEIP_OtherPatDetails :: !ParseContext -> PsErrInPatDetails
noParseContext :: ParseContext
incompleteDoBlock :: ParseContext

-- | Builds a <a>PsErrInPatDetails</a> with the information provided by the
--   <a>ParseContext</a>.
fromParseContext :: ParseContext -> PsErrInPatDetails
data NumUnderscoreReason
NumUnderscore_Integral :: NumUnderscoreReason
NumUnderscore_Float :: NumUnderscoreReason
data LexErrKind

-- | End of input
LexErrKind_EOF :: LexErrKind

-- | UTF-8 decoding error
LexErrKind_UTF8 :: LexErrKind

-- | Error at given character
LexErrKind_Char :: !Char -> LexErrKind
data LexErr

-- | Lexical error
LexError :: LexErr

-- | Unknown pragma
LexUnknownPragma :: LexErr

-- | Lexical error in pragma
LexErrorInPragma :: LexErr

-- | Numeric escape sequence out of range
LexNumEscapeRange :: LexErr

-- | Lexical error in string/character literal
LexStringCharLit :: LexErr

-- | Unexpected end-of-file in string/character literal
LexStringCharLitEOF :: LexErr

-- | Unterminated `{-'
LexUnterminatedComment :: LexErr

-- | Unterminated OPTIONS pragma
LexUnterminatedOptions :: LexErr

-- | Unterminated quasiquotation
LexUnterminatedQQ :: LexErr

-- | Errors from the Cmm parser
data CmmParserError

-- | Unknown Cmm primitive
CmmUnknownPrimitive :: !FastString -> CmmParserError

-- | Unknown macro
CmmUnknownMacro :: !FastString -> CmmParserError

-- | Unknown calling convention
CmmUnknownCConv :: !String -> CmmParserError

-- | Unrecognised safety
CmmUnrecognisedSafety :: !String -> CmmParserError

-- | Unrecognised hint
CmmUnrecognisedHint :: !String -> CmmParserError
data TransLayoutReason

-- | "`where' clause at the same depth as implicit layout block"
TransLayout_Where :: TransLayoutReason

-- | "`|' at the same depth as implicit layout block")
TransLayout_Pipe :: TransLayoutReason
data FileHeaderPragmaType
OptionsPrag :: FileHeaderPragmaType
IncludePrag :: FileHeaderPragmaType
LanguagePrag :: FileHeaderPragmaType
DocOptionsPrag :: FileHeaderPragmaType
instance GHC.Generics.Generic GHC.Parser.Errors.Types.PsHeaderMessage
instance GHC.Classes.Eq GHC.Parser.Errors.Types.PatIncompleteDoBlock
instance GHC.Classes.Eq GHC.Parser.Errors.Types.ParseContext
instance GHC.Classes.Ord GHC.Parser.Errors.Types.NumUnderscoreReason
instance GHC.Classes.Eq GHC.Parser.Errors.Types.NumUnderscoreReason
instance GHC.Show.Show GHC.Parser.Errors.Types.NumUnderscoreReason
instance GHC.Classes.Ord GHC.Parser.Errors.Types.LexErrKind
instance GHC.Classes.Eq GHC.Parser.Errors.Types.LexErrKind
instance GHC.Show.Show GHC.Parser.Errors.Types.LexErrKind
instance GHC.Generics.Generic GHC.Parser.Errors.Types.PsMessage

module GHC.HsToCore.Ticks

-- | Configuration for compilation pass to add tick for instrumentation to
--   binding sites.
data TicksConfig
TicksConfig :: ![TickishType] -> !ProfAuto -> !Bool -> TicksConfig

-- | What purposes do we need ticks for
[ticks_passes] :: TicksConfig -> ![TickishType]

-- | What kind of {-# SCC #-} to add automatically
[ticks_profAuto] :: TicksConfig -> !ProfAuto

-- | Whether to count the entries to functions
--   
--   Requires extra synchronization which can vastly degrade performance.
[ticks_countEntries] :: TicksConfig -> !Bool
data Tick
Tick :: SrcSpan -> [String] -> [OccName] -> BoxLabel -> Tick

-- | Tick source span
[tick_loc] :: Tick -> SrcSpan

-- | Path to the declaration
[tick_path] :: Tick -> [String]

-- | Identifiers being bound
[tick_ids] :: Tick -> [OccName]

-- | Label for the tick counter
[tick_label] :: Tick -> BoxLabel

-- | Reasons why we need ticks,
data TickishType

-- | For profiling
ProfNotes :: TickishType

-- | For Haskell Program Coverage
HpcTicks :: TickishType

-- | For ByteCode interpreter break points
Breakpoints :: TickishType

-- | For source notes
SourceNotes :: TickishType
addTicksToBinds :: Logger -> TicksConfig -> Module -> ModLocation -> NameSet -> [TyCon] -> LHsBinds GhcTc -> IO (LHsBinds GhcTc, Maybe (FilePath, SizedSeq Tick))
isGoodSrcSpan' :: SrcSpan -> Bool

-- | Strip CoreTicks from an HsExpr
stripTicksTopHsExpr :: HsExpr GhcTc -> ([CoreTickish], HsExpr GhcTc)
instance GHC.Classes.Eq GHC.HsToCore.Ticks.TickDensity
instance GHC.Classes.Eq GHC.HsToCore.Ticks.TickishType
instance GHC.Base.Functor GHC.HsToCore.Ticks.TM
instance GHC.Base.Applicative GHC.HsToCore.Ticks.TM
instance GHC.Base.Monad GHC.HsToCore.Ticks.TM

module GHC.HsToCore.Errors.Types
newtype MinBound
MinBound :: Integer -> MinBound
newtype MaxBound
MaxBound :: Integer -> MaxBound
type MaxUncoveredPatterns = Int
type MaxPmCheckModels = Int

-- | Diagnostics messages emitted during desugaring.
data DsMessage

-- | Simply wraps a generic <a>Diagnostic</a> message.
DsUnknownMessage :: UnknownDiagnostic -> DsMessage

-- | DsEmptyEnumeration is a warning (controlled by the
--   -Wempty-enumerations flag) that is emitted if an enumeration is empty.
--   
--   Example(s):
--   
--   main :: IO () main = do let enum = [5 .. 3] print enum
--   
--   Here <tt>enum</tt> would yield an empty list, because 5 is greater
--   than 3.
--   
--   Test case(s): warnings<i>should_compile</i>T10930
--   warnings<i>should_compile</i>T18402
--   warnings<i>should_compile</i>T10930b
--   numeric<i>should_compile</i>T10929 numeric<i>should_compile</i>T7881
--   deSugar<i>should_run</i>T18172
DsEmptyEnumeration :: DsMessage

-- | DsIdentitiesFound is a warning (controlled by the -Widentities flag)
--   that is emitted on uses of Prelude numeric conversions that are
--   probably the identity (and hence could be omitted).
--   
--   Example(s):
--   
--   main :: IO () main = do let x = 10 print $ conv 10
--   
--   where conv :: Int -&gt; Int conv x = fromIntegral x
--   
--   Here calling <tt>conv</tt> is essentially the identity function, and
--   therefore can be omitted.
--   
--   Test case(s): deSugar<i>should_compile</i>T4488
DsIdentitiesFound :: !Id -> !Type -> DsMessage
DsOverflowedLiterals :: !Integer -> !Name -> !Maybe (MinBound, MaxBound) -> !NegLiteralExtEnabled -> DsMessage
DsRedundantBangPatterns :: !HsMatchContext GhcRn -> !SDoc -> DsMessage
DsOverlappingPatterns :: !HsMatchContext GhcRn -> !SDoc -> DsMessage
DsInaccessibleRhs :: !HsMatchContext GhcRn -> !SDoc -> DsMessage
DsMaxPmCheckModelsReached :: !MaxPmCheckModels -> DsMessage
DsNonExhaustivePatterns :: !HsMatchContext GhcRn -> !ExhaustivityCheckType -> !MaxUncoveredPatterns -> [Id] -> [Nabla] -> DsMessage
DsTopLevelBindsNotAllowed :: !BindsType -> !HsBindLR GhcTc GhcTc -> DsMessage
DsUselessSpecialiseForClassMethodSelector :: !Id -> DsMessage
DsUselessSpecialiseForNoInlineFunction :: !Id -> DsMessage
DsMultiplicityCoercionsNotSupported :: DsMessage
DsOrphanRule :: !CoreRule -> DsMessage
DsRuleLhsTooComplicated :: !CoreExpr -> !CoreExpr -> DsMessage
DsRuleIgnoredDueToConstructor :: !DataCon -> DsMessage
DsRuleBindersNotBound :: ![Var] -> ![Var] -> !CoreExpr -> !CoreExpr -> DsMessage
DsLazyPatCantBindVarsOfUnliftedType :: [Var] -> DsMessage
DsNotYetHandledByTH :: !ThRejectionReason -> DsMessage
DsAggregatedViewExpressions :: [[LHsExpr GhcTc]] -> DsMessage
DsUnbangedStrictPatterns :: !HsBindLR GhcTc GhcTc -> DsMessage
DsCannotMixPolyAndUnliftedBindings :: !HsBindLR GhcTc GhcTc -> DsMessage
DsWrongDoBind :: !LHsExpr GhcTc -> !Type -> DsMessage
DsUnusedDoBind :: !LHsExpr GhcTc -> !Type -> DsMessage
DsRecBindsNotAllowedForUnliftedTys :: ![LHsBindLR GhcTc GhcTc] -> DsMessage
DsRuleMightInlineFirst :: !RuleName -> !Var -> !Activation -> DsMessage
DsAnotherRuleMightFireFirst :: !RuleName -> !RuleName -> !Var -> DsMessage
newtype DsArgNum
DsArgNum :: Int -> DsArgNum

-- | Why TemplateHaskell rejected the splice. Used in the
--   <a>DsNotYetHandledByTH</a> constructor of a <a>DsMessage</a>.
data ThRejectionReason
ThAmbiguousRecordUpdates :: !HsRecUpdField GhcRn -> ThRejectionReason
ThAbstractClosedTypeFamily :: !LFamilyDecl GhcRn -> ThRejectionReason
ThForeignLabel :: !CLabelString -> ThRejectionReason
ThForeignExport :: !LForeignDecl GhcRn -> ThRejectionReason
ThMinimalPragmas :: ThRejectionReason
ThSCCPragmas :: ThRejectionReason
ThNoUserInline :: ThRejectionReason
ThExoticFormOfType :: !HsType GhcRn -> ThRejectionReason
ThAmbiguousRecordSelectors :: !HsExpr GhcRn -> ThRejectionReason
ThMonadComprehensionSyntax :: !HsExpr GhcRn -> ThRejectionReason
ThCostCentres :: !HsExpr GhcRn -> ThRejectionReason
ThExpressionForm :: !HsExpr GhcRn -> ThRejectionReason
ThExoticStatement :: [Stmt GhcRn (LHsExpr GhcRn)] -> ThRejectionReason
ThExoticLiteral :: !HsLit GhcRn -> ThRejectionReason
ThExoticPattern :: !Pat GhcRn -> ThRejectionReason
ThGuardedLambdas :: !Match GhcRn (LHsExpr GhcRn) -> ThRejectionReason
ThNegativeOverloadedPatterns :: !Pat GhcRn -> ThRejectionReason
ThHaddockDocumentation :: ThRejectionReason
ThWarningAndDeprecationPragmas :: [LIdP GhcRn] -> ThRejectionReason
ThSplicesWithinDeclBrackets :: ThRejectionReason
ThNonLinearDataCon :: ThRejectionReason
data NegLiteralExtEnabled
YesUsingNegLiterals :: NegLiteralExtEnabled
NotUsingNegLiterals :: NegLiteralExtEnabled
negLiteralExtEnabled :: DynFlags -> NegLiteralExtEnabled
newtype ExhaustivityCheckType
ExhaustivityCheckType :: Maybe WarningFlag -> ExhaustivityCheckType
data BindsType
UnliftedTypeBinds :: BindsType
StrictBinds :: BindsType
instance GHC.Generics.Generic GHC.HsToCore.Errors.Types.DsMessage


-- | Compute the <a>Type</a> of an <tt><a>HsExpr</a> <a>GhcPass</a></tt> in
--   a pure fashion.
--   
--   Note that this does <i>not</i> currently support the use case of
--   annotating every subexpression in an <a>HsExpr</a> with its
--   <a>Type</a>. For more information on this task, see #12706, #15320,
--   #16804, and #17331.
module GHC.Hs.Syn.Type

-- | Compute the <a>Type</a> of an <tt><a>LHsExpr</a> <a>GhcPass</a></tt>
--   in a pure fashion.
lhsExprType :: LHsExpr GhcTc -> Type

-- | Compute the <a>Type</a> of an <tt><a>HsExpr</a> <a>GhcPass</a></tt> in
--   a pure fashion.
hsExprType :: HsExpr GhcTc -> Type
hsWrapperType :: HsWrapper -> Type -> Type
hsLitType :: HsLit (GhcPass p) -> Type
hsPatType :: Pat GhcTc -> Type
hsLPatType :: LPat GhcTc -> Type


-- | Statistics for per-module compilations
--   
--   (c) The GRASP/AQUA Project, Glasgow University, 1993-1998
module GHC.Hs.Stats

-- | Source Statistics
ppSourceStats :: Bool -> Located (HsModule GhcPs) -> SDoc


-- | Contains a debug function to dump parts of the GHC.Hs AST. It uses a
--   syb traversal which falls back to displaying based on the constructor
--   name, so can be used to dump anything having a <tt>Data.Data</tt>
--   instance.
module GHC.Hs.Dump

-- | Show a GHC syntax tree. This parameterised because it is also used for
--   comparing ASTs in ppr roundtripping tests, where the SrcSpan's are
--   blanked out, to avoid comparing locations, only structure
showAstData :: Data a => BlankSrcSpan -> BlankEpAnnotations -> a -> SDoc

-- | Show the full AST as the compiler sees it.
showAstDataFull :: Data a => a -> SDoc

-- | Should source spans be removed from output.
data BlankSrcSpan
BlankSrcSpan :: BlankSrcSpan
BlankSrcSpanFile :: BlankSrcSpan
NoBlankSrcSpan :: BlankSrcSpan

-- | Should EpAnnotations be removed from output.
data BlankEpAnnotations
BlankEpAnnotations :: BlankEpAnnotations
NoBlankEpAnnotations :: BlankEpAnnotations
instance GHC.Show.Show GHC.Hs.Dump.BlankSrcSpan
instance GHC.Classes.Eq GHC.Hs.Dump.BlankSrcSpan
instance GHC.Show.Show GHC.Hs.Dump.BlankEpAnnotations
instance GHC.Classes.Eq GHC.Hs.Dump.BlankEpAnnotations


-- | This is the syntax for bkp files which are parsed in 'ghc --backpack'
--   mode. This syntax is used purely for testing purposes.
module GHC.Driver.Backpack.Syntax
data HsUnitId n
HsUnitId :: Located n -> [LHsModuleSubst n] -> HsUnitId n
type LHsUnitId n = Located (HsUnitId n)
type HsModuleSubst n = (Located ModuleName, LHsModuleId n)
type LHsModuleSubst n = Located (HsModuleSubst n)
data HsModuleId n
HsModuleVar :: Located ModuleName -> HsModuleId n
HsModuleId :: LHsUnitId n -> Located ModuleName -> HsModuleId n
type LHsModuleId n = Located (HsModuleId n)
data HsComponentId
HsComponentId :: PackageName -> UnitId -> HsComponentId
[hsPackageName] :: HsComponentId -> PackageName
[hsComponentId] :: HsComponentId -> UnitId
type LHsUnit n = Located (HsUnit n)

-- | Top level <tt>unit</tt> declaration in a Backpack file.
data HsUnit n
HsUnit :: Located n -> [LHsUnitDecl n] -> HsUnit n
[hsunitName] :: HsUnit n -> Located n
[hsunitBody] :: HsUnit n -> [LHsUnitDecl n]
type LHsUnitDecl n = Located (HsUnitDecl n)

-- | A declaration in a package, e.g. a module or signature definition, or
--   an include.
data HsUnitDecl n
DeclD :: HscSource -> Located ModuleName -> Located (HsModule GhcPs) -> HsUnitDecl n
IncludeD :: IncludeDecl n -> HsUnitDecl n

-- | An include of another unit
data IncludeDecl n
IncludeDecl :: LHsUnitId n -> Maybe [LRenaming] -> Bool -> IncludeDecl n
[idUnitId] :: IncludeDecl n -> LHsUnitId n
[idModRenaming] :: IncludeDecl n -> Maybe [LRenaming]

-- | Is this a <tt>dependency signature</tt> include? If so, we don't
--   compile this include when we instantiate this unit (as there should
--   not be any modules brought into scope.)
[idSignatureInclude] :: IncludeDecl n -> Bool
type LRenaming = Located Renaming

-- | Rename a module from one name to another. The identity renaming means
--   that the module should be brought into scope.
data Renaming
Renaming :: Located ModuleName -> Maybe (Located ModuleName) -> Renaming
[renameFrom] :: Renaming -> Located ModuleName
[renameTo] :: Renaming -> Maybe (Located ModuleName)
instance GHC.Utils.Outputable.Outputable GHC.Driver.Backpack.Syntax.HsComponentId


-- | Printing related functions that depend on session state (DynFlags)
module GHC.Driver.Ppr

-- | Show a SDoc as a String with the default user style
showSDoc :: DynFlags -> SDoc -> String
showSDocUnsafe :: SDoc -> String

-- | Allows caller to specify the NamePprCtx to use
showSDocForUser :: DynFlags -> UnitState -> NamePprCtx -> SDoc -> String
showPpr :: Outputable a => DynFlags -> a -> String
showPprUnsafe :: Outputable a => a -> String
printForUser :: DynFlags -> Handle -> NamePprCtx -> Depth -> SDoc -> IO ()

module GHC.Driver.Errors.Types

-- | The umbrella type that encompasses all the different messages that GHC
--   might output during the different compilation stages. See Note
--   [GhcMessage].
data GhcMessage

-- | A message from the parsing phase.
[GhcPsMessage] :: PsMessage -> GhcMessage

-- | A message from typecheck/renaming phase.
[GhcTcRnMessage] :: TcRnMessage -> GhcMessage

-- | A message from the desugaring (HsToCore) phase.
[GhcDsMessage] :: DsMessage -> GhcMessage

-- | A message from the driver.
[GhcDriverMessage] :: DriverMessage -> GhcMessage

-- | An "escape" hatch which can be used when we don't know the source of
--   the message or if the message is not one of the typed ones. The
--   <a>Diagnostic</a> and <a>Typeable</a> constraints ensure that if we
--   <i>know</i>, at pattern-matching time, the originating type, we can
--   attempt a cast and access the fully-structured error. This would be
--   the case for a GHC plugin that offers a domain-specific error type but
--   that doesn't want to place the burden on IDEs/application code to
--   "know" it. The <a>Diagnostic</a> constraint ensures that worst case
--   scenario we can still render this into something which can be
--   eventually converted into a <a>DecoratedSDoc</a>.
[GhcUnknownMessage] :: UnknownDiagnostic -> GhcMessage
data GhcMessageOpts
GhcMessageOpts :: DiagnosticOpts PsMessage -> DiagnosticOpts TcRnMessage -> DiagnosticOpts DsMessage -> DiagnosticOpts DriverMessage -> GhcMessageOpts
[psMessageOpts] :: GhcMessageOpts -> DiagnosticOpts PsMessage
[tcMessageOpts] :: GhcMessageOpts -> DiagnosticOpts TcRnMessage
[dsMessageOpts] :: GhcMessageOpts -> DiagnosticOpts DsMessage
[driverMessageOpts] :: GhcMessageOpts -> DiagnosticOpts DriverMessage

-- | A message from the driver.
data DriverMessage

-- | Simply wraps a generic <a>Diagnostic</a> message <tt>a</tt>.
[DriverUnknownMessage] :: UnknownDiagnostic -> DriverMessage

-- | A parse error in parsing a Haskell file header during dependency
--   analysis
[DriverPsHeaderMessage] :: !PsMessage -> DriverMessage

-- | DriverMissingHomeModules is a warning (controlled with
--   -Wmissing-home-modules) that arises when running GHC in --make mode
--   when some modules needed for compilation are not included on the
--   command line. For example, if A imports B, `ghc --make A.hs` will
--   cause this warning, while `ghc --make A.hs B.hs` will not.
--   
--   Useful for cabal to ensure GHC won't pick up modules listed neither in
--   'exposed-modules' nor in 'other-modules'.
--   
--   Test case: warnings<i>should_compile</i>MissingMod
[DriverMissingHomeModules] :: UnitId -> [ModuleName] -> !BuildingCabalPackage -> DriverMessage

-- | DriverUnknown is a warning that arises when a user tries to reexport a
--   module which isn't part of that unit.
[DriverUnknownReexportedModules] :: UnitId -> [ModuleName] -> DriverMessage

-- | DriverUnknownHiddenModules is a warning that arises when a user tries
--   to hide a module which isn't part of that unit.
[DriverUnknownHiddenModules] :: UnitId -> [ModuleName] -> DriverMessage

-- | DriverUnusedPackages occurs when when package is requested on command
--   line, but was never needed during compilation. Activated by
--   -Wunused-packages.
--   
--   Test cases: warnings<i>should_compile</i>UnusedPackages
[DriverUnusedPackages] :: [(UnitId, PackageName, Version, PackageArg)] -> DriverMessage

-- | DriverUnnecessarySourceImports (controlled with -Wunused-imports)
--   occurs if there are {-# SOURCE #-} imports which are not necessary.
--   See <tt>warnUnnecessarySourceImports</tt> in <a>Make</a>.
--   
--   Test cases: warnings<i>should_compile</i>T10637
[DriverUnnecessarySourceImports] :: !ModuleName -> DriverMessage

-- | DriverDuplicatedModuleDeclaration occurs if a module <tt>A</tt> is
--   declared in multiple files.
--   
--   Test cases: None.
[DriverDuplicatedModuleDeclaration] :: !Module -> [FilePath] -> DriverMessage

-- | DriverModuleNotFound occurs if a module <tt>A</tt> can't be found.
--   
--   Test cases: None.
[DriverModuleNotFound] :: !ModuleName -> DriverMessage

-- | DriverFileModuleNameMismatch occurs if a module <tt>A</tt> is defined
--   in a file with a different name. The first field is the name written
--   in the source code; the second argument is the name extracted from the
--   filename.
--   
--   Test cases: module<i>mod178, </i>driver/bug1677
[DriverFileModuleNameMismatch] :: !ModuleName -> !ModuleName -> DriverMessage

-- | DriverUnexpectedSignature occurs when GHC encounters a module
--   <tt>A</tt> that imports a signature file which is neither in the
--   <tt>signatures</tt> section of a '.cabal' file nor in any package in
--   the home modules.
--   
--   Example:
--   
--   <ul>
--   <li>- MyStr.hsig is defined, but not added to <tt>signatures</tt> in
--   the '.cabal' file. signature MyStr where data Str</li>
--   <li>- A.hs, which tries to import the signature. module A where import
--   MyStr</li>
--   </ul>
--   
--   Test cases: driver/T12955
[DriverUnexpectedSignature] :: !ModuleName -> !BuildingCabalPackage -> GenInstantiations UnitId -> DriverMessage

-- | DriverFileNotFound occurs when the input file (e.g. given on the
--   command line) can't be found.
--   
--   Test cases: None.
[DriverFileNotFound] :: !FilePath -> DriverMessage

-- | DriverStaticPointersNotSupported occurs when the
--   <tt>StaticPointers</tt> extension is used in an interactive GHCi
--   context.
--   
--   Test cases: ghci<i>scripts</i>StaticPtr
[DriverStaticPointersNotSupported] :: DriverMessage

-- | DriverBackpackModuleNotFound occurs when Backpack can't find a
--   particular module during its dependency analysis.
--   
--   Test cases: -
[DriverBackpackModuleNotFound] :: !ModuleName -> DriverMessage

-- | DriverUserDefinedRuleIgnored is a warning that occurs when
--   user-defined rules are ignored. This typically happens when Safe
--   Haskell.
--   
--   Test cases:
--   
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn05
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn06
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn07
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered11
--   tests<i>safeHaskell</i>safeLanguage/SafeLang03
[DriverUserDefinedRuleIgnored] :: !RuleDecl GhcTc -> DriverMessage

-- | DriverMixedSafetyImport is an error that occurs when a module is
--   imported both as safe and unsafe.
--   
--   Test cases:
--   
--   tests<i>safeHaskell</i>safeInfered/Mixed03
--   tests<i>safeHaskell</i>safeInfered/Mixed02
[DriverMixedSafetyImport] :: !ModuleName -> DriverMessage

-- | DriverCannotLoadInterfaceFile is an error that occurs when we cannot
--   load the interface file for a particular module. This can happen for
--   example in the context of Safe Haskell, when we have to load a module
--   to check if it can be safely imported.
--   
--   Test cases: None.
[DriverCannotLoadInterfaceFile] :: !Module -> DriverMessage

-- | DriverInferredSafeImport is a warning (controlled by the Opt_WarnSafe
--   flag) that occurs when a module is inferred safe.
--   
--   Test cases: None.
[DriverInferredSafeModule] :: !Module -> DriverMessage

-- | DriverMarkedTrustworthyButInferredSafe is a warning (controlled by the
--   Opt_WarnTrustworthySafe flag) that occurs when a module is marked
--   trustworthy in SafeHaskell but it has been inferred safe.
--   
--   Test cases: tests<i>safeHaskell</i>safeInfered/TrustworthySafe02
--   tests<i>safeHaskell</i>safeInfered/TrustworthySafe03
[DriverMarkedTrustworthyButInferredSafe] :: !Module -> DriverMessage

-- | DriverInferredSafeImport is a warning (controlled by the
--   Opt_WarnInferredSafeImports flag) that occurs when a safe-inferred
--   module is imported from a safe module.
--   
--   Test cases: None.
[DriverInferredSafeImport] :: !Module -> DriverMessage

-- | DriverCannotImportUnsafeModule is an error that occurs when an usafe
--   module is being imported from a safe one.
--   
--   Test cases: None.
[DriverCannotImportUnsafeModule] :: !Module -> DriverMessage

-- | DriverMissingSafeHaskellMode is a warning (controlled by the
--   Opt_WarnMissingSafeHaskellMode flag) that occurs when a module is
--   using SafeHaskell features but SafeHaskell mode is not enabled.
--   
--   Test cases: None.
[DriverMissingSafeHaskellMode] :: !Module -> DriverMessage

-- | DriverPackageNotTrusted is an error that occurs when a package is
--   required to be trusted but it isn't.
--   
--   Test cases: tests<i>safeHaskell</i>check/Check01
--   tests<i>safeHaskell</i>check/Check08
--   tests<i>safeHaskell</i>check/Check06
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafeOnly09
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafe03
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafeOnly07
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafeOnly08
[DriverPackageNotTrusted] :: !UnitState -> !UnitId -> DriverMessage

-- | DriverCannotImportFromUntrustedPackage is an error that occurs in the
--   context of Safe Haskell when trying to import a module coming from an
--   untrusted package.
--   
--   Test cases: tests<i>safeHaskell</i>check/Check09
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafe01
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafe04
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafeOnly03
--   tests<i>safeHaskell</i>check<i>pkg01</i>ImpSafeOnly05
--   tests<i>safeHaskell</i>flags/SafeFlags17
--   tests<i>safeHaskell</i>flags/SafeFlags22
--   tests<i>safeHaskell</i>flags/SafeFlags23
--   tests<i>safeHaskell</i>ghci/p11 tests<i>safeHaskell</i>ghci/p12
--   tests<i>safeHaskell</i>ghci/p17 tests<i>safeHaskell</i>ghci/p3
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered01
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered02
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered02
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered03
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered05
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered06
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered09
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered10
--   tests<i>safeHaskell</i>safeInfered/UnsafeInfered11
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn01
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn03
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn04
--   tests<i>safeHaskell</i>safeInfered/UnsafeWarn05
--   tests<i>safeHaskell</i>unsafeLibs/BadImport01
--   tests<i>safeHaskell</i>unsafeLibs/BadImport06
--   tests<i>safeHaskell</i>unsafeLibs/BadImport07
--   tests<i>safeHaskell</i>unsafeLibs/BadImport08
--   tests<i>safeHaskell</i>unsafeLibs/BadImport09
--   tests<i>safeHaskell</i>unsafeLibs/Dep05
--   tests<i>safeHaskell</i>unsafeLibs/Dep06
--   tests<i>safeHaskell</i>unsafeLibs/Dep07
--   tests<i>safeHaskell</i>unsafeLibs/Dep08
--   tests<i>safeHaskell</i>unsafeLibs/Dep09
--   tests<i>safeHaskell</i>unsafeLibs/Dep10
[DriverCannotImportFromUntrustedPackage] :: !UnitState -> !Module -> DriverMessage
[DriverRedirectedNoMain] :: !ModuleName -> DriverMessage
[DriverHomePackagesNotClosed] :: ![UnitId] -> DriverMessage
data DriverMessageOpts
DriverMessageOpts :: DiagnosticOpts PsMessage -> DriverMessageOpts
[psDiagnosticOpts] :: DriverMessageOpts -> DiagnosticOpts PsMessage

-- | A collection of driver messages
type DriverMessages = Messages DriverMessage
data PsMessage

-- | A group of parser messages emitted in <a>Header</a>. See Note
--   [Messages from GHC.Parser.Header].
PsHeaderMessage :: !PsHeaderMessage -> PsMessage

-- | Pass to a <a>DriverMessage</a> the information whether or not the
--   '-fbuilding-cabal-package' flag is set.
data BuildingCabalPackage
YesBuildingCabalPackage :: BuildingCabalPackage
NoBuildingCabalPackage :: BuildingCabalPackage

-- | A collection of warning messages. <i>INVARIANT</i>: Each
--   <a>GhcMessage</a> in the collection should have <a>SevWarning</a>
--   severity.
type WarningMessages = Messages GhcMessage

-- | A collection of error messages. <i>INVARIANT</i>: Each
--   <a>GhcMessage</a> in the collection should have <a>SevError</a>
--   severity.
type ErrorMessages = Messages GhcMessage

-- | A single warning message. <i>INVARIANT</i>: It must have
--   <a>SevWarning</a> severity.
type WarnMsg = MsgEnvelope GhcMessage

-- | Creates a new <a>GhcMessage</a> out of any diagnostic. This function
--   is also provided to ease the integration of #18516 by allowing
--   diagnostics to be wrapped into the general (but structured)
--   <a>GhcMessage</a> type, so that the conversion can happen gradually.
--   This function should not be needed within GHC, as it would typically
--   be used by plugin or library authors (see comment for the
--   <a>GhcUnknownMessage</a> type constructor)
ghcUnknownMessage :: (DiagnosticOpts a ~ NoDiagnosticOpts, Diagnostic a, Typeable a) => a -> GhcMessage

-- | Abstracts away the frequent pattern where we are calling
--   <tt>ioMsgMaybe</tt> on the result of 'IO (Messages TcRnMessage, a)'.
hoistTcRnMessage :: Monad m => m (Messages TcRnMessage, a) -> m (Messages GhcMessage, a)

-- | Abstracts away the frequent pattern where we are calling
--   <tt>ioMsgMaybe</tt> on the result of 'IO (Messages DsMessage, a)'.
hoistDsMessage :: Monad m => m (Messages DsMessage, a) -> m (Messages GhcMessage, a)

-- | Checks if we are building a cabal package by consulting the
--   <a>DynFlags</a>.
checkBuildingCabalPackage :: DynFlags -> BuildingCabalPackage
instance GHC.Classes.Eq GHC.Driver.Errors.Types.BuildingCabalPackage
instance GHC.Generics.Generic GHC.Driver.Errors.Types.GhcMessage
instance GHC.Generics.Generic GHC.Driver.Errors.Types.DriverMessage


-- | Defines diagnostic codes for the diagnostics emitted by GHC.
--   
--   A diagnostic code is a numeric unique identifier for a diagnostic. See
--   Note [Diagnostic codes].
module GHC.Types.Error.Codes

-- | This function obtain a diagnostic code by looking up the constructor
--   name using generics, and using the <a>GhcDiagnosticCode</a> type
--   family.
constructorCode :: (Generic diag, GDiagnosticCode (Rep diag)) => diag -> Maybe DiagnosticCode
instance GHC.Types.Error.Codes.KnownConstructor con => GHC.Types.Error.Codes.ConstructorCode con f 'GHC.Maybe.Nothing
instance GHC.Types.Error.Codes.HasTypeProd ty (GHC.Types.Error.Codes.HasTypeQ ty f) orig f g => GHC.Types.Error.Codes.HasType ty orig (f GHC.Generics.:*: g)
instance forall a ty (orig :: GHC.Types.Symbol) (f :: * -> *) (l :: a) (g :: * -> *). GHC.Types.Error.Codes.HasType ty orig f => GHC.Types.Error.Codes.HasTypeProd ty ('GHC.Maybe.Just l) orig f g
instance GHC.Types.Error.Codes.HasType ty orig g => GHC.Types.Error.Codes.HasTypeProd ty 'GHC.Maybe.Nothing orig f g
instance (GHC.Types.Error.Codes.ConRecursInto con GHC.Types.~ 'GHC.Maybe.Just GHC.Types.Error.UnknownDiagnostic, GHC.Types.Error.Codes.HasType GHC.Types.Error.UnknownDiagnostic con f) => GHC.Types.Error.Codes.ConstructorCode con f ('GHC.Maybe.Just GHC.Types.Error.UnknownDiagnostic)
instance (GHC.Types.Error.Codes.ConRecursInto con GHC.Types.~ 'GHC.Maybe.Just ty, GHC.Types.Error.Codes.HasType ty con f, GHC.Generics.Generic ty, GHC.Types.Error.Codes.GDiagnosticCode (GHC.Generics.Rep ty)) => GHC.Types.Error.Codes.ConstructorCode con f ('GHC.Maybe.Just ty)
instance GHC.Types.Error.Codes.HasType ty orig (GHC.Generics.M1 i s (GHC.Generics.K1 x ty))
instance (TypeError ...) => GHC.Types.Error.Codes.HasType ty orig f
instance (GHC.Types.Error.Codes.ConstructorCode con f recur, recur GHC.Types.~ GHC.Types.Error.Codes.ConRecursInto con) => GHC.Types.Error.Codes.GDiagnosticCode (GHC.Generics.M1 i ('GHC.Generics.MetaCons con x y) f)
instance (GHC.Types.Error.Codes.GDiagnosticCode f, GHC.Types.Error.Codes.GDiagnosticCode g) => GHC.Types.Error.Codes.GDiagnosticCode (f GHC.Generics.:+: g)
instance GHC.Types.Error.Codes.GDiagnosticCode f => GHC.Types.Error.Codes.GDiagnosticCode (GHC.Generics.M1 i ('GHC.Generics.MetaData nm mod pkg nt) f)

module GHC.Tc.Errors.Ppr
pprTypeDoesNotHaveFixedRuntimeRep :: Type -> FixedRuntimeRepProvenance -> SDoc
pprScopeError :: RdrName -> NotInScopeError -> SDoc
tidySkolemInfo :: TidyEnv -> SkolemInfo -> SkolemInfo
tidySkolemInfoAnon :: TidyEnv -> SkolemInfoAnon -> SkolemInfoAnon
pprHsDocContext :: HsDocContext -> SDoc
inHsDocContext :: HsDocContext -> SDoc
data TcRnMessageOpts
TcRnMessageOpts :: !Bool -> TcRnMessageOpts

-- | Whether we show the error context or not
[tcOptsShowContext] :: TcRnMessageOpts -> !Bool
instance GHC.Types.Error.Diagnostic GHC.Tc.Errors.Types.TcRnMessage
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.SolverReportErrCtxt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Types.ImportError

module GHC.Parser.Errors.Ppr
psHeaderMessageDiagnostic :: PsHeaderMessage -> DecoratedSDoc
psHeaderMessageReason :: PsHeaderMessage -> DiagnosticReason
psHeaderMessageHints :: PsHeaderMessage -> [GhcHint]
suggestParensAndBlockArgs :: [GhcHint]
pp_unexpected_fun_app :: Outputable a => SDoc -> a -> SDoc
parse_error_in_pat :: SDoc
forallSym :: Bool -> SDoc
pprFileHeaderPragmaType :: FileHeaderPragmaType -> SDoc
instance GHC.Types.Error.Diagnostic GHC.Parser.Errors.Types.PsMessage

module GHC.Parser.Lexer
data Token
ITas :: Token
ITcase :: Token
ITclass :: Token
ITdata :: Token
ITdefault :: Token
ITderiving :: Token
ITdo :: Maybe FastString -> Token
ITelse :: Token
IThiding :: Token
ITforeign :: Token
ITif :: Token
ITimport :: Token
ITin :: Token
ITinfix :: Token
ITinfixl :: Token
ITinfixr :: Token
ITinstance :: Token
ITlet :: Token
ITmodule :: Token
ITnewtype :: Token
ITof :: Token
ITqualified :: Token
ITthen :: Token
ITtype :: Token
ITwhere :: Token
ITforall :: IsUnicodeSyntax -> Token
ITexport :: Token
ITlabel :: Token
ITdynamic :: Token
ITsafe :: Token
ITinterruptible :: Token
ITunsafe :: Token
ITstdcallconv :: Token
ITccallconv :: Token
ITcapiconv :: Token
ITprimcallconv :: Token
ITjavascriptcallconv :: Token
ITmdo :: Maybe FastString -> Token
ITfamily :: Token
ITrole :: Token
ITgroup :: Token
ITby :: Token
ITusing :: Token
ITpattern :: Token
ITstatic :: Token
ITstock :: Token
ITanyclass :: Token
ITvia :: Token
ITunit :: Token
ITsignature :: Token
ITdependency :: Token
ITrequires :: Token
ITinline_prag :: SourceText -> InlineSpec -> RuleMatchInfo -> Token
ITopaque_prag :: SourceText -> Token
ITspec_prag :: SourceText -> Token
ITspec_inline_prag :: SourceText -> Bool -> Token
ITsource_prag :: SourceText -> Token
ITrules_prag :: SourceText -> Token
ITwarning_prag :: SourceText -> Token
ITdeprecated_prag :: SourceText -> Token
ITline_prag :: SourceText -> Token
ITcolumn_prag :: SourceText -> Token
ITscc_prag :: SourceText -> Token
ITunpack_prag :: SourceText -> Token
ITnounpack_prag :: SourceText -> Token
ITann_prag :: SourceText -> Token
ITcomplete_prag :: SourceText -> Token
ITclose_prag :: Token
IToptions_prag :: String -> Token
ITinclude_prag :: String -> Token
ITlanguage_prag :: Token
ITminimal_prag :: SourceText -> Token
IToverlappable_prag :: SourceText -> Token
IToverlapping_prag :: SourceText -> Token
IToverlaps_prag :: SourceText -> Token
ITincoherent_prag :: SourceText -> Token
ITctype :: SourceText -> Token
ITcomment_line_prag :: Token
ITdotdot :: Token
ITcolon :: Token
ITdcolon :: IsUnicodeSyntax -> Token
ITequal :: Token
ITlam :: Token
ITlcase :: Token
ITlcases :: Token
ITvbar :: Token
ITlarrow :: IsUnicodeSyntax -> Token
ITrarrow :: IsUnicodeSyntax -> Token
ITdarrow :: IsUnicodeSyntax -> Token
ITlolly :: Token
ITminus :: Token
ITprefixminus :: Token
ITbang :: Token
ITtilde :: Token
ITat :: Token
ITtypeApp :: Token
ITpercent :: Token
ITstar :: IsUnicodeSyntax -> Token
ITdot :: Token
ITproj :: Bool -> Token
ITbiglam :: Token
ITocurly :: Token
ITccurly :: Token
ITvocurly :: Token
ITvccurly :: Token
ITobrack :: Token
ITopabrack :: Token
ITcpabrack :: Token
ITcbrack :: Token
IToparen :: Token
ITcparen :: Token
IToubxparen :: Token
ITcubxparen :: Token
ITsemi :: Token
ITcomma :: Token
ITunderscore :: Token
ITbackquote :: Token
ITsimpleQuote :: Token
ITvarid :: FastString -> Token
ITconid :: FastString -> Token
ITvarsym :: FastString -> Token
ITconsym :: FastString -> Token
ITqvarid :: (FastString, FastString) -> Token
ITqconid :: (FastString, FastString) -> Token
ITqvarsym :: (FastString, FastString) -> Token
ITqconsym :: (FastString, FastString) -> Token
ITdupipvarid :: FastString -> Token
ITlabelvarid :: SourceText -> FastString -> Token
ITchar :: SourceText -> Char -> Token
ITstring :: SourceText -> FastString -> Token
ITinteger :: IntegralLit -> Token
ITrational :: FractionalLit -> Token
ITprimchar :: SourceText -> Char -> Token
ITprimstring :: SourceText -> ByteString -> Token
ITprimint :: SourceText -> Integer -> Token
ITprimword :: SourceText -> Integer -> Token
ITprimfloat :: FractionalLit -> Token
ITprimdouble :: FractionalLit -> Token
ITopenExpQuote :: HasE -> IsUnicodeSyntax -> Token
ITopenPatQuote :: Token
ITopenDecQuote :: Token
ITopenTypQuote :: Token
ITcloseQuote :: IsUnicodeSyntax -> Token
ITopenTExpQuote :: HasE -> Token
ITcloseTExpQuote :: Token
ITdollar :: Token
ITdollardollar :: Token
ITtyQuote :: Token
ITquasiQuote :: (FastString, FastString, PsSpan) -> Token
ITqQuasiQuote :: (FastString, FastString, FastString, PsSpan) -> Token
ITproc :: Token
ITrec :: Token

-- | <pre>
--   (|
--   </pre>
IToparenbar :: IsUnicodeSyntax -> Token

-- | <pre>
--   |)
--   </pre>
ITcparenbar :: IsUnicodeSyntax -> Token

-- | <pre>
--   -&lt;
--   </pre>
ITlarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   &gt;-
--   </pre>
ITrarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   -&lt;&lt;
--   </pre>
ITLarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   &gt;&gt;-
--   </pre>
ITRarrowtail :: IsUnicodeSyntax -> Token

-- | Used when the lexer can't make sense of it
ITunknown :: String -> Token

-- | end of file token
ITeof :: Token

-- | The HsDocString contains more details about what this is and how to
--   pretty print it
ITdocComment :: HsDocString -> PsSpan -> Token

-- | doc options (prune, ignore-exports, etc)
ITdocOptions :: String -> PsSpan -> Token

-- | comment starting by "--"
ITlineComment :: String -> PsSpan -> Token

-- | comment in {- -}
ITblockComment :: String -> PsSpan -> Token
lexer :: Bool -> (Located Token -> P a) -> P a
lexerDbg :: Bool -> (Located Token -> P a) -> P a

-- | Parser options.
--   
--   See <a>mkParserOpts</a> to construct this.
data ParserOpts
ParserOpts :: !ExtsBitmap -> !DiagOpts -> [String] -> ParserOpts

-- | bitmap of permitted extensions
[pExtsBitmap] :: ParserOpts -> !ExtsBitmap

-- | Options to construct diagnostic messages.
[pDiagOpts] :: ParserOpts -> !DiagOpts

-- | supported extensions (only used for suggestions in error messages)
[pSupportedExts] :: ParserOpts -> [String]

-- | Given exactly the information needed, set up the <a>ParserOpts</a>
mkParserOpts :: EnumSet Extension -> DiagOpts -> [String] -> Bool -> Bool -> Bool -> Bool -> ParserOpts
data PState
PState :: StringBuffer -> ParserOpts -> Messages PsMessage -> Messages PsMessage -> Maybe RealSrcSpan -> !Word -> Maybe (PsLocated Token) -> PsSpan -> PsSpan -> PsSpan -> !Int -> PsLoc -> [LayoutContext] -> [Int] -> [FastString] -> [PsLocated Token] -> Maybe (PsLocated Token) -> PsSpan -> [ALRContext] -> Maybe ALRLayout -> Bool -> Maybe (Pair RealSrcSpan RealSrcSpan) -> Maybe [LEpaComment] -> [LEpaComment] -> OrdList (PsLocated HdkComment) -> PState
[buffer] :: PState -> StringBuffer
[options] :: PState -> ParserOpts
[warnings] :: PState -> Messages PsMessage
[errors] :: PState -> Messages PsMessage
[tab_first] :: PState -> Maybe RealSrcSpan
[tab_count] :: PState -> !Word
[last_tk] :: PState -> Maybe (PsLocated Token)
[prev_loc] :: PState -> PsSpan
[prev_loc2] :: PState -> PsSpan
[last_loc] :: PState -> PsSpan
[last_len] :: PState -> !Int
[loc] :: PState -> PsLoc
[context] :: PState -> [LayoutContext]
[lex_state] :: PState -> [Int]
[srcfiles] :: PState -> [FastString]
[alr_pending_implicit_tokens] :: PState -> [PsLocated Token]
[alr_next_token] :: PState -> Maybe (PsLocated Token)
[alr_last_loc] :: PState -> PsSpan
[alr_context] :: PState -> [ALRContext]
[alr_expecting_ocurly] :: PState -> Maybe ALRLayout
[alr_justClosedExplicitLetBlock] :: PState -> Bool
[eof_pos] :: PState -> Maybe (Pair RealSrcSpan RealSrcSpan)
[header_comments] :: PState -> Maybe [LEpaComment]
[comment_q] :: PState -> [LEpaComment]
[hdk_comments] :: PState -> OrdList (PsLocated HdkComment)

-- | Creates a parse state from a <a>ParserOpts</a> value
initParserState :: ParserOpts -> StringBuffer -> RealSrcLoc -> PState

-- | Set parser options for parsing OPTIONS pragmas
initPragState :: ParserOpts -> StringBuffer -> RealSrcLoc -> PState

-- | The parsing monad, isomorphic to <tt>StateT PState Maybe</tt>.
newtype P a
P :: (PState -> ParseResult a) -> P a
[unP] :: P a -> PState -> ParseResult a

-- | The result of running a parser.
data ParseResult a

-- | The parser has consumed a (possibly empty) prefix of the input and
--   produced a result. Use <a>getPsMessages</a> to check for accumulated
--   warnings and non-fatal errors.
--   
--   The carried parsing state can be used to resume parsing.
pattern POk :: PState -> a -> ParseResult a

-- | The parser has consumed a (possibly empty) prefix of the input and
--   failed.
--   
--   The carried parsing state can be used to resume parsing. It is the
--   state right before failure, including the fatal parse error.
--   <a>getPsMessages</a> and <a>getPsErrorMessages</a> must return a
--   non-empty bag of errors.
pattern PFailed :: PState -> ParseResult a
allocateComments :: RealSrcSpan -> [LEpaComment] -> ([LEpaComment], [LEpaComment])
allocatePriorComments :: RealSrcSpan -> [LEpaComment] -> Maybe [LEpaComment] -> (Maybe [LEpaComment], [LEpaComment], [LEpaComment])
allocateFinalComments :: RealSrcSpan -> [LEpaComment] -> Maybe [LEpaComment] -> (Maybe [LEpaComment], [LEpaComment], [LEpaComment])

-- | An mtl-style class for monads that support parsing-related operations.
--   For example, sometimes we make a second pass over the parsing results
--   to validate, disambiguate, or rearrange them, and we do so in the PV
--   monad which cannot consume input but can report parsing errors, check
--   for extension bits, and accumulate parsing annotations. Both P and PV
--   are instances of MonadP.
--   
--   MonadP grants us convenient overloading. The other option is to have
--   separate operations for each monad: addErrorP vs addErrorPV, getBitP
--   vs getBitPV, and so on.
class Monad m => MonadP m

-- | Add a non-fatal error. Use this when the parser can produce a result
--   despite the error.
--   
--   For example, when GHC encounters a <tt>forall</tt> in a type, but
--   <tt>-XExplicitForAll</tt> is disabled, the parser constructs
--   <tt>ForAllTy</tt> as if <tt>-XExplicitForAll</tt> was enabled, adding
--   a non-fatal error to the accumulator.
--   
--   Control flow wise, non-fatal errors act like warnings: they are added
--   to the accumulator and parsing continues. This allows GHC to report
--   more than one parse error per file.
addError :: MonadP m => MsgEnvelope PsMessage -> m ()

-- | Add a warning to the accumulator. Use <a>getPsMessages</a> to get the
--   accumulated warnings.
addWarning :: MonadP m => MsgEnvelope PsMessage -> m ()

-- | Add a fatal error. This will be the last error reported by the parser,
--   and the parser will not produce any result, ending in a <a>PFailed</a>
--   state.
addFatalError :: MonadP m => MsgEnvelope PsMessage -> m a

-- | Check if a given flag is currently set in the bitmap.
getBit :: MonadP m => ExtBits -> m Bool

-- | Go through the <tt>comment_q</tt> in <tt>PState</tt> and remove all
--   comments that belong within the given span
allocateCommentsP :: MonadP m => RealSrcSpan -> m EpAnnComments

-- | Go through the <tt>comment_q</tt> in <tt>PState</tt> and remove all
--   comments that come before or within the given span
allocatePriorCommentsP :: MonadP m => RealSrcSpan -> m EpAnnComments

-- | Go through the <tt>comment_q</tt> in <tt>PState</tt> and remove all
--   comments that come after the given span
allocateFinalCommentsP :: MonadP m => RealSrcSpan -> m EpAnnComments
getRealSrcLoc :: P RealSrcLoc
getPState :: P PState
failMsgP :: (SrcSpan -> MsgEnvelope PsMessage) -> P a
failLocMsgP :: RealSrcLoc -> RealSrcLoc -> (SrcSpan -> MsgEnvelope PsMessage) -> P a
srcParseFail :: P a

-- | Get a bag of the errors that have been accumulated so far. Does not
--   take -Werror into account.
getPsErrorMessages :: PState -> Messages PsMessage

-- | Get the warnings and errors accumulated so far. Does not take -Werror
--   into account.
getPsMessages :: PState -> (Messages PsMessage, Messages PsMessage)
popContext :: P ()
pushModuleContext :: P ()
setLastToken :: PsSpan -> Int -> P ()
setSrcLoc :: RealSrcLoc -> P ()
activeContext :: P Bool
nextIsEOF :: P Bool
getLexState :: P Int
popLexState :: P Int
pushLexState :: Int -> P ()

-- | Various boolean flags, mostly language extensions, that impact lexing
--   and parsing. Note that a handful of these can change during
--   lexing/parsing.
data ExtBits
FfiBit :: ExtBits
InterruptibleFfiBit :: ExtBits
CApiFfiBit :: ExtBits
ArrowsBit :: ExtBits
ThBit :: ExtBits
ThQuotesBit :: ExtBits
IpBit :: ExtBits
OverloadedLabelsBit :: ExtBits
ExplicitForallBit :: ExtBits
BangPatBit :: ExtBits
PatternSynonymsBit :: ExtBits
HaddockBit :: ExtBits
MagicHashBit :: ExtBits
RecursiveDoBit :: ExtBits
QualifiedDoBit :: ExtBits
UnicodeSyntaxBit :: ExtBits
UnboxedParensBit :: ExtBits
DatatypeContextsBit :: ExtBits
MonadComprehensionsBit :: ExtBits
TransformComprehensionsBit :: ExtBits
QqBit :: ExtBits
RawTokenStreamBit :: ExtBits
AlternativeLayoutRuleBit :: ExtBits
ALRTransitionalBit :: ExtBits
RelaxedLayoutBit :: ExtBits
NondecreasingIndentationBit :: ExtBits
SafeHaskellBit :: ExtBits
TraditionalRecordSyntaxBit :: ExtBits
ExplicitNamespacesBit :: ExtBits
LambdaCaseBit :: ExtBits
BinaryLiteralsBit :: ExtBits
NegativeLiteralsBit :: ExtBits
HexFloatLiteralsBit :: ExtBits
StaticPointersBit :: ExtBits
NumericUnderscoresBit :: ExtBits
StarIsTypeBit :: ExtBits
BlockArgumentsBit :: ExtBits
NPlusKPatternsBit :: ExtBits
DoAndIfThenElseBit :: ExtBits
MultiWayIfBit :: ExtBits
GadtSyntaxBit :: ExtBits
ImportQualifiedPostBit :: ExtBits
LinearTypesBit :: ExtBits
NoLexicalNegationBit :: ExtBits
OverloadedRecordDotBit :: ExtBits
OverloadedRecordUpdateBit :: ExtBits
InRulePragBit :: ExtBits
InNestedCommentBit :: ExtBits

-- | If this is enabled, '{-# LINE ... -#}' and '{-# COLUMN ... #-}' update
--   the internal position. Otherwise, those pragmas are lexed as tokens of
--   their own.
UsePosPragsBit :: ExtBits
xtest :: ExtBits -> ExtsBitmap -> Bool
xunset :: ExtBits -> ExtsBitmap -> ExtsBitmap
xset :: ExtBits -> ExtsBitmap -> ExtsBitmap
disableHaddock :: ParserOpts -> ParserOpts
lexTokenStream :: ParserOpts -> StringBuffer -> RealSrcLoc -> ParseResult [Located Token]

-- | Given a <a>RealSrcSpan</a> that surrounds a <tt>HsPar</tt> or
--   <tt>HsParTy</tt>, generate <a>AddEpAnn</a> values for the opening and
--   closing bordering on the start and end of the span
mkParensEpAnn :: RealSrcSpan -> (AddEpAnn, AddEpAnn)
getCommentsFor :: MonadP m => SrcSpan -> m EpAnnComments
getPriorCommentsFor :: MonadP m => SrcSpan -> m EpAnnComments
getFinalCommentsFor :: MonadP m => SrcSpan -> m EpAnnComments
getEofPos :: P (Maybe (Pair RealSrcSpan RealSrcSpan))
commentToAnnotation :: RealLocated Token -> LEpaComment

-- | Haddock comment as produced by the lexer. These are accumulated in
--   <a>PState</a> and then processed in
--   <a>GHC.Parser.PostProcess.Haddock</a>. The location of the
--   <a>HsDocString</a>s spans over the contents of the docstring - i.e. it
--   does not include the decorator ("-- |", "{-|" etc.)
data HdkComment
HdkCommentNext :: HsDocString -> HdkComment
HdkCommentPrev :: HsDocString -> HdkComment
HdkCommentNamed :: String -> HsDocString -> HdkComment
HdkCommentSection :: Int -> HsDocString -> HdkComment

-- | Test whether a <a>WarningFlag</a> is set
warnopt :: WarningFlag -> ParserOpts -> Bool
adjustChar :: Char -> Word8
addPsMessage :: SrcSpan -> PsMessage -> P ()
instance GHC.Show.Show GHC.Parser.Lexer.OpWs
instance GHC.Show.Show GHC.Parser.Lexer.Token
instance GHC.Show.Show GHC.Parser.Lexer.LayoutContext
instance GHC.Show.Show GHC.Parser.Lexer.HdkComment
instance GHC.Enum.Enum GHC.Parser.Lexer.ExtBits
instance GHC.Parser.Lexer.MonadP GHC.Parser.Lexer.P
instance GHC.Base.Functor GHC.Parser.Lexer.P
instance GHC.Base.Applicative GHC.Parser.Lexer.P
instance GHC.Base.Monad GHC.Parser.Lexer.P
instance GHC.Utils.Outputable.Outputable GHC.Parser.Lexer.Token

module GHC.Parser.PostProcess
mkRdrGetField :: SrcSpanAnnA -> LHsExpr GhcPs -> LocatedAn NoEpAnns (DotFieldOcc GhcPs) -> EpAnnCO -> LHsExpr GhcPs
mkRdrProjection :: NonEmpty (LocatedAn NoEpAnns (DotFieldOcc GhcPs)) -> EpAnn AnnProjection -> HsExpr GhcPs
type Fbind b = Either (LHsRecField GhcPs (LocatedA b)) (LHsRecProj GhcPs (LocatedA b))

-- | A useful function for building <tt>OpApps</tt>. The operator is always
--   a variable, and we don't know the fixity yet.
mkHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsIntegral :: IntegralLit -> HsOverLit GhcPs
mkHsFractional :: FractionalLit -> HsOverLit GhcPs
mkHsIsString :: SourceText -> FastString -> HsOverLit GhcPs
mkHsDo :: HsDoFlavour -> LocatedL [ExprLStmt GhcPs] -> HsExpr GhcPs
mkSpliceDecl :: LHsExpr GhcPs -> P (LHsDecl GhcPs)
mkRoleAnnotDecl :: SrcSpan -> LocatedN RdrName -> [Located (Maybe FastString)] -> [AddEpAnn] -> P (LRoleAnnotDecl GhcPs)
mkClassDecl :: SrcSpan -> Located (Maybe (LHsContext GhcPs), LHsType GhcPs) -> Located (a, [LHsFunDep GhcPs]) -> OrdList (LHsDecl GhcPs) -> LayoutInfo GhcPs -> [AddEpAnn] -> P (LTyClDecl GhcPs)
mkTyData :: SrcSpan -> Bool -> NewOrData -> Maybe (LocatedP CType) -> Located (Maybe (LHsContext GhcPs), LHsType GhcPs) -> Maybe (LHsKind GhcPs) -> [LConDecl GhcPs] -> Located (HsDeriving GhcPs) -> [AddEpAnn] -> P (LTyClDecl GhcPs)
mkDataFamInst :: SrcSpan -> NewOrData -> Maybe (LocatedP CType) -> (Maybe (LHsContext GhcPs), HsOuterFamEqnTyVarBndrs GhcPs, LHsType GhcPs) -> Maybe (LHsKind GhcPs) -> [LConDecl GhcPs] -> Located (HsDeriving GhcPs) -> [AddEpAnn] -> P (LInstDecl GhcPs)
mkTySynonym :: SrcSpan -> LHsType GhcPs -> LHsType GhcPs -> [AddEpAnn] -> P (LTyClDecl GhcPs)
mkTyFamInstEqn :: SrcSpan -> HsOuterFamEqnTyVarBndrs GhcPs -> LHsType GhcPs -> LHsType GhcPs -> [AddEpAnn] -> P (LTyFamInstEqn GhcPs)
mkStandaloneKindSig :: SrcSpan -> Located [LocatedN RdrName] -> LHsSigType GhcPs -> [AddEpAnn] -> P (LStandaloneKindSig GhcPs)
mkTyFamInst :: SrcSpan -> TyFamInstEqn GhcPs -> [AddEpAnn] -> P (LInstDecl GhcPs)
mkFamDecl :: SrcSpan -> FamilyInfo GhcPs -> TopLevelFlag -> LHsType GhcPs -> LFamilyResultSig GhcPs -> Maybe (LInjectivityAnn GhcPs) -> [AddEpAnn] -> P (LTyClDecl GhcPs)
mkInlinePragma :: SourceText -> (InlineSpec, RuleMatchInfo) -> Maybe Activation -> InlinePragma
mkOpaquePragma :: SourceText -> InlinePragma
mkPatSynMatchGroup :: LocatedN RdrName -> LocatedL (OrdList (LHsDecl GhcPs)) -> P (MatchGroup GhcPs (LHsExpr GhcPs))
mkRecConstrOrUpdate :: Bool -> LHsExpr GhcPs -> SrcSpan -> ([Fbind (HsExpr GhcPs)], Maybe SrcSpan) -> EpAnn [AddEpAnn] -> PV (HsExpr GhcPs)

-- | mkClassDecl builds a RdrClassDecl, filling in the names for tycon and
--   datacon by deriving them from the name of the class. We fill in the
--   names for the tycon and datacon corresponding to the class, by
--   deriving them from the name of the class itself. This saves recording
--   the names in the interface file (which would be equally good).
mkTyClD :: LTyClDecl (GhcPass p) -> LHsDecl (GhcPass p)
mkInstD :: LInstDecl (GhcPass p) -> LHsDecl (GhcPass p)
mkRdrRecordCon :: LocatedN RdrName -> HsRecordBinds GhcPs -> EpAnn [AddEpAnn] -> HsExpr GhcPs
mkRdrRecordUpd :: Bool -> LHsExpr GhcPs -> [Fbind (HsExpr GhcPs)] -> EpAnn [AddEpAnn] -> PV (HsExpr GhcPs)

-- | This rather gruesome function is used mainly by the parser. When
--   parsing:
--   
--   <pre>
--   data T a = T | T1 Int
--   </pre>
--   
--   we parse the data constructors as <i>types</i> because of parser
--   ambiguities, so then we need to change the <i>type constr</i> to a
--   <i>data constr</i>
--   
--   The exact-name case <i>can</i> occur when parsing:
--   
--   <pre>
--   data [] a = [] | a : [a]
--   </pre>
--   
--   For the exact-name case we return an original name.
setRdrNameSpace :: RdrName -> NameSpace -> RdrName

-- | Converts <a>LHsTyVarBndr</a> annotated with its <a>Specificity</a> to
--   one without annotations. Only accepts specified variables, and errors
--   if the provided binder has an <a>InferredSpec</a> annotation.
fromSpecTyVarBndr :: LHsTyVarBndr Specificity GhcPs -> P (LHsTyVarBndr () GhcPs)

-- | Converts a list of <a>LHsTyVarBndr</a>s annotated with their
--   <a>Specificity</a> to binders without annotations. Only accepts
--   specified variables, and errors if any of the provided binders has an
--   <a>InferredSpec</a> annotation.
fromSpecTyVarBndrs :: [LHsTyVarBndr Specificity GhcPs] -> P [LHsTyVarBndr () GhcPs]

-- | Add the annotation for a 'where' keyword to existing
--   <tt>HsLocalBinds</tt>
annBinds :: AddEpAnn -> EpAnnComments -> HsLocalBinds GhcPs -> (HsLocalBinds GhcPs, Maybe EpAnnComments)
fixValbindsAnn :: EpAnn AnnList -> EpAnn AnnList

-- | The <a>Anchor</a> for a stmtlist is based on either the location or
--   the first semicolon annotion.
stmtsAnchor :: Located (OrdList AddEpAnn, a) -> Anchor
stmtsLoc :: Located (OrdList AddEpAnn, a) -> SrcSpan
cvBindGroup :: OrdList (LHsDecl GhcPs) -> P (HsValBinds GhcPs)
cvBindsAndSigs :: OrdList (LHsDecl GhcPs) -> P (LHsBinds GhcPs, [LSig GhcPs], [LFamilyDecl GhcPs], [LTyFamInstDecl GhcPs], [LDataFamInstDecl GhcPs], [LDocDecl GhcPs])

-- | Function definitions are restructured here. Each is assumed to be
--   recursive initially, and non recursive definitions are discovered by
--   the dependency analyser.
cvTopDecls :: OrdList (LHsDecl GhcPs) -> [LHsDecl GhcPs]
placeHolderPunRhs :: DisambECP b => PV (LocatedA b)
mkImport :: Located CCallConv -> Located Safety -> (Located StringLiteral, LocatedN RdrName, LHsSigType GhcPs) -> P (EpAnn [AddEpAnn] -> HsDecl GhcPs)
parseCImport :: Located CCallConv -> Located Safety -> FastString -> String -> Located SourceText -> Maybe (ForeignImport (GhcPass p))
mkExport :: Located CCallConv -> (Located StringLiteral, LocatedN RdrName, LHsSigType GhcPs) -> P (EpAnn [AddEpAnn] -> HsDecl GhcPs)
mkExtName :: RdrName -> CLabelString

-- | Construct a GADT-style data constructor from the constructor names and
--   their type. Some interesting aspects of this function:
--   
--   <ul>
--   <li>This splits up the constructor type into its quantified type
--   variables (if provided), context (if provided), argument types, and
--   result type, and records whether this is a prefix or record GADT
--   constructor. See Note [GADT abstract syntax] in <a>GHC.Hs.Decls</a>
--   for more details.</li>
--   </ul>
mkGadtDecl :: SrcSpan -> NonEmpty (LocatedN RdrName) -> LHsUniToken "::" "∷" GhcPs -> LHsSigType GhcPs -> P (LConDecl GhcPs)
mkConDeclH98 :: EpAnn [AddEpAnn] -> LocatedN RdrName -> Maybe [LHsTyVarBndr Specificity GhcPs] -> Maybe (LHsContext GhcPs) -> HsConDeclH98Details GhcPs -> ConDecl GhcPs
checkImportDecl :: Maybe EpaLocation -> Maybe EpaLocation -> P ()

-- | Yield a parse error if we have a function applied directly to a do
--   block etc. and BlockArguments is not enabled.
checkExpBlockArguments :: LHsExpr GhcPs -> PV ()
checkCmdBlockArguments :: LHsCmd GhcPs -> PV ()

-- | Check if a fixity is valid. We support bypassing the usual bound
--   checks for some special operators.
checkPrecP :: Located (SourceText, Int) -> Located (OrdList (LocatedN RdrName)) -> P ()

-- | Validate the context constraints and break up a context into a list of
--   predicates.
--   
--   <pre>
--   (Eq a, Ord b)        --&gt;  [Eq a, Ord b]
--   Eq a                 --&gt;  [Eq a]
--   (Eq a)               --&gt;  [Eq a]
--   (((Eq a)))           --&gt;  [Eq a]
--   </pre>
checkContext :: LHsType GhcPs -> P (LHsContext GhcPs)
checkPattern :: LocatedA (PatBuilder GhcPs) -> P (LPat GhcPs)
checkPattern_details :: ParseContext -> PV (LocatedA (PatBuilder GhcPs)) -> P (LPat GhcPs)
incompleteDoBlock :: ParseContext

-- | Extra information for the expression GHC is currently
--   inspecting/parsing. It can be used to generate more informative parser
--   diagnostics and hints.
data ParseContext
ParseContext :: !Maybe RdrName -> !PatIncompleteDoBlock -> ParseContext

-- | If <a>Just</a>, this is an infix pattern with the bound operator name
[is_infix] :: ParseContext -> !Maybe RdrName

-- | Did the parser likely fail due to an incomplete do block?
[incomplete_do_block] :: ParseContext -> !PatIncompleteDoBlock

-- | Check for monad comprehensions
--   
--   If the flag MonadComprehensions is set, return a <a>MonadComp</a>
--   context, otherwise use the usual <a>ListComp</a> context
checkMonadComp :: PV HsDoFlavour
checkValDef :: SrcSpan -> LocatedA (PatBuilder GhcPs) -> Maybe (AddEpAnn, LHsType GhcPs) -> Located (GRHSs GhcPs (LHsExpr GhcPs)) -> P (HsBind GhcPs)
checkValSigLhs :: LHsExpr GhcPs -> P (LocatedN RdrName)
type LRuleTyTmVar = LocatedAn NoEpAnns RuleTyTmVar

-- | Essentially a wrapper for a <tt>RuleBndr GhcPs</tt>
data RuleTyTmVar
RuleTyTmVar :: EpAnn [AddEpAnn] -> LocatedN RdrName -> Maybe (LHsType GhcPs) -> RuleTyTmVar
mkRuleBndrs :: [LRuleTyTmVar] -> [LRuleBndr GhcPs]
mkRuleTyVarBndrs :: [LRuleTyTmVar] -> [LHsTyVarBndr () GhcPs]
checkRuleTyVarBndrNames :: [LHsTyVarBndr flag GhcPs] -> P ()
checkRecordSyntax :: (MonadP m, Outputable a) => LocatedA a -> m (LocatedA a)

-- | Check if the gadt_constrlist is empty. Only raise parse error for
--   `data T where` to avoid affecting existing error message, see #8258.
checkEmptyGADTs :: Located ([AddEpAnn], [LConDecl GhcPs]) -> P (Located ([AddEpAnn], [LConDecl GhcPs]))

-- | Add a fatal error. This will be the last error reported by the parser,
--   and the parser will not produce any result, ending in a <a>PFailed</a>
--   state.
addFatalError :: MonadP m => MsgEnvelope PsMessage -> m a

-- | Hint about bang patterns, assuming <tt>BangPatterns</tt> is off.
hintBangPat :: SrcSpan -> Pat GhcPs -> PV ()
mkBangTy :: EpAnn [AddEpAnn] -> SrcStrictness -> LHsType GhcPs -> HsType GhcPs

-- | Result of parsing <tt>{-# UNPACK #-}</tt> or <tt>{-# NOUNPACK
--   #-}</tt>.
data UnpackednessPragma
UnpackednessPragma :: [AddEpAnn] -> SourceText -> SrcUnpackedness -> UnpackednessPragma
mkMultTy :: LHsToken "%" GhcPs -> LHsType GhcPs -> LHsUniToken "->" "→" GhcPs -> HsArrow GhcPs
mkTokenLocation :: SrcSpan -> TokenLocation
data ImpExpSubSpec
ImpExpAbs :: ImpExpSubSpec
ImpExpAll :: ImpExpSubSpec
ImpExpList :: [LocatedA ImpExpQcSpec] -> ImpExpSubSpec
ImpExpAllWith :: [LocatedA ImpExpQcSpec] -> ImpExpSubSpec
data ImpExpQcSpec
ImpExpQcName :: LocatedN RdrName -> ImpExpQcSpec
ImpExpQcType :: EpaLocation -> LocatedN RdrName -> ImpExpQcSpec
ImpExpQcWildcard :: ImpExpQcSpec
mkModuleImpExp :: [AddEpAnn] -> LocatedA ImpExpQcSpec -> ImpExpSubSpec -> P (IE GhcPs)
mkTypeImpExp :: LocatedN RdrName -> P (LocatedN RdrName)
mkImpExpSubSpec :: [LocatedA ImpExpQcSpec] -> P ([AddEpAnn], ImpExpSubSpec)
checkImportSpec :: LocatedL [LIE GhcPs] -> P (LocatedL [LIE GhcPs])
starSym :: Bool -> FastString
warnStarIsType :: SrcSpan -> P ()
warnPrepositiveQualifiedModule :: SrcSpan -> P ()
failOpFewArgs :: MonadP m => LocatedN RdrName -> m a
failNotEnabledImportQualifiedPost :: SrcSpan -> P ()
failImportQualifiedTwice :: SrcSpan -> P ()
data SumOrTuple b

-- | Last two are the locations of the '|' before and after the payload
Sum :: ConTag -> Arity -> LocatedA b -> [EpaLocation] -> [EpaLocation] -> SumOrTuple b
Tuple :: [Either (EpAnn EpaLocation) (LocatedA b)] -> SumOrTuple b
data PV a
runPV :: PV a -> P a
newtype ECP
ECP :: (forall b. DisambECP b => PV (LocatedA b)) -> ECP
[unECP] :: ECP -> forall b. DisambECP b => PV (LocatedA b)

-- | Disambiguate infix operators. See Note [Ambiguous syntactic
--   categories]
class DisambInfixOp b
mkHsVarOpPV :: DisambInfixOp b => LocatedN RdrName -> PV (LocatedN b)
mkHsConOpPV :: DisambInfixOp b => LocatedN RdrName -> PV (LocatedN b)
mkHsInfixHolePV :: DisambInfixOp b => SrcSpan -> (EpAnnComments -> EpAnn EpAnnUnboundVar) -> PV (Located b)

-- | Disambiguate constructs that may appear when we do not know ahead of
--   time whether we are parsing an expression, a command, or a pattern.
--   See Note [Ambiguous syntactic categories]
class (b ~ (Body b) GhcPs, AnnoBody b) => DisambECP b where {
    
    -- | See Note [Body in DisambECP]
    type Body b :: Type -> Type;
    
    -- | Infix operator representation
    type InfixOp b;
    
    -- | Function argument representation
    type FunArg b;
}

-- | Return a command without ambiguity, or fail in a non-command context.
ecpFromCmd' :: DisambECP b => LHsCmd GhcPs -> PV (LocatedA b)

-- | Return an expression without ambiguity, or fail in a non-expression
--   context.
ecpFromExp' :: DisambECP b => LHsExpr GhcPs -> PV (LocatedA b)
mkHsProjUpdatePV :: DisambECP b => SrcSpan -> Located [LocatedAn NoEpAnns (DotFieldOcc GhcPs)] -> LocatedA b -> Bool -> [AddEpAnn] -> PV (LHsRecProj GhcPs (LocatedA b))

-- | Disambiguate "... -&gt; ..." (lambda)
mkHsLamPV :: DisambECP b => SrcSpan -> (EpAnnComments -> MatchGroup GhcPs (LocatedA b)) -> PV (LocatedA b)

-- | Disambiguate "let ... in ..."
mkHsLetPV :: DisambECP b => SrcSpan -> LHsToken "let" GhcPs -> HsLocalBinds GhcPs -> LHsToken "in" GhcPs -> LocatedA b -> PV (LocatedA b)

-- | Bring superclass constraints on InfixOp into scope. See Note
--   [UndecidableSuperClasses for associated types]
superInfixOp :: DisambECP b => (DisambInfixOp (InfixOp b) => PV (LocatedA b)) -> PV (LocatedA b)

-- | Disambiguate "f # x" (infix operator)
mkHsOpAppPV :: DisambECP b => SrcSpan -> LocatedA b -> LocatedN (InfixOp b) -> LocatedA b -> PV (LocatedA b)

-- | Disambiguate "case ... of ..."
mkHsCasePV :: DisambECP b => SrcSpan -> LHsExpr GhcPs -> LocatedL [LMatch GhcPs (LocatedA b)] -> EpAnnHsCase -> PV (LocatedA b)

-- | Disambiguate "case" and "cases"
mkHsLamCasePV :: DisambECP b => SrcSpan -> LamCaseVariant -> LocatedL [LMatch GhcPs (LocatedA b)] -> [AddEpAnn] -> PV (LocatedA b)

-- | Bring superclass constraints on FunArg into scope. See Note
--   [UndecidableSuperClasses for associated types]
superFunArg :: DisambECP b => (DisambECP (FunArg b) => PV (LocatedA b)) -> PV (LocatedA b)

-- | Disambiguate "f x" (function application)
mkHsAppPV :: DisambECP b => SrcSpanAnnA -> LocatedA b -> LocatedA (FunArg b) -> PV (LocatedA b)

-- | Disambiguate "f @t" (visible type application)
mkHsAppTypePV :: DisambECP b => SrcSpanAnnA -> LocatedA b -> LHsToken "@" GhcPs -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate "if ... then ... else ..."
mkHsIfPV :: DisambECP b => SrcSpan -> LHsExpr GhcPs -> Bool -> LocatedA b -> Bool -> LocatedA b -> AnnsIf -> PV (LocatedA b)

-- | Disambiguate "do { ... }" (do notation)
mkHsDoPV :: DisambECP b => SrcSpan -> Maybe ModuleName -> LocatedL [LStmt GhcPs (LocatedA b)] -> AnnList -> PV (LocatedA b)

-- | Disambiguate "( ... )" (parentheses)
mkHsParPV :: DisambECP b => SrcSpan -> LHsToken "(" GhcPs -> LocatedA b -> LHsToken ")" GhcPs -> PV (LocatedA b)

-- | Disambiguate a variable "f" or a data constructor <a>MkF</a>.
mkHsVarPV :: DisambECP b => LocatedN RdrName -> PV (LocatedA b)

-- | Disambiguate a monomorphic literal
mkHsLitPV :: DisambECP b => Located (HsLit GhcPs) -> PV (Located b)

-- | Disambiguate an overloaded literal
mkHsOverLitPV :: DisambECP b => LocatedAn a (HsOverLit GhcPs) -> PV (LocatedAn a b)

-- | Disambiguate a wildcard
mkHsWildCardPV :: DisambECP b => SrcSpan -> PV (Located b)

-- | Disambiguate "a :: t" (type annotation)
mkHsTySigPV :: DisambECP b => SrcSpanAnnA -> LocatedA b -> LHsType GhcPs -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "[a,b,c]" (list syntax)
mkHsExplicitListPV :: DisambECP b => SrcSpan -> [LocatedA b] -> AnnList -> PV (LocatedA b)

-- | Disambiguate "$(...)" and "[quasi|...|]" (TH splices)
mkHsSplicePV :: DisambECP b => Located (HsUntypedSplice GhcPs) -> PV (Located b)

-- | Disambiguate "f { a = b, ... }" syntax (record construction and record
--   updates)
mkHsRecordPV :: DisambECP b => Bool -> SrcSpan -> SrcSpan -> LocatedA b -> ([Fbind b], Maybe SrcSpan) -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "-a" (negation)
mkHsNegAppPV :: DisambECP b => SrcSpan -> LocatedA b -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "(# a)" (right operator section)
mkHsSectionR_PV :: DisambECP b => SrcSpan -> LocatedA (InfixOp b) -> LocatedA b -> PV (Located b)

-- | Disambiguate "(a -&gt; b)" (view pattern)
mkHsViewPatPV :: DisambECP b => SrcSpan -> LHsExpr GhcPs -> LocatedA b -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "a@b" (as-pattern)
mkHsAsPatPV :: DisambECP b => SrcSpan -> LocatedN RdrName -> LHsToken "@" GhcPs -> LocatedA b -> PV (LocatedA b)

-- | Disambiguate "~a" (lazy pattern)
mkHsLazyPatPV :: DisambECP b => SrcSpan -> LocatedA b -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate "!a" (bang pattern)
mkHsBangPatPV :: DisambECP b => SrcSpan -> LocatedA b -> [AddEpAnn] -> PV (LocatedA b)

-- | Disambiguate tuple sections and unboxed sums
mkSumOrTuplePV :: DisambECP b => SrcSpanAnnA -> Boxity -> SumOrTuple b -> [AddEpAnn] -> PV (LocatedA b)

-- | Validate infixexp LHS to reject unwanted {-# SCC ... #-} pragmas
rejectPragmaPV :: DisambECP b => LocatedA b -> PV ()
ecpFromExp :: LHsExpr GhcPs -> ECP
ecpFromCmd :: LHsCmd GhcPs -> ECP

-- | See Note [Ambiguous syntactic categories] and Note [PatBuilder]
data PatBuilder p

-- | Disambiguate constructs that may appear when we do not know ahead of
--   time whether we are parsing a type or a newtype/data constructor.
--   
--   See Note [Ambiguous syntactic categories] for the general idea.
--   
--   See Note [Parsing data constructors is hard] for the specific issue
--   this particular class is solving.
class DisambTD b

-- | Process the head of a type-level function/constructor application,
--   i.e. the <tt>H</tt> in <tt>H a b c</tt>.
mkHsAppTyHeadPV :: DisambTD b => LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>f x</tt> (function application or prefix data
--   constructor).
mkHsAppTyPV :: DisambTD b => LocatedA b -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>f @t</tt> (visible kind application)
mkHsAppKindTyPV :: DisambTD b => LocatedA b -> SrcSpan -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>f # x</tt> (infix operator)
mkHsOpTyPV :: DisambTD b => PromotionFlag -> LHsType GhcPs -> LocatedN RdrName -> LHsType GhcPs -> PV (LocatedA b)

-- | Disambiguate <tt>{-# UNPACK #-} t</tt> (unpack/nounpack pragma)
mkUnpackednessPV :: DisambTD b => Located UnpackednessPragma -> LocatedA b -> PV (LocatedA b)

-- | Annotate a type with either an <tt>{-# UNPACK #-}</tt> or a <tt>{-#
--   NOUNPACK #-}</tt> pragma.
addUnpackednessP :: MonadP m => Located UnpackednessPragma -> LHsType GhcPs -> m (LHsType GhcPs)
dataConBuilderCon :: DataConBuilder -> LocatedN RdrName
dataConBuilderDetails :: DataConBuilder -> HsConDeclH98Details GhcPs
instance Data.Traversable.Traversable GHC.Parser.PostProcess.PV_Result
instance GHC.Base.Functor GHC.Parser.PostProcess.PV_Result
instance Data.Foldable.Foldable GHC.Parser.PostProcess.PV_Result
instance GHC.Base.Functor GHC.Parser.PostProcess.PV
instance GHC.Parser.PostProcess.DisambECP (Language.Haskell.Syntax.Expr.HsCmd GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambECP (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambECP (GHC.Parser.Types.PatBuilder GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambInfixOp (Language.Haskell.Syntax.Expr.HsExpr GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambInfixOp GHC.Types.Name.Reader.RdrName
instance GHC.Parser.PostProcess.DisambTD (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.DisambTD GHC.Parser.Types.DataConBuilder
instance GHC.Base.Applicative GHC.Parser.PostProcess.PV
instance GHC.Base.Monad GHC.Parser.PostProcess.PV
instance GHC.Parser.Lexer.MonadP GHC.Parser.PostProcess.PV

module GHC.ThToHs
convertToHsExpr :: Origin -> SrcSpan -> Exp -> Either RunSpliceFailReason (LHsExpr GhcPs)
convertToPat :: Origin -> SrcSpan -> Pat -> Either RunSpliceFailReason (LPat GhcPs)
convertToHsDecls :: Origin -> SrcSpan -> [Dec] -> Either RunSpliceFailReason [LHsDecl GhcPs]
convertToHsType :: Origin -> SrcSpan -> Type -> Either RunSpliceFailReason (LHsType GhcPs)
thRdrNameGuesses :: Name -> [RdrName]
instance GHC.Base.Functor (GHC.ThToHs.CvtM' err)
instance GHC.ThToHs.CvtFlag () ()
instance GHC.ThToHs.CvtFlag Language.Haskell.TH.Syntax.Specificity GHC.Types.Var.Specificity
instance GHC.Base.Applicative (GHC.ThToHs.CvtM' err)
instance GHC.Base.Monad (GHC.ThToHs.CvtM' err)

module GHC.Parser.HaddockLex

-- | Lex identifiers from a docstring.
lexHsDoc :: P (LocatedN RdrName) -> HsDocString -> HsDoc GhcPs

-- | Lex <a>StringLiteral</a> for warning messages
lexStringLiteral :: P (LocatedN RdrName) -> Located StringLiteral -> Located (WithHsDocIdentifiers StringLiteral GhcPs)


-- | This module implements <a>addHaddockToModule</a>, which inserts
--   Haddock comments accumulated during parsing into the AST (#17544).
--   
--   We process Haddock comments in two phases:
--   
--   <ol>
--   <li>Parse the program (via the Happy parser in <a>y</a>), generating
--   an AST, and (quite separately) a list of all the Haddock comments
--   found in the file. More precisely, the Haddock comments are
--   accumulated in the <a>hdk_comments</a> field of the <a>PState</a>, the
--   parser state (see Lexer.x):data PState = PState { ... , hdk_comments
--   :: [PsLocated HdkComment] }</li>
--   </ol>
--   
--   Each of these Haddock comments has a <a>PsSpan</a>, which gives the
--   <a>BufPos</a> of the beginning and end of the Haddock comment.
--   
--   <ol>
--   <li>Walk over the AST, attaching the Haddock comments to the correct
--   parts of the tree. This step is called <a>addHaddockToModule</a>, and
--   is implemented in this module.</li>
--   </ol>
--   
--   See Note [Adding Haddock comments to the syntax tree].
--   
--   This approach codifies an important principle:
--   
--   The presence or absence of a Haddock comment should never change the
--   parsing of a program.
--   
--   Alternative approaches that did not work properly:
--   
--   <ol>
--   <li>Using <a>RealSrcLoc</a> instead of <a>BufPos</a>. This led to
--   failures in presence of {-# LANGUAGE CPP #-} and other sources of line
--   pragmas. See documentation on <a>BufPos</a> (in GHC.Types.SrcLoc) for
--   the details.</li>
--   <li>In earlier versions of GHC, the Haddock comments were incorporated
--   into the Parser.y grammar. The parser constructed the AST and attached
--   comments to it in a single pass. See Note [Old solution: Haddock in
--   the grammar] for the details.</li>
--   </ol>
module GHC.Parser.PostProcess.Haddock

-- | Add Haddock documentation accumulated in the parser state to a parsed
--   HsModule.
--   
--   Reports badly positioned comments when -Winvalid-haddock is enabled.
addHaddockToModule :: Located (HsModule GhcPs) -> P (Located (HsModule GhcPs))
instance GHC.Base.Monoid GHC.Parser.PostProcess.Haddock.HasInnerDocs
instance GHC.Base.Semigroup GHC.Parser.PostProcess.Haddock.HasInnerDocs
instance GHC.Show.Show GHC.Parser.PostProcess.Haddock.LowerLocBound
instance GHC.Show.Show GHC.Parser.PostProcess.Haddock.UpperLocBound
instance GHC.Show.Show GHC.Parser.PostProcess.Haddock.ColumnBound
instance GHC.Base.Monad GHC.Parser.PostProcess.Haddock.HdkM
instance GHC.Base.Applicative GHC.Parser.PostProcess.Haddock.HdkM
instance GHC.Base.Functor GHC.Parser.PostProcess.Haddock.HdkM
instance GHC.Base.Functor GHC.Parser.PostProcess.Haddock.HdkA
instance GHC.Parser.PostProcess.Haddock.HasHaddock a => GHC.Parser.PostProcess.Haddock.HasHaddock [a]
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.HsModule GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedL [GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcPs)])
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Decls.HsDecl GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcPs)
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Types.SrcLoc.Located [GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcPs)])
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedC (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock a => GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcPs a)
instance GHC.Parser.PostProcess.Haddock.HasHaddock a => GHC.Parser.PostProcess.Haddock.HasHaddock (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcPs a)
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcPs))
instance GHC.Parser.PostProcess.Haddock.HasHaddock (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcPs))
instance GHC.Base.Applicative GHC.Parser.PostProcess.Haddock.HdkA
instance GHC.Base.Semigroup GHC.Parser.PostProcess.Haddock.LocRange
instance GHC.Base.Monoid GHC.Parser.PostProcess.Haddock.LocRange
instance GHC.Base.Semigroup GHC.Parser.PostProcess.Haddock.ColumnBound
instance GHC.Base.Monoid GHC.Parser.PostProcess.Haddock.ColumnBound
instance GHC.Base.Semigroup GHC.Parser.PostProcess.Haddock.UpperLocBound
instance GHC.Base.Monoid GHC.Parser.PostProcess.Haddock.UpperLocBound
instance GHC.Base.Semigroup GHC.Parser.PostProcess.Haddock.LowerLocBound
instance GHC.Base.Monoid GHC.Parser.PostProcess.Haddock.LowerLocBound

module GHC.Cmm.Parser.Config
data PDConfig
PDConfig :: !Profile -> !Bool -> PDConfig
[pdProfile] :: PDConfig -> !Profile

-- | Insert alignment checks (cf <tt>-falignment-sanitisation</tt>)
[pdSanitizeAlignment] :: PDConfig -> !Bool
data CmmParserConfig
CmmParserConfig :: !ParserOpts -> !PDConfig -> !StgToCmmConfig -> CmmParserConfig
[cmmpParserOpts] :: CmmParserConfig -> !ParserOpts
[cmmpPDConfig] :: CmmParserConfig -> !PDConfig
[cmmpStgToCmmConfig] :: CmmParserConfig -> !StgToCmmConfig

module GHC.Cmm.Parser.Monad
newtype PD a
PD :: (PDConfig -> HomeUnit -> PState -> ParseResult a) -> PD a
[unPD] :: PD a -> PDConfig -> HomeUnit -> PState -> ParseResult a
liftP :: P a -> PD a
failMsgPD :: (SrcSpan -> MsgEnvelope PsMessage) -> PD a
getPDConfig :: PD PDConfig
getProfile :: PD Profile
getPlatform :: PD Platform

-- | Return the UnitId of the home-unit. This is used to create labels.
getHomeUnitId :: PD UnitId
data PDConfig
PDConfig :: !Profile -> !Bool -> PDConfig
[pdProfile] :: PDConfig -> !Profile

-- | Insert alignment checks (cf <tt>-falignment-sanitisation</tt>)
[pdSanitizeAlignment] :: PDConfig -> !Bool
instance GHC.Base.Functor GHC.Cmm.Parser.Monad.PD
instance GHC.Base.Applicative GHC.Cmm.Parser.Monad.PD
instance GHC.Base.Monad GHC.Cmm.Parser.Monad.PD


-- | This module provides the generated Happy parser for Haskell. It
--   exports a number of parsers which may be used in any library that uses
--   the GHC API. A common usage pattern is to initialize the parser state
--   with a given string and then parse that string:
--   
--   <pre>
--   runParser :: ParserOpts -&gt; String -&gt; P a -&gt; ParseResult a
--   runParser opts str parser = unP parser parseState
--   where
--     filename = "&lt;interactive&gt;"
--     location = mkRealSrcLoc (mkFastString filename) 1 1
--     buffer = stringToStringBuffer str
--     parseState = initParserState opts buffer location
--   </pre>
module GHC.Parser

-- | Parse a Haskell module with Haddock comments. This is done in two
--   steps:
--   
--   <ul>
--   <li><a>parseModuleNoHaddock</a> to build the AST</li>
--   <li><a>addHaddockToModule</a> to insert Haddock comments into it</li>
--   </ul>
--   
--   This is the only parser entry point that deals with Haddock comments.
--   The other entry points (<a>parseDeclaration</a>,
--   <a>parseExpression</a>, etc) do not insert them into the AST.
parseModule :: P (Located (HsModule GhcPs))
parseSignature :: P (Located (HsModule GhcPs))
parseImport :: P (GenLocated SrcSpanAnnA (ImportDecl GhcPs))
parseStatement :: P (GenLocated SrcSpanAnnA (StmtLR GhcPs GhcPs (GenLocated SrcSpanAnnA (HsExpr GhcPs))))
parseBackpack :: P [LHsUnit PackageName]
parseDeclaration :: P (GenLocated SrcSpanAnnA (HsDecl GhcPs))
parseExpression :: P ECP
parsePattern :: P (GenLocated SrcSpanAnnA (Pat GhcPs))
parseTypeSignature :: P (GenLocated SrcSpanAnnA (HsDecl GhcPs))
parseStmt :: P (Maybe (GenLocated SrcSpanAnnA (StmtLR GhcPs GhcPs (GenLocated SrcSpanAnnA (HsExpr GhcPs)))))
parseIdentifier :: P (LocatedN RdrName)
parseType :: P (GenLocated SrcSpanAnnA (HsType GhcPs))
parseHeader :: P (Located (HsModule GhcPs))
parseModuleNoHaddock :: P (Located (HsModule GhcPs))

module GHC.Parser.Utils

-- | Returns <tt>True</tt> if passed string is a statement.
isStmt :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string has an import declaration.
hasImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is an import declaration.
isImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is a declaration but <b><i>not
--   a splice</i></b>.
isDecl :: ParserOpts -> String -> Bool

module GHC.HsToCore.Errors.Ppr
badMonadBind :: Type -> SDoc
pprEqn :: HsMatchContext GhcRn -> SDoc -> String -> SDoc
pprContext :: Bool -> HsMatchContext GhcRn -> SDoc -> ((SDoc -> SDoc) -> SDoc) -> SDoc
dots :: Int -> [a] -> SDoc
instance GHC.Types.Error.Diagnostic GHC.HsToCore.Errors.Types.DsMessage

module GHC.Driver.Errors.Ppr
instance GHC.Types.Error.Diagnostic GHC.Driver.Errors.Types.GhcMessage
instance GHC.Types.Error.Diagnostic GHC.Driver.Errors.Types.DriverMessage


-- | Source errors
module GHC.Types.SourceError

-- | A source error is an error that is caused by one or more errors in the
--   source code. A <a>SourceError</a> is thrown by many functions in the
--   compilation pipeline. Inside GHC these errors are merely printed via
--   <tt>log_action</tt>, but API clients may treat them differently, for
--   example, insert them into a list box. If you want the default
--   behaviour, use the idiom:
--   
--   <pre>
--   handleSourceError printExceptionAndWarnings $ do
--     ... api calls that may fail ...
--   </pre>
--   
--   The <a>SourceError</a>s error messages can be accessed via
--   <a>srcErrorMessages</a>. This list may be empty if the compiler failed
--   due to <tt>-Werror</tt> (<tt>Opt_WarnIsError</tt>).
--   
--   See <tt>printExceptionAndWarnings</tt> for more information on what to
--   take care of when writing a custom error handler.
newtype SourceError
SourceError :: Messages GhcMessage -> SourceError
mkSrcErr :: Messages GhcMessage -> SourceError
srcErrorMessages :: SourceError -> Messages GhcMessage
throwErrors :: MonadIO io => Messages GhcMessage -> io a
throwOneError :: MonadIO io => MsgEnvelope GhcMessage -> io a

-- | Perform the given action and call the exception handler if the action
--   throws a <a>SourceError</a>. See <a>SourceError</a> for more
--   information.
handleSourceError :: MonadCatch m => (SourceError -> m a) -> m a -> m a
instance GHC.Show.Show GHC.Types.SourceError.SourceError
instance GHC.Exception.Type.Exception GHC.Types.SourceError.SourceError


-- | Parsing the top of a Haskell source file to get its module name,
--   imports and options.
--   
--   (c) Simon Marlow 2005 (c) Lemmih 2006
module GHC.Parser.Header

-- | Parse the imports of a source file.
--   
--   Throws a <a>SourceError</a> if parsing fails.
getImports :: ParserOpts -> Bool -> StringBuffer -> FilePath -> FilePath -> IO (Either (Messages PsMessage) ([(RawPkgQual, Located ModuleName)], [(RawPkgQual, Located ModuleName)], Bool, Located ModuleName))
mkPrelImports :: ModuleName -> SrcSpan -> Bool -> [LImportDecl GhcPs] -> [LImportDecl GhcPs]

-- | Parse OPTIONS and LANGUAGE pragmas of the source file.
--   
--   Throws a <a>SourceError</a> if flag parsing fails (including
--   unsupported flags.)
getOptionsFromFile :: ParserOpts -> FilePath -> IO (Messages PsMessage, [Located String])

-- | Parse OPTIONS and LANGUAGE pragmas of the source file.
--   
--   Throws a <a>SourceError</a> if flag parsing fails (including
--   unsupported flags.)
getOptions :: ParserOpts -> StringBuffer -> FilePath -> (Messages PsMessage, [Located String])
toArgs :: RealSrcLoc -> String -> Either String [Located String]

-- | Complain about non-dynamic flags in OPTIONS pragmas.
--   
--   Throws a <a>SourceError</a> if the input list is non-empty claiming
--   that the input flags are unknown.
checkProcessArgsResult :: MonadIO m => [Located String] -> m ()

module GHC.Driver.Errors

-- | Given a bag of diagnostics, turn them into an exception if any has
--   <a>SevError</a>, or print them out otherwise.
printOrThrowDiagnostics :: Logger -> GhcMessageOpts -> DiagOpts -> Messages GhcMessage -> IO ()
printMessages :: forall a. Diagnostic a => Logger -> DiagnosticOpts a -> DiagOpts -> Messages a -> IO ()
handleFlagWarnings :: Logger -> GhcMessageOpts -> DiagOpts -> [Warn] -> IO ()

-- | Convert a <tt>PsError</tt> into a wrapped <a>DriverMessage</a>; use it
--   for dealing with parse errors when the driver is doing dependency
--   analysis. Defined here to avoid module loops between
--   GHC.Driver.Error.Types and GHC.Driver.Error.Ppr
mkDriverPsHeaderMessage :: MsgEnvelope PsMessage -> MsgEnvelope DriverMessage

module GHC.Driver.Config.StgToJS

-- | Initialize StgToJS settings from DynFlags
initStgToJSConfig :: DynFlags -> StgToJSConfig

module GHC.Driver.Config.StgToCmm
initStgToCmmConfig :: DynFlags -> Module -> StgToCmmConfig

module GHC.Driver.Config.Stg.Ppr

-- | Initialize STG pretty-printing options from DynFlags
initStgPprOpts :: DynFlags -> StgPprOpts

module GHC.Driver.Config.Stg.Lift
initStgLiftConfig :: DynFlags -> StgLiftConfig

module GHC.Driver.Config.Logger

-- | Initialize LogFlags from DynFlags
initLogFlags :: DynFlags -> LogFlags

module GHC.Driver.Config.Linker
initFrameworkOpts :: DynFlags -> FrameworkOpts

module GHC.Driver.Config.HsToCore.Ticks
initTicksConfig :: DynFlags -> TicksConfig

module GHC.Driver.Config.Finder

-- | Locations and information the finder cares about.
--   
--   Should be taken from <tt>DynFlags</tt> via <tt>initFinderOpts</tt>.
data FinderOpts
FinderOpts :: [FilePath] -> Bool -> Bool -> Ways -> Bool -> Maybe FilePath -> Maybe FastString -> Set ModuleName -> Set ModuleName -> Maybe FilePath -> String -> Maybe FilePath -> String -> String -> Maybe FilePath -> String -> String -> Maybe FilePath -> FinderOpts

-- | Where are we allowed to look for Modules and Source files
[finder_importPaths] :: FinderOpts -> [FilePath]

-- | When looking up a home module:
--   
--   <ul>
--   <li><a>True</a>: search interface files (e.g. in '-c' mode)</li>
--   <li><a>False</a>: search source files (e.g. in '--make' mode)</li>
--   </ul>
[finder_lookupHomeInterfaces] :: FinderOpts -> Bool

-- | Don't check that an imported interface file actually exists if it can
--   only be at one location. The interface will be reported as
--   <a>InstalledFound</a> even if the file doesn't exist, so this is only
--   useful in specific cases (e.g. to generate dependencies with `ghc -M`)
[finder_bypassHiFileCheck] :: FinderOpts -> Bool
[finder_ways] :: FinderOpts -> Ways

-- | If we encounter unknown modules, should we suggest modules that have a
--   similar name.
[finder_enableSuggestions] :: FinderOpts -> Bool
[finder_workingDirectory] :: FinderOpts -> Maybe FilePath
[finder_thisPackageName] :: FinderOpts -> Maybe FastString
[finder_hiddenModules] :: FinderOpts -> Set ModuleName
[finder_reexportedModules] :: FinderOpts -> Set ModuleName
[finder_hieDir] :: FinderOpts -> Maybe FilePath
[finder_hieSuf] :: FinderOpts -> String
[finder_hiDir] :: FinderOpts -> Maybe FilePath
[finder_hiSuf] :: FinderOpts -> String
[finder_dynHiSuf] :: FinderOpts -> String
[finder_objectDir] :: FinderOpts -> Maybe FilePath
[finder_objectSuf] :: FinderOpts -> String
[finder_dynObjectSuf] :: FinderOpts -> String
[finder_stubDir] :: FinderOpts -> Maybe FilePath

-- | Create a new <a>FinderOpts</a> from DynFlags.
initFinderOpts :: DynFlags -> FinderOpts


-- | Functions for initialising error message printing configuration from
--   the GHC session flags.
module GHC.Driver.Config.Diagnostic

-- | Initialise the general configuration for printing diagnostic messages
--   For example, this configuration controls things like whether warnings
--   are treated like errors.
initDiagOpts :: DynFlags -> DiagOpts

-- | Initialise the configuration for printing specific diagnostic messages
initPrintConfig :: DynFlags -> DiagnosticOpts GhcMessage
initPsMessageOpts :: DynFlags -> DiagnosticOpts PsMessage
initDsMessageOpts :: DynFlags -> DiagnosticOpts DsMessage
initTcMessageOpts :: DynFlags -> DiagnosticOpts TcRnMessage
initDriverMessageOpts :: DynFlags -> DiagnosticOpts DriverMessage

module GHC.Driver.Config.Parser

-- | Extracts the flags needed for parsing
initParserOpts :: DynFlags -> ParserOpts

module GHC.Driver.Config.Core.Rules

-- | Initialize RuleOpts from DynFlags
initRuleOpts :: DynFlags -> RuleOpts

module GHC.Driver.Config.Core.Opt.Arity
initArityOpts :: DynFlags -> ArityOpts

module GHC.Driver.Config.CmmToLlvm

-- | Initialize the Llvm code generator configuration from DynFlags
initLlvmCgConfig :: Logger -> LlvmConfigCache -> DynFlags -> IO LlvmCgConfig

module GHC.Driver.Config.Cmm.Parser
initCmmParserConfig :: DynFlags -> CmmParserConfig

module GHC.Driver.Config.Cmm
initCmmConfig :: DynFlags -> CmmConfig


-- | The IO Monad with an environment
--   
--   The environment is passed around as a Reader monad but as its in the
--   IO monad, mutable references can be used for updating state.
module GHC.Data.IOEnv
data IOEnv env a
failM :: IOEnv env a
failWithM :: String -> IOEnv env a
data IOEnvFailure
IOEnvFailure :: IOEnvFailure
getEnv :: IOEnv env env

-- | Perform a computation with a different environment
setEnv :: env' -> IOEnv env' a -> IOEnv env a

-- | Perform a computation with an altered environment
updEnv :: (env -> env') -> IOEnv env' a -> IOEnv env a
runIOEnv :: env -> IOEnv env a -> IO a
unsafeInterleaveM :: IOEnv env a -> IOEnv env a
uninterruptibleMaskM_ :: IOEnv env a -> IOEnv env a
tryM :: IOEnv env r -> IOEnv env (Either IOEnvFailure r)
tryAllM :: IOEnv env r -> IOEnv env (Either SomeException r)
tryMostM :: IOEnv env r -> IOEnv env (Either SomeException r)
fixM :: (a -> IOEnv env a) -> IOEnv env a

-- | A mutable variable in the <a>IO</a> monad.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; r &lt;- newIORef 0
--   
--   &gt;&gt;&gt; readIORef r
--   0
--   
--   &gt;&gt;&gt; writeIORef r 1
--   
--   &gt;&gt;&gt; readIORef r
--   1
--   
--   &gt;&gt;&gt; atomicWriteIORef r 2
--   
--   &gt;&gt;&gt; readIORef r
--   2
--   
--   &gt;&gt;&gt; modifyIORef' r (+ 1)
--   
--   &gt;&gt;&gt; readIORef r
--   3
--   
--   &gt;&gt;&gt; atomicModifyIORef' r (\a -&gt; (a + 1, ()))
--   
--   &gt;&gt;&gt; readIORef r
--   4
--   </pre>
--   
--   See also <a>STRef</a> and <a>MVar</a>.
data () => IORef a
newMutVar :: a -> IOEnv env (IORef a)
readMutVar :: IORef a -> IOEnv env a
writeMutVar :: IORef a -> a -> IOEnv env ()
updMutVar :: IORef a -> (a -> a) -> IOEnv env ()
updMutVarM :: IORef a -> (a -> IOEnv env a) -> IOEnv env ()

-- | Atomically update the reference. Does not force the evaluation of the
--   new variable contents. For strict update, use <a>atomicUpdMutVar'</a>.
atomicUpdMutVar :: IORef a -> (a -> (a, b)) -> IOEnv env b

-- | Strict variant of <a>atomicUpdMutVar</a>.
atomicUpdMutVar' :: IORef a -> (a -> (a, b)) -> IOEnv env b
instance Control.Monad.Fix.MonadFix (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.Catch.MonadMask (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.Catch.MonadCatch (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.Catch.MonadThrow (GHC.Data.IOEnv.IOEnv env)
instance GHC.Show.Show GHC.Data.IOEnv.IOEnvFailure
instance GHC.Exception.Type.Exception GHC.Data.IOEnv.IOEnvFailure
instance GHC.Base.Functor (GHC.Data.IOEnv.IOEnv env)
instance Control.Monad.IO.Class.MonadIO (GHC.Data.IOEnv.IOEnv env)
instance GHC.Base.Monad (GHC.Data.IOEnv.IOEnv m)
instance Control.Monad.Fail.MonadFail (GHC.Data.IOEnv.IOEnv m)
instance GHC.Base.Applicative (GHC.Data.IOEnv.IOEnv m)
instance GHC.Driver.Session.ContainsDynFlags env => GHC.Driver.Session.HasDynFlags (GHC.Data.IOEnv.IOEnv env)
instance GHC.Driver.Hooks.ContainsHooks env => GHC.Driver.Hooks.HasHooks (GHC.Data.IOEnv.IOEnv env)
instance GHC.Utils.Logger.ContainsLogger env => GHC.Utils.Logger.HasLogger (GHC.Data.IOEnv.IOEnv env)
instance GHC.Unit.Module.ContainsModule env => GHC.Unit.Module.HasModule (GHC.Data.IOEnv.IOEnv env)
instance GHC.Base.Alternative (GHC.Data.IOEnv.IOEnv env)
instance GHC.Base.MonadPlus (GHC.Data.IOEnv.IOEnv env)


-- | Unfolding creation
module GHC.Core.Unfold.Make

-- | There is no known <a>Unfolding</a>
noUnfolding :: Unfolding
mkUnfolding :: UnfoldingOpts -> UnfoldingSource -> Bool -> Bool -> CoreExpr -> Maybe UnfoldingCache -> Unfolding
mkCoreUnfolding :: UnfoldingSource -> Bool -> CoreExpr -> Maybe UnfoldingCache -> UnfoldingGuidance -> Unfolding
mkFinalUnfolding :: UnfoldingOpts -> UnfoldingSource -> DmdSig -> CoreExpr -> Unfolding
mkFinalUnfolding' :: UnfoldingOpts -> UnfoldingSource -> DmdSig -> CoreExpr -> Maybe UnfoldingCache -> Unfolding
mkSimpleUnfolding :: UnfoldingOpts -> CoreExpr -> Unfolding
mkWorkerUnfolding :: SimpleOpts -> (CoreExpr -> CoreExpr) -> Unfolding -> Unfolding

-- | Make an INLINE unfolding that will be used once the RHS has been
--   saturated to the given arity.
mkInlineUnfoldingWithArity :: SimpleOpts -> UnfoldingSource -> Arity -> CoreExpr -> Unfolding

-- | Make an INLINE unfolding that may be used unsaturated (ug_unsat_ok =
--   unSaturatedOk) and that is reported as having its manifest arity (the
--   number of outer lambdas applications will resolve before doing any
--   work).
mkInlineUnfoldingNoArity :: SimpleOpts -> UnfoldingSource -> CoreExpr -> Unfolding
mkInlinableUnfolding :: SimpleOpts -> UnfoldingSource -> CoreExpr -> Unfolding
mkWrapperUnfolding :: SimpleOpts -> CoreExpr -> Arity -> Unfolding

-- | Used for things that absolutely must be unfolded
mkCompulsoryUnfolding :: CoreExpr -> Unfolding

-- | Same as <a>mkCompulsoryUnfolding</a> but simplifies the unfolding
--   first
mkCompulsoryUnfolding' :: SimpleOpts -> CoreExpr -> Unfolding
mkDFunUnfolding :: [Var] -> DataCon -> [CoreExpr] -> Unfolding
mkDataConUnfolding :: CoreExpr -> Unfolding
specUnfolding :: SimpleOpts -> [Var] -> (CoreExpr -> CoreExpr) -> [CoreArg] -> Unfolding -> Unfolding

-- | Sees if the unfolding is pretty certain to inline. If so, return a
--   *stable* unfolding for it, that will always inline. The CoreExpr is
--   the WW'd and simplified RHS. In contrast, the unfolding template might
--   not have been WW'd yet.
certainlyWillInline :: UnfoldingOpts -> IdInfo -> CoreExpr -> Maybe Unfolding

module GHC.Core.SimpleOpt

-- | Simple optimiser options
data SimpleOpts
SimpleOpts :: !UnfoldingOpts -> !OptCoercionOpts -> !Bool -> SimpleOpts

-- | Unfolding options
[so_uf_opts] :: SimpleOpts -> !UnfoldingOpts

-- | Coercion optimiser options
[so_co_opts] :: SimpleOpts -> !OptCoercionOpts

-- | Eta reduction on?
[so_eta_red] :: SimpleOpts -> !Bool

-- | Default options for the Simple optimiser.
defaultSimpleOpts :: SimpleOpts
simpleOptPgm :: SimpleOpts -> Module -> CoreProgram -> [CoreRule] -> (CoreProgram, [CoreRule], CoreProgram)
simpleOptExpr :: HasDebugCallStack => SimpleOpts -> CoreExpr -> CoreExpr
simpleOptExprWith :: HasDebugCallStack => SimpleOpts -> Subst -> InExpr -> OutExpr

-- | Returns Just (bndr,rhs) if the binding is a join point: If it's a
--   JoinId, just return it If it's not yet a JoinId but is always
--   tail-called, make it into a JoinId and return it. In the latter case,
--   eta-expand the RHS if necessary, to make the lambdas explicit, as is
--   required for join points
--   
--   Precondition: the InBndr has been occurrence-analysed, so its OccInfo
--   is valid
joinPointBinding_maybe :: InBndr -> InExpr -> Maybe (InBndr, InExpr)
joinPointBindings_maybe :: [(InBndr, InExpr)] -> Maybe [(InBndr, InExpr)]

-- | Returns <tt>Just ([b1..bp], dc, [t1..tk], [x1..xn])</tt> if the
--   argument expression is a *saturated* constructor application of the
--   form <tt>let b1 in .. let bp in dc t1..tk x1 .. xn</tt>, where t1..tk
--   are the *universally-quantified* type args of <tt>dc</tt>. Floats can
--   also be (and most likely are) single-alternative case expressions. Why
--   does <a>exprIsConApp_maybe</a> return floats? We may have to look
--   through lets and cases to detect that we are in the presence of a data
--   constructor wrapper. In this case, we need to return the lets and
--   cases that we traversed. See Note [exprIsConApp_maybe on data
--   constructors with wrappers]. Data constructor wrappers are unfolded
--   late, but we really want to trigger case-of-known-constructor as early
--   as possible. See also Note [Activation for data constructor wrappers]
--   in <a>GHC.Types.Id.Make</a>.
--   
--   We also return the incoming InScopeSet, augmented with the binders
--   from any [FloatBind] that we return
exprIsConApp_maybe :: HasDebugCallStack => InScopeEnv -> CoreExpr -> Maybe (InScopeSet, [FloatBind], DataCon, [Type], [CoreExpr])
exprIsLiteral_maybe :: InScopeEnv -> CoreExpr -> Maybe Literal
exprIsLambda_maybe :: HasDebugCallStack => InScopeEnv -> CoreExpr -> Maybe (Var, CoreExpr, [CoreTickish])
instance GHC.Utils.Outputable.Outputable GHC.Core.SimpleOpt.SimpleOptEnv

module GHC.Types.Id.Make
mkDictFunId :: Name -> [TyVar] -> ThetaType -> Class -> [Type] -> Id
mkDictSelId :: Name -> Class -> Id
mkDictSelRhs :: Class -> Int -> CoreExpr
mkFCallId :: Unique -> ForeignCall -> Type -> Id
unwrapNewTypeBody :: TyCon -> [Type] -> CoreExpr -> CoreExpr
wrapFamInstBody :: TyCon -> [Type] -> CoreExpr -> CoreExpr

-- | Data Constructor Boxer
newtype DataConBoxer
DCB :: ([Type] -> [Var] -> UniqSM ([Var], [CoreBind])) -> DataConBoxer
vanillaDataConBoxer :: DataConBoxer
mkDataConRep :: DataConBangOpts -> FamInstEnvs -> Name -> DataCon -> UniqSM DataConRep
mkDataConWorkId :: Name -> DataCon -> Id
data DataConBangOpts

-- | Used for imported data constructors See Note [Bangs on imported data
--   constructors]
FixedBangOpts :: [HsImplBang] -> DataConBangOpts
SrcBangOpts :: !BangOpts -> DataConBangOpts
data BangOpts
BangOpts :: !Bool -> !Bool -> !Bool -> !Bool -> BangOpts

-- | Strict fields by default
[bang_opt_strict_data] :: BangOpts -> !Bool

-- | Disable automatic field unboxing (e.g. if we aren't optimising)
[bang_opt_unbox_disable] :: BangOpts -> !Bool

-- | Unbox strict fields
[bang_opt_unbox_strict] :: BangOpts -> !Bool

-- | Unbox small strict fields
[bang_opt_unbox_small] :: BangOpts -> !Bool
unboxedUnitExpr :: CoreExpr
wiredInIds :: [Id]
ghcPrimIds :: [Id]
realWorldPrimId :: Id
voidPrimId :: Id
voidArgId :: Id
nullAddrId :: Id
seqId :: Id
lazyId :: Id
lazyIdKey :: Unique
coercionTokenId :: Id
coerceId :: Id
proxyHashId :: Id
nospecId :: Id
nospecIdName :: Name
noinlineId :: Id
noinlineIdName :: Name
noinlineConstraintId :: Id
noinlineConstraintIdName :: Name
coerceName :: Name
leftSectionName :: Name
rightSectionName :: Name


-- | Prepare the STG for bytecode generation:
--   
--   <ul>
--   <li>Ensure that all breakpoints are directly under a let-binding,
--   introducing a new binding for those that aren't already.</li>
--   <li>Protect Not-necessarily lifted join points, see Note
--   [Not-necessarily-lifted join points]</li>
--   </ul>
module GHC.Stg.BcPrep
bcPrep :: UniqSupply -> [InStgTopBinding] -> [OutStgTopBinding]

module GHC.Driver.Config.HsToCore
initBangOpts :: DynFlags -> BangOpts

module GHC.Core.Opt.WorkWrap.Utils
data WwOpts
MkWwOpts :: !FamInstEnvs -> !SimpleOpts -> !Bool -> !Module -> !Bool -> WwOpts

-- | Environment of type/data family instances
[wo_fam_envs] :: WwOpts -> !FamInstEnvs

-- | Options for the "Simple optimiser"
[wo_simple_opts] :: WwOpts -> !SimpleOpts

-- | Whether to enable "Constructed Product Result" analysis. (Originally
--   from DOI: 10.1017/S0956796803004751)
[wo_cpr_anal] :: WwOpts -> !Bool

-- | Used for absent argument error message
[wo_module] :: WwOpts -> !Module

-- | Generate workers even if the only effect is some args get passed
--   unlifted. See Note [WW for calling convention]
[wo_unlift_strict] :: WwOpts -> !Bool

-- | Given a function definition
--   
--   <pre>
--   data T = MkT Int Bool Char
--   f :: (a, b) -&gt; Int -&gt; T
--   f = \x y -&gt; E
--   </pre>
--   
--   <tt>mkWwBodies _ <tt>f</tt> ['x::(a,b)','y::Int'] '(a,b)' ['1P(L,L)',
--   '1P(L)'] '1'</tt> returns
--   
--   <ul>
--   <li>The wrapper body context for the call to the worker function,
--   lacking only the <a>Id</a> for the worker function:</li>
--   </ul>
--   
--   <pre>
--   W[_] :: Id -&gt; CoreExpr
--   W[work_fn] = \x y -&gt;          -- args of the wrapper    (cloned_arg_vars)
--     case x of (a, b) -&gt;         -- unbox wrapper args     (wrap_fn_str)
--     case y of I# n -&gt;           --
--     case &lt;work_fn&gt; a b n of     -- call to the worker fun (call_work)
--     (# i, b, c #) -&gt; MkT i b c  -- rebox result           (wrap_fn_cpr)
--   </pre>
--   
--   <ul>
--   <li>The worker body context that wraps around its hole reboxing defns
--   for x and y, as well as returning CPR transit variables of the unboxed
--   MkT result in an unboxed tuple:</li>
--   </ul>
--   
--   <pre>
--   w[_] :: CoreExpr -&gt; CoreExpr
--   w[fn_rhs] = \a b n -&gt;              -- args of the worker       (work_lam_args)
--     let { y = I# n; x = (a, b) } in  -- reboxing wrapper args    (work_fn_str)
--     case &lt;fn_rhs&gt; x y of             -- call to the original RHS (call_rhs)
--     MkT i b c -&gt; (# i, b, c #)       -- return CPR transit vars  (work_fn_cpr)
--   </pre>
--   
--   NB: The wrap_rhs hole is to be filled with the original wrapper RHS
--   <tt>x y -&gt; E</tt>. This is so that we can also use <tt>w</tt> to
--   transform stable unfoldings, the lambda args of which may be different
--   than x and y.
--   
--   <ul>
--   <li>Id details for the worker function like demands on arguments and
--   its join arity.</li>
--   </ul>
--   
--   All without looking at E (except for beta reduction, see Note [Join
--   points and beta-redexes]), which allows us to apply the same split to
--   function body and its unfolding(s) alike.
mkWwBodies :: WwOpts -> Id -> [Var] -> Type -> [Demand] -> Cpr -> UniqSM (Maybe WwResult)
mkWWstr :: WwOpts -> [Var] -> [StrictnessMark] -> UniqSM (WwUse, [(Var, StrictnessMark)], CoreExpr -> CoreExpr, [CoreExpr])
mkWWstr_one :: WwOpts -> Var -> StrictnessMark -> UniqSM (WwUse, [(Var, StrictnessMark)], CoreExpr -> CoreExpr, CoreExpr)

-- | Whether the worker needs an additional `Void#` arg as per Note
--   [Protecting the last value argument] or Note [Preserving float
--   barriers].
needsVoidWorkerArg :: Id -> [Var] -> [Var] -> Bool

-- | The information needed to build a pattern for a DataCon to be unboxed.
--   The pattern can be generated from <a>dcpc_dc</a> and
--   <a>dcpc_tc_args</a> via <a>dataConRepInstPat</a>. The coercion
--   <a>dcpc_co</a> is for newtype wrappers.
--   
--   If we get <tt>DataConPatContext dc tys co</tt> for some type
--   <tt>ty</tt> and <tt>dataConRepInstPat ... dc tys = (exs, flds)</tt>,
--   then
--   
--   <ul>
--   <li><tt>dc </tt>exs flds :: T tys@</li>
--   <li><pre>co :: T tys ~ ty</pre></li>
--   </ul>
--   
--   <tt>s</tt> will be <a>Demand</a> or <a>Cpr</a>.
data DataConPatContext s
DataConPatContext :: !DataCon -> ![Type] -> !Coercion -> ![s] -> DataConPatContext s
[dcpc_dc] :: DataConPatContext s -> !DataCon
[dcpc_tc_args] :: DataConPatContext s -> ![Type]
[dcpc_co] :: DataConPatContext s -> !Coercion
[dcpc_args] :: DataConPatContext s -> ![s]

-- | Describes the outer shape of an argument to be unboxed or left as-is
--   Depending on how <tt>s</tt> is instantiated (e.g., <a>Demand</a> or
--   <a>Cpr</a>).
data UnboxingDecision unboxing_info

-- | We ran out of strictness info. Leave untouched.
DontUnbox :: UnboxingDecision unboxing_info

-- | The argument is used strictly or the returned product was constructed,
--   so unbox it.
DoUnbox :: !unboxing_info -> UnboxingDecision unboxing_info

-- | The argument/field was absent. Drop it.
DropAbsent :: UnboxingDecision unboxing_info

-- | Unwraps the <a>Boxity</a> decision encoded in the given
--   <a>SubDemand</a> and returns a <a>DataConPatContext</a> as well the
--   nested demands on fields of the <a>DataCon</a> to unbox.
canUnboxArg :: FamInstEnvs -> Type -> Demand -> UnboxingDecision (DataConPatContext Demand)
findTypeShape :: FamInstEnvs -> Type -> TypeShape

-- | Returned by <a>isRecDataCon</a>. See also Note [Detecting recursive
--   data constructors].
data IsRecDataConResult

-- | The algorithm detected a loop
DefinitelyRecursive :: IsRecDataConResult

-- | The algorithm detected no loop, went out of fuel or hit an .hs-boot
--   file
NonRecursiveOrUnsure :: IsRecDataConResult

-- | <tt>isRecDataCon _ fuel dc</tt>, where <tt>tc = dataConTyCon dc</tt>
--   returns
--   
--   <ul>
--   <li><tt>DefinitelyRecursive</tt> if the analysis found that
--   <tt>tc</tt> is reachable through one of <tt>dc</tt>'s
--   <tt>arg_tys</tt>.</li>
--   <li><tt>NonRecursiveOrUnsure</tt> if the analysis found that
--   <tt>tc</tt> is not reachable through one of <tt>dc</tt>'s fields (so
--   surely non-recursive).</li>
--   <li><tt>NonRecursiveOrUnsure</tt> when <tt>fuel /= Infinity</tt> and
--   <tt>fuel</tt> expansions of nested data TyCons were not enough to
--   prove non-recursiveness, nor arrive at an occurrence of <tt>tc</tt>
--   thus proving recursiveness. (So not sure if non-recursive.)</li>
--   <li><tt>NonRecursiveOrUnsure</tt> when we hit an abstract TyCon (one
--   without visible DataCons), such as those imported from .hs-boot files.
--   Similarly for stuck type and data families.</li>
--   </ul>
--   
--   If <tt>fuel = <tt>Infinity</tt></tt> and there are no boot files
--   involved, then the result is never <tt>Nothing</tt> and the analysis
--   is a depth-first search. If <tt>fuel = <a>Int</a> f</tt>, then the
--   analysis behaves like a depth-limited DFS and returns <tt>Nothing</tt>
--   if the search was inconclusive.
--   
--   See Note [Detecting recursive data constructors] for which recursive
--   DataCons we want to flag.
isRecDataCon :: FamInstEnvs -> IntWithInf -> DataCon -> IsRecDataConResult

-- | Tries to find a suitable absent filler to bind the given absent
--   identifier to. See Note [Absent fillers].
--   
--   If <tt>mkAbsentFiller _ id == Just e</tt>, then <tt>e</tt> is an
--   absent filler with the same type as <tt>id</tt>. Otherwise, no
--   suitable filler could be found.
mkAbsentFiller :: WwOpts -> Id -> StrictnessMark -> Maybe CoreExpr
isWorkerSmallEnough :: Int -> Int -> [Var] -> Bool

-- | Exactly <a>dataConInstArgTys</a>, but lacks the (ASSERT'ed)
--   precondition that the <a>DataCon</a> may not have existentials. The
--   lack of cloning the existentials this function "dubious"; only use it
--   where type variables aren't substituted for! Why may the data con bind
--   existentials? See Note [Which types are unboxed?]
dubiousDataConInstArgTys :: DataCon -> [Type] -> [Type]

-- | WW split not profitable
boringSplit :: WwUse

-- | WW split profitable
usefulSplit :: WwUse
instance GHC.Show.Show GHC.Core.Opt.WorkWrap.Utils.IsRecDataConResult
instance GHC.Classes.Eq GHC.Core.Opt.WorkWrap.Utils.IsRecDataConResult
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.WorkWrap.Utils.IsRecDataConResult
instance GHC.Utils.Outputable.Outputable i => GHC.Utils.Outputable.Outputable (GHC.Core.Opt.WorkWrap.Utils.UnboxingDecision i)


-- | Constructed Product Result analysis. Identifies functions that surely
--   return heap-allocated records on every code path, so that we can
--   eliminate said heap allocation by performing a worker/wrapper split.
--   
--   See
--   <a>https://www.microsoft.com/en-us/research/publication/constructed-product-result-analysis-haskell/</a>.
--   CPR analysis should happen after strictness analysis. See Note [Phase
--   ordering].
module GHC.Core.Opt.CprAnal
cprAnalProgram :: Logger -> FamInstEnvs -> CoreProgram -> IO CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CprAnal.AnalEnv
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CprAnal.SigEnv

module GHC.Core.Opt.WorkWrap
data WwOpts
MkWwOpts :: !FamInstEnvs -> !SimpleOpts -> !Bool -> !Module -> !Bool -> WwOpts

-- | Environment of type/data family instances
[wo_fam_envs] :: WwOpts -> !FamInstEnvs

-- | Options for the "Simple optimiser"
[wo_simple_opts] :: WwOpts -> !SimpleOpts

-- | Whether to enable "Constructed Product Result" analysis. (Originally
--   from DOI: 10.1017/S0956796803004751)
[wo_cpr_anal] :: WwOpts -> !Bool

-- | Used for absent argument error message
[wo_module] :: WwOpts -> !Module

-- | Generate workers even if the only effect is some args get passed
--   unlifted. See Note [WW for calling convention]
[wo_unlift_strict] :: WwOpts -> !Bool
wwTopBinds :: WwOpts -> UniqSupply -> CoreProgram -> CoreProgram

module GHC.Core.Opt.LiberateCase

-- | Options for the liberate case pass.
data LibCaseOpts
LibCaseOpts :: !Maybe Int -> !UnfoldingOpts -> LibCaseOpts

-- | Bomb-out size for deciding if potential liberatees are too big.
[lco_threshold] :: LibCaseOpts -> !Maybe Int

-- | Unfolding options
[lco_unfolding_opts] :: LibCaseOpts -> !UnfoldingOpts
liberateCase :: LibCaseOpts -> CoreProgram -> CoreProgram

module GHC.Driver.Config.Core.Opt.LiberateCase

-- | Initialize configuration for the liberate case Core optomization pass.
initLiberateCaseOpts :: DynFlags -> LibCaseOpts

module GHC.Core.Opt.DmdAnal

-- | Options for the demand analysis
data DmdAnalOpts
DmdAnalOpts :: !Bool -> !Bool -> !Int -> !Int -> DmdAnalOpts

-- | Value of `-fdicts-strict` (on by default). When set, all functons are
--   implicitly strict in dictionary args.
[dmd_strict_dicts] :: DmdAnalOpts -> !Bool

-- | Governs whether the analysis should update boxity signatures. See Note
--   [Don't change boxity without worker/wrapper].
[dmd_do_boxity] :: DmdAnalOpts -> !Bool

-- | Value of `-fdmd-unbox-width`. See Note [Unboxed demand on function
--   bodies returning small products]
[dmd_unbox_width] :: DmdAnalOpts -> !Int

-- | Value of `-fmax-worker-args`. Don't unbox anything if we end up with
--   more than this many args.
[dmd_max_worker_args] :: DmdAnalOpts -> !Int

-- | Outputs a new copy of the Core program in which binders have been
--   annotated with demand and strictness information.
--   
--   Note: use <tt>seqBinds</tt> on the result to avoid leaks due to
--   lazyness (cf Note [Stamp out space leaks in demand analysis])
dmdAnalProgram :: DmdAnalOpts -> FamInstEnvs -> [CoreRule] -> CoreProgram -> CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.DmdAnal.AnalEnv

module GHC.Cmm.CLabel

-- | <a>CLabel</a> is an abstract type that supports the following
--   operations:
--   
--   <ul>
--   <li>Pretty printing</li>
--   <li>In a C file, does it need to be declared before use? (i.e. is it
--   guaranteed to be already in scope in the places we need to refer to
--   it?)</li>
--   <li>If it needs to be declared, what type (code or data) should it be
--   declared to have?</li>
--   <li>Is it visible outside this object file or not?</li>
--   <li>Is it "dynamic" (see details below)</li>
--   <li>Eq and Ord, so that we can make sets of CLabels (currently only
--   used in outputting C as far as I can tell, to avoid generating more
--   than one declaration for any given label).</li>
--   <li>Converting an info table label into an entry label.</li>
--   </ul>
--   
--   CLabel usage is a bit messy in GHC as they are used in a number of
--   different contexts:
--   
--   <ul>
--   <li>By the C-- AST to identify labels</li>
--   <li>By the unregisterised C code generator ("PprC") for naming
--   functions (hence the name <a>CLabel</a>)</li>
--   <li>By the native and LLVM code generators to identify labels</li>
--   </ul>
--   
--   For extra fun, each of these uses a slightly different subset of
--   constructors (e.g. <a>AsmTempLabel</a> and <a>AsmTempDerivedLabel</a>
--   are used only in the NCG and LLVM backends).
--   
--   In general, we use <a>IdLabel</a> to represent Haskell things early in
--   the pipeline. However, later optimization passes will often represent
--   blocks they create with <a>LocalBlockLabel</a> where there is no
--   obvious <a>Name</a> to hang off the label.
data CLabel

-- | Indicate if <a>GHC.CmmToC</a> has to generate an extern declaration
--   for the label (e.g. "extern StgWordArray(foo)"). The type is fixed to
--   StgWordArray.
--   
--   Symbols from the RTS don't need "extern" declarations because they are
--   exposed via "rts<i>include</i>Stg.h" with the appropriate type. See
--   <a>needsCDecl</a>.
--   
--   The fixed StgWordArray type led to "conflicting types" issues with
--   user provided Cmm files (not in the RTS) that declare data of another
--   type (#15467 and test for #17920). Hence the Cmm parser considers that
--   labels in data sections don't need the "extern" declaration (just add
--   one explicitly if you need it).
--   
--   See
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/backends/ppr-c#prototypes</a>
--   for why extern declaration are needed at all.
newtype NeedExternDecl
NeedExternDecl :: Bool -> NeedExternDecl

-- | Record where a foreign label is stored.
data ForeignLabelSource

-- | Label is in a named package
ForeignLabelInPackage :: UnitId -> ForeignLabelSource

-- | Label is in some external, system package that doesn't also contain
--   compiled Haskell code, and is not associated with any .hi files. We
--   don't have to worry about Haskell code being inlined from external
--   packages. It is safe to treat the RTS package as "external".
ForeignLabelInExternalPackage :: ForeignLabelSource

-- | Label is in the package currently being compiled. This is only used
--   for creating hacky tmp labels during code generation. Don't use it in
--   any code that might be inlined across a package boundary (ie, core
--   code) else the information will be wrong relative to the destination
--   module.
ForeignLabelInThisPackage :: ForeignLabelSource
data DynamicLinkerLabelInfo
CodeStub :: DynamicLinkerLabelInfo
SymbolPtr :: DynamicLinkerLabelInfo
GotSymbolPtr :: DynamicLinkerLabelInfo
GotSymbolOffset :: DynamicLinkerLabelInfo

-- | Which module is the info table from, and which number was it.
data ConInfoTableLocation
UsageSite :: Module -> Int -> ConInfoTableLocation
DefinitionSite :: ConInfoTableLocation
getConInfoTableLocation :: IdLabelInfo -> Maybe ConInfoTableLocation
mkClosureLabel :: Name -> CafInfo -> CLabel
mkSRTLabel :: Unique -> CLabel

-- | Decides between external and local labels based on the names
--   externality.
mkInfoTableLabel :: Name -> CafInfo -> CLabel
mkEntryLabel :: Name -> CafInfo -> CLabel
mkRednCountsLabel :: Name -> CLabel
mkTagHitLabel :: Name -> Unique -> CLabel
mkConInfoTableLabel :: Name -> ConInfoTableLocation -> CLabel
mkApEntryLabel :: Platform -> Bool -> Int -> CLabel
mkApInfoTableLabel :: Platform -> Bool -> Int -> CLabel
mkClosureTableLabel :: Name -> CafInfo -> CLabel
mkBytesLabel :: Name -> CLabel
mkLocalBlockLabel :: Unique -> CLabel
mkBlockInfoTableLabel :: Name -> CafInfo -> CLabel
mkBitmapLabel :: Unique -> CLabel
mkStringLitLabel :: Unique -> CLabel
mkInitializerStubLabel :: Module -> FastString -> CLabel
mkInitializerArrayLabel :: Module -> CLabel
mkFinalizerStubLabel :: Module -> FastString -> CLabel
mkFinalizerArrayLabel :: Module -> CLabel
mkAsmTempLabel :: Uniquable a => a -> CLabel
mkAsmTempDerivedLabel :: CLabel -> FastString -> CLabel
mkAsmTempEndLabel :: CLabel -> CLabel

-- | A label indicating the end of a procedure.
mkAsmTempProcEndLabel :: CLabel -> CLabel

-- | Construct a label for a DWARF Debug Information Entity (DIE)
--   describing another symbol.
mkAsmTempDieLabel :: CLabel -> CLabel
mkDirty_MUT_VAR_Label :: CLabel
mkMUT_VAR_CLEAN_infoLabel :: CLabel
mkNonmovingWriteBarrierEnabledLabel :: CLabel
mkUpdInfoLabel :: CLabel
mkBHUpdInfoLabel :: CLabel
mkIndStaticInfoLabel :: CLabel
mkMainCapabilityLabel :: CLabel
mkMAP_FROZEN_CLEAN_infoLabel :: CLabel
mkMAP_FROZEN_DIRTY_infoLabel :: CLabel
mkMAP_DIRTY_infoLabel :: CLabel
mkSMAP_FROZEN_CLEAN_infoLabel :: CLabel
mkSMAP_FROZEN_DIRTY_infoLabel :: CLabel
mkSMAP_DIRTY_infoLabel :: CLabel
mkBadAlignmentLabel :: CLabel
mkOutOfBoundsAccessLabel :: CLabel
mkMemcpyRangeOverlapLabel :: CLabel
mkArrWords_infoLabel :: CLabel
mkSRTInfoLabel :: Int -> CLabel
mkTopTickyCtrLabel :: CLabel
mkCAFBlackHoleInfoTableLabel :: CLabel
mkRtsPrimOpLabel :: PrimOp -> CLabel
mkRtsSlowFastTickyCtrLabel :: String -> CLabel

-- | A standard string unpacking thunk. See Note [unpack_cstring closures]
--   in StgStdThunks.cmm.
mkRtsUnpackCStringLabel :: CLabel

-- | A standard string unpacking thunk. See Note [unpack_cstring closures]
--   in StgStdThunks.cmm.
mkRtsUnpackCStringUtf8Label :: CLabel
mkSelectorInfoLabel :: Platform -> Bool -> Int -> CLabel
mkSelectorEntryLabel :: Platform -> Bool -> Int -> CLabel
mkCmmInfoLabel :: UnitId -> FastString -> CLabel
mkCmmEntryLabel :: UnitId -> FastString -> CLabel
mkCmmRetInfoLabel :: UnitId -> FastString -> CLabel
mkCmmRetLabel :: UnitId -> FastString -> CLabel
mkCmmCodeLabel :: UnitId -> FastString -> CLabel
mkCmmDataLabel :: UnitId -> NeedExternDecl -> FastString -> CLabel
mkRtsCmmDataLabel :: FastString -> CLabel
mkCmmClosureLabel :: UnitId -> FastString -> CLabel
mkRtsApFastLabel :: FastString -> CLabel
mkPrimCallLabel :: PrimCall -> CLabel

-- | Make a foreign label
mkForeignLabel :: FastString -> Maybe Int -> ForeignLabelSource -> FunctionOrData -> CLabel
mkCCLabel :: CostCentre -> CLabel
mkCCSLabel :: CostCentreStack -> CLabel
mkIPELabel :: Module -> CLabel

-- | Info Table Provenance Entry See Note [Mapping Info Tables to Source
--   Positions]
data InfoProvEnt
InfoProvEnt :: !CLabel -> !Int -> !String -> !Module -> !Maybe (RealSrcSpan, String) -> InfoProvEnt
[infoTablePtr] :: InfoProvEnt -> !CLabel
[infoProvEntClosureType] :: InfoProvEnt -> !Int
[infoTableType] :: InfoProvEnt -> !String
[infoProvModule] :: InfoProvEnt -> !Module
[infoTableProv] :: InfoProvEnt -> !Maybe (RealSrcSpan, String)
mkDynamicLinkerLabel :: DynamicLinkerLabelInfo -> CLabel -> CLabel
mkPicBaseLabel :: CLabel
mkDeadStripPreventer :: CLabel -> CLabel
mkHpcTicksLabel :: Module -> CLabel
hasCAF :: CLabel -> Bool
needsCDecl :: CLabel -> Bool

-- | If a label is a local block label then return just its <a>BlockId</a>,
--   otherwise <a>Nothing</a>.
maybeLocalBlockLabel :: CLabel -> Maybe BlockId

-- | Is a CLabel visible outside this object file or not? From the point of
--   view of the code generator, a name is externally visible if it has to
--   be declared as exported in the .o file's symbol table; that is, made
--   non-static.
externallyVisibleCLabel :: CLabel -> Bool

-- | Check whether a label corresponds to a C function that has a prototype
--   in a system header somewhere, or is built-in to the C compiler. For
--   these labels we avoid generating our own C prototypes.
isMathFun :: CLabel -> Bool
isCFunctionLabel :: CLabel -> Bool
isGcPtrLabel :: CLabel -> Bool

-- | Does a <a>CLabel</a> need dynamic linkage?
--   
--   When referring to data in code, we need to know whether that data
--   resides in a DLL or not. [Win32 only.] <tt>labelDynamic</tt> returns
--   <tt>True</tt> if the label is located in a DLL, be it a data reference
--   or not.
labelDynamic :: Module -> Platform -> Bool -> CLabel -> Bool

-- | Is a <a>CLabel</a> defined in the current module being compiled?
--   
--   Sometimes we can optimise references within a compilation unit in ways
--   that we couldn't for inter-module references. This provides a
--   conservative estimate of whether a <a>CLabel</a> lives in the current
--   module.
isLocalCLabel :: Module -> CLabel -> Bool
mayRedirectTo :: CLabel -> CLabel -> Bool

-- | Whether label is points to some kind of info table
isInfoTableLabel :: CLabel -> Bool

-- | Whether label points to an info table defined in Cmm
isCmmInfoTableLabel :: CLabel -> Bool

-- | Whether label is points to constructor info table
isConInfoTableLabel :: CLabel -> Bool
isIdLabel :: CLabel -> Bool
isTickyLabel :: CLabel -> Bool
hasHaskellName :: CLabel -> Maybe Name
hasIdLabelInfo :: CLabel -> Maybe IdLabelInfo

-- | Whether label is a top-level string literal
isBytesLabel :: CLabel -> Bool

-- | Whether label is a non-haskell label (defined in C code)
isForeignLabel :: CLabel -> Bool

-- | Whether label is a .rodata label
isSomeRODataLabel :: CLabel -> Bool

-- | Whether label is a static closure label (can come from haskell or cmm)
isStaticClosureLabel :: CLabel -> Bool
toClosureLbl :: Platform -> CLabel -> CLabel
toSlowEntryLbl :: Platform -> CLabel -> CLabel
toEntryLbl :: Platform -> CLabel -> CLabel
toInfoLbl :: Platform -> CLabel -> CLabel

-- | Style of label pretty-printing.
--   
--   When we produce C sources or headers, we have to take into account
--   that C compilers transform C labels when they convert them into
--   symbols. For example, they can add prefixes (e.g., "_" on Darwin) or
--   suffixes (size for stdcalls on Windows). So we provide two ways to
--   pretty-print CLabels: C style or Asm style.
data LabelStyle

-- | C label style (used by C and LLVM backends)
CStyle :: LabelStyle

-- | Asm label style (used by NCG backend)
AsmStyle :: LabelStyle

-- | For debugging problems with the CLabel representation. We can't make a
--   Show instance for CLabel because lots of its components don't have
--   instances. The regular Outputable instance only shows the label name,
--   and not its other info.
pprDebugCLabel :: Platform -> CLabel -> SDoc
pprCLabel :: IsLine doc => Platform -> CLabel -> doc
pprAsmLabel :: IsLine doc => Platform -> CLabel -> doc

-- | Generate a label for a procedure internal to a module (if
--   <tt>Opt_ExposeAllSymbols</tt> is enabled). See Note [Internal proc
--   labels].
ppInternalProcLabel :: IsLine doc => Module -> CLabel -> Maybe doc
dynamicLinkerLabelInfo :: CLabel -> Maybe (DynamicLinkerLabelInfo, CLabel)

-- | Update the label size field in a ForeignLabel
addLabelSize :: CLabel -> Int -> CLabel

-- | Get the label size field from a ForeignLabel
foreignLabelStdcallInfo :: CLabel -> Maybe Int
instance GHC.Classes.Ord GHC.Cmm.CLabel.ModuleLabelKind
instance GHC.Classes.Eq GHC.Cmm.CLabel.ModuleLabelKind
instance GHC.Classes.Eq GHC.Cmm.CLabel.NeedExternDecl
instance GHC.Classes.Ord GHC.Cmm.CLabel.NeedExternDecl
instance GHC.Classes.Ord GHC.Cmm.CLabel.ForeignLabelSource
instance GHC.Classes.Eq GHC.Cmm.CLabel.ForeignLabelSource
instance GHC.Show.Show GHC.Cmm.CLabel.TickyIdInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.TickyIdInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.ConInfoTableLocation
instance GHC.Classes.Eq GHC.Cmm.CLabel.ConInfoTableLocation
instance GHC.Classes.Ord GHC.Cmm.CLabel.IdLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.IdLabelInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.RtsLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.RtsLabelInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.CmmLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.CmmLabelInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.DynamicLinkerLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.DynamicLinkerLabelInfo
instance GHC.Classes.Eq GHC.Cmm.CLabel.CLabel
instance GHC.Classes.Ord GHC.Cmm.CLabel.InfoProvEnt
instance GHC.Classes.Eq GHC.Cmm.CLabel.InfoProvEnt
instance GHC.Show.Show GHC.Cmm.CLabel.CLabel
instance GHC.Classes.Ord GHC.Cmm.CLabel.CLabel
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CLabel.InfoProvEnt
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CLabel.CLabel
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.IdLabelInfo
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.ConInfoTableLocation
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.TickyIdInfo
instance GHC.Classes.Ord GHC.Cmm.CLabel.TickyIdInfo
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CLabel.ForeignLabelSource

module GHC.Types.IPE

-- | A map storing all the different uses of a specific data constructor
--   and the approximate source position that usage arose from. The
--   <a>Int</a> is an incrementing identifier which distinguishes each
--   usage of a constructor in a module. It is paired with the source
--   position the constructor was used at, if possible and a string which
--   names the source location. This is the same information as is the
--   payload for the <a>SourceNote</a> constructor.
type DCMap = UniqMap DataCon (NonEmpty (Int, Maybe IpeSourceLocation))

-- | A map from a <a>Name</a> to the best approximate source position that
--   name arose from.
type ClosureMap = UniqMap Name (Type, Maybe IpeSourceLocation)
data InfoTableProvMap
InfoTableProvMap :: DCMap -> ClosureMap -> InfoTableToSourceLocationMap -> InfoTableProvMap
[provDC] :: InfoTableProvMap -> DCMap
[provClosure] :: InfoTableProvMap -> ClosureMap
[provInfoTables] :: InfoTableProvMap -> InfoTableToSourceLocationMap
emptyInfoTableProvMap :: InfoTableProvMap

-- | Position and information about an info table. For return frames these
--   are the contents of a <a>SourceNote</a>.
type IpeSourceLocation = (RealSrcSpan, String)

module GHC.Stg.Debug
data StgDebugOpts
StgDebugOpts :: !Bool -> !Bool -> StgDebugOpts
[stgDebug_infoTableMap] :: StgDebugOpts -> !Bool
[stgDebug_distinctConstructorTables] :: StgDebugOpts -> !Bool
collectDebugInformation :: StgDebugOpts -> ModLocation -> [StgTopBinding] -> ([StgTopBinding], InfoTableProvMap)

module GHC.Driver.Config.Stg.Debug

-- | Initialize STG pretty-printing options from DynFlags
initStgDebugOpts :: DynFlags -> StgDebugOpts

module GHC.CoreToStg
data CoreToStgOpts
CoreToStgOpts :: Platform -> Ways -> Bool -> Bool -> Bool -> StgDebugOpts -> CoreToStgOpts
[coreToStg_platform] :: CoreToStgOpts -> Platform
[coreToStg_ways] :: CoreToStgOpts -> Ways
[coreToStg_AutoSccsOnIndividualCafs] :: CoreToStgOpts -> Bool
[coreToStg_InfoTableMap] :: CoreToStgOpts -> Bool
[coreToStg_ExternalDynamicRefs] :: CoreToStgOpts -> Bool
[coreToStg_stgDebugOpts] :: CoreToStgOpts -> StgDebugOpts
coreToStg :: CoreToStgOpts -> Module -> ModLocation -> CoreProgram -> ([StgTopBinding], InfoTableProvMap, CollectedCCs)
instance GHC.Classes.Eq GHC.CoreToStg.LetInfo
instance GHC.Classes.Eq GHC.CoreToStg.HowBound
instance GHC.Base.Functor GHC.CoreToStg.CtsM
instance GHC.Base.Applicative GHC.CoreToStg.CtsM
instance GHC.Base.Monad GHC.CoreToStg.CtsM

module GHC.Driver.Config.CoreToStg
initCoreToStgOpts :: DynFlags -> CoreToStgOpts

module GHC.HsToCore.Coverage
writeMixEntries :: FilePath -> Module -> SizedSeq Tick -> FilePath -> IO Int

-- | Create HPC initialization C code for a module
--   
--   Each module compiled with -fhpc declares an initialisation function of
--   the form `hpc_init_<a>module</a>()`, which is emitted into the _stub.c
--   file and annotated with <b>attribute</b>((constructor)) so that it
--   gets executed at startup time.
--   
--   The function's purpose is to call hs_hpc_module to register this
--   module with the RTS, and it looks something like this:
--   
--   <pre>
--   static void hpc_init_Main(void) __attribute__((constructor));
--   static void hpc_init_Main(void)
--   {
--     extern StgWord64 _hpc_tickboxes_Main_hpc[];
--     hs_hpc_module("Main",8,1150288664,_hpc_tickboxes_Main_hpc);
--   }
--   </pre>
hpcInitCode :: Platform -> Module -> HpcInfo -> CStub

module GHC.Cmm.BlockId
type BlockId = Label
mkBlockId :: Unique -> BlockId
newBlockId :: MonadUnique m => m BlockId
blockLbl :: BlockId -> CLabel
infoTblLbl :: BlockId -> CLabel

module GHC.CmmToAsm.Instr

-- | Common things that we can do with instructions, on all architectures.
--   These are used by the shared parts of the native code generator,
--   specifically the register allocators.
class Instruction instr

-- | Get the registers that are being used by this instruction. regUsage
--   doesn't need to do any trickery for jumps and such. Just state
--   precisely the regs read and written by that insn. The consequences of
--   control flow transfers, as far as register allocation goes, are taken
--   care of by the register allocator.
regUsageOfInstr :: Instruction instr => Platform -> instr -> RegUsage

-- | Apply a given mapping to all the register references in this
--   instruction.
patchRegsOfInstr :: Instruction instr => instr -> (Reg -> Reg) -> instr

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
isJumpishInstr :: Instruction instr => instr -> Bool

-- | Give the possible *local block* destinations of this jump instruction.
--   Must be defined for all jumpish instructions.
jumpDestsOfInstr :: Instruction instr => instr -> [BlockId]

-- | Check if the instr always transfers control flow to the given block.
--   Used by code layout to eliminate jumps that can be replaced by fall
--   through.
canFallthroughTo :: Instruction instr => instr -> BlockId -> Bool

-- | Change the destination of this jump instruction. Used in the linear
--   allocator when adding fixup blocks for join points.
patchJumpInstr :: Instruction instr => instr -> (BlockId -> BlockId) -> instr

-- | An instruction to spill a register into a spill slot.
mkSpillInstr :: Instruction instr => NCGConfig -> Reg -> Int -> Int -> [instr]

-- | An instruction to reload a register from a spill slot.
mkLoadInstr :: Instruction instr => NCGConfig -> Reg -> Int -> Int -> [instr]

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instruction instr => instr -> Maybe Int

-- | Check whether this instruction is some meta thing inserted into the
--   instruction stream for other purposes.
--   
--   Not something that has to be treated as a real machine instruction and
--   have its registers allocated.
--   
--   eg, comments, delta, ldata, etc.
isMetaInstr :: Instruction instr => instr -> Bool

-- | Copy the value in a register to another one. Must work for all
--   register classes.
mkRegRegMoveInstr :: Instruction instr => Platform -> Reg -> Reg -> instr

-- | Take the source and destination from this reg -&gt; reg move
--   instruction or Nothing if it's not one
takeRegRegMoveInstr :: Instruction instr => instr -> Maybe (Reg, Reg)

-- | Make an unconditional jump instruction. For architectures with branch
--   delay slots, its ok to put a NOP after the jump. Don't fill the delay
--   slot with an instruction that references regs or you'll confuse the
--   linear allocator.
mkJumpInstr :: Instruction instr => BlockId -> [instr]
mkStackAllocInstr :: Instruction instr => Platform -> Int -> [instr]
mkStackDeallocInstr :: Instruction instr => Platform -> Int -> [instr]

-- | Pretty-print an instruction
pprInstr :: Instruction instr => Platform -> instr -> SDoc
mkComment :: Instruction instr => FastString -> [instr]

-- | Holds a list of source and destination registers used by a particular
--   instruction.
--   
--   Machine registers that are pre-allocated to stgRegs are filtered out,
--   because they are uninteresting from a register allocation standpoint.
--   (We wouldn't want them to end up on the free list!)
--   
--   As far as we are concerned, the fixed registers simply don't exist
--   (for allocation purposes, anyway).
data RegUsage
RU :: [Reg] -> [Reg] -> RegUsage
[reads] :: RegUsage -> [Reg]
[writes] :: RegUsage -> [Reg]

-- | No regs read or written to.
noUsage :: RegUsage
instance GHC.Show.Show GHC.CmmToAsm.Instr.RegUsage

module GHC.Cmm.Expr
data CmmExpr
CmmLit :: !CmmLit -> CmmExpr
CmmLoad :: !CmmExpr -> !CmmType -> !AlignmentSpec -> CmmExpr
CmmReg :: !CmmReg -> CmmExpr
CmmMachOp :: MachOp -> [CmmExpr] -> CmmExpr
CmmStackSlot :: Area -> {-# UNPACK #-} !Int -> CmmExpr
CmmRegOff :: !CmmReg -> !Int -> CmmExpr
cmmExprType :: Platform -> CmmExpr -> CmmType
cmmExprWidth :: Platform -> CmmExpr -> Width

-- | Returns an alignment in bytes of a CmmExpr when it's a statically
--   known integer constant, otherwise returns an alignment of 1 byte. The
--   caller is responsible for using with a sensible CmmExpr argument.
cmmExprAlignment :: CmmExpr -> Alignment
maybeInvertCmmExpr :: CmmExpr -> Maybe CmmExpr
data CmmReg
CmmLocal :: {-# UNPACK #-} !LocalReg -> CmmReg
CmmGlobal :: GlobalReg -> CmmReg
cmmRegType :: Platform -> CmmReg -> CmmType
cmmRegWidth :: Platform -> CmmReg -> Width
data CmmLit
CmmInt :: !Integer -> !Width -> CmmLit
CmmFloat :: Rational -> !Width -> CmmLit
CmmVec :: [CmmLit] -> CmmLit
CmmLabel :: CLabel -> CmmLit
CmmLabelOff :: CLabel -> !Int -> CmmLit
CmmLabelDiffOff :: CLabel -> CLabel -> !Int -> !Width -> CmmLit
CmmBlock :: {-# UNPACK #-} !BlockId -> CmmLit
CmmHighStackMark :: CmmLit
cmmLitType :: Platform -> CmmLit -> CmmType
data AlignmentSpec
NaturallyAligned :: AlignmentSpec
Unaligned :: AlignmentSpec
data LocalReg

-- | Parameters: 1. Identifier 2. Type
LocalReg :: {-# UNPACK #-} !Unique -> !CmmType -> LocalReg
localRegType :: LocalReg -> CmmType
data GlobalReg
VanillaReg :: {-# UNPACK #-} !Int -> VGcPtr -> GlobalReg
FloatReg :: {-# UNPACK #-} !Int -> GlobalReg
DoubleReg :: {-# UNPACK #-} !Int -> GlobalReg
LongReg :: {-# UNPACK #-} !Int -> GlobalReg
XmmReg :: {-# UNPACK #-} !Int -> GlobalReg
YmmReg :: {-# UNPACK #-} !Int -> GlobalReg
ZmmReg :: {-# UNPACK #-} !Int -> GlobalReg
Sp :: GlobalReg
SpLim :: GlobalReg
Hp :: GlobalReg
HpLim :: GlobalReg
CCCS :: GlobalReg
CurrentTSO :: GlobalReg
CurrentNursery :: GlobalReg
HpAlloc :: GlobalReg
EagerBlackholeInfo :: GlobalReg
GCEnter1 :: GlobalReg
GCFun :: GlobalReg
BaseReg :: GlobalReg
MachSp :: GlobalReg
UnwindReturnReg :: GlobalReg
PicBaseReg :: GlobalReg
isArgReg :: GlobalReg -> Bool
globalRegType :: Platform -> GlobalReg -> CmmType
spReg :: CmmReg
hpReg :: CmmReg
spLimReg :: CmmReg
hpLimReg :: CmmReg
nodeReg :: CmmReg
currentTSOReg :: CmmReg
currentNurseryReg :: CmmReg
hpAllocReg :: CmmReg
cccsReg :: CmmReg
node :: GlobalReg
baseReg :: CmmReg
data VGcPtr
VGcPtr :: VGcPtr
VNonGcPtr :: VGcPtr
class Ord r => DefinerOfRegs r a
class Ord r => UserOfRegs r a
foldRegsDefd :: DefinerOfRegs r a => Platform -> (b -> r -> b) -> b -> a -> b
foldRegsUsed :: UserOfRegs r a => Platform -> (b -> r -> b) -> b -> a -> b
foldLocalRegsDefd :: DefinerOfRegs LocalReg a => Platform -> (b -> LocalReg -> b) -> b -> a -> b
foldLocalRegsUsed :: UserOfRegs LocalReg a => Platform -> (b -> LocalReg -> b) -> b -> a -> b

-- | Sets of registers
type RegSet r = Set r
type LocalRegSet = RegSet LocalReg
type GlobalRegSet = RegSet GlobalReg
emptyRegSet :: RegSet r
elemRegSet :: Ord r => r -> RegSet r -> Bool
extendRegSet :: Ord r => RegSet r -> r -> RegSet r
deleteFromRegSet :: Ord r => RegSet r -> r -> RegSet r
mkRegSet :: Ord r => [r] -> RegSet r
plusRegSet :: Ord r => RegSet r -> RegSet r -> RegSet r
minusRegSet :: Ord r => RegSet r -> RegSet r -> RegSet r
timesRegSet :: Ord r => RegSet r -> RegSet r -> RegSet r
sizeRegSet :: RegSet r -> Int
nullRegSet :: RegSet r -> Bool
regSetToList :: RegSet r -> [r]
isTrivialCmmExpr :: CmmExpr -> Bool
hasNoGlobalRegs :: CmmExpr -> Bool
isLit :: CmmExpr -> Bool
isComparisonExpr :: CmmExpr -> Bool

-- | A stack area is either the stack slot where a variable is spilled or
--   the stack space where function arguments and results are passed.
data Area
Old :: Area
Young :: {-# UNPACK #-} !BlockId -> Area
instance GHC.Show.Show GHC.Cmm.Expr.AlignmentSpec
instance GHC.Classes.Ord GHC.Cmm.Expr.AlignmentSpec
instance GHC.Classes.Eq GHC.Cmm.Expr.AlignmentSpec
instance GHC.Show.Show GHC.Cmm.Expr.Area
instance GHC.Classes.Ord GHC.Cmm.Expr.Area
instance GHC.Classes.Eq GHC.Cmm.Expr.Area
instance GHC.Show.Show GHC.Cmm.Expr.CmmLit
instance GHC.Classes.Eq GHC.Cmm.Expr.CmmLit
instance GHC.Show.Show GHC.Cmm.Expr.CmmExpr
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Reg.LocalReg GHC.Cmm.Reg.CmmReg
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Reg.GlobalReg GHC.Cmm.Reg.CmmReg
instance GHC.Classes.Ord r => GHC.Cmm.Expr.DefinerOfRegs r r
instance GHC.Cmm.Expr.DefinerOfRegs r a => GHC.Cmm.Expr.DefinerOfRegs r [a]
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Reg.LocalReg GHC.Cmm.Reg.CmmReg
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Reg.GlobalReg GHC.Cmm.Reg.CmmReg
instance GHC.Classes.Ord r => GHC.Cmm.Expr.UserOfRegs r r
instance (GHC.Classes.Ord r, GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Reg.CmmReg) => GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Expr.CmmExpr
instance GHC.Cmm.Expr.UserOfRegs r a => GHC.Cmm.Expr.UserOfRegs r [a]
instance GHC.Classes.Eq GHC.Cmm.Expr.CmmExpr
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.Expr.CmmExpr
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.Expr.CmmLit
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Expr.CmmLit
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Expr.Area

module GHC.Platform.X86_64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool
freeRegBase :: RegNo -> Bool

module GHC.Platform.X86
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool
freeRegBase :: RegNo -> Bool

module GHC.Platform.Wasm32
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.S390X
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.RISCV64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.PPC
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.NoRegs
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.LoongArch64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.ARM
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.AArch64
callerSaves :: GlobalReg -> Bool
activeStgRegs :: [GlobalReg]
haveRegBase :: Bool
globalRegMaybe :: GlobalReg -> Maybe RealReg
freeReg :: RegNo -> Bool

module GHC.Platform.Regs

-- | Returns <a>True</a> if this global register is stored in a
--   caller-saves machine register.
callerSaves :: Platform -> GlobalReg -> Bool

-- | Here is where the STG register map is defined for each target arch.
--   The order matters (for the llvm backend anyway)! We must make sure to
--   maintain the order here with the order used in the LLVM calling
--   conventions. Note that also, this isn't all registers, just the ones
--   that are currently possibly mapped to real registers.
activeStgRegs :: Platform -> [GlobalReg]
haveRegBase :: Platform -> Bool
globalRegMaybe :: Platform -> GlobalReg -> Maybe RealReg
freeReg :: Platform -> RegNo -> Bool

module GHC.Cmm.Node
data CmmNode e x
[CmmEntry] :: {-# UNPACK #-} !Label -> CmmTickScope -> CmmNode C O
[CmmComment] :: FastString -> CmmNode O O
[CmmTick] :: !CmmTickish -> CmmNode O O
[CmmUnwind] :: [(GlobalReg, Maybe CmmExpr)] -> CmmNode O O
[CmmAssign] :: !CmmReg -> !CmmExpr -> CmmNode O O
[CmmStore] :: !CmmExpr -> !CmmExpr -> !AlignmentSpec -> CmmNode O O
[CmmUnsafeForeignCall] :: ForeignTarget -> [CmmFormal] -> [CmmActual] -> CmmNode O O
[CmmBranch] :: {-# UNPACK #-} !Label -> CmmNode O C
[CmmCondBranch] :: CmmExpr -> {-# UNPACK #-} !Label -> Maybe Bool -> CmmNode O C
[CmmSwitch] :: CmmExpr -> SwitchTargets -> CmmNode O C
[CmmCall] :: CmmExpr -> Maybe Label -> [GlobalReg] -> ByteOff -> ByteOff -> ByteOff -> CmmNode O C
[CmmForeignCall] :: ForeignTarget -> [CmmFormal] -> [CmmActual] -> {-# UNPACK #-} !Label -> ByteOff -> ByteOff -> Bool -> CmmNode O C
type CmmFormal = LocalReg
type CmmActual = CmmExpr

-- | Tickish in Cmm context (annotations only)
type CmmTickish = GenTickish 'TickishPassCmm
type UpdFrameOffset = ByteOff

-- | A convention maps a list of values (function arguments or return
--   values) to registers or stack locations.
data Convention

-- | top-level Haskell functions use <tt>NativeDirectCall</tt>, which maps
--   arguments to registers starting with R2, according to how many
--   registers are available on the platform. This convention ignores R1,
--   because for a top-level function call the function closure is
--   implicit, and doesn't need to be passed.
NativeDirectCall :: Convention

-- | non-top-level Haskell functions, which pass the address of the
--   function closure in R1 (regardless of whether R1 is a real register or
--   not), and the rest of the arguments in registers or on the stack.
NativeNodeCall :: Convention

-- | a native return. The convention for returns depends on how many values
--   are returned: for just one value returned, the appropriate register is
--   used (R1, F1, etc.). regardless of whether it is a real register or
--   not. For multiple values returned, they are mapped to registers or the
--   stack.
NativeReturn :: Convention

-- | Slow entry points: all args pushed on the stack
Slow :: Convention

-- | Entry to the garbage collector: uses the node reg! (TODO: I don't
--   think we need this --SDM)
GC :: Convention
data ForeignConvention
ForeignConvention :: CCallConv -> [ForeignHint] -> [ForeignHint] -> CmmReturnInfo -> ForeignConvention
data ForeignTarget
ForeignTarget :: CmmExpr -> ForeignConvention -> ForeignTarget
PrimTarget :: CallishMachOp -> ForeignTarget
foreignTargetHints :: ForeignTarget -> ([ForeignHint], [ForeignHint])
data CmmReturnInfo
CmmMayReturn :: CmmReturnInfo
CmmNeverReturns :: CmmReturnInfo
mapExp :: (CmmExpr -> CmmExpr) -> CmmNode e x -> CmmNode e x
mapExpDeep :: (CmmExpr -> CmmExpr) -> CmmNode e x -> CmmNode e x
wrapRecExp :: (CmmExpr -> CmmExpr) -> CmmExpr -> CmmExpr
foldExp :: (CmmExpr -> z -> z) -> CmmNode e x -> z -> z
foldExpDeep :: (CmmExpr -> z -> z) -> CmmNode e x -> z -> z
wrapRecExpf :: (CmmExpr -> z -> z) -> CmmExpr -> z -> z
mapExpM :: (CmmExpr -> Maybe CmmExpr) -> CmmNode e x -> Maybe (CmmNode e x)
mapExpDeepM :: (CmmExpr -> Maybe CmmExpr) -> CmmNode e x -> Maybe (CmmNode e x)
wrapRecExpM :: (CmmExpr -> Maybe CmmExpr) -> CmmExpr -> Maybe CmmExpr
mapSuccessors :: (Label -> Label) -> CmmNode O C -> CmmNode O C
mapCollectSuccessors :: forall a. (Label -> (Label, a)) -> CmmNode O C -> (CmmNode O C, [a])

-- | Tick scope identifier, allowing us to reason about what annotations in
--   a Cmm block should scope over. We especially take care to allow
--   optimisations to reorganise blocks without losing tick association in
--   the process.
data CmmTickScope

-- | The global scope is the "root" of the scope graph. Every scope is a
--   sub-scope of the global scope. It doesn't make sense to add ticks to
--   this scope. On the other hand, this means that setting this scope on a
--   block means no ticks apply to it.
GlobalScope :: CmmTickScope

-- | Constructs a new sub-scope to an existing scope. This allows us to
--   translate Core-style scoping rules (see <tt>tickishScoped</tt>) into
--   the Cmm world. Suppose the following code:
--   
--   tick<a>1</a> case ... of A -&gt; tick<a>2</a> ... B -&gt; tick<a>3</a>
--   ...
--   
--   We want the top-level tick annotation to apply to blocks generated for
--   the A and B alternatives. We can achieve that by generating
--   tick<a>1</a> into a block with scope a, while the code for
--   alternatives A and B gets generated into sub-scopes a/b and a/c
--   respectively.
SubScope :: !Unique -> CmmTickScope -> CmmTickScope

-- | A combined scope scopes over everything that the two given scopes
--   cover. It is therefore a sub-scope of either scope. This is required
--   for optimisations. Consider common block elimination:
--   
--   A -&gt; tick<a>2</a> case ... of C -&gt; [common] B -&gt; tick<a>3</a>
--   case ... of D -&gt; [common]
--   
--   We will generate code for the C and D alternatives, and figure out
--   afterwards that it's actually common code. Scoping rules dictate that
--   the resulting common block needs to be covered by both tick<a>2</a>
--   and tick<a>3</a>, therefore we need to construct a scope that is a
--   child to *both* scope. Now we can do that - if we assign the scopes
--   a<i>c and b</i>d to the common-ed up blocks, the new block could have
--   a combined tick scope a<i>c+b</i>d, which both tick<a>2</a> and
--   tick<a>3</a> apply to.
CombinedScope :: CmmTickScope -> CmmTickScope -> CmmTickScope

-- | Checks whether two tick scopes are sub-scopes of each other. True if
--   the two scopes are equal.
isTickSubScope :: CmmTickScope -> CmmTickScope -> Bool

-- | Combine two tick scopes. The new scope should be sub-scope of both
--   parameters. We simplify automatically if one tick scope is a sub-scope
--   of the other already.
combineTickScopes :: CmmTickScope -> CmmTickScope -> CmmTickScope
instance GHC.Classes.Eq GHC.Cmm.Node.Convention
instance GHC.Classes.Eq GHC.Cmm.Node.CmmReturnInfo
instance GHC.Classes.Eq GHC.Cmm.Node.ForeignConvention
instance GHC.Classes.Eq GHC.Cmm.Node.ForeignTarget
instance GHC.Classes.Eq (GHC.Cmm.Node.CmmNode e x)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Node.CmmNode e x)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.C GHC.Cmm.Dataflow.Block.C)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.C GHC.Cmm.Dataflow.Block.O)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.O GHC.Cmm.Dataflow.Block.C)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Block.Block GHC.Cmm.Node.CmmNode GHC.Cmm.Dataflow.Block.O GHC.Cmm.Dataflow.Block.O)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.Dataflow.Graph.Graph GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Dataflow.Graph.NonLocal GHC.Cmm.Node.CmmNode
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Reg.LocalReg (GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Expr.UserOfRegs GHC.Cmm.Reg.GlobalReg (GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Reg.LocalReg (GHC.Cmm.Node.CmmNode e x)
instance GHC.Cmm.Expr.DefinerOfRegs GHC.Cmm.Reg.GlobalReg (GHC.Cmm.Node.CmmNode e x)
instance GHC.Classes.Eq GHC.Cmm.Node.CmmTickScope
instance GHC.Classes.Ord GHC.Cmm.Node.CmmTickScope
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.CmmTickScope
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.Node.ForeignTarget
instance (GHC.Classes.Ord r, GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Reg.CmmReg) => GHC.Cmm.Expr.UserOfRegs r GHC.Cmm.Node.ForeignTarget
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.ForeignConvention
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.CmmReturnInfo
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Node.Convention

module GHC.Cmm.Lexer
data CmmToken
CmmT_SpecChar :: Char -> CmmToken
CmmT_DotDot :: CmmToken
CmmT_DoubleColon :: CmmToken
CmmT_Shr :: CmmToken
CmmT_Shl :: CmmToken
CmmT_Ge :: CmmToken
CmmT_Le :: CmmToken
CmmT_Eq :: CmmToken
CmmT_Ne :: CmmToken
CmmT_BoolAnd :: CmmToken
CmmT_BoolOr :: CmmToken
CmmT_CLOSURE :: CmmToken
CmmT_INFO_TABLE :: CmmToken
CmmT_INFO_TABLE_RET :: CmmToken
CmmT_INFO_TABLE_FUN :: CmmToken
CmmT_INFO_TABLE_CONSTR :: CmmToken
CmmT_INFO_TABLE_SELECTOR :: CmmToken
CmmT_else :: CmmToken
CmmT_export :: CmmToken
CmmT_section :: CmmToken
CmmT_goto :: CmmToken
CmmT_if :: CmmToken
CmmT_call :: CmmToken
CmmT_jump :: CmmToken
CmmT_foreign :: CmmToken
CmmT_never :: CmmToken
CmmT_prim :: CmmToken
CmmT_reserve :: CmmToken
CmmT_return :: CmmToken
CmmT_returns :: CmmToken
CmmT_import :: CmmToken
CmmT_switch :: CmmToken
CmmT_case :: CmmToken
CmmT_default :: CmmToken
CmmT_push :: CmmToken
CmmT_unwind :: CmmToken
CmmT_bits8 :: CmmToken
CmmT_bits16 :: CmmToken
CmmT_bits32 :: CmmToken
CmmT_bits64 :: CmmToken
CmmT_bits128 :: CmmToken
CmmT_bits256 :: CmmToken
CmmT_bits512 :: CmmToken
CmmT_float32 :: CmmToken
CmmT_float64 :: CmmToken
CmmT_gcptr :: CmmToken
CmmT_GlobalReg :: GlobalReg -> CmmToken
CmmT_Name :: FastString -> CmmToken
CmmT_String :: String -> CmmToken
CmmT_Int :: Integer -> CmmToken
CmmT_Float :: Rational -> CmmToken
CmmT_EOF :: CmmToken
CmmT_False :: CmmToken
CmmT_True :: CmmToken
CmmT_likely :: CmmToken
CmmT_Relaxed :: CmmToken
CmmT_Acquire :: CmmToken
CmmT_Release :: CmmToken
CmmT_SeqCst :: CmmToken
cmmlex :: (Located CmmToken -> PD a) -> PD a
instance GHC.Show.Show GHC.Cmm.Lexer.CmmToken

module GHC.Cmm.LRegSet
type LRegSet = Word64Set
type LRegKey = Word64
emptyLRegSet :: LRegSet
nullLRegSet :: LRegSet -> Bool
insertLRegSet :: LocalReg -> LRegSet -> LRegSet
elemLRegSet :: LocalReg -> LRegSet -> Bool
deleteFromLRegSet :: LRegSet -> LocalReg -> LRegSet
sizeLRegSet :: Word64Set -> Int
plusLRegSet :: Word64Set -> Word64Set -> Word64Set
elemsLRegSet :: Word64Set -> [Word64]

module GHC.Cmm
type CmmProgram = [CmmGroup]

-- | Cmm group before SRT generation
type CmmGroup = GenCmmGroup CmmStatics CmmTopInfo CmmGraph

-- | Cmm group with SRTs
type CmmGroupSRTs = GenCmmGroup RawCmmStatics CmmTopInfo CmmGraph

-- | <a>Raw</a> cmm group (TODO (osa): not sure what that means)
type RawCmmGroup = GenCmmGroup RawCmmStatics (LabelMap RawCmmStatics) CmmGraph
type GenCmmGroup d h g = [GenCmmDecl d h g]
type CmmDecl = GenCmmDecl CmmStatics CmmTopInfo CmmGraph
type CmmDeclSRTs = GenCmmDecl RawCmmStatics CmmTopInfo CmmGraph

-- | A top-level chunk, abstracted over the type of the contents of the
--   basic blocks (Cmm or instructions are the likely instantiations).
data GenCmmDecl d h g
CmmProc :: h -> CLabel -> [GlobalReg] -> g -> GenCmmDecl d h g
CmmData :: Section -> d -> GenCmmDecl d h g
type CmmDataDecl = GenCmmDataDecl CmmStatics
cmmDataDeclCmmDecl :: GenCmmDataDecl d -> GenCmmDecl d h g
type CmmGraph = GenCmmGraph CmmNode
data GenCmmGraph n
CmmGraph :: BlockId -> Graph n C C -> GenCmmGraph n
[g_entry] :: GenCmmGraph n -> BlockId
[g_graph] :: GenCmmGraph n -> Graph n C C
toBlockMap :: CmmGraph -> LabelMap CmmBlock
revPostorder :: CmmGraph -> [CmmBlock]
toBlockList :: CmmGraph -> [CmmBlock]
type CmmBlock = Block CmmNode C C
type RawCmmDecl = GenCmmDecl RawCmmStatics (LabelMap RawCmmStatics) CmmGraph
data Section
Section :: SectionType -> CLabel -> Section
data SectionType
Text :: SectionType
Data :: SectionType
ReadOnlyData :: SectionType
RelocatableReadOnlyData :: SectionType
UninitialisedData :: SectionType
InitArray :: SectionType
FiniArray :: SectionType
CString :: SectionType
OtherSection :: String -> SectionType
data GenCmmStatics (rawOnly :: Bool)
[CmmStatics] :: CLabel -> CmmInfoTable -> CostCentreStack -> [CmmLit] -> [CmmLit] -> GenCmmStatics 'False

-- | Static data, after SRTs are generated
[CmmStaticsRaw] :: CLabel -> [CmmStatic] -> GenCmmStatics a
type CmmStatics = GenCmmStatics 'False
type RawCmmStatics = GenCmmStatics 'True
data CmmStatic

-- | a literal value, size given by cmmLitRep of the literal.
CmmStaticLit :: CmmLit -> CmmStatic

-- | uninitialised data, N bytes long
CmmUninitialised :: Int -> CmmStatic

-- | string of 8-bit values only, not zero terminated.
CmmString :: ByteString -> CmmStatic

-- | an embedded binary file and its byte length
CmmFileEmbed :: FilePath -> Int -> CmmStatic
data SectionProtection
ReadWriteSection :: SectionProtection
ReadOnlySection :: SectionProtection
WriteProtectedSection :: SectionProtection

-- | Should a data in this section be considered constant at runtime
sectionProtection :: Section -> SectionProtection
data GenBasicBlock i
BasicBlock :: BlockId -> [i] -> GenBasicBlock i

-- | The branch block id is that of the first block in the branch, which is
--   that branch's entry point
blockId :: GenBasicBlock i -> BlockId
newtype ListGraph i
ListGraph :: [GenBasicBlock i] -> ListGraph i
pprBBlock :: Outputable stmt => GenBasicBlock stmt -> SDoc

-- | CmmTopInfo is attached to each CmmDecl (see defn of CmmGroup), and
--   contains the extra info (beyond the executable code) that belongs to
--   that CmmDecl.
data CmmTopInfo
TopInfo :: LabelMap CmmInfoTable -> CmmStackInfo -> CmmTopInfo
[info_tbls] :: CmmTopInfo -> LabelMap CmmInfoTable
[stack_info] :: CmmTopInfo -> CmmStackInfo
data CmmStackInfo
StackInfo :: ByteOff -> Bool -> CmmStackInfo
[arg_space] :: CmmStackInfo -> ByteOff
[do_layout] :: CmmStackInfo -> Bool

-- | Info table as a haskell data type
data CmmInfoTable
CmmInfoTable :: CLabel -> SMRep -> ProfilingInfo -> Maybe CLabel -> Maybe (Id, CostCentreStack) -> CmmInfoTable
[cit_lbl] :: CmmInfoTable -> CLabel
[cit_rep] :: CmmInfoTable -> SMRep
[cit_prof] :: CmmInfoTable -> ProfilingInfo
[cit_srt] :: CmmInfoTable -> Maybe CLabel
[cit_clo] :: CmmInfoTable -> Maybe (Id, CostCentreStack)
topInfoTable :: GenCmmDecl a CmmTopInfo (GenCmmGraph n) -> Maybe CmmInfoTable
data ClosureTypeInfo
Constr :: ConTagZ -> ConstrDescription -> ClosureTypeInfo
Fun :: FunArity -> ArgDescr -> ClosureTypeInfo
Thunk :: ClosureTypeInfo
ThunkSelector :: SelectorOffset -> ClosureTypeInfo
BlackHole :: ClosureTypeInfo
IndStatic :: ClosureTypeInfo
data ProfilingInfo
NoProfilingInfo :: ProfilingInfo
ProfilingInfo :: ByteString -> ByteString -> ProfilingInfo
type ConstrDescription = ByteString
pprCmmGroup :: (OutputableP Platform d, OutputableP Platform info, OutputableP Platform g) => Platform -> GenCmmGroup d info g -> SDoc
pprSection :: Platform -> Section -> SDoc
pprStatic :: Platform -> CmmStatic -> SDoc
instance GHC.Classes.Ord GHC.Cmm.ProfilingInfo
instance GHC.Classes.Eq GHC.Cmm.ProfilingInfo
instance GHC.Classes.Ord GHC.Cmm.CmmInfoTable
instance GHC.Classes.Eq GHC.Cmm.CmmInfoTable
instance GHC.Show.Show GHC.Cmm.SectionType
instance GHC.Classes.Eq GHC.Cmm.SectionProtection
instance GHC.Base.Functor (GHC.Cmm.GenCmmDecl d h)
instance GHC.Base.Functor GHC.Cmm.GenBasicBlock
instance GHC.Base.Functor GHC.Cmm.ListGraph
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.Cmm.ListGraph instr)
instance GHC.Utils.Outputable.OutputableP env instr => GHC.Utils.Outputable.OutputableP env (GHC.Cmm.ListGraph instr)
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.Cmm.GenBasicBlock instr)
instance GHC.Utils.Outputable.OutputableP env instr => GHC.Utils.Outputable.OutputableP env (GHC.Cmm.GenBasicBlock instr)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.GenCmmStatics a)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmStatic
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CmmStatic
instance (GHC.Utils.Outputable.OutputableP GHC.Platform.Platform d, GHC.Utils.Outputable.OutputableP GHC.Platform.Platform info, GHC.Utils.Outputable.OutputableP GHC.Platform.Platform i) => GHC.Utils.Outputable.OutputableP GHC.Platform.Platform (GHC.Cmm.GenCmmDecl d info i)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmTopInfo
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmInfoTable
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CmmStackInfo
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.CmmGraph

module GHC.StgToCmm.Sequel

-- | A Sequel tells what to do with the result of this expression
data Sequel

-- | Return result(s) to continuation found on the stack.
Return :: Sequel
AssignTo :: [LocalReg] -> Bool -> Sequel
data SelfLoopInfo
MkSelfLoopInfo :: !Id -> !RepArity -> ![LocalReg] -> !BlockId -> SelfLoopInfo
[sli_id] :: SelfLoopInfo -> !Id

-- | always equal to <a>idFunRepArity</a> of sli_id, i.e. unarised arity,
--   including void arguments
[sli_arity] :: SelfLoopInfo -> !RepArity

-- | Excludes void arguments (LocalReg is never void)
[sli_registers] :: SelfLoopInfo -> ![LocalReg]
[sli_header_block] :: SelfLoopInfo -> !BlockId
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Sequel.Sequel

module GHC.CmmToAsm.X86.Regs

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: FastString -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm
strImmLit :: FastString -> Imm
litToImm :: CmmLit -> Imm
data AddrMode
AddrBaseIndex :: EABase -> EAIndex -> Displacement -> AddrMode
ImmAddr :: Imm -> Int -> AddrMode
addrOffset :: AddrMode -> Int -> Maybe AddrMode
spRel :: Platform -> Int -> AddrMode
argRegs :: RegNo -> [Reg]
allArgRegs :: Platform -> [(Reg, Reg)]
allIntArgRegs :: Platform -> [Reg]

-- | these are the regs which we cannot assume stay alive over a C call.
callClobberedRegs :: Platform -> [Reg]
instrClobberedRegs :: Platform -> [Reg]

-- | The complete set of machine registers.
allMachRegNos :: Platform -> [RegNo]

-- | Take the class of a register.
classOfRealReg :: Platform -> RealReg -> RegClass

-- | Get the name of the register with this number. NOTE: fixme, we dont
--   track which "way" the XMM registers are used
showReg :: Platform -> RegNo -> String
data EABase
EABaseNone :: EABase
EABaseReg :: Reg -> EABase
EABaseRip :: EABase
data EAIndex
EAIndexNone :: EAIndex
EAIndex :: Reg -> Int -> EAIndex
addrModeRegs :: AddrMode -> [Reg]
eax :: Reg
ebx :: Reg
ecx :: Reg
edx :: Reg
esi :: Reg
edi :: Reg
ebp :: Reg
esp :: Reg
rax :: Reg
rbx :: Reg
rcx :: Reg
rdx :: Reg
rsi :: Reg
rdi :: Reg
rbp :: Reg
rsp :: Reg
r8 :: Reg
r9 :: Reg
r10 :: Reg
r11 :: Reg
r12 :: Reg
r13 :: Reg
r14 :: Reg
r15 :: Reg
lastint :: Platform -> RegNo
xmm0 :: Reg
xmm1 :: Reg
xmm2 :: Reg
xmm3 :: Reg
xmm4 :: Reg
xmm5 :: Reg
xmm6 :: Reg
xmm7 :: Reg
xmm8 :: Reg
xmm9 :: Reg
xmm10 :: Reg
xmm11 :: Reg
xmm12 :: Reg
xmm13 :: Reg
xmm14 :: Reg
xmm15 :: Reg
xmm :: RegNo -> Reg
firstxmm :: RegNo
lastxmm :: Platform -> RegNo
ripRel :: Displacement -> AddrMode

-- | on 64bit platforms we pass the first 8 float/double arguments in the
--   xmm registers.
allFPArgRegs :: Platform -> [Reg]
allocatableRegs :: Platform -> [RealReg]


-- | Free regs map for x86_64
module GHC.CmmToAsm.Reg.Linear.X86_64
newtype FreeRegs
FreeRegs :: Word64 -> FreeRegs
noFreeRegs :: FreeRegs
releaseReg :: RealReg -> FreeRegs -> FreeRegs
initFreeRegs :: Platform -> FreeRegs
getFreeRegs :: Platform -> RegClass -> FreeRegs -> [RealReg]
allocateReg :: RealReg -> FreeRegs -> FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.X86_64.FreeRegs
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.X86_64.FreeRegs


-- | Free regs map for i386
module GHC.CmmToAsm.Reg.Linear.X86
newtype FreeRegs
FreeRegs :: Word32 -> FreeRegs
noFreeRegs :: FreeRegs
releaseReg :: RealReg -> FreeRegs -> FreeRegs
initFreeRegs :: Platform -> FreeRegs
getFreeRegs :: Platform -> RegClass -> FreeRegs -> [RealReg]
allocateReg :: RealReg -> FreeRegs -> FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.X86.FreeRegs
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.X86.FreeRegs

module GHC.CmmToAsm.Wasm.Utils
widthMax :: Width -> Integer
detEltsUFM :: Ord k => UniqFM k0 (k, a) -> [(k, a)]
detEltsUniqMap :: Ord k => UniqMap k a -> [(k, a)]
builderCommas :: (a -> Builder) -> [a] -> Builder

module GHC.CmmToAsm.Wasm.Types

-- | WebAssembly type of a WebAssembly value that WebAssembly code could
--   either expect on the evaluation stack or leave on the evaluation
--   stack.
data WasmType
I32 :: WasmType
I64 :: WasmType
F32 :: WasmType
F64 :: WasmType

-- | Singleton type useful for programming with <a>WasmType</a> at the type
--   level.
data WasmTypeTag :: WasmType -> Type
[TagI32] :: WasmTypeTag 'I32
[TagI64] :: WasmTypeTag 'I64
[TagF32] :: WasmTypeTag 'F32
[TagF64] :: WasmTypeTag 'F64
data SomeWasmType
[SomeWasmType] :: WasmTypeTag t -> SomeWasmType

-- | List of WebAssembly types used to describe the sequence of WebAssembly
--   values that a block of code may expect on the stack or leave on the
--   stack.
data TypeList :: [WasmType] -> Type
[TypeListNil] :: TypeList '[]
[TypeListCons] :: WasmTypeTag t -> TypeList ts -> TypeList (t : ts)
someWasmTypesFromTypeList :: TypeList ts -> [SomeWasmType]

-- | The type of a WebAssembly function, loop, block, or conditional. This
--   type says what values the code expects to pop off the stack and what
--   values it promises to push. The WebAssembly standard requires that
--   this type appear explicitly in the code.
data WasmFunctionType pre post
WasmFunctionType :: TypeList pre -> TypeList post -> WasmFunctionType pre post
[ft_pops] :: WasmFunctionType pre post -> TypeList pre
[ft_pushes] :: WasmFunctionType pre post -> TypeList post

-- | For simplicity, we record other metadata in <a>WasmCodeGenState</a> by
--   need, instead of carrying them along with <a>SymName</a>.
newtype SymName
SymName :: FastString -> SymName
data SymVisibility

-- | Not defined in the current compilation unit.
--   
--   <pre>
--   [ undefined binding=global vis=default ]
--   </pre>
SymUndefined :: SymVisibility

-- | Defined, not visible to other compilation units.
--   
--   <pre>
--   [ binding=local vis=default ]
--   </pre>
SymStatic :: SymVisibility

-- | Defined, visible to other compilation units.
--   
--   Adds <tt>.hidden</tt> &amp; <tt>.globl</tt> directives in the output
--   assembly.
--   
--   <pre>
--   [ binding=global vis=hidden ]
--   </pre>
SymDefault :: SymVisibility

-- | Represents whether a symbol is a data symbol or a function symbol.
--   Unlike linkers for other targets, <tt>wasm-ld</tt> does panic at
--   link-time if it finds symbol kind inconsistency between the definition
--   site and other use sites.
--   
--   Currently we solely rely on <tt>isCFunctionLabel</tt> to determine a
--   symbol's kind, but it does take extra effort to make it work. The main
--   source of inconsistency arises from hand-written Cmm sources, where
--   it's possible to refer to external entities like <tt>xxx_info</tt> and
--   <tt>xxx_closure</tt> without explicit <tt>import CLOSURE</tt>
--   declarations. The Cmm parser will implicitly assume those are foreign
--   function labels, and then this will break the WebAssembly backend.
--   #22368 provides more context on this issue.
--   
--   tl;dr for any GHC contributor that accidentally triggers
--   <tt>wasm-ld</tt> errors when hacking Cmm: whatever data symbols are
--   used in new code, just add the corresponding <tt>import CLOSURE</tt>
--   declarations at the top of that Cmm file.
data SymKind
SymData :: SymKind
SymFunc :: SymKind

-- | WebAssembly doesn't really have proper read-only memory regions yet.
--   Neverthless we add the .rodata logic here, wasm-ld will aggregate all
--   .rodata sections into a single one, which adds possibility for runtime
--   checks later, either via a customized runtime, or via code
--   instrumentation. See
--   <a>https://github.com/llvm/llvm-project/blob/b296aed8ae239c20ebdd7969e978f8d2a3b9c178/lld/wasm/Writer.cpp#L856</a>
data DataSectionKind
SectionData :: DataSectionKind
SectionROData :: DataSectionKind

-- | Neither Cmm or Wasm type system takes integer signedness into account,
--   therefore we always round up a <a>CmmExpr</a> to the right width and
--   handle it as an untyped integer.
data DataSectionContent
DataI8 :: Word8 -> DataSectionContent
DataI16 :: Word16 -> DataSectionContent
DataI32 :: Word32 -> DataSectionContent
DataI64 :: Word64 -> DataSectionContent
DataF32 :: Float -> DataSectionContent
DataF64 :: Double -> DataSectionContent
DataSym :: SymName -> Int -> DataSectionContent
DataSkip :: Int -> DataSectionContent
DataASCII :: ByteString -> DataSectionContent
DataIncBin :: FilePath -> Int -> DataSectionContent
data DataSection
DataSection :: DataSectionKind -> Alignment -> [DataSectionContent] -> DataSection
[dataSectionKind] :: DataSection -> DataSectionKind
[dataSectionAlignment] :: DataSection -> Alignment
[dataSectionContents] :: DataSection -> [DataSectionContent]
type GlobalInfo = (SymName, SomeWasmType)
type LocalInfo = (Int, SomeWasmType)
data FuncBody w
FuncBody :: [SomeWasmType] -> WasmControl (WasmStatements w) (WasmExpr w w) '[] '[w] -> FuncBody w
[funcLocals] :: FuncBody w -> [SomeWasmType]

-- | Most are Cmm functions, but may also contain synthesized function of
--   other types, sigh.
[funcBody] :: FuncBody w -> WasmControl (WasmStatements w) (WasmExpr w w) '[] '[w]
data Signage
Signed :: Signage
Unsigned :: Signage

-- | The <tt>w</tt> type variable in the Wasm IR stands for "platform word
--   type", so <a>TagI32</a> on wasm32, and <a>TagI64</a> on wasm64. This
--   way, we can make the codegen logic work on both wasm32/wasm64 in a
--   type-safe manner.
data WasmInstr :: WasmType -> [WasmType] -> [WasmType] -> Type
[WasmComment] :: String -> WasmInstr w pre pre
[WasmNop] :: WasmInstr w pre pre
[WasmDrop] :: WasmInstr w (t : pre) pre
[WasmUnreachable] :: WasmInstr w pre post
[WasmConst] :: WasmTypeTag t -> Integer -> WasmInstr w pre (t : pre)
[WasmSymConst] :: SymName -> WasmInstr w pre (w : pre)
[WasmLoad] :: WasmTypeTag t -> Maybe Int -> Signage -> Int -> AlignmentSpec -> WasmInstr w (w : pre) (t : pre)
[WasmStore] :: WasmTypeTag t -> Maybe Int -> Int -> AlignmentSpec -> WasmInstr w (t : (w : pre)) pre
[WasmGlobalGet] :: WasmTypeTag t -> SymName -> WasmInstr w pre (t : pre)
[WasmGlobalSet] :: WasmTypeTag t -> SymName -> WasmInstr w (t : pre) pre
[WasmLocalGet] :: WasmTypeTag t -> Int -> WasmInstr w pre (t : pre)
[WasmLocalSet] :: WasmTypeTag t -> Int -> WasmInstr w (t : pre) pre
[WasmLocalTee] :: WasmTypeTag t -> Int -> WasmInstr w (t : pre) (t : pre)
[WasmCCall] :: SymName -> WasmInstr w pre post
[WasmCCallIndirect] :: TypeList arg_tys -> TypeList ret_tys -> WasmInstr w (w : pre) post
[WasmConcat] :: WasmInstr w pre mid -> WasmInstr w mid post -> WasmInstr w pre post
[WasmReinterpret] :: WasmTypeTag t0 -> WasmTypeTag t1 -> WasmInstr w (t0 : pre) (t1 : pre)
[WasmTruncSat] :: Signage -> WasmTypeTag t0 -> WasmTypeTag t1 -> WasmInstr w (t0 : pre) (t1 : pre)
[WasmConvert] :: Signage -> WasmTypeTag t0 -> WasmTypeTag t1 -> WasmInstr w (t0 : pre) (t1 : pre)
[WasmAdd] :: WasmTypeTag t -> WasmInstr w (t : (t : pre)) (t : pre)
[WasmSub] :: WasmTypeTag t -> WasmInstr w (t : (t : pre)) (t : pre)
[WasmMul] :: WasmTypeTag t -> WasmInstr w (t : (t : pre)) (t : pre)
[WasmDiv] :: Signage -> WasmTypeTag t -> WasmInstr w (t : (t : pre)) (t : pre)
[WasmRem] :: Signage -> WasmTypeTag t -> WasmInstr w (t : (t : pre)) (t : pre)
[WasmAnd] :: WasmTypeTag t -> WasmInstr w (t : (t : pre)) (t : pre)
[WasmOr] :: WasmTypeTag t -> WasmInstr w (t : (t : pre)) (t : pre)
[WasmXor] :: WasmTypeTag t -> WasmInstr w (t : (t : pre)) (t : pre)
[WasmEq] :: WasmTypeTag t -> WasmInstr w (t : (t : pre)) (w : pre)
[WasmNe] :: WasmTypeTag t -> WasmInstr w (t : (t : pre)) (w : pre)
[WasmLt] :: Signage -> WasmTypeTag t -> WasmInstr w (t : (t : pre)) (w : pre)
[WasmGt] :: Signage -> WasmTypeTag t -> WasmInstr w (t : (t : pre)) (w : pre)
[WasmLe] :: Signage -> WasmTypeTag t -> WasmInstr w (t : (t : pre)) (w : pre)
[WasmGe] :: Signage -> WasmTypeTag t -> WasmInstr w (t : (t : pre)) (w : pre)
[WasmShl] :: WasmTypeTag t -> WasmInstr w (t : (t : pre)) (t : pre)
[WasmShr] :: Signage -> WasmTypeTag t -> WasmInstr w (t : (t : pre)) (t : pre)
[WasmI32Extend8S] :: WasmInstr w ('I32 : pre) ('I32 : pre)
[WasmI32Extend16S] :: WasmInstr w ('I32 : pre) ('I32 : pre)
[WasmI64Extend8S] :: WasmInstr w ('I64 : pre) ('I64 : pre)
[WasmI64Extend16S] :: WasmInstr w ('I64 : pre) ('I64 : pre)
[WasmI64Extend32S] :: WasmInstr w ('I64 : pre) ('I64 : pre)
[WasmI64ExtendI32] :: Signage -> WasmInstr w ('I32 : pre) ('I64 : pre)
[WasmI32WrapI64] :: WasmInstr w ('I64 : pre) ('I32 : pre)
[WasmF32DemoteF64] :: WasmInstr w ('F64 : pre) ('F32 : pre)
[WasmF64PromoteF32] :: WasmInstr w ('F32 : pre) ('F64 : pre)
[WasmAbs] :: WasmTypeTag t -> WasmInstr w (t : pre) (t : pre)
[WasmNeg] :: WasmTypeTag t -> WasmInstr w (t : pre) (t : pre)
[WasmCond] :: WasmInstr w pre pre -> WasmInstr w (w : pre) pre
newtype WasmExpr w t
WasmExpr :: (forall pre. WasmInstr w pre (t : pre)) -> WasmExpr w t
data SomeWasmExpr w
[SomeWasmExpr] :: WasmTypeTag t -> WasmExpr w t -> SomeWasmExpr w
newtype WasmStatements w
WasmStatements :: (forall pre. WasmInstr w pre pre) -> WasmStatements w

-- | Representation of WebAssembly control flow. Normally written as <tt>
--   WasmControl s e pre post </tt> Type parameter <tt>s</tt> is the type
--   of (unspecified) statements. It might be instantiated with an open Cmm
--   block or with a sequence of Wasm instructions. Parameter <tt>e</tt> is
--   the type of expressions. Parameter <tt>pre</tt> represents the values
--   that are expected on the WebAssembly stack when the code runs, and
--   <tt>post</tt> represents the state of the stack on completion.
data WasmControl :: Type -> Type -> [WasmType] -> [WasmType] -> Type
[WasmPush] :: WasmTypeTag t -> e -> WasmControl s e stack (t : stack)
[WasmBlock] :: WasmFunctionType pre post -> WasmControl s e pre post -> WasmControl s e pre post
[WasmLoop] :: WasmFunctionType pre post -> WasmControl s e pre post -> WasmControl s e pre post
[WasmIfTop] :: WasmFunctionType pre post -> WasmControl s e pre post -> WasmControl s e pre post -> WasmControl s e ('I32 : pre) post
[WasmBr] :: Int -> WasmControl s e dropped destination
[WasmFallthrough] :: WasmControl s e dropped destination
[WasmBrTable] :: e -> BrTableInterval -> [Int] -> Int -> WasmControl s e dropped destination
[WasmTailCall] :: e -> WasmControl s e t1star t2star
[WasmActions] :: s -> WasmControl s e stack stack
[WasmSeq] :: WasmControl s e pre mid -> WasmControl s e mid post -> WasmControl s e pre post
data BrTableInterval
BrTableInterval :: Integer -> Integer -> BrTableInterval
[bti_lo] :: BrTableInterval -> Integer
[bti_count] :: BrTableInterval -> Integer
wasmControlCast :: WasmControl s e pre post -> WasmControl s e pre' post'
data WasmCodeGenState w
WasmCodeGenState :: Platform -> SymSet -> SymMap ([SomeWasmType], [SomeWasmType]) -> SymMap (FuncBody w) -> SymMap DataSection -> [SymName] -> UniqFM LocalReg LocalInfo -> Int -> UniqSupply -> WasmCodeGenState w

-- | Target platform
[wasmPlatform] :: WasmCodeGenState w -> Platform

-- | Defined symbols with <a>SymDefault</a> visibility.
[defaultSyms] :: WasmCodeGenState w -> SymSet

-- | Function types, defined or not. There may exist a function whose type
--   is unknown (e.g. as a function pointer), in that case we fall back to
--   () -&gt; (), it's imperfect but works with wasm-ld.
[funcTypes] :: WasmCodeGenState w -> SymMap ([SomeWasmType], [SomeWasmType])

-- | Defined function bodies.
[funcBodies] :: WasmCodeGenState w -> SymMap (FuncBody w)

-- | Defined data sections.
[dataSections] :: WasmCodeGenState w -> SymMap DataSection

-- | ctors in the current compilation unit.
[ctors] :: WasmCodeGenState w -> [SymName]
[localRegs] :: WasmCodeGenState w -> UniqFM LocalReg LocalInfo
[localRegsCount] :: WasmCodeGenState w -> Int
[wasmUniqSupply] :: WasmCodeGenState w -> UniqSupply
initialWasmCodeGenState :: Platform -> UniqSupply -> WasmCodeGenState w
newtype WasmCodeGenM w a
WasmCodeGenM :: State (WasmCodeGenState w) a -> WasmCodeGenM w a
wasmGetsM :: (WasmCodeGenState w -> a) -> WasmCodeGenM w a
wasmPlatformM :: WasmCodeGenM w Platform
wasmWordTypeM :: WasmCodeGenM w (WasmTypeTag w)
wasmWordCmmTypeM :: WasmCodeGenM w CmmType
wasmStateM :: (WasmCodeGenState w -> (# a, WasmCodeGenState w #)) -> WasmCodeGenM w a
wasmModifyM :: (WasmCodeGenState w -> WasmCodeGenState w) -> WasmCodeGenM w ()
wasmExecM :: WasmCodeGenM w a -> WasmCodeGenState w -> WasmCodeGenState w
wasmUniq :: WasmCodeGenM w Unique
instance GHC.Classes.Ord GHC.CmmToAsm.Wasm.Types.SymName
instance GHC.Types.Unique.Uniquable GHC.CmmToAsm.Wasm.Types.SymName
instance GHC.Show.Show GHC.CmmToAsm.Wasm.Types.SymName
instance Data.String.IsString GHC.CmmToAsm.Wasm.Types.SymName
instance GHC.Classes.Eq GHC.CmmToAsm.Wasm.Types.SymName
instance GHC.Classes.Eq GHC.CmmToAsm.Wasm.Types.SymKind
instance GHC.Show.Show GHC.CmmToAsm.Wasm.Types.BrTableInterval
instance GHC.Base.Monad (GHC.CmmToAsm.Wasm.Types.WasmCodeGenM w)
instance GHC.Base.Applicative (GHC.CmmToAsm.Wasm.Types.WasmCodeGenM w)
instance GHC.Base.Functor (GHC.CmmToAsm.Wasm.Types.WasmCodeGenM w)
instance GHC.Show.Show (GHC.CmmToAsm.Wasm.Types.WasmTypeTag t)
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Wasm.Types.BrTableInterval
instance GHC.Classes.Eq GHC.CmmToAsm.Wasm.Types.SomeWasmType
instance Data.Type.Equality.TestEquality GHC.CmmToAsm.Wasm.Types.WasmTypeTag

module GHC.Wasm.ControlFlow

-- | Representation of WebAssembly control flow. Normally written as <tt>
--   WasmControl s e pre post </tt> Type parameter <tt>s</tt> is the type
--   of (unspecified) statements. It might be instantiated with an open Cmm
--   block or with a sequence of Wasm instructions. Parameter <tt>e</tt> is
--   the type of expressions. Parameter <tt>pre</tt> represents the values
--   that are expected on the WebAssembly stack when the code runs, and
--   <tt>post</tt> represents the state of the stack on completion.
data WasmControl :: Type -> Type -> [WasmType] -> [WasmType] -> Type
[WasmPush] :: WasmTypeTag t -> e -> WasmControl s e stack (t : stack)
[WasmBlock] :: WasmFunctionType pre post -> WasmControl s e pre post -> WasmControl s e pre post
[WasmLoop] :: WasmFunctionType pre post -> WasmControl s e pre post -> WasmControl s e pre post
[WasmIfTop] :: WasmFunctionType pre post -> WasmControl s e pre post -> WasmControl s e pre post -> WasmControl s e ('I32 : pre) post
[WasmBr] :: Int -> WasmControl s e dropped destination
[WasmFallthrough] :: WasmControl s e dropped destination
[WasmBrTable] :: e -> BrTableInterval -> [Int] -> Int -> WasmControl s e dropped destination
[WasmTailCall] :: e -> WasmControl s e t1star t2star
[WasmActions] :: s -> WasmControl s e stack stack
[WasmSeq] :: WasmControl s e pre mid -> WasmControl s e mid post -> WasmControl s e pre post
(<>) :: forall s e pre mid post. WasmControl s e pre mid -> WasmControl s e mid post -> WasmControl s e pre post
pattern WasmIf :: WasmFunctionType pre post -> e -> WasmControl s e pre post -> WasmControl s e pre post -> WasmControl s e pre post
data BrTableInterval
BrTableInterval :: Integer -> Integer -> BrTableInterval
[bti_lo] :: BrTableInterval -> Integer
[bti_count] :: BrTableInterval -> Integer

-- | Module : GHC.Wasm.ControlFlow Description : Representation of
--   control-flow portion of the WebAssembly instruction set
inclusiveInterval :: Integer -> Integer -> BrTableInterval

-- | WebAssembly type of a WebAssembly value that WebAssembly code could
--   either expect on the evaluation stack or leave on the evaluation
--   stack.
data WasmType

-- | Singleton type useful for programming with <a>WasmType</a> at the type
--   level.
data WasmTypeTag :: WasmType -> Type
[TagI32] :: WasmTypeTag 'I32
[TagI64] :: WasmTypeTag 'I64
[TagF32] :: WasmTypeTag 'F32
[TagF64] :: WasmTypeTag 'F64

-- | List of WebAssembly types used to describe the sequence of WebAssembly
--   values that a block of code may expect on the stack or leave on the
--   stack.
data TypeList :: [WasmType] -> Type
[TypeListNil] :: TypeList '[]
[TypeListCons] :: WasmTypeTag t -> TypeList ts -> TypeList (t : ts)

-- | The type of a WebAssembly function, loop, block, or conditional. This
--   type says what values the code expects to pop off the stack and what
--   values it promises to push. The WebAssembly standard requires that
--   this type appear explicitly in the code.
data WasmFunctionType pre post
WasmFunctionType :: TypeList pre -> TypeList post -> WasmFunctionType pre post
[ft_pops] :: WasmFunctionType pre post -> TypeList pre
[ft_pushes] :: WasmFunctionType pre post -> TypeList post

module GHC.CmmToAsm.Utils

-- | Returns the info table associated with the CmmDecl's entry point, if
--   any.
topInfoTable :: GenCmmDecl a (LabelMap i) (ListGraph b) -> Maybe i

-- | Return the list of BlockIds in a CmmDecl that are entry points for
--   this proc (i.e. they may be jumped to from outside this proc).
entryBlocks :: GenCmmDecl a (LabelMap i) (ListGraph b) -> [BlockId]

module GHC.CmmToAsm.Types
type NatCmm instr = GenCmmGroup RawCmmStatics (LabelMap RawCmmStatics) (ListGraph instr)
type NatCmmDecl statics instr = GenCmmDecl statics (LabelMap RawCmmStatics) (ListGraph instr)
type NatBasicBlock instr = GenBasicBlock instr
data GenBasicBlock i
BasicBlock :: BlockId -> [i] -> GenBasicBlock i

-- | The branch block id is that of the first block in the branch, which is
--   that branch's entry point
blockId :: GenBasicBlock i -> BlockId
newtype ListGraph i
ListGraph :: [GenBasicBlock i] -> ListGraph i
type RawCmmStatics = GenCmmStatics 'True
type RawCmmDecl = GenCmmDecl RawCmmStatics (LabelMap RawCmmStatics) CmmGraph

module GHC.CmmToAsm.Ppr

-- | Get bytes of a Double representation
doubleToBytes :: Double -> [Word8]

-- | Get bytes of a Float representation
floatToBytes :: Float -> [Word8]
pprASCII :: forall doc. IsLine doc => ByteString -> doc

-- | Emit a ".string" directive
pprString :: IsLine doc => ByteString -> doc

-- | Emit a ".incbin" directive
--   
--   A NULL byte is added after the binary data.
pprFileEmbed :: IsLine doc => FilePath -> doc
pprSectionHeader :: IsLine doc => NCGConfig -> Section -> doc


-- | The LLVM Type System.
module GHC.Llvm.Types

-- | A global mutable variable. Maybe defined or external
data LMGlobal
LMGlobal :: LlvmVar -> Maybe LlvmStatic -> LMGlobal

-- | Returns the variable of the <a>LMGlobal</a>
[getGlobalVar] :: LMGlobal -> LlvmVar

-- | Return the value of the <a>LMGlobal</a>
[getGlobalValue] :: LMGlobal -> Maybe LlvmStatic

-- | A String in LLVM
type LMString = FastString

-- | A type alias
type LlvmAlias = (LMString, LlvmType)

-- | Llvm Types
data LlvmType

-- | An integer with a given width in bits.
LMInt :: Int -> LlvmType

-- | 32 bit floating point
LMFloat :: LlvmType

-- | 64 bit floating point
LMDouble :: LlvmType

-- | 80 bit (x86 only) floating point
LMFloat80 :: LlvmType

-- | 128 bit floating point
LMFloat128 :: LlvmType

-- | A pointer to a <a>LlvmType</a>
LMPointer :: LlvmType -> LlvmType

-- | An array of <a>LlvmType</a>
LMArray :: Int -> LlvmType -> LlvmType

-- | A vector of <a>LlvmType</a>
LMVector :: Int -> LlvmType -> LlvmType

-- | A <a>LlvmVar</a> can represent a label (address)
LMLabel :: LlvmType

-- | Void type
LMVoid :: LlvmType

-- | Packed structure type
LMStruct :: [LlvmType] -> LlvmType

-- | Unpacked structure type
LMStructU :: [LlvmType] -> LlvmType

-- | A type alias
LMAlias :: LlvmAlias -> LlvmType

-- | LLVM Metadata
LMMetadata :: LlvmType

-- | Function type, used to create pointers to functions
LMFunction :: LlvmFunctionDecl -> LlvmType
ppType :: LlvmType -> SDoc
ppParams :: LlvmParameterListType -> [LlvmParameter] -> SDoc

-- | An LLVM section definition. If Nothing then let LLVM decide the
--   section
type LMSection = Maybe LMString
type LMAlign = Maybe Int
data LMConst

-- | Mutable global variable
Global :: LMConst

-- | Constant global variable
Constant :: LMConst

-- | Alias of another variable
Alias :: LMConst

-- | LLVM Variables
data LlvmVar

-- | Variables with a global scope.
LMGlobalVar :: LMString -> LlvmType -> LlvmLinkageType -> LMSection -> LMAlign -> LMConst -> LlvmVar

-- | Variables local to a function or parameters.
LMLocalVar :: Unique -> LlvmType -> LlvmVar

-- | Named local variables. Sometimes we need to be able to explicitly name
--   variables (e.g for function arguments).
LMNLocalVar :: LMString -> LlvmType -> LlvmVar

-- | A constant variable
LMLitVar :: LlvmLit -> LlvmVar

-- | Llvm Literal Data.
--   
--   These can be used inline in expressions.
data LlvmLit

-- | Refers to an integer constant (i64 42).
LMIntLit :: Integer -> LlvmType -> LlvmLit

-- | Floating point literal
LMFloatLit :: Double -> LlvmType -> LlvmLit

-- | Literal NULL, only applicable to pointer types
LMNullLit :: LlvmType -> LlvmLit

-- | Vector literal
LMVectorLit :: [LlvmLit] -> LlvmLit

-- | Undefined value, random bit pattern. Useful for optimisations.
LMUndefLit :: LlvmType -> LlvmLit

-- | Llvm Static Data.
--   
--   These represent the possible global level variables and constants.
data LlvmStatic

-- | A comment in a static section
LMComment :: LMString -> LlvmStatic

-- | A static variant of a literal value
LMStaticLit :: LlvmLit -> LlvmStatic

-- | For uninitialised data
LMUninitType :: LlvmType -> LlvmStatic

-- | Defines a static <a>LMString</a>
LMStaticStr :: LMString -> LlvmType -> LlvmStatic

-- | A static array
LMStaticArray :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A static structure type
LMStaticStruc :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A static structure type
LMStaticStrucU :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A pointer to other data
LMStaticPointer :: LlvmVar -> LlvmStatic

-- | Truncate
LMTrunc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Pointer conversion
LMBitc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Integer conversion
LMPtoI :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Constant addition operation
LMAdd :: LlvmStatic -> LlvmStatic -> LlvmStatic

-- | Constant subtraction operation
LMSub :: LlvmStatic -> LlvmStatic -> LlvmStatic
garbageLit :: LlvmType -> Maybe LlvmLit

-- | Return the <a>LlvmType</a> of the <a>LlvmVar</a>
getVarType :: LlvmVar -> LlvmType

-- | Return the <a>LlvmType</a> of a <a>LlvmLit</a>
getLitType :: LlvmLit -> LlvmType

-- | Return the <a>LlvmType</a> of the <a>LlvmStatic</a>
getStatType :: LlvmStatic -> LlvmType

-- | Return the <a>LlvmLinkageType</a> for a <a>LlvmVar</a>
getLink :: LlvmVar -> LlvmLinkageType

-- | Add a pointer indirection to the supplied type. <a>LMLabel</a> and
--   <a>LMVoid</a> cannot be lifted.
pLift :: LlvmType -> LlvmType

-- | Lift a variable to <a>LMPointer</a> type.
pVarLift :: LlvmVar -> LlvmVar

-- | Remove the pointer indirection of the supplied type. Only
--   <a>LMPointer</a> constructors can be lowered.
pLower :: LlvmType -> LlvmType

-- | Lower a variable of <a>LMPointer</a> type.
pVarLower :: LlvmVar -> LlvmVar

-- | Test if the given <a>LlvmType</a> is an integer
isInt :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is a floating point type
isFloat :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMPointer</a> construct
isPointer :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMVector</a> construct
isVector :: LlvmType -> Bool

-- | Test if a <a>LlvmVar</a> is global.
isGlobal :: LlvmVar -> Bool

-- | Width in bits of an <a>LlvmType</a>, returns 0 if not applicable
llvmWidthInBits :: Platform -> LlvmType -> Int
i128 :: LlvmType
i64 :: LlvmType
i32 :: LlvmType
i16 :: LlvmType
i8 :: LlvmType
i1 :: LlvmType
i8Ptr :: LlvmType

-- | The target architectures word size
llvmWord :: Platform -> LlvmType

-- | The target architectures word size
llvmWordPtr :: Platform -> LlvmType

-- | An LLVM Function
data LlvmFunctionDecl
LlvmFunctionDecl :: LMString -> LlvmLinkageType -> LlvmCallConvention -> LlvmType -> LlvmParameterListType -> [LlvmParameter] -> LMAlign -> LlvmFunctionDecl

-- | Unique identifier of the function
[decName] :: LlvmFunctionDecl -> LMString

-- | LinkageType of the function
[funcLinkage] :: LlvmFunctionDecl -> LlvmLinkageType

-- | The calling convention of the function
[funcCc] :: LlvmFunctionDecl -> LlvmCallConvention

-- | Type of the returned value
[decReturnType] :: LlvmFunctionDecl -> LlvmType

-- | Indicates if this function uses varargs
[decVarargs] :: LlvmFunctionDecl -> LlvmParameterListType

-- | Parameter types and attributes
[decParams] :: LlvmFunctionDecl -> [LlvmParameter]

-- | Function align value, must be power of 2
[funcAlign] :: LlvmFunctionDecl -> LMAlign
type LlvmFunctionDecls = [LlvmFunctionDecl]
type LlvmParameter = (LlvmType, [LlvmParamAttr])

-- | LLVM Parameter Attributes.
--   
--   Parameter attributes are used to communicate additional information
--   about the result or parameters of a function
data LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be zero-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
ZeroExt :: LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be sign-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
SignExt :: LlvmParamAttr

-- | This indicates that this parameter or return value should be treated
--   in a special target-dependent fashion during while emitting code for a
--   function call or return (usually, by putting it in a register as
--   opposed to memory).
InReg :: LlvmParamAttr

-- | This indicates that the pointer parameter should really be passed by
--   value to the function.
ByVal :: LlvmParamAttr

-- | This indicates that the pointer parameter specifies the address of a
--   structure that is the return value of the function in the source
--   program.
SRet :: LlvmParamAttr

-- | This indicates that the pointer does not alias any global or any other
--   parameter.
NoAlias :: LlvmParamAttr

-- | This indicates that the callee does not make any copies of the pointer
--   that outlive the callee itself
NoCapture :: LlvmParamAttr

-- | This indicates that the pointer parameter can be excised using the
--   trampoline intrinsics.
Nest :: LlvmParamAttr

-- | Llvm Function Attributes.
--   
--   Function attributes are set to communicate additional information
--   about a function. Function attributes are considered to be part of the
--   function, not of the function type, so functions with different
--   parameter attributes can have the same function type. Functions can
--   have multiple attributes.
--   
--   Descriptions taken from
--   <a>http://llvm.org/docs/LangRef.html#fnattrs</a>
data LlvmFuncAttr

-- | This attribute indicates that the inliner should attempt to inline
--   this function into callers whenever possible, ignoring any active
--   inlining size threshold for this caller.
AlwaysInline :: LlvmFuncAttr

-- | This attribute indicates that the source code contained a hint that
--   inlining this function is desirable (such as the "inline" keyword in
--   C/C++). It is just a hint; it imposes no requirements on the inliner.
InlineHint :: LlvmFuncAttr

-- | This attribute indicates that the inliner should never inline this
--   function in any situation. This attribute may not be used together
--   with the alwaysinline attribute.
NoInline :: LlvmFuncAttr

-- | This attribute suggests that optimization passes and code generator
--   passes make choices that keep the code size of this function low, and
--   otherwise do optimizations specifically to reduce code size.
OptSize :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns
--   normally. This produces undefined behavior at runtime if the function
--   ever does dynamically return.
NoReturn :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns with
--   an unwind or exceptional control flow. If the function does unwind,
--   its runtime behavior is undefined.
NoUnwind :: LlvmFuncAttr

-- | This attribute indicates that the function computes its result (or
--   decides to unwind an exception) based strictly on its arguments,
--   without dereferencing any pointer arguments or otherwise accessing any
--   mutable state (e.g. memory, control registers, etc) visible to caller
--   functions. It does not write through any pointer arguments (including
--   byval arguments) and never changes any state visible to callers. This
--   means that it cannot unwind exceptions by calling the C++ exception
--   throwing methods, but could use the unwind instruction.
ReadNone :: LlvmFuncAttr

-- | This attribute indicates that the function does not write through any
--   pointer arguments (including byval arguments) or otherwise modify any
--   state (e.g. memory, control registers, etc) visible to caller
--   functions. It may dereference pointer arguments and read state that
--   may be set in the caller. A readonly function always returns the same
--   value (or unwinds an exception identically) when called with the same
--   set of arguments and global state. It cannot unwind an exception by
--   calling the C++ exception throwing methods, but may use the unwind
--   instruction.
ReadOnly :: LlvmFuncAttr

-- | This attribute indicates that the function should emit a stack
--   smashing protector. It is in the form of a "canary"—a random value
--   placed on the stack before the local variables that's checked upon
--   return from the function to see if it has been overwritten. A
--   heuristic is used to determine if a function needs stack protectors or
--   not.
--   
--   If a function that has an ssp attribute is inlined into a function
--   that doesn't have an ssp attribute, then the resulting function will
--   have an ssp attribute.
Ssp :: LlvmFuncAttr

-- | This attribute indicates that the function should always emit a stack
--   smashing protector. This overrides the ssp function attribute.
--   
--   If a function that has an sspreq attribute is inlined into a function
--   that doesn't have an sspreq attribute or which has an ssp attribute,
--   then the resulting function will have an sspreq attribute.
SspReq :: LlvmFuncAttr

-- | This attribute indicates that the code generator should not use a red
--   zone, even if the target-specific ABI normally permits it.
NoRedZone :: LlvmFuncAttr

-- | This attributes disables implicit floating point instructions.
NoImplicitFloat :: LlvmFuncAttr

-- | This attribute disables prologue / epilogue emission for the function.
--   This can have very system-specific consequences.
Naked :: LlvmFuncAttr

-- | Different types to call a function.
data LlvmCallType

-- | Normal call, allocate a new stack frame.
StdCall :: LlvmCallType

-- | Tail call, perform the call in the current stack frame.
TailCall :: LlvmCallType

-- | Different calling conventions a function can use.
data LlvmCallConvention

-- | The C calling convention. This calling convention (the default if no
--   other calling convention is specified) matches the target C calling
--   conventions. This calling convention supports varargs function calls
--   and tolerates some mismatch in the declared prototype and implemented
--   declaration of the function (as does normal C).
CC_Ccc :: LlvmCallConvention

-- | This calling convention attempts to make calls as fast as possible
--   (e.g. by passing things in registers). This calling convention allows
--   the target to use whatever tricks it wants to produce fast code for
--   the target, without having to conform to an externally specified ABI
--   (Application Binary Interface). Implementations of this convention
--   should allow arbitrary tail call optimization to be supported. This
--   calling convention does not support varargs and requires the prototype
--   of al callees to exactly match the prototype of the function
--   definition.
CC_Fastcc :: LlvmCallConvention

-- | This calling convention attempts to make code in the caller as
--   efficient as possible under the assumption that the call is not
--   commonly executed. As such, these calls often preserve all registers
--   so that the call does not break any live ranges in the caller side.
--   This calling convention does not support varargs and requires the
--   prototype of all callees to exactly match the prototype of the
--   function definition.
CC_Coldcc :: LlvmCallConvention

-- | The GHC-specific <tt>registerised</tt> calling convention.
CC_Ghc :: LlvmCallConvention

-- | Any calling convention may be specified by number, allowing
--   target-specific calling conventions to be used. Target specific
--   calling conventions start at 64.
CC_Ncc :: Int -> LlvmCallConvention

-- | X86 Specific <a>StdCall</a> convention. LLVM includes a specific alias
--   for it rather than just using CC_Ncc.
CC_X86_Stdcc :: LlvmCallConvention

-- | Functions can have a fixed amount of parameters, or a variable amount.
data LlvmParameterListType
FixedArgs :: LlvmParameterListType
VarArgs :: LlvmParameterListType

-- | Linkage type of a symbol.
--   
--   The description of the constructors is copied from the Llvm Assembly
--   Language Reference Manual
--   <a>http://www.llvm.org/docs/LangRef.html#linkage</a>, because they
--   correspond to the Llvm linkage types.
data LlvmLinkageType

-- | Global values with internal linkage are only directly accessible by
--   objects in the current module. In particular, linking code into a
--   module with an internal global value may cause the internal to be
--   renamed as necessary to avoid collisions. Because the symbol is
--   internal to the module, all references can be updated. This
--   corresponds to the notion of the <tt>static</tt> keyword in C.
Internal :: LlvmLinkageType

-- | Globals with <tt>linkonce</tt> linkage are merged with other globals
--   of the same name when linkage occurs. This is typically used to
--   implement inline functions, templates, or other code which must be
--   generated in each translation unit that uses it. Unreferenced linkonce
--   globals are allowed to be discarded.
LinkOnce :: LlvmLinkageType

-- | <tt>weak</tt> linkage is exactly the same as linkonce linkage, except
--   that unreferenced weak globals may not be discarded. This is used for
--   globals that may be emitted in multiple translation units, but that
--   are not guaranteed to be emitted into every translation unit that uses
--   them. One example of this are common globals in C, such as <tt>int
--   X;</tt> at global scope.
Weak :: LlvmLinkageType

-- | <tt>appending</tt> linkage may only be applied to global variables of
--   pointer to array type. When two global variables with appending
--   linkage are linked together, the two global arrays are appended
--   together. This is the Llvm, typesafe, equivalent of having the system
--   linker append together <tt>sections</tt> with identical names when .o
--   files are linked.
Appending :: LlvmLinkageType

-- | The semantics of this linkage follow the ELF model: the symbol is weak
--   until linked, if not linked, the symbol becomes null instead of being
--   an undefined reference.
ExternWeak :: LlvmLinkageType

-- | The symbol participates in linkage and can be used to resolve external
--   symbol references.
ExternallyVisible :: LlvmLinkageType

-- | Alias for <a>ExternallyVisible</a> but with explicit textual form in
--   LLVM assembly.
External :: LlvmLinkageType

-- | Symbol is private to the module and should not appear in the symbol
--   table
Private :: LlvmLinkageType

-- | Llvm binary operators machine operations.
data LlvmMachOp

-- | add two integer, floating point or vector values.
LM_MO_Add :: LlvmMachOp

-- | subtract two ...
LM_MO_Sub :: LlvmMachOp

-- | multiply ..
LM_MO_Mul :: LlvmMachOp

-- | unsigned integer or vector division.
LM_MO_UDiv :: LlvmMachOp

-- | signed integer ..
LM_MO_SDiv :: LlvmMachOp

-- | unsigned integer or vector remainder (mod)
LM_MO_URem :: LlvmMachOp

-- | signed ...
LM_MO_SRem :: LlvmMachOp

-- | add two floating point or vector values.
LM_MO_FAdd :: LlvmMachOp

-- | subtract two ...
LM_MO_FSub :: LlvmMachOp

-- | multiply ...
LM_MO_FMul :: LlvmMachOp

-- | divide ...
LM_MO_FDiv :: LlvmMachOp

-- | remainder ...
LM_MO_FRem :: LlvmMachOp

-- | Left shift
LM_MO_Shl :: LlvmMachOp

-- | Logical shift right Shift right, filling with zero
LM_MO_LShr :: LlvmMachOp

-- | Arithmetic shift right The most significant bits of the result will be
--   equal to the sign bit of the left operand.
LM_MO_AShr :: LlvmMachOp

-- | AND bitwise logical operation.
LM_MO_And :: LlvmMachOp

-- | OR bitwise logical operation.
LM_MO_Or :: LlvmMachOp

-- | XOR bitwise logical operation.
LM_MO_Xor :: LlvmMachOp

-- | Llvm compare operations.
data LlvmCmpOp

-- | Equal (Signed and Unsigned)
LM_CMP_Eq :: LlvmCmpOp

-- | Not equal (Signed and Unsigned)
LM_CMP_Ne :: LlvmCmpOp

-- | Unsigned greater than
LM_CMP_Ugt :: LlvmCmpOp

-- | Unsigned greater than or equal
LM_CMP_Uge :: LlvmCmpOp

-- | Unsigned less than
LM_CMP_Ult :: LlvmCmpOp

-- | Unsigned less than or equal
LM_CMP_Ule :: LlvmCmpOp

-- | Signed greater than
LM_CMP_Sgt :: LlvmCmpOp

-- | Signed greater than or equal
LM_CMP_Sge :: LlvmCmpOp

-- | Signed less than
LM_CMP_Slt :: LlvmCmpOp

-- | Signed less than or equal
LM_CMP_Sle :: LlvmCmpOp

-- | Float equal
LM_CMP_Feq :: LlvmCmpOp

-- | Float not equal
LM_CMP_Fne :: LlvmCmpOp

-- | Float greater than
LM_CMP_Fgt :: LlvmCmpOp

-- | Float greater than or equal
LM_CMP_Fge :: LlvmCmpOp

-- | Float less than
LM_CMP_Flt :: LlvmCmpOp

-- | Float less than or equal
LM_CMP_Fle :: LlvmCmpOp

-- | Llvm cast operations.
data LlvmCastOp

-- | Integer truncate
LM_Trunc :: LlvmCastOp

-- | Integer extend (zero fill)
LM_Zext :: LlvmCastOp

-- | Integer extend (sign fill)
LM_Sext :: LlvmCastOp

-- | Float truncate
LM_Fptrunc :: LlvmCastOp

-- | Float extend
LM_Fpext :: LlvmCastOp

-- | Float to unsigned Integer
LM_Fptoui :: LlvmCastOp

-- | Float to signed Integer
LM_Fptosi :: LlvmCastOp

-- | Unsigned Integer to Float
LM_Uitofp :: LlvmCastOp

-- | Signed Int to Float
LM_Sitofp :: LlvmCastOp

-- | Pointer to Integer
LM_Ptrtoint :: LlvmCastOp

-- | Integer to Pointer
LM_Inttoptr :: LlvmCastOp

-- | Cast between types where no bit manipulation is needed
LM_Bitcast :: LlvmCastOp

-- | Convert a Haskell Double to an LLVM hex encoded floating point form.
--   In Llvm float literals can be printed in a big-endian hexadecimal
--   format, regardless of underlying architecture.
--   
--   See Note [LLVM Float Types].
ppDouble :: Platform -> Double -> SDoc
narrowFp :: Double -> Float
widenFp :: Float -> Double
ppFloat :: Platform -> Float -> SDoc
ppCommaJoin :: Outputable a => [a] -> SDoc
ppSpaceJoin :: Outputable a => [a] -> SDoc
instance GHC.Classes.Eq GHC.Llvm.Types.LMConst
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmParamAttr
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmFuncAttr
instance GHC.Show.Show GHC.Llvm.Types.LlvmCallType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCallType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCallConvention
instance GHC.Show.Show GHC.Llvm.Types.LlvmParameterListType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmParameterListType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmLinkageType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmType
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmFunctionDecl
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmLit
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmVar
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmMachOp
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCmpOp
instance GHC.Classes.Eq GHC.Llvm.Types.LlvmCastOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmCastOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmCmpOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmMachOp
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmType
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmFunctionDecl
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmLinkageType
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmCallConvention
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmFuncAttr
instance GHC.Utils.Outputable.Outputable GHC.Llvm.Types.LlvmParamAttr

module GHC.Llvm.MetaData

-- | A reference to an un-named metadata node.
newtype MetaId
MetaId :: Int -> MetaId

-- | LLVM metadata expressions
data MetaExpr
MetaStr :: !LMString -> MetaExpr
MetaNode :: !MetaId -> MetaExpr
MetaVar :: !LlvmVar -> MetaExpr
MetaStruct :: [MetaExpr] -> MetaExpr

-- | Associates some metadata with a specific label for attaching to an
--   instruction.
data MetaAnnot
MetaAnnot :: LMString -> MetaExpr -> MetaAnnot

-- | Metadata declarations. Metadata can only be declared in global scope.
data MetaDecl

-- | Named metadata. Only used for communicating module information to
--   LLVM. ('!name = !{ [!&lt;n&gt;] }' form).
MetaNamed :: !LMString -> [MetaId] -> MetaDecl

-- | Metadata node declaration. ('!0 = metadata !{ &lt;metadata
--   expression&gt; }' form).
MetaUnnamed :: !MetaId -> !MetaExpr -> MetaDecl
instance GHC.Enum.Enum GHC.Llvm.MetaData.MetaId
instance GHC.Classes.Ord GHC.Llvm.MetaData.MetaId
instance GHC.Classes.Eq GHC.Llvm.MetaData.MetaId
instance GHC.Classes.Eq GHC.Llvm.MetaData.MetaExpr
instance GHC.Classes.Eq GHC.Llvm.MetaData.MetaAnnot
instance GHC.Utils.Outputable.Outputable GHC.Llvm.MetaData.MetaId


-- | The LLVM abstract syntax.
module GHC.Llvm.Syntax

-- | Block labels
type LlvmBlockId = Unique

-- | A block of LLVM code.
data LlvmBlock
LlvmBlock :: LlvmBlockId -> [LlvmStatement] -> LlvmBlock

-- | The code label for this block
[blockLabel] :: LlvmBlock -> LlvmBlockId

-- | A list of LlvmStatement's representing the code for this block. This
--   list must end with a control flow statement.
[blockStmts] :: LlvmBlock -> [LlvmStatement]
type LlvmBlocks = [LlvmBlock]

-- | An LLVM Module. This is a top level container in LLVM.
data LlvmModule
LlvmModule :: [LMString] -> [LlvmAlias] -> [MetaDecl] -> [LMGlobal] -> LlvmFunctionDecls -> LlvmFunctions -> LlvmModule

-- | Comments to include at the start of the module.
[modComments] :: LlvmModule -> [LMString]

-- | LLVM Alias type definitions.
[modAliases] :: LlvmModule -> [LlvmAlias]

-- | LLVM meta data.
[modMeta] :: LlvmModule -> [MetaDecl]

-- | Global variables to include in the module.
[modGlobals] :: LlvmModule -> [LMGlobal]

-- | LLVM Functions used in this module but defined in other modules.
[modFwdDecls] :: LlvmModule -> LlvmFunctionDecls

-- | LLVM Functions defined in this module.
[modFuncs] :: LlvmModule -> LlvmFunctions

-- | An LLVM Function
data LlvmFunction
LlvmFunction :: LlvmFunctionDecl -> [LMString] -> [LlvmFuncAttr] -> LMSection -> Maybe LlvmStatic -> LlvmBlocks -> LlvmFunction

-- | The signature of this declared function.
[funcDecl] :: LlvmFunction -> LlvmFunctionDecl

-- | The functions arguments
[funcArgs] :: LlvmFunction -> [LMString]

-- | The function attributes.
[funcAttrs] :: LlvmFunction -> [LlvmFuncAttr]

-- | The section to put the function into,
[funcSect] :: LlvmFunction -> LMSection

-- | Prefix data
[funcPrefix] :: LlvmFunction -> Maybe LlvmStatic

-- | The body of the functions.
[funcBody] :: LlvmFunction -> LlvmBlocks
type LlvmFunctions = [LlvmFunction]
type SingleThreaded = Bool

-- | LLVM ordering types for synchronization purposes. (Introduced in LLVM
--   3.0). Please see the LLVM documentation for a better description.
data LlvmSyncOrdering

-- | Some partial order of operations exists.
SyncUnord :: LlvmSyncOrdering

-- | A single total order for operations at a single address exists.
SyncMonotonic :: LlvmSyncOrdering

-- | Acquire synchronization operation.
SyncAcquire :: LlvmSyncOrdering

-- | Release synchronization operation.
SyncRelease :: LlvmSyncOrdering

-- | Acquire + Release synchronization operation.
SyncAcqRel :: LlvmSyncOrdering

-- | Full sequential Consistency operation.
SyncSeqCst :: LlvmSyncOrdering

-- | LLVM atomic operations. Please see the <tt>atomicrmw</tt> instruction
--   in the LLVM documentation for a complete description.
data LlvmAtomicOp
LAO_Xchg :: LlvmAtomicOp
LAO_Add :: LlvmAtomicOp
LAO_Sub :: LlvmAtomicOp
LAO_And :: LlvmAtomicOp
LAO_Nand :: LlvmAtomicOp
LAO_Or :: LlvmAtomicOp
LAO_Xor :: LlvmAtomicOp
LAO_Max :: LlvmAtomicOp
LAO_Min :: LlvmAtomicOp
LAO_Umax :: LlvmAtomicOp
LAO_Umin :: LlvmAtomicOp

-- | Llvm Statements
data LlvmStatement

-- | Assign an expression to a variable: * dest: Variable to assign to *
--   source: Source expression
Assignment :: LlvmVar -> LlvmExpression -> LlvmStatement

-- | Memory fence operation
Fence :: Bool -> LlvmSyncOrdering -> LlvmStatement

-- | Always branch to the target label
Branch :: LlvmVar -> LlvmStatement

-- | Branch to label targetTrue if cond is true otherwise to label
--   targetFalse * cond: condition that will be tested, must be of type i1
--   * targetTrue: label to branch to if cond is true * targetFalse: label
--   to branch to if cond is false
BranchIf :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmStatement

-- | Comment Plain comment.
Comment :: [LMString] -> LlvmStatement

-- | Set a label on this position. * name: Identifier of this label, unique
--   for this module
MkLabel :: LlvmBlockId -> LlvmStatement

-- | Store variable value in pointer ptr. If value is of type t then ptr
--   must be of type t*. * value: Variable/Constant to store. * ptr:
--   Location to store the value in
Store :: LlvmVar -> LlvmVar -> LMAlign -> LlvmStatement

-- | Multiway branch * scrutinee: Variable or constant which must be of
--   integer type that is determines which arm is chosen. * def: The
--   default label if there is no match in target. * target: A list of
--   (value,label) where the value is an integer constant and label the
--   corresponding label to jump to if the scrutinee matches the value.
Switch :: LlvmVar -> LlvmVar -> [(LlvmVar, LlvmVar)] -> LlvmStatement

-- | Return a result. * result: The variable or constant to return
Return :: Maybe LlvmVar -> LlvmStatement

-- | An instruction for the optimizer that the code following is not
--   reachable
Unreachable :: LlvmStatement

-- | Raise an expression to a statement (if don't want result or want to
--   use Llvm unnamed values.
Expr :: LlvmExpression -> LlvmStatement

-- | A nop LLVM statement. Useful as its often more efficient to use this
--   then to wrap LLvmStatement in a Just or [].
Nop :: LlvmStatement

-- | A LLVM statement with metadata attached to it.
MetaStmt :: [MetaAnnot] -> LlvmStatement -> LlvmStatement

-- | Llvm Expressions
data LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the stack * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Alloca :: LlvmType -> Int -> LlvmExpression

-- | Perform the machine operator op on the operands left and right * op:
--   operator * left: left operand * right: right operand
LlvmOp :: LlvmMachOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Perform a compare operation on the operands left and right * op:
--   operator * left: left operand * right: right operand
Compare :: LlvmCmpOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a vector * val: The vector * idx: The
--   index of the scalar within the vector
Extract :: LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a structure * val: The structure * idx:
--   The index of the scalar within the structure Corresponds to
--   "extractvalue" instruction.
ExtractV :: LlvmVar -> Int -> LlvmExpression

-- | Insert a scalar element into a vector * val: The source vector * elt:
--   The scalar to insert * index: The index at which to insert the scalar
Insert :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the heap * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Malloc :: LlvmType -> Int -> LlvmExpression

-- | Load the value at location ptr
Load :: LlvmVar -> LMAlign -> LlvmExpression

-- | Atomic load of the value at location ptr
ALoad :: LlvmSyncOrdering -> SingleThreaded -> LlvmVar -> LlvmExpression

-- | Navigate in a structure, selecting elements * inbound: Is the pointer
--   inbounds? (computed pointer doesn't overflow) * ptr: Location of the
--   structure * indexes: A list of indexes to select the correct value.
GetElemPtr :: Bool -> LlvmVar -> [LlvmVar] -> LlvmExpression

-- | Cast the variable from to the to type. This is an abstraction of three
--   cast operators in Llvm, inttoptr, ptrtoint and bitcast. * cast: Cast
--   type * from: Variable to cast * to: type to cast to
Cast :: LlvmCastOp -> LlvmVar -> LlvmType -> LlvmExpression

-- | Atomic read-modify-write operation * op: Atomic operation * addr:
--   Address to modify * operand: Operand to operation * ordering: Ordering
--   requirement
AtomicRMW :: LlvmAtomicOp -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmExpression

-- | Compare-and-exchange operation * addr: Address to modify * old:
--   Expected value * new: New value * suc_ord: Ordering required in
--   success case * fail_ord: Ordering required in failure case, can be no
--   stronger than suc_ord
--   
--   Result is an <tt>i1</tt>, true if store was successful.
CmpXChg :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmSyncOrdering -> LlvmExpression

-- | Call a function. The result is the value of the expression. *
--   tailJumps: CallType to signal if the function should be tail called *
--   fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Concrete
--   arguments for the parameters * attrs: A list of function attributes
--   for the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
Call :: LlvmCallType -> LlvmVar -> [LlvmVar] -> [LlvmFuncAttr] -> LlvmExpression

-- | Call a function as above but potentially taking metadata as arguments.
--   * tailJumps: CallType to signal if the function should be tail called
--   * fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Arguments
--   that may include metadata. * attrs: A list of function attributes for
--   the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
CallM :: LlvmCallType -> LlvmVar -> [MetaExpr] -> [LlvmFuncAttr] -> LlvmExpression

-- | Merge variables from different basic blocks which are predecessors of
--   this basic block in a new variable of type tp. * tp: type of the
--   merged variable, must match the types of the predecessor variables. *
--   predecessors: A list of variables and the basic block that they
--   originate from.
Phi :: LlvmType -> [(LlvmVar, LlvmVar)] -> LlvmExpression

-- | Inline assembly expression. Syntax is very similar to the style used
--   by GCC. * assembly: Actual inline assembly code. * constraints:
--   Operand constraints. * return ty: Return type of function. * vars: Any
--   variables involved in the assembly code. * sideeffect: Does the
--   expression have side effects not visible from the constraints list. *
--   alignstack: Should the stack be conservatively aligned before this
--   expression is executed.
Asm :: LMString -> LMString -> LlvmType -> [LlvmVar] -> Bool -> Bool -> LlvmExpression

-- | A LLVM expression with metadata attached to it.
MExpr :: [MetaAnnot] -> LlvmExpression -> LlvmExpression
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmSyncOrdering
instance GHC.Show.Show GHC.Llvm.Syntax.LlvmSyncOrdering
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmAtomicOp
instance GHC.Show.Show GHC.Llvm.Syntax.LlvmAtomicOp
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmExpression
instance GHC.Classes.Eq GHC.Llvm.Syntax.LlvmStatement


-- | Pretty print LLVM IR Code.
module GHC.Llvm.Ppr

-- | Print out a whole LLVM module.
ppLlvmModule :: LlvmCgConfig -> LlvmModule -> SDoc

-- | Print out a multi-line comment, can be inside a function or on its own
ppLlvmComments :: [LMString] -> SDoc

-- | Print out a comment, can be inside a function or on its own
ppLlvmComment :: LMString -> SDoc

-- | Print out a list of global mutable variable definitions
ppLlvmGlobals :: LlvmCgConfig -> [LMGlobal] -> SDoc

-- | Print out a global mutable variable definition
ppLlvmGlobal :: LlvmCgConfig -> LMGlobal -> SDoc

-- | Print out a list of LLVM type aliases.
ppLlvmAliases :: [LlvmAlias] -> SDoc

-- | Print out an LLVM type alias.
ppLlvmAlias :: LlvmAlias -> SDoc

-- | Print out a list of LLVM metadata.
ppLlvmMetas :: LlvmCgConfig -> [MetaDecl] -> SDoc

-- | Print out an LLVM metadata definition.
ppLlvmMeta :: LlvmCgConfig -> MetaDecl -> SDoc

-- | Print out a list of function declaration.
ppLlvmFunctionDecls :: LlvmFunctionDecls -> SDoc

-- | Print out a function declaration. Declarations define the function
--   type but don't define the actual body of the function.
ppLlvmFunctionDecl :: LlvmFunctionDecl -> SDoc

-- | Print out a list of function definitions.
ppLlvmFunctions :: LlvmCgConfig -> LlvmFunctions -> SDoc

-- | Print out a function definition.
ppLlvmFunction :: LlvmCgConfig -> LlvmFunction -> SDoc
ppVar :: LlvmCgConfig -> LlvmVar -> SDoc

-- | Print a literal value. No type.
ppLit :: LlvmCgConfig -> LlvmLit -> SDoc
ppTypeLit :: LlvmCgConfig -> LlvmLit -> SDoc

-- | Return the variable name or value of the <a>LlvmVar</a> in Llvm IR
--   textual representation (e.g. <tt>@x</tt>, <tt>%y</tt> or <tt>42</tt>).
ppName :: LlvmCgConfig -> LlvmVar -> SDoc

-- | Return the variable name or value of the <a>LlvmVar</a> in a plain
--   textual representation (e.g. <tt>x</tt>, <tt>y</tt> or <tt>42</tt>).
ppPlainName :: LlvmCgConfig -> LlvmVar -> SDoc


-- | This module supplies bindings to generate Llvm IR from Haskell
--   (<a>http://www.llvm.org/docs/LangRef.html</a>).
--   
--   Note: this module is developed in a demand driven way. It is no
--   complete LLVM binding library in Haskell, but enough to generate code
--   for GHC.
--   
--   This code is derived from code taken from the Essential Haskell
--   Compiler (EHC) project.
module GHC.Llvm

-- | An LLVM Module. This is a top level container in LLVM.
data LlvmModule
LlvmModule :: [LMString] -> [LlvmAlias] -> [MetaDecl] -> [LMGlobal] -> LlvmFunctionDecls -> LlvmFunctions -> LlvmModule

-- | Comments to include at the start of the module.
[modComments] :: LlvmModule -> [LMString]

-- | LLVM Alias type definitions.
[modAliases] :: LlvmModule -> [LlvmAlias]

-- | LLVM meta data.
[modMeta] :: LlvmModule -> [MetaDecl]

-- | Global variables to include in the module.
[modGlobals] :: LlvmModule -> [LMGlobal]

-- | LLVM Functions used in this module but defined in other modules.
[modFwdDecls] :: LlvmModule -> LlvmFunctionDecls

-- | LLVM Functions defined in this module.
[modFuncs] :: LlvmModule -> LlvmFunctions

-- | An LLVM Function
data LlvmFunction
LlvmFunction :: LlvmFunctionDecl -> [LMString] -> [LlvmFuncAttr] -> LMSection -> Maybe LlvmStatic -> LlvmBlocks -> LlvmFunction

-- | The signature of this declared function.
[funcDecl] :: LlvmFunction -> LlvmFunctionDecl

-- | The functions arguments
[funcArgs] :: LlvmFunction -> [LMString]

-- | The function attributes.
[funcAttrs] :: LlvmFunction -> [LlvmFuncAttr]

-- | The section to put the function into,
[funcSect] :: LlvmFunction -> LMSection

-- | Prefix data
[funcPrefix] :: LlvmFunction -> Maybe LlvmStatic

-- | The body of the functions.
[funcBody] :: LlvmFunction -> LlvmBlocks

-- | An LLVM Function
data LlvmFunctionDecl
LlvmFunctionDecl :: LMString -> LlvmLinkageType -> LlvmCallConvention -> LlvmType -> LlvmParameterListType -> [LlvmParameter] -> LMAlign -> LlvmFunctionDecl

-- | Unique identifier of the function
[decName] :: LlvmFunctionDecl -> LMString

-- | LinkageType of the function
[funcLinkage] :: LlvmFunctionDecl -> LlvmLinkageType

-- | The calling convention of the function
[funcCc] :: LlvmFunctionDecl -> LlvmCallConvention

-- | Type of the returned value
[decReturnType] :: LlvmFunctionDecl -> LlvmType

-- | Indicates if this function uses varargs
[decVarargs] :: LlvmFunctionDecl -> LlvmParameterListType

-- | Parameter types and attributes
[decParams] :: LlvmFunctionDecl -> [LlvmParameter]

-- | Function align value, must be power of 2
[funcAlign] :: LlvmFunctionDecl -> LMAlign
type LlvmFunctions = [LlvmFunction]
type LlvmFunctionDecls = [LlvmFunctionDecl]

-- | Llvm Statements
data LlvmStatement

-- | Assign an expression to a variable: * dest: Variable to assign to *
--   source: Source expression
Assignment :: LlvmVar -> LlvmExpression -> LlvmStatement

-- | Memory fence operation
Fence :: Bool -> LlvmSyncOrdering -> LlvmStatement

-- | Always branch to the target label
Branch :: LlvmVar -> LlvmStatement

-- | Branch to label targetTrue if cond is true otherwise to label
--   targetFalse * cond: condition that will be tested, must be of type i1
--   * targetTrue: label to branch to if cond is true * targetFalse: label
--   to branch to if cond is false
BranchIf :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmStatement

-- | Comment Plain comment.
Comment :: [LMString] -> LlvmStatement

-- | Set a label on this position. * name: Identifier of this label, unique
--   for this module
MkLabel :: LlvmBlockId -> LlvmStatement

-- | Store variable value in pointer ptr. If value is of type t then ptr
--   must be of type t*. * value: Variable/Constant to store. * ptr:
--   Location to store the value in
Store :: LlvmVar -> LlvmVar -> LMAlign -> LlvmStatement

-- | Multiway branch * scrutinee: Variable or constant which must be of
--   integer type that is determines which arm is chosen. * def: The
--   default label if there is no match in target. * target: A list of
--   (value,label) where the value is an integer constant and label the
--   corresponding label to jump to if the scrutinee matches the value.
Switch :: LlvmVar -> LlvmVar -> [(LlvmVar, LlvmVar)] -> LlvmStatement

-- | Return a result. * result: The variable or constant to return
Return :: Maybe LlvmVar -> LlvmStatement

-- | An instruction for the optimizer that the code following is not
--   reachable
Unreachable :: LlvmStatement

-- | Raise an expression to a statement (if don't want result or want to
--   use Llvm unnamed values.
Expr :: LlvmExpression -> LlvmStatement

-- | A nop LLVM statement. Useful as its often more efficient to use this
--   then to wrap LLvmStatement in a Just or [].
Nop :: LlvmStatement

-- | A LLVM statement with metadata attached to it.
MetaStmt :: [MetaAnnot] -> LlvmStatement -> LlvmStatement

-- | Llvm Expressions
data LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the stack * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Alloca :: LlvmType -> Int -> LlvmExpression

-- | Perform the machine operator op on the operands left and right * op:
--   operator * left: left operand * right: right operand
LlvmOp :: LlvmMachOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Perform a compare operation on the operands left and right * op:
--   operator * left: left operand * right: right operand
Compare :: LlvmCmpOp -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a vector * val: The vector * idx: The
--   index of the scalar within the vector
Extract :: LlvmVar -> LlvmVar -> LlvmExpression

-- | Extract a scalar element from a structure * val: The structure * idx:
--   The index of the scalar within the structure Corresponds to
--   "extractvalue" instruction.
ExtractV :: LlvmVar -> Int -> LlvmExpression

-- | Insert a scalar element into a vector * val: The source vector * elt:
--   The scalar to insert * index: The index at which to insert the scalar
Insert :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmExpression

-- | Allocate amount * sizeof(tp) bytes on the heap * tp: LlvmType to
--   reserve room for * amount: The nr of tp's which must be allocated
Malloc :: LlvmType -> Int -> LlvmExpression

-- | Load the value at location ptr
Load :: LlvmVar -> LMAlign -> LlvmExpression

-- | Atomic load of the value at location ptr
ALoad :: LlvmSyncOrdering -> SingleThreaded -> LlvmVar -> LlvmExpression

-- | Navigate in a structure, selecting elements * inbound: Is the pointer
--   inbounds? (computed pointer doesn't overflow) * ptr: Location of the
--   structure * indexes: A list of indexes to select the correct value.
GetElemPtr :: Bool -> LlvmVar -> [LlvmVar] -> LlvmExpression

-- | Cast the variable from to the to type. This is an abstraction of three
--   cast operators in Llvm, inttoptr, ptrtoint and bitcast. * cast: Cast
--   type * from: Variable to cast * to: type to cast to
Cast :: LlvmCastOp -> LlvmVar -> LlvmType -> LlvmExpression

-- | Atomic read-modify-write operation * op: Atomic operation * addr:
--   Address to modify * operand: Operand to operation * ordering: Ordering
--   requirement
AtomicRMW :: LlvmAtomicOp -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmExpression

-- | Compare-and-exchange operation * addr: Address to modify * old:
--   Expected value * new: New value * suc_ord: Ordering required in
--   success case * fail_ord: Ordering required in failure case, can be no
--   stronger than suc_ord
--   
--   Result is an <tt>i1</tt>, true if store was successful.
CmpXChg :: LlvmVar -> LlvmVar -> LlvmVar -> LlvmSyncOrdering -> LlvmSyncOrdering -> LlvmExpression

-- | Call a function. The result is the value of the expression. *
--   tailJumps: CallType to signal if the function should be tail called *
--   fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Concrete
--   arguments for the parameters * attrs: A list of function attributes
--   for the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
Call :: LlvmCallType -> LlvmVar -> [LlvmVar] -> [LlvmFuncAttr] -> LlvmExpression

-- | Call a function as above but potentially taking metadata as arguments.
--   * tailJumps: CallType to signal if the function should be tail called
--   * fnptrval: An LLVM value containing a pointer to a function to be
--   invoked. Can be indirect. Should be LMFunction type. * args: Arguments
--   that may include metadata. * attrs: A list of function attributes for
--   the call. Only NoReturn, NoUnwind, ReadOnly and ReadNone are valid
--   here.
CallM :: LlvmCallType -> LlvmVar -> [MetaExpr] -> [LlvmFuncAttr] -> LlvmExpression

-- | Merge variables from different basic blocks which are predecessors of
--   this basic block in a new variable of type tp. * tp: type of the
--   merged variable, must match the types of the predecessor variables. *
--   predecessors: A list of variables and the basic block that they
--   originate from.
Phi :: LlvmType -> [(LlvmVar, LlvmVar)] -> LlvmExpression

-- | Inline assembly expression. Syntax is very similar to the style used
--   by GCC. * assembly: Actual inline assembly code. * constraints:
--   Operand constraints. * return ty: Return type of function. * vars: Any
--   variables involved in the assembly code. * sideeffect: Does the
--   expression have side effects not visible from the constraints list. *
--   alignstack: Should the stack be conservatively aligned before this
--   expression is executed.
Asm :: LMString -> LMString -> LlvmType -> [LlvmVar] -> Bool -> Bool -> LlvmExpression

-- | A LLVM expression with metadata attached to it.
MExpr :: [MetaAnnot] -> LlvmExpression -> LlvmExpression
type LlvmBlocks = [LlvmBlock]

-- | A block of LLVM code.
data LlvmBlock
LlvmBlock :: LlvmBlockId -> [LlvmStatement] -> LlvmBlock

-- | The code label for this block
[blockLabel] :: LlvmBlock -> LlvmBlockId

-- | A list of LlvmStatement's representing the code for this block. This
--   list must end with a control flow statement.
[blockStmts] :: LlvmBlock -> [LlvmStatement]

-- | Block labels
type LlvmBlockId = Unique

-- | LLVM Parameter Attributes.
--   
--   Parameter attributes are used to communicate additional information
--   about the result or parameters of a function
data LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be zero-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
ZeroExt :: LlvmParamAttr

-- | This indicates to the code generator that the parameter or return
--   value should be sign-extended to a 32-bit value by the caller (for a
--   parameter) or the callee (for a return value).
SignExt :: LlvmParamAttr

-- | This indicates that this parameter or return value should be treated
--   in a special target-dependent fashion during while emitting code for a
--   function call or return (usually, by putting it in a register as
--   opposed to memory).
InReg :: LlvmParamAttr

-- | This indicates that the pointer parameter should really be passed by
--   value to the function.
ByVal :: LlvmParamAttr

-- | This indicates that the pointer parameter specifies the address of a
--   structure that is the return value of the function in the source
--   program.
SRet :: LlvmParamAttr

-- | This indicates that the pointer does not alias any global or any other
--   parameter.
NoAlias :: LlvmParamAttr

-- | This indicates that the callee does not make any copies of the pointer
--   that outlive the callee itself
NoCapture :: LlvmParamAttr

-- | This indicates that the pointer parameter can be excised using the
--   trampoline intrinsics.
Nest :: LlvmParamAttr
type LlvmParameter = (LlvmType, [LlvmParamAttr])

-- | LLVM atomic operations. Please see the <tt>atomicrmw</tt> instruction
--   in the LLVM documentation for a complete description.
data LlvmAtomicOp
LAO_Xchg :: LlvmAtomicOp
LAO_Add :: LlvmAtomicOp
LAO_Sub :: LlvmAtomicOp
LAO_And :: LlvmAtomicOp
LAO_Nand :: LlvmAtomicOp
LAO_Or :: LlvmAtomicOp
LAO_Xor :: LlvmAtomicOp
LAO_Max :: LlvmAtomicOp
LAO_Min :: LlvmAtomicOp
LAO_Umax :: LlvmAtomicOp
LAO_Umin :: LlvmAtomicOp

-- | LLVM ordering types for synchronization purposes. (Introduced in LLVM
--   3.0). Please see the LLVM documentation for a better description.
data LlvmSyncOrdering

-- | Some partial order of operations exists.
SyncUnord :: LlvmSyncOrdering

-- | A single total order for operations at a single address exists.
SyncMonotonic :: LlvmSyncOrdering

-- | Acquire synchronization operation.
SyncAcquire :: LlvmSyncOrdering

-- | Release synchronization operation.
SyncRelease :: LlvmSyncOrdering

-- | Acquire + Release synchronization operation.
SyncAcqRel :: LlvmSyncOrdering

-- | Full sequential Consistency operation.
SyncSeqCst :: LlvmSyncOrdering

-- | Different calling conventions a function can use.
data LlvmCallConvention

-- | The C calling convention. This calling convention (the default if no
--   other calling convention is specified) matches the target C calling
--   conventions. This calling convention supports varargs function calls
--   and tolerates some mismatch in the declared prototype and implemented
--   declaration of the function (as does normal C).
CC_Ccc :: LlvmCallConvention

-- | This calling convention attempts to make calls as fast as possible
--   (e.g. by passing things in registers). This calling convention allows
--   the target to use whatever tricks it wants to produce fast code for
--   the target, without having to conform to an externally specified ABI
--   (Application Binary Interface). Implementations of this convention
--   should allow arbitrary tail call optimization to be supported. This
--   calling convention does not support varargs and requires the prototype
--   of al callees to exactly match the prototype of the function
--   definition.
CC_Fastcc :: LlvmCallConvention

-- | This calling convention attempts to make code in the caller as
--   efficient as possible under the assumption that the call is not
--   commonly executed. As such, these calls often preserve all registers
--   so that the call does not break any live ranges in the caller side.
--   This calling convention does not support varargs and requires the
--   prototype of all callees to exactly match the prototype of the
--   function definition.
CC_Coldcc :: LlvmCallConvention

-- | The GHC-specific <tt>registerised</tt> calling convention.
CC_Ghc :: LlvmCallConvention

-- | Any calling convention may be specified by number, allowing
--   target-specific calling conventions to be used. Target specific
--   calling conventions start at 64.
CC_Ncc :: Int -> LlvmCallConvention

-- | X86 Specific <a>StdCall</a> convention. LLVM includes a specific alias
--   for it rather than just using CC_Ncc.
CC_X86_Stdcc :: LlvmCallConvention

-- | Different types to call a function.
data LlvmCallType

-- | Normal call, allocate a new stack frame.
StdCall :: LlvmCallType

-- | Tail call, perform the call in the current stack frame.
TailCall :: LlvmCallType

-- | Functions can have a fixed amount of parameters, or a variable amount.
data LlvmParameterListType
FixedArgs :: LlvmParameterListType
VarArgs :: LlvmParameterListType

-- | Linkage type of a symbol.
--   
--   The description of the constructors is copied from the Llvm Assembly
--   Language Reference Manual
--   <a>http://www.llvm.org/docs/LangRef.html#linkage</a>, because they
--   correspond to the Llvm linkage types.
data LlvmLinkageType

-- | Global values with internal linkage are only directly accessible by
--   objects in the current module. In particular, linking code into a
--   module with an internal global value may cause the internal to be
--   renamed as necessary to avoid collisions. Because the symbol is
--   internal to the module, all references can be updated. This
--   corresponds to the notion of the <tt>static</tt> keyword in C.
Internal :: LlvmLinkageType

-- | Globals with <tt>linkonce</tt> linkage are merged with other globals
--   of the same name when linkage occurs. This is typically used to
--   implement inline functions, templates, or other code which must be
--   generated in each translation unit that uses it. Unreferenced linkonce
--   globals are allowed to be discarded.
LinkOnce :: LlvmLinkageType

-- | <tt>weak</tt> linkage is exactly the same as linkonce linkage, except
--   that unreferenced weak globals may not be discarded. This is used for
--   globals that may be emitted in multiple translation units, but that
--   are not guaranteed to be emitted into every translation unit that uses
--   them. One example of this are common globals in C, such as <tt>int
--   X;</tt> at global scope.
Weak :: LlvmLinkageType

-- | <tt>appending</tt> linkage may only be applied to global variables of
--   pointer to array type. When two global variables with appending
--   linkage are linked together, the two global arrays are appended
--   together. This is the Llvm, typesafe, equivalent of having the system
--   linker append together <tt>sections</tt> with identical names when .o
--   files are linked.
Appending :: LlvmLinkageType

-- | The semantics of this linkage follow the ELF model: the symbol is weak
--   until linked, if not linked, the symbol becomes null instead of being
--   an undefined reference.
ExternWeak :: LlvmLinkageType

-- | The symbol participates in linkage and can be used to resolve external
--   symbol references.
ExternallyVisible :: LlvmLinkageType

-- | Alias for <a>ExternallyVisible</a> but with explicit textual form in
--   LLVM assembly.
External :: LlvmLinkageType

-- | Symbol is private to the module and should not appear in the symbol
--   table
Private :: LlvmLinkageType

-- | Llvm Function Attributes.
--   
--   Function attributes are set to communicate additional information
--   about a function. Function attributes are considered to be part of the
--   function, not of the function type, so functions with different
--   parameter attributes can have the same function type. Functions can
--   have multiple attributes.
--   
--   Descriptions taken from
--   <a>http://llvm.org/docs/LangRef.html#fnattrs</a>
data LlvmFuncAttr

-- | This attribute indicates that the inliner should attempt to inline
--   this function into callers whenever possible, ignoring any active
--   inlining size threshold for this caller.
AlwaysInline :: LlvmFuncAttr

-- | This attribute indicates that the source code contained a hint that
--   inlining this function is desirable (such as the "inline" keyword in
--   C/C++). It is just a hint; it imposes no requirements on the inliner.
InlineHint :: LlvmFuncAttr

-- | This attribute indicates that the inliner should never inline this
--   function in any situation. This attribute may not be used together
--   with the alwaysinline attribute.
NoInline :: LlvmFuncAttr

-- | This attribute suggests that optimization passes and code generator
--   passes make choices that keep the code size of this function low, and
--   otherwise do optimizations specifically to reduce code size.
OptSize :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns
--   normally. This produces undefined behavior at runtime if the function
--   ever does dynamically return.
NoReturn :: LlvmFuncAttr

-- | This function attribute indicates that the function never returns with
--   an unwind or exceptional control flow. If the function does unwind,
--   its runtime behavior is undefined.
NoUnwind :: LlvmFuncAttr

-- | This attribute indicates that the function computes its result (or
--   decides to unwind an exception) based strictly on its arguments,
--   without dereferencing any pointer arguments or otherwise accessing any
--   mutable state (e.g. memory, control registers, etc) visible to caller
--   functions. It does not write through any pointer arguments (including
--   byval arguments) and never changes any state visible to callers. This
--   means that it cannot unwind exceptions by calling the C++ exception
--   throwing methods, but could use the unwind instruction.
ReadNone :: LlvmFuncAttr

-- | This attribute indicates that the function does not write through any
--   pointer arguments (including byval arguments) or otherwise modify any
--   state (e.g. memory, control registers, etc) visible to caller
--   functions. It may dereference pointer arguments and read state that
--   may be set in the caller. A readonly function always returns the same
--   value (or unwinds an exception identically) when called with the same
--   set of arguments and global state. It cannot unwind an exception by
--   calling the C++ exception throwing methods, but may use the unwind
--   instruction.
ReadOnly :: LlvmFuncAttr

-- | This attribute indicates that the function should emit a stack
--   smashing protector. It is in the form of a "canary"—a random value
--   placed on the stack before the local variables that's checked upon
--   return from the function to see if it has been overwritten. A
--   heuristic is used to determine if a function needs stack protectors or
--   not.
--   
--   If a function that has an ssp attribute is inlined into a function
--   that doesn't have an ssp attribute, then the resulting function will
--   have an ssp attribute.
Ssp :: LlvmFuncAttr

-- | This attribute indicates that the function should always emit a stack
--   smashing protector. This overrides the ssp function attribute.
--   
--   If a function that has an sspreq attribute is inlined into a function
--   that doesn't have an sspreq attribute or which has an ssp attribute,
--   then the resulting function will have an sspreq attribute.
SspReq :: LlvmFuncAttr

-- | This attribute indicates that the code generator should not use a red
--   zone, even if the target-specific ABI normally permits it.
NoRedZone :: LlvmFuncAttr

-- | This attributes disables implicit floating point instructions.
NoImplicitFloat :: LlvmFuncAttr

-- | This attribute disables prologue / epilogue emission for the function.
--   This can have very system-specific consequences.
Naked :: LlvmFuncAttr

-- | Llvm compare operations.
data LlvmCmpOp

-- | Equal (Signed and Unsigned)
LM_CMP_Eq :: LlvmCmpOp

-- | Not equal (Signed and Unsigned)
LM_CMP_Ne :: LlvmCmpOp

-- | Unsigned greater than
LM_CMP_Ugt :: LlvmCmpOp

-- | Unsigned greater than or equal
LM_CMP_Uge :: LlvmCmpOp

-- | Unsigned less than
LM_CMP_Ult :: LlvmCmpOp

-- | Unsigned less than or equal
LM_CMP_Ule :: LlvmCmpOp

-- | Signed greater than
LM_CMP_Sgt :: LlvmCmpOp

-- | Signed greater than or equal
LM_CMP_Sge :: LlvmCmpOp

-- | Signed less than
LM_CMP_Slt :: LlvmCmpOp

-- | Signed less than or equal
LM_CMP_Sle :: LlvmCmpOp

-- | Float equal
LM_CMP_Feq :: LlvmCmpOp

-- | Float not equal
LM_CMP_Fne :: LlvmCmpOp

-- | Float greater than
LM_CMP_Fgt :: LlvmCmpOp

-- | Float greater than or equal
LM_CMP_Fge :: LlvmCmpOp

-- | Float less than
LM_CMP_Flt :: LlvmCmpOp

-- | Float less than or equal
LM_CMP_Fle :: LlvmCmpOp

-- | Llvm binary operators machine operations.
data LlvmMachOp

-- | add two integer, floating point or vector values.
LM_MO_Add :: LlvmMachOp

-- | subtract two ...
LM_MO_Sub :: LlvmMachOp

-- | multiply ..
LM_MO_Mul :: LlvmMachOp

-- | unsigned integer or vector division.
LM_MO_UDiv :: LlvmMachOp

-- | signed integer ..
LM_MO_SDiv :: LlvmMachOp

-- | unsigned integer or vector remainder (mod)
LM_MO_URem :: LlvmMachOp

-- | signed ...
LM_MO_SRem :: LlvmMachOp

-- | add two floating point or vector values.
LM_MO_FAdd :: LlvmMachOp

-- | subtract two ...
LM_MO_FSub :: LlvmMachOp

-- | multiply ...
LM_MO_FMul :: LlvmMachOp

-- | divide ...
LM_MO_FDiv :: LlvmMachOp

-- | remainder ...
LM_MO_FRem :: LlvmMachOp

-- | Left shift
LM_MO_Shl :: LlvmMachOp

-- | Logical shift right Shift right, filling with zero
LM_MO_LShr :: LlvmMachOp

-- | Arithmetic shift right The most significant bits of the result will be
--   equal to the sign bit of the left operand.
LM_MO_AShr :: LlvmMachOp

-- | AND bitwise logical operation.
LM_MO_And :: LlvmMachOp

-- | OR bitwise logical operation.
LM_MO_Or :: LlvmMachOp

-- | XOR bitwise logical operation.
LM_MO_Xor :: LlvmMachOp

-- | Llvm cast operations.
data LlvmCastOp

-- | Integer truncate
LM_Trunc :: LlvmCastOp

-- | Integer extend (zero fill)
LM_Zext :: LlvmCastOp

-- | Integer extend (sign fill)
LM_Sext :: LlvmCastOp

-- | Float truncate
LM_Fptrunc :: LlvmCastOp

-- | Float extend
LM_Fpext :: LlvmCastOp

-- | Float to unsigned Integer
LM_Fptoui :: LlvmCastOp

-- | Float to signed Integer
LM_Fptosi :: LlvmCastOp

-- | Unsigned Integer to Float
LM_Uitofp :: LlvmCastOp

-- | Signed Int to Float
LM_Sitofp :: LlvmCastOp

-- | Pointer to Integer
LM_Ptrtoint :: LlvmCastOp

-- | Integer to Pointer
LM_Inttoptr :: LlvmCastOp

-- | Cast between types where no bit manipulation is needed
LM_Bitcast :: LlvmCastOp

-- | LLVM Variables
data LlvmVar

-- | Variables with a global scope.
LMGlobalVar :: LMString -> LlvmType -> LlvmLinkageType -> LMSection -> LMAlign -> LMConst -> LlvmVar

-- | Variables local to a function or parameters.
LMLocalVar :: Unique -> LlvmType -> LlvmVar

-- | Named local variables. Sometimes we need to be able to explicitly name
--   variables (e.g for function arguments).
LMNLocalVar :: LMString -> LlvmType -> LlvmVar

-- | A constant variable
LMLitVar :: LlvmLit -> LlvmVar

-- | Llvm Static Data.
--   
--   These represent the possible global level variables and constants.
data LlvmStatic

-- | A comment in a static section
LMComment :: LMString -> LlvmStatic

-- | A static variant of a literal value
LMStaticLit :: LlvmLit -> LlvmStatic

-- | For uninitialised data
LMUninitType :: LlvmType -> LlvmStatic

-- | Defines a static <a>LMString</a>
LMStaticStr :: LMString -> LlvmType -> LlvmStatic

-- | A static array
LMStaticArray :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A static structure type
LMStaticStruc :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A static structure type
LMStaticStrucU :: [LlvmStatic] -> LlvmType -> LlvmStatic

-- | A pointer to other data
LMStaticPointer :: LlvmVar -> LlvmStatic

-- | Truncate
LMTrunc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Pointer conversion
LMBitc :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Pointer to Integer conversion
LMPtoI :: LlvmStatic -> LlvmType -> LlvmStatic

-- | Constant addition operation
LMAdd :: LlvmStatic -> LlvmStatic -> LlvmStatic

-- | Constant subtraction operation
LMSub :: LlvmStatic -> LlvmStatic -> LlvmStatic

-- | Llvm Literal Data.
--   
--   These can be used inline in expressions.
data LlvmLit

-- | Refers to an integer constant (i64 42).
LMIntLit :: Integer -> LlvmType -> LlvmLit

-- | Floating point literal
LMFloatLit :: Double -> LlvmType -> LlvmLit

-- | Literal NULL, only applicable to pointer types
LMNullLit :: LlvmType -> LlvmLit

-- | Vector literal
LMVectorLit :: [LlvmLit] -> LlvmLit

-- | Undefined value, random bit pattern. Useful for optimisations.
LMUndefLit :: LlvmType -> LlvmLit

-- | Llvm Types
data LlvmType

-- | An integer with a given width in bits.
LMInt :: Int -> LlvmType

-- | 32 bit floating point
LMFloat :: LlvmType

-- | 64 bit floating point
LMDouble :: LlvmType

-- | 80 bit (x86 only) floating point
LMFloat80 :: LlvmType

-- | 128 bit floating point
LMFloat128 :: LlvmType

-- | A pointer to a <a>LlvmType</a>
LMPointer :: LlvmType -> LlvmType

-- | An array of <a>LlvmType</a>
LMArray :: Int -> LlvmType -> LlvmType

-- | A vector of <a>LlvmType</a>
LMVector :: Int -> LlvmType -> LlvmType

-- | A <a>LlvmVar</a> can represent a label (address)
LMLabel :: LlvmType

-- | Void type
LMVoid :: LlvmType

-- | Packed structure type
LMStruct :: [LlvmType] -> LlvmType

-- | Unpacked structure type
LMStructU :: [LlvmType] -> LlvmType

-- | A type alias
LMAlias :: LlvmAlias -> LlvmType

-- | LLVM Metadata
LMMetadata :: LlvmType

-- | Function type, used to create pointers to functions
LMFunction :: LlvmFunctionDecl -> LlvmType

-- | A type alias
type LlvmAlias = (LMString, LlvmType)

-- | A global mutable variable. Maybe defined or external
data LMGlobal
LMGlobal :: LlvmVar -> Maybe LlvmStatic -> LMGlobal

-- | Returns the variable of the <a>LMGlobal</a>
[getGlobalVar] :: LMGlobal -> LlvmVar

-- | Return the value of the <a>LMGlobal</a>
[getGlobalValue] :: LMGlobal -> Maybe LlvmStatic

-- | A String in LLVM
type LMString = FastString

-- | An LLVM section definition. If Nothing then let LLVM decide the
--   section
type LMSection = Maybe LMString
type LMAlign = Maybe Int
data LMConst

-- | Mutable global variable
Global :: LMConst

-- | Constant global variable
Constant :: LMConst

-- | Alias of another variable
Alias :: LMConst
i64 :: LlvmType
i32 :: LlvmType
i16 :: LlvmType
i8 :: LlvmType
i1 :: LlvmType
i8Ptr :: LlvmType

-- | The target architectures word size
llvmWord :: Platform -> LlvmType

-- | The target architectures word size
llvmWordPtr :: Platform -> LlvmType

-- | LLVM metadata expressions
data MetaExpr
MetaStr :: !LMString -> MetaExpr
MetaNode :: !MetaId -> MetaExpr
MetaVar :: !LlvmVar -> MetaExpr
MetaStruct :: [MetaExpr] -> MetaExpr

-- | Associates some metadata with a specific label for attaching to an
--   instruction.
data MetaAnnot
MetaAnnot :: LMString -> MetaExpr -> MetaAnnot

-- | Metadata declarations. Metadata can only be declared in global scope.
data MetaDecl

-- | Named metadata. Only used for communicating module information to
--   LLVM. ('!name = !{ [!&lt;n&gt;] }' form).
MetaNamed :: !LMString -> [MetaId] -> MetaDecl

-- | Metadata node declaration. ('!0 = metadata !{ &lt;metadata
--   expression&gt; }' form).
MetaUnnamed :: !MetaId -> !MetaExpr -> MetaDecl

-- | A reference to an un-named metadata node.
newtype MetaId
MetaId :: Int -> MetaId

-- | Test if a <a>LlvmVar</a> is global.
isGlobal :: LlvmVar -> Bool

-- | Return the <a>LlvmType</a> of a <a>LlvmLit</a>
getLitType :: LlvmLit -> LlvmType

-- | Return the <a>LlvmType</a> of the <a>LlvmVar</a>
getVarType :: LlvmVar -> LlvmType

-- | Return the <a>LlvmLinkageType</a> for a <a>LlvmVar</a>
getLink :: LlvmVar -> LlvmLinkageType

-- | Return the <a>LlvmType</a> of the <a>LlvmStatic</a>
getStatType :: LlvmStatic -> LlvmType

-- | Lift a variable to <a>LMPointer</a> type.
pVarLift :: LlvmVar -> LlvmVar

-- | Lower a variable of <a>LMPointer</a> type.
pVarLower :: LlvmVar -> LlvmVar

-- | Add a pointer indirection to the supplied type. <a>LMLabel</a> and
--   <a>LMVoid</a> cannot be lifted.
pLift :: LlvmType -> LlvmType

-- | Remove the pointer indirection of the supplied type. Only
--   <a>LMPointer</a> constructors can be lowered.
pLower :: LlvmType -> LlvmType

-- | Test if the given <a>LlvmType</a> is an integer
isInt :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is a floating point type
isFloat :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMPointer</a> construct
isPointer :: LlvmType -> Bool

-- | Test if the given <a>LlvmType</a> is an <a>LMVector</a> construct
isVector :: LlvmType -> Bool

-- | Width in bits of an <a>LlvmType</a>, returns 0 if not applicable
llvmWidthInBits :: Platform -> LlvmType -> Int
ppVar :: LlvmCgConfig -> LlvmVar -> SDoc

-- | Print a literal value. No type.
ppLit :: LlvmCgConfig -> LlvmLit -> SDoc
ppTypeLit :: LlvmCgConfig -> LlvmLit -> SDoc

-- | Return the variable name or value of the <a>LlvmVar</a> in Llvm IR
--   textual representation (e.g. <tt>@x</tt>, <tt>%y</tt> or <tt>42</tt>).
ppName :: LlvmCgConfig -> LlvmVar -> SDoc

-- | Return the variable name or value of the <a>LlvmVar</a> in a plain
--   textual representation (e.g. <tt>x</tt>, <tt>y</tt> or <tt>42</tt>).
ppPlainName :: LlvmCgConfig -> LlvmVar -> SDoc

-- | Print out a whole LLVM module.
ppLlvmModule :: LlvmCgConfig -> LlvmModule -> SDoc

-- | Print out a multi-line comment, can be inside a function or on its own
ppLlvmComments :: [LMString] -> SDoc

-- | Print out a comment, can be inside a function or on its own
ppLlvmComment :: LMString -> SDoc

-- | Print out a list of global mutable variable definitions
ppLlvmGlobals :: LlvmCgConfig -> [LMGlobal] -> SDoc

-- | Print out a global mutable variable definition
ppLlvmGlobal :: LlvmCgConfig -> LMGlobal -> SDoc

-- | Print out a list of function declaration.
ppLlvmFunctionDecls :: LlvmFunctionDecls -> SDoc

-- | Print out a function declaration. Declarations define the function
--   type but don't define the actual body of the function.
ppLlvmFunctionDecl :: LlvmFunctionDecl -> SDoc

-- | Print out a list of function definitions.
ppLlvmFunctions :: LlvmCgConfig -> LlvmFunctions -> SDoc

-- | Print out a function definition.
ppLlvmFunction :: LlvmCgConfig -> LlvmFunction -> SDoc

-- | Print out an LLVM type alias.
ppLlvmAlias :: LlvmAlias -> SDoc

-- | Print out a list of LLVM type aliases.
ppLlvmAliases :: [LlvmAlias] -> SDoc

-- | Print out a list of LLVM metadata.
ppLlvmMetas :: LlvmCgConfig -> [MetaDecl] -> SDoc

-- | Print out an LLVM metadata definition.
ppLlvmMeta :: LlvmCgConfig -> MetaDecl -> SDoc


-- | Deal with Cmm registers
module GHC.CmmToLlvm.Regs

-- | Get the LlvmVar function argument storing the real register
lmGlobalRegArg :: Platform -> GlobalReg -> LlvmVar

-- | Get the LlvmVar function variable storing the real register
lmGlobalRegVar :: Platform -> GlobalReg -> LlvmVar

-- | A list of STG Registers that should always be considered alive
alwaysLive :: [GlobalReg]

-- | STG Type Based Alias Analysis hierarchy
stgTBAA :: [(Unique, LMString, Maybe Unique)]

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
baseN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
stackN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
heapN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
rxN :: Unique

-- | Id values The <a>rootN</a> node is the root (there can be more than
--   one) of the TBAA hierarchy and as of LLVM 4.0 should *only* be
--   referenced by other nodes. It should never occur in any LLVM
--   instruction statement.
topN :: Unique

-- | The TBAA metadata identifier
tbaa :: LMString

-- | Get the correct TBAA metadata information for this register type
getTBAA :: GlobalReg -> Unique


-- | Formats on this architecture A Format is a combination of width and
--   class
--   
--   TODO: Signed vs unsigned?
--   
--   TODO: This module is currently shared by all architectures because
--   NCGMonad need to know about it to make a VReg. It would be better to
--   have architecture specific formats, and do the overloading properly.
--   eg SPARC doesn't care about FF80.
module GHC.CmmToAsm.Format
data Format
II8 :: Format
II16 :: Format
II32 :: Format
II64 :: Format
FF32 :: Format
FF64 :: Format

-- | Get the integer format of this width.
intFormat :: Width -> Format

-- | Get the float format of this width.
floatFormat :: Width -> Format

-- | Check if a format represent an integer value.
isIntFormat :: Format -> Bool

-- | Check if a format represents a floating point value.
isFloatFormat :: Format -> Bool

-- | Convert a Cmm type to a Format.
cmmTypeFormat :: CmmType -> Format

-- | Get the Width of a Format.
formatToWidth :: Format -> Width
formatInBytes :: Format -> Int
instance GHC.Classes.Eq GHC.CmmToAsm.Format.Format
instance GHC.Show.Show GHC.CmmToAsm.Format.Format

module GHC.CmmToAsm.X86.RegInfo
mkVirtualReg :: Unique -> Format -> VirtualReg
regDotColor :: Platform -> RealReg -> SDoc

module GHC.CmmToAsm.PPC.Regs

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
mkVirtualReg :: Unique -> Format -> VirtualReg
regDotColor :: RealReg -> SDoc
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: FastString -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm
LO :: Imm -> Imm
HI :: Imm -> Imm
HA :: Imm -> Imm
HIGHERA :: Imm -> Imm
HIGHESTA :: Imm -> Imm
strImmLit :: FastString -> Imm
litToImm :: CmmLit -> Imm
data AddrMode
AddrRegReg :: Reg -> Reg -> AddrMode
AddrRegImm :: Reg -> Imm -> AddrMode
addrOffset :: AddrMode -> Int -> Maybe AddrMode
spRel :: Platform -> Int -> AddrMode
argRegs :: RegNo -> [Reg]
allArgRegs :: [Reg]
callClobberedRegs :: Platform -> [Reg]
allMachRegNos :: [RegNo]
classOfRealReg :: RealReg -> RegClass
showReg :: RegNo -> String
toRegNo :: Reg -> RegNo
allFPArgRegs :: Platform -> [Reg]
fits16Bits :: Integral a => a -> Bool
makeImmediate :: Integral a => Width -> Bool -> a -> Maybe Imm
fReg :: Int -> RegNo
r0 :: Reg
sp :: Reg
toc :: Reg
r3 :: Reg
r4 :: Reg
r11 :: Reg
r12 :: Reg
r30 :: Reg
tmpReg :: Platform -> Reg
f1 :: Reg
allocatableRegs :: Platform -> [RealReg]


-- | Free regs map for PowerPC
module GHC.CmmToAsm.Reg.Linear.PPC
data FreeRegs
FreeRegs :: !Word32 -> !Word32 -> FreeRegs
noFreeRegs :: FreeRegs
releaseReg :: RealReg -> FreeRegs -> FreeRegs
initFreeRegs :: Platform -> FreeRegs
getFreeRegs :: RegClass -> FreeRegs -> [RealReg]
allocateReg :: RealReg -> FreeRegs -> FreeRegs
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.PPC.FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.PPC.FreeRegs


-- | Constants describing the DWARF format. Most of this simply mirrors
--   /usr/include/dwarf.h.
module GHC.CmmToAsm.Dwarf.Constants

-- | Language ID used for Haskell.
dW_LANG_Haskell :: Word
dW_TAG_compile_unit :: Word
dW_TAG_subroutine_type :: Word
dW_TAG_file_type :: Word
dW_TAG_subprogram :: Word
dW_TAG_lexical_block :: Word
dW_TAG_base_type :: Word
dW_TAG_structure_type :: Word
dW_TAG_pointer_type :: Word
dW_TAG_array_type :: Word
dW_TAG_subrange_type :: Word
dW_TAG_typedef :: Word
dW_TAG_variable :: Word
dW_TAG_arg_variable :: Word
dW_TAG_auto_variable :: Word
dW_TAG_ghc_src_note :: Word
dW_AT_name :: Word
dW_AT_stmt_list :: Word
dW_AT_low_pc :: Word
dW_AT_high_pc :: Word
dW_AT_language :: Word
dW_AT_comp_dir :: Word
dW_AT_producer :: Word
dW_AT_external :: Word
dW_AT_frame_base :: Word
dW_AT_use_UTF8 :: Word
dW_AT_linkage_name :: Word
dW_AT_ghc_tick_parent :: Word
dW_AT_ghc_span_file :: Word
dW_AT_ghc_span_start_line :: Word
dW_AT_ghc_span_start_col :: Word
dW_AT_ghc_span_end_line :: Word
dW_AT_ghc_span_end_col :: Word
dW_CHILDREN_no :: Word8
dW_CHILDREN_yes :: Word8
dW_FORM_addr :: Word
dW_FORM_data2 :: Word
dW_FORM_data4 :: Word
dW_FORM_string :: Word
dW_FORM_flag :: Word
dW_FORM_block1 :: Word
dW_FORM_ref4 :: Word
dW_FORM_ref_addr :: Word
dW_FORM_flag_present :: Word
dW_ATE_address :: Word
dW_ATE_boolean :: Word
dW_ATE_float :: Word
dW_ATE_signed :: Word
dW_ATE_signed_char :: Word
dW_ATE_unsigned :: Word
dW_ATE_unsigned_char :: Word
dW_CFA_set_loc :: Word8
dW_CFA_undefined :: Word8
dW_CFA_same_value :: Word8
dW_CFA_def_cfa :: Word8
dW_CFA_def_cfa_offset :: Word8
dW_CFA_def_cfa_expression :: Word8
dW_CFA_expression :: Word8
dW_CFA_offset_extended_sf :: Word8
dW_CFA_def_cfa_offset_sf :: Word8
dW_CFA_def_cfa_sf :: Word8
dW_CFA_val_offset :: Word8
dW_CFA_val_expression :: Word8
dW_CFA_offset :: Word8
dW_OP_addr :: Word8
dW_OP_deref :: Word8
dW_OP_consts :: Word8
dW_OP_minus :: Word8
dW_OP_mul :: Word8
dW_OP_plus :: Word8
dW_OP_lit0 :: Word8
dW_OP_breg0 :: Word8
dW_OP_call_frame_cfa :: Word8
dwarfInfoSection :: IsDoc doc => Platform -> doc
dwarfAbbrevSection :: IsDoc doc => Platform -> doc
dwarfLineSection :: IsDoc doc => Platform -> doc
dwarfFrameSection :: IsDoc doc => Platform -> doc
dwarfGhcSection :: IsDoc doc => Platform -> doc
dwarfARangesSection :: IsDoc doc => Platform -> doc
dwarfSection :: IsDoc doc => Platform -> String -> doc
dwarfInfoLabel :: IsLine doc => doc
dwarfAbbrevLabel :: IsLine doc => doc
dwarfLineLabel :: IsLine doc => doc
dwarfFrameLabel :: IsLine doc => doc

-- | Mapping of registers to DWARF register numbers
dwarfRegNo :: Platform -> Reg -> Word8

-- | Virtual register number to use for return address.
dwarfReturnRegNo :: Platform -> Word8

module GHC.CmmToAsm.CFG

-- | A control flow graph where edges have been annotated with a weight.
--   Implemented as IntMap (IntMap &lt;edgeData&gt;) We must uphold the
--   invariant that for each edge A -&gt; B we must have: A entry B in the
--   outer map. A entry B in the map we get when looking up A. Maintaining
--   this invariant is useful as any failed lookup now indicates an actual
--   error in code which might go unnoticed for a while otherwise.
type CFG = EdgeInfoMap EdgeInfo
data CfgEdge
CfgEdge :: !BlockId -> !BlockId -> !EdgeInfo -> CfgEdge
[edgeFrom] :: CfgEdge -> !BlockId
[edgeTo] :: CfgEdge -> !BlockId
[edgeInfo] :: CfgEdge -> !EdgeInfo

-- | Information about edges
data EdgeInfo
EdgeInfo :: !TransitionSource -> !EdgeWeight -> EdgeInfo
[transitionSource] :: EdgeInfo -> !TransitionSource
[edgeWeight] :: EdgeInfo -> !EdgeWeight
newtype EdgeWeight
EdgeWeight :: Double -> EdgeWeight
[weightToDouble] :: EdgeWeight -> Double

-- | Can we trace back a edge to a specific Cmm Node or has it been
--   introduced during assembly codegen. We use this to maintain some
--   information which would otherwise be lost during the Cmm &lt;-&gt; asm
--   transition. See also Note [Inverting conditions]
data TransitionSource
CmmSource :: CmmNode O C -> BranchInfo -> TransitionSource
[trans_cmmNode] :: TransitionSource -> CmmNode O C
[trans_info] :: TransitionSource -> BranchInfo
AsmCodeGen :: TransitionSource

-- | Adds a edge with the given weight to the cfg If there already existed
--   an edge it is overwritten. `addWeightEdge from to weight cfg`
addWeightEdge :: BlockId -> BlockId -> EdgeWeight -> CFG -> CFG

-- | Adds a new edge, overwrites existing edges if present
addEdge :: BlockId -> BlockId -> EdgeInfo -> CFG -> CFG
delEdge :: BlockId -> BlockId -> CFG -> CFG

-- | Insert a block in the control flow between two other blocks. We pass a
--   list of tuples (A,B,C) where * A -&gt; C: Old edge * A -&gt; B -&gt; C
--   : New Arc, where B is the new block. It's possible that a block has
--   two jumps to the same block in the assembly code. However we still
--   only store a single edge for these cases. We assign the old edge info
--   to the edge A -&gt; B and assign B -&gt; C the weight of an
--   unconditional jump.
addNodesBetween :: Weights -> CFG -> [(BlockId, BlockId, BlockId)] -> CFG
shortcutWeightMap :: LabelMap (Maybe BlockId) -> CFG -> CFG
reverseEdges :: CFG -> CFG

-- | Filter the CFG with a custom function f. Parameters are `f from to
--   edgeInfo`
filterEdges :: (BlockId -> BlockId -> EdgeInfo -> Bool) -> CFG -> CFG

-- | Sometimes we insert a block which should unconditionally be executed
--   after a given block. This function updates the CFG for these cases. So
--   we get A -&gt; B =&gt; A -&gt; A' -&gt; B -&gt; C =&gt; -&gt; C
addImmediateSuccessor :: Weights -> BlockId -> BlockId -> CFG -> CFG

-- | Convenience function, generate edge info based on weight not
--   originating from cmm.
mkWeightInfo :: EdgeWeight -> EdgeInfo

-- | Adjust the weight between the blocks using the given function. If
--   there is no such edge returns the original map.
adjustEdgeWeight :: CFG -> (EdgeWeight -> EdgeWeight) -> BlockId -> BlockId -> CFG

-- | Set the weight between the blocks to the given weight. If there is no
--   such edge returns the original map.
setEdgeWeight :: CFG -> EdgeWeight -> BlockId -> BlockId -> CFG

-- | Returns a unordered list of all edges with info
infoEdgeList :: CFG -> [CfgEdge]

-- | Returns a unordered list of all edges without weights
edgeList :: CFG -> [Edge]

-- | Get successors of a given node with edge weights.
getSuccessorEdges :: HasDebugCallStack => CFG -> BlockId -> [(BlockId, EdgeInfo)]

-- | Get successors of a given node without edge weights.
getSuccessors :: HasDebugCallStack => CFG -> BlockId -> [BlockId]

-- | Destinations from bid ordered by weight (descending)
getSuccEdgesSorted :: CFG -> BlockId -> [(BlockId, EdgeInfo)]
getEdgeInfo :: BlockId -> BlockId -> CFG -> Maybe EdgeInfo
getCfgNodes :: CFG -> [BlockId]

-- | Is this block part of this graph?
hasNode :: CFG -> BlockId -> Bool

-- | Determine loop membership of blocks based on SCC analysis This is
--   faster but only gives yes/no answers.
loopMembers :: HasDebugCallStack => CFG -> LabelMap Bool
loopLevels :: CFG -> BlockId -> LabelMap Int

-- | Determine loop membership of blocks based on Dominator analysis. This
--   is slower but gives loop levels instead of just loop membership.
--   However it only detects natural loops. Irreducible control flow is not
--   recognized even if it loops. But that is rare enough that we don't
--   have to care about that special case.
loopInfo :: HasDebugCallStack => CFG -> BlockId -> LoopInfo
getCfg :: Platform -> Weights -> CmmGraph -> CFG

-- | Generate weights for a Cmm proc based on some simple heuristics.
getCfgProc :: Platform -> Weights -> RawCmmDecl -> CFG
pprEdgeWeights :: CFG -> SDoc

-- | Check if the nodes in the cfg and the set of blocks are the same. In a
--   case of a mismatch we panic and show the difference.
sanityCheckCfg :: CFG -> LabelSet -> SDoc -> Bool
optimizeCFG :: Bool -> Weights -> RawCmmDecl -> CFG -> CFG

-- | We take in a CFG which has on its edges weights which are relative
--   only to other edges originating from the same node.
--   
--   We return a CFG for which each edge represents a GLOBAL weight. This
--   means edge weights are comparable across the whole graph.
--   
--   For irreducible control flow results might be imprecise, otherwise
--   they are reliable.
--   
--   The algorithm is based on the Paper "Static Branch Prediction and
--   Program Profile Analysis" by Y Wu, JR Larus The only big change is
--   that we go over the nodes in the body of loops in reverse post order.
--   Which is required for diamond control flow to work probably.
--   
--   We also apply a few prediction heuristics (based on the same paper)
--   
--   The returned result represents frequences. For blocks it's the
--   expected number of executions and for edges is the number of
--   traversals.
mkGlobalWeights :: HasDebugCallStack => BlockId -> CFG -> (LabelMap Double, LabelMap (LabelMap Double))
instance GHC.Real.Fractional GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Real.Real GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Num.Num GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Enum.Enum GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Classes.Ord GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.EdgeWeight
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.BranchInfo
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.TransitionSource
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.EdgeInfo
instance GHC.Cmm.Dataflow.Graph.NonLocal GHC.CmmToAsm.CFG.BlockNode
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.LoopInfo
instance GHC.Classes.Eq GHC.CmmToAsm.CFG.CfgEdge
instance GHC.Classes.Ord GHC.CmmToAsm.CFG.CfgEdge
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.CfgEdge
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.EdgeInfo
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.BranchInfo
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.CFG.EdgeWeight

module GHC.CmmToAsm.Reg.Liveness
type RegSet = UniqSet Reg

-- | Map from some kind of register to a.
--   
--   While we give the type for keys as Reg which is the common case
--   sometimes we end up using VirtualReq or naked Uniques. See Note
--   [UniqFM and the register allocator]
type RegMap a = UniqFM Reg a
emptyRegMap :: RegMap a
type BlockMap a = LabelMap a
mapEmpty :: IsMap map => map a

-- | A top level thing which carries liveness information.
type LiveCmmDecl statics instr = GenCmmDecl statics LiveInfo [SCC (LiveBasicBlock instr)]

-- | The register allocator also wants to use SPILL/RELOAD meta
--   instructions, so we'll keep those here.
data InstrSR instr

-- | A real machine instruction
Instr :: instr -> InstrSR instr

-- | spill this reg to a stack slot
SPILL :: Reg -> Int -> InstrSR instr

-- | reload this reg from a stack slot
RELOAD :: Int -> Reg -> InstrSR instr

-- | An instruction with liveness information.
data LiveInstr instr
LiveInstr :: InstrSR instr -> Maybe Liveness -> LiveInstr instr

-- | Liveness information. The regs which die are ones which are no longer
--   live in the *next* instruction in this sequence. (NB. if the
--   instruction is a jump, these registers might still be live at the jump
--   target(s) - you have to check the liveness at the destination block to
--   find out).
data Liveness
Liveness :: RegSet -> RegSet -> RegSet -> Liveness

-- | registers born in this instruction (written to for first time).
[liveBorn] :: Liveness -> RegSet

-- | registers that died because they were read for the last time.
[liveDieRead] :: Liveness -> RegSet

-- | registers that died because they were clobbered by something.
[liveDieWrite] :: Liveness -> RegSet

-- | Stash regs live on entry to each basic block in the info part of the
--   cmm code.
data LiveInfo
LiveInfo :: LabelMap RawCmmStatics -> [BlockId] -> BlockMap RegSet -> BlockMap IntSet -> LiveInfo

-- | A basic block with liveness information.
type LiveBasicBlock instr = GenBasicBlock (LiveInstr instr)

-- | map a function across all the basic blocks in this code
mapBlockTop :: (LiveBasicBlock instr -> LiveBasicBlock instr) -> LiveCmmDecl statics instr -> LiveCmmDecl statics instr

-- | map a function across all the basic blocks in this code (monadic
--   version)
mapBlockTopM :: Monad m => (LiveBasicBlock instr -> m (LiveBasicBlock instr)) -> LiveCmmDecl statics instr -> m (LiveCmmDecl statics instr)
mapSCCM :: Monad m => (a -> m b) -> SCC a -> m (SCC b)
mapGenBlockTop :: (GenBasicBlock i -> GenBasicBlock i) -> GenCmmDecl d h (ListGraph i) -> GenCmmDecl d h (ListGraph i)

-- | map a function across all the basic blocks in this code (monadic
--   version)
mapGenBlockTopM :: Monad m => (GenBasicBlock i -> m (GenBasicBlock i)) -> GenCmmDecl d h (ListGraph i) -> m (GenCmmDecl d h (ListGraph i))

-- | Map over instruction type in <a>LiveCmmDecl</a>
mapLiveCmmDecl :: (instr -> b) -> LiveCmmDecl statics instr -> LiveCmmDecl statics b

-- | Pretty-print a <a>LiveCmmDecl</a>
pprLiveCmmDecl :: (OutputableP Platform statics, Instruction instr) => Platform -> LiveCmmDecl statics instr -> SDoc

-- | Strip away liveness information, yielding NatCmmDecl
stripLive :: (OutputableP Platform statics, Instruction instr) => NCGConfig -> LiveCmmDecl statics instr -> NatCmmDecl statics instr

-- | Strip away liveness information from a basic block, and make real
--   spill instructions out of SPILL, RELOAD pseudos along the way.
stripLiveBlock :: Instruction instr => NCGConfig -> LiveBasicBlock instr -> NatBasicBlock instr

-- | Slurp out the list of register conflicts and reg-reg moves from this
--   top level thing. Slurping of conflicts and moves is wrapped up
--   together so we don't have to make two passes over the same code when
--   we want to build the graph.
slurpConflicts :: Instruction instr => LiveCmmDecl statics instr -> (Bag (UniqSet Reg), Bag (Reg, Reg))

-- | For spill/reloads
--   
--   SPILL v1, slot1 ... RELOAD slot1, v2
--   
--   If we can arrange that v1 and v2 are allocated to the same hreg it's
--   more likely the spill/reload instrs can be cleaned and replaced by a
--   nop reg-reg move.
slurpReloadCoalesce :: forall statics instr. Instruction instr => LiveCmmDecl statics instr -> Bag (Reg, Reg)

-- | Erase Delta instructions.
eraseDeltasLive :: Instruction instr => LiveCmmDecl statics instr -> LiveCmmDecl statics instr

-- | Patch the registers in this code according to this register mapping.
--   also erase reg -&gt; reg moves when the reg is the same. also erase
--   reg -&gt; reg moves when the destination dies in this instr.
patchEraseLive :: Instruction instr => (Reg -> Reg) -> LiveCmmDecl statics instr -> LiveCmmDecl statics instr

-- | Patch registers in this LiveInstr, including the liveness information.
patchRegsLiveInstr :: Instruction instr => (Reg -> Reg) -> LiveInstr instr -> LiveInstr instr

-- | If we've compute liveness info for this code already we have to
--   reverse the SCCs in each top to get them back to the right order so we
--   can do it again.
reverseBlocksInTops :: LiveCmmDecl statics instr -> LiveCmmDecl statics instr
regLiveness :: Instruction instr => Platform -> LiveCmmDecl statics instr -> UniqSM (LiveCmmDecl statics instr)

-- | Convert a NatCmmDecl to a LiveCmmDecl, with liveness information
cmmTopLiveness :: Instruction instr => Maybe CFG -> Platform -> NatCmmDecl statics instr -> UniqSM (LiveCmmDecl statics instr)
instance GHC.Base.Functor GHC.CmmToAsm.Reg.Liveness.InstrSR
instance GHC.Base.Functor GHC.CmmToAsm.Reg.Liveness.LiveInstr
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.CmmToAsm.Reg.Liveness.LiveInfo
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.CmmToAsm.Reg.Liveness.LiveInstr instr)
instance GHC.Utils.Outputable.OutputableP env instr => GHC.Utils.Outputable.OutputableP env (GHC.CmmToAsm.Reg.Liveness.LiveInstr instr)
instance GHC.CmmToAsm.Instr.Instruction instr => GHC.CmmToAsm.Instr.Instruction (GHC.CmmToAsm.Reg.Liveness.InstrSR instr)
instance GHC.Utils.Outputable.Outputable instr => GHC.Utils.Outputable.Outputable (GHC.CmmToAsm.Reg.Liveness.InstrSR instr)


-- | Put common type definitions here to break recursive module
--   dependencies.
module GHC.CmmToAsm.Reg.Linear.Base

-- | Used to store the register assignment on entry to a basic block. We
--   use this to handle join points, where multiple branch instructions
--   target a particular label. We have to insert fixup code to make the
--   register assignments from the different sources match up.
data BlockAssignment freeRegs

-- | Find the register mapping for a specific BlockId.
lookupBlockAssignment :: BlockId -> BlockAssignment freeRegs -> Maybe (freeRegs, RegMap Loc)

-- | Lookup which register a virtual register was first assigned to.
lookupFirstUsed :: VirtualReg -> BlockAssignment freeRegs -> Maybe RealReg

-- | An initial empty <a>BlockAssignment</a>
emptyBlockAssignment :: BlockAssignment freeRegs

-- | Add new register mappings for a specific block.
updateBlockAssignment :: BlockId -> (freeRegs, RegMap Loc) -> BlockAssignment freeRegs -> BlockAssignment freeRegs

-- | Where a vreg is currently stored A temporary can be marked as living
--   in both a register and memory (InBoth), for example if it was recently
--   loaded from a spill location. This makes it cheap to spill (no save
--   instruction required), but we have to be careful to turn this into
--   InReg if the value in the register is changed.
data Loc

-- | vreg is in a register
InReg :: !RealReg -> Loc

-- | vreg is held in a stack slot
InMem :: {-# UNPACK #-} !StackSlot -> Loc

-- | vreg is held in both a register and a stack slot
InBoth :: !RealReg -> {-# UNPACK #-} !StackSlot -> Loc

-- | Get the reg numbers stored in this Loc.
regsOfLoc :: Loc -> [RealReg]

-- | Reasons why instructions might be inserted by the spiller. Used when
--   generating stats for -ddrop-asm-stats.
data SpillReason

-- | vreg was spilled to a slot so we could use its current hreg for
--   another vreg
SpillAlloc :: !Unique -> SpillReason

-- | vreg was moved because its hreg was clobbered
SpillClobber :: !Unique -> SpillReason

-- | vreg was loaded from a spill slot
SpillLoad :: !Unique -> SpillReason

-- | reg-reg move inserted during join to targets
SpillJoinRR :: !Unique -> SpillReason

-- | reg-mem move inserted during join to targets
SpillJoinRM :: !Unique -> SpillReason

-- | Used to carry interesting stats out of the register allocator.
data RegAllocStats
RegAllocStats :: UniqFM Unique [Int] -> [(BlockId, BlockId, BlockId)] -> RegAllocStats
[ra_spillInstrs] :: RegAllocStats -> UniqFM Unique [Int]

-- | (from,fixup,to) : We inserted fixup code between from and to
[ra_fixupList] :: RegAllocStats -> [(BlockId, BlockId, BlockId)]

-- | The register allocator state
data RA_State freeRegs
RA_State :: BlockAssignment freeRegs -> !freeRegs -> RegMap Loc -> Int -> StackMap -> UniqSupply -> [SpillReason] -> !NCGConfig -> [(BlockId, BlockId, BlockId)] -> RA_State freeRegs

-- | the current mapping from basic blocks to the register assignments at
--   the beginning of that block.
[ra_blockassig] :: RA_State freeRegs -> BlockAssignment freeRegs

-- | free machine registers
[ra_freeregs] :: RA_State freeRegs -> !freeRegs

-- | assignment of temps to locations
[ra_assig] :: RA_State freeRegs -> RegMap Loc

-- | current stack delta
[ra_delta] :: RA_State freeRegs -> Int

-- | free stack slots for spilling
[ra_stack] :: RA_State freeRegs -> StackMap

-- | unique supply for generating names for join point fixup blocks.
[ra_us] :: RA_State freeRegs -> UniqSupply

-- | Record why things were spilled, for -ddrop-asm-stats. Just keep a list
--   here instead of a map of regs -&gt; reasons. We don't want to slow
--   down the allocator if we're not going to emit the stats.
[ra_spills] :: RA_State freeRegs -> [SpillReason]

-- | Native code generator configuration
[ra_config] :: RA_State freeRegs -> !NCGConfig

-- | (from,fixup,to) : We inserted fixup code between from and to
[ra_fixups] :: RA_State freeRegs -> [(BlockId, BlockId, BlockId)]
instance GHC.Classes.Ord GHC.CmmToAsm.Reg.Linear.Base.ReadingOrWriting
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Linear.Base.ReadingOrWriting
instance GHC.Classes.Ord GHC.CmmToAsm.Reg.Linear.Base.Loc
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.Base.Loc
instance GHC.Classes.Eq GHC.CmmToAsm.Reg.Linear.Base.Loc
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.Base.Loc

module GHC.CmmToAsm.Reg.Linear.Stats

-- | Build a map of how many times each reg was alloced, clobbered, loaded
--   etc.
binSpillReasons :: [SpillReason] -> UniqFM Unique [Int]

-- | Count reg-reg moves remaining in this code.
countRegRegMovesNat :: Instruction instr => NatCmmDecl statics instr -> Int

-- | Pretty print some RegAllocStats
pprStats :: Instruction instr => [NatCmmDecl statics instr] -> [RegAllocStats] -> SDoc


-- | State monad for the linear register allocator.
module GHC.CmmToAsm.Reg.Linear.State

-- | The register allocator state
data RA_State freeRegs
RA_State :: BlockAssignment freeRegs -> !freeRegs -> RegMap Loc -> Int -> StackMap -> UniqSupply -> [SpillReason] -> !NCGConfig -> [(BlockId, BlockId, BlockId)] -> RA_State freeRegs

-- | the current mapping from basic blocks to the register assignments at
--   the beginning of that block.
[ra_blockassig] :: RA_State freeRegs -> BlockAssignment freeRegs

-- | free machine registers
[ra_freeregs] :: RA_State freeRegs -> !freeRegs

-- | assignment of temps to locations
[ra_assig] :: RA_State freeRegs -> RegMap Loc

-- | current stack delta
[ra_delta] :: RA_State freeRegs -> Int

-- | free stack slots for spilling
[ra_stack] :: RA_State freeRegs -> StackMap

-- | unique supply for generating names for join point fixup blocks.
[ra_us] :: RA_State freeRegs -> UniqSupply

-- | Record why things were spilled, for -ddrop-asm-stats. Just keep a list
--   here instead of a map of regs -&gt; reasons. We don't want to slow
--   down the allocator if we're not going to emit the stats.
[ra_spills] :: RA_State freeRegs -> [SpillReason]

-- | Native code generator configuration
[ra_config] :: RA_State freeRegs -> !NCGConfig

-- | (from,fixup,to) : We inserted fixup code between from and to
[ra_fixups] :: RA_State freeRegs -> [(BlockId, BlockId, BlockId)]

-- | The register allocator monad type.
data RegM freeRegs a

-- | Run a computation in the RegM register allocator monad.
runR :: NCGConfig -> BlockAssignment freeRegs -> freeRegs -> RegMap Loc -> StackMap -> UniqSupply -> RegM freeRegs a -> (BlockAssignment freeRegs, StackMap, RegAllocStats, a)
spillR :: Instruction instr => Reg -> Unique -> RegM freeRegs ([instr], Int)
loadR :: Instruction instr => Reg -> Int -> RegM freeRegs [instr]
getFreeRegsR :: RegM freeRegs freeRegs
setFreeRegsR :: freeRegs -> RegM freeRegs ()
getAssigR :: RegM freeRegs (RegMap Loc)
setAssigR :: RegMap Loc -> RegM freeRegs ()
getBlockAssigR :: RegM freeRegs (BlockAssignment freeRegs)
setBlockAssigR :: BlockAssignment freeRegs -> RegM freeRegs ()
setDeltaR :: Int -> RegM freeRegs ()
getDeltaR :: RegM freeRegs Int
getUniqueR :: RegM freeRegs Unique

-- | Get native code generator configuration
getConfig :: RegM a NCGConfig

-- | Get target platform from native code generator configuration
getPlatform :: RegM a Platform

-- | Record that a spill instruction was inserted, for profiling.
recordSpill :: SpillReason -> RegM freeRegs ()

-- | Record a created fixup block
recordFixupBlock :: BlockId -> BlockId -> BlockId -> RegM freeRegs ()
instance GHC.Base.Functor (GHC.CmmToAsm.Reg.Linear.State.RegM freeRegs)
instance GHC.Base.Applicative (GHC.CmmToAsm.Reg.Linear.State.RegM freeRegs)
instance GHC.Base.Monad (GHC.CmmToAsm.Reg.Linear.State.RegM freeRegs)


-- | Clean out unneeded spill/reload instructions.
--   
--   Handling of join points ~~~~~~~~~~~~~~~~~~~~~~~
--   
--   <pre>
--   B1:                          B2:
--    ...                          ...
--       RELOAD SLOT(0), %r1          RELOAD SLOT(0), %r1
--       ... A ...                    ... B ...
--       jump B3                      jump B3
--   
--                B3: ... C ...
--                    RELOAD SLOT(0), %r1
--                    ...
--   
--   </pre>
--   
--   The Plan ~~~~~~~~
--   
--   As long as %r1 hasn't been written to in A, B or C then we don't need
--   the reload in B3.
--   
--   What we really care about here is that on the entry to B3, %r1 will
--   always have the same value that is in SLOT(0) (ie, %r1 is _valid_)
--   
--   This also works if the reloads in B1/B2 were spills instead, because
--   spilling %r1 to a slot makes that slot have the same value as %r1.
module GHC.CmmToAsm.Reg.Graph.SpillClean

-- | Clean out unneeded spill/reloads from this top level thing.
cleanSpills :: Instruction instr => Platform -> LiveCmmDecl statics instr -> LiveCmmDecl statics instr
instance GHC.Types.Unique.Uniquable GHC.CmmToAsm.Reg.Graph.SpillClean.Store
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Graph.SpillClean.Store


-- | When there aren't enough registers to hold all the vregs we have to
--   spill some of those vregs to slots on the stack. This module is used
--   modify the code to use those slots.
module GHC.CmmToAsm.Reg.Graph.Spill

-- | Spill all these virtual regs to stack slots.
--   
--   Bumps the number of required stack slots if required.
--   
--   TODO: See if we can split some of the live ranges instead of just
--   globally spilling the virtual reg. This might make the spill cleaner's
--   job easier.
--   
--   TODO: On CISCy x86 and x86_64 we don't necessarily have to add a mov
--   instruction when making spills. If an instr is using a spilled virtual
--   we may be able to address the spill slot directly.
regSpill :: Instruction instr => Platform -> [LiveCmmDecl statics instr] -> UniqSet Int -> Int -> UniqSet VirtualReg -> UniqSM ([LiveCmmDecl statics instr], UniqSet Int, Int, SpillStats)

-- | Spiller statistics. Tells us what registers were spilled.
data SpillStats
SpillStats :: UniqFM Reg (Reg, Int, Int) -> SpillStats
[spillStoreLoad] :: SpillStats -> UniqFM Reg (Reg, Int, Int)

-- | Add a spill/reload count to a stats record for a register.
accSpillSL :: (Reg, Int, Int) -> (Reg, Int, Int) -> (Reg, Int, Int)
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Graph.Spill.SpillStats


-- | Register coalescing.
module GHC.CmmToAsm.Reg.Graph.Coalesce

-- | Do register coalescing on this top level thing
--   
--   For Reg -&gt; Reg moves, if the first reg dies at the same time the
--   second reg is born then the mov only serves to join live ranges. The
--   two regs can be renamed to be the same and the move instruction safely
--   erased.
regCoalesce :: Instruction instr => [LiveCmmDecl statics instr] -> UniqSM [LiveCmmDecl statics instr]

-- | Slurp out mov instructions that only serve to join live ranges.
--   
--   During a mov, if the source reg dies and the destination reg is born
--   then we can rename the two regs to the same thing and eliminate the
--   move.
slurpJoinMovs :: Instruction instr => LiveCmmDecl statics instr -> Bag (Reg, Reg)

module GHC.CmmToAsm.Reg.Graph.SpillCost

-- | Records the expected cost to spill some register.
type SpillCostRecord = (VirtualReg, Int, Int, Int)

-- | Add two spill cost records.
plusSpillCostRecord :: SpillCostRecord -> SpillCostRecord -> SpillCostRecord

-- | Show a spill cost record, including the degree from the graph and
--   final calculated spill cost.
pprSpillCostRecord :: (VirtualReg -> RegClass) -> (Reg -> SDoc) -> Graph VirtualReg RegClass RealReg -> SpillCostRecord -> SDoc

-- | Map of <a>SpillCostRecord</a>
type SpillCostInfo = UniqFM VirtualReg SpillCostRecord

-- | An empty map of spill costs.
zeroSpillCostInfo :: SpillCostInfo

-- | Add two spill cost infos.
plusSpillCostInfo :: SpillCostInfo -> SpillCostInfo -> SpillCostInfo

-- | Slurp out information used for determining spill costs.
--   
--   For each vreg, the number of times it was written to, read from, and
--   the number of instructions it was live on entry to (lifetime)
slurpSpillCostInfo :: forall instr statics. Instruction instr => Platform -> Maybe CFG -> LiveCmmDecl statics instr -> SpillCostInfo

-- | Choose a node to spill from this graph
chooseSpill :: SpillCostInfo -> Graph VirtualReg RegClass RealReg -> VirtualReg

-- | Extract a map of register lifetimes from a <a>SpillCostInfo</a>.
lifeMapFromSpillCostInfo :: SpillCostInfo -> UniqFM VirtualReg (VirtualReg, Int)

module GHC.CmmToAsm.AArch64.Regs
allMachRegNos :: [RegNo]
allocatableRegs :: Platform -> [RealReg]
allGpArgRegs :: [Reg]
allFpArgRegs :: [Reg]
data AddrMode
AddrRegReg :: Reg -> Reg -> AddrMode
AddrRegImm :: Reg -> Imm -> AddrMode
AddrReg :: Reg -> AddrMode
data Imm
ImmInt :: Int -> Imm
ImmInteger :: Integer -> Imm
ImmCLbl :: CLabel -> Imm
ImmLit :: FastString -> Imm
ImmIndex :: CLabel -> Int -> Imm
ImmFloat :: Rational -> Imm
ImmDouble :: Rational -> Imm
ImmConstantSum :: Imm -> Imm -> Imm
ImmConstantDiff :: Imm -> Imm -> Imm
strImmLit :: FastString -> Imm
litToImm :: CmmLit -> Imm

-- | regSqueeze_class reg Calculate the maximum number of register colors
--   that could be denied to a node of this class due to having this reg as
--   a neighbour.
virtualRegSqueeze :: RegClass -> VirtualReg -> Int
realRegSqueeze :: RegClass -> RealReg -> Int
mkVirtualReg :: Unique -> Format -> VirtualReg
classOfRealReg :: RealReg -> RegClass
regDotColor :: RealReg -> SDoc
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Regs.Imm
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Regs.Imm
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Regs.AddrMode
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Regs.AddrMode


-- | Hard wired things related to registers. This is module is preventing
--   the native code generator being able to emit code for non-host
--   architectures.
--   
--   TODO: Do a better job of the overloading, and eliminate this module.
--   We'd probably do better with a Register type class, and hook this to
--   Instruction somehow.
--   
--   TODO: We should also make arch specific versions of
--   RegAlloc.Graph.TrivColorable
module GHC.CmmToAsm.Reg.Target
targetVirtualRegSqueeze :: Platform -> RegClass -> VirtualReg -> Int
targetRealRegSqueeze :: Platform -> RegClass -> RealReg -> Int
targetClassOfRealReg :: Platform -> RealReg -> RegClass
targetMkVirtualReg :: Platform -> Unique -> Format -> VirtualReg
targetRegDotColor :: Platform -> RealReg -> SDoc
targetClassOfReg :: Platform -> Reg -> RegClass


-- | Carries interesting info for debugging / profiling of the graph
--   coloring register allocator.
module GHC.CmmToAsm.Reg.Graph.Stats

-- | Holds interesting statistics from the register allocator.
data RegAllocStats statics instr
RegAllocStatsStart :: [LiveCmmDecl statics instr] -> Graph VirtualReg RegClass RealReg -> SpillCostInfo -> !Platform -> RegAllocStats statics instr

-- | Initial code, with liveness.
[raLiveCmm] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | The initial, uncolored graph.
[raGraph] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | Information to help choose which regs to spill.
[raSpillCosts] :: RegAllocStats statics instr -> SpillCostInfo

-- | Target platform
[raPlatform] :: RegAllocStats statics instr -> !Platform
RegAllocStatsSpill :: [LiveCmmDecl statics instr] -> Graph VirtualReg RegClass RealReg -> UniqFM VirtualReg VirtualReg -> SpillStats -> SpillCostInfo -> [LiveCmmDecl statics instr] -> !Platform -> RegAllocStats statics instr

-- | Code we tried to allocate registers for.
[raCode] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | The initial, uncolored graph.
[raGraph] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | The regs that were coalesced.
[raCoalesced] :: RegAllocStats statics instr -> UniqFM VirtualReg VirtualReg

-- | Spiller stats.
[raSpillStats] :: RegAllocStats statics instr -> SpillStats

-- | Information to help choose which regs to spill.
[raSpillCosts] :: RegAllocStats statics instr -> SpillCostInfo

-- | Code with spill instructions added.
[raSpilled] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Target platform
[raPlatform] :: RegAllocStats statics instr -> !Platform
RegAllocStatsColored :: [LiveCmmDecl statics instr] -> Graph VirtualReg RegClass RealReg -> Graph VirtualReg RegClass RealReg -> UniqFM VirtualReg VirtualReg -> [LiveCmmDecl statics instr] -> [LiveCmmDecl statics instr] -> [LiveCmmDecl statics instr] -> [NatCmmDecl statics instr] -> (Int, Int, Int) -> !Platform -> RegAllocStats statics instr

-- | Code we tried to allocate registers for.
[raCode] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | The initial, uncolored graph.
[raGraph] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | Coalesced and colored graph.
[raGraphColored] :: RegAllocStats statics instr -> Graph VirtualReg RegClass RealReg

-- | The regs that were coalesced.
[raCoalesced] :: RegAllocStats statics instr -> UniqFM VirtualReg VirtualReg

-- | Code with coalescings applied.
[raCodeCoalesced] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Code with vregs replaced by hregs.
[raPatched] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Code with unneeded spill/reloads cleaned out.
[raSpillClean] :: RegAllocStats statics instr -> [LiveCmmDecl statics instr]

-- | Final code.
[raFinal] :: RegAllocStats statics instr -> [NatCmmDecl statics instr]

-- | Spill/reload/reg-reg moves present in this code.
[raSRMs] :: RegAllocStats statics instr -> (Int, Int, Int)

-- | Target platform
[raPlatform] :: RegAllocStats statics instr -> !Platform

-- | Do all the different analysis on this list of RegAllocStats
pprStats :: [RegAllocStats statics instr] -> Graph VirtualReg RegClass RealReg -> SDoc

-- | Dump a table of how many spill loads / stores were inserted for each
--   vreg.
pprStatsSpills :: [RegAllocStats statics instr] -> SDoc

-- | Dump a table of how long vregs tend to live for in the initial code.
pprStatsLifetimes :: [RegAllocStats statics instr] -> SDoc

-- | Dump a table of how many conflicts vregs tend to have in the initial
--   code.
pprStatsConflict :: [RegAllocStats statics instr] -> SDoc

-- | For every vreg, dump how many conflicts it has, and its lifetime. Good
--   for making a scatter plot.
pprStatsLifeConflict :: [RegAllocStats statics instr] -> Graph VirtualReg RegClass RealReg -> SDoc

-- | Count spill<i>reload</i>reg-reg moves. Lets us see how well the
--   register allocator has done.
countSRMs :: Instruction instr => LiveCmmDecl statics instr -> (Int, Int, Int)
addSRM :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int)
instance GHC.Base.Functor (GHC.CmmToAsm.Reg.Graph.Stats.RegAllocStats statics)
instance (GHC.Utils.Outputable.OutputableP GHC.Platform.Platform statics, GHC.Utils.Outputable.OutputableP GHC.Platform.Platform instr) => GHC.Utils.Outputable.Outputable (GHC.CmmToAsm.Reg.Graph.Stats.RegAllocStats statics instr)


-- | Graph coloring register allocator.
module GHC.CmmToAsm.Reg.Graph

-- | The top level of the graph coloring register allocator.
regAlloc :: (OutputableP Platform statics, Instruction instr) => NCGConfig -> UniqFM RegClass (UniqSet RealReg) -> UniqSet Int -> Int -> [LiveCmmDecl statics instr] -> Maybe CFG -> UniqSM ([NatCmmDecl statics instr], Maybe Int, [RegAllocStats statics instr])

module GHC.CmmToAsm.Reg.Linear.AArch64

-- | Armv6 | Armv7-A | Armv8-A AArch64 | | SIMD extension | NEON | NEON |
--   |===========================================================================|
--   | - Operates on 32-bit | - Separate reg. bank, | - Separate reg. bank,
--   | | GP ARM registers | 32x64-bit NEON regs | 32x128-bit NEON regs | |
--   - 8-bit<i>16-bit integer | - 8</i>16<i>32</i>64-bit int | -
--   8<i>16</i>32/64-bit int | | | - Single precision fp | - Single
--   precision fp | | | | - Double precision fp | | | | - Single/Double fp
--   are | | | | IEEE compliant | | - 2x16-bit/4x8-bit ops | - Up to
--   16x8-bit ops | - Up to 16x8-bit ops | | per instruction | per
--   instruction | per instruction |
--   '---------------------------------------------------------------------------'
data FreeRegs
FreeRegs :: !Word32 -> !Word32 -> FreeRegs
noFreeRegs :: FreeRegs
showBits :: Word32 -> String
allocateReg :: HasCallStack => RealReg -> FreeRegs -> FreeRegs
getFreeRegs :: RegClass -> FreeRegs -> [RealReg]
initFreeRegs :: Platform -> FreeRegs
releaseReg :: HasCallStack => RealReg -> FreeRegs -> FreeRegs
instance GHC.Show.Show GHC.CmmToAsm.Reg.Linear.AArch64.FreeRegs
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Reg.Linear.AArch64.FreeRegs

module GHC.CmmToAsm.AArch64.Instr

-- | TODO: verify this!
stackFrameHeaderSize :: Platform -> Int

-- | All registers are 8 byte wide.
spillSlotSize :: Int

-- | The number of bytes that the stack pointer should be aligned to.
stackAlign :: Int

-- | The number of spill slots available without allocating more.
maxSpillSlots :: NCGConfig -> Int

-- | Convert a spill slot number to a *byte* offset, with no sign.
spillSlotToOffset :: NCGConfig -> Int -> Int
regUsageOfInstr :: Platform -> Instr -> RegUsage

-- | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
--   16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 |
--   30 | 31 | | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 42
--   | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57
--   | 58 | 59 | 60 | 61 | 62 | 63 | |== General Purpose registers
--   ==================================================================================================================================|
--   | <a>argument passing -------------</a> | IR | <a>tmp registers
--   --------</a> | IP0| IP1| PL | <a>callee saved ------------</a> | FP |
--   LR | SP | | <a>free registers
--   --------------------------------------------------------------------</a>
--   | BR | Sp | Hp | R1 | R2 | R3 | R4 | R5 | R6 | SL | -- | -- | -- | |==
--   SIMD/FP Registers
--   ==========================================================================================================================================|
--   | <a>argument passing -------------</a> | <a>callee saved (lower 64
--   bits) ---</a> | <a>caller saved ----------------------</a> | | <a>free
--   registers -------------</a> | F1 | F2 | F3 | F4 | D1 | D2 | D3 | D4 |
--   <a>free registers
--   -----------------------------------------------------</a> |
--   '---------------------------------------------------------------------------------------------------------------------------------------------------------------'
--   IR: Indirect result location register, IP: Intra-procedure register,
--   PL: Platform register, FP: Frame pointer, LR: Link register, SP: Stack
--   pointer BR: Base, SL: SpLim
--   
--   TODO: The zero register is currently mapped to -1 but should get it's
--   own separate number.
callerSavedRegisters :: [Reg]

-- | Apply a given mapping to all the register references in this
--   instruction.
patchRegsOfInstr :: Instr -> (Reg -> Reg) -> Instr

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
isJumpishInstr :: Instr -> Bool

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
jumpDestsOfInstr :: Instr -> [BlockId]
canFallthroughTo :: Instr -> BlockId -> Bool

-- | Change the destination of this jump instruction. Used in the linear
--   allocator when adding fixup blocks for join points.
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr

-- | An instruction to spill a register into a spill slot.
mkSpillInstr :: HasCallStack => NCGConfig -> Reg -> Int -> Int -> [Instr]
mkLoadInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int
isMetaInstr :: Instr -> Bool

-- | Copy the value in a register to another one. Must work for all
--   register classes.
mkRegRegMoveInstr :: Reg -> Reg -> Instr

-- | Take the source and destination from this reg -&gt; reg move
--   instruction or Nothing if it's not one
takeRegRegMoveInstr :: Instr -> Maybe (Reg, Reg)

-- | Make an unconditional jump instruction.
mkJumpInstr :: BlockId -> [Instr]
mkStackAllocInstr :: Platform -> Int -> [Instr]
mkStackDeallocInstr :: Platform -> Int -> [Instr]
allocMoreStack :: Platform -> Int -> NatCmmDecl statics Instr -> UniqSM (NatCmmDecl statics Instr, [(BlockId, BlockId)])
data Instr
COMMENT :: SDoc -> Instr
MULTILINE_COMMENT :: SDoc -> Instr
ANN :: SDoc -> Instr -> Instr
LOCATION :: Int -> Int -> Int -> String -> Instr
LDATA :: Section -> RawCmmStatics -> Instr
NEWBLOCK :: BlockId -> Instr
DELTA :: Int -> Instr
SXTB :: Operand -> Operand -> Instr
UXTB :: Operand -> Operand -> Instr
SXTH :: Operand -> Operand -> Instr
UXTH :: Operand -> Operand -> Instr

-- | SXTW Operand Operand | SXTX Operand Operand
PUSH_STACK_FRAME :: Instr
POP_STACK_FRAME :: Instr

-- | ADC Operand Operand Operand -- rd = rn + rm + C | ADCS ...
ADD :: Operand -> Operand -> Operand -> Instr

-- | ADDS Operand Operand Operand -- rd = rn + rm | ADR ... | ADRP ...
CMN :: Operand -> Operand -> Instr
CMP :: Operand -> Operand -> Instr

-- | MADD ... | MNEG ...
MSUB :: Operand -> Operand -> Operand -> Operand -> Instr
MUL :: Operand -> Operand -> Operand -> Instr
NEG :: Operand -> Operand -> Instr

-- | NEGS ... | NGC ... | NGCS ... | SBC ... | SBCS ...
SDIV :: Operand -> Operand -> Operand -> Instr

-- | SMADDL ... | SMNEGL ... | SMSUBL ...
SMULH :: Operand -> Operand -> Operand -> Instr
SMULL :: Operand -> Operand -> Operand -> Instr
SUB :: Operand -> Operand -> Operand -> Instr

-- | SUBS ...
UDIV :: Operand -> Operand -> Operand -> Instr

-- | UMADDL ... -- Xd = Xa + Wn × Wm | UMNEGL ... -- Xd = - Wn × Wm |
--   UMSUBL ... -- Xd = Xa - Wn × Wm | UMULH ... -- Xd = (Xn × Xm)_127:64 |
--   UMULL ... -- Xd = Wn × Wm
SBFM :: Operand -> Operand -> Operand -> Operand -> Instr
UBFM :: Operand -> Operand -> Operand -> Operand -> Instr
SBFX :: Operand -> Operand -> Operand -> Operand -> Instr
UBFX :: Operand -> Operand -> Operand -> Operand -> Instr
AND :: Operand -> Operand -> Operand -> Instr
ANDS :: Operand -> Operand -> Operand -> Instr
ASR :: Operand -> Operand -> Operand -> Instr
BIC :: Operand -> Operand -> Operand -> Instr
BICS :: Operand -> Operand -> Operand -> Instr
EON :: Operand -> Operand -> Operand -> Instr
EOR :: Operand -> Operand -> Operand -> Instr
LSL :: Operand -> Operand -> Operand -> Instr
LSR :: Operand -> Operand -> Operand -> Instr
MOV :: Operand -> Operand -> Instr
MOVK :: Operand -> Operand -> Instr

-- | MOVN Operand Operand | MOVZ Operand Operand
MVN :: Operand -> Operand -> Instr
ORN :: Operand -> Operand -> Operand -> Instr
ORR :: Operand -> Operand -> Operand -> Instr
ROR :: Operand -> Operand -> Operand -> Instr
TST :: Operand -> Operand -> Instr
STR :: Format -> Operand -> Operand -> Instr
STLR :: Format -> Operand -> Operand -> Instr
LDR :: Format -> Operand -> Operand -> Instr
LDAR :: Format -> Operand -> Operand -> Instr
STP :: Format -> Operand -> Operand -> Operand -> Instr
LDP :: Format -> Operand -> Operand -> Operand -> Instr
CSET :: Operand -> Cond -> Instr
CBZ :: Operand -> Target -> Instr
CBNZ :: Operand -> Target -> Instr
J :: Target -> Instr
B :: Target -> Instr
BL :: Target -> [Reg] -> [Reg] -> Instr
BCOND :: Cond -> Target -> Instr
DMBSY :: Instr
FCVT :: Operand -> Operand -> Instr
SCVTF :: Operand -> Operand -> Instr
FCVTZS :: Operand -> Operand -> Instr
FABS :: Operand -> Operand -> Instr
instrCon :: Instr -> String
data Target
TBlock :: BlockId -> Target
TLabel :: CLabel -> Target
TReg :: Reg -> Target
data ExtMode
EUXTB :: ExtMode
EUXTH :: ExtMode
EUXTW :: ExtMode
EUXTX :: ExtMode
ESXTB :: ExtMode
ESXTH :: ExtMode
ESXTW :: ExtMode
ESXTX :: ExtMode
data ShiftMode
SLSL :: ShiftMode
SLSR :: ShiftMode
SASR :: ShiftMode
SROR :: ShiftMode
type ExtShift = Int
type RegShift = Int
data Operand
OpReg :: Width -> Reg -> Operand
OpRegExt :: Width -> Reg -> ExtMode -> ExtShift -> Operand
OpRegShift :: Width -> Reg -> ShiftMode -> RegShift -> Operand
OpImm :: Imm -> Operand
OpImmShift :: Imm -> ShiftMode -> RegShift -> Operand
OpAddr :: AddrMode -> Operand
opReg :: Width -> Reg -> Operand
xzr :: Operand
wzr :: Operand
sp :: Operand
ip0 :: Operand
_x :: Int -> Operand
x0 :: Operand
x1 :: Operand
x2 :: Operand
x3 :: Operand
x4 :: Operand
x5 :: Operand
x6 :: Operand
x7 :: Operand
x8 :: Operand
x9 :: Operand
x10 :: Operand
x11 :: Operand
x12 :: Operand
x13 :: Operand
x14 :: Operand
x15 :: Operand
x16 :: Operand
x17 :: Operand
x18 :: Operand
x19 :: Operand
x20 :: Operand
x21 :: Operand
x22 :: Operand
x23 :: Operand
x24 :: Operand
x25 :: Operand
x26 :: Operand
x27 :: Operand
x28 :: Operand
x29 :: Operand
x30 :: Operand
x31 :: Operand
_d :: Int -> Operand
d0 :: Operand
d1 :: Operand
d2 :: Operand
d3 :: Operand
d4 :: Operand
d5 :: Operand
d6 :: Operand
d7 :: Operand
d8 :: Operand
d9 :: Operand
d10 :: Operand
d11 :: Operand
d12 :: Operand
d13 :: Operand
d14 :: Operand
d15 :: Operand
d16 :: Operand
d17 :: Operand
d18 :: Operand
d19 :: Operand
d20 :: Operand
d21 :: Operand
d22 :: Operand
d23 :: Operand
d24 :: Operand
d25 :: Operand
d26 :: Operand
d27 :: Operand
d28 :: Operand
d29 :: Operand
d30 :: Operand
d31 :: Operand
opRegUExt :: Width -> Reg -> Operand
opRegSExt :: Width -> Reg -> Operand
instance GHC.Classes.Ord GHC.CmmToAsm.AArch64.Instr.Target
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.Target
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Instr.ExtMode
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.ExtMode
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Instr.ShiftMode
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.ShiftMode
instance GHC.Show.Show GHC.CmmToAsm.AArch64.Instr.Operand
instance GHC.Classes.Eq GHC.CmmToAsm.AArch64.Instr.Operand
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.Instr.RegUsage

module GHC.CmmToAsm.AArch64.RegInfo
data JumpDest
DestBlockId :: BlockId -> JumpDest
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutStatics :: (BlockId -> Maybe JumpDest) -> RawCmmStatics -> RawCmmStatics
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.AArch64.RegInfo.JumpDest

module GHC.CmmToAsm.AArch64.Ppr
pprNatCmmDecl :: IsDoc doc => NCGConfig -> NatCmmDecl RawCmmStatics Instr -> doc
pprInstr :: IsDoc doc => Platform -> Instr -> doc
pprBasicBlock :: IsDoc doc => NCGConfig -> LabelMap RawCmmStatics -> NatBasicBlock Instr -> doc

module GHC.Cmm.Utils
primRepCmmType :: Platform -> PrimRep -> CmmType
slotCmmType :: Platform -> SlotTy -> CmmType
typeCmmType :: Platform -> UnaryType -> CmmType
typeForeignHint :: UnaryType -> ForeignHint
primRepForeignHint :: PrimRep -> ForeignHint
zeroCLit :: Platform -> CmmLit
mkIntCLit :: Platform -> Int -> CmmLit
mkWordCLit :: Platform -> Integer -> CmmLit
packHalfWordsCLit :: Platform -> StgHalfWord -> StgHalfWord -> CmmLit

-- | We make a top-level decl for the string, and return a label pointing
--   to it
mkByteStringCLit :: CLabel -> ByteString -> (CmmLit, GenCmmDecl (GenCmmStatics raw) info stmt)

-- | We make a top-level decl for the embedded binary file, and return a
--   label pointing to it
mkFileEmbedLit :: CLabel -> FilePath -> Int -> (CmmLit, GenCmmDecl (GenCmmStatics raw) info stmt)

-- | Build a data-segment data block
mkDataLits :: Section -> CLabel -> [CmmLit] -> GenCmmDecl (GenCmmStatics raw) info stmt
mkRODataLits :: CLabel -> [CmmLit] -> GenCmmDecl (GenCmmStatics raw) info stmt
mkStgWordCLit :: Platform -> StgWord -> CmmLit
mkIntExpr :: Platform -> Int -> CmmExpr
zeroExpr :: Platform -> CmmExpr
mkLblExpr :: CLabel -> CmmExpr
cmmRegOff :: CmmReg -> Int -> CmmExpr
cmmOffset :: Platform -> CmmExpr -> Int -> CmmExpr
cmmLabelOff :: CLabel -> Int -> CmmLit
cmmOffsetLit :: CmmLit -> Int -> CmmLit
cmmOffsetExpr :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmRegOffB :: CmmReg -> ByteOff -> CmmExpr
cmmOffsetB :: Platform -> CmmExpr -> ByteOff -> CmmExpr
cmmLabelOffB :: CLabel -> ByteOff -> CmmLit
cmmOffsetLitB :: CmmLit -> ByteOff -> CmmLit
cmmOffsetExprB :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmRegOffW :: Platform -> CmmReg -> WordOff -> CmmExpr
cmmOffsetW :: Platform -> CmmExpr -> WordOff -> CmmExpr
cmmLabelOffW :: Platform -> CLabel -> WordOff -> CmmLit
cmmOffsetLitW :: Platform -> CmmLit -> WordOff -> CmmLit
cmmOffsetExprW :: Platform -> CmmExpr -> CmmExpr -> CmmExpr

-- | Useful for creating an index into an array, with a statically known
--   offset. The type is the element type; used for making the multiplier
cmmIndex :: Platform -> Width -> CmmExpr -> Int -> CmmExpr

-- | Useful for creating an index into an array, with an unknown offset.
cmmIndexExpr :: Platform -> Width -> CmmExpr -> CmmExpr -> CmmExpr
cmmLoadIndex :: Platform -> CmmType -> CmmExpr -> Int -> CmmExpr
cmmLoadIndexW :: Platform -> CmmExpr -> Int -> CmmType -> CmmExpr

-- | Load a naturally-aligned non-pointer word.
cmmLoadBWord :: Platform -> CmmExpr -> CmmExpr

-- | Load a naturally-aligned GC pointer.
cmmLoadGCWord :: Platform -> CmmExpr -> CmmExpr
cmmNegate :: Platform -> CmmExpr -> CmmExpr
cmmULtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUGeWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUGtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUShrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmSLtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmNeWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmEqWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmAndWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmSubWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmAddWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmMulWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmQuotWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmToWord :: Platform -> CmmExpr -> CmmExpr
cmmMkAssign :: Platform -> CmmExpr -> Unique -> (CmmNode O O, CmmExpr)
baseExpr :: CmmExpr
spExpr :: CmmExpr
hpExpr :: CmmExpr
spLimExpr :: CmmExpr
hpLimExpr :: CmmExpr
currentTSOExpr :: CmmExpr
currentNurseryExpr :: CmmExpr
cccsExpr :: CmmExpr
cmmTagMask :: Platform -> CmmExpr
cmmPointerMask :: Platform -> CmmExpr
cmmUntag :: Platform -> CmmExpr -> CmmExpr
cmmIsTagged :: Platform -> CmmExpr -> CmmExpr
cmmIsNotTagged :: Platform -> CmmExpr -> CmmExpr
cmmConstrTag1 :: Platform -> CmmExpr -> CmmExpr
mAX_PTR_TAG :: Platform -> Int
tAG_MASK :: Platform -> Int

-- | Returns True if the two STG registers overlap on the specified
--   platform, in the sense that writing to one will clobber the other.
--   This includes the case that the two registers are the same STG
--   register. See Note [Overlapping global registers] for details.
regsOverlap :: Platform -> CmmReg -> CmmReg -> Bool

-- | Returns True if the STG register is used by the expression, in the
--   sense that a store to the register might affect the value of the
--   expression.
--   
--   We must check for overlapping registers and not just equal registers
--   here, otherwise CmmSink may incorrectly reorder assignments that
--   conflict due to overlap. See #10521 and Note [Overlapping global
--   registers].
regUsedIn :: Platform -> CmmReg -> CmmExpr -> Bool
mkLiveness :: Platform -> [LocalReg] -> Liveness
modifyGraph :: (Graph n C C -> Graph n' C C) -> GenCmmGraph n -> GenCmmGraph n'
ofBlockMap :: BlockId -> LabelMap CmmBlock -> CmmGraph
toBlockMap :: CmmGraph -> LabelMap CmmBlock
ofBlockList :: BlockId -> [CmmBlock] -> CmmGraph
toBlockList :: CmmGraph -> [CmmBlock]

-- | like <a>toBlockList</a>, but the entry block always comes first
toBlockListEntryFirst :: CmmGraph -> [CmmBlock]

-- | Like <a>toBlockListEntryFirst</a>, but we strive to ensure that we
--   order blocks so that the false case of a conditional jumps to the next
--   block in the output list of blocks. This matches the way OldCmm blocks
--   were output since in OldCmm the false case was a fallthrough, whereas
--   in Cmm conditional branches have both true and false successors. Block
--   ordering can make a big difference in performance in the LLVM backend.
--   Note that we rely crucially on the order of successors returned for
--   CmmCondBranch by the NonLocal instance for CmmNode defined in
--   <a>GHC.Cmm.Node</a>. -GBM
toBlockListEntryFirstFalseFallthrough :: CmmGraph -> [CmmBlock]
foldlGraphBlocks :: (a -> CmmBlock -> a) -> a -> CmmGraph -> a
mapGraphNodes :: (CmmNode C O -> CmmNode C O, CmmNode O O -> CmmNode O O, CmmNode O C -> CmmNode O C) -> CmmGraph -> CmmGraph
mapGraphNodes1 :: (forall e x. CmmNode e x -> CmmNode e x) -> CmmGraph -> CmmGraph

-- | Extract all tick annotations from the given block
blockTicks :: Block CmmNode C C -> [CmmTickish]

module GHC.StgToCmm.Closure
type DynTag = Int
tagForCon :: Platform -> DataCon -> DynTag
isSmallFamily :: Platform -> Int -> Bool

-- | Assumes that there is precisely one <a>PrimRep</a> of the type. This
--   assumption holds after unarise. See Note [Post-unarisation invariants]
idPrimRep :: Id -> PrimRep
isVoidRep :: PrimRep -> Bool
isGcPtrRep :: PrimRep -> Bool

-- | Assumes that Ids have one PrimRep, which holds after unarisation. See
--   Note [Post-unarisation invariants]
addIdReps :: [NonVoid Id] -> [NonVoid (PrimRep, Id)]

-- | Assumes that arguments have one PrimRep, which holds after
--   unarisation. See Note [Post-unarisation invariants]
addArgReps :: [NonVoid StgArg] -> [NonVoid (PrimRep, StgArg)]

-- | Assumes that the argument has one PrimRep, which holds after
--   unarisation. See Note [Post-unarisation invariants]
argPrimRep :: StgArg -> PrimRep
newtype NonVoid a
NonVoid :: a -> NonVoid a
fromNonVoid :: NonVoid a -> a
nonVoidIds :: [Id] -> [NonVoid Id]
nonVoidStgArgs :: [StgArg] -> [NonVoid StgArg]

-- | Used in places where some invariant ensures that all these Ids are
--   non-void; e.g. constructor field binders in case expressions. See Note
--   [Post-unarisation invariants] in <a>GHC.Stg.Unarise</a>.
assertNonVoidIds :: [Id] -> [NonVoid Id]

-- | Used in places where some invariant ensures that all these arguments
--   are non-void; e.g. constructor arguments. See Note [Post-unarisation
--   invariants] in <a>GHC.Stg.Unarise</a>.
assertNonVoidStgArgs :: [StgArg] -> [NonVoid StgArg]

-- | Information about an identifier, from the code generator's point of
--   view. Every identifier is bound to a LambdaFormInfo in the
--   environment, which gives the code generator enough info to be able to
--   tail call or return that identifier.
data LambdaFormInfo

-- | StandardFormInfo tells whether this thunk has one of a small number of
--   standard forms
data StandardFormInfo
mkLFThunk :: Type -> TopLevelFlag -> [Id] -> UpdateFlag -> LambdaFormInfo
mkLFReEntrant :: TopLevelFlag -> [Id] -> [Id] -> ArgDescr -> LambdaFormInfo
mkConLFInfo :: DataCon -> LambdaFormInfo
mkSelectorLFInfo :: Id -> Int -> Bool -> LambdaFormInfo
mkApLFInfo :: Id -> UpdateFlag -> Arity -> LambdaFormInfo
mkLFImported :: Id -> LambdaFormInfo
mkLFArgument :: Id -> LambdaFormInfo
mkLFLetNoEscape :: LambdaFormInfo
mkLFStringLit :: LambdaFormInfo

-- | Return the tag in the low order bits of a variable bound to this
--   LambdaForm
lfDynTag :: Platform -> LambdaFormInfo -> DynTag
isLFThunk :: LambdaFormInfo -> Bool
isLFReEntrant :: LambdaFormInfo -> Bool
lfUpdatable :: LambdaFormInfo -> Bool
data CgLoc
CmmLoc :: CmmExpr -> CgLoc
LneLoc :: BlockId -> [LocalReg] -> CgLoc
data CallMethod

-- | No args, not a function
EnterIt :: CallMethod
JumpToIt :: BlockId -> [LocalReg] -> CallMethod
ReturnIt :: CallMethod
InferedReturnIt :: CallMethod
SlowCall :: CallMethod
DirectEntry :: CLabel -> RepArity -> CallMethod
nodeMustPointToIt :: Profile -> LambdaFormInfo -> Bool
isKnownFun :: LambdaFormInfo -> Bool
funTag :: Platform -> ClosureInfo -> DynTag
tagForArity :: Platform -> RepArity -> DynTag
getCallMethod :: StgToCmmConfig -> Name -> Id -> LambdaFormInfo -> RepArity -> CgLoc -> Maybe SelfLoopInfo -> CallMethod
data ClosureInfo
mkClosureInfo :: Profile -> Bool -> Id -> LambdaFormInfo -> Int -> Int -> String -> ClosureInfo

-- | Convert from <a>ClosureInfo</a> to <a>CmmInfoTable</a>.
mkCmmInfo :: ClosureInfo -> Id -> CostCentreStack -> CmmInfoTable
closureLFInfo :: ClosureInfo -> LambdaFormInfo
closureName :: ClosureInfo -> Id
closureInfoLabel :: ClosureInfo -> CLabel
staticClosureLabel :: Platform -> ClosureInfo -> CLabel
closureSlowEntryLabel :: Platform -> ClosureInfo -> CLabel
closureLocalEntryLabel :: Platform -> ClosureInfo -> CLabel
closureUpdReqd :: ClosureInfo -> Bool
closureReEntrant :: ClosureInfo -> Bool
closureFunInfo :: ClosureInfo -> Maybe (RepArity, ArgDescr)
isToplevClosure :: ClosureInfo -> Bool
blackHoleOnEntry :: ClosureInfo -> Bool
isStaticClosure :: ClosureInfo -> Bool
mkDataConInfoTable :: Profile -> DataCon -> ConInfoTableLocation -> Bool -> Int -> Int -> CmmInfoTable
cafBlackHoleInfoTable :: CmmInfoTable
indStaticInfoTable :: CmmInfoTable
staticClosureNeedsLink :: Bool -> CmmInfoTable -> Bool

-- | Get the info table label for a *thunk*.
mkClosureInfoTableLabel :: Platform -> Id -> LambdaFormInfo -> CLabel
instance GHC.Show.Show a => GHC.Show.Show (GHC.StgToCmm.Closure.NonVoid a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.StgToCmm.Closure.NonVoid a)
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Closure.CallMethod
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.StgToCmm.Closure.NonVoid a)
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.StgToCmm.Closure.CgLoc

module GHC.StgToCmm.ArgRep
data ArgRep
P :: ArgRep
N :: ArgRep
L :: ArgRep
V :: ArgRep
F :: ArgRep
D :: ArgRep
V16 :: ArgRep
V32 :: ArgRep
V64 :: ArgRep
toArgRep :: Platform -> PrimRep -> ArgRep
argRepSizeW :: Platform -> ArgRep -> WordOff
argRepString :: ArgRep -> String
isNonV :: ArgRep -> Bool
idArgRep :: Platform -> Id -> ArgRep
slowCallPattern :: [ArgRep] -> (FastString, RepArity)
instance GHC.Classes.Eq GHC.StgToCmm.ArgRep.ArgRep
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.ArgRep.ArgRep

module GHC.Stg.InferTags.Rewrite
rewriteTopBinds :: Module -> UniqSupply -> [GenStgTopBinding 'InferTaggedBinders] -> [TgStgTopBinding]
instance GHC.Base.Applicative GHC.Stg.InferTags.Rewrite.RM
instance GHC.Base.Monad GHC.Stg.InferTags.Rewrite.RM
instance GHC.Base.Functor GHC.Stg.InferTags.Rewrite.RM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Stg.InferTags.Rewrite.RM

module GHC.Stg.InferTags
inferTags :: StgPprOpts -> Bool -> Logger -> Module -> [CgStgTopBinding] -> IO ([TgStgTopBinding], NameEnv TagSig)

module GHC.StgToCmm.CgUtils

-- | Fixup global registers so that they assign to locations within the
--   RegTable if they aren't pinned for the current target.
fixStgRegisters :: Platform -> RawCmmDecl -> RawCmmDecl
baseRegOffset :: Platform -> GlobalReg -> Int
get_Regtable_addr_from_offset :: Platform -> Int -> CmmExpr
regTableOffset :: Platform -> Int -> CmmExpr

-- | We map STG registers onto appropriate CmmExprs. Either they map to
--   real machine registers or stored as offsets from BaseReg. Given a
--   GlobalReg, get_GlobalReg_addr always produces the register table
--   address for it.
get_GlobalReg_addr :: Platform -> GlobalReg -> CmmExpr


-- | Base LLVM Code Generation module
--   
--   Contains functions useful through out the code generator.
module GHC.CmmToLlvm.Base
type LlvmCmmDecl = GenCmmDecl [LlvmData] (Maybe RawCmmStatics) (ListGraph LlvmStatement)
type LlvmBasicBlock = GenBasicBlock LlvmStatement

-- | Global registers live on proc entry
type LiveGlobalRegs = [GlobalReg]

-- | Unresolved code. Of the form: (data label, data type, unresolved data)
type LlvmUnresData = (CLabel, Section, LlvmType, [UnresStatic])

-- | Top level LLVM Data (globals and type aliases)
type LlvmData = ([LMGlobal], [LlvmType])

-- | An unresolved Label.
--   
--   Labels are unresolved when we haven't yet determined if they are
--   defined in the module we are currently compiling, or an external one.
type UnresLabel = CmmLit
type UnresStatic = Either UnresLabel LlvmStatic

-- | The Llvm monad. Wraps <tt>LlvmEnv</tt> state as well as the
--   <tt>IO</tt> monad
data LlvmM a

-- | Get initial Llvm environment.
runLlvm :: Logger -> LlvmCgConfig -> LlvmVersion -> BufHandle -> LlvmM a -> IO a

-- | Clear variables from the environment for a subcomputation
withClearVars :: LlvmM a -> LlvmM a

-- | Lookup variables or functions in the environment.
varLookup :: Uniquable key => key -> LlvmM (Maybe LlvmType)

-- | Insert variables or functions into the environment.
varInsert :: Uniquable key => key -> LlvmType -> LlvmM ()

-- | Set a register as allocated on the stack
markStackReg :: GlobalReg -> LlvmM ()

-- | Check whether a register is allocated on the stack
checkStackReg :: GlobalReg -> LlvmM Bool

-- | Lookup variables or functions in the environment.
funLookup :: Uniquable key => key -> LlvmM (Maybe LlvmType)

-- | Insert variables or functions into the environment.
funInsert :: Uniquable key => key -> LlvmType -> LlvmM ()

-- | Get the LLVM version we are generating code for
getLlvmVer :: LlvmM LlvmVersion

-- | Dumps the document if the corresponding flag has been set by the user
dumpIfSetLlvm :: DumpFlag -> String -> DumpFormat -> SDoc -> LlvmM ()

-- | Prints the given contents to the output handle
renderLlvm :: SDoc -> LlvmM ()

-- | Marks a variable as "used"
markUsedVar :: LlvmVar -> LlvmM ()

-- | Return all variables marked as "used" so far
getUsedVars :: LlvmM [LlvmVar]

-- | Here we pre-initialise some functions that are used internally by GHC
--   so as to make sure they have the most general type in the case that
--   user code also uses these functions but with a different type than GHC
--   internally. (Main offender is treating return type as <tt>void</tt>
--   instead of 'void *'). Fixes trac #5486.
ghcInternalFunctions :: LlvmM ()

-- | Get target platform
getPlatform :: LlvmM Platform
getConfig :: LlvmM LlvmCgConfig

-- | Allocate a new global unnamed metadata identifier
getMetaUniqueId :: LlvmM MetaId

-- | Sets metadata node for a given unique
setUniqMeta :: Unique -> MetaId -> LlvmM ()

-- | Gets metadata node for given unique
getUniqMeta :: Unique -> LlvmM (Maybe MetaId)

-- | Lifting of IO actions. Not exported, as we want to encapsulate IO.
liftIO :: IO a -> LlvmM a

-- | Translate a basic CmmType to an LlvmType.
cmmToLlvmType :: CmmType -> LlvmType

-- | Translate a Cmm Float Width to a LlvmType.
widthToLlvmFloat :: Width -> LlvmType

-- | Translate a Cmm Bit Width to a LlvmType.
widthToLlvmInt :: Width -> LlvmType

-- | Llvm Function type for Cmm function
llvmFunTy :: LiveGlobalRegs -> LlvmM LlvmType

-- | Llvm Function signature
llvmFunSig :: LiveGlobalRegs -> CLabel -> LlvmLinkageType -> LlvmM LlvmFunctionDecl

-- | A Function's arguments
llvmFunArgs :: Platform -> LiveGlobalRegs -> [LlvmVar]

-- | Llvm standard fun attributes
llvmStdFunAttrs :: [LlvmFuncAttr]

-- | Alignment to use for functions
llvmFunAlign :: Platform -> LMAlign

-- | Alignment to use for into tables
llvmInfAlign :: Platform -> LMAlign

-- | Pointer width
llvmPtrBits :: Platform -> Int

-- | Convert a list of types to a list of function parameters (each with no
--   parameter attributes)
tysToParams :: [LlvmType] -> [LlvmParameter]

-- | Section to use for a function
llvmFunSection :: LlvmCgConfig -> LMString -> LMSection

-- | Return a list of "padding" registers for LLVM function calls.
--   
--   When we generate LLVM function signatures, we can't just make any
--   register alive on function entry. Instead, we need to insert fake
--   arguments of the same register class until we are sure that one of
--   them is mapped to the register we want alive. E.g. to ensure that F5
--   is alive, we may need to insert fake arguments mapped to F1, F2, F3
--   and F4.
--   
--   Invariant: Cmm FPR regs with number "n" maps to real registers with
--   number "n" If the calling convention uses registers in a different
--   order or if the invariant doesn't hold, this code probably won't be
--   correct.
padLiveArgs :: Platform -> LiveGlobalRegs -> LiveGlobalRegs
isFPR :: GlobalReg -> Bool

-- | Pretty print a <a>CLabel</a>.
strCLabel_llvm :: CLabel -> LlvmM LMString

-- | Create/get a pointer to a global value. Might return an alias if the
--   value in question hasn't been defined yet. We especially make no
--   guarantees on the type of the returned pointer.
getGlobalPtr :: LMString -> LlvmM LlvmVar

-- | Generate definitions for aliases forward-referenced by
--   <tt>getGlobalPtr</tt>.
--   
--   Must be called at a point where we are sure that no new global
--   definitions will be generated anymore!
generateExternDecls :: LlvmM ([LMGlobal], [LlvmType])

-- | Here we take a global variable definition, rename it with a
--   <tt>$def</tt> suffix, and generate the appropriate alias.
aliasify :: LMGlobal -> LlvmM [LMGlobal]

-- | Derive the definition label. It has an identified structure type.
llvmDefLabel :: LMString -> LMString
instance GHC.Base.Monad GHC.CmmToLlvm.Base.LlvmM
instance GHC.Base.Applicative GHC.CmmToLlvm.Base.LlvmM
instance GHC.Base.Functor GHC.CmmToLlvm.Base.LlvmM
instance GHC.Utils.Logger.HasLogger GHC.CmmToLlvm.Base.LlvmM
instance GHC.Types.Unique.Supply.MonadUnique GHC.CmmToLlvm.Base.LlvmM


-- | Handle conversion of CmmProc to LLVM code.
module GHC.CmmToLlvm.CodeGen

-- | Top-level of the LLVM proc Code generator
genLlvmProc :: RawCmmDecl -> LlvmM [LlvmCmmDecl]
instance GHC.Show.Show GHC.CmmToLlvm.CodeGen.Signage
instance GHC.Classes.Eq GHC.CmmToLlvm.CodeGen.Signage
instance GHC.Base.Semigroup GHC.CmmToLlvm.CodeGen.LlvmAccum
instance GHC.Base.Monoid GHC.CmmToLlvm.CodeGen.LlvmAccum

module GHC.Cmm.Switch.Implement

-- | Traverses the <a>CmmGraph</a>, making sure that <a>CmmSwitch</a> are
--   suitable for code generation.
cmmImplementSwitchPlans :: Platform -> CmmGraph -> UniqSM CmmGraph

module GHC.Cmm.Opt
constantFoldNode :: Platform -> CmmNode e x -> CmmNode e x
constantFoldExpr :: Platform -> CmmExpr -> CmmExpr
cmmMachOpFold :: Platform -> MachOp -> [CmmExpr] -> CmmExpr
cmmMachOpFoldM :: Platform -> MachOp -> [CmmExpr] -> Maybe CmmExpr


-- | Utilities for dealing with constructors/destructors.
module GHC.Cmm.InitFini
data InitOrFini
IsInitArray :: InitOrFini
IsFiniArray :: InitOrFini
isInitOrFiniArray :: RawCmmDecl -> Maybe (InitOrFini, [CLabel])


-- | Handle conversion of CmmData to LLVM code.
module GHC.CmmToLlvm.Data

-- | Pass a CmmStatic section to an equivalent Llvm code.
genLlvmData :: (Section, RawCmmStatics) -> LlvmM LlvmData

-- | Handle static data
genData :: CmmStatic -> LlvmM LlvmStatic


-- | Pretty print helpers for the LLVM Code generator.
module GHC.CmmToLlvm.Ppr

-- | Pretty print LLVM code
pprLlvmCmmDecl :: LlvmCmmDecl -> LlvmM (SDoc, [LlvmVar])

-- | Pretty print LLVM data code
pprLlvmData :: LlvmCgConfig -> LlvmData -> SDoc

-- | The section we are putting info tables and their entry code into,
--   should be unique since we process the assembly pattern matching this.
infoSection :: String


-- | This is the top-level module in the LLVM code generator.
module GHC.CmmToLlvm
data LlvmVersion
llvmVersionList :: LlvmVersion -> [Int]

-- | Top-level of the LLVM Code generator
llvmCodeGen :: Logger -> LlvmCgConfig -> Handle -> Stream IO RawCmmGroup a -> IO a

-- | Read in assembly file and process
llvmFixupAsm :: Platform -> FilePath -> FilePath -> IO ()

module GHC.CmmToC
cmmToC :: Platform -> RawCmmGroup -> SDoc
instance GHC.Base.Monad GHC.CmmToC.TE
instance GHC.Base.Applicative GHC.CmmToC.TE
instance GHC.Base.Functor GHC.CmmToC.TE

module GHC.Cmm.Info
mkEmptyContInfoTable :: CLabel -> CmmInfoTable
cmmToRawCmm :: Logger -> Profile -> Stream IO CmmGroupSRTs a -> IO (Stream IO RawCmmGroup a)

-- | Value of the srt field of an info table when using an StgLargeSRT
srtEscape :: Platform -> StgHalfWord

-- | Takes a closure pointer and returns the info table pointer
closureInfoPtr :: Platform -> DoAlignSanitisation -> CmmExpr -> CmmExpr

-- | Takes an info pointer (the first word of a closure) and returns its
--   entry code
entryCode :: Platform -> CmmExpr -> CmmExpr

-- | Takes a closure pointer, and return the *zero-indexed* constructor tag
--   obtained from the info table This lives in the SRT field of the info
--   table (constructors don't need SRTs).
getConstrTag :: Profile -> DoAlignSanitisation -> CmmExpr -> CmmExpr

-- | Takes a closure pointer, and return the closure type obtained from the
--   info table
cmmGetClosureType :: Profile -> DoAlignSanitisation -> CmmExpr -> CmmExpr

-- | Takes an info pointer (the first word of a closure) and returns a
--   pointer to the first word of the standard-form info table, excluding
--   the entry-code word (if present)
infoTable :: Profile -> CmmExpr -> CmmExpr

-- | Takes an info table pointer (from infoTable) and returns the constr
--   tag field of the info table (same as the srt_bitmap field)
infoTableConstrTag :: Profile -> CmmExpr -> CmmExpr

-- | Takes an info table pointer (from infoTable) and returns the
--   srt_bitmap field of the info table
infoTableSrtBitmap :: Profile -> CmmExpr -> CmmExpr

-- | Takes an info table pointer (from infoTable) and returns the closure
--   type field of the info table.
infoTableClosureType :: Profile -> CmmExpr -> CmmExpr
infoTablePtrs :: Profile -> CmmExpr -> CmmExpr
infoTableNonPtrs :: Profile -> CmmExpr -> CmmExpr

-- | Takes the info pointer of a function, and returns a pointer to the
--   first word of the StgFunInfoExtra struct in the info table.
funInfoTable :: Profile -> CmmExpr -> CmmExpr

-- | Takes the info pointer of a function, returns the function's arity
funInfoArity :: Profile -> CmmExpr -> CmmExpr
stdInfoTableSizeW :: Profile -> WordOff
fixedInfoTableSizeW :: WordOff
profInfoTableSizeW :: WordOff
maxStdInfoTableSizeW :: WordOff
maxRetInfoTableSizeW :: WordOff
stdInfoTableSizeB :: Profile -> ByteOff
conInfoTableSizeB :: Profile -> Int

-- | Byte offset of the SRT bitmap half-word which is in the
--   *higher-addressed* part of the type_lit
stdSrtBitmapOffset :: Profile -> ByteOff

-- | Byte offset of the closure type half-word
stdClosureTypeOffset :: Profile -> ByteOff
stdPtrsOffset :: Profile -> ByteOff
stdNonPtrsOffset :: Profile -> ByteOff

module GHC.CmmToAsm.PPC.Instr
data Instr
COMMENT :: FastString -> Instr
LOCATION :: Int -> Int -> Int -> String -> Instr
LDATA :: Section -> RawCmmStatics -> Instr
NEWBLOCK :: BlockId -> Instr
DELTA :: Int -> Instr
LD :: Format -> Reg -> AddrMode -> Instr
LDFAR :: Format -> Reg -> AddrMode -> Instr
LDR :: Format -> Reg -> AddrMode -> Instr
LA :: Format -> Reg -> AddrMode -> Instr
ST :: Format -> Reg -> AddrMode -> Instr
STFAR :: Format -> Reg -> AddrMode -> Instr
STU :: Format -> Reg -> AddrMode -> Instr
STC :: Format -> Reg -> AddrMode -> Instr
LIS :: Reg -> Imm -> Instr
LI :: Reg -> Imm -> Instr
MR :: Reg -> Reg -> Instr
CMP :: Format -> Reg -> RI -> Instr
CMPL :: Format -> Reg -> RI -> Instr
BCC :: Cond -> BlockId -> Maybe Bool -> Instr
BCCFAR :: Cond -> BlockId -> Maybe Bool -> Instr
JMP :: CLabel -> [Reg] -> Instr
MTCTR :: Reg -> Instr
BCTR :: [Maybe BlockId] -> Maybe CLabel -> [Reg] -> Instr
BL :: CLabel -> [Reg] -> Instr
BCTRL :: [Reg] -> Instr
ADD :: Reg -> Reg -> RI -> Instr
ADDO :: Reg -> Reg -> Reg -> Instr
ADDC :: Reg -> Reg -> Reg -> Instr
ADDE :: Reg -> Reg -> Reg -> Instr
ADDZE :: Reg -> Reg -> Instr
ADDIS :: Reg -> Reg -> Imm -> Instr
SUBF :: Reg -> Reg -> Reg -> Instr
SUBFO :: Reg -> Reg -> Reg -> Instr
SUBFC :: Reg -> Reg -> RI -> Instr
SUBFE :: Reg -> Reg -> Reg -> Instr
MULL :: Format -> Reg -> Reg -> RI -> Instr
MULLO :: Format -> Reg -> Reg -> Reg -> Instr
MFOV :: Format -> Reg -> Instr
MULHU :: Format -> Reg -> Reg -> Reg -> Instr
DIV :: Format -> Bool -> Reg -> Reg -> Reg -> Instr
AND :: Reg -> Reg -> RI -> Instr
ANDC :: Reg -> Reg -> Reg -> Instr
NAND :: Reg -> Reg -> Reg -> Instr
OR :: Reg -> Reg -> RI -> Instr
ORIS :: Reg -> Reg -> Imm -> Instr
XOR :: Reg -> Reg -> RI -> Instr
XORIS :: Reg -> Reg -> Imm -> Instr
EXTS :: Format -> Reg -> Reg -> Instr
CNTLZ :: Format -> Reg -> Reg -> Instr
NEG :: Reg -> Reg -> Instr
NOT :: Reg -> Reg -> Instr
SL :: Format -> Reg -> Reg -> RI -> Instr
SR :: Format -> Reg -> Reg -> RI -> Instr
SRA :: Format -> Reg -> Reg -> RI -> Instr
RLWINM :: Reg -> Reg -> Int -> Int -> Int -> Instr
CLRLI :: Format -> Reg -> Reg -> Int -> Instr
CLRRI :: Format -> Reg -> Reg -> Int -> Instr
FADD :: Format -> Reg -> Reg -> Reg -> Instr
FSUB :: Format -> Reg -> Reg -> Reg -> Instr
FMUL :: Format -> Reg -> Reg -> Reg -> Instr
FDIV :: Format -> Reg -> Reg -> Reg -> Instr
FABS :: Reg -> Reg -> Instr
FNEG :: Reg -> Reg -> Instr
FCMP :: Reg -> Reg -> Instr
FCTIWZ :: Reg -> Reg -> Instr
FCTIDZ :: Reg -> Reg -> Instr
FCFID :: Reg -> Reg -> Instr
FRSP :: Reg -> Reg -> Instr
CRNOR :: Int -> Int -> Int -> Instr
MFCR :: Reg -> Instr
MFLR :: Reg -> Instr
FETCHPC :: Reg -> Instr
HWSYNC :: Instr
ISYNC :: Instr
LWSYNC :: Instr
NOP :: Instr
data RI
RIReg :: Reg -> RI
RIImm :: Imm -> RI
archWordFormat :: Bool -> Format

-- | The size of a minimal stackframe header including minimal parameter
--   save area.
stackFrameHeaderSize :: Platform -> Int

-- | The number of spill slots available without allocating more.
maxSpillSlots :: NCGConfig -> Int
allocMoreStack :: Platform -> Int -> NatCmmDecl statics Instr -> UniqSM (NatCmmDecl statics Instr, [(BlockId, BlockId)])
makeFarBranches :: Platform -> LabelMap RawCmmStatics -> [NatBasicBlock Instr] -> UniqSM [NatBasicBlock Instr]

-- | Make an unconditional jump instruction.
mkJumpInstr :: BlockId -> [Instr]
mkLoadInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | An instruction to spill a register into a spill slot.
mkSpillInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | Change the destination of this jump instruction. Used in the linear
--   allocator when adding fixup blocks for join points.
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr

-- | Apply a given mapping to all the register references in this
--   instruction.
patchRegsOfInstr :: Instr -> (Reg -> Reg) -> Instr

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
jumpDestsOfInstr :: Instr -> [BlockId]
canFallthroughTo :: Instr -> BlockId -> Bool

-- | Take the source and destination from this reg -&gt; reg move
--   instruction or Nothing if it's not one
takeRegRegMoveInstr :: Instr -> Maybe (Reg, Reg)

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int

-- | Copy the value in a register to another one. Must work for all
--   register classes.
mkRegRegMoveInstr :: Reg -> Reg -> Instr
mkStackAllocInstr :: Platform -> Int -> [Instr]
mkStackDeallocInstr :: Platform -> Int -> [Instr]

-- | Get the registers that are being used by this instruction. regUsage
--   doesn't need to do any trickery for jumps and such. Just state
--   precisely the regs read and written by that insn. The consequences of
--   control flow transfers, as far as register allocation goes, are taken
--   care of by the register allocator.
regUsageOfInstr :: Platform -> Instr -> RegUsage

-- | Checks whether this instruction is a jump/branch instruction. One that
--   can change the flow of control in a way that the register allocator
--   needs to worry about.
isJumpishInstr :: Instr -> Bool
isMetaInstr :: Instr -> Bool

module GHC.CmmToAsm.PPC.RegInfo
data JumpDest
DestBlockId :: BlockId -> JumpDest
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
shortcutStatics :: (BlockId -> Maybe JumpDest) -> RawCmmStatics -> RawCmmStatics
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.PPC.RegInfo.JumpDest

module GHC.CmmToAsm.PPC.Ppr
pprNatCmmDecl :: IsDoc doc => NCGConfig -> NatCmmDecl RawCmmStatics Instr -> doc
pprInstr :: IsDoc doc => Platform -> Instr -> doc

module GHC.Cmm.DebugBlock

-- | Debug information about a block of code. Ticks scope over nested
--   blocks.
data DebugBlock
DebugBlock :: !Label -> !Label -> !CLabel -> !Bool -> !Maybe DebugBlock -> ![CmmTickish] -> !Maybe CmmTickish -> !Maybe Int -> [UnwindPoint] -> ![DebugBlock] -> DebugBlock

-- | Entry label of containing proc
[dblProcedure] :: DebugBlock -> !Label

-- | Hoopl label
[dblLabel] :: DebugBlock -> !Label

-- | Output label
[dblCLabel] :: DebugBlock -> !CLabel

-- | Has an info table?
[dblHasInfoTbl] :: DebugBlock -> !Bool

-- | The parent of this proc. See Note [Splitting DebugBlocks]
[dblParent] :: DebugBlock -> !Maybe DebugBlock

-- | Ticks defined in this block
[dblTicks] :: DebugBlock -> ![CmmTickish]

-- | Best source tick covering block
[dblSourceTick] :: DebugBlock -> !Maybe CmmTickish

-- | Output position relative to other blocks. <tt>Nothing</tt> means the
--   block was optimized out
[dblPosition] :: DebugBlock -> !Maybe Int
[dblUnwind] :: DebugBlock -> [UnwindPoint]

-- | Nested blocks
[dblBlocks] :: DebugBlock -> ![DebugBlock]

-- | Extract debug data from a group of procedures. We will prefer source
--   notes that come from the given module (presumably the module that we
--   are currently compiling).
cmmDebugGen :: ModLocation -> RawCmmGroup -> [DebugBlock]
cmmDebugLabels :: (i -> Bool) -> GenCmmGroup d g (ListGraph i) -> [Label]

-- | Sets position and unwind table fields in the debug block tree
--   according to native generated code.
cmmDebugLink :: [Label] -> LabelMap [UnwindPoint] -> [DebugBlock] -> [DebugBlock]

-- | Converts debug blocks into a label map for easier lookups
debugToMap :: [DebugBlock] -> LabelMap DebugBlock

-- | Maps registers to expressions that yield their "old" values further up
--   the stack. Most interesting for the stack pointer <tt>Sp</tt>, but
--   might be useful to document saved registers, too. Note that a
--   register's value will be <a>Nothing</a> when the register's previous
--   value cannot be reconstructed.
type UnwindTable = Map GlobalReg (Maybe UnwindExpr)

-- | A label associated with an <a>UnwindTable</a>
data UnwindPoint
UnwindPoint :: !CLabel -> !UnwindTable -> UnwindPoint

-- | Expressions, used for unwind information
data UnwindExpr

-- | literal value
UwConst :: !Int -> UnwindExpr

-- | register plus offset
UwReg :: !GlobalReg -> !Int -> UnwindExpr

-- | pointer dereferencing
UwDeref :: UnwindExpr -> UnwindExpr
UwLabel :: CLabel -> UnwindExpr
UwPlus :: UnwindExpr -> UnwindExpr -> UnwindExpr
UwMinus :: UnwindExpr -> UnwindExpr -> UnwindExpr
UwTimes :: UnwindExpr -> UnwindExpr -> UnwindExpr

-- | Conversion of Cmm expressions to unwind expressions. We check for
--   unsupported operator usages and simplify the expression as far as
--   possible.
toUnwindExpr :: Platform -> CmmExpr -> UnwindExpr
pprUnwindTable :: IsLine doc => Platform -> UnwindTable -> doc
instance GHC.Classes.Eq GHC.Cmm.DebugBlock.UnwindExpr
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.DebugBlock.DebugBlock
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.DebugBlock.UnwindPoint
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.Cmm.DebugBlock.UnwindExpr

module GHC.CmmToAsm.X86.Instr
data Instr
COMMENT :: FastString -> Instr
LOCATION :: Int -> Int -> Int -> String -> Instr
LDATA :: Section -> (Alignment, RawCmmStatics) -> Instr
NEWBLOCK :: BlockId -> Instr
UNWIND :: CLabel -> UnwindTable -> Instr
DELTA :: Int -> Instr

-- | N.B. when used with the <a>II64</a> <a>Format</a>, the source operand
--   is interpreted to be a 32-bit sign-extended value. True 64-bit
--   operands need to be moved with <tt>MOVABS</tt>, which we currently
--   don't use.
MOV :: Format -> Operand -> Operand -> Instr
CMOV :: Cond -> Format -> Operand -> Reg -> Instr

-- | The format argument is the size of operand 1 (the number of bits we
--   keep) We always zero *all* high bits, even though this isn't how the
--   actual instruction works. The code generator also seems to rely on
--   this behaviour and it's faster to execute on many cpus as well so for
--   now I'm just documenting the fact.
MOVZxL :: Format -> Operand -> Operand -> Instr
MOVSxL :: Format -> Operand -> Operand -> Instr
LEA :: Format -> Operand -> Operand -> Instr
ADD :: Format -> Operand -> Operand -> Instr
ADC :: Format -> Operand -> Operand -> Instr
SUB :: Format -> Operand -> Operand -> Instr
SBB :: Format -> Operand -> Operand -> Instr
MUL :: Format -> Operand -> Operand -> Instr
MUL2 :: Format -> Operand -> Instr
IMUL :: Format -> Operand -> Operand -> Instr
IMUL2 :: Format -> Operand -> Instr
DIV :: Format -> Operand -> Instr
IDIV :: Format -> Operand -> Instr
ADD_CC :: Format -> Operand -> Operand -> Instr
SUB_CC :: Format -> Operand -> Operand -> Instr
AND :: Format -> Operand -> Operand -> Instr
OR :: Format -> Operand -> Operand -> Instr
XOR :: Format -> Operand -> Operand -> Instr
NOT :: Format -> Operand -> Instr
NEGI :: Format -> Operand -> Instr
BSWAP :: Format -> Reg -> Instr
SHL :: Format -> Operand -> Operand -> Instr
SAR :: Format -> Operand -> Operand -> Instr
SHR :: Format -> Operand -> Operand -> Instr
BT :: Format -> Imm -> Operand -> Instr
NOP :: Instr
X87Store :: Format -> AddrMode -> Instr
CVTSS2SD :: Reg -> Reg -> Instr
CVTSD2SS :: Reg -> Reg -> Instr
CVTTSS2SIQ :: Format -> Operand -> Reg -> Instr
CVTTSD2SIQ :: Format -> Operand -> Reg -> Instr
CVTSI2SS :: Format -> Operand -> Reg -> Instr
CVTSI2SD :: Format -> Operand -> Reg -> Instr
FDIV :: Format -> Operand -> Operand -> Instr
SQRT :: Format -> Operand -> Reg -> Instr
TEST :: Format -> Operand -> Operand -> Instr
CMP :: Format -> Operand -> Operand -> Instr
SETCC :: Cond -> Operand -> Instr
PUSH :: Format -> Operand -> Instr
POP :: Format -> Operand -> Instr
JMP :: Operand -> [Reg] -> Instr
JXX :: Cond -> BlockId -> Instr
JXX_GBL :: Cond -> Imm -> Instr
JMP_TBL :: Operand -> [Maybe JumpDest] -> Section -> CLabel -> Instr

-- | X86 call instruction
CALL :: Either Imm Reg -> [Reg] -> Instr
CLTD :: Format -> Instr
FETCHGOT :: Reg -> Instr
FETCHPC :: Reg -> Instr
POPCNT :: Format -> Operand -> Reg -> Instr
LZCNT :: Format -> Operand -> Reg -> Instr
TZCNT :: Format -> Operand -> Reg -> Instr
BSF :: Format -> Operand -> Reg -> Instr
BSR :: Format -> Operand -> Reg -> Instr
PDEP :: Format -> Operand -> Operand -> Reg -> Instr
PEXT :: Format -> Operand -> Operand -> Reg -> Instr
PREFETCH :: PrefetchVariant -> Format -> Operand -> Instr
LOCK :: Instr -> Instr
XADD :: Format -> Operand -> Operand -> Instr
CMPXCHG :: Format -> Operand -> Operand -> Instr
XCHG :: Format -> Operand -> Reg -> Instr
MFENCE :: Instr
data Operand
OpReg :: Reg -> Operand
OpImm :: Imm -> Operand
OpAddr :: AddrMode -> Operand
data PrefetchVariant
NTA :: PrefetchVariant
Lvl0 :: PrefetchVariant
Lvl1 :: PrefetchVariant
Lvl2 :: PrefetchVariant
data JumpDest
DestBlockId :: BlockId -> JumpDest
DestImm :: Imm -> JumpDest
getJumpDestBlockId :: JumpDest -> Maybe BlockId
canShortcut :: Instr -> Maybe JumpDest
shortcutStatics :: (BlockId -> Maybe JumpDest) -> (Alignment, RawCmmStatics) -> (Alignment, RawCmmStatics)
shortcutJump :: (BlockId -> Maybe JumpDest) -> Instr -> Instr
allocMoreStack :: Platform -> Int -> NatCmmDecl statics Instr -> UniqSM (NatCmmDecl statics Instr, [(BlockId, BlockId)])
maxSpillSlots :: NCGConfig -> Int
archWordFormat :: Bool -> Format

-- | Check whether an instruction represents a reg-reg move. The register
--   allocator attempts to eliminate reg-&gt;reg moves whenever it can, by
--   assigning the src and dest temporaries to the same real register.
takeRegRegMoveInstr :: Instr -> Maybe (Reg, Reg)

-- | Returns which registers are read and written as a (read, written)
--   pair.
regUsageOfInstr :: Platform -> Instr -> RegUsage

-- | See if this instruction is telling us the current C stack delta
takeDeltaInstr :: Instr -> Maybe Int

-- | Make a spill reload instruction.
mkLoadInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | Make an unconditional branch instruction.
mkJumpInstr :: BlockId -> [Instr]
mkStackAllocInstr :: Platform -> Int -> [Instr]
mkStackDeallocInstr :: Platform -> Int -> [Instr]

-- | Make a spill instruction.
mkSpillInstr :: NCGConfig -> Reg -> Int -> Int -> [Instr]

-- | Make a reg-reg move instruction.
mkRegRegMoveInstr :: Platform -> Reg -> Reg -> Instr
jumpDestsOfInstr :: Instr -> [BlockId]
canFallthroughTo :: Instr -> BlockId -> Bool

-- | Applies the supplied function to all registers in instructions.
--   Typically used to change virtual registers to real registers.
patchRegsOfInstr :: Instr -> (Reg -> Reg) -> Instr
patchJumpInstr :: Instr -> (BlockId -> BlockId) -> Instr
isMetaInstr :: Instr -> Bool
isJumpishInstr :: Instr -> Bool
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.X86.Instr.JumpDest

module GHC.CmmToAsm.X86.Ppr
pprNatCmmDecl :: IsDoc doc => NCGConfig -> NatCmmDecl (Alignment, RawCmmStatics) Instr -> doc
pprInstr :: forall doc. IsDoc doc => Platform -> Instr -> doc

module GHC.CmmToAsm.Reg.Linear.FreeRegs
class Show freeRegs => FR freeRegs
frAllocateReg :: FR freeRegs => Platform -> RealReg -> freeRegs -> freeRegs
frGetFreeRegs :: FR freeRegs => Platform -> RegClass -> freeRegs -> [RealReg]
frInitFreeRegs :: FR freeRegs => Platform -> freeRegs
frReleaseReg :: FR freeRegs => Platform -> RealReg -> freeRegs -> freeRegs
maxSpillSlots :: NCGConfig -> Int
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.X86.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.X86_64.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.PPC.FreeRegs
instance GHC.CmmToAsm.Reg.Linear.FreeRegs.FR GHC.CmmToAsm.Reg.Linear.AArch64.FreeRegs


-- | Handles joining of a jump instruction to its targets.
module GHC.CmmToAsm.Reg.Linear.JoinToTargets

-- | For a jump instruction at the end of a block, generate fixup code so
--   its vregs are in the correct regs for its destination.
joinToTargets :: (FR freeRegs, Instruction instr) => BlockMap RegSet -> BlockId -> instr -> RegM freeRegs ([NatBasicBlock instr], instr)

module GHC.CmmToAsm.Reg.Linear
regAlloc :: Instruction instr => NCGConfig -> LiveCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr, Maybe Int, Maybe RegAllocStats)

module GHC.CmmToAsm.Monad
data NcgImpl statics instr jumpDest
NcgImpl :: !NCGConfig -> (RawCmmDecl -> NatM [NatCmmDecl statics instr]) -> (instr -> Maybe (NatCmmDecl statics instr)) -> (jumpDest -> Maybe BlockId) -> (instr -> Maybe jumpDest) -> ((BlockId -> Maybe jumpDest) -> statics -> statics) -> ((BlockId -> Maybe jumpDest) -> instr -> instr) -> (NatCmmDecl statics instr -> SDoc) -> (NatCmmDecl statics instr -> HDoc) -> Int -> [RealReg] -> (Int -> NatCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr, [(BlockId, BlockId)])) -> (Platform -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> UniqSM [NatBasicBlock instr]) -> ([instr] -> [UnwindPoint]) -> (Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]) -> NcgImpl statics instr jumpDest
[ncgConfig] :: NcgImpl statics instr jumpDest -> !NCGConfig
[cmmTopCodeGen] :: NcgImpl statics instr jumpDest -> RawCmmDecl -> NatM [NatCmmDecl statics instr]
[generateJumpTableForInstr] :: NcgImpl statics instr jumpDest -> instr -> Maybe (NatCmmDecl statics instr)
[getJumpDestBlockId] :: NcgImpl statics instr jumpDest -> jumpDest -> Maybe BlockId

-- | Does this jump always jump to a single destination and is
--   shortcutable?
--   
--   We use this to determine shortcutable instructions - See Note [What is
--   shortcutting] Note that if we return a destination here we *most*
--   support the relevant shortcutting in shortcutStatics for jump tables
--   and shortcutJump for the instructions itself.
[canShortcut] :: NcgImpl statics instr jumpDest -> instr -> Maybe jumpDest

-- | Replace references to blockIds with other destinations - used to
--   update jump tables.
[shortcutStatics] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> statics -> statics

-- | Change the jump destination(s) of an instruction.
[shortcutJump] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> instr -> instr

-- | <a>GenModule</a> is only for printing internal labels. See Note
--   [Internal proc labels] in CLabel.
[pprNatCmmDeclS] :: NcgImpl statics instr jumpDest -> NatCmmDecl statics instr -> SDoc
[pprNatCmmDeclH] :: NcgImpl statics instr jumpDest -> NatCmmDecl statics instr -> HDoc
[maxSpillSlots] :: NcgImpl statics instr jumpDest -> Int
[allocatableRegs] :: NcgImpl statics instr jumpDest -> [RealReg]

-- | The list of block ids records the redirected jumps to allow us to
--   update the CFG.
[ncgAllocMoreStack] :: NcgImpl statics instr jumpDest -> Int -> NatCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr, [(BlockId, BlockId)])
[ncgMakeFarBranches] :: NcgImpl statics instr jumpDest -> Platform -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> UniqSM [NatBasicBlock instr]

-- | given the instruction sequence of a block, produce a list of the
--   block's <a>UnwindPoint</a>s See Note [What is this unwinding
--   business?] in <a>GHC.Cmm.DebugBlock</a> and Note [Unwinding
--   information in the NCG] in this module.
[extractUnwindPoints] :: NcgImpl statics instr jumpDest -> [instr] -> [UnwindPoint]

-- | Turn the sequence of <tt>jcc l1; jmp l2</tt> into <tt>jncc l2;
--   &lt;block_l1&gt;</tt> when possible.
[invertCondBranches] :: NcgImpl statics instr jumpDest -> Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]
data NatM_State
NatM_State :: UniqSupply -> Int -> [CLabel] -> Maybe Reg -> NCGConfig -> DwarfFiles -> LabelMap DebugBlock -> CFG -> NatM_State
[natm_us] :: NatM_State -> UniqSupply

-- | Stack offset for unwinding information
[natm_delta] :: NatM_State -> Int
[natm_imports] :: NatM_State -> [CLabel]
[natm_pic] :: NatM_State -> Maybe Reg
[natm_config] :: NatM_State -> NCGConfig
[natm_fileid] :: NatM_State -> DwarfFiles
[natm_debug_map] :: NatM_State -> LabelMap DebugBlock

-- | Having a CFG with additional information is essential for some
--   operations. However we can't reconstruct all information once we
--   generated instructions. So instead we update the CFG as we go.
[natm_cfg] :: NatM_State -> CFG
mkNatM_State :: UniqSupply -> Int -> NCGConfig -> DwarfFiles -> LabelMap DebugBlock -> CFG -> NatM_State
data NatM a
initNat :: NatM_State -> NatM a -> (a, NatM_State)
addImportNat :: CLabel -> NatM ()

-- | Record that we added a block between <tt>from</tt> and <tt>old</tt>.
addNodeBetweenNat :: BlockId -> BlockId -> BlockId -> NatM ()

-- | Place <a>succ</a> after <tt>block</tt> and change any edges block
--   -&gt; X to <a>succ</a> -&gt; X
addImmediateSuccessorNat :: BlockId -> BlockId -> NatM ()
updateCfgNat :: (CFG -> CFG) -> NatM ()
getUniqueNat :: NatM Unique
setDeltaNat :: Int -> NatM ()

-- | Get native code generator configuration
getConfig :: NatM NCGConfig

-- | Get target platform from native code generator configuration
getPlatform :: NatM Platform
getDeltaNat :: NatM Int
getThisModuleNat :: NatM Module
getBlockIdNat :: NatM BlockId
getNewLabelNat :: NatM CLabel
getNewRegNat :: Format -> NatM Reg
getPicBaseMaybeNat :: NatM (Maybe Reg)
getPicBaseNat :: Format -> NatM Reg

-- | Get CFG edge weights
getCfgWeights :: NatM Weights
getFileId :: FastString -> NatM Int
getDebugBlock :: Label -> NatM (Maybe DebugBlock)
type DwarfFiles = UniqFM FastString (FastString, Int)

-- | Two 32-bit regs used as a single virtual 64-bit register
data Reg64
Reg64 :: !Reg -> !Reg -> Reg64

-- | Two 32-bit regs used as a single virtual 64-bit register and the code
--   to set them appropriately
data RegCode64 code
RegCode64 :: code -> !Reg -> !Reg -> RegCode64 code

-- | Return a virtual 64-bit register
getNewReg64 :: NatM Reg64

-- | Convert a 64-bit LocalReg into two virtual 32-bit regs.
--   
--   Used to handle 64-bit "registers" on 32-bit architectures
localReg64 :: HasDebugCallStack => LocalReg -> Reg64
instance GHC.Base.Monad GHC.CmmToAsm.Monad.NatM
instance GHC.Base.Applicative GHC.CmmToAsm.Monad.NatM
instance GHC.Base.Functor GHC.CmmToAsm.Monad.NatM
instance GHC.Types.Unique.Supply.MonadUnique GHC.CmmToAsm.Monad.NatM
instance GHC.Unit.Module.HasModule GHC.CmmToAsm.Monad.NatM

module GHC.CmmToAsm.PIC
cmmMakeDynamicReference :: CmmMakeDynamicReferenceM m => NCGConfig -> ReferenceKind -> CLabel -> m CmmExpr
class Monad m => CmmMakeDynamicReferenceM m
addImport :: CmmMakeDynamicReferenceM m => CLabel -> m ()
data ReferenceKind
DataReference :: ReferenceKind
CallReference :: ReferenceKind
JumpReference :: ReferenceKind
needImportedSymbols :: NCGConfig -> Bool
pprImportedSymbol :: NCGConfig -> CLabel -> HDoc
pprGotDeclaration :: NCGConfig -> HDoc
initializePicBase_ppc :: Arch -> OS -> Reg -> [NatCmmDecl RawCmmStatics Instr] -> NatM [NatCmmDecl RawCmmStatics Instr]
initializePicBase_x86 :: Arch -> OS -> Reg -> [NatCmmDecl (Alignment, RawCmmStatics) Instr] -> NatM [NatCmmDecl (Alignment, RawCmmStatics) Instr]
instance GHC.Classes.Eq GHC.CmmToAsm.PIC.ReferenceKind
instance GHC.CmmToAsm.PIC.CmmMakeDynamicReferenceM GHC.CmmToAsm.Monad.NatM

module GHC.CmmToAsm.X86.CodeGen
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl (Alignment, RawCmmStatics) Instr]
generateJumpTableForInstr :: NCGConfig -> Instr -> Maybe (NatCmmDecl (Alignment, RawCmmStatics) Instr)
extractUnwindPoints :: [Instr] -> [UnwindPoint]

-- | This works on the invariant that all jumps in the given blocks are
--   required. Starting from there we try to make a few more jumps
--   redundant by reordering them. We depend on the information in the CFG
--   to do so so without a given CFG we do nothing.
invertCondBranches :: Maybe CFG -> LabelMap a -> [NatBasicBlock Instr] -> [NatBasicBlock Instr]

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal yields the insns in the
--   correct order.
type InstrBlock = OrdList Instr


-- | Native code generator for x86 and x86-64 architectures
module GHC.CmmToAsm.X86
ncgX86_64 :: NCGConfig -> NcgImpl (Alignment, RawCmmStatics) Instr JumpDest
ncgX86 :: NCGConfig -> NcgImpl (Alignment, RawCmmStatics) Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.X86.Instr.Instr

module GHC.CmmToAsm.PPC.CodeGen

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal (pre-order?) yields the
--   insns in the correct order.
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl RawCmmStatics Instr]
generateJumpTableForInstr :: NCGConfig -> Instr -> Maybe (NatCmmDecl RawCmmStatics Instr)

-- | <a>InstrBlock</a>s are the insn sequences generated by the insn
--   selectors. They are really trees of insns to facilitate fast
--   appending, where a left-to-right traversal yields the insns in the
--   correct order.
type InstrBlock = OrdList Instr


-- | Native code generator for PPC architectures
module GHC.CmmToAsm.PPC
ncgPPC :: NCGConfig -> NcgImpl RawCmmStatics Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.PPC.Instr.Instr

module GHC.CmmToAsm.BlockLayout
sequenceTop :: Instruction instr => NcgImpl statics instr jumpDest -> Maybe CFG -> NatCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr)
backendMaintainsCfg :: Platform -> Bool
instance GHC.Classes.Eq GHC.CmmToAsm.BlockLayout.BlockChain
instance GHC.Classes.Ord GHC.CmmToAsm.BlockLayout.BlockChain
instance GHC.Utils.Outputable.Outputable GHC.CmmToAsm.BlockLayout.BlockChain

module GHC.Driver.Config.CmmToAsm

-- | Initialize the native code generator configuration from the DynFlags
initNCGConfig :: DynFlags -> Module -> NCGConfig

module GHC.CmmToAsm.Dwarf.Types

-- | Individual dwarf records. Each one will be encoded as an entry in the
--   <tt>.debug_info</tt> section.
data DwarfInfo
DwarfCompileUnit :: [DwarfInfo] -> String -> String -> String -> CLabel -> CLabel -> DwarfInfo
[dwChildren] :: DwarfInfo -> [DwarfInfo]
[dwName] :: DwarfInfo -> String
[dwProducer] :: DwarfInfo -> String
[dwCompDir] :: DwarfInfo -> String
[dwLowLabel] :: DwarfInfo -> CLabel
[dwHighLabel] :: DwarfInfo -> CLabel
DwarfSubprogram :: [DwarfInfo] -> String -> CLabel -> Maybe CLabel -> DwarfInfo
[dwChildren] :: DwarfInfo -> [DwarfInfo]
[dwName] :: DwarfInfo -> String
[dwLabel] :: DwarfInfo -> CLabel

-- | label of DIE belonging to the parent tick
[dwParent] :: DwarfInfo -> Maybe CLabel
DwarfBlock :: [DwarfInfo] -> CLabel -> Maybe CLabel -> DwarfInfo
[dwChildren] :: DwarfInfo -> [DwarfInfo]
[dwLabel] :: DwarfInfo -> CLabel
[dwMarker] :: DwarfInfo -> Maybe CLabel
DwarfSrcNote :: RealSrcSpan -> DwarfInfo
[dwSrcSpan] :: DwarfInfo -> RealSrcSpan

-- | Generate assembly for DWARF data
pprDwarfInfo :: IsDoc doc => Platform -> Bool -> DwarfInfo -> doc

-- | Abbreviation declaration. This explains the binary encoding we use for
--   representing <a>DwarfInfo</a>. Be aware that this must be updated
--   along with <a>pprDwarfInfo</a>.
pprAbbrevDecls :: IsDoc doc => Platform -> Bool -> doc

-- | A DWARF address range. This is used by the debugger to quickly locate
--   which compilation unit a given address belongs to. This type assumes a
--   non-segmented address-space.
data DwarfARange
DwarfARange :: CLabel -> CLabel -> DwarfARange
[dwArngStartLabel] :: DwarfARange -> CLabel
[dwArngEndLabel] :: DwarfARange -> CLabel

-- | Print assembler directives corresponding to a DWARF
--   <tt>.debug_aranges</tt> address table entry.
pprDwarfARanges :: IsDoc doc => Platform -> [DwarfARange] -> Unique -> doc

-- | Information about unwind instructions for a procedure. This
--   corresponds to a "Common Information Entry" (CIE) in DWARF.
data DwarfFrame
DwarfFrame :: CLabel -> UnwindTable -> [DwarfFrameProc] -> DwarfFrame
[dwCieLabel] :: DwarfFrame -> CLabel
[dwCieInit] :: DwarfFrame -> UnwindTable
[dwCieProcs] :: DwarfFrame -> [DwarfFrameProc]

-- | Unwind instructions for an individual procedure. Corresponds to a
--   "Frame Description Entry" (FDE) in DWARF.
data DwarfFrameProc
DwarfFrameProc :: CLabel -> Bool -> [DwarfFrameBlock] -> DwarfFrameProc
[dwFdeProc] :: DwarfFrameProc -> CLabel
[dwFdeHasInfo] :: DwarfFrameProc -> Bool

-- | List of blocks. Order must match asm!
[dwFdeBlocks] :: DwarfFrameProc -> [DwarfFrameBlock]

-- | Unwind instructions for a block. Will become part of the containing
--   FDE.
data DwarfFrameBlock
DwarfFrameBlock :: Bool -> [UnwindPoint] -> DwarfFrameBlock
[dwFdeBlkHasInfo] :: DwarfFrameBlock -> Bool

-- | these unwind points must occur in the same order as they occur in the
--   block
[dwFdeUnwind] :: DwarfFrameBlock -> [UnwindPoint]

-- | Header for the <tt>.debug_frame</tt> section. Here we emit the "Common
--   Information Entry" record that establishes general call frame
--   parameters and the default stack layout.
pprDwarfFrame :: forall doc. IsDoc doc => Platform -> DwarfFrame -> doc

-- | Assembly for a single byte of constant DWARF data
pprByte :: IsDoc doc => Word8 -> doc

-- | Assembly for a two-byte constant integer
pprHalf :: IsDoc doc => Word16 -> doc

-- | Assembly for 4 bytes of dynamic DWARF data
pprData4' :: IsDoc doc => Line doc -> doc

-- | Assembly for a DWARF word of dynamic data. This means 32 bit, as we
--   are generating 32 bit DWARF.
pprDwWord :: IsDoc doc => Line doc -> doc

-- | Assembly for a machine word of dynamic data. Depends on the
--   architecture we are currently generating code for.
pprWord :: IsDoc doc => Platform -> Line doc -> doc

-- | Prints a number in "little endian base 128" format. The idea is to
--   optimize for small numbers by stopping once all further bytes would be
--   0. The highest bit in every byte signals whether there are further
--   bytes to read.
pprLEBWord :: IsDoc doc => Word -> doc

-- | Same as <tt>pprLEBWord</tt>, but for a signed number
pprLEBInt :: IsDoc doc => Int -> doc

-- | Align assembly at (machine) word boundary
wordAlign :: IsDoc doc => Platform -> doc

-- | Generate an offset into another section. This is tricky because this
--   is handled differently depending on platform: Mac Os expects us to
--   calculate the offset using assembler arithmetic. Linux expects us to
--   just reference the target directly, and will figure out on their own
--   that we actually need an offset. Finally, Windows has a special
--   directive to refer to relative offsets. Fun.
sectionOffset :: IsDoc doc => Platform -> Line doc -> Line doc -> doc
instance GHC.Enum.Enum GHC.CmmToAsm.Dwarf.Types.DwarfAbbrev
instance GHC.Classes.Eq GHC.CmmToAsm.Dwarf.Types.DwarfAbbrev
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.CmmToAsm.Dwarf.Types.DwarfFrameBlock

module GHC.CmmToAsm.Dwarf

-- | Generate DWARF/debug information
dwarfGen :: IsDoc doc => String -> NCGConfig -> ModLocation -> UniqSupply -> [DebugBlock] -> (doc, UniqSupply)

module GHC.CmmToAsm.AArch64.CodeGen
cmmTopCodeGen :: RawCmmDecl -> NatM [NatCmmDecl RawCmmStatics Instr]
generateJumpTableForInstr :: NCGConfig -> Instr -> Maybe (NatCmmDecl RawCmmStatics Instr)
makeFarBranches :: Platform -> LabelMap RawCmmStatics -> [NatBasicBlock Instr] -> UniqSM [NatBasicBlock Instr]


-- | Native code generator for AArch64 architectures
module GHC.CmmToAsm.AArch64
ncgAArch64 :: NCGConfig -> NcgImpl RawCmmStatics Instr JumpDest
instance GHC.CmmToAsm.Instr.Instruction GHC.CmmToAsm.AArch64.Instr.Instr

module GHC.Cmm.Dataflow
type C = 'Closed
type O = 'Open

-- | A sequence of nodes. May be any of four shapes (O<i>O, O</i>C, C<i>O,
--   C</i>C). Open at the entry means single entry, mutatis mutandis for
--   exit. A closed<i>closed block is a </i>basic/ block and can't be
--   extended further. Clients should avoid manipulating blocks and should
--   stick to either nodes or graphs.
data Block n e x
lastNode :: Block n x C -> n O C
entryLabel :: NonLocal thing => thing C x -> Label

-- | Folds backward over all nodes of an open-open block. Strict in the
--   accumulator.
foldNodesBwdOO :: (node O O -> f -> f) -> Block node O O -> f -> f

-- | Folds backward over all the nodes of an open-open block and allows
--   rewriting them. The accumulator is both the block of nodes and
--   <tt>f</tt> (usually dataflow facts). Strict in both accumulated parts.
foldRewriteNodesBwdOO :: forall f node. (node O O -> f -> UniqSM (Block node O O, f)) -> Block node O O -> f -> UniqSM (Block node O O, f)
data DataflowLattice a
DataflowLattice :: a -> JoinFun a -> DataflowLattice a
[fact_bot] :: DataflowLattice a -> a
[fact_join] :: DataflowLattice a -> JoinFun a
newtype OldFact a
OldFact :: a -> OldFact a
newtype NewFact a
NewFact :: a -> NewFact a

-- | The result of joining OldFact and NewFact.
data JoinedFact a

-- | Result is different than OldFact.
Changed :: !a -> JoinedFact a

-- | Result is the same as OldFact.
NotChanged :: !a -> JoinedFact a
type TransferFun f = CmmBlock -> FactBase f -> FactBase f

-- | Function for rewriting and analysis combined. To be used with
--   <tt>rewriteCmm</tt>.
--   
--   Currently set to work with <tt>UniqSM</tt> monad, but we could
--   probably abstract that away (if we do that, we might want to
--   specialize the fixpoint algorithms to the particular monads through
--   SPECIALIZE).
type RewriteFun f = CmmBlock -> FactBase f -> UniqSM (CmmBlock, FactBase f)
type family Fact (x :: Extensibility) f :: Type
type FactBase f = LabelMap f
getFact :: DataflowLattice f -> Label -> FactBase f -> f

-- | Returns the joined facts for each label.
mkFactBase :: DataflowLattice f -> [(Label, f)] -> FactBase f
analyzeCmmFwd :: NonLocal node => DataflowLattice f -> TransferFun' node f -> GenCmmGraph node -> FactBase f -> FactBase f
analyzeCmmBwd :: NonLocal node => DataflowLattice f -> TransferFun' node f -> GenCmmGraph node -> FactBase f -> FactBase f
rewriteCmmBwd :: NonLocal node => DataflowLattice f -> RewriteFun' node f -> GenCmmGraph node -> FactBase f -> UniqSM (GenCmmGraph node, FactBase f)
changedIf :: Bool -> a -> JoinedFact a

-- | Returns the result of joining the facts from all the successors of the
--   provided node or block.
joinOutFacts :: NonLocal n => DataflowLattice f -> n e C -> FactBase f -> f
joinFacts :: DataflowLattice f -> [f] -> f

module GHC.Cmm.Liveness
type CmmLocalLive = CmmLive LocalReg

-- | Calculated liveness info for a CmmGraph
cmmLocalLiveness :: Platform -> CmmGraph -> BlockEntryLiveness LocalReg
cmmLocalLivenessL :: Platform -> CmmGraph -> BlockEntryLivenessL
cmmGlobalLiveness :: Platform -> CmmGraph -> BlockEntryLiveness GlobalReg

-- | The dataflow lattice
liveLattice :: Ord r => DataflowLattice (CmmLive r)

-- | The dataflow lattice
liveLatticeL :: DataflowLattice LRegSet
gen_kill :: (DefinerOfRegs r n, UserOfRegs r n) => Platform -> n -> CmmLive r -> CmmLive r
gen_killL :: (DefinerOfRegs LocalReg n, UserOfRegs LocalReg n) => Platform -> n -> LRegSet -> LRegSet

module GHC.Cmm.Sink
cmmSink :: Platform -> CmmGraph -> CmmGraph

module GHC.Cmm.ProcPoint
type ProcPointSet = LabelSet
data Status
ReachedBy :: ProcPointSet -> Status
ProcPoint :: Status
callProcPoints :: CmmGraph -> ProcPointSet
minimalProcPointSet :: Platform -> ProcPointSet -> CmmGraph -> UniqSM ProcPointSet
splitAtProcPoints :: Platform -> CLabel -> ProcPointSet -> ProcPointSet -> LabelMap Status -> CmmDecl -> UniqSM [CmmDecl]
procPointAnalysis :: ProcPointSet -> CmmGraph -> LabelMap Status
attachContInfoTables :: ProcPointSet -> CmmDecl -> CmmDecl
instance GHC.Utils.Outputable.Outputable GHC.Cmm.ProcPoint.Status

module GHC.Cmm.Lint
cmmLint :: (OutputableP Platform d, OutputableP Platform h) => Platform -> GenCmmGroup d h CmmGraph -> Maybe SDoc
cmmLintGraph :: Platform -> CmmGraph -> Maybe SDoc
instance GHC.Base.Monad GHC.Cmm.Lint.CmmLint
instance GHC.Base.Applicative GHC.Cmm.Lint.CmmLint
instance GHC.Base.Functor GHC.Cmm.Lint.CmmLint

module GHC.Cmm.Dominators

-- | <h1>Dominator sets</h1>
--   
--   Node X dominates node Y if and only if every path from the entry to Y
--   includes X. Node Y technically dominates itself, but it is never
--   included in the *representation* of its dominator set.
--   
--   A dominator set is represented as a linked list in which each node
--   points to its *immediate* dominator, which is its parent in the
--   dominator tree. In many circumstances the immediate dominator will be
--   the only dominator of interest.
data DominatorSet
ImmediateDominator :: Label -> DominatorSet -> DominatorSet

-- | Label of the immediate dominator.
[ds_label] :: DominatorSet -> Label

-- | Set of nodes dominating the immediate dominator.
[ds_parent] :: DominatorSet -> DominatorSet
EntryNode :: DominatorSet

-- | The result of dominator analysis. Also includes a reverse postorder
--   numbering, which is needed for dominator analysis and for other
--   (downstream) analyses.
--   
--   Invariant: Dominators, graph, and RP numberings include only
--   *reachable* blocks.
data GraphWithDominators node
GraphWithDominators :: GenCmmGraph node -> LabelMap DominatorSet -> LabelMap RPNum -> GraphWithDominators node
[gwd_graph] :: GraphWithDominators node -> GenCmmGraph node
[gwd_dominators] :: GraphWithDominators node -> LabelMap DominatorSet
[gwd_rpnumbering] :: GraphWithDominators node -> LabelMap RPNum

-- | Reverse postorder number of a node in a CFG
data RPNum

-- | Call this function with a <a>CmmGraph</a> to get back the results of a
--   dominator analysis of that graph (as well as a reverse postorder
--   numbering). The result also includes the subgraph of the original
--   graph that contains only the reachable blocks.
graphWithDominators :: forall node. (NonLocal node, HasDebugCallStack) => GenCmmGraph node -> GraphWithDominators node

-- | <h1>Utility functions</h1>
--   
--   Call <a>graphMap</a> to get the mapping from <a>Label</a> to
--   <a>Block</a> that is embedded in every <a>CmmGraph</a>.
graphMap :: GenCmmGraph n -> LabelMap (Block n C C)

-- | Use <a>gwdRPNumber</a> on the result of the dominator analysis to get
--   a mapping from the <a>Label</a> of each reachable block to the reverse
--   postorder number of that block.
gwdRPNumber :: HasDebugCallStack => GraphWithDominators node -> Label -> RPNum

-- | Use <a>gwdDominatorsOf</a> on the result of the dominator analysis to
--   get a mapping from the <a>Label</a> of each reachable block to the
--   dominator set (and the immediate dominator) of that block. The
--   implementation is space-efficient: intersecting dominator sets share
--   the representation of their intersection.
gwdDominatorsOf :: HasDebugCallStack => GraphWithDominators node -> Label -> DominatorSet
gwdDominatorTree :: GraphWithDominators node -> Tree Label

-- | Use to tell if the given label is in the given dominator set. Which is
--   to say, does the bloc with with given label _properly_ and
--   _non-vacuously_ dominate the node whose dominator set this is?
--   
--   Takes linear time in the height of the dominator tree, but uses space
--   efficiently.
dominatorsMember :: Label -> DominatorSet -> Bool

-- | Intersect two dominator sets to produce a third dominator set. This
--   function takes time linear in the size of the sets. As such it is
--   inefficient and should be used only for things like visualizations or
--   linters.
intersectDominators :: DominatorSet -> DominatorSet -> DominatorSet
instance GHC.Classes.Eq GHC.Cmm.Dominators.DominatorSet
instance GHC.Classes.Ord GHC.Cmm.Dominators.RPNum
instance GHC.Classes.Eq GHC.Cmm.Dominators.RPNum
instance GHC.Show.Show GHC.Cmm.Dominators.RPNum
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Dominators.RPNum
instance GHC.Utils.Outputable.Outputable GHC.Cmm.Dominators.DominatorSet

module GHC.Wasm.ControlFlow.FromCmm

-- | Convert a Cmm CFG to WebAssembly's structured control flow.
structuredControl :: forall expr stmt m. Applicative m => Platform -> (Label -> CmmExpr -> m expr) -> (Label -> CmmActions -> m stmt) -> CmmGraph -> m (WasmControl stmt expr '[] '[ 'I32])
instance GHC.Utils.Outputable.Outputable GHC.Wasm.ControlFlow.FromCmm.Context
instance GHC.Utils.Outputable.Outputable GHC.Wasm.ControlFlow.FromCmm.ContainingSyntax

module GHC.CmmToAsm.Wasm.FromCmm

-- | Calculate the natural alignment size given the platform word type.
alignmentFromWordType :: WasmTypeTag w -> Alignment
globalInfoFromCmmGlobalReg :: WasmTypeTag w -> GlobalReg -> Maybe GlobalInfo
supportedCmmGlobalRegs :: [GlobalReg]

-- | Invoked for each <a>RawCmmGroup</a>.
onCmmGroup :: RawCmmGroup -> WasmCodeGenM w ()

module GHC.CmmToAsm.Wasm.Asm
asmTellEverything :: WasmTypeTag w -> WasmCodeGenState w -> WasmAsmM ()

-- | Default indent level is none
execWasmAsmM :: Bool -> WasmAsmM a -> Builder
instance GHC.Base.Monad GHC.CmmToAsm.Wasm.Asm.WasmAsmM
instance GHC.Base.Applicative GHC.CmmToAsm.Wasm.Asm.WasmAsmM
instance GHC.Base.Functor GHC.CmmToAsm.Wasm.Asm.WasmAsmM
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.CmmToAsm.Wasm.Asm.WasmAsmM a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (GHC.CmmToAsm.Wasm.Asm.WasmAsmM a)

module GHC.CmmToAsm.Wasm
ncgWasm :: Platform -> ToolSettings -> UniqSupply -> ModLocation -> Handle -> Stream IO RawCmmGroup a -> IO a


-- | Native code generator
--   
--   The native-code generator has machine-independent and
--   machine-dependent modules.
--   
--   This module (<a>GHC.CmmToAsm</a>) is the top-level machine-independent
--   module. Before entering machine-dependent land, we do some
--   machine-independent optimisations (defined below) on the
--   <tt>CmmStmts</tt>s.
--   
--   We convert to the machine-specific <a>Instr</a> datatype with
--   <tt>cmmCodeGen</tt>, assuming an infinite supply of registers. We then
--   use a machine-independent register allocator (<tt>regAlloc</tt>) to
--   rejoin reality. Obviously, <tt>regAlloc</tt> has machine-specific
--   helper functions (see about <a>RegAllocInfo</a> below).
--   
--   Finally, we order the basic blocks of the function so as to minimise
--   the number of jumps between blocks, by utilising fallthrough wherever
--   possible.
--   
--   The machine-dependent bits break down as follows:
--   
--   <ul>
--   <li>[<a>MachRegs</a>] Everything about the target platform's machine
--   registers (and immediate operands, and addresses, which tend to
--   intermingle/interact with registers).</li>
--   <li>[<a>MachInstrs</a>] Includes the <a>Instr</a> datatype (possibly
--   should have a module of its own), plus a miscellany of other things
--   (e.g., <tt>targetDoubleSize</tt>, <tt>smStablePtrTable</tt>, ...)</li>
--   <li>[<a>MachCodeGen</a>] is where <tt>Cmm</tt> stuff turns into
--   machine instructions.</li>
--   <li>[<a>PprMach</a>] <a>pprInstr</a> turns an <a>Instr</a> into text
--   (well, really a <a>SDoc</a>).</li>
--   <li>[<a>RegAllocInfo</a>] In the register allocator, we manipulate
--   <tt>MRegsState</tt>s, which are <tt>BitSet</tt>s, one bit per machine
--   register. When we want to say something about a specific machine
--   register (e.g., ``it gets clobbered by this instruction''), we
--   set/unset its bit. Obviously, we do this <tt>BitSet</tt> thing for
--   efficiency reasons.</li>
--   </ul>
--   
--   The <tt>RegAllocInfo</tt> module collects together the
--   machine-specific info needed to do register allocation.
--   
--   <ul>
--   <li>[<a>RegisterAlloc</a>] The (machine-independent) register
--   allocator. -}</li>
--   </ul>
module GHC.CmmToAsm
nativeCodeGen :: forall a. Logger -> ToolSettings -> NCGConfig -> ModLocation -> Handle -> UniqSupply -> Stream IO RawCmmGroup a -> IO a

-- | Complete native code generation phase for a single top-level chunk of
--   Cmm. Dumping the output of each stage along the way. Global conflict
--   graph and NGC stats
cmmNativeGen :: forall statics instr jumpDest. (Instruction instr, OutputableP Platform statics, Outputable jumpDest) => Logger -> NcgImpl statics instr jumpDest -> UniqSupply -> DwarfFiles -> LabelMap DebugBlock -> RawCmmDecl -> Int -> IO (UniqSupply, DwarfFiles, [NatCmmDecl statics instr], [CLabel], Maybe [RegAllocStats statics instr], Maybe [RegAllocStats], LabelMap [UnwindPoint])
data NcgImpl statics instr jumpDest
NcgImpl :: !NCGConfig -> (RawCmmDecl -> NatM [NatCmmDecl statics instr]) -> (instr -> Maybe (NatCmmDecl statics instr)) -> (jumpDest -> Maybe BlockId) -> (instr -> Maybe jumpDest) -> ((BlockId -> Maybe jumpDest) -> statics -> statics) -> ((BlockId -> Maybe jumpDest) -> instr -> instr) -> (NatCmmDecl statics instr -> SDoc) -> (NatCmmDecl statics instr -> HDoc) -> Int -> [RealReg] -> (Int -> NatCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr, [(BlockId, BlockId)])) -> (Platform -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> UniqSM [NatBasicBlock instr]) -> ([instr] -> [UnwindPoint]) -> (Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]) -> NcgImpl statics instr jumpDest
[ncgConfig] :: NcgImpl statics instr jumpDest -> !NCGConfig
[cmmTopCodeGen] :: NcgImpl statics instr jumpDest -> RawCmmDecl -> NatM [NatCmmDecl statics instr]
[generateJumpTableForInstr] :: NcgImpl statics instr jumpDest -> instr -> Maybe (NatCmmDecl statics instr)
[getJumpDestBlockId] :: NcgImpl statics instr jumpDest -> jumpDest -> Maybe BlockId

-- | Does this jump always jump to a single destination and is
--   shortcutable?
--   
--   We use this to determine shortcutable instructions - See Note [What is
--   shortcutting] Note that if we return a destination here we *most*
--   support the relevant shortcutting in shortcutStatics for jump tables
--   and shortcutJump for the instructions itself.
[canShortcut] :: NcgImpl statics instr jumpDest -> instr -> Maybe jumpDest

-- | Replace references to blockIds with other destinations - used to
--   update jump tables.
[shortcutStatics] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> statics -> statics

-- | Change the jump destination(s) of an instruction.
[shortcutJump] :: NcgImpl statics instr jumpDest -> (BlockId -> Maybe jumpDest) -> instr -> instr

-- | <a>GenModule</a> is only for printing internal labels. See Note
--   [Internal proc labels] in CLabel.
[pprNatCmmDeclS] :: NcgImpl statics instr jumpDest -> NatCmmDecl statics instr -> SDoc
[pprNatCmmDeclH] :: NcgImpl statics instr jumpDest -> NatCmmDecl statics instr -> HDoc
[maxSpillSlots] :: NcgImpl statics instr jumpDest -> Int
[allocatableRegs] :: NcgImpl statics instr jumpDest -> [RealReg]

-- | The list of block ids records the redirected jumps to allow us to
--   update the CFG.
[ncgAllocMoreStack] :: NcgImpl statics instr jumpDest -> Int -> NatCmmDecl statics instr -> UniqSM (NatCmmDecl statics instr, [(BlockId, BlockId)])
[ncgMakeFarBranches] :: NcgImpl statics instr jumpDest -> Platform -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> UniqSM [NatBasicBlock instr]

-- | given the instruction sequence of a block, produce a list of the
--   block's <a>UnwindPoint</a>s See Note [What is this unwinding
--   business?] in <a>GHC.Cmm.DebugBlock</a> and Note [Unwinding
--   information in the NCG] in this module.
[extractUnwindPoints] :: NcgImpl statics instr jumpDest -> [instr] -> [UnwindPoint]

-- | Turn the sequence of <tt>jcc l1; jmp l2</tt> into <tt>jncc l2;
--   &lt;block_l1&gt;</tt> when possible.
[invertCondBranches] :: NcgImpl statics instr jumpDest -> Maybe CFG -> LabelMap RawCmmStatics -> [NatBasicBlock instr] -> [NatBasicBlock instr]
instance GHC.Base.Functor GHC.CmmToAsm.CmmOptM
instance GHC.Base.Applicative GHC.CmmToAsm.CmmOptM
instance GHC.Base.Monad GHC.CmmToAsm.CmmOptM
instance GHC.CmmToAsm.PIC.CmmMakeDynamicReferenceM GHC.CmmToAsm.CmmOptM


-- | Test a Cmm control-flow graph for reducibility. And provide a function
--   that, when given an arbitrary control-flow graph, returns an
--   equivalent, reducible control-flow graph. The equivalent graph is
--   obtained by "splitting" (copying) nodes of the original graph. The
--   resulting equivalent graph has the same dynamic behavior as the
--   original, but it is larger.
--   
--   Documentation uses the language of control-flow analysis, in which a
--   basic block is called a "node." These "nodes" are <a>CmmBlock</a>s or
--   equivalent; they have nothing to do with a <a>CmmNode</a>.
--   
--   For more on reducibility and related analyses and algorithms, see Note
--   [Reducibility resources]
module GHC.Cmm.Reducibility

-- | Represents the result of a reducibility analysis.
data Reducibility
Reducible :: Reducibility
Irreducible :: Reducibility

-- | Given a graph, say whether the graph is reducible. The graph must be
--   bundled with a dominator analysis and a reverse postorder numbering,
--   as these results are needed to perform the test.
reducibility :: NonLocal node => GraphWithDominators node -> Reducibility

-- | Given a graph, return an equivalent reducible graph, by "splitting"
--   (copying) nodes if necessary. The input graph must be bundled with a
--   dominator analysis and a reverse postorder numbering. The computation
--   is monadic because when a node is split, the new copy needs a fresh
--   label.
--   
--   Use this function whenever a downstream algorithm needs a reducible
--   control-flow graph.
asReducible :: GraphWithDominators CmmNode -> UniqSM (GraphWithDominators CmmNode)
instance GHC.Show.Show GHC.Cmm.Reducibility.Reducibility
instance GHC.Classes.Eq GHC.Cmm.Reducibility.Reducibility
instance GHC.Base.Semigroup GHC.Cmm.Reducibility.CmmSuper
instance GHC.Data.Graph.Collapse.PureSupernode GHC.Cmm.Reducibility.CmmSuper
instance GHC.Data.Graph.Collapse.Supernode GHC.Cmm.Reducibility.CmmSuper GHC.Data.Graph.Collapse.NullCollapseViz

module GHC.Cmm.ContFlowOpt
cmmCfgOpts :: Bool -> CmmGraph -> CmmGraph
cmmCfgOptsProc :: Bool -> CmmDecl -> CmmDecl
removeUnreachableBlocksProc :: Platform -> CmmDecl -> CmmDecl
replaceLabels :: LabelMap BlockId -> CmmGraph -> CmmGraph

module GHC.Cmm.CommonBlockElim
elimCommonBlocks :: CmmGraph -> CmmGraph

module GHC.Cmm.CallConv
data ParamLocation
RegisterParam :: GlobalReg -> ParamLocation
StackParam :: ByteOff -> ParamLocation

-- | Given a list of arguments, and a function that tells their types,
--   return a list showing where each argument is passed
assignArgumentsPos :: Profile -> ByteOff -> Convention -> (a -> CmmType) -> [a] -> (ByteOff, [(a, ParamLocation)])
assignStack :: Platform -> ByteOff -> (a -> CmmType) -> [a] -> (ByteOff, [(a, ParamLocation)])
realArgRegsCover :: Platform -> [GlobalReg]
allArgRegsCover :: Platform -> [GlobalReg]
instance GHC.Utils.Outputable.Outputable GHC.Cmm.CallConv.ParamLocation

module GHC.Cmm.Graph

-- | CmmAGraph is a chunk of code consisting of:
--   
--   <ul>
--   <li>ordinary statements (assignments, stores etc.)</li>
--   <li>jumps</li>
--   <li>labels</li>
--   <li>out-of-line labelled blocks</li>
--   </ul>
--   
--   The semantics is that control falls through labels and out-of-line
--   blocks. Everything after a jump up to the next label is by definition
--   unreachable code, and will be discarded.
--   
--   Two CmmAGraphs can be stuck together with <a>*</a>, with the meaning
--   that control flows from the first to the second.
--   
--   A <a>CmmAGraph</a> can be turned into a <a>CmmGraph</a> (closed at
--   both ends) by providing a label for the entry point and a tick scope;
--   see <a>labelAGraph</a>.
type CmmAGraph = OrdList CgStmt

-- | Unlabeled graph with tick scope
type CmmAGraphScoped = (CmmAGraph, CmmTickScope)
data CgStmt
CgLabel :: BlockId -> CmmTickScope -> CgStmt
CgStmt :: CmmNode O O -> CgStmt
CgLast :: CmmNode O C -> CgStmt
CgFork :: BlockId -> CmmAGraph -> CmmTickScope -> CgStmt
(<*>) :: CmmAGraph -> CmmAGraph -> CmmAGraph
catAGraphs :: [CmmAGraph] -> CmmAGraph

-- | creates a sequence "goto id; id:" as an AGraph
mkLabel :: BlockId -> CmmTickScope -> CmmAGraph

-- | creates an open AGraph from a given node
mkMiddle :: CmmNode O O -> CmmAGraph

-- | creates a closed AGraph from a given node
mkLast :: CmmNode O C -> CmmAGraph

-- | A labelled code block; should end in a last node
outOfLine :: BlockId -> CmmAGraphScoped -> CmmAGraph

-- | allocate a fresh label for the entry point
lgraphOfAGraph :: CmmAGraphScoped -> UniqSM CmmGraph

-- | use the given BlockId as the label of the entry point
labelAGraph :: BlockId -> CmmAGraphScoped -> CmmGraph
stackStubExpr :: Width -> CmmExpr
mkNop :: CmmAGraph
mkAssign :: CmmReg -> CmmExpr -> CmmAGraph

-- | Assumes natural alignment
mkStore :: CmmExpr -> CmmExpr -> CmmAGraph
mkUnsafeCall :: ForeignTarget -> [CmmFormal] -> [CmmActual] -> CmmAGraph
mkFinalCall :: Profile -> CmmExpr -> CCallConv -> [CmmExpr] -> UpdFrameOffset -> CmmAGraph
mkCallReturnsTo :: Profile -> CmmExpr -> Convention -> [CmmExpr] -> BlockId -> ByteOff -> UpdFrameOffset -> [CmmExpr] -> CmmAGraph
mkJumpReturnsTo :: Profile -> CmmExpr -> Convention -> [CmmExpr] -> BlockId -> ByteOff -> UpdFrameOffset -> CmmAGraph
mkJump :: Profile -> Convention -> CmmExpr -> [CmmExpr] -> UpdFrameOffset -> CmmAGraph
mkJumpExtra :: Profile -> Convention -> CmmExpr -> [CmmExpr] -> UpdFrameOffset -> [CmmExpr] -> CmmAGraph

-- | A jump where the caller says what the live GlobalRegs are. Used for
--   low-level hand-written Cmm.
mkRawJump :: Profile -> CmmExpr -> UpdFrameOffset -> [GlobalReg] -> CmmAGraph
mkCbranch :: CmmExpr -> BlockId -> BlockId -> Maybe Bool -> CmmAGraph
mkSwitch :: CmmExpr -> SwitchTargets -> CmmAGraph
mkReturn :: Profile -> CmmExpr -> [CmmExpr] -> UpdFrameOffset -> CmmAGraph
mkComment :: FastString -> CmmAGraph
mkCallEntry :: Profile -> Convention -> [CmmFormal] -> [CmmFormal] -> (Int, [GlobalReg], CmmAGraph)
mkBranch :: BlockId -> CmmAGraph

-- | Construct a <a>CmmUnwind</a> node for the given register and unwinding
--   expression.
mkUnwind :: GlobalReg -> CmmExpr -> CmmAGraph
copyInOflow :: Profile -> Convention -> Area -> [CmmFormal] -> [CmmFormal] -> (Int, [GlobalReg], CmmAGraph)
copyOutOflow :: Profile -> Convention -> Transfer -> Area -> [CmmExpr] -> UpdFrameOffset -> [CmmExpr] -> (Int, [GlobalReg], CmmAGraph)
noExtraStack :: [CmmExpr]
toCall :: CmmExpr -> Maybe BlockId -> UpdFrameOffset -> ByteOff -> ByteOff -> [GlobalReg] -> CmmAGraph
data Transfer
Call :: Transfer
JumpRet :: Transfer
Jump :: Transfer
Ret :: Transfer
instance GHC.Classes.Eq GHC.Cmm.Graph.Transfer

module GHC.StgToCmm.Monad
data FCode a
initC :: IO CgState
initFCodeState :: Platform -> FCodeState
runC :: StgToCmmConfig -> FCodeState -> CgState -> FCode a -> (a, CgState)
fixC :: (a -> FCode a) -> FCode a
newUnique :: FCode Unique
emitLabel :: BlockId -> FCode ()
emit :: CmmAGraph -> FCode ()
emitDecl :: CmmDecl -> FCode ()
emitProcWithConvention :: Convention -> Maybe CmmInfoTable -> CLabel -> [CmmFormal] -> CmmAGraphScoped -> FCode ()
emitProcWithStackFrame :: Convention -> Maybe CmmInfoTable -> CLabel -> [CmmFormal] -> [CmmFormal] -> CmmAGraphScoped -> Bool -> FCode ()
emitOutOfLine :: BlockId -> CmmAGraphScoped -> FCode ()
emitAssign :: CmmReg -> CmmExpr -> FCode ()

-- | Assumes natural alignment.
emitStore :: CmmExpr -> CmmExpr -> FCode ()
emitStore' :: AlignmentSpec -> CmmExpr -> CmmExpr -> FCode ()
emitComment :: FastString -> FCode ()
emitTick :: CmmTickish -> FCode ()
emitUnwind :: [(GlobalReg, Maybe CmmExpr)] -> FCode ()
newTemp :: MonadUnique m => CmmType -> m LocalReg
getCmm :: FCode a -> FCode (a, CmmGroup)
aGraphToGraph :: CmmAGraphScoped -> FCode CmmGraph
getPlatform :: FCode Platform
getProfile :: FCode Profile
getCodeR :: FCode a -> FCode (a, CmmAGraph)
getCode :: FCode a -> FCode CmmAGraph

-- | Generate code into a fresh tick (sub-)scope and gather generated code
getCodeScoped :: FCode a -> FCode (a, CmmAGraphScoped)
getHeapUsage :: (VirtualHpOffset -> FCode a) -> FCode a
getContext :: FCode SDocContext
mkCmmIfThenElse :: CmmExpr -> CmmAGraph -> CmmAGraph -> FCode CmmAGraph
mkCmmIfThen :: CmmExpr -> CmmAGraph -> FCode CmmAGraph
mkCmmIfGoto :: CmmExpr -> BlockId -> FCode CmmAGraph
mkCmmIfThenElse' :: CmmExpr -> CmmAGraph -> CmmAGraph -> Maybe Bool -> FCode CmmAGraph
mkCmmIfThen' :: CmmExpr -> CmmAGraph -> Maybe Bool -> FCode CmmAGraph
mkCmmIfGoto' :: CmmExpr -> BlockId -> Maybe Bool -> FCode CmmAGraph
mkCall :: CmmExpr -> (Convention, Convention) -> [CmmFormal] -> [CmmExpr] -> UpdFrameOffset -> [CmmExpr] -> FCode CmmAGraph
mkCmmCall :: CmmExpr -> [CmmFormal] -> [CmmExpr] -> UpdFrameOffset -> FCode CmmAGraph
forkClosureBody :: FCode () -> FCode ()
forkLneBody :: FCode a -> FCode a
forkAlts :: [FCode a] -> FCode [a]
forkAltPair :: FCode a -> FCode a -> FCode (a, a)
codeOnly :: FCode () -> FCode ()

-- | A *zero-indexed* constructor tag
type ConTagZ = Int

-- | A Sequel tells what to do with the result of this expression
data Sequel

-- | Return result(s) to continuation found on the stack.
Return :: Sequel
AssignTo :: [LocalReg] -> Bool -> Sequel
data ReturnKind
AssignedDirectly :: ReturnKind
ReturnedTo :: BlockId -> ByteOff -> ReturnKind
withSequel :: Sequel -> FCode a -> FCode a
getSequel :: FCode Sequel
data SelfLoopInfo
MkSelfLoopInfo :: !Id -> !RepArity -> ![LocalReg] -> !BlockId -> SelfLoopInfo
[sli_id] :: SelfLoopInfo -> !Id

-- | always equal to <a>idFunRepArity</a> of sli_id, i.e. unarised arity,
--   including void arguments
[sli_arity] :: SelfLoopInfo -> !RepArity

-- | Excludes void arguments (LocalReg is never void)
[sli_registers] :: SelfLoopInfo -> ![LocalReg]
[sli_header_block] :: SelfLoopInfo -> !BlockId
setTickyCtrLabel :: CLabel -> FCode a -> FCode a
getTickyCtrLabel :: FCode CLabel

-- | Places blocks generated by the given code into a fresh (sub-)scope.
--   This will make sure that Cmm annotations in our scope will apply to
--   the Cmm blocks generated therein - but not the other way around.
tickScope :: FCode a -> FCode a

-- | The current tick scope. We will assign this to generated blocks.
getTickScope :: FCode CmmTickScope
withUpdFrameOff :: UpdFrameOffset -> FCode a -> FCode a
getUpdFrameOff :: FCode UpdFrameOffset
data HeapUsage
HeapUsage :: VirtualHpOffset -> VirtualHpOffset -> HeapUsage
[virtHp] :: HeapUsage -> VirtualHpOffset
[realHp] :: HeapUsage -> VirtualHpOffset
type VirtualHpOffset = WordOff
initHpUsage :: HeapUsage
getHpUsage :: FCode HeapUsage
setHpUsage :: HeapUsage -> FCode ()
heapHWM :: HeapUsage -> VirtualHpOffset
setVirtHp :: VirtualHpOffset -> FCode ()
getVirtHp :: FCode VirtualHpOffset
setRealHp :: VirtualHpOffset -> FCode ()
getModuleName :: FCode Module
getState :: FCode CgState
setState :: CgState -> FCode ()
getSelfLoop :: FCode (Maybe SelfLoopInfo)
withSelfLoop :: SelfLoopInfo -> FCode a -> FCode a
getStgToCmmConfig :: FCode StgToCmmConfig
data CgIdInfo
CgIdInfo :: Id -> LambdaFormInfo -> CgLoc -> CgIdInfo

-- | Id that this is the info for
[cg_id] :: CgIdInfo -> Id
[cg_lf] :: CgIdInfo -> LambdaFormInfo

-- | <a>CmmExpr</a> for the *tagged* value
[cg_loc] :: CgIdInfo -> CgLoc
getBinds :: FCode CgBindings
setBinds :: CgBindings -> FCode ()
data StgToCmmConfig
StgToCmmConfig :: !Profile -> Module -> !TempDir -> !SDocContext -> !Bool -> !Maybe Word -> !Int -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> Maybe String -> !Bool -> !Bool -> !Bool -> StgToCmmConfig

-- | Current profile
[stgToCmmProfile] :: StgToCmmConfig -> !Profile

-- | The module being compiled. This field kept lazy for Cmm/Parser.y which
--   preloads it with a panic
[stgToCmmThisModule] :: StgToCmmConfig -> Module

-- | Temp Dir for files used in compilation
[stgToCmmTmpDir] :: StgToCmmConfig -> !TempDir

-- | Context for StgToCmm phase
[stgToCmmContext] :: StgToCmmConfig -> !SDocContext

-- | Whether we wish to output debug information
[stgToCmmEmitDebugInfo] :: StgToCmmConfig -> !Bool

-- | Threshold at which Binary literals (e.g. strings) are either dumped to
--   a file and a CmmFileEmbed literal is emitted (over threshold), or
--   become a CmmString Literal (under or at threshold). CmmFileEmbed is
--   only supported with the NCG, thus a Just means two things: We have a
--   threshold, and will be using the NCG. Conversely, a Nothing implies we
--   are not using NCG and disables CmmFileEmbed. See Note [Embedding large
--   binary blobs] in GHC.CmmToAsm.Ppr, and <tt>cgTopBinding</tt> in
--   GHC.StgToCmm.
[stgToCmmBinBlobThresh] :: StgToCmmConfig -> !Maybe Word

-- | Max size, in bytes, of inline array allocations.
[stgToCmmMaxInlAllocSize] :: StgToCmmConfig -> !Int

-- | Ticky profiling enabled (cf <tt>-ticky</tt>)
[stgToCmmDoTicky] :: StgToCmmConfig -> !Bool

-- | True indicates ticky prof traces allocs of each named thing in
--   addition to allocs _by_ that thing
[stgToCmmTickyAllocd] :: StgToCmmConfig -> !Bool

-- | True indicates ticky uses name-specific counters for join-points
--   (let-no-escape)
[stgToCmmTickyLNE] :: StgToCmmConfig -> !Bool

-- | True indicates ticky uses name-specific counters for dynamic thunks
[stgToCmmTickyDynThunk] :: StgToCmmConfig -> !Bool

-- | True indicates ticky will count number of avoided tag checks by tag
--   inference.
[stgToCmmTickyTag] :: StgToCmmConfig -> !Bool

-- | Loopification enabled (cf <tt>-floopification</tt>)
[stgToCmmLoopification] :: StgToCmmConfig -> !Bool

-- | Insert alignment check (cf <tt>-falignment-sanitisation</tt>)
[stgToCmmAlignCheck] :: StgToCmmConfig -> !Bool

-- | perform code generation for code coverage
[stgToCmmOptHpc] :: StgToCmmConfig -> !Bool
[stgToCmmFastPAPCalls] :: StgToCmmConfig -> !Bool

-- | Check if cost-centre profiling is enabled
[stgToCmmSCCProfiling] :: StgToCmmConfig -> !Bool
[stgToCmmEagerBlackHole] :: StgToCmmConfig -> !Bool

-- | true means generate C Stub for IPE map, See Note [Mapping Info Tables
--   to Source Positions]
[stgToCmmInfoTableMap] :: StgToCmmConfig -> !Bool

-- | Include info tables with fallback source locations in the info table
--   map
[stgToCmmInfoTableMapWithFallback] :: StgToCmmConfig -> !Bool

-- | Include info tables for STACK closures in the info table map
[stgToCmmInfoTableMapWithStack] :: StgToCmmConfig -> !Bool

-- | true means omit heap checks when no allocation is performed
[stgToCmmOmitYields] :: StgToCmmConfig -> !Bool

-- | true means don't generate interface programs (implied by -O0)
[stgToCmmOmitIfPragmas] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fPIC</tt>
[stgToCmmPIC] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fPIE</tt>
[stgToCmmPIE] :: StgToCmmConfig -> !Bool

-- | true if <tt>-fexternal-dynamic-refs</tt>, meaning generate code for
--   linking against dynamic libraries
[stgToCmmExtDynRefs] :: StgToCmmConfig -> !Bool

-- | decides whether to check array bounds in StgToCmm.Prim or not
[stgToCmmDoBoundsCheck] :: StgToCmmConfig -> !Bool

-- | Verify tag inference predictions.
[stgToCmmDoTagCheck] :: StgToCmmConfig -> !Bool

-- | Allowed to emit larger than native size arithmetic (only LLVM and C
--   backends)
[stgToCmmAllowBigArith] :: StgToCmmConfig -> !Bool

-- | Allowed to generate QuotRem instructions
[stgToCmmAllowQuotRemInstr] :: StgToCmmConfig -> !Bool

-- | Allowed to generate QuotRem
[stgToCmmAllowQuotRem2] :: StgToCmmConfig -> !Bool

-- | Allowed to generate AddWordC, SubWordC, Add2, etc.
[stgToCmmAllowExtendedAddSubInstrs] :: StgToCmmConfig -> !Bool

-- | Allowed to generate IntMul2 instruction
[stgToCmmAllowIntMul2Instr] :: StgToCmmConfig -> !Bool

-- | Disable use of precomputed standard thunks.
[stgToCmmTickyAP] :: StgToCmmConfig -> !Bool

-- | Error (if any) to raise when vector instructions are used, see
--   <tt>StgToCmm.Prim.checkVecCompatibility</tt>
[stgToCmmVecInstrsErr] :: StgToCmmConfig -> Maybe String

-- | check for Advanced Vector Extensions
[stgToCmmAvx] :: StgToCmmConfig -> !Bool

-- | check for Advanced Vector Extensions 2
[stgToCmmAvx2] :: StgToCmmConfig -> !Bool

-- | check for Advanced Vector 512-bit Extensions
[stgToCmmAvx512f] :: StgToCmmConfig -> !Bool
data CgState
MkCgState :: CmmAGraph -> OrdList CmmDecl -> CgBindings -> HeapUsage -> UniqSupply -> CgState
[cgs_stmts] :: CgState -> CmmAGraph
[cgs_tops] :: CgState -> OrdList CmmDecl
[cgs_binds] :: CgState -> CgBindings
[cgs_hp_usg] :: CgState -> HeapUsage
[cgs_uniqs] :: CgState -> UniqSupply
instance GHC.Base.Functor GHC.StgToCmm.Monad.FCode
instance GHC.Base.Applicative GHC.StgToCmm.Monad.FCode
instance GHC.Base.Monad GHC.StgToCmm.Monad.FCode
instance GHC.Types.Unique.Supply.MonadUnique GHC.StgToCmm.Monad.FCode
instance GHC.Utils.Outputable.OutputableP GHC.Platform.Platform GHC.StgToCmm.Monad.CgIdInfo


-- | Our extended FCode monad.
module GHC.StgToCmm.ExtCode

-- | Does a computation in the FCode monad, with a current environment and
--   a list of local declarations. Returns the resulting list of
--   declarations.
data CmmParse a
unEC :: CmmParse a -> String -> Env -> Decls -> FCode (Decls, a)

-- | The environment contains variable definitions or blockids.
data Named

-- | Holds CmmLit(CmmLabel ..) which gives the label type, eg, RtsLabel,
--   ForeignLabel, CmmLabel etc.
VarN :: CmmExpr -> Named

-- | A function name from this unit
FunN :: UnitId -> Named

-- | A blockid of some code or data.
LabelN :: BlockId -> Named

-- | An environment of named things.
type Env = UniqFM FastString Named

-- | Takes the variable declarations and imports from the monad and makes
--   an environment, which is looped back into the computation. In this
--   way, we can have embedded declarations that scope over the whole
--   procedure, and imports that scope over the entire module. Discards the
--   local declaration contained within decl'
loopDecls :: CmmParse a -> CmmParse a

-- | Get the current environment from the monad.
getEnv :: CmmParse Env

-- | Set context name for a sub-parse
withName :: String -> CmmParse a -> CmmParse a

-- | Get the current context name from the monad
getName :: CmmParse String

-- | Create a fresh local variable of a given type.
newLocal :: CmmType -> FastString -> CmmParse LocalReg

-- | Allocate a fresh label.
newLabel :: FastString -> CmmParse BlockId
newBlockId :: MonadUnique m => m BlockId

-- | Add a local function to the environment.
newFunctionName :: FastString -> UnitId -> ExtCode

-- | Add an imported foreign label to the list of local declarations. If
--   this is done at the start of the module the declaration will scope
--   over the whole module.
newImport :: (FastString, CLabel) -> CmmParse ()

-- | Lookup the BlockId bound to the label with this name. If one hasn't
--   been bound yet, create a fresh one based on the Unique of the name.
lookupLabel :: FastString -> CmmParse BlockId

-- | Lookup the location of a named variable. Unknown names are treated as
--   if they had been 'import'ed from the runtime system. This saves us a
--   lot of bother in the RTS sources, at the expense of deferring some
--   errors to link time.
lookupName :: FastString -> CmmParse CmmExpr

-- | Lift an FCode computation into the CmmParse monad
code :: FCode a -> CmmParse a
emit :: CmmAGraph -> CmmParse ()
emitLabel :: BlockId -> CmmParse ()
emitAssign :: CmmReg -> CmmExpr -> CmmParse ()
emitStore :: Maybe MemoryOrdering -> CmmExpr -> CmmExpr -> CmmParse ()
getCode :: CmmParse a -> CmmParse CmmAGraph
getCodeR :: CmmParse a -> CmmParse (a, CmmAGraph)
getCodeScoped :: CmmParse a -> CmmParse (a, CmmAGraphScoped)
emitOutOfLine :: BlockId -> CmmAGraphScoped -> CmmParse ()
withUpdFrameOff :: UpdFrameOffset -> CmmParse () -> CmmParse ()
getUpdFrameOff :: CmmParse UpdFrameOffset
getProfile :: CmmParse Profile
getPlatform :: CmmParse Platform
getContext :: CmmParse SDocContext
instance GHC.Base.Functor GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Base.Applicative GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Base.Monad GHC.StgToCmm.ExtCode.CmmParse
instance GHC.Types.Unique.Supply.MonadUnique GHC.StgToCmm.ExtCode.CmmParse

module GHC.StgToCmm.Env
data CgIdInfo
litIdInfo :: Platform -> Id -> LambdaFormInfo -> CmmLit -> CgIdInfo
lneIdInfo :: Platform -> Id -> [NonVoid Id] -> CgIdInfo
rhsIdInfo :: Id -> LambdaFormInfo -> FCode (CgIdInfo, LocalReg)
mkRhsInit :: Platform -> LocalReg -> LambdaFormInfo -> CmmExpr -> CmmAGraph

-- | Returns a <a>CmmExpr</a> for the *tagged* pointer
idInfoToAmode :: CgIdInfo -> CmmExpr
addBindC :: CgIdInfo -> FCode ()
addBindsC :: [CgIdInfo] -> FCode ()
bindArgsToRegs :: [NonVoid Id] -> FCode [LocalReg]
bindToReg :: NonVoid Id -> LambdaFormInfo -> FCode LocalReg
rebindToReg :: NonVoid Id -> FCode LocalReg
bindArgToReg :: NonVoid Id -> FCode LocalReg
idToReg :: Platform -> NonVoid Id -> LocalReg
getCgIdInfo :: Id -> FCode CgIdInfo

-- | Retrieve cg info for a name if it already exists.
getCgInfo_maybe :: Name -> FCode (Maybe CgIdInfo)
maybeLetNoEscape :: CgIdInfo -> Maybe (BlockId, [LocalReg])

module GHC.StgToCmm.Lit
cgLit :: Literal -> FCode CmmExpr
mkSimpleLit :: Platform -> Literal -> CmmLit

-- | Make a global definition for the string, and return its label
newStringCLit :: String -> FCode CmmLit
newByteStringCLit :: ByteString -> FCode CmmLit

module GHC.StgToCmm.Utils

-- | Emit a data-segment data block
emitDataLits :: CLabel -> [CmmLit] -> FCode ()

-- | Emit a read-only data block
emitRODataLits :: CLabel -> [CmmLit] -> FCode ()
emitDataCon :: CLabel -> CmmInfoTable -> CostCentreStack -> [CmmLit] -> FCode ()
emitRtsCall :: UnitId -> FastString -> [(CmmExpr, ForeignHint)] -> Bool -> FCode ()
emitRtsCallWithResult :: LocalReg -> ForeignHint -> UnitId -> FastString -> [(CmmExpr, ForeignHint)] -> Bool -> FCode ()
emitRtsCallGen :: [(LocalReg, ForeignHint)] -> CLabel -> [(CmmExpr, ForeignHint)] -> Bool -> FCode ()
emitBarf :: String -> FCode ()
assignTemp :: CmmExpr -> FCode LocalReg
newTemp :: MonadUnique m => CmmType -> m LocalReg
newUnboxedTupleRegs :: Type -> FCode ([LocalReg], [ForeignHint])
emitMultiAssign :: [LocalReg] -> [CmmExpr] -> FCode ()
emitCmmLitSwitch :: CmmExpr -> [(Literal, CmmAGraphScoped)] -> CmmAGraphScoped -> FCode ()
emitSwitch :: CmmExpr -> [(ConTagZ, CmmAGraphScoped)] -> Maybe CmmAGraphScoped -> ConTagZ -> ConTagZ -> FCode ()
tagToClosure :: Platform -> TyCon -> CmmExpr -> CmmExpr
mkTaggedObjectLoad :: Platform -> LocalReg -> LocalReg -> ByteOff -> DynTag -> CmmAGraph

-- | Returns <a>True</a> if this global register is stored in a
--   caller-saves machine register.
callerSaves :: Platform -> GlobalReg -> Bool
callerSaveVolatileRegs :: Platform -> (CmmAGraph, CmmAGraph)

-- | We map STG registers onto appropriate CmmExprs. Either they map to
--   real machine registers or stored as offsets from BaseReg. Given a
--   GlobalReg, get_GlobalReg_addr always produces the register table
--   address for it.
get_GlobalReg_addr :: Platform -> GlobalReg -> CmmExpr
callerSaveGlobalReg :: Platform -> GlobalReg -> CmmAGraph
callerRestoreGlobalReg :: Platform -> GlobalReg -> CmmAGraph
cmmAndWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmNegate :: Platform -> CmmExpr -> CmmExpr
cmmEqWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmNeWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUGtWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmSubWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmMulWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmAddWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmUShrWord :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOffsetExprW :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmOffsetExprB :: Platform -> CmmExpr -> CmmExpr -> CmmExpr
cmmRegOffW :: Platform -> CmmReg -> WordOff -> CmmExpr
cmmRegOffB :: CmmReg -> ByteOff -> CmmExpr
cmmLabelOffW :: Platform -> CLabel -> WordOff -> CmmLit
cmmLabelOffB :: CLabel -> ByteOff -> CmmLit
cmmOffsetW :: Platform -> CmmExpr -> WordOff -> CmmExpr
cmmOffsetB :: Platform -> CmmExpr -> ByteOff -> CmmExpr
cmmOffsetLitW :: Platform -> CmmLit -> WordOff -> CmmLit
cmmOffsetLitB :: CmmLit -> ByteOff -> CmmLit
cmmLoadIndexW :: Platform -> CmmExpr -> Int -> CmmType -> CmmExpr
cmmConstrTag1 :: Platform -> CmmExpr -> CmmExpr
cmmUntag :: Platform -> CmmExpr -> CmmExpr
cmmIsTagged :: Platform -> CmmExpr -> CmmExpr

-- | <tt>addToMem rep ptr n</tt> adds <tt>n</tt> to the integer pointed-to
--   by <tt>ptr</tt>.
addToMem :: CmmType -> CmmExpr -> Int -> CmmAGraph

-- | <tt>addToMemE rep ptr n</tt> adds <tt>n</tt> to the integer pointed-to
--   by <tt>ptr</tt>.
addToMemE :: CmmType -> CmmExpr -> CmmExpr -> CmmAGraph
addToMemLblE :: CmmType -> CLabel -> CmmExpr -> CmmAGraph
addToMemLbl :: CmmType -> CLabel -> Int -> CmmAGraph
whenUpdRemSetEnabled :: FCode a -> FCode ()

-- | Emit code to add an entry to a now-overwritten pointer to the update
--   remembered set.
emitUpdRemSetPush :: CmmExpr -> FCode ()
emitUpdRemSetPushThunk :: CmmExpr -> FCode ()

-- | Convert source information collected about identifiers in <a>Debug</a>
--   to entries suitable for placing into the info table provenance table.
--   
--   The initial stats given to this function will (or should) only contain
--   stats for stack info tables skipped during <tt>generateCgIPEStub</tt>.
--   As the fold progresses, counts of tables per closure type will be
--   accumulated.
convertInfoProvMap :: StgToCmmConfig -> Module -> InfoTableProvMap -> IPEStats -> [CmmInfoTable] -> (IPEStats, [InfoProvEnt])

-- | A bare bones InfoProvEnt for things which don't have a good source
--   location
cmmInfoTableToInfoProvEnt :: Module -> CmmInfoTable -> InfoProvEnt
data IPEStats
IPEStats :: !Int -> !IntMap Int -> !Int -> !Int -> IPEStats
[ipe_total] :: IPEStats -> !Int
[ipe_closure_types] :: IPEStats -> !IntMap Int
[ipe_fallback] :: IPEStats -> !Int
[ipe_skipped] :: IPEStats -> !Int
closureIpeStats :: Int -> IPEStats
fallbackIpeStats :: IPEStats
skippedIpeStats :: IPEStats
instance GHC.Base.Semigroup GHC.StgToCmm.Utils.IPEStats
instance GHC.Base.Monoid GHC.StgToCmm.Utils.IPEStats
instance GHC.Utils.Outputable.Outputable GHC.StgToCmm.Utils.IPEStats

module GHC.StgToCmm.TagCheck

-- | Call barf if we failed to predict a tag correctly. This is immensely
--   useful when debugging issues in tag inference as it will result in a
--   program abort when we encounter an invalid call/heap object, rather
--   than leaving it be and segfaulting arbitrary or producing invalid
--   results. We check if either: * A tag is present * Or the object is a
--   25 (for which zero is the proper tag)
emitTagAssertion :: String -> CmmExpr -> FCode ()
emitArgTagCheck :: SDoc -> [CbvMark] -> [Id] -> FCode ()
checkArg :: SDoc -> CbvMark -> StgArg -> FCode ()
whenCheckTags :: FCode () -> FCode ()
checkArgStatic :: SDoc -> StrictnessMark -> StgArg -> FCode ()

-- | Check all arguments marked as cbv for the presence of a tag *at
--   runtime*.
checkFunctionArgTags :: SDoc -> Id -> [Id] -> FCode ()

-- | Check all required-tagged arguments of a constructor are tagged *at
--   compile time*.
checkConArgsStatic :: SDoc -> DataCon -> [StgArg] -> FCode ()
checkConArgsDyn :: SDoc -> DataCon -> [StgArg] -> FCode ()

module GHC.StgToCmm.Hpc

-- | Emit top-level tables for HPC and return code to initialise
initHpc :: Module -> HpcInfo -> FCode ()
mkTickBox :: Platform -> Module -> Int -> CmmAGraph


-- | Annotate a CmmGraph with ThreadSanitizer instrumentation calls.
module GHC.Cmm.ThreadSanitizer
annotateTSAN :: Platform -> CmmGraph -> UniqSM CmmGraph

module GHC.StgToCmm.Ticky
withNewTickyCounterFun :: Bool -> Id -> [NonVoid Id] -> [NonVoid Id] -> FCode a -> FCode a
withNewTickyCounterLNE :: Id -> [NonVoid Id] -> FCode a -> FCode a
withNewTickyCounterThunk :: Bool -> Bool -> Id -> [NonVoid Id] -> FCode a -> FCode a
withNewTickyCounterStdThunk :: Bool -> Id -> [StgArg] -> FCode a -> FCode a
withNewTickyCounterCon :: Id -> DataCon -> ConstructorNumber -> FCode a -> FCode a
emitTickyCounterTag :: Unique -> NonVoid Id -> FCode CLabel
tickyDynAlloc :: Maybe Id -> SMRep -> LambdaFormInfo -> FCode ()
tickyAllocHeap :: Bool -> VirtualHpOffset -> FCode ()
tickyAllocPrim :: CmmExpr -> CmmExpr -> CmmExpr -> FCode ()
tickyAllocThunk :: CmmExpr -> CmmExpr -> FCode ()
tickyAllocPAP :: CmmExpr -> CmmExpr -> FCode ()
tickyHeapCheck :: FCode ()
tickyStackCheck :: FCode ()
tickyDirectCall :: RepArity -> [StgArg] -> FCode ()
tickyPushUpdateFrame :: FCode ()
tickyUpdateFrameOmitted :: FCode ()
tickyEnterDynCon :: FCode ()
tickyEnterFun :: ClosureInfo -> FCode ()
tickyEnterThunk :: ClosureInfo -> FCode ()
tickyEnterLNE :: FCode ()
tickyUpdateBhCaf :: ClosureInfo -> FCode ()
tickyUnboxedTupleReturn :: RepArity -> FCode ()
tickyReturnOldCon :: RepArity -> FCode ()
tickyReturnNewCon :: RepArity -> FCode ()
tickyKnownCallTooFewArgs :: FCode ()
tickyKnownCallExact :: FCode ()
tickyKnownCallExtraArgs :: FCode ()
tickySlowCall :: LambdaFormInfo -> [StgArg] -> FCode ()
tickySlowCallPat :: [PrimRep] -> FCode ()

-- | Predicted a pointer would be tagged correctly (GHC will crash if not
--   so no miss case)
tickyTagged :: FCode ()

-- | Pass a boolean expr indicating if tag was present.
tickyUntagged :: CmmExpr -> FCode ()

-- | Called when for `case v of ...` we can avoid entering v based on tag
--   inference information.
tickyTagSkip :: Unique -> Id -> FCode ()
instance GHC.Utils.Json.ToJson GHC.StgToCmm.Ticky.TickyClosureType

module GHC.StgToCmm.InfoTableProv
emitIpeBufferListNode :: Module -> [InfoProvEnt] -> FCode ()

module GHC.StgToCmm.Layout
mkArgDescr :: Platform -> [Id] -> ArgDescr

-- | <tt>emitCall conv fun args</tt> makes a call to the entry-code of
--   <tt>fun</tt>, using the call/return convention <tt>conv</tt>, passing
--   <tt>args</tt>, and returning the results to the current sequel.
emitCall :: (Convention, Convention) -> CmmExpr -> [CmmExpr] -> FCode ReturnKind

-- | Return multiple values to the sequel
--   
--   If the sequel is <tt>Return</tt>
--   
--   <pre>
--   return (x,y)
--   </pre>
--   
--   If the sequel is <tt>AssignTo [p,q]</tt>
--   
--   <pre>
--   p=x; q=y;
--   </pre>
emitReturn :: [CmmExpr] -> FCode ReturnKind
adjustHpBackwards :: FCode ()
emitClosureProcAndInfoTable :: Bool -> Id -> LambdaFormInfo -> CmmInfoTable -> [NonVoid Id] -> ((Int, LocalReg, [LocalReg]) -> FCode ()) -> FCode ()
emitClosureAndInfoTable :: Platform -> CmmInfoTable -> Convention -> [LocalReg] -> FCode () -> FCode ()
slowCall :: CmmExpr -> [StgArg] -> FCode ReturnKind
directCall :: Convention -> CLabel -> RepArity -> [StgArg] -> FCode ReturnKind
data FieldOffOrPadding a
FieldOff :: NonVoid a -> ByteOff -> FieldOffOrPadding a
Padding :: ByteOff -> ByteOff -> FieldOffOrPadding a

-- | Used to tell the various <tt>mkVirtHeapOffsets</tt> functions what
--   kind of header the object has. This will be accounted for in the
--   offsets of the fields returned.
data ClosureHeader
NoHeader :: ClosureHeader
StdHeader :: ClosureHeader
ThunkHeader :: ClosureHeader
mkVirtHeapOffsets :: Profile -> ClosureHeader -> [NonVoid (PrimRep, a)] -> (WordOff, WordOff, [(NonVoid a, ByteOff)])
mkVirtHeapOffsetsWithPadding :: Profile -> ClosureHeader -> [NonVoid (PrimRep, a)] -> (WordOff, WordOff, [FieldOffOrPadding a])

-- | Just like mkVirtHeapOffsets, but for constructors
mkVirtConstrOffsets :: Profile -> [NonVoid (PrimRep, a)] -> (WordOff, WordOff, [(NonVoid a, ByteOff)])

-- | Just like mkVirtConstrOffsets, but used when we don't have the actual
--   arguments. Useful when e.g. generating info tables; we just need to
--   know sizes of pointer and non-pointer fields.
mkVirtConstrSizes :: Profile -> [NonVoid PrimRep] -> (WordOff, WordOff)
getHpRelOffset :: VirtualHpOffset -> FCode CmmExpr
data ArgRep
P :: ArgRep
N :: ArgRep
L :: ArgRep
V :: ArgRep
F :: ArgRep
D :: ArgRep
V16 :: ArgRep
V32 :: ArgRep
V64 :: ArgRep
toArgRep :: Platform -> PrimRep -> ArgRep
argRepSizeW :: Platform -> ArgRep -> WordOff
getArgAmode :: NonVoid StgArg -> FCode CmmExpr
getNonVoidArgAmodes :: [StgArg] -> FCode [CmmExpr]


-- | Provides the heuristics for when it's beneficial to lambda lift
--   bindings. Most significantly, this employs a cost model to estimate
--   impact on heap allocations, by looking at an STG expression's
--   <a>Skeleton</a>.
module GHC.Stg.Lift.Analysis

-- | Captures details of the syntax tree relevant to the cost model, such
--   as closures, multi-shot lambdas and case expressions.
data Skeleton
ClosureSk :: !Id -> !DIdSet -> !Skeleton -> Skeleton
RhsSk :: !Card -> !Skeleton -> Skeleton
AltSk :: !Skeleton -> !Skeleton -> Skeleton
BothSk :: !Skeleton -> !Skeleton -> Skeleton
NilSk :: Skeleton

-- | The type used in binder positions in <a>GenStgExpr</a>s.
data BinderInfo

-- | Let(-no-escape)-bound thing with a flag indicating whether it occurs
--   as an argument or in a nullary application (see
--   <a>GHC.Stg.Lift.Analysis#arg_occs</a>).
BindsClosure :: !Id -> !Bool -> BinderInfo

-- | Every other kind of binder
BoringBinder :: !Id -> BinderInfo

-- | Gets the bound <a>Id</a> out a <a>BinderInfo</a>.
binderInfoBndr :: BinderInfo -> Id
type LlStgBinding = GenStgBinding 'LiftLams
type LlStgExpr = GenStgExpr 'LiftLams
type LlStgRhs = GenStgRhs 'LiftLams
type LlStgAlt = GenStgAlt 'LiftLams

-- | Tags every binder with its <a>BinderInfo</a> and let bindings with
--   their <a>Skeleton</a>s.
tagSkeletonTopBind :: CgStgBinding -> LlStgBinding

-- | Combines several heuristics to decide whether to lambda-lift a given
--   <tt>let</tt>-binding to top-level. See
--   <a>GHC.Stg.Lift.Analysis#when</a> for details.
goodToLift :: StgLiftConfig -> TopLevelFlag -> RecFlag -> (DIdSet -> DIdSet) -> [(BinderInfo, LlStgRhs)] -> Skeleton -> Maybe DIdSet

-- | <tt>closureGrowth expander sizer f fvs</tt> computes the closure
--   growth in words as a result of lifting <tt>f</tt> to top-level. If
--   there was any growing closure under a multi-shot lambda, the result
--   will be <a>infinity</a>. Also see <a>GHC.Stg.Lift.Analysis#clogro</a>.
closureGrowth :: (DIdSet -> DIdSet) -> (Id -> Int) -> IdSet -> DIdSet -> Skeleton -> IntWithInf
instance GHC.Utils.Outputable.Outputable GHC.Stg.Lift.Analysis.BinderInfo
instance GHC.Utils.Outputable.OutputableBndr GHC.Stg.Lift.Analysis.BinderInfo
instance GHC.Utils.Outputable.Outputable GHC.Stg.Lift.Analysis.Skeleton


-- | Implements a selective lambda lifter, running late in the optimisation
--   pipeline.
--   
--   If you are interested in the cost model that is employed to decide
--   whether to lift a binding or not, look at
--   <a>GHC.Stg.Lift.Analysis</a>. <a>GHC.Stg.Lift.Monad</a> contains the
--   transformation monad that hides away some plumbing of the
--   transformation.
module GHC.Stg.Lift
data StgLiftConfig
StgLiftConfig :: !Profile -> !Maybe Int -> !Maybe Int -> !Bool -> StgLiftConfig
[c_targetProfile] :: StgLiftConfig -> !Profile

-- | Maximum number of arguments after lambda lifting a recursive function.
[c_liftLamsRecArgs] :: StgLiftConfig -> !Maybe Int

-- | Maximum number of arguments after lambda lifting non-recursive
--   function.
[c_liftLamsNonRecArgs] :: StgLiftConfig -> !Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[c_liftLamsKnown] :: StgLiftConfig -> !Bool

-- | Lambda lifts bindings to top-level deemed worth lifting (see
--   <a>goodToLift</a>).
--   
--   (Mostly) textbook instance of the lambda lifting transformation,
--   selecting which bindings to lambda lift by consulting
--   <a>goodToLift</a>.
stgLiftLams :: Module -> StgLiftConfig -> UniqSupply -> [InStgTopBinding] -> [OutStgTopBinding]


-- | Bytecode assembler types
module GHC.ByteCode.Types
data CompiledByteCode
CompiledByteCode :: [UnlinkedBCO] -> ItblEnv -> [FFIInfo] -> AddrEnv -> Maybe ModBreaks -> CompiledByteCode
[bc_bcos] :: CompiledByteCode -> [UnlinkedBCO]
[bc_itbls] :: CompiledByteCode -> ItblEnv
[bc_ffis] :: CompiledByteCode -> [FFIInfo]
[bc_strs] :: CompiledByteCode -> AddrEnv
[bc_breaks] :: CompiledByteCode -> Maybe ModBreaks
seqCompiledByteCode :: CompiledByteCode -> ()
newtype FFIInfo
FFIInfo :: RemotePtr C_ffi_cif -> FFIInfo
newtype RegBitmap
RegBitmap :: Word32 -> RegBitmap
[unRegBitmap] :: RegBitmap -> Word32
data NativeCallType
NativePrimCall :: NativeCallType
NativeTupleReturn :: NativeCallType
data NativeCallInfo
NativeCallInfo :: !NativeCallType -> !WordOff -> !GlobalRegSet -> !WordOff -> NativeCallInfo
[nativeCallType] :: NativeCallInfo -> !NativeCallType
[nativeCallSize] :: NativeCallInfo -> !WordOff
[nativeCallRegs] :: NativeCallInfo -> !GlobalRegSet
[nativeCallStackSpillSize] :: NativeCallInfo -> !WordOff
voidTupleReturnInfo :: NativeCallInfo
voidPrimCallInfo :: NativeCallInfo
newtype ByteOff
ByteOff :: Int -> ByteOff
newtype WordOff
WordOff :: Int -> WordOff
data UnlinkedBCO
UnlinkedBCO :: !Name -> {-# UNPACK #-} !Int -> !UArray Int Word16 -> !UArray Int Word64 -> !SizedSeq BCONPtr -> !SizedSeq BCOPtr -> UnlinkedBCO
[unlinkedBCOName] :: UnlinkedBCO -> !Name
[unlinkedBCOArity] :: UnlinkedBCO -> {-# UNPACK #-} !Int
[unlinkedBCOInstrs] :: UnlinkedBCO -> !UArray Int Word16
[unlinkedBCOBitmap] :: UnlinkedBCO -> !UArray Int Word64
[unlinkedBCOLits] :: UnlinkedBCO -> !SizedSeq BCONPtr
[unlinkedBCOPtrs] :: UnlinkedBCO -> !SizedSeq BCOPtr
data BCOPtr
BCOPtrName :: !Name -> BCOPtr
BCOPtrPrimOp :: !PrimOp -> BCOPtr
BCOPtrBCO :: !UnlinkedBCO -> BCOPtr
BCOPtrBreakArray :: BCOPtr
data BCONPtr
BCONPtrWord :: {-# UNPACK #-} !Word -> BCONPtr
BCONPtrLbl :: !FastString -> BCONPtr
BCONPtrItbl :: !Name -> BCONPtr

-- | A reference to a top-level string literal; see Note [Generating code
--   for top-level string literal bindings] in GHC.StgToByteCode.
BCONPtrAddr :: !Name -> BCONPtr

-- | Only used internally in the assembler in an intermediate
--   representation; should never appear in a fully-assembled UnlinkedBCO.
--   Also see Note [Allocating string literals] in GHC.ByteCode.Asm.
BCONPtrStr :: !ByteString -> BCONPtr
type ItblEnv = NameEnv (Name, ItblPtr)
newtype ItblPtr
ItblPtr :: RemotePtr StgInfoTable -> ItblPtr
type AddrEnv = NameEnv (Name, AddrPtr)
newtype AddrPtr
AddrPtr :: RemotePtr () -> AddrPtr

-- | Information about a breakpoint that we know at code-generation time In
--   order to be used, this needs to be hydrated relative to the current
--   HscEnv by <tt>hydrateCgBreakInfo</tt>. Everything here can be fully
--   forced and that's critical for preventing space leaks (see #22530)
data CgBreakInfo
CgBreakInfo :: ![IfaceTvBndr] -> ![Maybe (IfaceIdBndr, Word16)] -> !IfaceType -> CgBreakInfo

-- | Type variables in scope at the breakpoint
[cgb_tyvars] :: CgBreakInfo -> ![IfaceTvBndr]
[cgb_vars] :: CgBreakInfo -> ![Maybe (IfaceIdBndr, Word16)]
[cgb_resty] :: CgBreakInfo -> !IfaceType

-- | All the information about the breakpoints for a module
data ModBreaks
ModBreaks :: ForeignRef BreakArray -> !Array BreakIndex SrcSpan -> !Array BreakIndex [OccName] -> !Array BreakIndex [String] -> !Array BreakIndex (RemotePtr CostCentre) -> IntMap CgBreakInfo -> RemotePtr ModuleName -> ModBreaks

-- | The array of flags, one per breakpoint, indicating which breakpoints
--   are enabled.
[modBreaks_flags] :: ModBreaks -> ForeignRef BreakArray

-- | An array giving the source span of each breakpoint.
[modBreaks_locs] :: ModBreaks -> !Array BreakIndex SrcSpan

-- | An array giving the names of the free variables at each breakpoint.
[modBreaks_vars] :: ModBreaks -> !Array BreakIndex [OccName]

-- | An array giving the names of the declarations enclosing each
--   breakpoint. See Note [Field modBreaks_decls]
[modBreaks_decls] :: ModBreaks -> !Array BreakIndex [String]

-- | Array pointing to cost centre for each breakpoint
[modBreaks_ccs] :: ModBreaks -> !Array BreakIndex (RemotePtr CostCentre)

-- | info about each breakpoint from the bytecode generator
[modBreaks_breakInfo] :: ModBreaks -> IntMap CgBreakInfo
[modBreaks_module] :: ModBreaks -> RemotePtr ModuleName

-- | Breakpoint index
type BreakIndex = Int

-- | Construct an empty ModBreaks
emptyModBreaks :: ModBreaks

-- | C CostCentre type
data CCostCentre
instance Control.DeepSeq.NFData GHC.ByteCode.Types.FFIInfo
instance GHC.Show.Show GHC.ByteCode.Types.FFIInfo
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.ByteOff
instance GHC.Real.Real GHC.ByteCode.Types.ByteOff
instance GHC.Classes.Ord GHC.ByteCode.Types.ByteOff
instance GHC.Num.Num GHC.ByteCode.Types.ByteOff
instance GHC.Real.Integral GHC.ByteCode.Types.ByteOff
instance GHC.Show.Show GHC.ByteCode.Types.ByteOff
instance GHC.Classes.Eq GHC.ByteCode.Types.ByteOff
instance GHC.Enum.Enum GHC.ByteCode.Types.ByteOff
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.WordOff
instance GHC.Real.Real GHC.ByteCode.Types.WordOff
instance GHC.Classes.Ord GHC.ByteCode.Types.WordOff
instance GHC.Num.Num GHC.ByteCode.Types.WordOff
instance GHC.Real.Integral GHC.ByteCode.Types.WordOff
instance GHC.Show.Show GHC.ByteCode.Types.WordOff
instance GHC.Classes.Eq GHC.ByteCode.Types.WordOff
instance GHC.Enum.Enum GHC.ByteCode.Types.WordOff
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.RegBitmap
instance GHC.Bits.FiniteBits GHC.ByteCode.Types.RegBitmap
instance GHC.Bits.Bits GHC.ByteCode.Types.RegBitmap
instance GHC.Real.Real GHC.ByteCode.Types.RegBitmap
instance GHC.Classes.Ord GHC.ByteCode.Types.RegBitmap
instance GHC.Num.Num GHC.ByteCode.Types.RegBitmap
instance GHC.Real.Integral GHC.ByteCode.Types.RegBitmap
instance GHC.Show.Show GHC.ByteCode.Types.RegBitmap
instance GHC.Classes.Eq GHC.ByteCode.Types.RegBitmap
instance GHC.Enum.Enum GHC.ByteCode.Types.RegBitmap
instance GHC.Classes.Eq GHC.ByteCode.Types.NativeCallType
instance Control.DeepSeq.NFData GHC.ByteCode.Types.ItblPtr
instance GHC.Show.Show GHC.ByteCode.Types.ItblPtr
instance Control.DeepSeq.NFData GHC.ByteCode.Types.AddrPtr
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.CompiledByteCode
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.CgBreakInfo
instance Control.DeepSeq.NFData GHC.ByteCode.Types.UnlinkedBCO
instance Control.DeepSeq.NFData GHC.ByteCode.Types.BCOPtr
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.UnlinkedBCO
instance Control.DeepSeq.NFData GHC.ByteCode.Types.BCONPtr
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Types.NativeCallInfo

module GHC.Linker.Types
newtype Loader
Loader :: MVar (Maybe LoaderState) -> Loader
[loader_state] :: Loader -> MVar (Maybe LoaderState)
data LoaderState
LoaderState :: !LinkerEnv -> !LinkableSet -> !LinkableSet -> !PkgsLoaded -> ![(FilePath, String)] -> LoaderState

-- | Current global mapping from Names to their true values
[linker_env] :: LoaderState -> !LinkerEnv

-- | The currently loaded interpreted modules (home package)
[bcos_loaded] :: LoaderState -> !LinkableSet

-- | And the currently-loaded compiled modules (home package)
[objs_loaded] :: LoaderState -> !LinkableSet

-- | The currently-loaded packages; always object code haskell libraries,
--   system libraries, transitive dependencies
[pkgs_loaded] :: LoaderState -> !PkgsLoaded

-- | We need to remember the name of previous temporary DLL/.so libraries
--   so we can link them (see #10322)
[temp_sos] :: LoaderState -> ![(FilePath, String)]
uninitializedLoader :: IO Loader
modifyClosureEnv :: LoaderState -> (ClosureEnv -> ClosureEnv) -> LoaderState
data LinkerEnv
LinkerEnv :: ClosureEnv -> !ItblEnv -> !AddrEnv -> LinkerEnv

-- | Current global mapping from closure Names to their true values
[closure_env] :: LinkerEnv -> ClosureEnv

-- | The current global mapping from RdrNames of DataCons to info table
--   addresses. When a new Unlinked is linked into the running image, or an
--   existing module in the image is replaced, the itbl_env must be updated
--   appropriately.
[itbl_env] :: LinkerEnv -> !ItblEnv

-- | Like <a>closure_env</a> and <a>itbl_env</a>, but for top-level 'Addr#'
--   literals, see Note [Generating code for top-level string literal
--   bindings] in GHC.StgToByteCode.
[addr_env] :: LinkerEnv -> !AddrEnv
filterLinkerEnv :: (Name -> Bool) -> LinkerEnv -> LinkerEnv
type ClosureEnv = NameEnv (Name, ForeignHValue)
emptyClosureEnv :: ClosureEnv
extendClosureEnv :: ClosureEnv -> [(Name, ForeignHValue)] -> ClosureEnv

-- | Information we can use to dynamically link modules into the compiler
data Linkable
LM :: !UTCTime -> !Module -> [Unlinked] -> Linkable

-- | Time at which this linkable was built (i.e. when the bytecodes were
--   produced, or the mod date on the files)
[linkableTime] :: Linkable -> !UTCTime

-- | The linkable module itself
[linkableModule] :: Linkable -> !Module

-- | Those files and chunks of code we have yet to link.
--   
--   INVARIANT: A valid linkable always has at least one <a>Unlinked</a>
--   item.
[linkableUnlinked] :: Linkable -> [Unlinked]
type LinkableSet = ModuleEnv Linkable
mkLinkableSet :: [Linkable] -> LinkableSet
unionLinkableSet :: LinkableSet -> LinkableSet -> LinkableSet
type ObjFile = FilePath

-- | Objects which have yet to be linked by the compiler
data Unlinked

-- | An object file (.o)
DotO :: ObjFile -> Unlinked

-- | Static archive file (.a)
DotA :: FilePath -> Unlinked

-- | Dynamically linked library file (.so, .dll, .dylib)
DotDLL :: FilePath -> Unlinked

-- | Serialised core which we can turn into BCOs (or object files), or used
--   by some other backend See Note [Interface Files with Core Definitions]
CoreBindings :: WholeCoreBindings -> Unlinked

-- | A list of BCOs, but hidden behind extra indirection to avoid being too
--   strict.
LoadedBCOs :: [Unlinked] -> Unlinked

-- | A byte-code object, lives only in memory. Also carries some static
--   pointer table entries which should be loaded along with the BCOs. See
--   Note [Grand plan for static forms] in
--   <a>GHC.Iface.Tidy.StaticPtrTable</a>.
BCOs :: CompiledByteCode -> [SptEntry] -> Unlinked

-- | An entry to be inserted into a module's static pointer table. See Note
--   [Grand plan for static forms] in <a>GHC.Iface.Tidy.StaticPtrTable</a>.
data SptEntry
SptEntry :: Id -> Fingerprint -> SptEntry
isObjectLinkable :: Linkable -> Bool
linkableObjs :: Linkable -> [FilePath]

-- | Is this an actual file on disk we can link in somehow?
isObject :: Unlinked -> Bool

-- | Retrieve the filename of the linkable if possible. Panic if it is a
--   byte-code object
nameOfObject :: Unlinked -> FilePath
nameOfObject_maybe :: Unlinked -> Maybe FilePath

-- | Is this a bytecode linkable with no file on disk?
isInterpretable :: Unlinked -> Bool

-- | Retrieve the compiled byte-code if possible. Panic if it is a
--   file-based linkable
byteCodeOfObject :: Unlinked -> [CompiledByteCode]
data LibrarySpec
Objects :: [FilePath] -> LibrarySpec
Archive :: FilePath -> LibrarySpec
DLL :: String -> LibrarySpec
DLLPath :: FilePath -> LibrarySpec
Framework :: String -> LibrarySpec
data LoadedPkgInfo
LoadedPkgInfo :: !UnitId -> ![LibrarySpec] -> ![LibrarySpec] -> UniqDSet UnitId -> LoadedPkgInfo
[loaded_pkg_uid] :: LoadedPkgInfo -> !UnitId
[loaded_pkg_hs_objs] :: LoadedPkgInfo -> ![LibrarySpec]
[loaded_pkg_non_hs_objs] :: LoadedPkgInfo -> ![LibrarySpec]
[loaded_pkg_trans_deps] :: LoadedPkgInfo -> UniqDSet UnitId
type PkgsLoaded = UniqDFM UnitId LoadedPkgInfo
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.LoadedPkgInfo
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.LibrarySpec
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.Linkable
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.Unlinked
instance GHC.Utils.Outputable.Outputable GHC.Linker.Types.SptEntry

module GHC.Unit.Module.ModGuts

-- | A ModGuts is carried through the compiler, accumulating stuff as it
--   goes There is only one ModGuts at any time, the one for the module
--   being compiled right now. Once it is compiled, a <tt>ModIface</tt> and
--   <tt>ModDetails</tt> are extracted and the ModGuts is discarded.
data ModGuts
ModGuts :: !Module -> HscSource -> SrcSpan -> ![AvailInfo] -> !Dependencies -> ![Usage] -> !Bool -> !GlobalRdrEnv -> !FixityEnv -> ![TyCon] -> ![ClsInst] -> ![FamInst] -> ![PatSyn] -> ![CoreRule] -> !CoreProgram -> !ForeignStubs -> ![(ForeignSrcLang, FilePath)] -> !Warnings GhcRn -> [Annotation] -> [CompleteMatch] -> !HpcInfo -> !Maybe ModBreaks -> InstEnv -> FamInstEnv -> !NameSet -> SafeHaskellMode -> Bool -> !Maybe Docs -> ModGuts

-- | Module being compiled
[mg_module] :: ModGuts -> !Module

-- | Whether it's an hs-boot module
[mg_hsc_src] :: ModGuts -> HscSource

-- | For error messages from inner passes
[mg_loc] :: ModGuts -> SrcSpan

-- | What it exports
[mg_exports] :: ModGuts -> ![AvailInfo]

-- | What it depends on, directly or otherwise
[mg_deps] :: ModGuts -> !Dependencies

-- | What was used? Used for interfaces.
[mg_usages] :: ModGuts -> ![Usage]

-- | Did we run a TH splice?
[mg_used_th] :: ModGuts -> !Bool

-- | Top-level lexical environment
[mg_rdr_env] :: ModGuts -> !GlobalRdrEnv

-- | Fixities declared in this module. Used for creating interface files.
[mg_fix_env] :: ModGuts -> !FixityEnv

-- | TyCons declared in this module (includes TyCons for classes)
[mg_tcs] :: ModGuts -> ![TyCon]

-- | Class instances declared in this module
[mg_insts] :: ModGuts -> ![ClsInst]

-- | Family instances declared in this module
[mg_fam_insts] :: ModGuts -> ![FamInst]

-- | Pattern synonyms declared in this module
[mg_patsyns] :: ModGuts -> ![PatSyn]

-- | Before the core pipeline starts, contains See Note [Overall plumbing
--   for rules] in <a>GHC.Core.Rules</a>
[mg_rules] :: ModGuts -> ![CoreRule]

-- | Bindings for this module
[mg_binds] :: ModGuts -> !CoreProgram

-- | Foreign exports declared in this module
[mg_foreign] :: ModGuts -> !ForeignStubs

-- | Files to be compiled with the C compiler
[mg_foreign_files] :: ModGuts -> ![(ForeignSrcLang, FilePath)]

-- | Warnings declared in the module
[mg_warns] :: ModGuts -> !Warnings GhcRn

-- | Annotations declared in this module
[mg_anns] :: ModGuts -> [Annotation]

-- | Complete Matches
[mg_complete_matches] :: ModGuts -> [CompleteMatch]

-- | Coverage tick boxes in the module
[mg_hpc_info] :: ModGuts -> !HpcInfo

-- | Breakpoints for the module
[mg_modBreaks] :: ModGuts -> !Maybe ModBreaks

-- | Class instance environment for <i>home-package</i> modules (including
--   this one); c.f. <tt>tcg_inst_env</tt>
[mg_inst_env] :: ModGuts -> InstEnv

-- | Type-family instance environment for <i>home-package</i> modules
--   (including this one); c.f. <tt>tcg_fam_inst_env</tt>
[mg_fam_inst_env] :: ModGuts -> FamInstEnv
[mg_boot_exports] :: ModGuts -> !NameSet

-- | Safe Haskell mode
[mg_safe_haskell] :: ModGuts -> SafeHaskellMode

-- | Do we need to trust our own package for Safe Haskell? See Note [Trust
--   Own Package] in <a>GHC.Rename.Names</a>
[mg_trust_pkg] :: ModGuts -> Bool

-- | Documentation.
[mg_docs] :: ModGuts -> !Maybe Docs
mg_mnwib :: ModGuts -> ModuleNameWithIsBoot

-- | A restricted form of <a>ModGuts</a> for code generation purposes
data CgGuts
CgGuts :: !Module -> [TyCon] -> CoreProgram -> [CostCentre] -> !ForeignStubs -> ![(ForeignSrcLang, FilePath)] -> !Set UnitId -> !HpcInfo -> !Maybe ModBreaks -> [SptEntry] -> CgGuts

-- | Module being compiled
[cg_module] :: CgGuts -> !Module

-- | Algebraic data types (including ones that started life as classes);
--   generate constructors and info tables. Includes newtypes, just for the
--   benefit of External Core
[cg_tycons] :: CgGuts -> [TyCon]

-- | The tidied main bindings, including previously-implicit bindings for
--   record and class selectors, and data constructor wrappers. But *not*
--   data constructor workers; reason: we regard them as part of the
--   code-gen of tycons
[cg_binds] :: CgGuts -> CoreProgram
[cg_ccs] :: CgGuts -> [CostCentre]

-- | Foreign export stubs
[cg_foreign] :: CgGuts -> !ForeignStubs
[cg_foreign_files] :: CgGuts -> ![(ForeignSrcLang, FilePath)]

-- | Dependent packages, used to generate #includes for C code gen
[cg_dep_pkgs] :: CgGuts -> !Set UnitId

-- | Program coverage tick box information
[cg_hpc_info] :: CgGuts -> !HpcInfo

-- | Module breakpoints
[cg_modBreaks] :: CgGuts -> !Maybe ModBreaks

-- | Static pointer table entries for static forms defined in the module.
--   See Note [Grand plan for static forms] in
--   <a>GHC.Iface.Tidy.StaticPtrTable</a>
[cg_spt_entries] :: CgGuts -> [SptEntry]


-- | Functions for collecting together and applying rewrite rules to a
--   module. The <a>CoreRule</a> datatype itself is declared elsewhere.
module GHC.Core.Rules

-- | The main rule matching function. Attempts to apply all (active)
--   supplied rules to this instance of an application in a given context,
--   returning the rule applied and the resulting expression if successful.
lookupRule :: RuleOpts -> InScopeEnv -> (Activation -> Bool) -> Id -> [CoreExpr] -> [CoreRule] -> Maybe (CoreRule, CoreExpr)

-- | Gathers a collection of <a>CoreRule</a>s. Maps (the name of) an
--   <a>Id</a> to its rules
type RuleBase = NameEnv [CoreRule]

-- | A full rule environment which we can apply rules from. Like a
--   <a>RuleBase</a>, but it also includes the set of visible orphans we
--   use to filter out orphan rules which are not visible (even though we
--   can see them...) See Note [Orphans] in GHC.Core
data RuleEnv
RuleEnv :: !RuleBase -> !RuleBase -> !RuleBase -> !ModuleSet -> RuleEnv
[re_local_rules] :: RuleEnv -> !RuleBase
[re_home_rules] :: RuleEnv -> !RuleBase
[re_eps_rules] :: RuleEnv -> !RuleBase
[re_visible_orphs] :: RuleEnv -> !ModuleSet
mkRuleEnv :: ModGuts -> RuleBase -> RuleBase -> RuleEnv
emptyRuleEnv :: RuleEnv
updExternalPackageRules :: RuleEnv -> RuleBase -> RuleEnv
addLocalRules :: RuleEnv -> [CoreRule] -> RuleEnv
updLocalRules :: RuleEnv -> [CoreRule] -> RuleEnv
emptyRuleBase :: RuleBase
mkRuleBase :: [CoreRule] -> RuleBase
extendRuleBaseList :: RuleBase -> [CoreRule] -> RuleBase
pprRuleBase :: RuleBase -> SDoc

-- | Report partial matches for rules beginning with the specified string
--   for the purposes of error reporting
ruleCheckProgram :: RuleOpts -> CompilerPhase -> String -> (Id -> [CoreRule]) -> CoreProgram -> SDoc
extendRuleInfo :: RuleInfo -> [CoreRule] -> RuleInfo
addRuleInfo :: RuleInfo -> RuleInfo -> RuleInfo
addIdSpecialisations :: Id -> [CoreRule] -> Id
addRulesToId :: RuleBase -> Id -> Id

-- | Gather all the rules for locally bound identifiers from the supplied
--   bindings
rulesOfBinds :: [CoreBind] -> [CoreRule]
getRules :: RuleEnv -> Id -> [CoreRule]
pprRulesForUser :: [CoreRule] -> SDoc

-- | Used to make <a>CoreRule</a> for an <a>Id</a> defined in the module
--   being compiled. See also <a>CoreRule</a>
mkRule :: Module -> Bool -> Bool -> RuleName -> Activation -> Name -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> CoreRule
mkSpecRule :: DynFlags -> Module -> Bool -> Activation -> SDoc -> Id -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> CoreRule

-- | Find the "top" free names of several expressions. Such names are
--   either:
--   
--   <ol>
--   <li>The function finally being applied to in an application chain (if
--   that name is a GlobalId: see <a>GHC.Types.Var#globalvslocal</a>),
--   or</li>
--   <li>The <tt>TyCon</tt> if the expression is a <a>Type</a></li>
--   </ol>
--   
--   This is used for the fast-match-check for rules; if the top names
--   don't match, the rest can't
roughTopNames :: [CoreExpr] -> [Maybe Name]

module GHC.Core.Opt.Simplify.Monad
data TopEnvConfig
TopEnvConfig :: !Int -> !Int -> TopEnvConfig
[te_history_size] :: TopEnvConfig -> !Int
[te_tick_factor] :: TopEnvConfig -> !Int
data SimplM result
initSmpl :: Logger -> IO RuleEnv -> TopEnvConfig -> Int -> SimplM a -> IO (a, SimplCount)
traceSmpl :: String -> SDoc -> SimplM ()
getSimplRules :: SimplM RuleEnv

-- | A monad for generating unique identifiers
class Monad m => MonadUnique m

-- | Get a new UniqueSupply
getUniqueSupplyM :: MonadUnique m => m UniqSupply

-- | Get a new unique identifier
getUniqueM :: MonadUnique m => m Unique

-- | Get an infinite list of new unique identifiers
getUniquesM :: MonadUnique m => m [Unique]
newId :: FastString -> Mult -> Type -> SimplM Id

-- | Make a join id with given type and arity but without call-by-value
--   annotations.
newJoinId :: [Var] -> Type -> SimplM Id
data SimplCount
tick :: Tick -> SimplM ()
freeTick :: Tick -> SimplM ()
checkedTick :: Tick -> SimplM ()
getSimplCount :: SimplM SimplCount
zeroSimplCount :: Bool -> SimplCount
pprSimplCount :: SimplCount -> SDoc
plusSimplCount :: SimplCount -> SimplCount -> SimplCount
isZeroSimplCount :: SimplCount -> Bool
instance GHC.Base.Functor GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Base.Applicative GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Base.Monad GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Core.Opt.Simplify.Monad.SimplM
instance GHC.Utils.Logger.HasLogger GHC.Core.Opt.Simplify.Monad.SimplM
instance Control.Monad.IO.Class.MonadIO GHC.Core.Opt.Simplify.Monad.SimplM

module GHC.Core.Opt.Simplify.Env
data SimplMode
SimplMode :: !CompilerPhase -> ![String] -> !Bool -> !Bool -> !Bool -> !Bool -> !UnfoldingOpts -> !Bool -> !Bool -> !FloatEnable -> !Bool -> !ArityOpts -> !RuleOpts -> !Bool -> !Bool -> !OptCoercionOpts -> SimplMode
[sm_phase] :: SimplMode -> !CompilerPhase

-- | Name(s) of the phase
[sm_names] :: SimplMode -> ![String]

-- | Whether RULES are enabled
[sm_rules] :: SimplMode -> !Bool

-- | Whether inlining is enabled
[sm_inline] :: SimplMode -> !Bool

-- | Whether eta-expansion is enabled
[sm_eta_expand] :: SimplMode -> !Bool

-- | Do we swizzle casts past lambdas?
[sm_cast_swizzle] :: SimplMode -> !Bool

-- | Unfolding options
[sm_uf_opts] :: SimplMode -> !UnfoldingOpts

-- | Whether case-of-case is enabled
[sm_case_case] :: SimplMode -> !Bool

-- | Whether pre-inlining is enabled
[sm_pre_inline] :: SimplMode -> !Bool

-- | Whether to enable floating out
[sm_float_enable] :: SimplMode -> !FloatEnable
[sm_do_eta_reduction] :: SimplMode -> !Bool
[sm_arity_opts] :: SimplMode -> !ArityOpts
[sm_rule_opts] :: SimplMode -> !RuleOpts
[sm_case_folding] :: SimplMode -> !Bool
[sm_case_merge] :: SimplMode -> !Bool

-- | Coercion optimiser options
[sm_co_opt_opts] :: SimplMode -> !OptCoercionOpts
updMode :: (SimplMode -> SimplMode) -> SimplEnv -> SimplEnv
smPedanticBottoms :: SimplMode -> Bool
smPlatform :: SimplMode -> Platform
data SimplEnv
SimplEnv :: !SimplMode -> !(FamInstEnv, FamInstEnv) -> TvSubstEnv -> CvSubstEnv -> SimplIdSubst -> !UnVarSet -> !InScopeSet -> !Int -> SimplEnv
[seMode] :: SimplEnv -> !SimplMode
[seFamEnvs] :: SimplEnv -> !(FamInstEnv, FamInstEnv)
[seTvSubst] :: SimplEnv -> TvSubstEnv
[seCvSubst] :: SimplEnv -> CvSubstEnv
[seIdSubst] :: SimplEnv -> SimplIdSubst

-- | Fast OutVarSet tracking which recursive RHSs we are analysing. See
--   Note [Eta reduction in recursive RHSs] in GHC.Core.Opt.Arity.
[seRecIds] :: SimplEnv -> !UnVarSet
[seInScope] :: SimplEnv -> !InScopeSet
[seCaseDepth] :: SimplEnv -> !Int
pprSimplEnv :: SimplEnv -> SDoc
seArityOpts :: SimplEnv -> ArityOpts
seCaseCase :: SimplEnv -> Bool
seCaseFolding :: SimplEnv -> Bool
seCaseMerge :: SimplEnv -> Bool
seCastSwizzle :: SimplEnv -> Bool
seDoEtaReduction :: SimplEnv -> Bool
seEtaExpand :: SimplEnv -> Bool
seFloatEnable :: SimplEnv -> FloatEnable
seInline :: SimplEnv -> Bool
seNames :: SimplEnv -> [String]
seOptCoercionOpts :: SimplEnv -> OptCoercionOpts
sePedanticBottoms :: SimplEnv -> Bool
sePhase :: SimplEnv -> CompilerPhase
sePlatform :: SimplEnv -> Platform
sePreInline :: SimplEnv -> Bool
seRuleOpts :: SimplEnv -> RuleOpts
seRules :: SimplEnv -> Bool
seUnfoldingOpts :: SimplEnv -> UnfoldingOpts
mkSimplEnv :: SimplMode -> (FamInstEnv, FamInstEnv) -> SimplEnv
extendIdSubst :: SimplEnv -> Id -> SimplSR -> SimplEnv
extendTvSubst :: SimplEnv -> TyVar -> Type -> SimplEnv
extendCvSubst :: SimplEnv -> CoVar -> Coercion -> SimplEnv
zapSubstEnv :: SimplEnv -> SimplEnv
setSubstEnv :: SimplEnv -> TvSubstEnv -> CvSubstEnv -> SimplIdSubst -> SimplEnv
bumpCaseDepth :: SimplEnv -> SimplEnv
getInScope :: SimplEnv -> InScopeSet
setInScopeFromE :: SimplEnv -> SimplEnv -> SimplEnv
setInScopeFromF :: SimplEnv -> SimplFloats -> SimplEnv
setInScopeSet :: SimplEnv -> InScopeSet -> SimplEnv
modifyInScope :: SimplEnv -> CoreBndr -> SimplEnv
addNewInScopeIds :: SimplEnv -> [CoreBndr] -> SimplEnv
getSimplRules :: SimplM RuleEnv
enterRecGroupRHSs :: SimplEnv -> [OutBndr] -> (SimplEnv -> SimplM (r, SimplEnv)) -> SimplM (r, SimplEnv)

-- | A substitution result.
data SimplSR
DoneEx :: OutExpr -> Maybe JoinArity -> SimplSR
DoneId :: OutId -> SimplSR
ContEx :: TvSubstEnv -> CvSubstEnv -> SimplIdSubst -> InExpr -> SimplSR
mkContEx :: SimplEnv -> InExpr -> SimplSR
substId :: SimplEnv -> InId -> SimplSR
lookupRecBndr :: SimplEnv -> InId -> OutId
simplNonRecBndr :: SimplEnv -> InBndr -> SimplM (SimplEnv, OutBndr)
simplNonRecJoinBndr :: SimplEnv -> InBndr -> Mult -> OutType -> SimplM (SimplEnv, OutBndr)
simplRecBndrs :: SimplEnv -> [InBndr] -> SimplM SimplEnv
simplRecJoinBndrs :: SimplEnv -> [InBndr] -> Mult -> OutType -> SimplM SimplEnv
simplBinder :: SimplEnv -> InBndr -> SimplM (SimplEnv, OutBndr)
simplBinders :: SimplEnv -> [InBndr] -> SimplM (SimplEnv, [OutBndr])
substTy :: HasDebugCallStack => SimplEnv -> Type -> Type
substTyVar :: SimplEnv -> TyVar -> Type
getSubst :: SimplEnv -> Subst
substCo :: SimplEnv -> Coercion -> Coercion
substCoVar :: SimplEnv -> CoVar -> Coercion
data SimplFloats
SimplFloats :: LetFloats -> JoinFloats -> InScopeSet -> SimplFloats
[sfLetFloats] :: SimplFloats -> LetFloats
[sfJoinFloats] :: SimplFloats -> JoinFloats
[sfInScope] :: SimplFloats -> InScopeSet
emptyFloats :: SimplEnv -> SimplFloats
isEmptyFloats :: SimplFloats -> Bool
mkRecFloats :: SimplFloats -> SimplFloats
mkFloatBind :: SimplEnv -> OutBind -> (SimplFloats, SimplEnv)
addLetFloats :: SimplFloats -> LetFloats -> SimplFloats
addJoinFloats :: SimplFloats -> JoinFloats -> SimplFloats
addFloats :: SimplFloats -> SimplFloats -> SimplFloats
extendFloats :: SimplFloats -> OutBind -> SimplFloats
wrapFloats :: SimplFloats -> OutExpr -> OutExpr
isEmptyJoinFloats :: JoinFloats -> Bool
isEmptyLetFloats :: LetFloats -> Bool
doFloatFromRhs :: FloatEnable -> TopLevelFlag -> RecFlag -> Bool -> SimplFloats -> OutExpr -> Bool
getTopFloatBinds :: SimplFloats -> [CoreBind]
data LetFloats
data FloatEnable
FloatDisabled :: FloatEnable
FloatNestedOnly :: FloatEnable
FloatEnabled :: FloatEnable
letFloatBinds :: LetFloats -> [CoreBind]
emptyLetFloats :: LetFloats
unitLetFloat :: OutBind -> LetFloats
addLetFlts :: LetFloats -> LetFloats -> LetFloats
mapLetFloats :: LetFloats -> ((Id, CoreExpr) -> (Id, CoreExpr)) -> LetFloats
type JoinFloat = OutBind
type JoinFloats = OrdList JoinFloat
emptyJoinFloats :: JoinFloats
wrapJoinFloats :: JoinFloats -> OutExpr -> OutExpr
wrapJoinFloatsX :: SimplFloats -> OutExpr -> (SimplFloats, OutExpr)
unitJoinFloat :: OutBind -> JoinFloats
addJoinFlts :: JoinFloats -> JoinFloats -> JoinFloats
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.SimplFloats
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.LetFloats
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.FloatFlag
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.SimplSR
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Env.SimplMode


-- | Info about modules in the "home" unit
module GHC.Unit.Home.ModInfo

-- | Information about modules in the package being compiled
data HomeModInfo
HomeModInfo :: !ModIface -> ModDetails -> !HomeModLinkable -> HomeModInfo

-- | The basic loaded interface file: every loaded module has one of these,
--   even if it is imported from another package
[hm_iface] :: HomeModInfo -> !ModIface

-- | Extra information that has been created from the <a>ModIface</a> for
--   the module, typically during typechecking
[hm_details] :: HomeModInfo -> ModDetails

-- | The actual artifact we would like to link to access things in this
--   module. See Note [Home module build products]
--   
--   <a>hm_linkable</a> might be empty:
--   
--   <ol>
--   <li>If this is an .hs-boot module</li>
--   <li>Temporarily during compilation if we pruned away the old linkable
--   because it was out of date.</li>
--   </ol>
--   
--   When re-linking a module (<a>HscNoRecomp</a>), we construct the
--   <a>HomeModInfo</a> by building a new <a>ModDetails</a> from the old
--   <a>ModIface</a> (only).
[hm_linkable] :: HomeModInfo -> !HomeModLinkable
data HomeModLinkable
HomeModLinkable :: !Maybe Linkable -> !Maybe Linkable -> HomeModLinkable
[homeMod_bytecode] :: HomeModLinkable -> !Maybe Linkable
[homeMod_object] :: HomeModLinkable -> !Maybe Linkable
homeModInfoObject :: HomeModInfo -> Maybe Linkable
homeModInfoByteCode :: HomeModInfo -> Maybe Linkable
emptyHomeModInfoLinkable :: HomeModLinkable
justBytecode :: Linkable -> HomeModLinkable
justObjects :: Linkable -> HomeModLinkable
bytecodeAndObjects :: Linkable -> Linkable -> HomeModLinkable

-- | Helps us find information about modules in the home package
type HomePackageTable = DModuleNameEnv HomeModInfo

-- | Constructs an empty HomePackageTable
emptyHomePackageTable :: HomePackageTable
lookupHpt :: HomePackageTable -> ModuleName -> Maybe HomeModInfo
eltsHpt :: HomePackageTable -> [HomeModInfo]
filterHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> HomePackageTable
allHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> Bool
anyHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> Bool
mapHpt :: (HomeModInfo -> HomeModInfo) -> HomePackageTable -> HomePackageTable
delFromHpt :: HomePackageTable -> ModuleName -> HomePackageTable
addToHpt :: HomePackageTable -> ModuleName -> HomeModInfo -> HomePackageTable
addHomeModInfoToHpt :: HomeModInfo -> HomePackageTable -> HomePackageTable
addListToHpt :: HomePackageTable -> [(ModuleName, HomeModInfo)] -> HomePackageTable
lookupHptDirectly :: HomePackageTable -> Unique -> Maybe HomeModInfo
lookupHptByModule :: HomePackageTable -> Module -> Maybe HomeModInfo
listToHpt :: [(ModuleName, HomeModInfo)] -> HomePackageTable
listHMIToHpt :: [HomeModInfo] -> HomePackageTable
pprHPT :: HomePackageTable -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.Unit.Home.ModInfo.HomeModLinkable

module GHC.Unit.Module.Status

-- | Action to perform in backend compilation
data HscBackendAction

-- | Update the boot and signature file results.
HscUpdate :: ModIface -> HscBackendAction

-- | Recompile this module.
HscRecomp :: CgGuts -> !ModLocation -> !PartialModIface -> !Maybe Fingerprint -> HscBackendAction

-- | Information for the code generator.
[hscs_guts] :: HscBackendAction -> CgGuts

-- | Module info
[hscs_mod_location] :: HscBackendAction -> !ModLocation

-- | Partial interface
[hscs_partial_iface] :: HscBackendAction -> !PartialModIface

-- | Old interface hash for this compilation, if an old interface file
--   exists. Pass to <tt>hscMaybeWriteIface</tt> when writing the interface
--   to avoid updating the existing interface when the interface isn't
--   changed.
[hscs_old_iface_hash] :: HscBackendAction -> !Maybe Fingerprint

-- | Status of a module in incremental compilation
data HscRecompStatus

-- | Nothing to do because code already exists.
HscUpToDate :: ModIface -> HomeModLinkable -> HscRecompStatus

-- | Recompilation of module, or update of interface is required.
--   Optionally pass the old interface hash to avoid updating the existing
--   interface when it has not changed.
HscRecompNeeded :: Maybe Fingerprint -> HscRecompStatus
instance GHC.Utils.Outputable.Outputable GHC.Unit.Module.Status.HscBackendAction

module GHC.StgToJS.StaticPtr
initStaticPtrs :: [SptEntry] -> G JStat


-- | JavaScript code generator
module GHC.StgToJS.CodeGen

-- | Code generator for JavaScript
stgToJS :: Logger -> StgToJSConfig -> [CgStgTopBinding] -> Module -> [SptEntry] -> ForeignStubs -> CollectedCCs -> FilePath -> IO ()

module GHC.StgToJS

-- | Code generator for JavaScript
stgToJS :: Logger -> StgToJSConfig -> [CgStgTopBinding] -> Module -> [SptEntry] -> ForeignStubs -> CollectedCCs -> FilePath -> IO ()


-- | Types used by the runtime interpreter
module GHC.Runtime.Interpreter.Types

-- | Interpreter
data Interp
Interp :: !InterpInstance -> !Loader -> Interp

-- | Interpreter instance (internal, external)
[interpInstance] :: Interp -> !InterpInstance

-- | Interpreter loader
[interpLoader] :: Interp -> !Loader
data InterpInstance

-- | External interpreter
ExternalInterp :: !IServConfig -> !IServ -> InterpInstance

-- | Internal interpreter
InternalInterp :: InterpInstance

-- | External interpreter
--   
--   The external interpreter is spawned lazily (on first use) to avoid
--   slowing down sessions that don't require it. The contents of the MVar
--   reflects the state of the interpreter (running or not).
newtype IServ
IServ :: MVar IServState -> IServ

-- | External interpreter instance
data IServInstance
IServInstance :: !Pipe -> !ProcessHandle -> !UniqFM FastString (Ptr ()) -> ![HValueRef] -> IServInstance
[iservPipe] :: IServInstance -> !Pipe
[iservProcess] :: IServInstance -> !ProcessHandle
[iservLookupSymbolCache] :: IServInstance -> !UniqFM FastString (Ptr ())

-- | Values that need to be freed before the next command is sent. Threads
--   can append values to this list asynchronously (by modifying the IServ
--   state MVar).
[iservPendingFrees] :: IServInstance -> ![HValueRef]

-- | Configuration needed to spawn an external interpreter
data IServConfig
IServConfig :: !String -> ![String] -> !Bool -> !Bool -> !Maybe (CreateProcess -> IO ProcessHandle) -> IO () -> IServConfig

-- | External program to run
[iservConfProgram] :: IServConfig -> !String

-- | Command-line options
[iservConfOpts] :: IServConfig -> ![String]

-- | Use Profiling way
[iservConfProfiled] :: IServConfig -> !Bool

-- | Use Dynamic way
[iservConfDynamic] :: IServConfig -> !Bool

-- | Hook
[iservConfHook] :: IServConfig -> !Maybe (CreateProcess -> IO ProcessHandle)

-- | Trace action executed after spawn
[iservConfTrace] :: IServConfig -> IO ()

-- | State of an external interpreter
data IServState

-- | Not spawned yet
IServPending :: IServState

-- | Running
IServRunning :: !IServInstance -> IServState


-- | Code generation for the Static Pointer Table
--   
--   (c) 2014 I/O Tweag
--   
--   Each module that uses <tt>static</tt> keyword declares an
--   initialization function of the form hs_spt_init_&lt;module&gt;() which
--   is emitted into the _stub.c file and annotated with
--   <b>attribute</b>((constructor)) so that it gets executed at startup
--   time.
--   
--   The function's purpose is to call hs_spt_insert to insert the static
--   pointers of this module in the hashtable of the RTS, and it looks
--   something like this:
--   
--   <pre>
--   static void hs_hpc_init_Main(void) __attribute__((constructor));
--   static void hs_hpc_init_Main(void) {
--   
--     static StgWord64 k0[2] = {16252233372134256ULL,7370534374096082ULL};
--     extern StgPtr Main_r2wb_closure;
--     hs_spt_insert(k0, &amp;Main_r2wb_closure);
--   
--     static StgWord64 k1[2] = {12545634534567898ULL,5409674567544151ULL};
--     extern StgPtr Main_r2wc_closure;
--     hs_spt_insert(k1, &amp;Main_r2wc_closure);
--   
--   }
--   </pre>
--   
--   where the constants are fingerprints produced from the static forms.
--   
--   The linker must find the definitions matching the <tt>extern StgPtr
--   <a>name</a></tt> declarations. For this to work, the identifiers of
--   static pointers need to be exported. This is done in <a>newLvlVar</a>.
--   
--   There is also a finalization function for the time when the module is
--   unloaded.
--   
--   <pre>
--   static void hs_hpc_fini_Main(void) __attribute__((destructor));
--   static void hs_hpc_fini_Main(void) {
--   
--     static StgWord64 k0[2] = {16252233372134256ULL,7370534374096082ULL};
--     hs_spt_remove(k0);
--   
--     static StgWord64 k1[2] = {12545634534567898ULL,5409674567544151ULL};
--     hs_spt_remove(k1);
--   
--   }
--   </pre>
module GHC.Iface.Tidy.StaticPtrTable

-- | Replaces all bindings of the form
--   
--   <pre>
--   b = /\ ... -&gt; makeStatic location value
--   </pre>
--   
--   with
--   
--   <pre>
--   b = /\ ... -&gt;
--     StaticPtr key (StaticPtrInfo "pkg key" "module" location) value
--   </pre>
--   
--   where a distinct key is generated for each binding.
--   
--   It also yields the C stub that inserts these bindings into the static
--   pointer table.
sptCreateStaticBinds :: StaticPtrOpts -> Module -> CoreProgram -> IO ([SptEntry], Maybe CStub, CoreProgram)

-- | <tt>sptModuleInitCode module fps</tt> is a C stub to insert the static
--   entries of <tt>module</tt> into the static pointer table.
--   
--   <tt>fps</tt> is a list associating each binding corresponding to a
--   static entry with its fingerprint.
sptModuleInitCode :: Platform -> Module -> [SptEntry] -> CStub
data StaticPtrOpts
StaticPtrOpts :: !Platform -> !Bool -> !MkStringIds -> !DataCon -> !DataCon -> StaticPtrOpts

-- | Target platform
[opt_platform] :: StaticPtrOpts -> !Platform

-- | Generate CStub or not
[opt_gen_cstub] :: StaticPtrOpts -> !Bool

-- | Ids for `unpackCString[Utf8]#`
[opt_mk_string] :: StaticPtrOpts -> !MkStringIds

-- | <tt>StaticPtrInfo</tt> datacon
[opt_static_ptr_info_datacon] :: StaticPtrOpts -> !DataCon

-- | <tt>StaticPtr</tt> datacon
[opt_static_ptr_datacon] :: StaticPtrOpts -> !DataCon


-- | Functions for converting Core things to interface file things.
module GHC.CoreToIface
toIfaceTvBndr :: TyVar -> IfaceTvBndr
toIfaceTvBndrs :: [TyVar] -> [IfaceTvBndr]
toIfaceIdBndr :: Id -> IfaceIdBndr
toIfaceBndr :: Var -> IfaceBndr
toIfaceTopBndr :: Id -> IfaceTopBndrInfo
toIfaceForAllBndr :: VarBndr TyCoVar flag -> VarBndr IfaceBndr flag
toIfaceForAllBndrs :: [VarBndr TyCoVar vis] -> [VarBndr IfaceBndr vis]
toIfaceTyVar :: TyVar -> FastString
toIfaceType :: Type -> IfaceType
toIfaceTypeX :: VarSet -> Type -> IfaceType
toIfaceKind :: Type -> IfaceType
toIfaceTcArgs :: TyCon -> [Type] -> IfaceAppArgs
toIfaceTyCon :: TyCon -> IfaceTyCon
toIfaceTyCon_name :: Name -> IfaceTyCon
toIfaceTyLit :: TyLit -> IfaceTyLit
tidyToIfaceType :: TidyEnv -> Type -> IfaceType
tidyToIfaceContext :: TidyEnv -> ThetaType -> IfaceContext
tidyToIfaceTcArgs :: TidyEnv -> TyCon -> [Type] -> IfaceAppArgs
toIfaceCoercion :: Coercion -> IfaceCoercion
toIfaceCoercionX :: VarSet -> Coercion -> IfaceCoercion
patSynToIfaceDecl :: PatSyn -> IfaceDecl
toIfaceExpr :: CoreExpr -> IfaceExpr
toIfaceBang :: TidyEnv -> HsImplBang -> IfaceBang
toIfaceSrcBang :: HsSrcBang -> IfaceSrcBang
toIfaceLetBndr :: Id -> IfaceLetBndr
toIfaceIdDetails :: IdDetails -> IfaceIdDetails
toIfaceIdInfo :: IdInfo -> IfaceIdInfo
toIfUnfolding :: Bool -> Unfolding -> Maybe IfaceInfoItem
toIfaceTickish :: CoreTickish -> Maybe IfaceTickish
toIfaceBind :: Bind Id -> IfaceBinding IfaceLetBndr
toIfaceTopBind :: Bind Id -> IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo
toIfaceAlt :: CoreAlt -> IfaceAlt
toIfaceCon :: AltCon -> IfaceConAlt
toIfaceApp :: Expr CoreBndr -> [Arg CoreBndr] -> IfaceExpr
toIfaceVar :: Id -> IfaceExpr
toIfaceLFInfo :: Name -> LambdaFormInfo -> IfaceLFInfo
dehydrateCgBreakInfo :: [TyVar] -> [Maybe (Id, Word16)] -> Type -> CgBreakInfo


-- | Bytecode instruction definitions
module GHC.ByteCode.Instr
data BCInstr
STKCHECK :: Word -> BCInstr
PUSH_L :: !Word16 -> BCInstr
PUSH_LL :: !Word16 -> !Word16 -> BCInstr
PUSH_LLL :: !Word16 -> !Word16 -> !Word16 -> BCInstr
PUSH8 :: !Word16 -> BCInstr
PUSH16 :: !Word16 -> BCInstr
PUSH32 :: !Word16 -> BCInstr
PUSH8_W :: !Word16 -> BCInstr
PUSH16_W :: !Word16 -> BCInstr
PUSH32_W :: !Word16 -> BCInstr
PUSH_G :: Name -> BCInstr
PUSH_PRIMOP :: PrimOp -> BCInstr
PUSH_BCO :: ProtoBCO Name -> BCInstr
PUSH_ALTS :: ProtoBCO Name -> ArgRep -> BCInstr
PUSH_ALTS_TUPLE :: ProtoBCO Name -> !NativeCallInfo -> ProtoBCO Name -> BCInstr
PUSH_PAD8 :: BCInstr
PUSH_PAD16 :: BCInstr
PUSH_PAD32 :: BCInstr
PUSH_UBX8 :: Literal -> BCInstr
PUSH_UBX16 :: Literal -> BCInstr
PUSH_UBX32 :: Literal -> BCInstr
PUSH_UBX :: Literal -> Word16 -> BCInstr
PUSH_ADDR :: Name -> BCInstr
PUSH_APPLY_N :: BCInstr
PUSH_APPLY_V :: BCInstr
PUSH_APPLY_F :: BCInstr
PUSH_APPLY_D :: BCInstr
PUSH_APPLY_L :: BCInstr
PUSH_APPLY_P :: BCInstr
PUSH_APPLY_PP :: BCInstr
PUSH_APPLY_PPP :: BCInstr
PUSH_APPLY_PPPP :: BCInstr
PUSH_APPLY_PPPPP :: BCInstr
PUSH_APPLY_PPPPPP :: BCInstr
SLIDE :: Word16 -> Word16 -> BCInstr
ALLOC_AP :: !Word16 -> BCInstr
ALLOC_AP_NOUPD :: !Word16 -> BCInstr
ALLOC_PAP :: !Word16 -> !Word16 -> BCInstr
MKAP :: !Word16 -> !Word16 -> BCInstr
MKPAP :: !Word16 -> !Word16 -> BCInstr
UNPACK :: !Word16 -> BCInstr
PACK :: DataCon -> !Word16 -> BCInstr
LABEL :: LocalLabel -> BCInstr
TESTLT_I :: Int -> LocalLabel -> BCInstr
TESTEQ_I :: Int -> LocalLabel -> BCInstr
TESTLT_W :: Word -> LocalLabel -> BCInstr
TESTEQ_W :: Word -> LocalLabel -> BCInstr
TESTLT_I64 :: Int64 -> LocalLabel -> BCInstr
TESTEQ_I64 :: Int64 -> LocalLabel -> BCInstr
TESTLT_I32 :: Int32 -> LocalLabel -> BCInstr
TESTEQ_I32 :: Int32 -> LocalLabel -> BCInstr
TESTLT_I16 :: Int16 -> LocalLabel -> BCInstr
TESTEQ_I16 :: Int16 -> LocalLabel -> BCInstr
TESTLT_I8 :: Int8 -> LocalLabel -> BCInstr
TESTEQ_I8 :: Int16 -> LocalLabel -> BCInstr
TESTLT_W64 :: Word64 -> LocalLabel -> BCInstr
TESTEQ_W64 :: Word64 -> LocalLabel -> BCInstr
TESTLT_W32 :: Word32 -> LocalLabel -> BCInstr
TESTEQ_W32 :: Word32 -> LocalLabel -> BCInstr
TESTLT_W16 :: Word16 -> LocalLabel -> BCInstr
TESTEQ_W16 :: Word16 -> LocalLabel -> BCInstr
TESTLT_W8 :: Word8 -> LocalLabel -> BCInstr
TESTEQ_W8 :: Word8 -> LocalLabel -> BCInstr
TESTLT_F :: Float -> LocalLabel -> BCInstr
TESTEQ_F :: Float -> LocalLabel -> BCInstr
TESTLT_D :: Double -> LocalLabel -> BCInstr
TESTEQ_D :: Double -> LocalLabel -> BCInstr
TESTLT_P :: Word16 -> LocalLabel -> BCInstr
TESTEQ_P :: Word16 -> LocalLabel -> BCInstr
CASEFAIL :: BCInstr
JMP :: LocalLabel -> BCInstr
CCALL :: Word16 -> RemotePtr C_ffi_cif -> Word16 -> BCInstr
PRIMCALL :: BCInstr
SWIZZLE :: Word16 -> Word16 -> BCInstr
ENTER :: BCInstr
RETURN :: ArgRep -> BCInstr
RETURN_TUPLE :: BCInstr
BRK_FUN :: !Word16 -> RemotePtr ModuleName -> RemotePtr CostCentre -> BCInstr
data ProtoBCO a
ProtoBCO :: a -> [BCInstr] -> [StgWord] -> Word16 -> Int -> Either [CgStgAlt] CgStgRhs -> [FFIInfo] -> ProtoBCO a
[protoBCOName] :: ProtoBCO a -> a
[protoBCOInstrs] :: ProtoBCO a -> [BCInstr]
[protoBCOBitmap] :: ProtoBCO a -> [StgWord]
[protoBCOBitmapSize] :: ProtoBCO a -> Word16
[protoBCOArity] :: ProtoBCO a -> Int
[protoBCOExpr] :: ProtoBCO a -> Either [CgStgAlt] CgStgRhs
[protoBCOFFIs] :: ProtoBCO a -> [FFIInfo]
bciStackUse :: BCInstr -> Word

-- | A local block label (e.g. identifying a case alternative).
newtype LocalLabel
LocalLabel :: Word32 -> LocalLabel
[getLocalLabel] :: LocalLabel -> Word32
instance GHC.Classes.Ord GHC.ByteCode.Instr.LocalLabel
instance GHC.Classes.Eq GHC.ByteCode.Instr.LocalLabel
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.ByteCode.Instr.ProtoBCO a)
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Instr.BCInstr
instance GHC.Utils.Outputable.Outputable GHC.ByteCode.Instr.LocalLabel


-- | PrimOp's Ids
module GHC.Builtin.PrimOps.Ids

-- | Get primop id.
--   
--   Retrieve it from <a>primOpIds</a> cache.
primOpId :: PrimOp -> Id

-- | All the primop ids, as a list
allThePrimOpIds :: [Id]


-- | Constant Folder
module GHC.Core.Opt.ConstantFold
primOpRules :: Name -> PrimOp -> Maybe CoreRule
builtinRules :: [CoreRule]

-- | Match the scrutinee of a case and potentially return a new scrutinee
--   and a function to apply to each literal alternative.
caseRules :: Platform -> CoreExpr -> Maybe (CoreExpr, AltCon -> Maybe AltCon, Id -> CoreExpr)
instance GHC.Base.Functor GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Base.Applicative GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Base.Monad GHC.Core.Opt.ConstantFold.RuleM
instance Control.Monad.Fail.MonadFail GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Base.Alternative GHC.Core.Opt.ConstantFold.RuleM
instance GHC.Base.MonadPlus GHC.Core.Opt.ConstantFold.RuleM

module GHC.Unit.External

-- | Information about the currently loaded external packages. This is
--   mutable because packages will be demand-loaded during a compilation
--   run as required.
newtype ExternalUnitCache
ExternalUnitCache :: IORef ExternalPackageState -> ExternalUnitCache
[euc_eps] :: ExternalUnitCache -> IORef ExternalPackageState
initExternalUnitCache :: IO ExternalUnitCache
eucEPS :: ExternalUnitCache -> IO ExternalPackageState

-- | Information about other packages that we have slurped in by reading
--   their interface files
data ExternalPackageState
EPS :: !InstalledModuleEnv ModuleNameWithIsBoot -> !PackageIfaceTable -> InstalledModuleEnv (UniqDSet ModuleName) -> !PackageTypeEnv -> !PackageInstEnv -> !PackageFamInstEnv -> !PackageRuleBase -> !PackageAnnEnv -> !PackageCompleteMatches -> !ModuleEnv FamInstEnv -> !EpsStats -> ExternalPackageState

-- | In OneShot mode (only), home-package modules accumulate in the
--   external package state, and are sucked in lazily. For these home-pkg
--   modules (only) we need to record which are boot modules. We set this
--   field after loading all the explicitly-imported interfaces, but before
--   doing anything else
--   
--   The <a>ModuleName</a> part is not necessary, but it's useful for debug
--   prints, and it's convenient because this field comes direct from
--   <a>imp_dep_mods</a>
[eps_is_boot] :: ExternalPackageState -> !InstalledModuleEnv ModuleNameWithIsBoot

-- | The <a>ModIface</a>s for modules in external packages whose interfaces
--   we have opened. The declarations in these interface files are held in
--   the <tt>eps_decls</tt>, <a>eps_inst_env</a>, <a>eps_fam_inst_env</a>
--   and <tt>eps_rules</tt> fields of this record, not in the
--   <a>mi_decls</a> fields of the interface we have sucked in.
--   
--   What <i>is</i> in the PIT is:
--   
--   <ul>
--   <li>The Module</li>
--   <li>Fingerprint info</li>
--   <li>Its exports</li>
--   <li>Fixities</li>
--   <li>Deprecations and warnings</li>
--   </ul>
[eps_PIT] :: ExternalPackageState -> !PackageIfaceTable

-- | Cache for <a>mi_free_holes</a>. Ordinarily, we can rely on the
--   <a>eps_PIT</a> for this information, EXCEPT that when we do dependency
--   analysis, we need to look at the <tt>Dependencies</tt> of our imports
--   to determine what their precise free holes are
--   (<tt>moduleFreeHolesPrecise</tt>). We don't want to repeatedly reread
--   in the interface for every import, so cache it here. When the PIT gets
--   filled in we can drop these entries.
[eps_free_holes] :: ExternalPackageState -> InstalledModuleEnv (UniqDSet ModuleName)

-- | Result of typechecking all the external package interface files we
--   have sucked in. The domain of the mapping is external-package modules
[eps_PTE] :: ExternalPackageState -> !PackageTypeEnv

-- | The total <a>InstEnv</a> accumulated from all the external-package
--   modules
[eps_inst_env] :: ExternalPackageState -> !PackageInstEnv

-- | The total <a>FamInstEnv</a> accumulated from all the external-package
--   modules
[eps_fam_inst_env] :: ExternalPackageState -> !PackageFamInstEnv

-- | The total <tt>RuleEnv</tt> accumulated from all the external-package
--   modules
[eps_rule_base] :: ExternalPackageState -> !PackageRuleBase

-- | The total <a>AnnEnv</a> accumulated from all the external-package
--   modules
[eps_ann_env] :: ExternalPackageState -> !PackageAnnEnv

-- | The total <a>CompleteMatches</a> accumulated from all the
--   external-package modules
[eps_complete_matches] :: ExternalPackageState -> !PackageCompleteMatches

-- | The family instances accumulated from external packages, keyed off the
--   module that declared them
[eps_mod_fam_inst_env] :: ExternalPackageState -> !ModuleEnv FamInstEnv

-- | Statistics about what was loaded from external packages
[eps_stats] :: ExternalPackageState -> !EpsStats
initExternalPackageState :: ExternalPackageState

-- | Accumulated statistics about what we are putting into the
--   <a>ExternalPackageState</a>. "In" means stuff that is just <i>read</i>
--   from interface files, "Out" means actually sucked in and type-checked
data EpsStats
EpsStats :: !Int -> EpsStats
[n_ifaces_in, n_decls_in, n_decls_out, n_rules_in, n_rules_out, n_insts_in, n_insts_out] :: EpsStats -> !Int

-- | Add stats for one newly-read interface
addEpsInStats :: EpsStats -> Int -> Int -> Int -> EpsStats
type PackageTypeEnv = TypeEnv

-- | Helps us find information about modules in the imported packages
type PackageIfaceTable = ModuleEnv ModIface
type PackageInstEnv = InstEnv
type PackageFamInstEnv = FamInstEnv
type PackageRuleBase = RuleBase
type PackageCompleteMatches = CompleteMatches

-- | Constructs an empty PackageIfaceTable
emptyPackageIfaceTable :: PackageIfaceTable

module GHC.Unit.Env
data UnitEnv
UnitEnv :: {-# UNPACK #-} !ExternalUnitCache -> UnitId -> !HomeUnitGraph -> !Platform -> !GhcNameVersion -> UnitEnv

-- | Information about the currently loaded external packages. This is
--   mutable because packages will be demand-loaded during a compilation
--   run as required.
[ue_eps] :: UnitEnv -> {-# UNPACK #-} !ExternalUnitCache
[ue_current_unit] :: UnitEnv -> UnitId
[ue_home_unit_graph] :: UnitEnv -> !HomeUnitGraph

-- | Platform
[ue_platform] :: UnitEnv -> !Platform

-- | GHC name/version (used for dynamic library suffix)
[ue_namever] :: UnitEnv -> !GhcNameVersion
initUnitEnv :: UnitId -> HomeUnitGraph -> GhcNameVersion -> Platform -> IO UnitEnv
ueEPS :: UnitEnv -> IO ExternalPackageState

-- | Get home-unit
--   
--   Unsafe because the home-unit may not be set
unsafeGetHomeUnit :: UnitEnv -> HomeUnit
updateHug :: (HomeUnitGraph -> HomeUnitGraph) -> UnitEnv -> UnitEnv
updateHpt_lazy :: (HomePackageTable -> HomePackageTable) -> UnitEnv -> UnitEnv
updateHpt :: (HomePackageTable -> HomePackageTable) -> UnitEnv -> UnitEnv
ue_units :: HasDebugCallStack => UnitEnv -> UnitState
ue_currentHomeUnitEnv :: HasDebugCallStack => UnitEnv -> HomeUnitEnv
ue_setUnits :: UnitState -> UnitEnv -> UnitEnv
ue_setUnitFlags :: HasDebugCallStack => UnitId -> DynFlags -> UnitEnv -> UnitEnv
ue_unit_dbs :: UnitEnv -> Maybe [UnitDatabase UnitId]
ue_all_home_unit_ids :: UnitEnv -> Set UnitId
ue_setUnitDbs :: Maybe [UnitDatabase UnitId] -> UnitEnv -> UnitEnv
ue_hpt :: HasDebugCallStack => UnitEnv -> HomePackageTable
ue_homeUnit :: UnitEnv -> Maybe HomeUnit
ue_unsafeHomeUnit :: UnitEnv -> HomeUnit
ue_setFlags :: HasDebugCallStack => DynFlags -> UnitEnv -> UnitEnv
ue_setActiveUnit :: UnitId -> UnitEnv -> UnitEnv
ue_currentUnit :: UnitEnv -> UnitId
ue_findHomeUnitEnv :: HasDebugCallStack => UnitId -> UnitEnv -> HomeUnitEnv
ue_updateHomeUnitEnv :: (HomeUnitEnv -> HomeUnitEnv) -> UnitId -> UnitEnv -> UnitEnv
ue_unitHomeUnit :: UnitId -> UnitEnv -> HomeUnit
ue_unitFlags :: HasDebugCallStack => UnitId -> UnitEnv -> DynFlags

-- | Rename a unit id in the internal unit env.
--   
--   <tt><a>ue_renameUnitId</a> oldUnit newUnit UnitEnv</tt>, it is assumed
--   that the <tt>oldUnit</tt> exists in the map, otherwise we panic. The
--   <a>DynFlags</a> associated with the home unit will have its field
--   <a>homeUnitId</a> set to <tt>newUnit</tt>.
ue_renameUnitId :: HasDebugCallStack => UnitId -> UnitId -> UnitEnv -> UnitEnv
ue_transitiveHomeDeps :: UnitId -> UnitEnv -> [UnitId]
type HomeUnitGraph = UnitEnvGraph HomeUnitEnv
data HomeUnitEnv
HomeUnitEnv :: !UnitState -> !Maybe [UnitDatabase UnitId] -> DynFlags -> HomePackageTable -> !Maybe HomeUnit -> HomeUnitEnv

-- | External units
[homeUnitEnv_units] :: HomeUnitEnv -> !UnitState

-- | Stack of unit databases for the target platform.
--   
--   This field is populated with the result of <a>initUnits</a>.
--   
--   <a>Nothing</a> means the databases have never been read from disk.
--   
--   Usually we don't reload the databases from disk if they are cached,
--   even if the database flags changed!
[homeUnitEnv_unit_dbs] :: HomeUnitEnv -> !Maybe [UnitDatabase UnitId]

-- | The dynamic flag settings
[homeUnitEnv_dflags] :: HomeUnitEnv -> DynFlags

-- | The home package table describes already-compiled home-package
--   modules, <i>excluding</i> the module we are compiling right now. (In
--   one-shot mode the current module is the only home-package module, so
--   homeUnitEnv_hpt is empty. All other modules count as
--   "external-package" modules. However, even in GHCi mode, hi-boot
--   interfaces are demand-loaded into the external-package table.)
--   
--   <a>homeUnitEnv_hpt</a> is not mutable because we only demand-load
--   external packages; the home package is eagerly loaded, module by
--   module, by the compilation manager.
--   
--   The HPT may contain modules compiled earlier by <tt>--make</tt> but
--   not actually below the current module in the dependency graph.
--   
--   (This changes a previous invariant: changed Jan 05.)
[homeUnitEnv_hpt] :: HomeUnitEnv -> HomePackageTable

-- | Home-unit
[homeUnitEnv_home_unit] :: HomeUnitEnv -> !Maybe HomeUnit
mkHomeUnitEnv :: DynFlags -> HomePackageTable -> Maybe HomeUnit -> HomeUnitEnv
lookupHugByModule :: Module -> HomeUnitGraph -> Maybe HomeModInfo
hugElts :: HomeUnitGraph -> [(UnitId, HomeUnitEnv)]
lookupHug :: HomeUnitGraph -> UnitId -> ModuleName -> Maybe HomeModInfo
addHomeModInfoToHug :: HomeModInfo -> HomeUnitGraph -> HomeUnitGraph
newtype UnitEnvGraph v
UnitEnvGraph :: Map UnitEnvGraphKey v -> UnitEnvGraph v
[unitEnv_graph] :: UnitEnvGraph v -> Map UnitEnvGraphKey v
type UnitEnvGraphKey = UnitId
unitEnv_insert :: UnitEnvGraphKey -> v -> UnitEnvGraph v -> UnitEnvGraph v
unitEnv_delete :: UnitEnvGraphKey -> UnitEnvGraph v -> UnitEnvGraph v
unitEnv_adjust :: (v -> v) -> UnitEnvGraphKey -> UnitEnvGraph v -> UnitEnvGraph v
unitEnv_new :: Map UnitEnvGraphKey v -> UnitEnvGraph v
unitEnv_singleton :: UnitEnvGraphKey -> v -> UnitEnvGraph v
unitEnv_map :: (v -> v) -> UnitEnvGraph v -> UnitEnvGraph v
unitEnv_member :: UnitEnvGraphKey -> UnitEnvGraph v -> Bool
unitEnv_lookup_maybe :: UnitEnvGraphKey -> UnitEnvGraph v -> Maybe v
unitEnv_lookup :: UnitEnvGraphKey -> UnitEnvGraph v -> v
unitEnv_keys :: UnitEnvGraph v -> Set UnitEnvGraphKey
unitEnv_elts :: UnitEnvGraph v -> [(UnitEnvGraphKey, v)]
unitEnv_hpts :: UnitEnvGraph HomeUnitEnv -> [HomePackageTable]
unitEnv_foldWithKey :: (b -> UnitEnvGraphKey -> a -> b) -> b -> UnitEnvGraph a -> b
unitEnv_union :: (a -> a -> a) -> UnitEnvGraph a -> UnitEnvGraph a -> UnitEnvGraph a
unitEnv_mapWithKey :: (UnitEnvGraphKey -> v -> b) -> UnitEnvGraph v -> UnitEnvGraph b
assertUnitEnvInvariant :: HasDebugCallStack => UnitEnv -> UnitEnv

-- | Lookup <a>UnitInfo</a> for every preload unit from the UnitState and
--   for every unit used to instantiate the home unit.
preloadUnitsInfo :: UnitEnv -> MaybeErr UnitErr [UnitInfo]

-- | Lookup <a>UnitInfo</a> for every preload unit from the UnitState, for
--   every unit used to instantiate the home unit, and for every unit
--   explicitly passed in the given list of UnitId.
preloadUnitsInfo' :: UnitEnv -> [UnitId] -> MaybeErr UnitErr [UnitInfo]

-- | Test if the module comes from the home unit
isUnitEnvInstalledModule :: UnitEnv -> InstalledModule -> Bool
instance Data.Traversable.Traversable GHC.Unit.Env.UnitEnvGraph
instance Data.Foldable.Foldable GHC.Unit.Env.UnitEnvGraph
instance GHC.Base.Functor GHC.Unit.Env.UnitEnvGraph
instance GHC.Utils.Outputable.Outputable (GHC.Unit.Env.UnitEnvGraph GHC.Unit.Env.HomeUnitEnv)
instance GHC.Utils.Outputable.Outputable GHC.Unit.Env.HomeUnitEnv

module GHC.Types.Name.Ppr

-- | Creates some functions that work out the best ways to format names for
--   the user according to a set of heuristics.
mkNamePprCtx :: PromotionTickContext -> UnitEnv -> GlobalRdrEnv -> NamePprCtx

-- | Creates a function for formatting modules based on two heuristics: (1)
--   if the module is the current module, don't qualify, and (2) if there
--   is only one exposed package which exports this module, don't qualify.
mkQualModule :: UnitState -> Maybe HomeUnit -> QueryQualifyModule

-- | Creates a function for formatting packages based on two heuristics:
--   (1) don't qualify if the package in question is "main", and (2) only
--   qualify with a unit id if the package ID would be ambiguous.
mkQualPackage :: UnitState -> QueryQualifyPackage

-- | A function which only qualifies package names if necessary; but
--   qualifies all other identifiers.
pkgQual :: UnitState -> NamePprCtx


-- | Interacting with the iserv interpreter, whether it is running on an
--   external process or in the current process.
module GHC.Runtime.Interpreter
newtype BCOOpts
BCOOpts :: Int -> BCOOpts

-- | Number of parallel jobs doing BCO serialization
[bco_n_jobs] :: BCOOpts -> Int

-- | Execute an action of type <tt>IO [a]</tt>, returning
--   <a>ForeignHValue</a>s for each of the results.
evalStmt :: Interp -> EvalOpts -> EvalExpr ForeignHValue -> IO (EvalStatus_ [ForeignHValue] [HValueRef])
data () => EvalStatus_ a b
EvalComplete :: Word64 -> EvalResult a -> EvalStatus_ a b
EvalBreak :: Bool -> HValueRef -> Int -> String -> RemoteRef (ResumeContext b) -> RemotePtr CostCentreStack -> EvalStatus_ a b
type EvalStatus a = EvalStatus_ a a
data () => EvalResult a
EvalException :: SerializableException -> EvalResult a
EvalSuccess :: a -> EvalResult a

-- | We can pass simple expressions to EvalStmt, consisting of values and
--   application. This allows us to wrap the statement to be executed in
--   another function, which is used by GHCi to implement :set args and
--   :set prog. It might be worthwhile to extend this little language in
--   the future.
data () => EvalExpr a
EvalThis :: a -> EvalExpr a
EvalApp :: EvalExpr a -> EvalExpr a -> EvalExpr a
resumeStmt :: Interp -> EvalOpts -> ForeignRef (ResumeContext [HValueRef]) -> IO (EvalStatus_ [ForeignHValue] [HValueRef])
abandonStmt :: Interp -> ForeignRef (ResumeContext [HValueRef]) -> IO ()

-- | Execute an action of type <tt>IO ()</tt>
evalIO :: Interp -> ForeignHValue -> IO ()

-- | Execute an action of type <tt>IO String</tt>
evalString :: Interp -> ForeignHValue -> IO String

-- | Execute an action of type <tt>String -&gt; IO String</tt>
evalStringToIOString :: Interp -> ForeignHValue -> String -> IO String

-- | Allocate and store the given bytes in memory, returning a pointer to
--   the memory in the remote process.
mallocData :: Interp -> ByteString -> IO (RemotePtr ())

-- | Create a set of BCOs that may be mutually recursive.
createBCOs :: Interp -> BCOOpts -> [ResolvedBCO] -> IO [HValueRef]
addSptEntry :: Interp -> Fingerprint -> ForeignHValue -> IO ()
mkCostCentres :: Interp -> String -> [(String, String)] -> IO [RemotePtr CostCentre]
costCentreStackInfo :: Interp -> RemotePtr CostCentreStack -> IO [String]
newBreakArray :: Interp -> Int -> IO (ForeignRef BreakArray)
newModuleName :: Interp -> ModuleName -> IO (RemotePtr ModuleName)
storeBreakpoint :: Interp -> ForeignRef BreakArray -> Int -> Int -> IO ()
breakpointStatus :: Interp -> ForeignRef BreakArray -> Int -> IO Bool
getBreakpointVar :: Interp -> ForeignHValue -> Int -> IO (Maybe ForeignHValue)
getClosure :: Interp -> ForeignHValue -> IO (GenClosure ForeignHValue)
getModBreaks :: HomeModInfo -> ModBreaks

-- | Send a Seq message to the iserv process to force a value #2950
seqHValue :: Interp -> UnitEnv -> ForeignHValue -> IO (EvalResult ())

-- | Interpreter uses Dynamic way
interpreterDynamic :: Interp -> Bool

-- | Interpreter uses Profiling way
interpreterProfiled :: Interp -> Bool
initObjLinker :: Interp -> IO ()
lookupSymbol :: Interp -> FastString -> IO (Maybe (Ptr ()))
lookupClosure :: Interp -> String -> IO (Maybe HValueRef)

-- | loadDLL loads a dynamic library using the OS's native linker (i.e.
--   dlopen() on Unix, LoadLibrary() on Windows). It takes either an
--   absolute pathname to the file, or a relative filename (e.g.
--   "libfoo.so" or "foo.dll"). In the latter case, loadDLL searches the
--   standard locations for the appropriate library.
--   
--   Returns:
--   
--   Nothing =&gt; success Just err_msg =&gt; failure
loadDLL :: Interp -> String -> IO (Maybe String)
loadArchive :: Interp -> String -> IO ()
loadObj :: Interp -> String -> IO ()
unloadObj :: Interp -> String -> IO ()
addLibrarySearchPath :: Interp -> String -> IO (Ptr ())
removeLibrarySearchPath :: Interp -> Ptr () -> IO Bool
resolveObjs :: Interp -> IO SuccessFlag
findSystemLibrary :: Interp -> String -> IO (Maybe String)

-- | Run a command in the interpreter's context. With
--   <tt>-fexternal-interpreter</tt>, the command is serialized and sent to
--   an external iserv process, and the response is deserialized (hence the
--   <tt>Binary</tt> constraint). With <tt>-fno-external-interpreter</tt>
--   we execute the command directly here.
interpCmd :: Binary a => Interp -> Message a -> IO a

-- | A <tt>Message a</tt> is a message that returns a value of type
--   <tt>a</tt>. These are requests sent from GHC to the server.
data () => Message a

-- | Exit the iserv process
[Shutdown] :: Message ()
[RtsRevertCAFs] :: Message ()
[InitLinker] :: Message ()
[LookupSymbol] :: String -> Message (Maybe (RemotePtr ()))
[LookupClosure] :: String -> Message (Maybe HValueRef)
[LoadDLL] :: String -> Message (Maybe String)
[LoadArchive] :: String -> Message ()
[LoadObj] :: String -> Message ()
[UnloadObj] :: String -> Message ()
[AddLibrarySearchPath] :: String -> Message (RemotePtr ())
[RemoveLibrarySearchPath] :: RemotePtr () -> Message Bool
[ResolveObjs] :: Message Bool
[FindSystemLibrary] :: String -> Message (Maybe String)

-- | Create a set of BCO objects, and return HValueRefs to them Note: Each
--   ByteString contains a Binary-encoded [ResolvedBCO], not a ResolvedBCO.
--   The list is to allow us to serialise the ResolvedBCOs in parallel. See
--   <tt>createBCOs</tt> in compiler<i>GHC</i>Runtime/Interpreter.hs.
[CreateBCOs] :: [ByteString] -> Message [HValueRef]

-- | Release <a>HValueRef</a>s
[FreeHValueRefs] :: [HValueRef] -> Message ()

-- | Add entries to the Static Pointer Table
[AddSptEntry] :: Fingerprint -> HValueRef -> Message ()

-- | Malloc some data and return a <a>RemotePtr</a> to it
[MallocData] :: ByteString -> Message (RemotePtr ())
[MallocStrings] :: [ByteString] -> Message [RemotePtr ()]

-- | Calls <a>prepareForeignCall</a>
[PrepFFI] :: FFIConv -> [FFIType] -> FFIType -> Message (RemotePtr C_ffi_cif)

-- | Free data previously created by <a>PrepFFI</a>
[FreeFFI] :: RemotePtr C_ffi_cif -> Message ()

-- | Create an info table for a constructor
[MkConInfoTable] :: Bool -> Int -> Int -> Int -> Int -> ByteString -> Message (RemotePtr StgInfoTable)

-- | Evaluate a statement
[EvalStmt] :: EvalOpts -> EvalExpr HValueRef -> Message (EvalStatus_ [HValueRef] [HValueRef])

-- | Resume evaluation of a statement after a breakpoint
[ResumeStmt] :: EvalOpts -> RemoteRef (ResumeContext [HValueRef]) -> Message (EvalStatus_ [HValueRef] [HValueRef])

-- | Abandon evaluation of a statement after a breakpoint
[AbandonStmt] :: RemoteRef (ResumeContext [HValueRef]) -> Message ()

-- | Evaluate something of type <tt>IO String</tt>
[EvalString] :: HValueRef -> Message (EvalResult String)

-- | Evaluate something of type <tt>String -&gt; IO String</tt>
[EvalStringToString] :: HValueRef -> String -> Message (EvalResult String)

-- | Evaluate something of type <tt>IO ()</tt>
[EvalIO] :: HValueRef -> Message (EvalResult ())

-- | Create a set of CostCentres with the same module name
[MkCostCentres] :: String -> [(String, String)] -> Message [RemotePtr CostCentre]

-- | Show a <a>CostCentreStack</a> as a <tt>[String]</tt>
[CostCentreStackInfo] :: RemotePtr CostCentreStack -> Message [String]

-- | Create a new array of breakpoint flags
[NewBreakArray] :: Int -> Message (RemoteRef BreakArray)

-- | Set how many times a breakpoint should be ignored also used for
--   enable/disable
[SetupBreakpoint] :: RemoteRef BreakArray -> Int -> Int -> Message ()

-- | Query the status of a breakpoint (True <a>=</a> enabled)
[BreakpointStatus] :: RemoteRef BreakArray -> Int -> Message Bool

-- | Get a reference to a free variable at a breakpoint
[GetBreakpointVar] :: HValueRef -> Int -> Message (Maybe HValueRef)

-- | Start a new TH module, return a state token that should be
[StartTH] :: Message (RemoteRef (IORef QState))

-- | Evaluate a TH computation.
--   
--   Returns a ByteString, because we have to force the result before
--   returning it to ensure there are no errors lurking in it. The TH types
--   don't have NFData instances, and even if they did, we have to
--   serialize the value anyway, so we might as well serialize it to force
--   it.
[RunTH] :: RemoteRef (IORef QState) -> HValueRef -> THResultType -> Maybe Loc -> Message (QResult ByteString)

-- | Run the given mod finalizers.
[RunModFinalizers] :: RemoteRef (IORef QState) -> [RemoteRef (Q ())] -> Message (QResult ())

-- | Remote interface to GHC.Exts.Heap.getClosureData. This is used by the
--   GHCi debugger to inspect values in the heap for :print and type
--   reconstruction.
[GetClosure] :: HValueRef -> Message (GenClosure HValueRef)

-- | Evaluate something. This is used to support :force in GHCi.
[Seq] :: HValueRef -> Message (EvalStatus_ () ())

-- | Resume forcing a free variable in a breakpoint (#2950)
[ResumeSeq] :: RemoteRef (ResumeContext ()) -> Message (EvalStatus_ () ())

-- | Allocate a string for a breakpoint module name. This uses an empty
--   dummy type because <tt>ModuleName</tt> isn't available here.
[NewBreakModule] :: String -> Message (RemotePtr BreakModule)

-- | Grab a lock on the <a>IServ</a> and do something with it. Overloaded
--   because this is used from TcM as well as IO.
withIServ :: ExceptionMonad m => IServConfig -> IServ -> (IServInstance -> m (IServInstance, a)) -> m a
withIServ_ :: (MonadIO m, ExceptionMonad m) => IServConfig -> IServ -> (IServInstance -> m a) -> m a

-- | Stop the interpreter
stopInterp :: Interp -> IO ()

-- | Send a <a>Message</a> and receive the response from the iserv process
iservCall :: Binary a => IServInstance -> Message a -> IO a

-- | Read a value from the iserv process
readIServ :: IServInstance -> Get a -> IO a

-- | Send a value to the iserv process
writeIServ :: IServInstance -> Put -> IO ()
purgeLookupSymbolCache :: Interp -> IO ()
freeHValueRefs :: Interp -> [HValueRef] -> IO ()

-- | Creates a <a>ForeignRef</a> that will automatically release the
--   <a>RemoteRef</a> when it is no longer referenced.
mkFinalizedHValue :: Interp -> RemoteRef a -> IO (ForeignRef a)

-- | Convert a <a>ForeignRef</a> to the value it references directly. This
--   only works when the interpreter is running in the same process as the
--   compiler, so it fails when <tt>-fexternal-interpreter</tt> is on.
wormhole :: Interp -> ForeignRef a -> IO a

-- | Convert an <a>RemoteRef</a> to the value it references directly. This
--   only works when the interpreter is running in the same process as the
--   compiler, so it fails when <tt>-fexternal-interpreter</tt> is on.
wormholeRef :: Interp -> RemoteRef a -> IO a
fromEvalResult :: EvalResult a -> IO a

module GHC.HsToCore.Breakpoints
mkModBreaks :: Interp -> Module -> SizedSeq Tick -> IO ModBreaks


-- | Subsystem configuration
module GHC.Driver.Config

-- | Initialise coercion optimiser configuration from DynFlags
initOptCoercionOpts :: DynFlags -> OptCoercionOpts

-- | Initialise Simple optimiser configuration from DynFlags
initSimpleOpts :: DynFlags -> SimpleOpts

-- | Extract BCO options from DynFlags
initBCOOpts :: DynFlags -> IO BCOOpts

-- | Extract GHCi options from DynFlags and step
initEvalOpts :: DynFlags -> Bool -> EvalOpts

module GHC.Driver.Config.Core.Opt.WorkWrap
initWorkWrapOpts :: Module -> DynFlags -> FamInstEnvs -> WwOpts


-- | Bytecode assembler and linker
module GHC.ByteCode.Linker
linkBCO :: Interp -> LinkerEnv -> NameEnv Int -> RemoteRef BreakArray -> UnlinkedBCO -> IO ResolvedBCO
lookupStaticPtr :: Interp -> FastString -> IO (Ptr ())
lookupIE :: Interp -> ItblEnv -> Name -> IO (Ptr ())
nameToCLabel :: Name -> String -> FastString
linkFail :: String -> String -> IO a


-- | Generate infotables for interpreter-made bytecodes
module GHC.ByteCode.InfoTable
mkITbls :: Interp -> Profile -> [TyCon] -> IO ItblEnv


-- | Bytecode assembler and linker
module GHC.ByteCode.Asm
assembleBCOs :: Interp -> Profile -> [ProtoBCO Name] -> [TyCon] -> AddrEnv -> Maybe ModBreaks -> IO CompiledByteCode
assembleOneBCO :: Interp -> Profile -> ProtoBCO Name -> IO UnlinkedBCO

-- | Finds external references. Remember to remove the names defined by
--   this group of BCOs themselves
bcoFreeNames :: UnlinkedBCO -> UniqDSet Name
data () => SizedSeq a
sizeSS :: SizedSeq a -> Word
ssElts :: SizedSeq a -> [a]
iNTERP_STACK_CHECK_THRESH :: Int
mkNativeCallInfoLit :: Platform -> NativeCallInfo -> Literal
instance GHC.Base.Functor GHC.ByteCode.Asm.Assembler
instance GHC.Base.Applicative GHC.ByteCode.Asm.Assembler
instance GHC.Base.Monad GHC.ByteCode.Asm.Assembler

module GHC.Runtime.Context

-- | Interactive context, recording information about the state of the
--   context in which statements are executed in a GHCi session.
data InteractiveContext
InteractiveContext :: DynFlags -> Int -> [InteractiveImport] -> [TyThing] -> IcGlobalRdrEnv -> (InstEnv, [FamInst]) -> FixityEnv -> Maybe [Type] -> [Resume] -> Name -> Name -> Maybe FilePath -> !Plugins -> InteractiveContext

-- | The <a>DynFlags</a> used to evaluate interactive expressions and
--   statements.
[ic_dflags] :: InteractiveContext -> DynFlags

-- | Each GHCi stmt or declaration brings some new things into scope. We
--   give them names like interactive:Ghci9.T, where the ic_index is the
--   '9'. The ic_mod_index is incremented whenever we add something to
--   ic_tythings See Note [The interactive package]
[ic_mod_index] :: InteractiveContext -> Int

-- | The GHCi top-level scope (icReaderEnv) is extended with these imports
--   
--   This field is only stored here so that the client can retrieve it with
--   GHC.getContext. GHC itself doesn't use it, but does reset it to empty
--   sometimes (such as before a GHC.load). The context is set with
--   GHC.setContext.
[ic_imports] :: InteractiveContext -> [InteractiveImport]

-- | TyThings defined by the user, in reverse order of definition (ie most
--   recent at the front). Also used in GHC.Tc.Module.runTcInteractive to
--   fill the type checker environment. See Note [ic_tythings]
[ic_tythings] :: InteractiveContext -> [TyThing]

-- | Essentially the cached <a>GlobalRdrEnv</a>.
--   
--   The GlobalRdrEnv contains everything in scope at the command line,
--   both imported and everything in ic_tythings, with the correct
--   shadowing.
--   
--   The IcGlobalRdrEnv contains extra data to allow efficient
--   recalculation when the set of imports change. See Note [icReaderEnv
--   recalculation]
[ic_gre_cache] :: InteractiveContext -> IcGlobalRdrEnv

-- | All instances and family instances created during this session. These
--   are grabbed en masse after each update to be sure that proper
--   overlapping is retained. That is, rather than re-check the overlapping
--   each time we update the context, we just take the results from the
--   instance code that already does that.
[ic_instances] :: InteractiveContext -> (InstEnv, [FamInst])

-- | Fixities declared in let statements
[ic_fix_env] :: InteractiveContext -> FixityEnv

-- | The current default types, set by a 'default' declaration
[ic_default] :: InteractiveContext -> Maybe [Type]

-- | The stack of breakpoint contexts
[ic_resume] :: InteractiveContext -> [Resume]

-- | The monad that GHCi is executing in
[ic_monad] :: InteractiveContext -> Name

-- | The function that is used for printing results of expressions in ghci
--   and -e mode.
[ic_int_print] :: InteractiveContext -> Name

-- | virtual CWD of the program
[ic_cwd] :: InteractiveContext -> Maybe FilePath

-- | Cache of loaded plugins. We store them here to avoid having to load
--   them every time we switch to the interactive context.
[ic_plugins] :: InteractiveContext -> !Plugins
data InteractiveImport

-- | Bring the exports of a particular module (filtered by an import decl)
--   into scope
IIDecl :: ImportDecl GhcPs -> InteractiveImport

-- | Bring into scope the entire top-level envt of of this module,
--   including the things imported into it.
IIModule :: ModuleName -> InteractiveImport

-- | Constructs an empty InteractiveContext.
emptyInteractiveContext :: DynFlags -> InteractiveContext

-- | extendInteractiveContext is called with new TyThings recently defined
--   to update the InteractiveContext to include them. By putting new
--   things first, unqualified use will pick the most recently defined
--   thing with a given name, while still keeping the old names in scope in
--   their qualified form (Ghci1.foo).
extendInteractiveContext :: InteractiveContext -> [TyThing] -> InstEnv -> [FamInst] -> Maybe [Type] -> FixityEnv -> InteractiveContext
extendInteractiveContextWithIds :: InteractiveContext -> [Id] -> InteractiveContext
setInteractivePrintName :: InteractiveContext -> Name -> InteractiveContext
substInteractiveContext :: InteractiveContext -> Subst -> InteractiveContext
replaceImportEnv :: IcGlobalRdrEnv -> GlobalRdrEnv -> IcGlobalRdrEnv
icReaderEnv :: InteractiveContext -> GlobalRdrEnv
icInteractiveModule :: InteractiveContext -> Module

-- | This function returns the list of visible TyThings (useful for e.g.
--   showBindings).
--   
--   It picks only those TyThings that are not shadowed by later
--   definitions on the interpreter, to not clutter :showBindings with
--   shadowed ids, which would show up as Ghci9.foo.
--   
--   Some TyThings define many names; we include them if _any_ name is
--   still available unqualified.
icInScopeTTs :: InteractiveContext -> [TyThing]

-- | Get the NamePprCtx function based on the flags and this
--   InteractiveContext
icNamePprCtx :: UnitEnv -> InteractiveContext -> NamePprCtx
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Context.InteractiveImport

module GHC.Core.Lint.Interactive
interactiveInScope :: InteractiveContext -> [Var]


-- | Linking Haskell units
module GHC.Linker.Unit
collectLinkOpts :: GhcNameVersion -> Ways -> [UnitInfo] -> ([String], [String], [String])
collectArchives :: GhcNameVersion -> Ways -> UnitInfo -> IO [FilePath]

-- | Find all the link options in these and the preload packages, returning
--   (package hs lib options, extra library options, other flags)
getUnitLinkOpts :: GhcNameVersion -> Ways -> UnitEnv -> [UnitId] -> IO ([String], [String], [String])
getLibs :: GhcNameVersion -> Ways -> UnitEnv -> [UnitId] -> IO [(String, String)]

module GHC.Linker.MacOS

-- | On macOS we rely on the linkers <tt>-dead_strip_dylibs</tt> flag to
--   remove unused libraries from the dynamic library. We do this to reduce
--   the number of load commands that end up in the dylib, and has been
--   limited to 32K (32768) since macOS Sierra (10.14).
--   
--   <tt>-dead_strip_dylibs</tt> does not dead strip <tt>-rpath</tt>
--   entries, as such passing <tt>-l</tt> and <tt>-rpath</tt> to the linker
--   will result in the unnecessary libraries not being included in the
--   load commands, however the <tt>-rpath</tt> entries are all forced to
--   be included. This can lead to 100s of <tt>-rpath</tt> entries being
--   included when only a handful of libraries end up being truly linked.
--   
--   Thus after building the library, we run a fixup phase where we inject
--   the <tt>-rpath</tt> for each found library (in the given library
--   search paths) into the dynamic library through <tt>-add_rpath</tt>.
--   
--   See Note [Dynamic linking on macOS]
runInjectRPaths :: Logger -> ToolSettings -> [FilePath] -> FilePath -> IO ()
getUnitFrameworkOpts :: UnitEnv -> [UnitId] -> IO [String]
getFrameworkOpts :: FrameworkOpts -> Platform -> [String]
loadFramework :: Interp -> [FilePath] -> FilePath -> IO (Maybe String)

module GHC.Linker.ExtraObj
mkExtraObj :: Logger -> TmpFs -> DynFlags -> UnitState -> Suffix -> String -> IO FilePath
mkExtraObjToLinkIntoBinary :: Logger -> TmpFs -> DynFlags -> UnitState -> IO (Maybe FilePath)
mkNoteObjsToLinkIntoBinary :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [UnitId] -> IO [FilePath]
checkLinkInfo :: Logger -> DynFlags -> UnitEnv -> [UnitId] -> FilePath -> IO Bool

-- | Return the "link info" string
--   
--   See Note [LinkInfo section]
getLinkInfo :: DynFlags -> UnitEnv -> [UnitId] -> IO String

-- | Grab compiler info and cache it in DynFlags.
getCompilerInfo :: Logger -> DynFlags -> IO CompilerInfo
ghcLinkInfoSectionName :: String
ghcLinkInfoNoteName :: String
platformSupportsSavingLinkOpts :: OS -> Bool
haveRtsOptsFlags :: DynFlags -> Bool

module GHC.SysTools
initSysTools :: String -> IO Settings

-- | Copy a file with its permissions. If the destination file already
--   exists, it is replaced atomically. Neither path may refer to an
--   existing directory. No exceptions are thrown if the permissions could
--   not be copied.
copyFile :: FilePath -> FilePath -> IO ()

-- | Copy remaining bytes from the first Handle to the second one
copyHandle :: Handle -> Handle -> IO ()

-- | Copy file after printing the given header
copyWithHeader :: String -> FilePath -> FilePath -> IO ()

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option

-- | Expand occurrences of the <tt>$topdir</tt> interpolation in a string.
expandTopDir :: FilePath -> String -> String

module GHC.SysTools.Cpp

-- | Run CPP
--   
--   UnitEnv is needed to compute MIN_VERSION macros
doCpp :: Logger -> TmpFs -> DynFlags -> UnitEnv -> CppOpts -> FilePath -> FilePath -> IO ()
data CppOpts
CppOpts :: !Bool -> !Bool -> CppOpts

-- | Use "cc -E" as preprocessor, otherwise use "cpp"
[cppUseCc] :: CppOpts -> !Bool

-- | Enable generation of LINE pragmas
[cppLinePragmas] :: CppOpts -> !Bool

-- | Find out path to <tt>ghcversion.h</tt> file
getGhcVersionPathName :: DynFlags -> UnitEnv -> IO FilePath
applyCDefs :: DefunctionalizedCDefs -> Logger -> DynFlags -> IO [String]
offsetIncludePaths :: DynFlags -> IncludeSpecs -> IncludeSpecs


-- | GHCJS linker, collects dependencies from the object files which
--   contain linkable units with dependency information
module GHC.StgToJS.Linker.Linker
jsLinkBinary :: JSLinkConfig -> StgToJSConfig -> [FilePath] -> Logger -> DynFlags -> UnitEnv -> [FilePath] -> [UnitId] -> IO ()

-- | Embed a JS file into a .o file
--   
--   The JS file is merely copied into a .o file with an additional header
--   ("//Javascript") in order to be recognized later on.
--   
--   JS files may contain option pragmas of the form: //#OPTIONS: For now,
--   only the CPP option is supported. If the CPP option is set, we append
--   some common CPP definitions to the file and call cpp on it.
embedJsFile :: Logger -> DynFlags -> TmpFs -> UnitEnv -> FilePath -> FilePath -> IO ()

module GHC.Linker.Windows
maybeCreateManifest :: Logger -> TmpFs -> DynFlags -> FilePath -> IO [FilePath]


-- | Dynamic linker
module GHC.Linker.Dynamic
linkDynLib :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [String] -> [UnitId] -> IO ()

-- | Some platforms require that we explicitly link against <tt>libm</tt>
--   if any math-y things are used (which we assume to include all
--   programs). See #14022.
libmLinkOpts :: Platform -> [Option]

module GHC.Linker.Static
linkBinary :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [FilePath] -> [UnitId] -> IO ()

-- | Linking a static lib will not really link anything. It will merely
--   produce a static archive of all dependent static libraries. The
--   resulting library will still need to be linked with any remaining link
--   flags.
linkStaticLib :: Logger -> DynFlags -> UnitEnv -> [String] -> [UnitId] -> IO ()

module GHC.Driver.Env.Types

-- | The Hsc monad: Passing an environment and diagnostic state
newtype Hsc a
Hsc :: (HscEnv -> Messages GhcMessage -> IO (a, Messages GhcMessage)) -> Hsc a

-- | HscEnv is like <a>Session</a>, except that some of the fields are
--   immutable. An HscEnv is used to compile a single module from plain
--   Haskell source code (after preprocessing) to either C, assembly or
--   C--. It's also used to store the dynamic linker state to allow for
--   multiple linkers in the same address space. Things like the module
--   graph don't change during a single compilation.
--   
--   Historical note: "hsc" used to be the name of the compiler binary,
--   when there was a separate driver and compiler. To compile a single
--   module, the driver would invoke hsc on the source code... so nowadays
--   we think of hsc as the layer of the compiler that deals with compiling
--   a single module.
data HscEnv
HscEnv :: DynFlags -> [Target] -> ModuleGraph -> InteractiveContext -> {-# UNPACK #-} !NameCache -> {-# UNPACK #-} !FinderCache -> KnotVars (IORef TypeEnv) -> Maybe Interp -> !Plugins -> UnitEnv -> !Logger -> !Hooks -> !TmpFs -> !LlvmConfigCache -> HscEnv

-- | The dynamic flag settings
[hsc_dflags] :: HscEnv -> DynFlags

-- | The targets (or roots) of the current session
[hsc_targets] :: HscEnv -> [Target]

-- | The module graph of the current session
[hsc_mod_graph] :: HscEnv -> ModuleGraph

-- | The context for evaluating interactive statements
[hsc_IC] :: HscEnv -> InteractiveContext

-- | Global Name cache so that each Name gets a single Unique. Also track
--   the origin of the Names.
[hsc_NC] :: HscEnv -> {-# UNPACK #-} !NameCache

-- | The cached result of performing finding in the file system
[hsc_FC] :: HscEnv -> {-# UNPACK #-} !FinderCache

-- | Used for one-shot compilation only, to initialise the
--   <tt>IfGblEnv</tt>. See <a>tcg_type_env_var</a> for <a>TcGblEnv</a>.
--   See also Note [hsc_type_env_var hack]
[hsc_type_env_vars] :: HscEnv -> KnotVars (IORef TypeEnv)

-- | target code interpreter (if any) to use for TH and GHCi. See Note
--   [Target code interpreter]
[hsc_interp] :: HscEnv -> Maybe Interp

-- | Plugins
[hsc_plugins] :: HscEnv -> !Plugins

-- | Unit environment (unit state, home unit, etc.).
--   
--   Initialized from the databases cached in <tt>hsc_unit_dbs</tt> and
--   from the DynFlags.
[hsc_unit_env] :: HscEnv -> UnitEnv

-- | Logger with its flags.
--   
--   Don't forget to update the logger flags if the logging related
--   DynFlags change. Or better, use hscSetFlags setter which does it.
[hsc_logger] :: HscEnv -> !Logger

-- | Hooks
[hsc_hooks] :: HscEnv -> !Hooks

-- | Temporary files
[hsc_tmpfs] :: HscEnv -> !TmpFs

-- | LLVM configuration cache.
[hsc_llvm_config] :: HscEnv -> !LlvmConfigCache
instance Control.Monad.IO.Class.MonadIO GHC.Driver.Env.Types.Hsc
instance GHC.Base.Monad GHC.Driver.Env.Types.Hsc
instance GHC.Base.Applicative GHC.Driver.Env.Types.Hsc
instance GHC.Base.Functor GHC.Driver.Env.Types.Hsc
instance GHC.Driver.Session.HasDynFlags GHC.Driver.Env.Types.Hsc
instance GHC.Utils.Logger.HasLogger GHC.Driver.Env.Types.Hsc
instance GHC.Driver.Session.ContainsDynFlags GHC.Driver.Env.Types.HscEnv

module GHC.Driver.Env

-- | The Hsc monad: Passing an environment and diagnostic state
newtype Hsc a
Hsc :: (HscEnv -> Messages GhcMessage -> IO (a, Messages GhcMessage)) -> Hsc a

-- | HscEnv is like <a>Session</a>, except that some of the fields are
--   immutable. An HscEnv is used to compile a single module from plain
--   Haskell source code (after preprocessing) to either C, assembly or
--   C--. It's also used to store the dynamic linker state to allow for
--   multiple linkers in the same address space. Things like the module
--   graph don't change during a single compilation.
--   
--   Historical note: "hsc" used to be the name of the compiler binary,
--   when there was a separate driver and compiler. To compile a single
--   module, the driver would invoke hsc on the source code... so nowadays
--   we think of hsc as the layer of the compiler that deals with compiling
--   a single module.
data HscEnv
HscEnv :: DynFlags -> [Target] -> ModuleGraph -> InteractiveContext -> {-# UNPACK #-} !NameCache -> {-# UNPACK #-} !FinderCache -> KnotVars (IORef TypeEnv) -> Maybe Interp -> !Plugins -> UnitEnv -> !Logger -> !Hooks -> !TmpFs -> !LlvmConfigCache -> HscEnv

-- | The dynamic flag settings
[hsc_dflags] :: HscEnv -> DynFlags

-- | The targets (or roots) of the current session
[hsc_targets] :: HscEnv -> [Target]

-- | The module graph of the current session
[hsc_mod_graph] :: HscEnv -> ModuleGraph

-- | The context for evaluating interactive statements
[hsc_IC] :: HscEnv -> InteractiveContext

-- | Global Name cache so that each Name gets a single Unique. Also track
--   the origin of the Names.
[hsc_NC] :: HscEnv -> {-# UNPACK #-} !NameCache

-- | The cached result of performing finding in the file system
[hsc_FC] :: HscEnv -> {-# UNPACK #-} !FinderCache

-- | Used for one-shot compilation only, to initialise the
--   <tt>IfGblEnv</tt>. See <a>tcg_type_env_var</a> for <a>TcGblEnv</a>.
--   See also Note [hsc_type_env_var hack]
[hsc_type_env_vars] :: HscEnv -> KnotVars (IORef TypeEnv)

-- | target code interpreter (if any) to use for TH and GHCi. See Note
--   [Target code interpreter]
[hsc_interp] :: HscEnv -> Maybe Interp

-- | Plugins
[hsc_plugins] :: HscEnv -> !Plugins

-- | Unit environment (unit state, home unit, etc.).
--   
--   Initialized from the databases cached in <tt>hsc_unit_dbs</tt> and
--   from the DynFlags.
[hsc_unit_env] :: HscEnv -> UnitEnv

-- | Logger with its flags.
--   
--   Don't forget to update the logger flags if the logging related
--   DynFlags change. Or better, use hscSetFlags setter which does it.
[hsc_logger] :: HscEnv -> !Logger

-- | Hooks
[hsc_hooks] :: HscEnv -> !Hooks

-- | Temporary files
[hsc_tmpfs] :: HscEnv -> !TmpFs

-- | LLVM configuration cache.
[hsc_llvm_config] :: HscEnv -> !LlvmConfigCache

-- | Update Flags
hscUpdateFlags :: (DynFlags -> DynFlags) -> HscEnv -> HscEnv

-- | Set Flags
hscSetFlags :: HasDebugCallStack => DynFlags -> HscEnv -> HscEnv
hsc_home_unit :: HscEnv -> HomeUnit
hsc_home_unit_maybe :: HscEnv -> Maybe HomeUnit
hsc_units :: HasDebugCallStack => HscEnv -> UnitState
hsc_HPT :: HscEnv -> HomePackageTable
hsc_HUE :: HscEnv -> HomeUnitEnv
hsc_HUG :: HscEnv -> HomeUnitGraph
hsc_all_home_unit_ids :: HscEnv -> Set UnitId

-- | Update the LogFlags of the Log in hsc_logger from the DynFlags in
--   hsc_dflags. You need to call this when DynFlags are modified.
hscUpdateLoggerFlags :: HscEnv -> HscEnv
hscUpdateHUG :: (HomeUnitGraph -> HomeUnitGraph) -> HscEnv -> HscEnv
hscUpdateHPT_lazy :: (HomePackageTable -> HomePackageTable) -> HscEnv -> HscEnv
hscUpdateHPT :: (HomePackageTable -> HomePackageTable) -> HscEnv -> HscEnv
hscSetActiveHomeUnit :: HasDebugCallStack => HomeUnit -> HscEnv -> HscEnv
hscSetActiveUnitId :: HasDebugCallStack => UnitId -> HscEnv -> HscEnv
hscActiveUnitId :: HscEnv -> UnitId
runHsc :: HscEnv -> Hsc a -> IO a
runHsc' :: HscEnv -> Hsc a -> IO (a, Messages GhcMessage)

-- | Switches in the DynFlags and Plugins from the InteractiveContext
mkInteractiveHscEnv :: HscEnv -> HscEnv

-- | A variant of runHsc that switches in the DynFlags and Plugins from the
--   InteractiveContext before running the Hsc computation.
runInteractiveHsc :: HscEnv -> Hsc a -> IO a

-- | Retrieve the ExternalPackageState cache.
hscEPS :: HscEnv -> IO ExternalPackageState

-- | Retrieve the target code interpreter
--   
--   Fails if no target code interpreter is available
hscInterp :: HscEnv -> Interp
hptCompleteSigs :: HscEnv -> [CompleteMatch]

-- | Find all the instance declarations (of classes and families) from the
--   Home Package Table filtered by the provided predicate function. Used
--   in <tt>tcRnImports</tt>, to select the instances that are in the
--   transitive closure of imports from the currently compiled module.
hptAllInstances :: HscEnv -> (InstEnv, [FamInst])

-- | Find instances visible from the given set of imports
hptInstancesBelow :: HscEnv -> UnitId -> ModuleNameWithIsBoot -> (InstEnv, [FamInst])

-- | Get annotations from modules "below" this one (in the dependency
--   sense)
hptAnns :: HscEnv -> Maybe (UnitId, ModuleNameWithIsBoot) -> [Annotation]
hptAllThings :: (HomeModInfo -> [a]) -> HscEnv -> [a]

-- | Get things from modules "below" this one (in the dependency sense) C.f
--   Inst.hptInstances
hptSomeThingsBelowUs :: (HomeModInfo -> [a]) -> Bool -> HscEnv -> UnitId -> ModuleNameWithIsBoot -> [a]

-- | Get rules from modules "below" this one (in the dependency sense)
hptRules :: HscEnv -> UnitId -> ModuleNameWithIsBoot -> [CoreRule]

-- | Deal with gathering annotations in from all possible places and
--   combining them into a single <a>AnnEnv</a>
prepareAnnotations :: HscEnv -> Maybe ModGuts -> IO AnnEnv

-- | Discard the contents of the InteractiveContext, but keep the DynFlags
--   and the loaded plugins. It will also keep ic_int_print and ic_monad if
--   their names are from external packages.
discardIC :: HscEnv -> HscEnv

-- | Find the <a>TyThing</a> for the given <a>Name</a> by using all the
--   resources at our disposal: the compiled modules in the
--   <a>HomePackageTable</a> and the compiled modules in other packages
--   that live in <a>PackageTypeEnv</a>. Note that this does NOT look up
--   the <a>TyThing</a> in the module being compiled: you have to do that
--   yourself, if desired
lookupType :: HscEnv -> Name -> IO (Maybe TyThing)

-- | Find the <a>ModIface</a> for a <a>GenModule</a>, searching in both the
--   loaded home and external package module information
lookupIfaceByModule :: HomeUnitGraph -> PackageIfaceTable -> Module -> Maybe ModIface
mainModIs :: HomeUnitEnv -> Module


-- | Module finder
module GHC.Unit.Finder

-- | The result of searching for an imported module.
--   
--   NB: FindResult manages both user source-import lookups (which can
--   result in <a>GenModule</a>) as well as direct imports for interfaces
--   (which always result in <a>InstalledModule</a>).
data FindResult

-- | The module was found
Found :: ModLocation -> Module -> FindResult

-- | The requested unit was not found
NoPackage :: Unit -> FindResult

-- | _Error_: both in multiple packages
FoundMultiple :: [(Module, ModuleOrigin)] -> FindResult

-- | Not found
NotFound :: [FilePath] -> Maybe Unit -> [Unit] -> [Unit] -> [UnusableUnit] -> [ModuleSuggestion] -> FindResult

-- | Places where I looked
[fr_paths] :: FindResult -> [FilePath]

-- | Just p =&gt; module is in this unit's manifest, but couldn't find the
--   .hi file
[fr_pkg] :: FindResult -> Maybe Unit

-- | Module is in these units, but the *module* is hidden
[fr_mods_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but the *unit* is hidden
[fr_pkgs_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but it is unusable
[fr_unusables] :: FindResult -> [UnusableUnit]

-- | Possible mis-spelled modules
[fr_suggestions] :: FindResult -> [ModuleSuggestion]
data InstalledFindResult
InstalledFound :: ModLocation -> InstalledModule -> InstalledFindResult
InstalledNoPackage :: UnitId -> InstalledFindResult
InstalledNotFound :: [FilePath] -> Maybe UnitId -> InstalledFindResult

-- | Locations and information the finder cares about.
--   
--   Should be taken from <tt>DynFlags</tt> via <tt>initFinderOpts</tt>.
data FinderOpts
FinderOpts :: [FilePath] -> Bool -> Bool -> Ways -> Bool -> Maybe FilePath -> Maybe FastString -> Set ModuleName -> Set ModuleName -> Maybe FilePath -> String -> Maybe FilePath -> String -> String -> Maybe FilePath -> String -> String -> Maybe FilePath -> FinderOpts

-- | Where are we allowed to look for Modules and Source files
[finder_importPaths] :: FinderOpts -> [FilePath]

-- | When looking up a home module:
--   
--   <ul>
--   <li><a>True</a>: search interface files (e.g. in '-c' mode)</li>
--   <li><a>False</a>: search source files (e.g. in '--make' mode)</li>
--   </ul>
[finder_lookupHomeInterfaces] :: FinderOpts -> Bool

-- | Don't check that an imported interface file actually exists if it can
--   only be at one location. The interface will be reported as
--   <a>InstalledFound</a> even if the file doesn't exist, so this is only
--   useful in specific cases (e.g. to generate dependencies with `ghc -M`)
[finder_bypassHiFileCheck] :: FinderOpts -> Bool
[finder_ways] :: FinderOpts -> Ways

-- | If we encounter unknown modules, should we suggest modules that have a
--   similar name.
[finder_enableSuggestions] :: FinderOpts -> Bool
[finder_workingDirectory] :: FinderOpts -> Maybe FilePath
[finder_thisPackageName] :: FinderOpts -> Maybe FastString
[finder_hiddenModules] :: FinderOpts -> Set ModuleName
[finder_reexportedModules] :: FinderOpts -> Set ModuleName
[finder_hieDir] :: FinderOpts -> Maybe FilePath
[finder_hieSuf] :: FinderOpts -> String
[finder_hiDir] :: FinderOpts -> Maybe FilePath
[finder_hiSuf] :: FinderOpts -> String
[finder_dynHiSuf] :: FinderOpts -> String
[finder_objectDir] :: FinderOpts -> Maybe FilePath
[finder_objectSuf] :: FinderOpts -> String
[finder_dynObjectSuf] :: FinderOpts -> String
[finder_stubDir] :: FinderOpts -> Maybe FilePath
data FinderCache
initFinderCache :: IO FinderCache
flushFinderCaches :: FinderCache -> UnitEnv -> IO ()

-- | Locate a module that was imported by the user. We have the module's
--   name, and possibly a package name. Without a package name, this
--   function will use the search path and the known exposed packages to
--   find the module, if a package is specified then only that package is
--   searched for the module.
findImportedModule :: HscEnv -> ModuleName -> PkgQual -> IO FindResult

-- | Locate a plugin module requested by the user, for a compiler plugin.
--   This consults the same set of exposed packages as
--   <a>findImportedModule</a>, unless <tt>-hide-all-plugin-packages</tt>
--   or <tt>-plugin-package</tt> are specified.
findPluginModule :: FinderCache -> FinderOpts -> UnitState -> Maybe HomeUnit -> ModuleName -> IO FindResult

-- | Locate a specific <a>GenModule</a>. The purpose of this function is to
--   create a <a>ModLocation</a> for a given <a>GenModule</a>, that is to
--   find out where the files associated with this module live. It is used
--   when reading the interface for a module mentioned by another
--   interface, for example (a "system import").
findExactModule :: FinderCache -> FinderOpts -> UnitEnvGraph FinderOpts -> UnitState -> Maybe HomeUnit -> InstalledModule -> IO InstalledFindResult
findHomeModule :: FinderCache -> FinderOpts -> HomeUnit -> ModuleName -> IO FindResult
findExposedPackageModule :: FinderCache -> FinderOpts -> UnitState -> ModuleName -> PkgQual -> IO FindResult
mkHomeModLocation :: FinderOpts -> ModuleName -> FilePath -> ModLocation
mkHomeModLocation2 :: FinderOpts -> ModuleName -> FilePath -> String -> ModLocation
mkHiOnlyModLocation :: FinderOpts -> Suffix -> Suffix -> FilePath -> String -> ModLocation

-- | Constructs the filename of a .hi file for a given source file. Does
--   <i>not</i> check whether the .hi file exists
mkHiPath :: FinderOpts -> FilePath -> String -> FilePath

-- | Constructs the filename of a .o file for a given source file. Does
--   <i>not</i> check whether the .o file exists
mkObjPath :: FinderOpts -> FilePath -> String -> FilePath
addModuleToFinder :: FinderCache -> Module -> ModLocation -> IO ()
addHomeModuleToFinder :: FinderCache -> HomeUnit -> ModuleName -> ModLocation -> IO Module
uncacheModule :: FinderCache -> HomeUnit -> ModuleName -> IO ()
mkStubPaths :: FinderOpts -> ModuleName -> ModLocation -> FilePath
findObjectLinkableMaybe :: Module -> ModLocation -> IO (Maybe Linkable)
findObjectLinkable :: Module -> FilePath -> UTCTime -> IO Linkable
lookupFileCache :: FinderCache -> FilePath -> IO Fingerprint

module GHC.Driver.CodeOutput
codeOutput :: forall a. Logger -> TmpFs -> LlvmConfigCache -> DynFlags -> UnitState -> Module -> FilePath -> ModLocation -> (a -> ForeignStubs) -> [(ForeignSrcLang, FilePath)] -> Set UnitId -> Stream IO RawCmmGroup a -> IO (FilePath, (Bool, Maybe FilePath), [(ForeignSrcLang, FilePath)], a)
outputForeignStubs :: Logger -> TmpFs -> DynFlags -> UnitState -> Module -> ModLocation -> ForeignStubs -> IO (Bool, Maybe FilePath)

-- | Generate code to initialise cost centres
profilingInitCode :: Platform -> Module -> CollectedCCs -> CStub

-- | Generate code to initialise info pointer origin See Note [Mapping Info
--   Tables to Source Positions]
ipInitCode :: Bool -> Platform -> Module -> CStub

module GHC.StgToCmm.Prof
initCostCentres :: CollectedCCs -> FCode ()
ccType :: Platform -> CmmType
ccsType :: Platform -> CmmType
mkCCostCentre :: CostCentre -> CmmLit
mkCCostCentreStack :: CostCentreStack -> CmmLit

-- | Emit info-table provenance declarations and track IPE stats.
--   
--   Note that the stats passed to this function will (rather, should) only
--   ever contain stats for skipped STACK info tables accumulated in
--   <tt>generateCgIPEStub</tt>.
initInfoTableProv :: IPEStats -> [CmmInfoTable] -> InfoTableProvMap -> FCode (Maybe (IPEStats, CStub))

-- | Profiling header words in a dynamic closure
dynProfHdr :: Profile -> CmmExpr -> [CmmExpr]

-- | Record the allocation of a closure. The CmmExpr is the cost centre
--   stack to which to attribute the allocation.
profDynAlloc :: SMRep -> CmmExpr -> FCode ()

-- | Record the allocation of a closure (size is given by a CmmExpr) The
--   size must be in words, because the allocation counter in a CCS counts
--   in words.
profAlloc :: CmmExpr -> CmmExpr -> FCode ()

-- | The profiling header words in a static closure
staticProfHdr :: Profile -> CostCentreStack -> [CmmLit]

-- | Initialise the profiling field of an update frame
initUpdFrameProf :: CmmExpr -> FCode ()
enterCostCentreThunk :: CmmExpr -> FCode ()
enterCostCentreFun :: CostCentreStack -> CmmExpr -> FCode ()
costCentreFrom :: Platform -> CmmExpr -> CmmExpr
storeCurCCS :: CmmExpr -> CmmAGraph
emitSetCCC :: CostCentre -> Bool -> Bool -> FCode ()
saveCurrentCostCentre :: FCode (Maybe LocalReg)
restoreCurrentCostCentre :: Maybe LocalReg -> FCode ()
ldvEnter :: CmmExpr -> FCode ()

-- | Called when a closure is entered, marks the closure as having been
--   "used". The closure is not an "inherently used" one. The closure is
--   not <tt>IND</tt> because that is not considered for LDV profiling.
ldvEnterClosure :: ClosureInfo -> CmmReg -> FCode ()
ldvRecordCreate :: CmmExpr -> FCode ()

module GHC.StgToCmm.Heap
getVirtHp :: FCode VirtualHpOffset
setVirtHp :: VirtualHpOffset -> FCode ()
setRealHp :: VirtualHpOffset -> FCode ()
getHpRelOffset :: VirtualHpOffset -> FCode CmmExpr
entryHeapCheck :: ClosureInfo -> Maybe LocalReg -> Int -> [LocalReg] -> FCode () -> FCode ()
altHeapCheck :: [LocalReg] -> FCode a -> FCode a
noEscapeHeapCheck :: [LocalReg] -> FCode a -> FCode a
altHeapCheckReturnsTo :: [LocalReg] -> Label -> ByteOff -> FCode a -> FCode a
heapStackCheckGen :: Maybe CmmExpr -> Maybe CmmExpr -> FCode ()

-- | lower-level version for <a>GHC.Cmm.Parser</a>
entryHeapCheck' :: Bool -> CmmExpr -> Int -> [LocalReg] -> FCode () -> FCode ()

-- | Make a static closure, adding on any extra padding needed for CAFs,
--   and adding a static link field if necessary.
mkStaticClosureFields :: Profile -> CmmInfoTable -> CostCentreStack -> CafInfo -> [CmmLit] -> [CmmLit] -> [CmmLit]
mkStaticClosure :: Profile -> CLabel -> CostCentreStack -> [CmmLit] -> [CmmLit] -> [CmmLit] -> [CmmLit] -> [CmmLit] -> [CmmLit]
allocDynClosure :: Maybe Id -> CmmInfoTable -> LambdaFormInfo -> CmmExpr -> CmmExpr -> [(NonVoid StgArg, VirtualHpOffset)] -> FCode CmmExpr
allocDynClosureCmm :: Maybe Id -> CmmInfoTable -> LambdaFormInfo -> CmmExpr -> CmmExpr -> [(CmmExpr, ByteOff)] -> FCode CmmExpr

-- | Low-level heap object allocation.
allocHeapClosure :: SMRep -> CmmExpr -> CmmExpr -> [(CmmExpr, ByteOff)] -> FCode CmmExpr
emitSetDynHdr :: CmmExpr -> CmmExpr -> CmmExpr -> FCode ()

module GHC.Cmm.Info.Build
type CAFSet = Set CAFfyLabel
type CAFEnv = LabelMap CAFSet

-- | For each code block: - collect the references reachable from this code
--   block to FUN, THUNK or RET labels for which <tt>hasCAF == True</tt>
--   
--   This gives us a <a>CAFEnv</a>: a mapping from code block to sets of
--   labels
cafAnal :: Platform -> LabelSet -> CLabel -> CmmGraph -> CAFEnv

-- | Collect possible CAFfy references from a <a>CmmData</a> decl.
cafAnalData :: Platform -> CmmStatics -> CAFSet

-- | Attach SRTs to all info tables in the <a>CmmDecl</a>s, and add SRT
--   declarations to the <a>ModuleSRTInfo</a>.
doSRTs :: CmmConfig -> ModuleSRTInfo -> [(CAFEnv, [CmmDecl])] -> [(CAFSet, CmmDataDecl)] -> IO (ModuleSRTInfo, [CmmDeclSRTs])
data ModuleSRTInfo
ModuleSRTInfo :: Module -> Map (Set SRTEntry) SRTEntry -> Map SRTEntry (Set SRTEntry) -> SRTMap -> ModuleSRTInfo

-- | Current module being compiled. Required for calling labelDynamic.
[thisModule] :: ModuleSRTInfo -> Module

-- | previous SRTs we've emitted, so we can de-duplicate. Used to implement
--   the [Common] optimisation.
[dedupSRTs] :: ModuleSRTInfo -> Map (Set SRTEntry) SRTEntry

-- | The reverse mapping, so that we can remove redundant entries. e.g. if
--   we have an SRT [a,b,c], and we know that b points to [c,d], we can
--   omit c and emit [a,b]. Used to implement the [Filter] optimisation.
[flatSRTs] :: ModuleSRTInfo -> Map SRTEntry (Set SRTEntry)
[moduleSRTMap] :: ModuleSRTInfo -> SRTMap
emptySRT :: Module -> ModuleSRTInfo

-- | Maps labels from <a>cafAnal</a> to the final CLabel that will appear
--   in the SRT. - closures with singleton SRTs resolve to their single
--   entry - closures with larger SRTs map to the label for that SRT - CAFs
--   must not map to anything! - if a labels maps to Nothing, we found that
--   this label's SRT is empty, so we don't need to refer to it from other
--   SRTs.
type SRTMap = Map CAFfyLabel (Maybe SRTEntry)

-- | Given <a>SRTMap</a> of a module, returns the set of non-CAFFY names in
--   the module. Any <tt>Name</tt>s not in the set are CAFFY.
srtMapNonCAFs :: SRTMap -> NonCaffySet
instance GHC.Classes.Ord GHC.Cmm.Info.Build.CAFfyLabel
instance GHC.Classes.Eq GHC.Cmm.Info.Build.CAFfyLabel
instance GHC.Classes.Ord GHC.Cmm.Info.Build.SRTEntry
instance GHC.Classes.Eq GHC.Cmm.Info.Build.SRTEntry
instance GHC.Classes.Ord GHC.Cmm.Info.Build.SomeLabel
instance GHC.Classes.Eq GHC.Cmm.Info.Build.SomeLabel
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.CAFfyLabel
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.SRTEntry
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.ModuleSRTInfo
instance GHC.Utils.Outputable.OutputableP env GHC.Cmm.CLabel.CLabel => GHC.Utils.Outputable.OutputableP env GHC.Cmm.Info.Build.SomeLabel

module GHC.StgToCmm.Foreign

-- | Emit code for a foreign call, and return the results to the sequel.
--   Precondition: the length of the arguments list is the same as the
--   arity of the foreign function.
cgForeignCall :: ForeignCall -> Type -> [StgArg] -> Type -> FCode ReturnKind
emitPrimCall :: [CmmFormal] -> CallishMachOp -> [CmmActual] -> FCode ()
emitCCall :: [(CmmFormal, ForeignHint)] -> CmmExpr -> [(CmmActual, ForeignHint)] -> FCode ()
emitCCallNeverReturns :: [(CmmFormal, ForeignHint)] -> CmmExpr -> [(CmmActual, ForeignHint)] -> FCode ()
emitForeignCall :: Safety -> [CmmFormal] -> ForeignTarget -> [CmmActual] -> FCode ReturnKind
emitSaveThreadState :: FCode ()

-- | Produce code to save the current thread state to <tt>CurrentTSO</tt>
saveThreadState :: MonadUnique m => Profile -> m CmmAGraph
emitLoadThreadState :: FCode ()

-- | Save STG registers
--   
--   STG registers must be saved around a C call, just in case the STG
--   register is mapped to a caller-saves machine register. Normally we
--   don't need to worry about this the code generator has already loaded
--   any live STG registers into variables for us, but in hand-written
--   low-level Cmm code where we don't know which registers are live, we
--   might have to save them all.
emitSaveRegs :: FCode ()

-- | Restore STG registers (see <a>emitSaveRegs</a>)
emitRestoreRegs :: FCode ()

-- | Push a subset of STG registers onto the stack, specified by the bitmap
--   
--   Sometimes, a "live" subset of the STG registers needs to be saved on
--   the stack, for example when storing an unboxed tuple to be used in the
--   GHCi bytecode interpreter.
--   
--   The "live registers" bitmap corresponds to the list of registers given
--   by <a>allArgRegsCover</a>, with the least significant bit indicating
--   liveness of the first register in the list.
--   
--   Each register is saved to a stack slot of one or more machine words,
--   even if the register size itself is smaller.
--   
--   The resulting Cmm code looks like this, with a line for each real or
--   virtual register used for returning tuples:
--   
--   ... if((mask &amp; 2) != 0) { Sp_adj(-1); Sp(0) = R2; } if((mask &amp;
--   1) != 0) { Sp_adj(-1); Sp(0) = R1; }
--   
--   See Note [GHCi and native call registers]
emitPushArgRegs :: CmmExpr -> FCode ()

-- | Pop a subset of STG registers from the stack (see
--   <a>emitPushArgRegs</a>)
emitPopArgRegs :: CmmExpr -> FCode ()

-- | Produce code to load the current thread state from <tt>CurrentTSO</tt>
loadThreadState :: MonadUnique m => Profile -> m CmmAGraph
emitOpenNursery :: FCode ()
emitCloseNursery :: FCode ()

module GHC.StgToCmm.Prim
cgOpApp :: StgOp -> [StgArg] -> Type -> FCode ReturnKind
shouldInlinePrimOp :: StgToCmmConfig -> PrimOp -> [CmmExpr] -> Bool

module GHC.Cmm.LayoutStack
cmmLayoutStack :: CmmConfig -> ProcPointSet -> ByteOff -> CmmGraph -> UniqSM (CmmGraph, LabelMap StackMap)
setInfoTableStackMap :: Platform -> LabelMap StackMap -> CmmDecl -> CmmDecl
instance GHC.Utils.Outputable.Outputable GHC.Cmm.LayoutStack.StackSlot
instance GHC.Utils.Outputable.Outputable GHC.Cmm.LayoutStack.StackMap

module GHC.Cmm.Pipeline

-- | Top level driver for C-- pipeline
--   
--   Converts C-- with an implicit stack and native C-- calls into
--   optimized, CPS converted and native-call-less C--. The latter C-- can
--   be used to generate assembly.
cmmPipeline :: Logger -> CmmConfig -> ModuleSRTInfo -> CmmGroup -> IO (ModuleSRTInfo, CmmGroupSRTs)


-- | GHC.StgToByteCode: Generate bytecode from STG
module GHC.StgToByteCode
data UnlinkedBCO
byteCodeGen :: HscEnv -> Module -> [CgStgTopBinding] -> [TyCon] -> Maybe ModBreaks -> IO CompiledByteCode
instance GHC.Classes.Ord GHC.StgToByteCode.Discr
instance GHC.Classes.Eq GHC.StgToByteCode.Discr
instance GHC.Base.Functor GHC.StgToByteCode.BcM
instance GHC.Base.Applicative GHC.StgToByteCode.BcM
instance GHC.Base.Monad GHC.StgToByteCode.BcM
instance GHC.Driver.Session.HasDynFlags GHC.StgToByteCode.BcM
instance GHC.Utils.Outputable.Outputable GHC.StgToByteCode.Discr

module GHC.Iface.Errors
badIfaceFile :: String -> SDoc -> SDoc
hiModuleNameMismatchWarn :: Module -> Module -> SDoc
homeModError :: InstalledModule -> ModLocation -> SDoc
cannotFindInterface :: UnitState -> Maybe HomeUnit -> Profile -> ([FilePath] -> SDoc) -> ModuleName -> InstalledFindResult -> SDoc
cantFindInstalledErr :: SDoc -> SDoc -> UnitState -> Maybe HomeUnit -> Profile -> ([FilePath] -> SDoc) -> ModuleName -> InstalledFindResult -> SDoc
cannotFindModule :: HscEnv -> ModuleName -> FindResult -> SDoc
cantFindErr :: BuildingCabalPackage -> SDoc -> SDoc -> UnitEnv -> Profile -> ([FilePath] -> SDoc) -> ModuleName -> FindResult -> SDoc
mayShowLocations :: DynFlags -> [FilePath] -> SDoc

module GHC.Driver.Monad

-- | A monad that has all the features needed by GHC API calls.
--   
--   In short, a GHC monad
--   
--   <ul>
--   <li>allows embedding of IO actions,</li>
--   <li>can log warnings,</li>
--   <li>allows handling of (extensible) exceptions, and</li>
--   <li>maintains a current session.</li>
--   </ul>
--   
--   If you do not use <a>Ghc</a> or <a>GhcT</a>, make sure to call
--   <a>initGhcMonad</a> before any call to the GHC API functions can
--   occur.
class (Functor m, ExceptionMonad m, HasDynFlags m, HasLogger m) => GhcMonad m
getSession :: GhcMonad m => m HscEnv
setSession :: GhcMonad m => HscEnv -> m ()

-- | A minimal implementation of a <a>GhcMonad</a>. If you need a custom
--   monad, e.g., to maintain additional state consider wrapping this monad
--   or using <a>GhcT</a>.
newtype Ghc a
Ghc :: (Session -> IO a) -> Ghc a
[unGhc] :: Ghc a -> Session -> IO a

-- | A monad transformer to add GHC specific features to another monad.
--   
--   Note that the wrapped monad must support IO and handling of
--   exceptions.
newtype GhcT m a
GhcT :: (Session -> m a) -> GhcT m a
[unGhcT] :: GhcT m a -> Session -> m a
liftGhcT :: m a -> GhcT m a

-- | Reflect a computation in the <a>Ghc</a> monad into the <a>IO</a>
--   monad.
--   
--   You can use this to call functions returning an action in the
--   <a>Ghc</a> monad inside an <a>IO</a> action. This is needed for some
--   (too restrictive) callback arguments of some library functions:
--   
--   <pre>
--   libFunc :: String -&gt; (Int -&gt; IO a) -&gt; IO a
--   ghcFunc :: Int -&gt; Ghc a
--   
--   ghcFuncUsingLibFunc :: String -&gt; Ghc a -&gt; Ghc a
--   ghcFuncUsingLibFunc str =
--     reifyGhc $ \s -&gt;
--       libFunc $ \i -&gt; do
--         reflectGhc (ghcFunc i) s
--   </pre>
reflectGhc :: Ghc a -> Session -> IO a
reifyGhc :: (Session -> IO a) -> Ghc a

-- | Grabs the DynFlags from the Session
getSessionDynFlags :: GhcMonad m => m DynFlags

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a

-- | The Session is a handle to the complete state of a compilation
--   session. A compilation session consists of a set of modules
--   constituting the current program or library, the context for
--   interactive evaluation, and various caches.
data Session
Session :: !IORef HscEnv -> Session

-- | Call the argument with the current session.
withSession :: GhcMonad m => (HscEnv -> m a) -> m a

-- | Set the current session to the result of applying the current session
--   to the argument.
modifySession :: GhcMonad m => (HscEnv -> HscEnv) -> m ()

-- | Set the current session to the result of applying the current session
--   to the argument.
modifySessionM :: GhcMonad m => (HscEnv -> m HscEnv) -> m ()

-- | Call an action with a temporarily modified Session.
withTempSession :: GhcMonad m => (HscEnv -> HscEnv) -> m a -> m a

-- | Modify the logger
modifyLogger :: GhcMonad m => (Logger -> Logger) -> m ()

-- | Push a log hook on the stack
pushLogHookM :: GhcMonad m => (LogAction -> LogAction) -> m ()

-- | Pop a log hook from the stack
popLogHookM :: GhcMonad m => m ()

-- | Put a log message
putLogMsgM :: GhcMonad m => MessageClass -> SrcSpan -> SDoc -> m ()

-- | Put a log message
putMsgM :: GhcMonad m => SDoc -> m ()

-- | Time an action
withTimingM :: GhcMonad m => SDoc -> (b -> ()) -> m b -> m b

-- | A monad that allows logging of diagnostics.
logDiagnostics :: GhcMonad m => Messages GhcMessage -> m ()

-- | Print the all diagnostics in a <a>SourceError</a>. Useful inside
--   exception handlers.
printException :: (HasLogger m, MonadIO m, HasDynFlags m) => SourceError -> m ()

-- | A function called to log warnings and errors.
type WarnErrLogger = forall m. (HasDynFlags m, MonadIO m, HasLogger m) => Maybe SourceError -> m ()
defaultWarnErrLogger :: WarnErrLogger
instance Control.Monad.IO.Class.MonadIO GHC.Driver.Monad.Ghc
instance Control.Monad.Catch.MonadMask GHC.Driver.Monad.Ghc
instance Control.Monad.Catch.MonadCatch GHC.Driver.Monad.Ghc
instance Control.Monad.Catch.MonadThrow GHC.Driver.Monad.Ghc
instance Control.Monad.Fix.MonadFix GHC.Driver.Monad.Ghc
instance Control.Monad.Fail.MonadFail GHC.Driver.Monad.Ghc
instance GHC.Base.Monad GHC.Driver.Monad.Ghc
instance GHC.Base.Applicative GHC.Driver.Monad.Ghc
instance GHC.Base.Functor GHC.Driver.Monad.Ghc
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (GHC.Driver.Monad.GhcT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (GHC.Driver.Monad.GhcT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (GHC.Driver.Monad.GhcT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (GHC.Driver.Monad.GhcT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (GHC.Driver.Monad.GhcT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (GHC.Driver.Monad.GhcT m)
instance GHC.Base.Monad m => GHC.Base.Monad (GHC.Driver.Monad.GhcT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (GHC.Driver.Monad.GhcT m)
instance GHC.Base.Functor m => GHC.Base.Functor (GHC.Driver.Monad.GhcT m)
instance Control.Monad.IO.Class.MonadIO m => GHC.Driver.Session.HasDynFlags (GHC.Driver.Monad.GhcT m)
instance Control.Monad.IO.Class.MonadIO m => GHC.Utils.Logger.HasLogger (GHC.Driver.Monad.GhcT m)
instance GHC.Utils.Exception.ExceptionMonad m => GHC.Driver.Monad.GhcMonad (GHC.Driver.Monad.GhcT m)
instance GHC.Driver.Session.HasDynFlags GHC.Driver.Monad.Ghc
instance GHC.Utils.Logger.HasLogger GHC.Driver.Monad.Ghc
instance GHC.Driver.Monad.GhcMonad GHC.Driver.Monad.Ghc

module GHC.Driver.GenerateCgIPEStub
generateCgIPEStub :: HscEnv -> Module -> InfoTableProvMap -> (NonCaffySet, ModuleLFInfos, Map CmmInfoTable (Maybe IpeSourceLocation), IPEStats) -> Stream IO CmmGroupSRTs CmmCgInfos

-- | Given: * an initial mapping from info tables to possible source
--   locations, * initial <a>IPEStats</a>, * a <a>CmmGroupSRTs</a>,
--   
--   map every info table listed in the <a>CmmProc</a>s of the group to
--   their possible source locations and update <a>IPEStats</a> for skipped
--   stack info tables (in case both -finfo-table-map and
--   -fno-info-table-map-with-stack were given). See: Note [Stacktraces
--   from Info Table Provenance Entries (IPE based stack unwinding)]
--   
--   Note: While it would be cleaner if we could keep the recursion and
--   accumulation internal to this function, this cannot be done without
--   separately traversing stream of <a>CmmGroupSRTs</a> in <a>Main</a>.
--   The initial implementation of this logic did such a thing, and code
--   generation performance suffered considerably as a result (see #23103).
lookupEstimatedTicks :: HscEnv -> Map CmmInfoTable (Maybe IpeSourceLocation) -> IPEStats -> CmmGroupSRTs -> IO (Map CmmInfoTable (Maybe IpeSourceLocation), IPEStats)

module GHC.Core.Opt.Monad
data FloatOutSwitches
FloatOutSwitches :: Maybe Int -> Bool -> Bool -> Bool -> FloatOutSwitches

-- | Just n <a>=</a> float lambdas to top level, if doing so will abstract
--   over n or fewer value variables Nothing <a>=</a> float all lambdas to
--   top level, regardless of how many free variables Just 0 is the vanilla
--   case: float a lambda iff it has no free vars
[floatOutLambdas] :: FloatOutSwitches -> Maybe Int

-- | True <a>=</a> float constants to top level, even if they do not escape
--   a lambda
[floatOutConstants] :: FloatOutSwitches -> Bool

-- | True <a>=</a> float out over-saturated applications based on arity
--   information. See Note [Floating over-saturated applications] in
--   GHC.Core.Opt.SetLevels
[floatOutOverSatApps] :: FloatOutSwitches -> Bool

-- | Allow floating to the top level only.
[floatToTopLevelOnly] :: FloatOutSwitches -> Bool

-- | The monad used by Core-to-Core passes to register simplification
--   statistics. Also used to have common state (in the form of
--   UniqueSupply) for generating Uniques.
data CoreM a
runCoreM :: HscEnv -> RuleBase -> Char -> Module -> NamePprCtx -> SrcSpan -> CoreM a -> IO (a, SimplCount)

-- | Adjust the dyn flags passed to the argument action
mapDynFlagsCoreM :: (DynFlags -> DynFlags) -> CoreM a -> CoreM a

-- | Drop the single count of the argument action so it doesn't effect the
--   total.
dropSimplCount :: CoreM a -> CoreM a
getHscEnv :: CoreM HscEnv
getModule :: HasModule m => m Module
initRuleEnv :: ModGuts -> CoreM RuleEnv
getExternalRuleBase :: CoreM RuleBase
getDynFlags :: HasDynFlags m => m DynFlags
getPackageFamInstEnv :: CoreM PackageFamInstEnv
getInteractiveContext :: CoreM InteractiveContext
getUniqTag :: CoreM Char
getNamePprCtx :: CoreM NamePprCtx
getSrcSpanM :: CoreM SrcSpan
addSimplCount :: SimplCount -> CoreM ()

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a

-- | Lift an <a>IO</a> operation into <a>CoreM</a> while consuming its
--   <a>SimplCount</a>
liftIOWithCount :: IO (SimplCount, a) -> CoreM a

-- | Get all annotations of a given type. This happens lazily, that is no
--   deserialization will take place until the [a] is actually demanded and
--   the [a] can also be empty (the UniqFM is not filtered).
--   
--   This should be done once at the start of a Core-to-Core pass that uses
--   annotations.
--   
--   See Note [Annotations]
getAnnotations :: Typeable a => ([Word8] -> a) -> ModGuts -> CoreM (ModuleEnv [a], NameEnv [a])

-- | Get at most one annotation of a given type per annotatable item.
getFirstAnnotations :: Typeable a => ([Word8] -> a) -> ModGuts -> CoreM (ModuleEnv a, NameEnv a)

-- | Output a message to the screen
putMsg :: SDoc -> CoreM ()

-- | Output a String message to the screen
putMsgS :: String -> CoreM ()

-- | Output an error to the screen. Does not cause the compiler to die.
errorMsg :: SDoc -> CoreM ()
msg :: MessageClass -> SDoc -> CoreM ()

-- | Output a fatal error to the screen. Does not cause the compiler to
--   die.
fatalErrorMsg :: SDoc -> CoreM ()

-- | Output a fatal error to the screen. Does not cause the compiler to
--   die.
fatalErrorMsgS :: String -> CoreM ()

-- | Outputs a debugging message at verbosity level of <tt>-v</tt> or
--   higher
debugTraceMsg :: SDoc -> CoreM ()

-- | Output a string debugging message at verbosity level of <tt>-v</tt> or
--   higher
debugTraceMsgS :: String -> CoreM ()
instance GHC.Base.Functor GHC.Core.Opt.Monad.CoreM
instance GHC.Base.Monad GHC.Core.Opt.Monad.CoreM
instance GHC.Base.Applicative GHC.Core.Opt.Monad.CoreM
instance GHC.Base.Alternative GHC.Core.Opt.Monad.CoreM
instance GHC.Base.MonadPlus GHC.Core.Opt.Monad.CoreM
instance GHC.Types.Unique.Supply.MonadUnique GHC.Core.Opt.Monad.CoreM
instance Control.Monad.IO.Class.MonadIO GHC.Core.Opt.Monad.CoreM
instance GHC.Driver.Session.HasDynFlags GHC.Core.Opt.Monad.CoreM
instance GHC.Utils.Logger.HasLogger GHC.Core.Opt.Monad.CoreM
instance GHC.Unit.Module.HasModule GHC.Core.Opt.Monad.CoreM
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Monad.FloatOutSwitches

module GHC.Core.Opt.Specialise

-- | Specialise calls to type-class overloaded functions occurring in a
--   program.
specProgram :: ModGuts -> CoreM ModGuts
specUnfolding :: SimpleOpts -> [Var] -> (CoreExpr -> CoreExpr) -> [CoreArg] -> Unfolding -> Unfolding
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.UsageDetails
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.CallInfoSet
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.CallInfo
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.SpecArg
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.FloatedDictBinds
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.DictBind
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Specialise.SpecEnv

module GHC.Core.Opt.SpecConstr
specConstrProgram :: ModGuts -> CoreM ModGuts
data () => SpecConstrAnnotation
NoSpecConstr :: SpecConstrAnnotation
ForceSpecConstr :: SpecConstrAnnotation
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.CallPat
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.ScUsage
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.ArgOcc
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.Call
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.HowBound
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SpecConstr.Value

module GHC.Core.Opt.SetLevels
setLevels :: FloatOutSwitches -> CoreProgram -> UniqSupply -> [LevelledBind]
data Level
Level :: Int -> Int -> LevelType -> Level
data LevelType
BndrLvl :: LevelType
JoinCeilLvl :: LevelType
tOP_LEVEL :: Level
isJoinCeilLvl :: Level -> Bool
asJoinCeilLvl :: Level -> Level
type LevelledBind = TaggedBind FloatSpec
type LevelledExpr = TaggedExpr FloatSpec
type LevelledBndr = TaggedBndr FloatSpec
data FloatSpec
FloatMe :: Level -> FloatSpec
StayPut :: Level -> FloatSpec
floatSpecLevel :: FloatSpec -> Level
incMinorLvl :: Level -> Level
ltMajLvl :: Level -> Level -> Bool
ltLvl :: Level -> Level -> Bool
isTopLvl :: Level -> Bool
instance GHC.Classes.Eq GHC.Core.Opt.SetLevels.LevelType
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SetLevels.FloatSpec
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.SetLevels.Level
instance GHC.Classes.Eq GHC.Core.Opt.SetLevels.Level

module GHC.Core.Opt.FloatOut
floatOutwards :: Logger -> FloatOutSwitches -> UniqSupply -> CoreProgram -> IO CoreProgram
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.FloatOut.FloatBinds


-- | Adds cost-centers to call sites selected with the
--   <tt>-fprof-caller=...</tt> flag.
module GHC.Core.Opt.CallerCC
addCallerCostCentres :: ModGuts -> CoreM ModGuts
data CallerCcFilter
CallerCcFilter :: Maybe ModuleName -> NamePattern -> CallerCcFilter
[ccfModuleName] :: CallerCcFilter -> Maybe ModuleName
[ccfFuncName] :: CallerCcFilter -> NamePattern
data NamePattern
PChar :: Char -> NamePattern -> NamePattern
PWildcard :: NamePattern -> NamePattern
PEnd :: NamePattern
parseCallerCcFilter :: String -> Either String CallerCcFilter
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CallerCC.CallerCcFilter
instance GHC.Utils.Binary.Binary GHC.Core.Opt.CallerCC.CallerCcFilter
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.CallerCC.NamePattern
instance GHC.Utils.Binary.Binary GHC.Core.Opt.CallerCC.NamePattern


-- | This module manages storing the various GHC option flags in a modules
--   interface file as part of the recompilation checking infrastructure.
module GHC.Iface.Recomp.Flags

-- | Produce a fingerprint of a <tt>DynFlags</tt> value. We only base the
--   finger print on important fields in <tt>DynFlags</tt> so that the
--   recompilation checker can use this fingerprint.
--   
--   NB: The <a>GenModule</a> parameter is the <a>GenModule</a> recorded by
--   the *interface* file, not the actual <a>GenModule</a> according to our
--   <a>DynFlags</a>.
fingerprintDynFlags :: HscEnv -> Module -> (BinHandle -> Name -> IO ()) -> IO Fingerprint
fingerprintOptFlags :: DynFlags -> (BinHandle -> Name -> IO ()) -> IO Fingerprint
fingerprintHpcFlags :: DynFlags -> (BinHandle -> Name -> IO ()) -> IO Fingerprint

module GHC.Core.Lint
data LintPassResultConfig
LintPassResultConfig :: !DiagOpts -> !Platform -> !LintFlags -> !Bool -> !SDoc -> ![Var] -> LintPassResultConfig
[lpr_diagOpts] :: LintPassResultConfig -> !DiagOpts
[lpr_platform] :: LintPassResultConfig -> !Platform
[lpr_makeLintFlags] :: LintPassResultConfig -> !LintFlags
[lpr_showLintWarnings] :: LintPassResultConfig -> !Bool
[lpr_passPpr] :: LintPassResultConfig -> !SDoc
[lpr_localsInScope] :: LintPassResultConfig -> ![Var]
data LintFlags
LF :: Bool -> Bool -> StaticPtrCheck -> Bool -> Bool -> Bool -> LintFlags
[lf_check_global_ids] :: LintFlags -> Bool
[lf_check_inline_loop_breakers] :: LintFlags -> Bool

-- | See Note [Checking StaticPtrs]
[lf_check_static_ptrs] :: LintFlags -> StaticPtrCheck

-- | See Note [Linting type synonym applications]
[lf_report_unsat_syns] :: LintFlags -> Bool

-- | See Note [Linting linearity]
[lf_check_linearity] :: LintFlags -> Bool
[lf_check_fixed_rep] :: LintFlags -> Bool
data StaticPtrCheck

-- | Allow <tt>makeStatic</tt> to occur anywhere.
AllowAnywhere :: StaticPtrCheck

-- | Allow <tt>makeStatic</tt> calls at the top-level only.
AllowAtTopLevel :: StaticPtrCheck

-- | Reject any <tt>makeStatic</tt> occurrence.
RejectEverywhere :: StaticPtrCheck
data LintConfig
LintConfig :: !DiagOpts -> !Platform -> !LintFlags -> ![Var] -> LintConfig

-- | Diagnostics opts
[l_diagOpts] :: LintConfig -> !DiagOpts

-- | Target platform
[l_platform] :: LintConfig -> !Platform

-- | Linting the result of this pass
[l_flags] :: LintConfig -> !LintFlags

-- | <a>Id</a>s that should be treated as being in scope
[l_vars] :: LintConfig -> ![Var]
type WarnsAndErrs = (Bag SDoc, Bag SDoc)

-- | Type-check a <a>CoreProgram</a>. See Note [Core Lint guarantee].
lintCoreBindings' :: LintConfig -> CoreProgram -> WarnsAndErrs
lintUnfolding :: Bool -> LintConfig -> SrcLoc -> CoreExpr -> Maybe (Bag SDoc)
lintPassResult :: Logger -> LintPassResultConfig -> CoreProgram -> IO ()
lintExpr :: LintConfig -> CoreExpr -> Maybe (Bag SDoc)

-- | This checks whether a pass correctly looks through debug annotations
--   (<tt>SourceNote</tt>). This works a bit different from other
--   consistency checks: We check this by running the given task twice,
--   noting all differences between the results.
lintAnnots :: SDoc -> (ModGuts -> CoreM ModGuts) -> ModGuts -> CoreM ModGuts
lintAxioms :: Logger -> LintConfig -> SDoc -> [CoAxiom Branched] -> IO ()

-- | Configuration for boilerplate operations at the end of a compilation
--   pass producing Core.
data EndPassConfig
EndPassConfig :: !Bool -> !Maybe LintPassResultConfig -> !NamePprCtx -> !Maybe DumpFlag -> !SDoc -> !SDoc -> EndPassConfig

-- | Whether core bindings should be dumped with the size of what they are
--   binding (i.e. the size of the RHS of the binding).
[ep_dumpCoreSizes] :: EndPassConfig -> !Bool

-- | Whether we should lint the result of this pass.
[ep_lintPassResult] :: EndPassConfig -> !Maybe LintPassResultConfig
[ep_namePprCtx] :: EndPassConfig -> !NamePprCtx
[ep_dumpFlag] :: EndPassConfig -> !Maybe DumpFlag
[ep_prettyPass] :: EndPassConfig -> !SDoc
[ep_passDetails] :: EndPassConfig -> !SDoc
endPassIO :: Logger -> EndPassConfig -> CoreProgram -> [CoreRule] -> IO ()
displayLintResults :: Logger -> Bool -> SDoc -> SDoc -> WarnsAndErrs -> IO ()
dumpPassResult :: Logger -> Bool -> NamePprCtx -> Maybe DumpFlag -> String -> SDoc -> CoreProgram -> [CoreRule] -> IO ()
instance GHC.Classes.Eq GHC.Core.Lint.StaticPtrCheck
instance GHC.Base.Functor GHC.Core.Lint.LintM
instance GHC.Base.Applicative GHC.Core.Lint.LintM
instance GHC.Base.Monad GHC.Core.Lint.LintM
instance Control.Monad.Fail.MonadFail GHC.Core.Lint.LintM


-- | Adds cost-centers after the core piple has run.
module GHC.Core.LateCC
addLateCostCentresMG :: ModGuts -> CoreM ModGuts
addLateCostCentresPgm :: DynFlags -> Logger -> Module -> CoreProgram -> IO (CoreProgram, Set CostCentre)
addLateCostCentres :: Env -> CoreProgram -> (CoreProgram, Set CostCentre)
data Env
Env :: !Module -> !Bool -> !CostCentreState -> !Bool -> Env
[thisModule] :: Env -> !Module
[countEntries] :: Env -> !Bool
[ccState] :: Env -> !CostCentreState
[collectCCs] :: Env -> !Bool

module GHC.Core.Opt.Simplify.Utils
rebuildLam :: SimplEnv -> [OutBndr] -> OutExpr -> SimplCont -> SimplM OutExpr
mkCase :: SimplMode -> OutExpr -> OutId -> OutType -> [OutAlt] -> SimplM OutExpr
prepareAlts :: OutExpr -> InId -> [InAlt] -> SimplM ([AltCon], [InAlt])
tryEtaExpandRhs :: SimplEnv -> BindContext -> OutId -> OutExpr -> SimplM (ArityType, OutExpr)
wantEtaExpansion :: CoreExpr -> Bool
preInlineUnconditionally :: SimplEnv -> TopLevelFlag -> InId -> InExpr -> StaticEnv -> Maybe SimplEnv
postInlineUnconditionally :: SimplEnv -> BindContext -> OutId -> OccInfo -> OutExpr -> Bool
activeUnfolding :: SimplMode -> Id -> Bool
activeRule :: SimplMode -> Activation -> Bool
getUnfoldingInRuleMatch :: SimplEnv -> InScopeEnv
updModeForStableUnfoldings :: Activation -> SimplMode -> SimplMode
updModeForRules :: SimplMode -> SimplMode
data BindContext
BC_Let :: TopLevelFlag -> RecFlag -> BindContext
BC_Join :: RecFlag -> SimplCont -> BindContext
bindContextLevel :: BindContext -> TopLevelFlag
data SimplCont

-- | Stop[e] = e
Stop :: OutType -> CallCtxt -> SubDemand -> SimplCont
CastIt :: OutCoercion -> SimplCont -> SimplCont
ApplyToVal :: DupFlag -> OutType -> InExpr -> StaticEnv -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_hole_ty] :: SimplCont -> OutType
[sc_arg] :: SimplCont -> InExpr
[sc_env] :: SimplCont -> StaticEnv
[sc_cont] :: SimplCont -> SimplCont
ApplyToTy :: OutType -> OutType -> SimplCont -> SimplCont
[sc_arg_ty] :: SimplCont -> OutType
[sc_hole_ty] :: SimplCont -> OutType
[sc_cont] :: SimplCont -> SimplCont
Select :: DupFlag -> InId -> [InAlt] -> StaticEnv -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_bndr] :: SimplCont -> InId
[sc_alts] :: SimplCont -> [InAlt]
[sc_env] :: SimplCont -> StaticEnv
[sc_cont] :: SimplCont -> SimplCont
StrictBind :: DupFlag -> InId -> FromWhat -> InExpr -> StaticEnv -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_bndr] :: SimplCont -> InId
[sc_from] :: SimplCont -> FromWhat
[sc_body] :: SimplCont -> InExpr
[sc_env] :: SimplCont -> StaticEnv
[sc_cont] :: SimplCont -> SimplCont
StrictArg :: DupFlag -> ArgInfo -> OutType -> SimplCont -> SimplCont
[sc_dup] :: SimplCont -> DupFlag
[sc_fun] :: SimplCont -> ArgInfo
[sc_fun_ty] :: SimplCont -> OutType
[sc_cont] :: SimplCont -> SimplCont
TickIt :: CoreTickish -> SimplCont -> SimplCont
data DupFlag
NoDup :: DupFlag
Simplified :: DupFlag
OkToDup :: DupFlag
data FromWhat
FromLet :: FromWhat
FromBeta :: OutType -> FromWhat
type StaticEnv = SimplEnv
isSimplified :: DupFlag -> Bool
contIsStop :: SimplCont -> Bool
contIsDupable :: SimplCont -> Bool
contResultType :: SimplCont -> OutType
contHoleType :: SimplCont -> OutType
contHoleScaling :: SimplCont -> Mult
contIsTrivial :: SimplCont -> Bool
contArgs :: SimplCont -> (Bool, [ArgSummary], SimplCont)
contIsRhs :: SimplCont -> Maybe RecFlag
countArgs :: SimplCont -> Int
mkBoringStop :: OutType -> SimplCont
mkRhsStop :: OutType -> RecFlag -> Demand -> SimplCont
mkLazyArgStop :: OutType -> ArgInfo -> SimplCont
interestingCallContext :: SimplEnv -> SimplCont -> CallCtxt
data ArgInfo
ArgInfo :: OutId -> [ArgSpec] -> RewriteCall -> Bool -> [Demand] -> [Int] -> ArgInfo
[ai_fun] :: ArgInfo -> OutId
[ai_args] :: ArgInfo -> [ArgSpec]
[ai_rewrite] :: ArgInfo -> RewriteCall
[ai_encl] :: ArgInfo -> Bool
[ai_dmds] :: ArgInfo -> [Demand]
[ai_discs] :: ArgInfo -> [Int]
data ArgSpec
ValArg :: Demand -> OutExpr -> OutType -> ArgSpec
[as_dmd] :: ArgSpec -> Demand
[as_arg] :: ArgSpec -> OutExpr
[as_hole_ty] :: ArgSpec -> OutType
TyArg :: OutType -> OutType -> ArgSpec
[as_arg_ty] :: ArgSpec -> OutType
[as_hole_ty] :: ArgSpec -> OutType
CastBy :: OutCoercion -> ArgSpec
data RewriteCall
TryRules :: FullArgCount -> [CoreRule] -> RewriteCall
TryInlining :: RewriteCall
TryNothing :: RewriteCall
mkArgInfo :: SimplEnv -> RuleEnv -> Id -> SimplCont -> ArgInfo
addValArgTo :: ArgInfo -> OutExpr -> OutType -> ArgInfo
addCastTo :: ArgInfo -> OutCoercion -> ArgInfo
addTyArgTo :: ArgInfo -> OutType -> OutType -> ArgInfo
argInfoExpr :: OutId -> [ArgSpec] -> OutExpr
argInfoAppArgs :: [ArgSpec] -> [OutExpr]
pushSimplifiedArgs :: SimplEnv -> [ArgSpec] -> SimplCont -> SimplCont
pushSimplifiedRevArgs :: SimplEnv -> [ArgSpec] -> SimplCont -> SimplCont
isStrictArgInfo :: ArgInfo -> Bool
lazyArgContext :: ArgInfo -> CallCtxt
abstractFloats :: UnfoldingOpts -> TopLevelFlag -> [OutTyVar] -> SimplFloats -> OutExpr -> SimplM ([OutBind], OutExpr)
isExitJoinId :: Var -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.SimplCont
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.ArgInfo
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.ArgSpec
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Simplify.Utils.DupFlag

module GHC.Core.Opt.Simplify.Iteration
simplTopBinds :: SimplEnv -> [InBind] -> SimplM (SimplFloats, SimplEnv)
simplExpr :: SimplEnv -> CoreExpr -> SimplM CoreExpr
simplImpRules :: SimplEnv -> [CoreRule] -> SimplM [CoreRule]

module GHC.Core.Opt.Simplify

-- | Configuration record for <a>simplifyExpr</a>. The values of this
--   datatype are <i>only</i> driven by the demands of that function.
data SimplifyExprOpts
SimplifyExprOpts :: ![FamInst] -> !SimplMode -> !TopEnvConfig -> SimplifyExprOpts
[se_fam_inst] :: SimplifyExprOpts -> ![FamInst]
[se_mode] :: SimplifyExprOpts -> !SimplMode
[se_top_env_cfg] :: SimplifyExprOpts -> !TopEnvConfig

-- | Configuration record for <a>simplifyPgm</a>. The values of this
--   datatype are <i>only</i> driven by the demands of that function.
data SimplifyOpts
SimplifyOpts :: !Bool -> !Int -> !SimplMode -> !Maybe LintPassResultConfig -> !RuleBase -> !TopEnvConfig -> SimplifyOpts
[so_dump_core_sizes] :: SimplifyOpts -> !Bool
[so_iterations] :: SimplifyOpts -> !Int
[so_mode] :: SimplifyOpts -> !SimplMode
[so_pass_result_cfg] :: SimplifyOpts -> !Maybe LintPassResultConfig
[so_hpt_rules] :: SimplifyOpts -> !RuleBase
[so_top_env_cfg] :: SimplifyOpts -> !TopEnvConfig
simplifyExpr :: Logger -> ExternalUnitCache -> SimplifyExprOpts -> CoreExpr -> IO CoreExpr
simplifyPgm :: Logger -> UnitEnv -> NamePprCtx -> SimplifyOpts -> ModGuts -> IO (SimplCount, ModGuts)

module GHC.Core.Opt.Pipeline.Types

-- | A description of the plugin pass itself
type CorePluginPass = ModGuts -> CoreM ModGuts
data CoreToDo

-- | The core-to-core simplifier.
CoreDoSimplify :: !SimplifyOpts -> CoreToDo
CoreDoPluginPass :: String -> CorePluginPass -> CoreToDo
CoreDoFloatInwards :: CoreToDo
CoreDoFloatOutwards :: FloatOutSwitches -> CoreToDo
CoreLiberateCase :: CoreToDo
CoreDoPrintCore :: CoreToDo
CoreDoStaticArgs :: CoreToDo
CoreDoCallArity :: CoreToDo
CoreDoExitify :: CoreToDo
CoreDoDemand :: Bool -> CoreToDo
CoreDoCpr :: CoreToDo
CoreDoWorkerWrapper :: CoreToDo
CoreDoSpecialising :: CoreToDo
CoreDoSpecConstr :: CoreToDo
CoreCSE :: CoreToDo
CoreDoRuleCheck :: CompilerPhase -> String -> CoreToDo
CoreDoNothing :: CoreToDo
CoreDoPasses :: [CoreToDo] -> CoreToDo
CoreDesugar :: CoreToDo
CoreDesugarOpt :: CoreToDo
CoreTidy :: CoreToDo
CorePrep :: CoreToDo
CoreAddCallerCcs :: CoreToDo
CoreAddLateCcs :: CoreToDo
bindsOnlyPass :: (CoreProgram -> CoreM CoreProgram) -> ModGuts -> CoreM ModGuts
pprPassDetails :: CoreToDo -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.Core.Opt.Pipeline.Types.CoreToDo

module GHC.Driver.Config.Core.Lint
endPass :: CoreToDo -> CoreProgram -> [CoreRule] -> CoreM ()
endPassHscEnvIO :: HscEnv -> NamePprCtx -> CoreToDo -> CoreProgram -> [CoreRule] -> IO ()

-- | Type-check a <a>CoreProgram</a>. See Note [Core Lint guarantee].
lintCoreBindings :: DynFlags -> CoreToDo -> [Var] -> CoreProgram -> WarnsAndErrs
initEndPassConfig :: DynFlags -> [Var] -> NamePprCtx -> CoreToDo -> EndPassConfig
initLintPassResultConfig :: DynFlags -> [Var] -> CoreToDo -> LintPassResultConfig
initLintConfig :: DynFlags -> [Var] -> LintConfig


-- | Various types used during typechecking.
--   
--   Please see <a>GHC.Tc.Utils.Monad</a> as well for operations on these
--   types. You probably want to import it, instead of this module.
--   
--   All the monads exported here are built on top of the same IOEnv monad.
--   The monad functions like a Reader monad in the way it passes the
--   environment around. This is done to allow the environment to be
--   manipulated in a stack like fashion when entering expressions... etc.
--   
--   For state that is global and should be returned at the end (e.g not
--   part of the stack mechanism), you should use a TcRef (= IORef) to
--   store them.
module GHC.Tc.Types
type TcRnIf a b = IOEnv (Env a b)
type TcRn = TcRnIf TcGblEnv TcLclEnv

-- | Historical "type-checking monad" (now it's just <a>TcRn</a>).
type TcM = TcRn

-- | Historical "renaming monad" (now it's just <a>TcRn</a>).
type RnM = TcRn
type IfM lcl = TcRnIf IfGblEnv lcl
type IfL = IfM IfLclEnv
type IfG = IfM ()

-- | Type alias for <a>IORef</a>; the convention is we'll use this for
--   mutable bits of data in <a>TcGblEnv</a> which are updated during
--   typechecking and returned at the end.
type TcRef a = IORef a
data Env gbl lcl
Env :: !HscEnv -> {-# UNPACK #-} !Char -> gbl -> lcl -> Env gbl lcl
[env_top] :: Env gbl lcl -> !HscEnv
[env_ut] :: Env gbl lcl -> {-# UNPACK #-} !Char
[env_gbl] :: Env gbl lcl -> gbl
[env_lcl] :: Env gbl lcl -> lcl

-- | <a>TcGblEnv</a> describes the top-level of the module at the point at
--   which the typechecker is finished work. It is this structure that is
--   handed on to the desugarer For state that needs to be updated during
--   the typechecking phase and returned at end, use a <a>TcRef</a> (=
--   <a>IORef</a>).
data TcGblEnv
TcGblEnv :: Module -> Module -> HscSource -> GlobalRdrEnv -> Maybe [Type] -> FixityEnv -> RecFieldEnv -> TypeEnv -> KnotVars (IORef TypeEnv) -> !InstEnv -> !FamInstEnv -> AnnEnv -> [AvailInfo] -> ImportAvails -> DefUses -> TcRef [GlobalRdrElt] -> TcRef NameSet -> TcRef Bool -> TcRef Bool -> TcRef ([Linkable], PkgsLoaded) -> TcRef OccSet -> [(Module, Fingerprint)] -> Maybe [(LIE GhcRn, Avails)] -> [LImportDecl GhcRn] -> Maybe (HsGroup GhcRn) -> TcRef [FilePath] -> TcRef [LHsDecl GhcPs] -> TcRef [(ForeignSrcLang, FilePath)] -> TcRef NameSet -> TcRef [(TcLclEnv, ThModFinalizers)] -> TcRef [String] -> TcRef (Map TypeRep Dynamic) -> TcRef (Maybe (ForeignRef (IORef QState))) -> TcRef THDocs -> Bag EvBind -> Maybe Id -> LHsBinds GhcTc -> NameSet -> [LTcSpecPrag] -> Warnings GhcRn -> [Annotation] -> [TyCon] -> NameSet -> [ClsInst] -> [FamInst] -> [LRuleDecl GhcTc] -> [LForeignDecl GhcTc] -> [PatSyn] -> Maybe (LHsDoc GhcRn) -> !AnyHpcUsage -> SelfBootInfo -> Maybe Name -> TcRef Bool -> TcRef (Messages TcRnMessage) -> [TcPluginSolver] -> UniqFM TyCon [TcPluginRewriter] -> [FillDefaulting] -> [HoleFitPlugin] -> RealSrcSpan -> TcRef WantedConstraints -> !CompleteMatches -> TcRef CostCentreState -> TcRef (ModuleEnv Int) -> TcGblEnv

-- | Module being compiled
[tcg_mod] :: TcGblEnv -> Module

-- | If a signature, the backing module See also Note [Identity versus
--   semantic module]
[tcg_semantic_mod] :: TcGblEnv -> Module

-- | What kind of module (regular Haskell, hs-boot, hsig)
[tcg_src] :: TcGblEnv -> HscSource

-- | Top level envt; used during renaming
[tcg_rdr_env] :: TcGblEnv -> GlobalRdrEnv

-- | Types used for defaulting. <tt>Nothing</tt> =&gt; no <tt>default</tt>
--   decl
[tcg_default] :: TcGblEnv -> Maybe [Type]

-- | Just for things in this module
[tcg_fix_env] :: TcGblEnv -> FixityEnv

-- | Just for things in this module See Note [The interactive package] in
--   <a>GHC.Runtime.Context</a>
[tcg_field_env] :: TcGblEnv -> RecFieldEnv

-- | Global type env for the module we are compiling now. All TyCons and
--   Classes (for this module) end up in here right away, along with their
--   derived constructors, selectors.
--   
--   (Ids defined in this module start in the local envt, though they move
--   to the global envt during zonking)
--   
--   NB: for what "things in this module" means, see Note [The interactive
--   package] in <a>GHC.Runtime.Context</a>
[tcg_type_env] :: TcGblEnv -> TypeEnv
[tcg_type_env_var] :: TcGblEnv -> KnotVars (IORef TypeEnv)

-- | Instance envt for all <i>home-package</i> modules; Includes the dfuns
--   in tcg_insts NB. BangPattern is to fix a leak, see #15111
[tcg_inst_env] :: TcGblEnv -> !InstEnv

-- | Ditto for family instances NB. BangPattern is to fix a leak, see
--   #15111
[tcg_fam_inst_env] :: TcGblEnv -> !FamInstEnv

-- | And for annotations
[tcg_ann_env] :: TcGblEnv -> AnnEnv

-- | What is exported
[tcg_exports] :: TcGblEnv -> [AvailInfo]

-- | Information about what was imported from where, including things bound
--   in this module. Also store Safe Haskell info here about transitive
--   trusted package requirements.
--   
--   There are not many uses of this field, so you can grep for all them.
--   
--   The ImportAvails records information about the following things:
--   
--   <ol>
--   <li>All of the modules you directly imported (tcRnImports)</li>
--   <li>The orphans (only!) of all imported modules in a GHCi session
--   (runTcInteractive)</li>
--   <li>The module that instantiated a signature</li>
--   <li>Each of the signatures that merged in</li>
--   </ol>
--   
--   It is used in the following ways: - imp_orphs is used to determine
--   what orphan modules should be visible in the context
--   (tcVisibleOrphanMods) - imp_finsts is used to determine what family
--   instances should be visible (tcExtendLocalFamInstEnv) - To resolve the
--   meaning of the export list of a module (tcRnExports) - imp_mods is
--   used to compute usage info (mkIfaceTc, deSugar) - imp_trust_own_pkg is
--   used for Safe Haskell in interfaces (mkIfaceTc, as well as in
--   <a>GHC.Driver.Main</a>) - To create the Dependencies field in
--   interface (mkDependencies)
[tcg_imports] :: TcGblEnv -> ImportAvails
[tcg_dus] :: TcGblEnv -> DefUses
[tcg_used_gres] :: TcGblEnv -> TcRef [GlobalRdrElt]
[tcg_keep] :: TcGblEnv -> TcRef NameSet

-- | <tt>True</tt> &lt;=&gt; Template Haskell syntax used.
--   
--   We need this so that we can generate a dependency on the Template
--   Haskell package, because the desugarer is going to emit loads of
--   references to TH symbols. The reference is implicit rather than
--   explicit, so we have to zap a mutable variable.
[tcg_th_used] :: TcGblEnv -> TcRef Bool

-- | <tt>True</tt> &lt;=&gt; A Template Haskell splice was used.
--   
--   Splices disable recompilation avoidance (see #481)
[tcg_th_splice_used] :: TcGblEnv -> TcRef Bool

-- | The set of runtime dependencies required by this module See Note
--   [Object File Dependencies]
[tcg_th_needed_deps] :: TcGblEnv -> TcRef ([Linkable], PkgsLoaded)

-- | Allows us to choose unique DFun names.
[tcg_dfun_n] :: TcGblEnv -> TcRef OccSet

-- | The requirements we merged with; we always have to recompile if any of
--   these changed.
[tcg_merged] :: TcGblEnv -> [(Module, Fingerprint)]
[tcg_rn_exports] :: TcGblEnv -> Maybe [(LIE GhcRn, Avails)]
[tcg_rn_imports] :: TcGblEnv -> [LImportDecl GhcRn]

-- | Renamed decls, maybe. <tt>Nothing</tt> &lt;=&gt; Don't retain renamed
--   decls.
[tcg_rn_decls] :: TcGblEnv -> Maybe (HsGroup GhcRn)

-- | dependencies from addDependentFile
[tcg_dependent_files] :: TcGblEnv -> TcRef [FilePath]

-- | Top-level declarations from addTopDecls
[tcg_th_topdecls] :: TcGblEnv -> TcRef [LHsDecl GhcPs]

-- | Foreign files emitted from TH.
[tcg_th_foreign_files] :: TcGblEnv -> TcRef [(ForeignSrcLang, FilePath)]

-- | Exact names bound in top-level declarations in tcg_th_topdecls
[tcg_th_topnames] :: TcGblEnv -> TcRef NameSet

-- | Template Haskell module finalizers.
--   
--   They can use particular local environments.
[tcg_th_modfinalizers] :: TcGblEnv -> TcRef [(TcLclEnv, ThModFinalizers)]

-- | Core plugins added by Template Haskell code.
[tcg_th_coreplugins] :: TcGblEnv -> TcRef [String]
[tcg_th_state] :: TcGblEnv -> TcRef (Map TypeRep Dynamic)

-- | Template Haskell state
[tcg_th_remote_state] :: TcGblEnv -> TcRef (Maybe (ForeignRef (IORef QState)))

-- | Docs added in Template Haskell via <tt>putDoc</tt>.
[tcg_th_docs] :: TcGblEnv -> TcRef THDocs
[tcg_ev_binds] :: TcGblEnv -> Bag EvBind
[tcg_tr_module] :: TcGblEnv -> Maybe Id
[tcg_binds] :: TcGblEnv -> LHsBinds GhcTc
[tcg_sigs] :: TcGblEnv -> NameSet
[tcg_imp_specs] :: TcGblEnv -> [LTcSpecPrag]
[tcg_warns] :: TcGblEnv -> Warnings GhcRn
[tcg_anns] :: TcGblEnv -> [Annotation]
[tcg_tcs] :: TcGblEnv -> [TyCon]
[tcg_ksigs] :: TcGblEnv -> NameSet
[tcg_insts] :: TcGblEnv -> [ClsInst]
[tcg_fam_insts] :: TcGblEnv -> [FamInst]
[tcg_rules] :: TcGblEnv -> [LRuleDecl GhcTc]
[tcg_fords] :: TcGblEnv -> [LForeignDecl GhcTc]
[tcg_patsyns] :: TcGblEnv -> [PatSyn]

-- | Maybe Haddock header docs
[tcg_doc_hdr] :: TcGblEnv -> Maybe (LHsDoc GhcRn)

-- | <tt>True</tt> if any part of the prog uses hpc instrumentation. NB.
--   BangPattern is to fix a leak, see #15111
[tcg_hpc] :: TcGblEnv -> !AnyHpcUsage

-- | Whether this module has a corresponding hi-boot file
[tcg_self_boot] :: TcGblEnv -> SelfBootInfo

-- | The Name of the main function, if this module is the main module.
[tcg_main] :: TcGblEnv -> Maybe Name

-- | Has the typechecker inferred this module as -XSafe (Safe Haskell)? See
--   Note [Safe Haskell Overlapping Instances Implementation], although
--   this is used for more than just that failure case.
[tcg_safe_infer] :: TcGblEnv -> TcRef Bool

-- | Unreported reasons why tcg_safe_infer is False. INVARIANT: If this
--   Messages is non-empty, then tcg_safe_infer is False. It may be that
--   tcg_safe_infer is False but this is empty, if no reasons are supplied
--   (#19714), or if those reasons have already been reported by
--   GHC.Driver.Main.markUnsafeInfer
[tcg_safe_infer_reasons] :: TcGblEnv -> TcRef (Messages TcRnMessage)

-- | A list of user-defined type-checking plugins for constraint solving.
[tcg_tc_plugin_solvers] :: TcGblEnv -> [TcPluginSolver]

-- | A collection of all the user-defined type-checking plugins for
--   rewriting type family applications, collated by their type family
--   <a>TyCon</a>s.
[tcg_tc_plugin_rewriters] :: TcGblEnv -> UniqFM TyCon [TcPluginRewriter]

-- | A list of user-defined plugins for type defaulting plugins.
[tcg_defaulting_plugins] :: TcGblEnv -> [FillDefaulting]

-- | A list of user-defined plugins for hole fit suggestions.
[tcg_hf_plugins] :: TcGblEnv -> [HoleFitPlugin]

-- | The RealSrcSpan this module came from
[tcg_top_loc] :: TcGblEnv -> RealSrcSpan

-- | Wanted constraints of static forms. See Note [Constraints in static
--   forms].
[tcg_static_wc] :: TcGblEnv -> TcRef WantedConstraints

-- | Tracking indices for cost centre annotations
[tcg_complete_matches] :: TcGblEnv -> !CompleteMatches
[tcg_cc_st] :: TcGblEnv -> TcRef CostCentreState

-- | See Note [Generating fresh names for FFI wrappers]
[tcg_next_wrapper_num] :: TcGblEnv -> TcRef (ModuleEnv Int)
data TcLclEnv
TcLclEnv :: RealSrcSpan -> [ErrCtxt] -> Bool -> TcLevel -> ThStage -> ThBindEnv -> ArrowCtxt -> LocalRdrEnv -> TcTypeEnv -> TcRef UsageEnv -> TcBinderStack -> TcRef WantedConstraints -> TcRef (Messages TcRnMessage) -> TcLclEnv
[tcl_loc] :: TcLclEnv -> RealSrcSpan
[tcl_ctxt] :: TcLclEnv -> [ErrCtxt]
[tcl_in_gen_code] :: TcLclEnv -> Bool
[tcl_tclvl] :: TcLclEnv -> TcLevel
[tcl_th_ctxt] :: TcLclEnv -> ThStage
[tcl_th_bndrs] :: TcLclEnv -> ThBindEnv
[tcl_arrow_ctxt] :: TcLclEnv -> ArrowCtxt
[tcl_rdr] :: TcLclEnv -> LocalRdrEnv
[tcl_env] :: TcLclEnv -> TcTypeEnv
[tcl_usage] :: TcLclEnv -> TcRef UsageEnv
[tcl_bndrs] :: TcLclEnv -> TcBinderStack
[tcl_lie] :: TcLclEnv -> TcRef WantedConstraints
[tcl_errs] :: TcLclEnv -> TcRef (Messages TcRnMessage)
setLclEnvTcLevel :: TcLclEnv -> TcLevel -> TcLclEnv
getLclEnvTcLevel :: TcLclEnv -> TcLevel
setLclEnvLoc :: TcLclEnv -> RealSrcSpan -> TcLclEnv
getLclEnvLoc :: TcLclEnv -> RealSrcSpan
lclEnvInGeneratedCode :: TcLclEnv -> Bool
data IfGblEnv
IfGblEnv :: SDoc -> KnotVars (IfG TypeEnv) -> IfGblEnv
[if_doc] :: IfGblEnv -> SDoc
[if_rec_types] :: IfGblEnv -> KnotVars (IfG TypeEnv)
data IfLclEnv
IfLclEnv :: !Module -> IsBootInterface -> SDoc -> Maybe NameShape -> Maybe TypeEnv -> FastStringEnv TyVar -> FastStringEnv Id -> IfLclEnv
[if_mod] :: IfLclEnv -> !Module
[if_boot] :: IfLclEnv -> IsBootInterface
[if_loc] :: IfLclEnv -> SDoc
[if_nsubst] :: IfLclEnv -> Maybe NameShape
[if_implicits_env] :: IfLclEnv -> Maybe TypeEnv
[if_tv_env] :: IfLclEnv -> FastStringEnv TyVar
[if_id_env] :: IfLclEnv -> FastStringEnv Id
tcVisibleOrphanMods :: TcGblEnv -> ModuleSet

-- | A <a>RewriteEnv</a> carries the necessary context for performing
--   rewrites (i.e. type family reductions and following filled-in
--   metavariables) in the solver.
data RewriteEnv
RE :: !CtLoc -> !CtFlavour -> !EqRel -> !TcRef RewriterSet -> RewriteEnv

-- | In which context are we rewriting?
--   
--   Type-checking plugins might want to use this location information when
--   emitting new Wanted constraints when rewriting type family
--   applications. This ensures that such Wanted constraints will, when
--   unsolved, give rise to error messages with the correct source
--   location.
[re_loc] :: RewriteEnv -> !CtLoc
[re_flavour] :: RewriteEnv -> !CtFlavour

-- | At what role are we rewriting?
--   
--   See Note [Rewriter EqRels] in GHC.Tc.Solver.Rewrite
[re_eq_rel] :: RewriteEnv -> !EqRel

-- | See Note [Wanteds rewrite Wanteds]
[re_rewriters] :: RewriteEnv -> !TcRef RewriterSet

-- | <a>FrontendResult</a> describes the result of running the frontend of
--   a Haskell module. Currently one always gets a
--   <a>FrontendTypecheck</a>, since running the frontend involves
--   typechecking a program. hs-sig merges are not handled here.
--   
--   This data type really should be in GHC.Driver.Env, but it needs to
--   have a TcGblEnv which is only defined here.
data FrontendResult
FrontendTypecheck :: TcGblEnv -> FrontendResult
type ErrCtxt = (Bool, TidyEnv -> TcM (TidyEnv, SDoc))
type RecFieldEnv = NameEnv [FieldLabel]
pushErrCtxt :: CtOrigin -> ErrCtxt -> CtLoc -> CtLoc
pushErrCtxtSameOrigin :: ErrCtxt -> CtLoc -> CtLoc

-- | <a>ImportAvails</a> summarises what was imported from where,
--   irrespective of whether the imported things are actually used or not.
--   It is used:
--   
--   <ul>
--   <li>when processing the export list,</li>
--   <li>when constructing usage info for the interface file,</li>
--   <li>to identify the list of directly imported modules for
--   initialisation purposes and for optimised overlap checking of family
--   instances,</li>
--   <li>when figuring out what things are really unused</li>
--   </ul>
data ImportAvails
ImportAvails :: ImportedMods -> InstalledModuleEnv ModuleNameWithIsBoot -> Set UnitId -> Bool -> Set UnitId -> InstalledModuleEnv ModuleNameWithIsBoot -> [ModuleName] -> [Module] -> [Module] -> ImportAvails

-- | Domain is all directly-imported modules
--   
--   See the documentation on ImportedModsVal in
--   <a>GHC.Unit.Module.Imported</a> for the meaning of the fields.
--   
--   We need a full ModuleEnv rather than a ModuleNameEnv here, because we
--   might be importing modules of the same name from different packages.
--   (currently not the case, but might be in the future).
[imp_mods] :: ImportAvails -> ImportedMods

-- | Home-package modules directly imported by the module being compiled.
[imp_direct_dep_mods] :: ImportAvails -> InstalledModuleEnv ModuleNameWithIsBoot

-- | Packages directly needed by the module being compiled
[imp_dep_direct_pkgs] :: ImportAvails -> Set UnitId

-- | Do we require that our own package is trusted? This is to handle
--   efficiently the case where a Safe module imports a Trustworthy module
--   that resides in the same package as it. See Note [Trust Own Package]
--   in <a>GHC.Rename.Names</a>
[imp_trust_own_pkg] :: ImportAvails -> Bool

-- | This records the packages the current module needs to trust for Safe
--   Haskell compilation to succeed. A package is required to be trusted if
--   we are dependent on a trustworthy module in that package. See Note
--   [Tracking Trust Transitively] in <a>GHC.Rename.Names</a>
[imp_trust_pkgs] :: ImportAvails -> Set UnitId

-- | Domain is all modules which have hs-boot files, and whether we should
--   import the boot version of interface file. Only used in one-shot mode
--   to populate eps_is_boot.
[imp_boot_mods] :: ImportAvails -> InstalledModuleEnv ModuleNameWithIsBoot

-- | Signature modules below this one
[imp_sig_mods] :: ImportAvails -> [ModuleName]

-- | Orphan modules below us in the import tree (and maybe including us for
--   imported modules)
[imp_orphs] :: ImportAvails -> [Module]

-- | Family instance modules below us in the import tree (and maybe
--   including us for imported modules)
[imp_finsts] :: ImportAvails -> [Module]
emptyImportAvails :: ImportAvails

-- | Union two ImportAvails
--   
--   This function is a key part of Import handling, basically for each
--   import we create a separate ImportAvails structure and then union them
--   all together with this function.
plusImportAvails :: ImportAvails -> ImportAvails -> ImportAvails
data WhereFrom
ImportByUser :: IsBootInterface -> WhereFrom
ImportBySystem :: WhereFrom
ImportByPlugin :: WhereFrom
mkModDeps :: Set (UnitId, ModuleNameWithIsBoot) -> InstalledModuleEnv ModuleNameWithIsBoot
type TcTypeEnv = NameEnv TcTyThing
type TcBinderStack = [TcBinder]
data TcBinder
TcIdBndr :: TcId -> TopLevelFlag -> TcBinder
TcIdBndr_ExpType :: Name -> ExpType -> TopLevelFlag -> TcBinder
TcTvBndr :: Name -> TyVar -> TcBinder

-- | A typecheckable thing available in a local context. Could be
--   <a>AGlobal</a> <a>TyThing</a>, but also lexically scoped variables,
--   etc. See <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a>
--   given a <a>Name</a>.
data TcTyThing
AGlobal :: TyThing -> TcTyThing
ATcId :: TcId -> IdBindingInfo -> TcTyThing
[tct_id] :: TcTyThing -> TcId
[tct_info] :: TcTyThing -> IdBindingInfo
ATyVar :: Name -> TcTyVar -> TcTyThing
ATcTyCon :: TyCon -> TcTyThing
APromotionErr :: PromotionErr -> TcTyThing

-- | Matches on either a global <a>TyCon</a> or a <a>TcTyCon</a>.
tcTyThingTyCon_maybe :: TcTyThing -> Maybe TyCon
data PromotionErr
TyConPE :: PromotionErr
ClassPE :: PromotionErr
FamDataConPE :: PromotionErr
ConstrainedDataConPE :: PredType -> PromotionErr
PatSynPE :: PromotionErr
RecDataConPE :: PromotionErr
TermVariablePE :: PromotionErr
NoDataKindsDC :: PromotionErr

-- | IdBindingInfo describes how an Id is bound.
--   
--   It is used for the following purposes: a) for static forms in
--   <a>checkClosedInStaticForm</a> and b) to figure out when a nested
--   binding can be generalised, in <a>decideGeneralisationPlan</a>.
data IdBindingInfo
NotLetBound :: IdBindingInfo
ClosedLet :: IdBindingInfo
NonClosedLet :: RhsNames -> ClosedTypeId -> IdBindingInfo
type ClosedTypeId = Bool
type RhsNames = NameSet

-- | IsGroupClosed describes a group of mutually-recursive bindings
data IsGroupClosed
IsGroupClosed :: NameEnv RhsNames -> ClosedTypeId -> IsGroupClosed
data SelfBootInfo
NoSelfBoot :: SelfBootInfo
SelfBoot :: ModDetails -> NameSet -> SelfBootInfo
[sb_mds] :: SelfBootInfo -> ModDetails
[sb_tcs] :: SelfBootInfo -> NameSet
bootExports :: SelfBootInfo -> NameSet
tcTyThingCategory :: TcTyThing -> String
pprTcTyThingCategory :: TcTyThing -> SDoc
peCategory :: PromotionErr -> String
pprPECategory :: PromotionErr -> SDoc

-- | A list of conlikes which represents a complete pattern match. These
--   arise from <tt>COMPLETE</tt> signatures. See also Note [Implementation
--   of COMPLETE pragmas].
data CompleteMatch
type CompleteMatches = [CompleteMatch]
data ThStage
Splice :: SpliceType -> ThStage
RunSplice :: TcRef [ForeignRef (Q ())] -> ThStage
Comp :: ThStage
Brack :: ThStage -> PendingStuff -> ThStage
data SpliceType
Typed :: SpliceType
Untyped :: SpliceType
data PendingStuff
RnPendingUntyped :: TcRef [PendingRnSplice] -> PendingStuff
RnPendingTyped :: PendingStuff
TcPending :: TcRef [PendingTcSplice] -> TcRef WantedConstraints -> QuoteWrapper -> PendingStuff
topStage :: ThStage
topAnnStage :: ThStage
topSpliceStage :: ThStage
type ThLevel = Int
impLevel :: ThLevel
outerLevel :: ThLevel
thLevel :: ThStage -> ThLevel
data () => ForeignSrcLang
LangC :: ForeignSrcLang
LangCxx :: ForeignSrcLang
LangObjc :: ForeignSrcLang
LangObjcxx :: ForeignSrcLang
LangAsm :: ForeignSrcLang
LangJs :: ForeignSrcLang
RawObject :: ForeignSrcLang

-- | The current collection of docs that Template Haskell has built up via
--   putDoc.
type THDocs = Map DocLoc (HsDoc GhcRn)

-- | This is a mirror of Template Haskell's DocLoc, but the TH names are
--   resolved to GHC names.
data DocLoc
DeclDoc :: Name -> DocLoc
ArgDoc :: Name -> Int -> DocLoc
InstDoc :: Name -> DocLoc
ModuleDoc :: DocLoc
type ThBindEnv = NameEnv (TopLevelFlag, ThLevel)
data ArrowCtxt
NoArrowCtxt :: ArrowCtxt
ArrowCtxt :: LocalRdrEnv -> TcRef WantedConstraints -> ArrowCtxt
type TcSigFun = Name -> Maybe TcSigInfo
data TcSigInfo
TcIdSig :: TcIdSigInfo -> TcSigInfo
TcPatSynSig :: TcPatSynInfo -> TcSigInfo
data TcIdSigInfo
CompleteSig :: TcId -> UserTypeCtxt -> SrcSpan -> TcIdSigInfo
[sig_bndr] :: TcIdSigInfo -> TcId
[sig_ctxt] :: TcIdSigInfo -> UserTypeCtxt
[sig_loc] :: TcIdSigInfo -> SrcSpan
PartialSig :: Name -> LHsSigWcType GhcRn -> UserTypeCtxt -> SrcSpan -> TcIdSigInfo
[psig_name] :: TcIdSigInfo -> Name
[psig_hs_ty] :: TcIdSigInfo -> LHsSigWcType GhcRn
[sig_ctxt] :: TcIdSigInfo -> UserTypeCtxt
[sig_loc] :: TcIdSigInfo -> SrcSpan
data TcIdSigInst
TISI :: TcIdSigInfo -> [(Name, InvisTVBinder)] -> TcThetaType -> TcSigmaType -> [(Name, TcTyVar)] -> Maybe TcType -> TcIdSigInst
[sig_inst_sig] :: TcIdSigInst -> TcIdSigInfo
[sig_inst_skols] :: TcIdSigInst -> [(Name, InvisTVBinder)]
[sig_inst_theta] :: TcIdSigInst -> TcThetaType
[sig_inst_tau] :: TcIdSigInst -> TcSigmaType
[sig_inst_wcs] :: TcIdSigInst -> [(Name, TcTyVar)]
[sig_inst_wcx] :: TcIdSigInst -> Maybe TcType
data TcPatSynInfo
TPSI :: Name -> [InvisTVBinder] -> [InvisTVBinder] -> TcThetaType -> [InvisTVBinder] -> TcThetaType -> TcSigmaType -> TcPatSynInfo
[patsig_name] :: TcPatSynInfo -> Name
[patsig_implicit_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_univ_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_req] :: TcPatSynInfo -> TcThetaType
[patsig_ex_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_prov] :: TcPatSynInfo -> TcThetaType
[patsig_body_ty] :: TcPatSynInfo -> TcSigmaType
isPartialSig :: TcIdSigInst -> Bool

-- | No signature or a partial signature
hasCompleteSig :: TcSigFun -> Name -> Bool
type TcId = Id
type TcIdSet = IdSet

-- | A <a>NameShape</a> is a substitution on <a>Name</a>s that can be used
--   to refine the identities of a hole while we are renaming interfaces
--   (see <a>GHC.Iface.Rename</a>). Specifically, a <a>NameShape</a> for
--   <tt>ns_module_name</tt> <tt>A</tt>, defines a mapping from
--   <tt>{A.T}</tt> (for some <a>OccName</a> <tt>T</tt>) to some arbitrary
--   other <a>Name</a>.
--   
--   The most intriguing thing about a <a>NameShape</a>, however, is how
--   it's constructed. A <a>NameShape</a> is *implied* by the exported
--   <a>AvailInfo</a>s of the implementor of an interface: if an
--   implementor of signature <tt>&lt;H&gt;</tt> exports <tt>M.T</tt>, you
--   implicitly define a substitution from <tt>{H.T}</tt> to <tt>M.T</tt>.
--   So a <a>NameShape</a> is computed from the list of <a>AvailInfo</a>s
--   that are exported by the implementation of a module, or successively
--   merged together by the export lists of signatures which are joining
--   together.
--   
--   It's not the most obvious way to go about doing this, but it does seem
--   to work!
--   
--   NB: Can't boot this and put it in NameShape because then we start
--   pulling in too many DynFlags things.
data NameShape
NameShape :: ModuleName -> [AvailInfo] -> OccEnv Name -> NameShape
[ns_mod_name] :: NameShape -> ModuleName
[ns_exports] :: NameShape -> [AvailInfo]
[ns_map] :: NameShape -> OccEnv Name
removeBindingShadowing :: HasOccName a => [a] -> [a]

-- | Get target platform
getPlatform :: TcRnIf a b Platform
data TcPlugin
TcPlugin :: TcPluginM s -> (s -> TcPluginSolver) -> (s -> UniqFM TyCon TcPluginRewriter) -> (s -> TcPluginM ()) -> TcPlugin

-- | Initialize plugin, when entering type-checker.
[tcPluginInit] :: TcPlugin -> TcPluginM s

-- | Solve some constraints.
--   
--   This function will be invoked at two points in the constraint solving
--   process: once to simplify Given constraints, and once to solve Wanted
--   constraints. In the first case (and only in the first case), no Wanted
--   constraints will be passed to the plugin.
--   
--   The plugin can either return a contradiction, or specify that it has
--   solved some constraints (with evidence), and possibly emit additional
--   constraints. These returned constraints must be Givens in the first
--   case, and Wanteds in the second.
--   
--   Use <tt> \ _ _ _ _ _ -&gt; pure $ TcPluginOK [] [] </tt> if your
--   plugin does not provide this functionality.
[tcPluginSolve] :: TcPlugin -> s -> TcPluginSolver

-- | Rewrite saturated type family applications.
--   
--   The plugin is expected to supply a mapping from type family names to
--   rewriting functions. For each type family <a>TyCon</a>, the plugin
--   should provide a function which takes in the given constraints and
--   arguments of a saturated type family application, and return a
--   possible rewriting. See <a>TcPluginRewriter</a> for the expected shape
--   of such a function.
--   
--   Use <tt> \ _ -&gt; emptyUFM </tt> if your plugin does not provide this
--   functionality.
[tcPluginRewrite] :: TcPlugin -> s -> UniqFM TyCon TcPluginRewriter

-- | Clean up after the plugin, when exiting the type-checker.
[tcPluginStop] :: TcPlugin -> s -> TcPluginM ()

-- | Result of running a solver plugin.
data TcPluginSolveResult
TcPluginSolveResult :: [Ct] -> [(EvTerm, Ct)] -> [Ct] -> TcPluginSolveResult

-- | Insoluble constraints found by the plugin.
--   
--   These constraints will be added to the inert set, and reported as
--   insoluble to the user.
[tcPluginInsolubleCts] :: TcPluginSolveResult -> [Ct]

-- | Solved constraints, together with their evidence.
--   
--   These are removed from the inert set, and the evidence for them is
--   recorded.
[tcPluginSolvedCts] :: TcPluginSolveResult -> [(EvTerm, Ct)]

-- | New constraints that the plugin wishes to emit.
--   
--   These will be added to the work list.
[tcPluginNewCts] :: TcPluginSolveResult -> [Ct]

-- | The plugin found a contradiction. The returned constraints are removed
--   from the inert set, and recorded as insoluble.
--   
--   The returned list of constraints should never be empty.
pattern TcPluginContradiction :: [Ct] -> TcPluginSolveResult

-- | The plugin has not found any contradictions,
--   
--   The first field is for constraints that were solved. The second field
--   contains new work, that should be processed by the constraint solver.
pattern TcPluginOk :: [(EvTerm, Ct)] -> [Ct] -> TcPluginSolveResult
data TcPluginRewriteResult

-- | The plugin does not rewrite the type family application.
TcPluginNoRewrite :: TcPluginRewriteResult

-- | The plugin rewrites the type family application providing a rewriting
--   together with evidence: a <a>Reduction</a>, which contains the
--   rewritten type together with a <tt>Coercion</tt> whose right-hand-side
--   type is the rewritten type.
--   
--   The plugin can also emit additional Wanted constraints.
TcPluginRewriteTo :: !Reduction -> [Ct] -> TcPluginRewriteResult
[tcPluginReduction] :: TcPluginRewriteResult -> !Reduction
[tcRewriterNewWanteds] :: TcPluginRewriteResult -> [Ct]

-- | The <tt>solve</tt> function of a type-checking plugin takes in Given
--   and Wanted constraints, and should return a <a>TcPluginSolveResult</a>
--   indicating which Wanted constraints it could solve, or whether any are
--   insoluble.
type TcPluginSolver = EvBindsVar -> -- | Givens [Ct] -> -- | Wanteds [Ct] -> TcPluginM TcPluginSolveResult

-- | For rewriting type family applications, a type-checking plugin
--   provides a function of this type for each type family <a>TyCon</a>.
--   
--   The function is provided with the current set of Given constraints,
--   together with the arguments to the type family. The type family
--   application will always be fully saturated.
type TcPluginRewriter = -- | Rewriter environment RewriteEnv -> -- | Givens [Ct] -> -- | type family arguments [TcType] -> TcPluginM TcPluginRewriteResult

-- | <a>TcPluginM</a> is the monad in which type-checking plugins operate.
data TcPluginM a

-- | This function provides an escape for direct access to the <a>TcM</a>
--   monad. It should not be used lightly, and the provided
--   <a>TcPluginM</a> API should be favoured instead.
unsafeTcPluginTcM :: TcM a -> TcPluginM a

-- | A plugin for controlling defaulting.
data DefaultingPlugin
DefaultingPlugin :: TcPluginM s -> (s -> FillDefaulting) -> (s -> TcPluginM ()) -> DefaultingPlugin

-- | Initialize plugin, when entering type-checker.
[dePluginInit] :: DefaultingPlugin -> TcPluginM s

-- | Default some types
[dePluginRun] :: DefaultingPlugin -> s -> FillDefaulting

-- | Clean up after the plugin, when exiting the type-checker.
[dePluginStop] :: DefaultingPlugin -> s -> TcPluginM ()

-- | A collection of candidate default types for a type variable.
data DefaultingProposal
DefaultingProposal :: TcTyVar -> [Type] -> [Ct] -> DefaultingProposal

-- | The type variable to default.
[deProposalTyVar] :: DefaultingProposal -> TcTyVar

-- | Candidate types to default the type variable to.
[deProposalCandidates] :: DefaultingProposal -> [Type]

-- | The constraints against which defaults are checked.
[deProposalCts] :: DefaultingProposal -> [Ct]
type FillDefaulting = WantedConstraints -> TcPluginM [DefaultingProposal]
type DefaultingPluginResult = [DefaultingProposal]
type RoleAnnotEnv = NameEnv (LRoleAnnotDecl GhcRn)
emptyRoleAnnotEnv :: RoleAnnotEnv
mkRoleAnnotEnv :: [LRoleAnnotDecl GhcRn] -> RoleAnnotEnv
lookupRoleAnnot :: RoleAnnotEnv -> Name -> Maybe (LRoleAnnotDecl GhcRn)
getRoleAnnots :: [Name] -> RoleAnnotEnv -> [LRoleAnnotDecl GhcRn]

-- | Check the <a>TcGblEnv</a> for consistency. Currently, only checks
--   axioms, but should check other aspects, too.
lintGblEnv :: Logger -> DynFlags -> TcGblEnv -> TcM ()

-- | An error which might arise during typechecking/renaming.
data TcRnMessage
instance GHC.Classes.Ord GHC.Tc.Types.DocLoc
instance GHC.Classes.Eq GHC.Tc.Types.DocLoc
instance Control.Monad.Fail.MonadFail GHC.Tc.Types.TcPluginM
instance GHC.Base.Monad GHC.Tc.Types.TcPluginM
instance GHC.Base.Applicative GHC.Tc.Types.TcPluginM
instance GHC.Base.Functor GHC.Tc.Types.TcPluginM
instance GHC.Unit.Module.ContainsModule GHC.Tc.Types.TcGblEnv
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.DefaultingProposal
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcSigInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcPatSynInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcIdSigInst
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcIdSigInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.WhereFrom
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcTyThing
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.IdBindingInfo
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.ThStage
instance GHC.Utils.Outputable.Outputable GHC.Tc.Types.TcBinder
instance GHC.Types.Name.Occurrence.HasOccName GHC.Tc.Types.TcBinder
instance GHC.Driver.Session.ContainsDynFlags (GHC.Tc.Types.Env gbl lcl)
instance GHC.Driver.Hooks.ContainsHooks (GHC.Tc.Types.Env gbl lcl)
instance GHC.Utils.Logger.ContainsLogger (GHC.Tc.Types.Env gbl lcl)
instance GHC.Unit.Module.ContainsModule gbl => GHC.Unit.Module.ContainsModule (GHC.Tc.Types.Env gbl lcl)


-- | Functions for working with the typechecker environment (setters,
--   getters...).
module GHC.Tc.Utils.Monad

-- | Setup the initial typechecking environment
initTc :: HscEnv -> HscSource -> Bool -> Module -> RealSrcSpan -> TcM r -> IO (Messages TcRnMessage, Maybe r)

-- | Run a <a>TcM</a> action in the context of an existing <tt>GblEnv</tt>.
initTcWithGbl :: HscEnv -> TcGblEnv -> RealSrcSpan -> TcM r -> IO (Messages TcRnMessage, Maybe r)
initTcInteractive :: HscEnv -> TcM a -> IO (Messages TcRnMessage, Maybe a)
initTcRnIf :: Char -> HscEnv -> gbl -> lcl -> TcRnIf gbl lcl a -> IO a
discardResult :: TcM a -> TcM ()
getTopEnv :: TcRnIf gbl lcl HscEnv
updTopEnv :: (HscEnv -> HscEnv) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
getGblEnv :: TcRnIf gbl lcl gbl
updGblEnv :: (gbl -> gbl) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
setGblEnv :: gbl' -> TcRnIf gbl' lcl a -> TcRnIf gbl lcl a
getLclEnv :: TcRnIf gbl lcl lcl
updLclEnv :: (lcl -> lcl) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
setLclEnv :: lcl' -> TcRnIf gbl lcl' a -> TcRnIf gbl lcl a
restoreLclEnv :: TcLclEnv -> TcRnIf gbl TcLclEnv a -> TcRnIf gbl TcLclEnv a
updTopFlags :: (DynFlags -> DynFlags) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
getEnvs :: TcRnIf gbl lcl (gbl, lcl)
setEnvs :: (gbl', lcl') -> TcRnIf gbl' lcl' a -> TcRnIf gbl lcl a
updEnvs :: ((gbl, lcl) -> (gbl, lcl)) -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
restoreEnvs :: (TcGblEnv, TcLclEnv) -> TcRn a -> TcRn a
xoptM :: Extension -> TcRnIf gbl lcl Bool
doptM :: DumpFlag -> TcRnIf gbl lcl Bool
goptM :: GeneralFlag -> TcRnIf gbl lcl Bool
woptM :: WarningFlag -> TcRnIf gbl lcl Bool
setXOptM :: Extension -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetXOptM :: Extension -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetGOptM :: GeneralFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetWOptM :: WarningFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a

-- | Do it flag is true
whenDOptM :: DumpFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
whenGOptM :: GeneralFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
whenWOptM :: WarningFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
whenXOptM :: Extension -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
unlessXOptM :: Extension -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
getGhcMode :: TcRnIf gbl lcl GhcMode
withoutDynamicNow :: TcRnIf gbl lcl a -> TcRnIf gbl lcl a
getEpsVar :: TcRnIf gbl lcl (TcRef ExternalPackageState)
getEps :: TcRnIf gbl lcl ExternalPackageState

-- | Update the external package state. Returns the second result of the
--   modifier function.
--   
--   This is an atomic operation and forces evaluation of the modified EPS
--   in order to avoid space leaks.
updateEps :: (ExternalPackageState -> (ExternalPackageState, a)) -> TcRnIf gbl lcl a

-- | Update the external package state.
--   
--   This is an atomic operation and forces evaluation of the modified EPS
--   in order to avoid space leaks.
updateEps_ :: (ExternalPackageState -> ExternalPackageState) -> TcRnIf gbl lcl ()
getHpt :: TcRnIf gbl lcl HomePackageTable
getEpsAndHug :: TcRnIf gbl lcl (ExternalPackageState, HomeUnitGraph)
newArrowScope :: TcM a -> TcM a
escapeArrowScope :: TcM a -> TcM a
newUnique :: TcRnIf gbl lcl Unique
newUniqueSupply :: TcRnIf gbl lcl UniqSupply
newName :: OccName -> TcM Name
newNameAt :: OccName -> SrcSpan -> TcM Name
cloneLocalName :: Name -> TcM Name
newSysName :: OccName -> TcRnIf gbl lcl Name
newSysLocalId :: FastString -> Mult -> TcType -> TcRnIf gbl lcl TcId
newSysLocalIds :: FastString -> [Scaled TcType] -> TcRnIf gbl lcl [TcId]
newTcRef :: a -> TcRnIf gbl lcl (TcRef a)
readTcRef :: TcRef a -> TcRnIf gbl lcl a
writeTcRef :: TcRef a -> a -> TcRnIf gbl lcl ()
updTcRef :: TcRef a -> (a -> a) -> TcRnIf gbl lcl ()
traceTc :: String -> SDoc -> TcRn ()
traceRn :: String -> SDoc -> TcRn ()
traceOptTcRn :: DumpFlag -> SDoc -> TcRn ()

-- | Dump if the given <a>DumpFlag</a> is set.
dumpOptTcRn :: DumpFlag -> String -> DumpFormat -> SDoc -> TcRn ()

-- | Unconditionally dump some trace output
--   
--   Certain tests (T3017, Roles3, T12763 etc.) expect part of the output
--   generated by `-ddump-types` to be in <a>PprUser</a> style. However,
--   generally we want all other debugging output to use <a>PprDump</a>
--   style. We <a>PprUser</a> style if <tt>useUserStyle</tt> is True.
dumpTcRn :: Bool -> DumpFlag -> String -> DumpFormat -> SDoc -> TcRn ()
getNamePprCtx :: TcRn NamePprCtx

-- | Like logInfoTcRn, but for user consumption
printForUserTcRn :: SDoc -> TcRn ()
traceIf :: SDoc -> TcRnIf m n ()
traceOptIf :: DumpFlag -> SDoc -> TcRnIf m n ()
debugTc :: TcM () -> TcM ()
getIsGHCi :: TcRn Bool
getGHCiMonad :: TcRn Name
getInteractivePrintName :: TcRn Name
tcIsHsBootOrSig :: TcRn Bool
tcIsHsig :: TcRn Bool
tcSelfBootInfo :: TcRn SelfBootInfo
getGlobalRdrEnv :: TcRn GlobalRdrEnv
getRdrEnvs :: TcRn (GlobalRdrEnv, LocalRdrEnv)
getImports :: TcRn ImportAvails
getFixityEnv :: TcRn FixityEnv
extendFixityEnv :: [(Name, FixItem)] -> RnM a -> RnM a
getRecFieldEnv :: TcRn RecFieldEnv
getDeclaredDefaultTys :: TcRn (Maybe [Type])
addDependentFiles :: [FilePath] -> TcRn ()
getSrcSpanM :: TcRn SrcSpan
setSrcSpan :: SrcSpan -> TcRn a -> TcRn a
setSrcSpanA :: SrcSpanAnn' ann -> TcRn a -> TcRn a
addLocM :: (a -> TcM b) -> Located a -> TcM b
addLocMA :: (a -> TcM b) -> GenLocated (SrcSpanAnn' ann) a -> TcM b
inGeneratedCode :: TcRn Bool
wrapLocM :: (a -> TcM b) -> Located a -> TcM (Located b)
wrapLocAM :: (a -> TcM b) -> LocatedAn an a -> TcM (Located b)
wrapLocFstM :: (a -> TcM (b, c)) -> Located a -> TcM (Located b, c)
wrapLocFstMA :: (a -> TcM (b, c)) -> GenLocated (SrcSpanAnn' ann) a -> TcM (GenLocated (SrcSpanAnn' ann) b, c)
wrapLocSndM :: (a -> TcM (b, c)) -> Located a -> TcM (b, Located c)
wrapLocSndMA :: (a -> TcM (b, c)) -> GenLocated (SrcSpanAnn' ann) a -> TcM (b, GenLocated (SrcSpanAnn' ann) c)
wrapLocM_ :: (a -> TcM ()) -> Located a -> TcM ()
wrapLocMA_ :: (a -> TcM ()) -> LocatedA a -> TcM ()
wrapLocMA :: (a -> TcM b) -> GenLocated (SrcSpanAnn' ann) a -> TcRn (GenLocated (SrcSpanAnn' ann) b)
getErrsVar :: TcRn (TcRef (Messages TcRnMessage))
setErrsVar :: TcRef (Messages TcRnMessage) -> TcRn a -> TcRn a
addErr :: TcRnMessage -> TcRn ()
failWith :: TcRnMessage -> TcRn a
failAt :: SrcSpan -> TcRnMessage -> TcRn a
addErrAt :: SrcSpan -> TcRnMessage -> TcRn ()
addErrs :: [(SrcSpan, TcRnMessage)] -> TcRn ()
checkErr :: Bool -> TcRnMessage -> TcRn ()
addMessages :: Messages TcRnMessage -> TcRn ()
discardWarnings :: TcRn a -> TcRn a
mkDetailedMessage :: ErrInfo -> TcRnMessage -> TcRnMessageDetailed

-- | <tt>tcCollectingUsage thing_inside</tt> runs <tt>thing_inside</tt> and
--   returns the usage information which was collected as part of the
--   execution of <tt>thing_inside</tt>. Careful: <tt>tcCollectingUsage
--   thing_inside</tt> itself does not report any usage information, it's
--   up to the caller to incorporate the returned usage information into
--   the larger context appropriately.
tcCollectingUsage :: TcM a -> TcM (UsageEnv, a)

-- | <tt>tcScalingUsage mult thing_inside</tt> runs <tt>thing_inside</tt>
--   and scales all the usage information by <tt>mult</tt>.
tcScalingUsage :: Mult -> TcM a -> TcM a
tcEmitBindingUsage :: UsageEnv -> TcM ()
recoverM :: TcRn r -> TcRn r -> TcRn r

-- | Drop elements of the input that fail, so the result list can be
--   shorter than the argument list
mapAndRecoverM :: (a -> TcRn b) -> [a] -> TcRn [b]

-- | Apply the function to all elements on the input list If all succeed,
--   return the list of results Otherwise fail, propagating all errors
mapAndReportM :: (a -> TcRn b) -> [a] -> TcRn [b]

-- | The accumulator is not updated if the action fails
foldAndRecoverM :: (b -> a -> TcRn b) -> b -> [a] -> TcRn b
attemptM :: TcRn r -> TcRn (Maybe r)
tryTc :: TcRn a -> TcRn (Maybe a, Messages TcRnMessage)
askNoErrs :: TcRn a -> TcRn (a, Bool)
discardErrs :: TcRn a -> TcRn a
tryTcDiscardingErrs :: TcM r -> TcM r -> TcM r
checkNoErrs :: TcM r -> TcM r
whenNoErrs :: TcM () -> TcM ()
ifErrsM :: TcRn r -> TcRn r -> TcRn r
failIfErrsM :: TcRn ()
getErrCtxt :: TcM [ErrCtxt]
setErrCtxt :: [ErrCtxt] -> TcM a -> TcM a

-- | Add a fixed message to the error context. This message should not do
--   any tidying.
addErrCtxt :: SDoc -> TcM a -> TcM a

-- | Add a message to the error context. This message may do tidying.
addErrCtxtM :: (TidyEnv -> TcM (TidyEnv, SDoc)) -> TcM a -> TcM a

-- | Add a fixed landmark message to the error context. A landmark message
--   is always sure to be reported, even if there is a lot of context. It
--   also doesn't count toward the maximum number of contexts reported.
addLandmarkErrCtxt :: SDoc -> TcM a -> TcM a

-- | Variant of <a>addLandmarkErrCtxt</a> that allows for monadic
--   operations and tidying.
addLandmarkErrCtxtM :: (TidyEnv -> TcM (TidyEnv, SDoc)) -> TcM a -> TcM a
popErrCtxt :: TcM a -> TcM a
getCtLocM :: CtOrigin -> Maybe TypeOrKind -> TcM CtLoc
setCtLocM :: CtLoc -> TcM a -> TcM a
addErrTc :: TcRnMessage -> TcM ()
addErrTcM :: (TidyEnv, TcRnMessage) -> TcM ()
failWithTc :: TcRnMessage -> TcM a
failWithTcM :: (TidyEnv, TcRnMessage) -> TcM a
checkTc :: Bool -> TcRnMessage -> TcM ()
checkTcM :: Bool -> (TidyEnv, TcRnMessage) -> TcM ()
failIfTc :: Bool -> TcRnMessage -> TcM ()
failIfTcM :: Bool -> (TidyEnv, TcRnMessage) -> TcM ()
mkErrInfo :: TidyEnv -> [ErrCtxt] -> TcM SDoc
addTcRnDiagnostic :: TcRnMessage -> TcM ()

-- | A variation of <a>addDiagnostic</a> that takes a function to produce a
--   <tt>TcRnDsMessage</tt> given some additional context about the
--   diagnostic.
addDetailedDiagnostic :: (ErrInfo -> TcRnMessage) -> TcM ()
mkTcRnMessage :: SrcSpan -> TcRnMessage -> TcRn (MsgEnvelope TcRnMessage)
reportDiagnostic :: MsgEnvelope TcRnMessage -> TcRn ()
reportDiagnostics :: [MsgEnvelope TcRnMessage] -> TcM ()

-- | Display a warning if a condition is met.
warnIf :: Bool -> TcRnMessage -> TcRn ()

-- | Display a warning if a condition is met.
diagnosticTc :: Bool -> TcRnMessage -> TcM ()

-- | Display a diagnostic if a condition is met.
diagnosticTcM :: Bool -> (TidyEnv, TcRnMessage) -> TcM ()

-- | Display a diagnostic in the current context.
addDiagnosticTc :: TcRnMessage -> TcM ()

-- | Display a diagnostic in a given context.
addDiagnosticTcM :: (TidyEnv, TcRnMessage) -> TcM ()

-- | Display a diagnostic for the current source location, taken from the
--   <a>TcRn</a> monad.
addDiagnostic :: TcRnMessage -> TcRn ()

-- | Display a diagnostic for a given source location.
addDiagnosticAt :: SrcSpan -> TcRnMessage -> TcRn ()
newTcEvBinds :: TcM EvBindsVar

-- | Creates an EvBindsVar incapable of holding any bindings. It still
--   tracks covar usages (see comments on ebv_tcvs in
--   <a>GHC.Tc.Types.Evidence</a>), thus must be made monadically
newNoTcEvBinds :: TcM EvBindsVar
cloneEvBindsVar :: EvBindsVar -> TcM EvBindsVar
addTcEvBind :: EvBindsVar -> EvBind -> TcM ()
addTopEvBinds :: Bag EvBind -> TcM a -> TcM a
getTcEvTyCoVars :: EvBindsVar -> TcM TyCoVarSet
getTcEvBindsMap :: EvBindsVar -> TcM EvBindMap
setTcEvBindsMap :: EvBindsVar -> EvBindMap -> TcM ()
chooseUniqueOccTc :: (OccSet -> OccName) -> TcM OccName
getConstraintVar :: TcM (TcRef WantedConstraints)
setConstraintVar :: TcRef WantedConstraints -> TcM a -> TcM a
emitConstraints :: WantedConstraints -> TcM ()
emitStaticConstraints :: WantedConstraints -> TcM ()
emitSimple :: Ct -> TcM ()
emitSimples :: Cts -> TcM ()
emitImplication :: Implication -> TcM ()
emitImplications :: Bag Implication -> TcM ()
emitInsoluble :: Ct -> TcM ()
emitDelayedErrors :: Bag DelayedError -> TcM ()
emitHole :: Hole -> TcM ()
emitHoles :: Bag Hole -> TcM ()
emitNotConcreteError :: NotConcreteError -> TcM ()

-- | Throw out any constraints emitted by the thing_inside
discardConstraints :: TcM a -> TcM a
captureConstraints :: TcM a -> TcM (a, WantedConstraints)
tryCaptureConstraints :: TcM a -> TcM (Maybe a, WantedConstraints)

-- | The name says it all. The returned TcLevel is the *inner* TcLevel.
pushLevelAndCaptureConstraints :: TcM a -> TcM (TcLevel, WantedConstraints, a)
pushTcLevelM_ :: TcM a -> TcM a
pushTcLevelM :: TcM a -> TcM (TcLevel, a)
getTcLevel :: TcM TcLevel
setTcLevel :: TcLevel -> TcM a -> TcM a
isTouchableTcM :: TcTyVar -> TcM Bool
getLclTypeEnv :: TcM TcTypeEnv
setLclTypeEnv :: TcLclEnv -> TcM a -> TcM a
traceTcConstraints :: String -> TcM ()
emitNamedTypeHole :: (Name, TcTyVar) -> TcM ()
data IsExtraConstraint
YesExtraConstraint :: IsExtraConstraint
NoExtraConstraint :: IsExtraConstraint
emitAnonTypeHole :: IsExtraConstraint -> TcTyVar -> TcM ()
recordThUse :: TcM ()
recordThSpliceUse :: TcM ()
recordThNeededRuntimeDeps :: [Linkable] -> PkgsLoaded -> TcM ()
keepAlive :: Name -> TcRn ()
getStage :: TcM ThStage
getStageAndBindLevel :: Name -> TcRn (Maybe (TopLevelFlag, ThLevel, ThStage))
setStage :: ThStage -> TcM a -> TcRn a

-- | Adds the given modFinalizers to the global environment and set them to
--   use the current local environment.
addModFinalizersWithLclEnv :: ThModFinalizers -> TcM ()

-- | Mark that safe inference has failed See Note [Safe Haskell Overlapping
--   Instances Implementation] although this is used for more than just
--   that failure case.
recordUnsafeInfer :: Messages TcRnMessage -> TcM ()

-- | Figure out the final correct safe haskell mode
finalSafeMode :: DynFlags -> TcGblEnv -> IO SafeHaskellMode

-- | Switch instances to safe instances if we're in Safe mode.
fixSafeInstances :: SafeHaskellMode -> [ClsInst] -> [ClsInst]
getLocalRdrEnv :: RnM LocalRdrEnv
setLocalRdrEnv :: LocalRdrEnv -> RnM a -> RnM a
mkIfLclEnv :: Module -> SDoc -> IsBootInterface -> IfLclEnv

-- | Run an <a>IfG</a> (top-level interface monad) computation inside an
--   existing <a>TcRn</a> (typecheck-renaming monad) computation by
--   initializing an <a>IfGblEnv</a> based on <a>TcGblEnv</a>.
initIfaceTcRn :: IfG a -> TcRn a
initIfaceCheck :: SDoc -> HscEnv -> IfG a -> IO a
initIfaceLcl :: Module -> SDoc -> IsBootInterface -> IfL a -> IfM lcl a

-- | Initialize interface typechecking, but with a <a>NameShape</a> to
--   apply when typechecking top-level <a>OccName</a>s (see
--   <tt>lookupIfaceTop</tt>)
initIfaceLclWithSubst :: Module -> SDoc -> IsBootInterface -> NameShape -> IfL a -> IfM lcl a

-- | <a>initIfaceLoad</a> can be used when there's no chance that the
--   action will call <tt>typecheckIface</tt> when inside a module loop and
--   hence <tt>tcIfaceGlobal</tt>.
initIfaceLoad :: HscEnv -> IfG a -> IO a

-- | This is used when we are doing to call <tt>typecheckModule</tt> on an
--   <tt>ModIface</tt>, if it's part of a loop with some other modules then
--   we need to use their IORef TypeEnv vars when typechecking but
--   crucially not our own.
initIfaceLoadModule :: HscEnv -> Module -> IfG a -> IO a
getIfModule :: IfL Module
failIfM :: SDoc -> IfL a

-- | Run thing_inside in an interleaved thread. It shares everything with
--   the parent thread, so this is DANGEROUS.
--   
--   It throws an error if the computation fails
--   
--   It's used for lazily type-checking interface signatures, which is
--   pretty benign.
--   
--   See Note [Masking exceptions in forkM]
forkM :: SDoc -> IfL a -> IfL a
setImplicitEnvM :: TypeEnv -> IfL a -> IfL a

-- | A convenient wrapper for taking a <tt>MaybeErr SDoc a</tt> and
--   throwing an exception if it is an error.
withException :: MonadIO m => SDocContext -> m (MaybeErr SDoc a) -> m a

-- | Get the next cost centre index associated with a given name.
getCCIndexM :: (gbl -> TcRef CostCentreState) -> FastString -> TcRnIf gbl lcl CostCentreIndex

-- | See <a>getCCIndexM</a>.
getCCIndexTcM :: FastString -> TcM CostCentreIndex
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.Monad.IsExtraConstraint
instance GHC.Types.Unique.Supply.MonadUnique (GHC.Data.IOEnv.IOEnv (GHC.Tc.Types.Env gbl lcl))


-- | Monadic type operations
--   
--   This module contains monadic operations over types that contain
--   mutable type variables.
module GHC.Tc.Utils.TcMType

-- | Type variable that might be a metavariable
type TcTyVar = Var
type TcKind = Kind
type TcType = Type
type TcTauType = TcType
type TcThetaType = ThetaType
type TcTyVarSet = TyVarSet
newFlexiTyVar :: Kind -> TcM TcTyVar

-- | Create a new flexi ty var with a specific name
newNamedFlexiTyVar :: FastString -> Kind -> TcM TcTyVar
newFlexiTyVarTy :: Kind -> TcM TcType
newFlexiTyVarTys :: Int -> Kind -> TcM [TcType]
newOpenFlexiTyVar :: TcM TcTyVar

-- | Create a tyvar that can be a lifted or unlifted type. Returns alpha ::
--   TYPE kappa, where both alpha and kappa are fresh
newOpenFlexiTyVarTy :: TcM TcType
newOpenTypeKind :: TcM TcKind
newOpenBoxedTypeKind :: TcM TcKind
newMetaKindVar :: TcM TcKind
newMetaKindVars :: Int -> TcM [TcKind]
newMetaTyVarTyAtLevel :: TcLevel -> TcKind -> TcM TcType
newAnonMetaTyVar :: MetaInfo -> Kind -> TcM TcTyVar

-- | Create a new metavariable, of the given kind, which can only be
--   unified with a concrete type.
--   
--   Invariant: the kind must be concrete, as per Note [ConcreteTv]. This
--   is checked with an assertion.
newConcreteTyVar :: HasDebugCallStack => ConcreteTvOrigin -> TcKind -> TcM TcTyVar
cloneMetaTyVar :: TcTyVar -> TcM TcTyVar
newCycleBreakerTyVar :: TcKind -> TcM TcTyVar
newMultiplicityVar :: TcM TcType
readMetaTyVar :: TyVar -> TcM MetaDetails
writeMetaTyVar :: HasDebugCallStack => TcTyVar -> TcType -> TcM ()
writeMetaTyVarRef :: HasDebugCallStack => TcTyVar -> TcRef MetaDetails -> TcType -> TcM ()
newTauTvDetailsAtLevel :: TcLevel -> TcM TcTyVarDetails
newMetaDetails :: MetaInfo -> TcM TcTyVarDetails
newMetaTyVarName :: FastString -> TcM Name
isFilledMetaTyVar_maybe :: TcTyVar -> TcM (Maybe Type)
isFilledMetaTyVar :: TyVar -> TcM Bool
isUnfilledMetaTyVar :: TyVar -> TcM Bool
newEvVar :: TcPredType -> TcRnIf gbl lcl EvVar
newEvVars :: TcThetaType -> TcM [EvVar]
newDict :: Class -> [TcType] -> TcM DictId

-- | Create a new Wanted constraint with the given <a>CtLoc</a>.
newWantedWithLoc :: CtLoc -> PredType -> TcM CtEvidence

-- | Create a new Wanted constraint with the given <a>CtOrigin</a>, and
--   location information taken from the <a>TcM</a> environment.
newWanted :: CtOrigin -> Maybe TypeOrKind -> PredType -> TcM CtEvidence

-- | Create new Wanted constraints with the given <a>CtOrigin</a>, and
--   location information taken from the <a>TcM</a> environment.
newWanteds :: CtOrigin -> ThetaType -> TcM [CtEvidence]
cloneWanted :: Ct -> TcM Ct
cloneWC :: WantedConstraints -> TcM WantedConstraints
cloneWantedCtEv :: CtEvidence -> TcM CtEvidence

-- | Emits a new Wanted. Deals with both equalities and non-equalities.
emitWanted :: CtOrigin -> TcPredType -> TcM EvTerm

-- | Emits a new equality constraint
emitWantedEq :: CtOrigin -> TypeOrKind -> Role -> TcType -> TcType -> TcM Coercion

-- | Creates a new EvVar and immediately emits it as a Wanted. No equality
--   predicates here.
emitWantedEvVar :: CtOrigin -> TcPredType -> TcM EvVar
emitWantedEvVars :: CtOrigin -> [TcPredType] -> TcM [EvVar]
emitWantedEqs :: CtOrigin -> [(TcType, TcType)] -> TcM ()
newTcEvBinds :: TcM EvBindsVar

-- | Creates an EvBindsVar incapable of holding any bindings. It still
--   tracks covar usages (see comments on ebv_tcvs in
--   <a>GHC.Tc.Types.Evidence</a>), thus must be made monadically
newNoTcEvBinds :: TcM EvBindsVar
addTcEvBind :: EvBindsVar -> EvBind -> TcM ()

-- | Emit a new wanted expression hole
emitNewExprHole :: RdrName -> Type -> TcM HoleExprRef
newCoercionHole :: TcPredType -> TcM CoercionHole

-- | Put a value in a coercion hole
fillCoercionHole :: CoercionHole -> Coercion -> TcM ()

-- | Is a coercion hole filled in?
isFilledCoercionHole :: CoercionHole -> TcM Bool

-- | Retrieve the contents of a coercion hole. Panics if the hole is
--   unfilled
unpackCoercionHole :: CoercionHole -> TcM Coercion

-- | Retrieve the contents of a coercion hole, if it is filled
unpackCoercionHole_maybe :: CoercionHole -> TcM (Maybe Coercion)

-- | Check that a coercion is appropriate for filling a hole. (The hole
--   itself is needed only for printing.) Always returns the checked
--   coercion, but this return value is necessary so that the input
--   coercion is forced only when the output is forced.
checkCoercionHole :: CoVar -> Coercion -> TcM Coercion

-- | A coercion hole used to store evidence for `Concrete#` constraints.
--   
--   See Note [The Concrete mechanism].
type ConcreteHole = CoercionHole

-- | Create a new (initially unfilled) coercion hole, to hold evidence for
--   a <tt>'Concrete#' (ty :: ki)</tt> constraint.
newConcreteHole :: Kind -> Type -> TcM (ConcreteHole, TcType)

-- | Create a new <a>Implication</a> with as many sensible defaults for its
--   fields as possible. Note that the <a>ic_tclvl</a>, <a>ic_binds</a>,
--   and <a>ic_info</a> fields do <i>not</i> have sensible defaults, so
--   they are initialized with lazy thunks that will <a>panic</a> if
--   forced, so one should take care to initialize these fields after
--   creation.
--   
--   This is monadic to look up the <a>TcLclEnv</a>, which is used to
--   initialize <a>ic_env</a>, and to set the -Winaccessible-code flag. See
--   Note [Avoid -Winaccessible-code when deriving] in
--   <a>GHC.Tc.TyCl.Instance</a>.
newImplication :: TcM Implication
newMetaTyVars :: [TyVar] -> TcM (Subst, [TcTyVar])
newMetaTyVarX :: Subst -> TyVar -> TcM (Subst, TcTyVar)
newMetaTyVarsX :: Subst -> [TyVar] -> TcM (Subst, [TcTyVar])
newMetaTyVarTyVarX :: Subst -> TyVar -> TcM (Subst, TcTyVar)
newTyVarTyVar :: Name -> Kind -> TcM TcTyVar
cloneTyVarTyVar :: Name -> Kind -> TcM TcTyVar
newPatSigTyVar :: Name -> Kind -> TcM TcTyVar
newSkolemTyVar :: SkolemInfo -> Name -> Kind -> TcM TcTyVar
newWildCardX :: Subst -> TyVar -> TcM (Subst, TcTyVar)

-- | An expected type to check against during type-checking. See Note
--   [ExpType] in <a>GHC.Tc.Utils.TcMType</a>, where you'll also find
--   manipulators.
data ExpType
Check :: TcType -> ExpType
Infer :: !InferResult -> ExpType
type ExpSigmaType = ExpType
type ExpRhoType = ExpType

-- | Make an <a>ExpType</a> suitable for checking.
mkCheckExpType :: TcType -> ExpType
newInferExpType :: TcM ExpType
newInferExpTypeFRR :: FixedRuntimeRepContext -> TcM ExpTypeFRR

-- | Infer a type using a fresh ExpType See also Note [ExpType] in
--   <a>GHC.Tc.Utils.TcMType</a>
--   
--   Use <a>tcInferFRR</a> if you require the type to have a fixed runtime
--   representation.
tcInfer :: (ExpSigmaType -> TcM a) -> TcM (a, TcSigmaType)

-- | Like <a>tcInfer</a>, except it ensures that the resulting type has a
--   syntactically fixed RuntimeRep as per Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete.
tcInferFRR :: FixedRuntimeRepContext -> (ExpSigmaTypeFRR -> TcM a) -> TcM (a, TcSigmaTypeFRR)

-- | Extract a type out of an ExpType. Otherwise, panics.
readExpType :: ExpType -> TcM TcType

-- | Extract a type out of an ExpType, if one exists. But one should always
--   exist. Unless you're quite sure you know what you're doing.
readExpType_maybe :: ExpType -> TcM (Maybe TcType)

-- | Same as readExpType, but for Scaled ExpTypes
readScaledExpType :: Scaled ExpType -> TcM (Scaled Type)

-- | Extracts the expected type if there is one, or generates a new TauTv
--   if there isn't.
expTypeToType :: ExpType -> TcM TcType
scaledExpTypeToType :: Scaled ExpType -> TcM (Scaled TcType)

-- | Returns the expected type when in checking mode.
checkingExpType_maybe :: ExpType -> Maybe TcType

-- | Returns the expected type when in checking mode. Panics if in
--   inference mode.
checkingExpType :: String -> ExpType -> TcType
inferResultToType :: InferResult -> TcM Type
ensureMonoType :: TcType -> TcM ()
promoteTcType :: TcLevel -> TcType -> TcM (TcCoercionN, TcType)
zonkTidyTcType :: TidyEnv -> TcType -> TcM (TidyEnv, TcType)
zonkTidyTcTypes :: TidyEnv -> [TcType] -> TcM (TidyEnv, [TcType])
zonkTidyOrigin :: TidyEnv -> CtOrigin -> TcM (TidyEnv, CtOrigin)
zonkTidyOrigins :: TidyEnv -> [CtOrigin] -> TcM (TidyEnv, [CtOrigin])
zonkTidyFRRInfos :: TidyEnv -> [FixedRuntimeRepErrorInfo] -> TcM (TidyEnv, [FixedRuntimeRepErrorInfo])
tidyEvVar :: TidyEnv -> EvVar -> EvVar
tidyCt :: TidyEnv -> Ct -> Ct
tidyHole :: TidyEnv -> Hole -> Hole
tidyDelayedError :: TidyEnv -> DelayedError -> DelayedError
zonkTcTyVar :: TcTyVar -> TcM TcType
zonkTcTyVars :: [TcTyVar] -> TcM [TcType]
zonkTcTyVarToTcTyVar :: HasDebugCallStack => TcTyVar -> TcM TcTyVar
zonkTcTyVarsToTcTyVars :: HasDebugCallStack => [TcTyVar] -> TcM [TcTyVar]
zonkInvisTVBinder :: VarBndr TcTyVar spec -> TcM (VarBndr TcTyVar spec)
zonkTyCoVarsAndFV :: TyCoVarSet -> TcM TyCoVarSet
zonkTcTypeAndFV :: TcType -> TcM DTyCoVarSet
zonkDTyCoVarSetAndFV :: DTyCoVarSet -> TcM DTyCoVarSet
zonkTyCoVarsAndFVList :: [TyCoVar] -> TcM [TyCoVar]
zonkTcType :: TcType -> TcM TcType
zonkTcTypes :: [TcType] -> TcM [TcType]
zonkCo :: Coercion -> TcM Coercion
zonkTyCoVarKind :: TyCoVar -> TcM TyCoVar
zonkEvVar :: EvVar -> TcM EvVar
zonkWC :: WantedConstraints -> TcM WantedConstraints
zonkImplication :: Implication -> TcM Implication
zonkSimples :: Cts -> TcM Cts
zonkId :: TcId -> TcM TcId
zonkCoVar :: CoVar -> TcM CoVar
zonkCt :: Ct -> TcM Ct
zonkSkolemInfo :: SkolemInfo -> TcM SkolemInfo
zonkSkolemInfoAnon :: SkolemInfoAnon -> TcM SkolemInfoAnon

-- | Default a type variable using the given defaulting strategy.
--   
--   See Note [Type variable defaulting options] in GHC.Types.Basic.
defaultTyVar :: DefaultingStrategy -> TcTyVar -> TcM Bool
promoteMetaTyVarTo :: HasDebugCallStack => TcLevel -> TcTyVar -> TcM Bool
promoteTyVarSet :: HasDebugCallStack => TcTyVarSet -> TcM Bool
quantifyTyVars :: SkolemInfo -> NonStandardDefaultingStrategy -> CandidatesQTvs -> TcM [TcTyVar]
isQuantifiableTv :: TcLevel -> TcTyVar -> Bool
zonkAndSkolemise :: SkolemInfo -> TcTyCoVar -> TcM TcTyCoVar
skolemiseQuantifiedTyVar :: SkolemInfo -> TcTyVar -> TcM TcTyVar
doNotQuantifyTyVars :: CandidatesQTvs -> (TidyEnv -> TcM (TidyEnv, SDoc)) -> TcM ()

-- | Gathers free variables to use as quantification candidates (in
--   <a>quantifyTyVars</a>). This might output the same var in both sets,
--   if it's used in both a type and a kind. The variables to quantify must
--   have a TcLevel strictly greater than the ambient level. (See Wrinkle
--   in Note [Naughty quantification candidates]) See Note [CandidatesQTvs
--   determinism and order] See Note [Dependent type variables]
candidateQTyVarsOfType :: TcType -> TcM CandidatesQTvs

-- | Like <a>candidateQTyVarsOfType</a>, but consider every free variable
--   to be dependent. This is appropriate when generalizing a *kind*,
--   instead of a type. (That way, -XNoPolyKinds will default the variables
--   to Type.)
candidateQTyVarsOfKind :: TcKind -> TcM CandidatesQTvs

-- | Like <a>candidateQTyVarsOfType</a>, but over a list of types The
--   variables to quantify must have a TcLevel strictly greater than the
--   ambient level. (See Wrinkle in Note [Naughty quantification
--   candidates])
candidateQTyVarsOfTypes :: [Type] -> TcM CandidatesQTvs
candidateQTyVarsOfKinds :: [TcKind] -> TcM CandidatesQTvs
candidateQTyVarsWithBinders :: [TyVar] -> Type -> TcM CandidatesQTvs
data CandidatesQTvs
DV :: DTyVarSet -> DTyVarSet -> CoVarSet -> CandidatesQTvs
[dv_kvs] :: CandidatesQTvs -> DTyVarSet
[dv_tvs] :: CandidatesQTvs -> DTyVarSet
[dv_cvs] :: CandidatesQTvs -> CoVarSet
delCandidates :: CandidatesQTvs -> [Var] -> CandidatesQTvs
candidateKindVars :: CandidatesQTvs -> TyVarSet
partitionCandidates :: CandidatesQTvs -> (TyVar -> Bool) -> (TyVarSet, CandidatesQTvs)

-- | Check that the specified type has a fixed runtime representation.
--   
--   If it isn't, throw a representation-polymorphism error appropriate for
--   the context (as specified by the <a>FixedRuntimeRepProvenance</a>).
--   
--   Unlike the other representation polymorphism checks, which can emit
--   new Wanted constraints to be solved by the constraint solver, this
--   function does not emit any constraints: it has enough information to
--   immediately make a decision.
--   
--   See (1) in Note [Representation polymorphism checking] in
--   GHC.Tc.Utils.Concrete
checkTypeHasFixedRuntimeRep :: FixedRuntimeRepProvenance -> Type -> TcM ()

-- | Check whether any coercion hole in a RewriterSet is still unsolved.
--   Does this by recursively looking through filled coercion holes until
--   one is found that is not yet filled in, at which point this aborts.
anyUnfilledCoercionHoles :: RewriterSet -> TcM Bool
instance GHC.Base.Semigroup GHC.Tc.Utils.TcMType.UnfilledCoercionHoleMonoid
instance GHC.Base.Monoid GHC.Tc.Utils.TcMType.UnfilledCoercionHoleMonoid
instance GHC.Base.Semigroup GHC.Tc.Utils.TcMType.CandidatesQTvs
instance GHC.Base.Monoid GHC.Tc.Utils.TcMType.CandidatesQTvs
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.TcMType.CandidatesQTvs

module GHC.Rename.Unbound
mkUnboundName :: OccName -> Name
mkUnboundNameRdr :: RdrName -> Name
isUnboundName :: Name -> Bool
reportUnboundName :: RdrName -> RnM Name
reportUnboundName' :: WhatLooking -> RdrName -> RnM Name

-- | Called from the typechecker (<a>GHC.Tc.Errors</a>) when we find an
--   unbound variable
unknownNameSuggestions :: WhatLooking -> DynFlags -> HomePackageTable -> Module -> GlobalRdrEnv -> LocalRdrEnv -> ImportAvails -> RdrName -> ([ImportError], [GhcHint])
data WhatLooking
WL_Anything :: WhatLooking
WL_Constructor :: WhatLooking
WL_RecField :: WhatLooking
WL_None :: WhatLooking
data WhereLooking
WL_Anywhere :: WhereLooking
WL_Global :: WhereLooking
WL_LocalTop :: WhereLooking
WL_LocalOnly :: WhereLooking
data LookingFor
LF :: WhatLooking -> WhereLooking -> LookingFor
[lf_which] :: LookingFor -> WhatLooking
[lf_where] :: LookingFor -> WhereLooking
unboundName :: LookingFor -> RdrName -> RnM Name
unboundNameX :: LookingFor -> RdrName -> [GhcHint] -> RnM Name
notInScopeErr :: WhereLooking -> RdrName -> NotInScopeError
nameSpacesRelated :: DynFlags -> WhatLooking -> NameSpace -> NameSpace -> Bool
instance GHC.Classes.Eq GHC.Rename.Unbound.WhatLooking

module GHC.Iface.Env
newGlobalBinder :: Module -> OccName -> SrcSpan -> TcRnIf a b Name
newInteractiveBinder :: HscEnv -> OccName -> SrcSpan -> IO Name
externaliseName :: Module -> Name -> TcRnIf m n Name

-- | Look up a top-level name from the current Iface module
lookupIfaceTop :: OccName -> IfL Name

-- | Look up the <a>Name</a> for a given <a>GenModule</a> and
--   <a>OccName</a>. Consider alternatively using <a>lookupIfaceTop</a> if
--   you're in the <a>IfL</a> monad and <a>GenModule</a> is simply that of
--   the <a>ModIface</a> you are typechecking.
lookupOrig :: Module -> OccName -> TcRnIf a b Name
lookupNameCache :: NameCache -> Module -> OccName -> IO Name
lookupOrigNameCache :: OrigNameCache -> Module -> OccName -> Maybe Name
newIfaceName :: OccName -> IfL Name
newIfaceNames :: [OccName] -> IfL [Name]
extendIfaceIdEnv :: [Id] -> IfL a -> IfL a
extendIfaceTyVarEnv :: [TyVar] -> IfL a -> IfL a
tcIfaceLclId :: FastString -> IfL Id
tcIfaceTyVar :: FastString -> IfL TyVar
lookupIfaceVar :: IfaceBndr -> IfL (Maybe TyCoVar)
lookupIfaceTyVar :: IfaceTvBndr -> IfL (Maybe TyVar)
extendIfaceEnvs :: [TyCoVar] -> IfL a -> IfL a

-- | Set the <a>GenModule</a> of a <a>Name</a>.
setNameModule :: Maybe Module -> Name -> TcRnIf m n Name
ifaceExportNames :: [IfaceExport] -> TcRnIf gbl lcl [AvailInfo]
trace_if :: Logger -> SDoc -> IO ()
trace_hi_diffs :: Logger -> SDoc -> IO ()
allocateGlobalBinder :: NameCache -> Module -> OccName -> SrcSpan -> IO Name

module GHC.Types.Name.Shape

-- | A <a>NameShape</a> is a substitution on <a>Name</a>s that can be used
--   to refine the identities of a hole while we are renaming interfaces
--   (see <a>GHC.Iface.Rename</a>). Specifically, a <a>NameShape</a> for
--   <tt>ns_module_name</tt> <tt>A</tt>, defines a mapping from
--   <tt>{A.T}</tt> (for some <a>OccName</a> <tt>T</tt>) to some arbitrary
--   other <a>Name</a>.
--   
--   The most intriguing thing about a <a>NameShape</a>, however, is how
--   it's constructed. A <a>NameShape</a> is *implied* by the exported
--   <a>AvailInfo</a>s of the implementor of an interface: if an
--   implementor of signature <tt>&lt;H&gt;</tt> exports <tt>M.T</tt>, you
--   implicitly define a substitution from <tt>{H.T}</tt> to <tt>M.T</tt>.
--   So a <a>NameShape</a> is computed from the list of <a>AvailInfo</a>s
--   that are exported by the implementation of a module, or successively
--   merged together by the export lists of signatures which are joining
--   together.
--   
--   It's not the most obvious way to go about doing this, but it does seem
--   to work!
--   
--   NB: Can't boot this and put it in NameShape because then we start
--   pulling in too many DynFlags things.
data NameShape
NameShape :: ModuleName -> [AvailInfo] -> OccEnv Name -> NameShape
[ns_mod_name] :: NameShape -> ModuleName
[ns_exports] :: NameShape -> [AvailInfo]
[ns_map] :: NameShape -> OccEnv Name

-- | Create an empty <a>NameShape</a> (i.e., the renaming that would occur
--   with an implementing module with no exports) for a specific hole
--   <tt>mod_name</tt>.
emptyNameShape :: ModuleName -> NameShape

-- | Create a <a>NameShape</a> corresponding to an implementing module for
--   the hole <tt>mod_name</tt> that exports a list of <a>AvailInfo</a>s.
mkNameShape :: ModuleName -> [AvailInfo] -> NameShape

-- | Given an existing <a>NameShape</a>, merge it with a list of
--   <a>AvailInfo</a>s with Backpack style mix-in linking. This is used
--   solely when merging signatures together: we successively merge the
--   exports of each signature until we have the final, full exports of the
--   merged signature.
--   
--   What makes this operation nontrivial is what we are supposed to do
--   when we want to merge in an export for M.T when we already have an
--   existing export {H.T}. What should happen in this case is that {H.T}
--   should be unified with <tt>M.T</tt>: we've determined a more *precise*
--   identity for the export at <a>OccName</a> <tt>T</tt>.
--   
--   Note that we don't do unrestricted unification: only name holes from
--   <tt>ns_mod_name ns</tt> are flexible. This is because we have a much
--   more restricted notion of shaping than in Backpack'14: we do shaping
--   *as* we do type-checking. Thus, once we shape a signature, its exports
--   are *final* and we're not allowed to refine them further,
extendNameShape :: HscEnv -> NameShape -> [AvailInfo] -> IO (Either SDoc NameShape)

-- | The export list associated with this <a>NameShape</a> (i.e., what the
--   exports of an implementing module which induces this <a>NameShape</a>
--   would be.)
nameShapeExports :: NameShape -> [AvailInfo]

-- | Given a <a>Name</a>, substitute it according to the <a>NameShape</a>
--   implied substitution, i.e. map <tt>{A.T}</tt> to <tt>M.T</tt>, if the
--   implementing module exports <tt>M.T</tt>.
substNameShape :: NameShape -> Name -> Name

-- | Like <a>substNameShape</a>, but returns <tt>Nothing</tt> if no
--   substitution works.
maybeSubstNameShape :: NameShape -> Name -> Maybe Name

module GHC.Tc.TyCl.Build
buildDataCon :: FamInstEnvs -> DataConBangOpts -> Name -> Bool -> TyConRepName -> [HsSrcBang] -> [FieldLabel] -> [TyVar] -> [TyCoVar] -> [InvisTVBinder] -> [EqSpec] -> KnotTied ThetaType -> [KnotTied (Scaled Type)] -> KnotTied Type -> KnotTied TyCon -> NameEnv ConTag -> TcRnIf m n DataCon
buildPatSyn :: Name -> Bool -> PatSynMatcher -> PatSynBuilder -> ([InvisTVBinder], ThetaType) -> ([InvisTVBinder], ThetaType) -> [FRRType] -> Type -> [FieldLabel] -> PatSyn
type TcMethInfo = MethInfo
type MethInfo = (Name, Type, Maybe (DefMethSpec (SrcSpan, Type)))
buildClass :: Name -> [TyConBinder] -> [Role] -> [FunDep TyVar] -> Maybe (KnotTied ThetaType, [ClassATItem], [KnotTied MethInfo], ClassMinimalDef) -> TcRnIf m n Class

-- | Monadic because it makes a Name for the coercion TyCon We pass the
--   Name of the parent TyCon, as well as the TyCon itself, because the
--   latter is part of a knot, whereas the former is not.
mkNewTyConRhs :: Name -> TyCon -> DataCon -> TcRnIf m n AlgTyConRhs
newImplicitBinder :: Name -> (OccName -> OccName) -> TcRnIf m n Name

-- | Make the <a>TyConRepName</a> for this <a>TyCon</a>
newTyConRepName :: Name -> TcRnIf gbl lcl TyConRepName


-- | This module implements interface renaming, which is used to rewrite
--   interface files on the fly when we are doing indefinite typechecking
--   and need instantiations of modules which do not necessarily exist yet.
module GHC.Iface.Rename

-- | What we have is a generalized ModIface, which corresponds to a module
--   that looks like p[A=&lt;A&gt;]:B. We need a *specific* ModIface, e.g.
--   p[A=q():A]:B (or maybe even p[A=&lt;B&gt;]:B) which we load up (either
--   to merge it, or to just use during typechecking).
--   
--   Suppose we have:
--   
--   p[A=&lt;A&gt;]:M ==&gt; p[A=q():A]:M
--   
--   Substitute all occurrences of &lt;A&gt; with q():A (renameHoleModule).
--   Then, for any Name of form {A.T}, replace the Name with the Name
--   according to the exports of the implementing module. This works even
--   for p[A=&lt;B&gt;]:M, since we just read in the exports of B.hi, which
--   is assumed to be ready now.
--   
--   This function takes an optional <a>NameShape</a>, which can be used to
--   further refine the identities in this interface: suppose we read a
--   declaration for {H.T} but we actually know that this should be Foo.T;
--   then we'll also rename this (this is used when loading an interface to
--   merge it into a requirement.)
rnModIface :: HscEnv -> [(ModuleName, Module)] -> Maybe NameShape -> ModIface -> IO (Either (Messages TcRnMessage) ModIface)

-- | Rename just the exports of a <a>ModIface</a>. Useful when we're doing
--   shaping prior to signature merging.
rnModExports :: HscEnv -> [(ModuleName, Module)] -> ModIface -> IO (Either (Messages TcRnMessage) [AvailInfo])
tcRnModIface :: [(ModuleName, Module)] -> Maybe NameShape -> ModIface -> TcM ModIface
tcRnModExports :: [(ModuleName, Module)] -> ModIface -> TcM [AvailInfo]


-- | Checking for representation-polymorphism using the Concrete mechanism.
--   
--   This module contains the logic for enforcing the
--   representation-polymorphism invariants by way of emitting constraints.
module GHC.Tc.Utils.Concrete

-- | Given a type <tt>ty :: ki</tt>, this function ensures that <tt>ty</tt>
--   has a <b>fixed</b> <tt>RuntimeRep</tt>, by emitting a new equality
--   constraint <tt>ki ~ concrete_tv</tt> for a concrete metavariable
--   <tt>concrete_tv</tt>.
--   
--   Returns a coercion <tt>co :: ty ~# concrete_ty</tt> as evidence. If
--   <tt>ty</tt> obviously has a fixed <tt>RuntimeRep</tt>, e.g <tt>ki =
--   IntRep</tt>, then this function immediately returns <a>MRefl</a>,
--   without emitting any constraints.
hasFixedRuntimeRep :: HasDebugCallStack => FixedRuntimeRepContext -> TcType -> TcM (TcCoercionN, TcTypeFRR)

-- | Like <a>hasFixedRuntimeRep</a>, but we perform an eager syntactic
--   check.
--   
--   Throws an error in the <a>TcM</a> monad if the check fails.
--   
--   This is useful if we are not actually going to use the coercion
--   returned from <a>hasFixedRuntimeRep</a>; it would generally be unsound
--   to allow a non-reflexive coercion but not actually make use of it in a
--   cast.
--   
--   The goal is to eliminate all uses of this function and replace them
--   with <a>hasFixedRuntimeRep</a>, making use of the returned coercion.
--   This is what is meant by going from PHASE 1 to PHASE 2, in Note [The
--   Concrete mechanism].
hasFixedRuntimeRep_syntactic :: HasDebugCallStack => FixedRuntimeRepContext -> TcType -> TcM ()

-- | Try to turn the provided type into a concrete type, by ensuring
--   unfilled metavariables are appropriately marked as concrete.
--   
--   Returns a zonked type which is "as concrete as possible", and a list
--   of problems encountered when trying to make it concrete.
--   
--   INVARIANT: the returned type is equal to the input type, up to
--   zonking. INVARIANT: if this function returns an empty list of
--   <tt>NotConcreteReasons</tt>, then the returned type is concrete, in
--   the sense of Note [Concrete types].
makeTypeConcrete :: ConcreteTvOrigin -> TcType -> TcM (TcType, [NotConcreteReason])


-- | Typechecking annotations
module GHC.Tc.Gen.Annotation
tcAnnotations :: [LAnnDecl GhcRn] -> TcM [Annotation]
annCtxt :: OutputableBndrId p => AnnDecl (GhcPass p) -> SDoc

module GHC.Tc.Errors.Hole.FitTypes
data TypedHole
TypedHole :: Bag CtEvidence -> [Implication] -> Maybe Hole -> TypedHole

-- | Any relevant Cts to the hole
[th_relevant_cts] :: TypedHole -> Bag CtEvidence

-- | The nested implications of the hole with the innermost implication
--   first.
[th_implics] :: TypedHole -> [Implication]

-- | The hole itself, if available.
[th_hole] :: TypedHole -> Maybe Hole

-- | HoleFit is the type we use for valid hole fits. It contains the
--   element that was checked, the Id of that element as found by
--   <tt>tcLookup</tt>, and the refinement level of the fit, which is the
--   number of extra argument holes that this fit uses (e.g. if hfRefLvl is
--   2, the fit is for `Id _ _`).
data HoleFit
HoleFit :: Id -> HoleFitCandidate -> TcType -> Int -> [TcType] -> [TcType] -> Maybe [HsDocString] -> HoleFit

-- | The elements id in the TcM
[hfId] :: HoleFit -> Id

-- | The candidate that was checked.
[hfCand] :: HoleFit -> HoleFitCandidate

-- | The type of the id, possibly zonked.
[hfType] :: HoleFit -> TcType

-- | The number of holes in this fit.
[hfRefLvl] :: HoleFit -> Int

-- | The wrapper for the match.
[hfWrap] :: HoleFit -> [TcType]

-- | What the refinement variables got matched with, if anything
[hfMatches] :: HoleFit -> [TcType]

-- | Documentation of this HoleFit, if available.
[hfDoc] :: HoleFit -> Maybe [HsDocString]

-- | A fit that is just displayed as is. Here so thatHoleFitPlugins can
--   inject any fit they want.
RawHoleFit :: SDoc -> HoleFit

-- | HoleFitCandidates are passed to hole fit plugins and then checked
--   whether they fit a given typed-hole.
data HoleFitCandidate
IdHFCand :: Id -> HoleFitCandidate
NameHFCand :: Name -> HoleFitCandidate
GreHFCand :: GlobalRdrElt -> HoleFitCandidate

-- | A plugin for modifying the candidate hole fits *before* they're
--   checked.
type CandPlugin = TypedHole -> [HoleFitCandidate] -> TcM [HoleFitCandidate]

-- | A plugin for modifying hole fits *after* they've been found.
type FitPlugin = TypedHole -> [HoleFit] -> TcM [HoleFit]

-- | A HoleFitPlugin is a pair of candidate and fit plugins.
data HoleFitPlugin
HoleFitPlugin :: CandPlugin -> FitPlugin -> HoleFitPlugin
[candPlugin] :: HoleFitPlugin -> CandPlugin
[fitPlugin] :: HoleFitPlugin -> FitPlugin

-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can
--   track internal state. Note the existential quantification, ensuring
--   that the state cannot be modified from outside the plugin.
data HoleFitPluginR
HoleFitPluginR :: TcM (TcRef s) -> (TcRef s -> HoleFitPlugin) -> (TcRef s -> TcM ()) -> HoleFitPluginR

-- | Initializes the TcRef to be passed to the plugin
[hfPluginInit] :: HoleFitPluginR -> TcM (TcRef s)

-- | The function defining the plugin itself
[hfPluginRun] :: HoleFitPluginR -> TcRef s -> HoleFitPlugin

-- | Cleanup of state, guaranteed to be called even on error
[hfPluginStop] :: HoleFitPluginR -> TcRef s -> TcM ()
hfIsLcl :: HoleFit -> Bool
pprHoleFitCand :: HoleFitCandidate -> SDoc
instance GHC.Classes.Eq GHC.Tc.Errors.Hole.FitTypes.HoleFit
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Hole.FitTypes.HoleFit
instance GHC.Classes.Ord GHC.Tc.Errors.Hole.FitTypes.HoleFit
instance GHC.Classes.Eq GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Types.Name.NamedThing GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Types.Name.Occurrence.HasOccName GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Classes.Ord GHC.Tc.Errors.Hole.FitTypes.HoleFitCandidate
instance GHC.Utils.Outputable.Outputable GHC.Tc.Errors.Hole.FitTypes.TypedHole


-- | Extract docs from the renamer output so they can be serialized.
module GHC.HsToCore.Docs

-- | Extract docs from renamer output. This is monadic since we need to be
--   able to read documentation added from Template Haskell's
--   <tt>putDoc</tt>, which is stored in <a>tcg_th_docs</a>.
extractDocs :: MonadIO m => DynFlags -> TcGblEnv -> m (Maybe Docs)

-- | If we have an explicit export list, we extract the documentation
--   structure from that. Otherwise we use the renamed exports and
--   declarations.
mkDocStructure :: Module -> ImportAvails -> Maybe [(LIE GhcRn, Avails)] -> HsGroup GhcRn -> [AvailInfo] -> OccEnv Name -> DocStructure
mkDocStructureFromExportList :: Module -> ImportAvails -> [(LIE GhcRn, Avails)] -> DocStructure

-- | Figure out the documentation structure by correlating the module
--   exports with the located declarations.
mkDocStructureFromDecls :: OccEnv Name -> [AvailInfo] -> HsGroup GhcRn -> DocStructure

-- | Extract named documentation chunks from the renamed declarations.
--   
--   If there is no explicit export list, we simply return an empty map
--   since there would be no way to link to a named chunk.
getNamedChunks :: Bool -> HsGroup (GhcPass pass) -> Map String (HsDoc (GhcPass pass))

-- | Create decl and arg doc-maps by looping through the declarations. For
--   each declaration, find its names, its subordinates, and its doc
--   strings.
mkMaps :: OccEnv Name -> [Name] -> [(LHsDecl GhcRn, [HsDoc GhcRn])] -> (UniqMap Name [HsDoc GhcRn], UniqMap Name (IntMap (HsDoc GhcRn)))
getMainDeclBinder :: OccEnv Name -> HsDecl GhcRn -> [Name]

-- | The "OccEnv Name" is the default method environment for this module
--   Ultimately, the a special "defaultMethodOcc" name is used for the
--   signatures on bindings for default methods. Unfortunately, this name
--   isn't generated until typechecking, so it is not in the renamed AST.
--   We have to look it up from the <a>OccEnv</a> parameter constructed
--   from the typechecked AST. See also Note [default method Name] in
--   GHC.Iface.Recomp
sigNameNoLoc :: forall a. (UnXRec a, HasOccName (IdP a)) => OccEnv (IdP a) -> Sig a -> [IdP a]
getInstLoc :: Anno (IdGhcP p) ~ SrcSpanAnnN => InstDecl (GhcPass p) -> SrcSpan

-- | Get all subordinate declarations inside a declaration, and their docs.
--   A subordinate declaration is something like the associate type or data
--   family of a type class.
subordinates :: OccEnv Name -> Map RealSrcSpan Name -> HsDecl GhcRn -> [(Name, [HsDoc GhcRn], IntMap (HsDoc GhcRn))]

-- | Extract constructor argument docs from inside constructor decls.
conArgDocs :: ConDecl GhcRn -> IntMap (HsDoc GhcRn)
h98ConArgDocs :: HsConDeclH98Details GhcRn -> IntMap (HsDoc GhcRn)
gadtConArgDocs :: HsConDeclGADTDetails GhcRn -> HsType GhcRn -> IntMap (HsDoc GhcRn)
con_arg_docs :: Int -> [HsType GhcRn] -> IntMap (HsDoc GhcRn)
isValD :: HsDecl a -> Bool

-- | All the sub declarations of a class (that we handle), ordered by
--   source location, with documentation attached if it exists.
classDecls :: TyClDecl GhcRn -> [(LHsDecl GhcRn, [HsDoc GhcRn])]

-- | Extract function argument docs from inside top-level decls.
declTypeDocs :: HsDecl GhcRn -> IntMap (HsDoc GhcRn)
nubByName :: (a -> Name) -> [a] -> [a]

-- | Extract function argument docs from inside types.
typeDocs :: HsType GhcRn -> IntMap (HsDoc GhcRn)

-- | Extract function argument docs from inside types.
sigTypeDocs :: HsSigType GhcRn -> IntMap (HsDoc GhcRn)

-- | The top-level declarations of a module that we care about, ordered by
--   source location, with documentation attached if it exists.
topDecls :: HsGroup GhcRn -> [(LHsDecl GhcRn, [HsDoc GhcRn])]

-- | Take all declarations except pragmas, infix decls, rules from an
--   <a>HsGroup</a>.
ungroup :: HsGroup GhcRn -> [LHsDecl GhcRn]

-- | Collect docs and attach them to the right declarations.
--   
--   A declaration may have multiple doc strings attached to it.
--   
--   This is an example.
collectDocs :: forall p. UnXRec p => [LHsDecl p] -> [(LHsDecl p, [HsDoc p])]

-- | Filter out declarations that we don't handle in Haddock
filterDecls :: forall p doc. UnXRec p => [(LHsDecl p, doc)] -> [(LHsDecl p, doc)]

-- | Go through all class declarations and filter their sub-declarations
filterClasses :: forall p doc. IsPass p => [(LHsDecl (GhcPass p), doc)] -> [(LHsDecl (GhcPass p), doc)]

-- | Was this signature given by the user?
isUserSig :: Sig name -> Bool

-- | Take a field of declarations from a data structure and create HsDecls
--   using the given constructor
mkDecls :: (struct -> [GenLocated l decl]) -> (decl -> hsDecl) -> struct -> [GenLocated l hsDecl]

-- | Extracts out individual maps of documentation added via Template
--   Haskell's <tt>putDoc</tt>.
extractTHDocs :: THDocs -> ExtractedTHDocs

-- | Unions together two <tt>ArgDocMaps</tt> (or ArgMaps in haddock-api),
--   such that two maps with values for the same key merge the inner map as
--   well. Left biased so <tt>unionArgMaps a b</tt> prefers <tt>a</tt> over
--   <tt>b</tt>.
unionArgMaps :: forall b. UniqMap Name (IntMap b) -> UniqMap Name (IntMap b) -> UniqMap Name (IntMap b)


-- | Definitions for writing <i>plugins</i> for GHC. Plugins can hook into
--   several areas of the compiler. See the <a>Plugin</a> type. These
--   plugins include type-checker plugins, source plugins, and core-to-core
--   plugins.
module GHC.Driver.Plugins
data Plugins
Plugins :: ![StaticPlugin] -> ![ExternalPlugin] -> ![LoadedPlugin] -> !([Linkable], PkgsLoaded) -> Plugins

-- | Static plugins which do not need dynamic loading. These plugins are
--   intended to be added by GHC API users directly to this list.
--   
--   To add dynamically loaded plugins through the GHC API see
--   <tt>addPluginModuleName</tt> instead.
[staticPlugins] :: Plugins -> ![StaticPlugin]

-- | External plugins loaded directly from libraries without loading module
--   interfaces.
[externalPlugins] :: Plugins -> ![ExternalPlugin]

-- | Plugins dynamically loaded after processing arguments. What will be
--   loaded here is directed by DynFlags.pluginModNames. Arguments are
--   loaded from DynFlags.pluginModNameOpts.
--   
--   The purpose of this field is to cache the plugins so they don't have
--   to be loaded each time they are needed. See <a>initializePlugins</a>.
[loadedPlugins] :: Plugins -> ![LoadedPlugin]

-- | The object files required by the loaded plugins See Note [Plugin
--   dependencies]
[loadedPluginDeps] :: Plugins -> !([Linkable], PkgsLoaded)
emptyPlugins :: Plugins

-- | <a>Plugin</a> is the compiler plugin data type. Try to avoid
--   constructing one of these directly, and just modify some fields of
--   <a>defaultPlugin</a> instead: this is to try and preserve source-code
--   compatibility when we add fields to this.
--   
--   Nonetheless, this API is preliminary and highly likely to change in
--   the future.
data Plugin
Plugin :: CorePlugin -> TcPlugin -> DefaultingPlugin -> HoleFitPlugin -> ([CommandLineOption] -> HscEnv -> IO HscEnv) -> ([CommandLineOption] -> IO PluginRecompile) -> ([CommandLineOption] -> ModSummary -> ParsedResult -> Hsc ParsedResult) -> ([CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)) -> ([CommandLineOption] -> ModSummary -> TcGblEnv -> TcM TcGblEnv) -> ([CommandLineOption] -> LHsExpr GhcTc -> TcM (LHsExpr GhcTc)) -> (forall lcl. [CommandLineOption] -> ModIface -> IfM lcl ModIface) -> Plugin

-- | Modify the Core pipeline that will be used for compilation. This is
--   called as the Core pipeline is built for every module being compiled,
--   and plugins get the opportunity to modify the pipeline in a
--   nondeterministic order.
[installCoreToDos] :: Plugin -> CorePlugin

-- | An optional typechecker plugin, which may modify the behaviour of the
--   constraint solver.
[tcPlugin] :: Plugin -> TcPlugin

-- | An optional defaulting plugin, which may specify the additional
--   type-defaulting rules.
[defaultingPlugin] :: Plugin -> DefaultingPlugin

-- | An optional plugin to handle hole fits, which may re-order or change
--   the list of valid hole fits and refinement hole fits.
[holeFitPlugin] :: Plugin -> HoleFitPlugin

-- | An optional plugin to update <a>HscEnv</a>, right after plugin
--   loading. This can be used to register hooks or tweak any field of
--   <tt>DynFlags</tt> before doing actual work on a module.
[driverPlugin] :: Plugin -> [CommandLineOption] -> HscEnv -> IO HscEnv

-- | Specify how the plugin should affect recompilation.
[pluginRecompile] :: Plugin -> [CommandLineOption] -> IO PluginRecompile

-- | Modify the module when it is parsed. This is called by
--   <a>GHC.Driver.Main</a> when the parser has produced no or only
--   non-fatal errors. Compilation will fail if the messages produced by
--   this function contain any errors.
[parsedResultAction] :: Plugin -> [CommandLineOption] -> ModSummary -> ParsedResult -> Hsc ParsedResult

-- | Modify each group after it is renamed. This is called after each
--   <a>HsGroup</a> has been renamed.
[renamedResultAction] :: Plugin -> [CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)

-- | Modify the module when it is type checked. This is called at the very
--   end of typechecking.
[typeCheckResultAction] :: Plugin -> [CommandLineOption] -> ModSummary -> TcGblEnv -> TcM TcGblEnv

-- | Modify the TH splice or quasiqoute before it is run.
[spliceRunAction] :: Plugin -> [CommandLineOption] -> LHsExpr GhcTc -> TcM (LHsExpr GhcTc)

-- | Modify an interface that have been loaded. This is called by
--   <a>GHC.Iface.Load</a> when an interface is successfully loaded. Not
--   applied to the loading of the plugin interface. Tools that rely on
--   information from modules other than the currently compiled one should
--   implement this function.
[interfaceLoadAction] :: Plugin -> forall lcl. [CommandLineOption] -> ModIface -> IfM lcl ModIface

-- | Default plugin: does nothing at all, except for marking that safe
--   inference has failed unless <tt>-fplugin-trustworthy</tt> is passed.
--   For compatibility reason you should base all your plugin definitions
--   on this default value.
defaultPlugin :: Plugin

-- | Command line options gathered from the -PModule.Name:stuff syntax are
--   given to you as this type
type CommandLineOption = String

-- | Errors and warnings produced by the parser
data PsMessages
PsMessages :: Messages PsWarning -> Messages PsError -> PsMessages
[psWarnings] :: PsMessages -> Messages PsWarning
[psErrors] :: PsMessages -> Messages PsError

-- | Result of running the parser and the parser plugin
data ParsedResult
ParsedResult :: HsParsedModule -> PsMessages -> ParsedResult

-- | Parsed module, potentially modified by a plugin
[parsedResultModule] :: ParsedResult -> HsParsedModule

-- | Warnings and errors from parser, potentially modified by a plugin
[parsedResultMessages] :: ParsedResult -> PsMessages

-- | Load external plugins
loadExternalPlugins :: [ExternalPluginSpec] -> IO [ExternalPlugin]
purePlugin :: [CommandLineOption] -> IO PluginRecompile
impurePlugin :: [CommandLineOption] -> IO PluginRecompile
flagRecompile :: [CommandLineOption] -> IO PluginRecompile
data PluginRecompile
ForceRecompile :: PluginRecompile
NoForceRecompile :: PluginRecompile
MaybeRecompile :: Fingerprint -> PluginRecompile
data FrontendPlugin
FrontendPlugin :: FrontendPluginAction -> FrontendPlugin
[frontend] :: FrontendPlugin -> FrontendPluginAction
defaultFrontendPlugin :: FrontendPlugin
type FrontendPluginAction = [String] -> [(String, Maybe Phase)] -> Ghc ()
type CorePlugin = [CommandLineOption] -> [CoreToDo] -> CoreM [CoreToDo]
type TcPlugin = [CommandLineOption] -> Maybe TcPlugin

-- | A renamer plugin which mades the renamed source available in a
--   typechecker plugin.
keepRenamedSource :: [CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)
type DefaultingPlugin = [CommandLineOption] -> Maybe DefaultingPlugin

-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can
--   track internal state. Note the existential quantification, ensuring
--   that the state cannot be modified from outside the plugin.
data HoleFitPluginR
data PluginWithArgs
PluginWithArgs :: Plugin -> [CommandLineOption] -> PluginWithArgs

-- | the actual callable plugin
[paPlugin] :: PluginWithArgs -> Plugin

-- | command line arguments for the plugin
[paArguments] :: PluginWithArgs -> [CommandLineOption]
pluginsWithArgs :: Plugins -> [PluginWithArgs]
pluginRecompile' :: PluginWithArgs -> IO PluginRecompile

-- | A plugin with its arguments. The result of loading the plugin.
data LoadedPlugin
LoadedPlugin :: PluginWithArgs -> ModIface -> LoadedPlugin

-- | the actual plugin together with its commandline arguments
[lpPlugin] :: LoadedPlugin -> PluginWithArgs

-- | the module containing the plugin
[lpModule] :: LoadedPlugin -> ModIface
lpModuleName :: LoadedPlugin -> ModuleName

-- | A static plugin with its arguments. For registering compiled-in
--   plugins through the GHC API.
data StaticPlugin
StaticPlugin :: PluginWithArgs -> StaticPlugin

-- | the actual plugin together with its commandline arguments
[spPlugin] :: StaticPlugin -> PluginWithArgs

-- | External plugin loaded directly from a library without loading module
--   interfaces
data ExternalPlugin
ExternalPlugin :: PluginWithArgs -> String -> String -> ExternalPlugin

-- | Plugin with its arguments
[epPlugin] :: ExternalPlugin -> PluginWithArgs

-- | UnitId
[epUnit] :: ExternalPlugin -> String

-- | Module name
[epModule] :: ExternalPlugin -> String
mapPlugins :: Plugins -> (Plugin -> [CommandLineOption] -> a) -> [a]

-- | Perform an operation by using all of the plugins in turn.
withPlugins :: Monad m => Plugins -> PluginOperation m a -> a -> m a

-- | Perform a constant operation by using all of the plugins in turn.
withPlugins_ :: Monad m => Plugins -> ConstPluginOperation m a -> a -> m ()
instance GHC.Utils.Outputable.Outputable GHC.Driver.Plugins.PluginRecompile
instance GHC.Base.Semigroup GHC.Driver.Plugins.PluginRecompile
instance GHC.Base.Monoid GHC.Driver.Plugins.PluginRecompile

module GHC.Driver.Pipeline.Phases
data TPhase res
[T_Unlit] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_FileArgs] :: HscEnv -> FilePath -> TPhase (DynFlags, Messages PsMessage, [Warn])
[T_Cpp] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_HsPp] :: PipeEnv -> HscEnv -> FilePath -> FilePath -> TPhase FilePath
[T_HscRecomp] :: PipeEnv -> HscEnv -> FilePath -> HscSource -> TPhase (HscEnv, ModSummary, HscRecompStatus)
[T_Hsc] :: HscEnv -> ModSummary -> TPhase (FrontendResult, Messages GhcMessage)
[T_HscPostTc] :: HscEnv -> ModSummary -> FrontendResult -> Messages GhcMessage -> Maybe Fingerprint -> TPhase HscBackendAction
[T_HscBackend] :: PipeEnv -> HscEnv -> ModuleName -> HscSource -> ModLocation -> HscBackendAction -> TPhase ([FilePath], ModIface, HomeModLinkable, FilePath)
[T_CmmCpp] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_Cmm] :: PipeEnv -> HscEnv -> FilePath -> TPhase ([FilePath], FilePath)
[T_Cc] :: Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase FilePath
[T_As] :: Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase FilePath
[T_Js] :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase FilePath
[T_ForeignJs] :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase FilePath
[T_LlvmOpt] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_LlvmLlc] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_LlvmMangle] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_MergeForeign] :: PipeEnv -> HscEnv -> FilePath -> [FilePath] -> TPhase FilePath

-- | A wrapper around the interpretation function for phases.
data PhaseHook
PhaseHook :: (forall a. TPhase a -> IO a) -> PhaseHook

module GHC.Driver.Hooks
data Hooks
class HasHooks m
getHooks :: HasHooks m => m Hooks
class ContainsHooks a
extractHooks :: ContainsHooks a => a -> Hooks

-- | Hooks can be used by GHC API clients to replace parts of the compiler
--   pipeline. If a hook is not installed, GHC uses the default built-in
--   behaviour
emptyHooks :: Hooks
type family DsForeignsHook :: Type

-- | Actual type: <tt>Maybe ([LForeignDecl GhcTc] -&gt; DsM (ForeignStubs,
--   OrdList (Id, CoreExpr)))</tt>
dsForeignsHook :: Hooks -> Maybe DsForeignsHook
tcForeignImportsHook :: Hooks -> Maybe ([LForeignDecl GhcRn] -> TcM ([Id], [LForeignDecl GhcTc], Bag GlobalRdrElt))
tcForeignExportsHook :: Hooks -> Maybe ([LForeignDecl GhcRn] -> TcM (LHsBinds GhcTc, [LForeignDecl GhcTc], Bag GlobalRdrElt))
hscFrontendHook :: Hooks -> Maybe (ModSummary -> Hsc FrontendResult)
hscCompileCoreExprHook :: Hooks -> Maybe (HscEnv -> SrcSpan -> CoreExpr -> IO (ForeignHValue, [Linkable], PkgsLoaded))
ghcPrimIfaceHook :: Hooks -> Maybe ModIface
runPhaseHook :: Hooks -> Maybe PhaseHook
runMetaHook :: Hooks -> Maybe (MetaHook TcM)
linkHook :: Hooks -> Maybe (GhcLink -> DynFlags -> Bool -> HomePackageTable -> IO SuccessFlag)
runRnSpliceHook :: Hooks -> Maybe (HsUntypedSplice GhcRn -> RnM (HsUntypedSplice GhcRn))
getValueSafelyHook :: Hooks -> Maybe (HscEnv -> Name -> Type -> IO (Either Type (HValue, [Linkable], PkgsLoaded)))
createIservProcessHook :: Hooks -> Maybe (CreateProcess -> IO ProcessHandle)
stgToCmmHook :: Hooks -> Maybe (StgToCmmConfig -> InfoTableProvMap -> [TyCon] -> CollectedCCs -> [CgStgTopBinding] -> HpcInfo -> Stream IO CmmGroup ModuleLFInfos)
cmmToRawCmmHook :: Hooks -> forall a. Maybe (DynFlags -> Maybe Module -> Stream IO CmmGroupSRTs a -> IO (Stream IO RawCmmGroup a))


-- | Various types used during desugaring.
module GHC.HsToCore.Types

-- | Desugaring monad. See also <tt>TcM</tt>.
type DsM = TcRnIf DsGblEnv DsLclEnv

-- | Local state of the desugarer, extended as we lexically descend
data DsLclEnv
DsLclEnv :: DsMetaEnv -> RealSrcSpan -> Nablas -> DsLclEnv

-- | Template Haskell bindings
[dsl_meta] :: DsLclEnv -> DsMetaEnv

-- | To put in pattern-matching error msgs
[dsl_loc] :: DsLclEnv -> RealSrcSpan

-- | See Note [Long-distance information] in <a>GHC.HsToCore.Pmc</a>. The
--   set of reaching values Nablas is augmented as we walk inwards, refined
--   through each pattern match in turn
[dsl_nablas] :: DsLclEnv -> Nablas

-- | Global read-only context and state of the desugarer. The statefulness
--   is implemented through <a>IORef</a>s.
data DsGblEnv
DsGblEnv :: Module -> FamInstEnv -> GlobalRdrEnv -> NamePprCtx -> IORef (Messages DsMessage) -> (IfGblEnv, IfLclEnv) -> CompleteMatches -> IORef CostCentreState -> IORef (ModuleEnv Int) -> DsGblEnv
[ds_mod] :: DsGblEnv -> Module
[ds_fam_inst_env] :: DsGblEnv -> FamInstEnv
[ds_gbl_rdr_env] :: DsGblEnv -> GlobalRdrEnv
[ds_name_ppr_ctx] :: DsGblEnv -> NamePprCtx
[ds_msgs] :: DsGblEnv -> IORef (Messages DsMessage)
[ds_if_env] :: DsGblEnv -> (IfGblEnv, IfLclEnv)
[ds_complete_matches] :: DsGblEnv -> CompleteMatches
[ds_cc_st] :: DsGblEnv -> IORef CostCentreState

-- | See Note [Generating fresh names for FFI wrappers]
[ds_next_wrapper_num] :: DsGblEnv -> IORef (ModuleEnv Int)
type DsMetaEnv = NameEnv DsMetaVal
data DsMetaVal
DsBound :: Id -> DsMetaVal
DsSplice :: HsExpr GhcTc -> DsMetaVal
type CompleteMatches = [CompleteMatch]
instance GHC.Unit.Module.ContainsModule GHC.HsToCore.Types.DsGblEnv

module GHC.Driver.Config.Core.Opt.Simplify
initSimplifyExprOpts :: DynFlags -> InteractiveContext -> SimplifyExprOpts
initSimplifyOpts :: DynFlags -> [Var] -> Int -> SimplMode -> RuleBase -> SimplifyOpts
initSimplMode :: DynFlags -> CompilerPhase -> String -> SimplMode
initGentleSimplMode :: DynFlags -> SimplMode

module GHC.Driver.Config.Core.Lint.Interactive
lintInteractiveExpr :: SDoc -> HscEnv -> CoreExpr -> IO ()

module GHC.Core.Opt.Pipeline
core2core :: HscEnv -> ModGuts -> IO ModGuts
simplifyExpr :: Logger -> ExternalUnitCache -> SimplifyExprOpts -> CoreExpr -> IO CoreExpr


-- | The <tt>GHC.Builtin.Utils</tt> interface to the compiler's prelude
--   knowledge.
--   
--   This module serves as the central gathering point for names which the
--   compiler knows something about. This includes functions for,
--   
--   <ul>
--   <li>discerning whether a <a>Name</a> is known-key</li>
--   <li>given a <a>Unique</a>, looking up its corresponding known-key
--   <a>Name</a></li>
--   </ul>
--   
--   See Note [Known-key names] and Note [About wired-in things] for
--   information about the two types of prelude things in GHC.
module GHC.Builtin.Utils

-- | Is a <a>Name</a> known-key?
isKnownKeyName :: Name -> Bool

-- | Given a <a>Unique</a> lookup its associated <a>Name</a> if it
--   corresponds to a known-key thing.
lookupKnownKeyName :: Unique -> Maybe Name

-- | Given a <a>Unique</a> lookup any associated arbitrary SDoc's to be
--   displayed by GHCi's ':info' command.
lookupKnownNameInfo :: Name -> SDoc

-- | This list is used to ensure that when you say "Prelude.map" in your
--   source code, or in an interface file, you get a Name with the correct
--   known key (See Note [Known-key names] in <a>GHC.Builtin.Names</a>)
knownKeyNames :: [Name]
wiredInIds :: [Id]
ghcPrimIds :: [Id]
ghcPrimExports :: [IfaceExport]
ghcPrimDeclDocs :: Docs
maybeCharLikeCon :: DataCon -> Bool
maybeIntLikeCon :: DataCon -> Bool
isNumericClass :: Class -> Bool
isStandardClass :: Class -> Bool

module GHC.StgToCmm.DataCon
cgTopRhsCon :: StgToCmmConfig -> Id -> DataCon -> ConstructorNumber -> [NonVoid StgArg] -> (CgIdInfo, FCode ())
buildDynCon :: Id -> ConstructorNumber -> Bool -> CostCentreStack -> DataCon -> [NonVoid StgArg] -> FCode (CgIdInfo, FCode CmmAGraph)
bindConArgs :: AltCon -> LocalReg -> [NonVoid Id] -> FCode [LocalReg]

module GHC.StgToCmm.Expr
cgExpr :: CgStgExpr -> FCode ReturnKind
cgLit :: Literal -> FCode CmmExpr

module GHC.StgToCmm.Bind
cgTopRhsClosure :: Platform -> RecFlag -> Id -> CostCentreStack -> UpdateFlag -> [Id] -> CgStgExpr -> (CgIdInfo, FCode ())
cgBind :: CgStgBinding -> FCode ()
emitBlackHoleCode :: CmmExpr -> FCode ()
pushUpdateFrame :: CLabel -> CmmExpr -> FCode () -> FCode ()
emitUpdateFrame :: CmmExpr -> CLabel -> CmmExpr -> FCode ()

module GHC.Cmm.Parser
parseCmmFile :: CmmParserConfig -> Module -> HomeUnit -> FilePath -> IO (Messages PsMessage, Messages PsMessage, Maybe (CmmGroup, [InfoProvEnt]))
data CmmParserConfig
CmmParserConfig :: !ParserOpts -> !PDConfig -> !StgToCmmConfig -> CmmParserConfig
[cmmpParserOpts] :: CmmParserConfig -> !ParserOpts
[cmmpPDConfig] :: CmmParserConfig -> !PDConfig
[cmmpStgToCmmConfig] :: CmmParserConfig -> !StgToCmmConfig

module GHC.StgToCmm
codeGen :: Logger -> TmpFs -> StgToCmmConfig -> InfoTableProvMap -> [TyCon] -> CollectedCCs -> [CgStgTopBinding] -> HpcInfo -> Stream IO CmmGroup ModuleLFInfos

module GHC.Iface.Ext.Types
type Span = RealSrcSpan

-- | Current version of <tt>.hie</tt> files
hieVersion :: Integer

-- | GHC builds up a wealth of information about Haskell source as it
--   compiles it. <tt>.hie</tt> files are a way of persisting some of this
--   information to disk so that external tools that need to work with
--   haskell source don't need to parse, typecheck, and rename all over
--   again. These files contain:
--   
--   <ul>
--   <li>a simplified AST<ul><li>nodes are annotated with source positions
--   and types</li><li>identifiers are annotated with scope
--   information</li></ul></li>
--   <li>the raw bytes of the initial Haskell source</li>
--   </ul>
--   
--   Besides saving compilation cycles, <tt>.hie</tt> files also offer a
--   more stable interface than the GHC API.
data HieFile
HieFile :: FilePath -> Module -> Array TypeIndex HieTypeFlat -> HieASTs TypeIndex -> [AvailInfo] -> ByteString -> HieFile

-- | Initial Haskell source file path
[hie_hs_file] :: HieFile -> FilePath

-- | The module this HIE file is for
[hie_module] :: HieFile -> Module

-- | Types referenced in the <a>hie_asts</a>.
--   
--   See Note [Efficient serialization of redundant type info]
[hie_types] :: HieFile -> Array TypeIndex HieTypeFlat

-- | Type-annotated abstract syntax trees
[hie_asts] :: HieFile -> HieASTs TypeIndex

-- | The names that this module exports
[hie_exports] :: HieFile -> [AvailInfo]

-- | Raw bytes of the initial Haskell source
[hie_hs_src] :: HieFile -> ByteString
type TypeIndex = Int

-- | A flattened version of <tt>Type</tt>.
--   
--   See Note [Efficient serialization of redundant type info]
data HieType a
HTyVarTy :: Name -> HieType a
HAppTy :: a -> HieArgs a -> HieType a
HTyConApp :: IfaceTyCon -> HieArgs a -> HieType a
HForAllTy :: ((Name, a), ForAllTyFlag) -> a -> HieType a
HFunTy :: a -> a -> a -> HieType a

-- | type with constraint: <tt>t1 =&gt; t2</tt> (see <tt>IfaceDFunTy</tt>)
HQualTy :: a -> a -> HieType a
HLitTy :: IfaceTyLit -> HieType a
HCastTy :: a -> HieType a
HCoercionTy :: HieType a
type HieTypeFlat = HieType TypeIndex

-- | Roughly isomorphic to the original core <tt>Type</tt>.
newtype HieTypeFix
Roll :: HieType HieTypeFix -> HieTypeFix

-- | A list of type arguments along with their respective visibilities (ie.
--   is this an argument that would return <a>True</a> for
--   <tt>isVisibleForAllTyFlag</tt>?).
newtype HieArgs a
HieArgs :: [(Bool, a)] -> HieArgs a
type HiePath = LexicalFastString
pattern HiePath :: FastString -> HiePath

-- | Mapping from filepaths to the corresponding AST
newtype HieASTs a
HieASTs :: Map HiePath (HieAST a) -> HieASTs a
[getAsts] :: HieASTs a -> Map HiePath (HieAST a)
data HieAST a
Node :: SourcedNodeInfo a -> Span -> [HieAST a] -> HieAST a
[sourcedNodeInfo] :: HieAST a -> SourcedNodeInfo a
[nodeSpan] :: HieAST a -> Span
[nodeChildren] :: HieAST a -> [HieAST a]

-- | NodeInfos grouped by source
newtype SourcedNodeInfo a
SourcedNodeInfo :: Map NodeOrigin (NodeInfo a) -> SourcedNodeInfo a
[getSourcedNodeInfo] :: SourcedNodeInfo a -> Map NodeOrigin (NodeInfo a)

-- | Source of node info
data NodeOrigin
SourceInfo :: NodeOrigin
GeneratedInfo :: NodeOrigin

-- | A node annotation
data NodeAnnotation
NodeAnnotation :: !FastString -> !FastString -> NodeAnnotation

-- | name of the AST node constructor
[nodeAnnotConstr] :: NodeAnnotation -> !FastString

-- | name of the AST node Type
[nodeAnnotType] :: NodeAnnotation -> !FastString

-- | The information stored in one AST node.
--   
--   The type parameter exists to provide flexibility in representation of
--   types (see Note [Efficient serialization of redundant type info]).
data NodeInfo a
NodeInfo :: Set NodeAnnotation -> [a] -> NodeIdentifiers a -> NodeInfo a

-- | Annotations
[nodeAnnotations] :: NodeInfo a -> Set NodeAnnotation

-- | The Haskell types of this node, if any.
[nodeType] :: NodeInfo a -> [a]

-- | All the identifiers and their details
[nodeIdentifiers] :: NodeInfo a -> NodeIdentifiers a
pprNodeIdents :: Outputable a => NodeIdentifiers a -> SDoc
pprIdentifier :: Identifier -> SDoc
type Identifier = Either ModuleName Name
type NodeIdentifiers a = Map Identifier (IdentifierDetails a)

-- | Information associated with every identifier
--   
--   We need to include types with identifiers because sometimes multiple
--   identifiers occur in the same span(Overloaded Record Fields and so on)
data IdentifierDetails a
IdentifierDetails :: Maybe a -> Set ContextInfo -> IdentifierDetails a
[identType] :: IdentifierDetails a -> Maybe a
[identInfo] :: IdentifierDetails a -> Set ContextInfo

-- | Different contexts under which identifiers exist
data ContextInfo

-- | regular variable
Use :: ContextInfo
MatchBind :: ContextInfo

-- | import/export
IEThing :: IEType -> ContextInfo
TyDecl :: ContextInfo

-- | Value binding
ValBind :: BindType -> Scope -> Maybe Span -> ContextInfo

-- | Pattern binding
--   
--   This case is tricky because the bound identifier can be used in two
--   distinct scopes. Consider the following example (with
--   <tt>-XViewPatterns</tt>)
--   
--   <pre>
--   do (b, a, (a -&gt; True)) &lt;- bar
--      foo a
--   </pre>
--   
--   The identifier <tt>a</tt> has two scopes: in the view pattern <tt>(a
--   -&gt; True)</tt> and in the rest of the <tt>do</tt>-block in <tt>foo
--   a</tt>.
PatternBind :: Scope -> Scope -> Maybe Span -> ContextInfo
ClassTyDecl :: Maybe Span -> ContextInfo

-- | Declaration
Decl :: DeclType -> Maybe Span -> ContextInfo

-- | Type variable
TyVarBind :: Scope -> TyVarScope -> ContextInfo

-- | Record field
RecField :: RecFieldContext -> Maybe Span -> ContextInfo

-- | Constraint/Dictionary evidence variable binding
EvidenceVarBind :: EvVarSource -> Scope -> Maybe Span -> ContextInfo

-- | Usage of evidence variable
EvidenceVarUse :: ContextInfo
pprBindSpan :: Maybe Span -> SDoc
data EvVarSource

-- | bound by a pattern match
EvPatternBind :: EvVarSource

-- | bound by a type signature
EvSigBind :: EvVarSource

-- | bound by a hswrapper
EvWrapperBind :: EvVarSource

-- | bound by an implicit variable
EvImplicitBind :: EvVarSource

-- | Bound by some instance of given class
EvInstBind :: Bool -> Name -> EvVarSource
[isSuperInst] :: EvVarSource -> Bool
[cls] :: EvVarSource -> Name

-- | A direct let binding
EvLetBind :: EvBindDeps -> EvVarSource

-- | Eq/Ord instances compare on the converted HieName, as non-exported
--   names may have different uniques after a roundtrip
newtype EvBindDeps
EvBindDeps :: [Name] -> EvBindDeps
[getEvBindDeps] :: EvBindDeps -> [Name]

-- | Types of imports and exports
data IEType
Import :: IEType
ImportAs :: IEType
ImportHiding :: IEType
Export :: IEType
data RecFieldContext
RecFieldDecl :: RecFieldContext
RecFieldAssign :: RecFieldContext
RecFieldMatch :: RecFieldContext
RecFieldOcc :: RecFieldContext
data BindType
RegularBind :: BindType
InstanceBind :: BindType
data DeclType

-- | type or data family
FamDec :: DeclType

-- | type synonym
SynDec :: DeclType

-- | data declaration
DataDec :: DeclType

-- | constructor declaration
ConDec :: DeclType

-- | pattern synonym
PatSynDec :: DeclType

-- | class declaration
ClassDec :: DeclType

-- | instance declaration
InstDec :: DeclType
data Scope
NoScope :: Scope
LocalScope :: Span -> Scope
ModuleScope :: Scope

-- | Scope of a type variable.
--   
--   This warrants a data type apart from <a>Scope</a> because of
--   complexities introduced by features like
--   <tt>-XScopedTypeVariables</tt> and <tt>-XInstanceSigs</tt>. For
--   example, consider:
--   
--   <pre>
--   foo, bar, baz :: forall a. a -&gt; a
--   </pre>
--   
--   Here <tt>a</tt> is in scope in all the definitions of <tt>foo</tt>,
--   <tt>bar</tt>, and <tt>baz</tt>, so we need a list of scopes to keep
--   track of this. Furthermore, this list cannot be computed until we
--   resolve the binding sites of <tt>foo</tt>, <tt>bar</tt>, and
--   <tt>baz</tt>.
--   
--   Consequently, <tt>a</tt> starts with an <tt><a>UnresolvedScope</a>
--   [foo, bar, baz] Nothing</tt> which later gets resolved into a
--   <a>ResolvedScopes</a>.
data TyVarScope
ResolvedScopes :: [Scope] -> TyVarScope

-- | Unresolved scopes should never show up in the final <tt>.hie</tt> file
UnresolvedScope :: [Name] -> Maybe Span -> TyVarScope

-- | <a>Name</a>'s get converted into <a>HieName</a>'s before being written
--   into <tt>.hie</tt> files. See <a>toHieName</a> and
--   <tt>fromHieName</tt> for logic on how to convert between these two
--   types.
data HieName
ExternalName :: !Module -> !OccName -> !SrcSpan -> HieName
LocalName :: !OccName -> !SrcSpan -> HieName
KnownKeyName :: !Unique -> HieName
hieNameOcc :: HieName -> OccName
toHieName :: Name -> HieName
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Types.HieArgs a)
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.HieArgs
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.HieArgs
instance GHC.Base.Functor GHC.Iface.Ext.Types.HieArgs
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Types.HieType a)
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.HieType
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.HieType
instance GHC.Base.Functor GHC.Iface.Ext.Types.HieType
instance GHC.Classes.Eq GHC.Iface.Ext.Types.HieTypeFix
instance GHC.Classes.Ord GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Enum.Enum GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Classes.Eq GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Classes.Eq GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Classes.Ord GHC.Iface.Ext.Types.EvVarSource
instance GHC.Classes.Eq GHC.Iface.Ext.Types.EvVarSource
instance GHC.Classes.Ord GHC.Iface.Ext.Types.IEType
instance GHC.Enum.Enum GHC.Iface.Ext.Types.IEType
instance GHC.Classes.Eq GHC.Iface.Ext.Types.IEType
instance GHC.Classes.Ord GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Enum.Enum GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Classes.Eq GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Enum.Enum GHC.Iface.Ext.Types.BindType
instance GHC.Classes.Ord GHC.Iface.Ext.Types.BindType
instance GHC.Classes.Eq GHC.Iface.Ext.Types.BindType
instance GHC.Enum.Enum GHC.Iface.Ext.Types.DeclType
instance GHC.Classes.Ord GHC.Iface.Ext.Types.DeclType
instance GHC.Classes.Eq GHC.Iface.Ext.Types.DeclType
instance Data.Data.Data GHC.Iface.Ext.Types.Scope
instance GHC.Classes.Ord GHC.Iface.Ext.Types.Scope
instance GHC.Classes.Eq GHC.Iface.Ext.Types.Scope
instance GHC.Classes.Ord GHC.Iface.Ext.Types.TyVarScope
instance GHC.Classes.Eq GHC.Iface.Ext.Types.TyVarScope
instance GHC.Classes.Ord GHC.Iface.Ext.Types.ContextInfo
instance GHC.Classes.Eq GHC.Iface.Ext.Types.ContextInfo
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.IdentifierDetails
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.IdentifierDetails
instance GHC.Base.Functor GHC.Iface.Ext.Types.IdentifierDetails
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Types.IdentifierDetails a)
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.NodeInfo
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.NodeInfo
instance GHC.Base.Functor GHC.Iface.Ext.Types.NodeInfo
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.SourcedNodeInfo
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.SourcedNodeInfo
instance GHC.Base.Functor GHC.Iface.Ext.Types.SourcedNodeInfo
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.HieAST
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.HieAST
instance GHC.Base.Functor GHC.Iface.Ext.Types.HieAST
instance Data.Traversable.Traversable GHC.Iface.Ext.Types.HieASTs
instance Data.Foldable.Foldable GHC.Iface.Ext.Types.HieASTs
instance GHC.Base.Functor GHC.Iface.Ext.Types.HieASTs
instance GHC.Classes.Eq GHC.Iface.Ext.Types.HieName
instance GHC.Classes.Ord GHC.Iface.Ext.Types.HieName
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.HieName
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.HieFile
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieASTs GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.HieASTs a)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieAST GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.HieAST a)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.SourcedNodeInfo GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.SourcedNodeInfo a)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.NodeInfo GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.NodeInfo a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Types.IdentifierDetails a)
instance GHC.Base.Semigroup (GHC.Iface.Ext.Types.IdentifierDetails a)
instance GHC.Base.Monoid (GHC.Iface.Ext.Types.IdentifierDetails a)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.IdentifierDetails GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.ContextInfo
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.ContextInfo
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.TyVarScope
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.TyVarScope
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.Scope
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.Scope
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.DeclType
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.DeclType
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.BindType
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.BindType
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.RecFieldContext
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.IEType
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.IEType
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.EvVarSource
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.EvVarSource
instance GHC.Classes.Eq GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Classes.Ord GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.EvBindDeps
instance GHC.Classes.Ord GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.NodeAnnotation
instance GHC.Utils.Outputable.Outputable GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Utils.Binary.Binary GHC.Iface.Ext.Types.NodeOrigin
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieType GHC.Iface.Ext.Types.TypeIndex)
instance GHC.Utils.Binary.Binary (GHC.Iface.Ext.Types.HieArgs GHC.Iface.Ext.Types.TypeIndex)

module GHC.Iface.Ext.Utils
type RefMap a = Map Identifier [(Span, IdentifierDetails a)]
generateReferencesMap :: Foldable f => f (HieAST a) -> RefMap a
renderHieType :: DynFlags -> HieTypeFix -> String
resolveVisibility :: Type -> [Type] -> [(Bool, Type)]
foldType :: (HieType a -> a) -> HieTypeFix -> a
selectPoint :: HieFile -> (Int, Int) -> Maybe (HieAST Int)
findEvidenceUse :: NodeIdentifiers a -> [Name]
data EvidenceInfo a
EvidenceInfo :: Name -> RealSrcSpan -> a -> Maybe (EvVarSource, Scope, Maybe Span) -> EvidenceInfo a
[evidenceVar] :: EvidenceInfo a -> Name
[evidenceSpan] :: EvidenceInfo a -> RealSrcSpan
[evidenceType] :: EvidenceInfo a -> a
[evidenceDetails] :: EvidenceInfo a -> Maybe (EvVarSource, Scope, Maybe Span)
getEvidenceTreesAtPoint :: HieFile -> RefMap a -> (Int, Int) -> Forest (EvidenceInfo a)
getEvidenceTree :: RefMap a -> Name -> Maybe (Tree (EvidenceInfo a))
hieTypeToIface :: HieTypeFix -> IfaceType
data HieTypeState
HTS :: !TypeMap TypeIndex -> !IntMap HieTypeFlat -> !TypeIndex -> HieTypeState
[tyMap] :: HieTypeState -> !TypeMap TypeIndex
[htyTable] :: HieTypeState -> !IntMap HieTypeFlat
[freshIndex] :: HieTypeState -> !TypeIndex
initialHTS :: HieTypeState
freshTypeIndex :: State HieTypeState TypeIndex
compressTypes :: HieASTs Type -> (HieASTs TypeIndex, Array TypeIndex HieTypeFlat)
recoverFullType :: TypeIndex -> Array TypeIndex HieTypeFlat -> HieTypeFix
getTypeIndex :: Type -> State HieTypeState TypeIndex
resolveTyVarScopes :: Map HiePath (HieAST a) -> Map HiePath (HieAST a)
resolveTyVarScopeLocal :: HieAST a -> Map HiePath (HieAST a) -> HieAST a
getNameBinding :: Name -> Map HiePath (HieAST a) -> Maybe Span
getNameScope :: Name -> Map HiePath (HieAST a) -> Maybe [Scope]
getNameBindingInClass :: Name -> Span -> Map HiePath (HieAST a) -> Maybe Span
getNameScopeAndBinding :: Name -> Map HiePath (HieAST a) -> Maybe ([Scope], Maybe Span)
getScopeFromContext :: ContextInfo -> Maybe [Scope]
getBindSiteFromContext :: ContextInfo -> Maybe Span
flattenAst :: HieAST a -> [HieAST a]
smallestContainingSatisfying :: Span -> (HieAST a -> Bool) -> HieAST a -> Maybe (HieAST a)
selectLargestContainedBy :: Span -> HieAST a -> Maybe (HieAST a)
selectSmallestContaining :: Span -> HieAST a -> Maybe (HieAST a)
definedInAsts :: Map HiePath (HieAST a) -> Name -> Bool
getEvidenceBindDeps :: ContextInfo -> [Name]
isEvidenceBind :: ContextInfo -> Bool
isEvidenceContext :: ContextInfo -> Bool
isEvidenceUse :: ContextInfo -> Bool
isOccurrence :: ContextInfo -> Bool
scopeContainsSpan :: Scope -> Span -> Bool

-- | One must contain the other. Leaf nodes cannot contain anything
combineAst :: HieAST Type -> HieAST Type -> HieAST Type

-- | Insert an AST in a sorted list of disjoint Asts
insertAst :: HieAST Type -> [HieAST Type] -> [HieAST Type]
nodeInfo :: HieAST Type -> NodeInfo Type
emptyNodeInfo :: NodeInfo a
sourcedNodeIdents :: SourcedNodeInfo a -> NodeIdentifiers a
combineSourcedNodeInfo :: SourcedNodeInfo Type -> SourcedNodeInfo Type -> SourcedNodeInfo Type

-- | Merge two nodes together.
--   
--   Precondition and postcondition: elements in <a>nodeType</a> are
--   ordered.
combineNodeInfo :: NodeInfo Type -> NodeInfo Type -> NodeInfo Type

-- | Merge two sorted, disjoint lists of ASTs, combining when necessary.
--   
--   In the absence of position-altering pragmas (ex: <tt># line "file.hs"
--   3</tt>), different nodes in an AST tree should either have disjoint
--   spans (in which case you can say for sure which one comes first) or
--   one span should be completely contained in the other (in which case
--   the contained span corresponds to some child node).
--   
--   However, since Haskell does have position-altering pragmas it
--   <i>is</i> possible for spans to be overlapping. Here is an example of
--   a source file in which <tt>foozball</tt> and <tt>quuuuuux</tt> have
--   overlapping spans:
--   
--   <pre>
--   module Baz where
--   
--   # line 3 "Baz.hs"
--   foozball :: Int
--   foozball = 0
--   
--   # line 3 "Baz.hs"
--   bar, quuuuuux :: Int
--   bar = 1
--   quuuuuux = 2
--   </pre>
--   
--   In these cases, we just do our best to produce sensible
--   <a>HieAST</a>'s. The blame should be laid at the feet of whoever wrote
--   the line pragmas in the first place (usually the C preprocessor...).
mergeAsts :: [HieAST Type] -> [HieAST Type] -> [HieAST Type]
rightOf :: Span -> Span -> Bool
leftOf :: Span -> Span -> Bool
startsRightOf :: Span -> Span -> Bool

-- | combines and sorts ASTs using a merge sort
mergeSortAsts :: [HieAST Type] -> [HieAST Type]
simpleNodeInfo :: FastString -> FastString -> NodeInfo a
locOnly :: Monad m => SrcSpan -> ReaderT NodeOrigin m [HieAST a]
mkScopeA :: SrcSpanAnn' ann -> Scope
mkScope :: SrcSpan -> Scope
mkLScope :: Located a -> Scope
mkLScopeA :: GenLocated (SrcSpanAnn' a) e -> Scope
mkLScopeN :: LocatedN a -> Scope
combineScopes :: Scope -> Scope -> Scope
mkSourcedNodeInfo :: NodeOrigin -> NodeInfo a -> SourcedNodeInfo a
makeNodeA :: (Monad m, Data a) => a -> SrcSpanAnn' ann -> ReaderT NodeOrigin m [HieAST b]
makeNode :: (Monad m, Data a) => a -> SrcSpan -> ReaderT NodeOrigin m [HieAST b]
makeTypeNodeA :: (Monad m, Data a) => a -> SrcSpanAnnA -> Type -> ReaderT NodeOrigin m [HieAST Type]
makeTypeNode :: (Monad m, Data a) => a -> SrcSpan -> Type -> ReaderT NodeOrigin m [HieAST Type]
instance GHC.Base.Functor GHC.Iface.Ext.Utils.EvidenceInfo
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Iface.Ext.Utils.EvidenceInfo a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Iface.Ext.Utils.EvidenceInfo a)
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Ext.Utils.EvidenceInfo a)

module GHC.Iface.Ext.Debug
type Diff a = a -> a -> [SDoc]
diffFile :: Diff HieFile
diffAsts :: (Outputable a, Eq a, Ord a) => Diff a -> Diff (Map HiePath (HieAST a))
diffAst :: (Outputable a, Eq a, Ord a) => Diff a -> Diff (HieAST a)
type DiffIdent = Either ModuleName HieName
normalizeIdents :: Ord a => NodeIdentifiers a -> [(DiffIdent, IdentifierDetails a)]
diffList :: Diff a -> Diff [a]
eqDiff :: (Outputable a, Eq a) => Diff a
validAst :: HieAST a -> Either SDoc ()

-- | Look for any identifiers which occur outside of their supposed scopes.
--   Returns a list of error messages.
validateScopes :: Module -> Map HiePath (HieAST a) -> [SDoc]

module GHC.Iface.Ext.Binary

-- | Read a <a>HieFile</a> from a <a>FilePath</a>. Can use an existing
--   <a>NameCache</a>.
readHieFile :: NameCache -> FilePath -> IO HieFileResult

-- | Read a <a>HieFile</a> from a <a>FilePath</a>. Can use an existing
--   <a>NameCache</a>. Allows you to specify which versions of hieFile to
--   attempt to read. <a>Left</a> case returns the failing header versions.
readHieFileWithVersion :: (HieHeader -> Bool) -> NameCache -> FilePath -> IO (Either HieHeader HieFileResult)
type HieHeader = (Integer, ByteString)

-- | Write a <a>HieFile</a> to the given <a>FilePath</a>, with a proper
--   header and symbol tables for <a>Name</a>s and <a>FastString</a>s
writeHieFile :: FilePath -> HieFile -> IO ()

-- | <a>Name</a>'s get converted into <a>HieName</a>'s before being written
--   into <tt>.hie</tt> files. See <a>toHieName</a> and
--   <tt>fromHieName</tt> for logic on how to convert between these two
--   types.
data HieName
ExternalName :: !Module -> !OccName -> !SrcSpan -> HieName
LocalName :: !OccName -> !SrcSpan -> HieName
KnownKeyName :: !Unique -> HieName
toHieName :: Name -> HieName
data HieFileResult
HieFileResult :: Integer -> ByteString -> HieFile -> HieFileResult
[hie_file_result_version] :: HieFileResult -> Integer
[hie_file_result_ghc_version] :: HieFileResult -> ByteString
[hie_file_result] :: HieFileResult -> HieFile

-- | The header for HIE files - Capital ASCII letters "HIE".
hieMagic :: [Word8]
hieNameOcc :: HieName -> OccName


-- | Binary interface file support.
module GHC.Iface.Binary

-- | Write an interface file
writeBinIface :: Profile -> TraceBinIFace -> FilePath -> ModIface -> IO ()

-- | Read an interface file.
readBinIface :: Profile -> NameCache -> CheckHiWay -> TraceBinIFace -> FilePath -> IO ModIface

-- | Read an interface file header, checking the magic number, version, and
--   way. Returns the hash of the source file and a BinHandle which points
--   at the start of the rest of the interface file data.
readBinIfaceHeader :: Profile -> NameCache -> CheckHiWay -> TraceBinIFace -> FilePath -> IO (Fingerprint, BinHandle)
getSymtabName :: NameCache -> Dictionary -> SymbolTable -> BinHandle -> IO Name
data CheckHiWay
CheckHiWay :: CheckHiWay
IgnoreHiWay :: CheckHiWay
data TraceBinIFace
TraceBinIFace :: (SDoc -> IO ()) -> TraceBinIFace
QuietBinIFace :: TraceBinIFace

-- | This performs a get action after reading the dictionary and symbol
--   table. It is necessary to run this before trying to deserialise any
--   Names or FastStrings.
getWithUserData :: Binary a => NameCache -> BinHandle -> IO a

-- | Put a piece of data with an initialised <a>UserData</a> field. This is
--   necessary if you want to serialise Names or FastStrings. It also
--   writes a symbol table and the dictionary. This segment should be read
--   using <a>getWithUserData</a>.
putWithUserData :: Binary a => TraceBinIFace -> BinHandle -> a -> IO ()
getSymbolTable :: BinHandle -> NameCache -> IO SymbolTable
putName :: FSTable -> BinSymbolTable -> BinHandle -> Name -> IO ()
putSymbolTable :: BinHandle -> Int -> UniqFM Name (Int, Name) -> IO ()
data BinSymbolTable
BinSymbolTable :: !FastMutInt -> !IORef (UniqFM Name (Int, Name)) -> BinSymbolTable
[bin_symtab_next] :: BinSymbolTable -> !FastMutInt
[bin_symtab_map] :: BinSymbolTable -> !IORef (UniqFM Name (Int, Name))
instance GHC.Classes.Eq GHC.Iface.Binary.CheckHiWay


-- | Loading interface files
module GHC.Iface.Load
tcLookupImported_maybe :: Name -> TcM (MaybeErr SDoc TyThing)
importDecl :: Name -> IfM lcl (MaybeErr SDoc TyThing)
checkWiredInTyCon :: TyCon -> TcM ()
ifCheckWiredInThing :: TyThing -> IfL ()

-- | Load interface directly for a fully qualified <a>GenModule</a>. (This
--   is a fairly rare operation, but in particular it is used to load
--   orphan modules in order to pull their instances into the global
--   package table and to handle some operations in GHCi).
loadModuleInterface :: SDoc -> Module -> TcM ModIface

-- | Load interfaces for a collection of modules.
loadModuleInterfaces :: SDoc -> [Module] -> TcM ()

-- | Load the interface corresponding to an <tt>import</tt> directive in
--   source code. On a failure, fail in the monad with an error message.
loadSrcInterface :: SDoc -> ModuleName -> IsBootInterface -> PkgQual -> RnM ModIface

-- | Like <a>loadSrcInterface</a>, but returns a <a>MaybeErr</a>.
loadSrcInterface_maybe :: SDoc -> ModuleName -> IsBootInterface -> PkgQual -> RnM (MaybeErr SDoc ModIface)

-- | Loads the interface for a given Name. Should only be called for an
--   imported name; otherwise loadSysInterface may not find the interface
loadInterfaceForName :: SDoc -> Name -> TcRn ModIface

-- | Loads the interface for a given Module.
loadInterfaceForModule :: SDoc -> Module -> TcRn ModIface
loadInterface :: SDoc -> Module -> WhereFrom -> IfM lcl (MaybeErr SDoc ModIface)

-- | Loads a system interface and throws an exception if it fails
loadSysInterface :: SDoc -> Module -> IfM lcl ModIface

-- | Loads a user interface and throws an exception if it fails. The first
--   parameter indicates whether we should import the boot variant of the
--   module
loadUserInterface :: IsBootInterface -> SDoc -> Module -> IfM lcl ModIface
loadPluginInterface :: SDoc -> Module -> IfM lcl ModIface
findAndReadIface :: HscEnv -> SDoc -> InstalledModule -> Module -> IsBootInterface -> IO (MaybeErr SDoc (ModIface, FilePath))

-- | <tt>readIface</tt> tries just the one file.
--   
--   Failed err <a>=</a> file not found, or unreadable, or illegible
--   Succeeded iface <a>=</a> successfully found and parsed
readIface :: DynFlags -> NameCache -> Module -> FilePath -> IO (MaybeErr SDoc ModIface)

-- | Write interface file
writeIface :: Logger -> Profile -> FilePath -> ModIface -> IO ()

-- | Compute the signatures which must be compiled in order to load the
--   interface for a <a>GenModule</a>. The output of this function is
--   always a subset of <a>moduleFreeHoles</a>; it is more precise because
--   in signature <tt>p[A=&lt;A&gt;,B=&lt;B&gt;]:B</tt>, although the free
--   holes are A and B, B might not depend on A at all!
--   
--   If this is invoked on a signature, this does NOT include the signature
--   itself; e.g. precise free module holes of
--   <tt>p[A=&lt;A&gt;,B=&lt;B&gt;]:B</tt> never includes B.
moduleFreeHolesPrecise :: SDoc -> Module -> TcRnIf gbl lcl (MaybeErr SDoc (UniqDSet ModuleName))
needWiredInHomeIface :: TyThing -> Bool

-- | An <a>IfM</a> function to load the home interface for a wired-in
--   thing, so that we're sure that we see its instance declarations and
--   rules See Note [Loading instances for wired-in things]
loadWiredInHomeIface :: Name -> IfM lcl ()

-- | Show a ModIface but don't display details; suitable for ModIfaces
--   stored in the EPT.
pprModIfaceSimple :: UnitState -> ModIface -> SDoc
ifaceStats :: ExternalPackageState -> SDoc

-- | Show a ModIface
--   
--   The UnitState is used to pretty-print units
pprModIface :: UnitState -> ModIface -> SDoc

-- | Read binary interface, and print it out
showIface :: Logger -> DynFlags -> UnitState -> NameCache -> FilePath -> IO ()
instance GHC.Utils.Outputable.Outputable (GHC.Unit.Module.Warnings.Warnings pass)

module GHC.Tc.Utils.Env

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See
--   <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a> given a
--   <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing

-- | A typecheckable thing available in a local context. Could be
--   <a>AGlobal</a> <a>TyThing</a>, but also lexically scoped variables,
--   etc. See <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a>
--   given a <a>Name</a>.
data TcTyThing
AGlobal :: TyThing -> TcTyThing
ATcId :: TcId -> IdBindingInfo -> TcTyThing
[tct_id] :: TcTyThing -> TcId
[tct_info] :: TcTyThing -> IdBindingInfo
ATyVar :: Name -> TcTyVar -> TcTyThing
ATcTyCon :: TyCon -> TcTyThing
APromotionErr :: PromotionErr -> TcTyThing
type TcId = Id
data InstInfo a
InstInfo :: ClsInst -> InstBindings a -> InstInfo a
[iSpec] :: InstInfo a -> ClsInst
[iBinds] :: InstInfo a -> InstBindings a
iDFunId :: InstInfo a -> DFunId
pprInstInfoDetails :: OutputableBndrId a => InstInfo (GhcPass a) -> SDoc
simpleInstInfoClsTy :: InstInfo a -> (Class, Type)
simpleInstInfoTy :: InstInfo a -> Type
simpleInstInfoTyCon :: InstInfo a -> TyCon
data InstBindings a
InstBindings :: [Name] -> LHsBinds a -> [LSig a] -> [Extension] -> Bool -> InstBindings a
[ib_tyvars] :: InstBindings a -> [Name]
[ib_binds] :: InstBindings a -> LHsBinds a
[ib_pragmas] :: InstBindings a -> [LSig a]
[ib_extensions] :: InstBindings a -> [Extension]
[ib_derived] :: InstBindings a -> Bool
tcExtendGlobalEnv :: [TyThing] -> TcM r -> TcM r
tcExtendTyConEnv :: [TyCon] -> TcM r -> TcM r
tcExtendGlobalEnvImplicit :: [TyThing] -> TcM r -> TcM r
setGlobalTypeEnv :: TcGblEnv -> TypeEnv -> TcM TcGblEnv
tcExtendGlobalValEnv :: [Id] -> TcM a -> TcM a
tcTyThBinders :: [TyThing] -> TcM ThBindEnv
tcLookupLocatedGlobal :: LocatedA Name -> TcM TyThing
tcLookupGlobal :: Name -> TcM TyThing
tcLookupGlobalOnly :: Name -> TcM TyThing
tcLookupTyCon :: Name -> TcM TyCon
tcLookupClass :: Name -> TcM Class
tcLookupDataCon :: Name -> TcM DataCon
tcLookupPatSyn :: Name -> TcM PatSyn
tcLookupConLike :: Name -> TcM ConLike
tcLookupLocatedGlobalId :: LocatedA Name -> TcM Id
tcLookupLocatedTyCon :: LocatedN Name -> TcM TyCon
tcLookupLocatedClass :: LocatedA Name -> TcM Class
tcLookupAxiom :: Name -> TcM (CoAxiom Branched)
lookupGlobal :: HscEnv -> Name -> IO TyThing
lookupGlobal_maybe :: HscEnv -> Name -> IO (MaybeErr SDoc TyThing)
ioLookupDataCon :: HscEnv -> Name -> IO DataCon
addTypecheckedBinds :: TcGblEnv -> [LHsBinds GhcTc] -> TcGblEnv
tcExtendKindEnv :: NameEnv TcTyThing -> TcM r -> TcM r
tcExtendKindEnvList :: [(Name, TcTyThing)] -> TcM r -> TcM r
tcExtendTyVarEnv :: [TyVar] -> TcM r -> TcM r
tcExtendNameTyVarEnv :: [(Name, TcTyVar)] -> TcM r -> TcM r
tcExtendLetEnv :: TopLevelFlag -> TcSigFun -> IsGroupClosed -> [TcId] -> TcM a -> TcM a
tcExtendSigIds :: TopLevelFlag -> [TcId] -> TcM a -> TcM a
tcExtendRecIds :: [(Name, TcId)] -> TcM a -> TcM a
tcExtendIdEnv :: [TcId] -> TcM a -> TcM a
tcExtendIdEnv1 :: Name -> TcId -> TcM a -> TcM a
tcExtendIdEnv2 :: [(Name, TcId)] -> TcM a -> TcM a
tcExtendBinderStack :: [TcBinder] -> TcM a -> TcM a
tcExtendLocalTypeEnv :: TcLclEnv -> [(Name, TcTyThing)] -> TcLclEnv
isTypeClosedLetBndr :: Id -> Bool

-- | <tt>tcCheckUsage name mult thing_inside</tt> runs
--   <tt>thing_inside</tt>, checks that the usage of <tt>name</tt> is a
--   submultiplicity of <tt>mult</tt>, and removes <tt>name</tt> from the
--   usage environment. See also Note [Wrapper returned from tcSubMult] in
--   GHC.Tc.Utils.Unify, which applies to the wrapper returned from this
--   function.
tcCheckUsage :: Name -> Mult -> TcM a -> TcM (a, HsWrapper)
tcLookup :: Name -> TcM TcTyThing
tcLookupLocated :: LocatedA Name -> TcM TcTyThing
tcLookupLocalIds :: [Name] -> TcM [TcId]
tcLookupId :: Name -> TcM Id
tcLookupIdMaybe :: Name -> TcM (Maybe Id)
tcLookupTyVar :: Name -> TcM TcTyVar
tcLookupTcTyCon :: HasDebugCallStack => Name -> TcM TcTyCon
tcLookupLcl_maybe :: Name -> TcM (Maybe TcTyThing)
getInLocalScope :: TcM (Name -> Bool)
wrongThingErr :: String -> TcTyThing -> Name -> TcM a
pprBinders :: [Name] -> SDoc
tcAddDataFamConPlaceholders :: [LInstDecl GhcRn] -> TcM a -> TcM a
tcAddPatSynPlaceholders :: [PatSynBind GhcRn GhcRn] -> TcM a -> TcM a
getTypeSigNames :: [LSig GhcRn] -> NameSet
tcExtendRecEnv :: [(Name, TyThing)] -> TcM r -> TcM r
tcInitTidyEnv :: TcM TidyEnv

-- | Get a <a>TidyEnv</a> that includes mappings for all vars free in the
--   given type. Useful when tidying open types.
tcInitOpenTidyEnv :: [TyCoVar] -> TcM TidyEnv
tcLookupInstance :: Class -> [Type] -> TcM ClsInst
tcGetInstEnvs :: TcM InstEnvs
tcExtendRules :: [LRuleDecl GhcTc] -> TcM a -> TcM a
tcGetDefaultTys :: TcM ([Type], (Bool, Bool))
checkWellStaged :: SDoc -> ThLevel -> ThLevel -> TcM ()
tcMetaTy :: Name -> TcM Type
thLevel :: ThStage -> ThLevel
topIdLvl :: Id -> ThLevel
isBrackStage :: ThStage -> Bool

-- | Make a name for the dict fun for an instance decl. It's an *external*
--   name, like other top-level names, and hence must be made with
--   newGlobalBinder.
newDFunName :: Class -> [Type] -> SrcSpan -> TcM Name
newFamInstTyConName :: LocatedN Name -> [Type] -> TcM Name
newFamInstAxiomName :: LocatedN Name -> [[Type]] -> TcM Name
mkStableIdFromString :: String -> Type -> SrcSpan -> (OccName -> OccName) -> TcM TcId
mkStableIdFromName :: Name -> Type -> SrcSpan -> (OccName -> OccName) -> TcM TcId

-- | <pre>
--   mkWrapperName ref what nameBase
--   </pre>
--   
--   See Note [Generating fresh names for FFI wrappers] for <tt>ref</tt>'s
--   purpose.
mkWrapperName :: (MonadIO m, HasModule m) => IORef (ModuleEnv Int) -> String -> String -> m FastString
instance GHC.Hs.Extension.OutputableBndrId a => GHC.Utils.Outputable.Outputable (GHC.Tc.Utils.Env.InstInfo (GHC.Hs.Extension.GhcPass a))
instance GHC.Types.TyThing.MonadThings (GHC.Data.IOEnv.IOEnv (GHC.Tc.Types.Env GHC.Tc.Types.TcGblEnv GHC.Tc.Types.TcLclEnv))


-- | Specialisations of the <tt>HsSyn</tt> syntax for the typechecker
--   
--   This module is an extension of <tt>HsSyn</tt> syntax, for use in the
--   type checker.
module GHC.Tc.Utils.Zonk
mkHsDictLet :: TcEvBinds -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsApp :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)

-- | A simple case alternative with a single pattern, no binds, no guards;
--   pre-typechecking
mkHsCaseAlt :: (Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcAnn NoEpAnns, Anno (Match (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpanAnnA) => LPat (GhcPass p) -> LocatedA (body (GhcPass p)) -> LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
tcShortCutLit :: HsOverLit GhcRn -> ExpRhoType -> TcM (Maybe (HsOverLit GhcTc))
shortCutLit :: Platform -> OverLitVal -> TcType -> Maybe (HsExpr GhcTc)
hsOverLitName :: OverLitVal -> Name

-- | Returns the type of the whole pattern
conLikeResTy :: ConLike -> [Type] -> Type
type TcId = Id
type TcIdSet = IdSet
zonkTopDecls :: Bag EvBind -> LHsBinds GhcTc -> [LRuleDecl GhcTc] -> [LTcSpecPrag] -> [LForeignDecl GhcTc] -> TcM (TypeEnv, Bag EvBind, LHsBinds GhcTc, [LForeignDecl GhcTc], [LTcSpecPrag], [LRuleDecl GhcTc])
zonkTopExpr :: HsExpr GhcTc -> TcM (HsExpr GhcTc)
zonkTopLExpr :: LHsExpr GhcTc -> TcM (LHsExpr GhcTc)
zonkTopBndrs :: [TcId] -> TcM [Id]

-- | See Note [The ZonkEnv] Confused by zonking? See Note [What is
--   zonking?] in <a>GHC.Tc.Utils.TcMType</a>.
data ZonkEnv
data ZonkFlexi
DefaultFlexi :: ZonkFlexi
SkolemiseFlexi :: ZonkFlexi
RuntimeUnkFlexi :: ZonkFlexi
NoFlexi :: ZonkFlexi
emptyZonkEnv :: TcM ZonkEnv
mkEmptyZonkEnv :: ZonkFlexi -> TcM ZonkEnv
initZonkEnv :: (ZonkEnv -> TcM b) -> TcM b
zonkTyVarBindersX :: ZonkEnv -> [VarBndr TcTyVar vis] -> TcM (ZonkEnv, [VarBndr TyVar vis])
zonkTyVarBinderX :: ZonkEnv -> VarBndr TcTyVar vis -> TcM (ZonkEnv, VarBndr TyVar vis)
zonkTyBndrs :: [TcTyVar] -> TcM (ZonkEnv, [TyVar])
zonkTyBndrsX :: ZonkEnv -> [TcTyVar] -> TcM (ZonkEnv, [TyVar])
zonkTcTypeToType :: TcType -> TcM Type
zonkTcTypeToTypeX :: ZonkEnv -> TcType -> TcM Type
zonkTcTypesToTypesX :: ZonkEnv -> [TcType] -> TcM [Type]
zonkScaledTcTypesToTypesX :: ZonkEnv -> [Scaled TcType] -> TcM [Scaled Type]
zonkTyVarOcc :: HasDebugCallStack => ZonkEnv -> TcTyVar -> TcM Type
zonkCoToCo :: ZonkEnv -> Coercion -> TcM Coercion
zonkEvBinds :: ZonkEnv -> Bag EvBind -> TcM (ZonkEnv, Bag EvBind)
zonkTcEvBinds :: ZonkEnv -> TcEvBinds -> TcM (ZonkEnv, TcEvBinds)
zonkTcMethInfoToMethInfoX :: ZonkEnv -> TcMethInfo -> TcM MethInfo
lookupTyVarX :: ZonkEnv -> TcTyVar -> TyVar
instance GHC.Utils.Outputable.Outputable GHC.Tc.Utils.Zonk.ZonkEnv

module GHC.Tc.Utils.Instantiate
topSkolemise :: SkolemInfo -> TcSigmaType -> TcM (HsWrapper, [(Name, TyVar)], [EvVar], TcRhoType)
topInstantiate :: CtOrigin -> TcSigmaType -> TcM (HsWrapper, TcRhoType)
instantiateSigma :: CtOrigin -> [TyVar] -> TcThetaType -> TcSigmaType -> TcM ([TcTyVar], HsWrapper, TcSigmaType)
instCall :: CtOrigin -> [TcType] -> TcThetaType -> TcM HsWrapper
instDFunType :: DFunId -> [DFunInstType] -> TcM ([TcType], TcThetaType)
instStupidTheta :: CtOrigin -> TcThetaType -> TcM ()
instTyVarsWith :: CtOrigin -> [TyVar] -> [TcType] -> TcM Subst

-- | Create a new Wanted constraint with the given <a>CtOrigin</a>, and
--   location information taken from the <a>TcM</a> environment.
newWanted :: CtOrigin -> Maybe TypeOrKind -> PredType -> TcM CtEvidence

-- | Create new Wanted constraints with the given <a>CtOrigin</a>, and
--   location information taken from the <a>TcM</a> environment.
newWanteds :: CtOrigin -> ThetaType -> TcM [CtEvidence]
tcInstType :: ([TyVar] -> TcM (Subst, [TcTyVar])) -> Id -> TcM ([(Name, TcTyVar)], TcThetaType, TcType)
tcInstTypeBndrs :: Type -> TcM ([(Name, InvisTVBinder)], TcThetaType, TcType)
tcSkolemiseInvisibleBndrs :: SkolemInfoAnon -> Type -> TcM ([TcTyVar], TcType)

-- | Given a list of <tt>[<a>TyVar</a>]</tt>, skolemize the type variables,
--   returning a substitution mapping the original tyvars to the skolems,
--   and the list of newly bound skolems.
tcInstSkolTyVars :: SkolemInfo -> [TyVar] -> TcM (Subst, [TcTyVar])
tcInstSkolTyVarsX :: SkolemInfo -> Subst -> [TyVar] -> TcM (Subst, [TcTyVar])
tcSkolDFunType :: Type -> TcM (SkolemInfoAnon, [TcTyVar], TcThetaType, Class, [TcType])
tcSuperSkolTyVars :: TcLevel -> SkolemInfo -> [TyVar] -> (Subst, [TcTyVar])
tcInstSuperSkolTyVarsX :: SkolemInfo -> Subst -> [TyVar] -> TcM (Subst, [TcTyVar])

-- | Give fresh uniques to a bunch of TyVars, but they stay as TyVars,
--   rather than becoming TcTyVars Used in <a>newFamInst</a>, and
--   <a>newClsInst</a>
freshenTyVarBndrs :: [TyVar] -> TcM (Subst, [TyVar])

-- | Give fresh uniques to a bunch of CoVars Used in
--   "GHC.Tc.Instance.Family.newFamInst"
freshenCoVarBndrsX :: Subst -> [CoVar] -> TcM (Subst, [CoVar])
tcInstInvisibleTyBindersN :: Int -> TcKind -> TcM ([TcType], TcKind)

-- | Given ty::forall k1 k2. k, instantiate all the invisible
--   forall-binders returning ty <tt>kk1 </tt>kk2 :: k[kk1<i>k1, kk2</i>k1]
--   Called only to instantiate kinds, in user-written type signatures
tcInstInvisibleTyBinders :: TcType -> TcKind -> TcM (TcType, TcKind)
tcInstInvisibleTyBinder :: Subst -> PiTyVarBinder -> TcM (Subst, TcType)
newOverloadedLit :: HsOverLit GhcRn -> ExpRhoType -> TcM (HsOverLit GhcTc)
mkOverLit :: OverLitVal -> TcM (HsLit GhcTc)
newClsInst :: Maybe OverlapMode -> Name -> [TyVar] -> ThetaType -> Class -> [Type] -> TcM ClsInst
tcGetInsts :: TcM [ClsInst]
tcGetInstEnvs :: TcM InstEnvs
getOverlapFlag :: Maybe OverlapMode -> TcM OverlapFlag
tcExtendLocalInstEnv :: [ClsInst] -> TcM a -> TcM a
instCallConstraints :: CtOrigin -> TcThetaType -> TcM HsWrapper

-- | Used when <a>Name</a> is the wired-in name for a wired-in class
--   method, so the caller knows its type for sure, which should be of form
--   
--   <pre>
--   forall a. C a =&gt; &lt;blah&gt;
--   </pre>
--   
--   <a>newMethodFromName</a> is supposed to instantiate just the outer
--   type variable and constraint
newMethodFromName :: CtOrigin -> Name -> [TcRhoType] -> TcM (HsExpr GhcTc)
tcSyntaxName :: CtOrigin -> TcType -> (Name, HsExpr GhcRn) -> TcM (Name, HsExpr GhcTc)

-- | Returns free variables of WantedConstraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfWC :: WantedConstraints -> TyCoVarSet

-- | Returns free variables of constraints as a non-deterministic set
tyCoVarsOfCt :: Ct -> TcTyCoVarSet

-- | Returns free variables of a bag of constraints as a non-deterministic
--   set. See Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfCts :: Cts -> TcTyCoVarSet


-- | Type subsumption and unification
module GHC.Tc.Utils.Unify
tcWrapResult :: HsExpr GhcRn -> HsExpr GhcTc -> TcSigmaType -> ExpRhoType -> TcM (HsExpr GhcTc)
tcWrapResultO :: CtOrigin -> HsExpr GhcRn -> HsExpr GhcTc -> TcSigmaType -> ExpRhoType -> TcM (HsExpr GhcTc)
tcWrapResultMono :: HsExpr GhcRn -> HsExpr GhcTc -> TcRhoType -> ExpRhoType -> TcM (HsExpr GhcTc)
tcTopSkolemise :: UserTypeCtxt -> TcSigmaType -> (TcType -> TcM result) -> TcM (HsWrapper, result)
tcSkolemiseScoped :: UserTypeCtxt -> TcSigmaType -> (TcType -> TcM result) -> TcM (HsWrapper, result)

-- | Variant of <a>tcTopSkolemise</a> that takes an ExpType
tcSkolemiseExpType :: UserTypeCtxt -> ExpSigmaType -> (ExpRhoType -> TcM result) -> TcM (HsWrapper, result)
tcSubType :: CtOrigin -> UserTypeCtxt -> TcSigmaType -> ExpRhoType -> TcM HsWrapper
tcSubTypeSigma :: CtOrigin -> UserTypeCtxt -> TcSigmaType -> TcSigmaType -> TcM HsWrapper
tcSubTypePat :: CtOrigin -> UserTypeCtxt -> ExpSigmaType -> TcSigmaType -> TcM HsWrapper
tcSubTypeDS :: HsExpr GhcRn -> TcRhoType -> ExpRhoType -> TcM HsWrapper
tcSubTypeAmbiguity :: UserTypeCtxt -> TcSigmaType -> TcSigmaType -> TcM HsWrapper
tcSubMult :: CtOrigin -> Mult -> Mult -> TcM HsWrapper
checkConstraints :: SkolemInfoAnon -> [TcTyVar] -> [EvVar] -> TcM result -> TcM (TcEvBinds, result)
checkTvConstraints :: SkolemInfo -> [TcTyVar] -> TcM result -> TcM result
buildImplicationFor :: TcLevel -> SkolemInfoAnon -> [TcTyVar] -> [EvVar] -> WantedConstraints -> TcM (Bag Implication, TcEvBinds)
buildTvImplication :: SkolemInfoAnon -> [TcTyVar] -> TcLevel -> WantedConstraints -> TcM Implication
emitResidualTvConstraint :: SkolemInfo -> [TcTyVar] -> TcLevel -> WantedConstraints -> TcM ()
unifyType :: Maybe TypedThing -> TcTauType -> TcTauType -> TcM TcCoercionN
unifyKind :: Maybe TypedThing -> TcKind -> TcKind -> TcM CoercionN
unifyExpectedType :: HsExpr GhcRn -> TcRhoType -> ExpRhoType -> TcM TcCoercionN
uType :: TypeOrKind -> CtOrigin -> TcType -> TcType -> TcM CoercionN
promoteTcType :: TcLevel -> TcType -> TcM (TcCoercionN, TcType)
swapOverTyVars :: Bool -> TcTyVar -> TcTyVar -> Bool

-- | Checks (TYVAR-TV), (COERCION-HOLE) and (CONCRETE) of Note [Unification
--   preconditions]; returns True if these conditions are satisfied. But
--   see the Note for other preconditions, too.
startSolvingByUnification :: MetaInfo -> TcType -> TcM (Maybe TcType)

-- | Infer a type using a fresh ExpType See also Note [ExpType] in
--   <a>GHC.Tc.Utils.TcMType</a>
--   
--   Use <a>tcInferFRR</a> if you require the type to have a fixed runtime
--   representation.
tcInfer :: (ExpSigmaType -> TcM a) -> TcM (a, TcSigmaType)
matchExpectedListTy :: TcRhoType -> TcM (TcCoercionN, TcRhoType)
matchExpectedTyConApp :: TyCon -> TcRhoType -> TcM (TcCoercionN, [TcSigmaType])
matchExpectedAppTy :: TcRhoType -> TcM (TcCoercion, (TcSigmaType, TcSigmaType))

-- | Use this function to split off arguments types when you have an
--   "expected" type.
--   
--   This function skolemises at each polytype.
--   
--   Invariant: this function only applies the provided function to a list
--   of argument types which all have a syntactically fixed RuntimeRep in
--   the sense of Note [Fixed RuntimeRep] in GHC.Tc.Utils.Concrete. See
--   Note [Return arguments with a fixed RuntimeRep].
matchExpectedFunTys :: forall a. ExpectedFunTyOrigin -> UserTypeCtxt -> Arity -> ExpRhoType -> ([Scaled ExpSigmaTypeFRR] -> ExpRhoType -> TcM a) -> TcM (HsWrapper, a)

-- | Breaks apart a function kind into its pieces.
matchExpectedFunKind :: TypedThing -> Arity -> TcKind -> TcM Coercion

-- | <a>matchActualFunTySigma</a> looks for just one function arrow,
--   returning an uninstantiated sigma-type.
--   
--   Invariant: the returned argument type has a syntactically fixed
--   RuntimeRep in the sense of Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete.
--   
--   See Note [Return arguments with a fixed RuntimeRep].
matchActualFunTySigma :: ExpectedFunTyOrigin -> Maybe TypedThing -> (Arity, [Scaled TcSigmaType]) -> TcRhoType -> TcM (HsWrapper, Scaled TcSigmaTypeFRR, TcSigmaType)

-- | Like <a>matchExpectedFunTys</a>, but used when you have an "actual"
--   type, for example in function application.
--   
--   INVARIANT: the returned argument types all have a syntactically fixed
--   RuntimeRep in the sense of Note [Fixed RuntimeRep] in
--   GHC.Tc.Utils.Concrete. See Note [Return arguments with a fixed
--   RuntimeRep].
matchActualFunTysRho :: ExpectedFunTyOrigin -> CtOrigin -> Maybe TypedThing -> Arity -> TcSigmaType -> TcM (HsWrapper, [Scaled TcSigmaTypeFRR], TcRhoType)
checkTyVarEq :: TcTyVar -> TcType -> CheckTyEqResult
checkTyFamEq :: TyCon -> [TcType] -> TcType -> CheckTyEqResult
checkTypeEq :: CanEqLHS -> TcType -> CheckTyEqResult

module GHC.Tc.Instance.Typeable

-- | Generate the Typeable bindings for a module. This is the only
--   entry-point of this module and is invoked by the typechecker driver in
--   <tt>tcRnSrcDecls</tt>.
--   
--   See Note [Grand plan for Typeable] in <a>GHC.Tc.Instance.Typeable</a>.
mkTypeableBinds :: TcM TcGblEnv

-- | Is a particular <a>TyCon</a> representable by <tt>Typeable</tt>?.
--   These exclude type families and polytypes.
tyConIsTypeable :: TyCon -> Bool
instance GHC.Base.Monad GHC.Tc.Instance.Typeable.KindRepM
instance GHC.Base.Applicative GHC.Tc.Instance.Typeable.KindRepM
instance GHC.Base.Functor GHC.Tc.Instance.Typeable.KindRepM

module GHC.Runtime.Heap.Inspect

-- | Term reconstruction
--   
--   Given a pointer to a heap object (<a>HValue</a>) and its type, build a
--   <a>Term</a> representation of the object. Subterms (objects in the
--   payload) are also built up to the given <tt>max_depth</tt>. After
--   <tt>max_depth</tt> any subterms will appear as <a>Suspension</a>s. Any
--   thunks found while traversing the object will be forced based on
--   <tt>force</tt> parameter.
--   
--   Types of terms will be refined based on constructors we find during
--   term reconstruction. See <a>cvReconstructType</a> for an overview of
--   how type reconstruction works.
cvObtainTerm :: HscEnv -> Int -> Bool -> RttiType -> ForeignHValue -> IO Term

-- | Fast, breadth-first Type reconstruction
--   
--   Given a heap object (<a>HValue</a>) and its (possibly polymorphic)
--   type (usually obtained in GHCi), try to reconstruct a more monomorphic
--   type of the object. This is used for improving type information in
--   debugger. For example, if we have a polymorphic function:
--   
--   sumNumList :: Num a =&gt; [a] -&gt; a sumNumList [] = 0 sumNumList (x
--   : xs) = x + sumList xs
--   
--   and add a breakpoint to it:
--   
--   ghci&gt; break sumNumList ghci&gt; sumNumList ([0 .. 9] :: [Int])
--   
--   ghci shows us more precise types than just <tt>a</tt>s:
--   
--   Stopped in Main.sumNumList, debugger.hs:3:23-39 _result :: Int = _ x
--   :: Int = 0 xs :: [Int] = _
cvReconstructType :: HscEnv -> Int -> GhciType -> ForeignHValue -> IO (Maybe Type)
improveRTTIType :: HscEnv -> RttiType -> RttiType -> Maybe Subst
data Term
Term :: RttiType -> Either String DataCon -> ForeignHValue -> [Term] -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[val] :: Term -> ForeignHValue
[subTerms] :: Term -> [Term]
Prim :: RttiType -> [Word] -> Term
[ty] :: Term -> RttiType
[valRaw] :: Term -> [Word]
Suspension :: ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> Term
[ctype] :: Term -> ClosureType
[ty] :: Term -> RttiType
[val] :: Term -> ForeignHValue
[bound_to] :: Term -> Maybe Name
NewtypeWrap :: RttiType -> Either String DataCon -> Term -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[wrapped_term] :: Term -> Term
RefWrap :: RttiType -> Term -> Term
[ty] :: Term -> RttiType
[wrapped_term] :: Term -> Term
isFullyEvaluatedTerm :: Term -> Bool
termType :: Term -> RttiType
mapTermType :: (RttiType -> Type) -> Term -> Term
termTyCoVars :: Term -> TyCoVarSet
foldTerm :: TermFold a -> Term -> a
data TermFold a
TermFold :: TermProcessor a a -> (RttiType -> [Word] -> a) -> (ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> a) -> (RttiType -> Either String DataCon -> a -> a) -> (RttiType -> a -> a) -> TermFold a
[fTerm] :: TermFold a -> TermProcessor a a
[fPrim] :: TermFold a -> RttiType -> [Word] -> a
[fSuspension] :: TermFold a -> ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> a
[fNewtypeWrap] :: TermFold a -> RttiType -> Either String DataCon -> a -> a
[fRefWrap] :: TermFold a -> RttiType -> a -> a

-- | Takes a list of custom printers with a explicit recursion knot and a
--   term, and returns the output of the first successful printer, or the
--   default printer
cPprTerm :: Monad m => CustomTermPrinter m -> Term -> m SDoc
cPprTermBase :: forall m. Monad m => CustomTermPrinter m
constrClosToName :: HscEnv -> GenClosure a -> IO (Either String Name)
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Heap.Inspect.Term

module GHC.Rename.Utils
checkDupRdrNames :: [LocatedN RdrName] -> RnM ()
checkDupRdrNamesN :: [LocatedN RdrName] -> RnM ()
checkShadowedRdrNames :: [LocatedN RdrName] -> RnM ()
checkDupNames :: [Name] -> RnM ()
checkDupAndShadowedNames :: (GlobalRdrEnv, LocalRdrEnv) -> [Name] -> RnM ()
dupNamesErr :: Outputable n => (n -> SrcSpan) -> NonEmpty n -> RnM ()

-- | Ensure that a boxed or unboxed tuple has arity no larger than
--   <a>mAX_TUPLE_SIZE</a>.
checkTupSize :: Int -> TcM ()

-- | Ensure that a constraint tuple has arity no larger than
--   <a>mAX_CTUPLE_SIZE</a>.
checkCTupSize :: Int -> TcM ()
addFvRn :: FreeVars -> RnM (thing, FreeVars) -> RnM (thing, FreeVars)
mapFvRn :: Traversable f => (a -> RnM (b, FreeVars)) -> f a -> RnM (f b, FreeVars)
mapMaybeFvRn :: (a -> RnM (b, FreeVars)) -> Maybe a -> RnM (Maybe b, FreeVars)
warnUnusedMatches :: [Name] -> FreeVars -> RnM ()
warnUnusedTypePatterns :: [Name] -> FreeVars -> RnM ()
warnUnusedTopBinds :: [GlobalRdrElt] -> RnM ()
warnUnusedLocalBinds :: [Name] -> FreeVars -> RnM ()
warnForallIdentifier :: LocatedN RdrName -> RnM ()

-- | Checks to see if we need to warn for -Wunused-record-wildcards or
--   -Wredundant-record-wildcards
checkUnusedRecordWildcard :: SrcSpan -> FreeVars -> Maybe [Name] -> RnM ()

-- | Make a map from selector names to field labels and parent tycon names,
--   to be used when reporting unused record fields.
mkFieldEnv :: GlobalRdrEnv -> NameEnv (FieldLabelString, Parent)
badQualBndrErr :: RdrName -> TcRnMessage
typeAppErr :: String -> LHsType GhcPs -> TcRnMessage
badFieldConErr :: Name -> FieldLabelString -> TcRnMessage
wrapGenSpan :: a -> LocatedAn an a
genHsVar :: Name -> HsExpr GhcRn
genLHsVar :: Name -> LHsExpr GhcRn
genHsApp :: HsExpr GhcRn -> LHsExpr GhcRn -> HsExpr GhcRn
genHsApps :: Name -> [LHsExpr GhcRn] -> HsExpr GhcRn
genAppType :: HsExpr GhcRn -> HsType (NoGhcTc GhcRn) -> HsExpr GhcRn
genHsIntegralLit :: IntegralLit -> LocatedAn an (HsExpr GhcRn)
genHsTyLit :: FastString -> HsType GhcRn
genSimpleConPat :: Name -> [LPat GhcRn] -> LPat GhcRn
genVarPat :: Name -> LPat GhcRn
genWildPat :: LPat GhcRn
genSimpleFunBind :: Name -> [LPat GhcRn] -> LHsExpr GhcRn -> LHsBind GhcRn
genFunBind :: LocatedN Name -> [LMatch GhcRn (LHsExpr GhcRn)] -> HsBind GhcRn
newLocalBndrRn :: LocatedN RdrName -> RnM Name
newLocalBndrsRn :: [LocatedN RdrName] -> RnM [Name]
bindLocalNames :: [Name] -> RnM a -> RnM a
bindLocalNamesFV :: [Name] -> RnM (a, FreeVars) -> RnM (a, FreeVars)
addNameClashErrRn :: RdrName -> NonEmpty GlobalRdrElt -> RnM ()

-- | Throw an error message if a user attempts to quantify an inferred type
--   variable in a place where specificity cannot be observed. For example,
--   <tt>forall {a}. [a] -&gt; [a]</tt> would be rejected to the inferred
--   type variable <tt>{a}</tt>, but <tt>forall a. [a] -&gt; [a]</tt> would
--   be accepted. See <tt>Note [Unobservably inferred type variables]</tt>.
checkInferredVars :: HsDocContext -> Maybe SDoc -> LHsSigType GhcPs -> RnM ()

-- | Examines a non-outermost type for <tt>forall</tt>s or contexts, which
--   are assumed to be nested. For example, in the following declaration:
--   
--   <pre>
--   instance forall a. forall b. C (Either a b)
--   </pre>
--   
--   The outermost <tt>forall a</tt> is fine, but the nested <tt>forall
--   b</tt> is not. We invoke <a>noNestedForallsContextsErr</a> on the type
--   <tt>forall b. C (Either a b)</tt> to catch the nested <tt>forall</tt>
--   and create a suitable error message. <a>noNestedForallsContextsErr</a>
--   returns <tt><a>Just</a> err_msg</tt> if such a <tt>forall</tt> or
--   context is found, and returns <tt>Nothing</tt> otherwise.
--   
--   This is currently used in the following places:
--   
--   <ul>
--   <li>In GADT constructor types (in <tt>rnConDecl</tt>). See <tt>Note
--   [GADT abstract syntax] (Wrinkle: No nested foralls or contexts)</tt>
--   in <a>GHC.Hs.Type</a>.</li>
--   <li>In instance declaration types (in <tt>rnClsIntDecl</tt> and
--   <tt>rnSrcDerivDecl</tt> in <a>GHC.Rename.Module</a> and
--   <tt>renameSig</tt> in <a>GHC.Rename.Bind</a>). See <tt>Note [No nested
--   foralls or contexts in instance types]</tt> in
--   <a>GHC.Hs.Type</a>.</li>
--   </ul>
noNestedForallsContextsErr :: SDoc -> LHsType GhcRn -> Maybe (SrcSpan, TcRnMessage)

-- | A common way to invoke <a>noNestedForallsContextsErr</a>.
addNoNestedForallsContextsErr :: HsDocContext -> SDoc -> LHsType GhcRn -> RnM ()


-- | This module is not used by GHC itself. Rather, it exports all of the
--   functions and types you are likely to need when writing a plugin for
--   GHC. So authors of plugins can probably get away simply with saying
--   "import GHC.Plugins".
--   
--   Particularly interesting modules for plugin writers include
--   <a>GHC.Core</a> and <a>GHC.Core.Opt.Monad</a>.
module GHC.Plugins
data NameSpace

-- | Occurrence Name
--   
--   In this context that means: "classified (i.e. as a type name, value
--   name, etc) but not qualified and not yet resolved"
data OccName

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a

-- | Other names in the compiler add additional information to an OccName.
--   This class provides a consistent way to access the underlying OccName.
class HasOccName name
occName :: HasOccName name => name -> OccName
data OccEnv a
type OccSet = UniqSet OccName
type TidyOccEnv = UniqFM FastString Int
mkOccName :: NameSpace -> String -> OccName

-- | Test if the <a>OccName</a> is that for any operator (whether it is a
--   data constructor or variable or whatever)
isSymOcc :: OccName -> Bool
tcName :: NameSpace
clsName :: NameSpace
dataName :: NameSpace
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
emptyFsEnv :: FastStringEnv a
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
tcClsName :: NameSpace
tvName :: NameSpace
mkVarOccFS :: FastString -> OccName
occNameString :: OccName -> String
pprNameSpace :: NameSpace -> SDoc
isValNameSpace :: NameSpace -> Bool
srcDataName :: NameSpace
pprNonVarNameSpace :: NameSpace -> SDoc
pprNameSpaceBrief :: IsLine doc => NameSpace -> doc
pprOccName :: IsLine doc => OccName -> doc
mkOccNameFS :: NameSpace -> FastString -> OccName
mkVarOcc :: String -> OccName
mkDataOcc :: String -> OccName
mkDataOccFS :: FastString -> OccName
mkTyVarOcc :: String -> OccName
mkTyVarOccFS :: FastString -> OccName
mkTcOcc :: String -> OccName
mkTcOccFS :: FastString -> OccName
mkClsOcc :: String -> OccName
mkClsOccFS :: FastString -> OccName
mkDFunOcc :: String -> Bool -> OccSet -> OccName
setOccNameSpace :: NameSpace -> OccName -> OccName
demoteOccName :: OccName -> Maybe OccName
promoteOccName :: OccName -> Maybe OccName

-- | Test for definitions internally generated by GHC. This predicate is
--   used to suppress printing of internal definitions in some debug prints
isDerivedOccName :: OccName -> Bool
mkDataConWrapperOcc :: OccName -> OccName
mkWorkerOcc :: OccName -> OccName
mkMatcherOcc :: OccName -> OccName
mkBuilderOcc :: OccName -> OccName
mkDefaultMethodOcc :: OccName -> OccName
isDefaultMethodOcc :: OccName -> Bool

-- | Is an <a>OccName</a> one of a Typeable <tt>TyCon</tt> or
--   <tt>Module</tt> binding? This is needed as these bindings are renamed
--   differently. See Note [Grand plan for Typeable] in
--   <a>GHC.Tc.Instance.Typeable</a>.
isTypeableBindOcc :: OccName -> Bool
mkNewTyCoOcc :: OccName -> OccName
mkClassOpAuxOcc :: OccName -> OccName
mkCon2TagOcc :: OccName -> OccName
mkTag2ConOcc :: OccName -> OccName
mkMaxTagOcc :: OccName -> OccName
mkClassDataConOcc :: OccName -> OccName
mkDictOcc :: OccName -> OccName
mkIPOcc :: OccName -> OccName
mkSpecOcc :: OccName -> OccName
mkForeignExportOcc :: OccName -> OccName
mkRepEqOcc :: OccName -> OccName
mkGenR :: OccName -> OccName
mkGen1R :: OccName -> OccName
mkDataTOcc :: OccName -> OccName
mkDataCOcc :: OccName -> OccName
mkDataConWorkerOcc :: OccName -> OccName
mkSuperDictSelOcc :: Int -> OccName -> OccName
mkSuperDictAuxOcc :: Int -> OccName -> OccName
mkLocalOcc :: Unique -> OccName -> OccName
mkMethodOcc :: OccName -> OccName

-- | Derive a name for the representation type constructor of a
--   <tt>data</tt>/<tt>newtype</tt> instance.
mkInstTyTcOcc :: String -> OccSet -> OccName
mkInstTyCoOcc :: OccName -> OccName
mkEqPredCoOcc :: OccName -> OccName
mkRecFldSelOcc :: FastString -> OccName
mkTyConRepOcc :: OccName -> OccName
isVarOcc :: OccName -> Bool
isTvOcc :: OccName -> Bool
isTcOcc :: OccName -> Bool
isDataOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is a data constructor that starts with a
--   symbol (e.g. <tt>:</tt>, or <tt>[]</tt>)
isDataSymOcc :: OccName -> Bool

-- | <i>Value</i> <tt>OccNames</tt>s are those that are either in the
--   variable or data constructor namespaces
isValOcc :: OccName -> Bool

-- | Wrap parens around an operator
parenSymOcc :: OccName -> SDoc -> SDoc

-- | Haskell 98 encourages compilers to suppress warnings about unused
--   names in a pattern if they start with <tt>_</tt>: this implements that
--   test
startsWithUnderscore :: OccName -> Bool
isTcClsNameSpace :: NameSpace -> Bool
isTvNameSpace :: NameSpace -> Bool
isDataConNameSpace :: NameSpace -> Bool
isVarNameSpace :: NameSpace -> Bool
emptyOccEnv :: OccEnv a
unitOccEnv :: OccName -> a -> OccEnv a
extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
mapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b
lookupOccEnv :: OccEnv a -> OccName -> Maybe a
mkOccEnv :: [(OccName, a)] -> OccEnv a
mkOccEnv_C :: (a -> a -> a) -> [(OccName, a)] -> OccEnv a
extendOccEnvList :: OccEnv a -> [(OccName, a)] -> OccEnv a
elemOccEnv :: OccName -> OccEnv a -> Bool
nonDetOccEnvElts :: OccEnv a -> [a]
foldOccEnv :: (a -> b -> b) -> b -> OccEnv a -> b
plusOccEnv :: OccEnv a -> OccEnv a -> OccEnv a
plusOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccEnv a -> OccEnv a
extendOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccName -> a -> OccEnv a
extendOccEnv_Acc :: (a -> b -> b) -> (a -> b) -> OccEnv b -> OccName -> a -> OccEnv b
filterOccEnv :: (elt -> Bool) -> OccEnv elt -> OccEnv elt
delListFromOccEnv :: OccEnv a -> [OccName] -> OccEnv a
delFromOccEnv :: OccEnv a -> OccName -> OccEnv a
alterOccEnv :: (Maybe elt -> Maybe elt) -> OccEnv elt -> OccName -> OccEnv elt
minusOccEnv :: OccEnv a -> OccEnv b -> OccEnv a

-- | Alters (replaces or removes) those elements of the map that are
--   mentioned in the second map
minusOccEnv_C :: (a -> b -> Maybe a) -> OccEnv a -> OccEnv b -> OccEnv a
pprOccEnv :: (a -> SDoc) -> OccEnv a -> SDoc
emptyOccSet :: OccSet
unitOccSet :: OccName -> OccSet
mkOccSet :: [OccName] -> OccSet
extendOccSet :: OccSet -> OccName -> OccSet
extendOccSetList :: OccSet -> [OccName] -> OccSet
unionOccSets :: OccSet -> OccSet -> OccSet
unionManyOccSets :: [OccSet] -> OccSet
minusOccSet :: OccSet -> OccSet -> OccSet
elemOccSet :: OccName -> OccSet -> Bool
isEmptyOccSet :: OccSet -> Bool
intersectOccSet :: OccSet -> OccSet -> OccSet
filterOccSet :: (OccName -> Bool) -> OccSet -> OccSet

-- | Converts an OccSet to an OccEnv (operationally the identity)
occSetToEnv :: OccSet -> OccEnv OccName
emptyTidyOccEnv :: TidyOccEnv
initTidyOccEnv :: [OccName] -> TidyOccEnv
tidyOccName :: TidyOccEnv -> OccName -> (TidyOccEnv, OccName)
avoidClashesOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
delTidyOccEnvList :: TidyOccEnv -> [FastString] -> TidyOccEnv

-- | A unique, unambiguous name for something, containing information about
--   where that thing originated.
data Name
data NameSpace

-- | Occurrence Name
--   
--   In this context that means: "classified (i.e. as a type name, value
--   name, etc) but not qualified and not yet resolved"
data OccName

-- | A class allowing convenient access to the <a>Name</a> of various
--   datatypes
class NamedThing a
getOccName :: NamedThing a => a -> OccName
getName :: NamedThing a => a -> Name

-- | BuiltInSyntax is for things like <tt>(:)</tt>, <tt>[]</tt> and tuples,
--   which have special syntactic forms. They aren't in scope as such.
data BuiltInSyntax
BuiltInSyntax :: BuiltInSyntax
UserSyntax :: BuiltInSyntax

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in <a>GHC.Types.Unique.DFM</a> for explanation why it's not
--   deterministic and why it matters. Use DFastStringEnv if the set
--   eventually gets converted into a list or folded over in a way where
--   the order changes the generated code.
type FastStringEnv a = UniqFM FastString a

-- | Other names in the compiler add additional information to an OccName.
--   This class provides a consistent way to access the underlying OccName.
class HasOccName name
occName :: HasOccName name => name -> OccName
data OccEnv a
type OccSet = UniqSet OccName
type TidyOccEnv = UniqFM FastString Int
mkOccName :: NameSpace -> String -> OccName
nameModule :: HasDebugCallStack => Name -> Module
pprName :: forall doc. IsLine doc => Name -> doc

-- | Test if the <a>OccName</a> is that for any operator (whether it is a
--   data constructor or variable or whatever)
isSymOcc :: OccName -> Bool
isExternalName :: Name -> Bool
nameSrcSpan :: Name -> SrcSpan
tcName :: NameSpace
clsName :: NameSpace
dataName :: NameSpace
nameOccName :: Name -> OccName
mkSystemVarName :: Unique -> FastString -> Name
getOccFS :: NamedThing a => a -> FastString
pprInfixName :: (Outputable a, NamedThing a) => a -> SDoc
pprPrefixName :: NamedThing a => a -> SDoc

-- | Returns True if the name is (a) Internal (b) External but from the
--   specified module (c) External but from the <tt>interactive</tt>
--   package
--   
--   The key idea is that False means: the entity is defined in some other
--   module you can find the details (type, fixity, instances) in some
--   interface file those details will be stored in the EPT or HPT
--   
--   True means: the entity is defined in this module or earlier in the
--   GHCi session you can find details (type, fixity, instances) in the
--   TcGblEnv or TcLclEnv
--   
--   The isInteractiveModule part is because successive interactions of a
--   GHCi session each give rise to a fresh module (Ghci1, Ghci2, etc), but
--   they all come from the magic <tt>interactive</tt> package; and all the
--   details are kept in the TcLclEnv, TcGblEnv, NOT in the HPT or EPT. See
--   Note [The interactive package] in <a>GHC.Runtime.Context</a>
nameIsLocalOrFrom :: Module -> Name -> Bool
tidyNameOcc :: Name -> OccName -> Name
mkSysTvName :: Unique -> FastString -> Name
nameModule_maybe :: Name -> Maybe Module
isInternalName :: Name -> Bool
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
emptyFsEnv :: FastStringEnv a
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
nameUnique :: Name -> Unique
tcClsName :: NameSpace
tvName :: NameSpace
mkVarOccFS :: FastString -> OccName
occNameString :: OccName -> String
getSrcLoc :: NamedThing a => a -> SrcLoc

-- | Will the <a>Name</a> come from a dynamically linked package?
isDynLinkName :: Platform -> Module -> Name -> Bool
getSrcSpan :: NamedThing a => a -> SrcSpan
pprDefinedAt :: Name -> SDoc
isSystemName :: Name -> Bool
pprNameSpace :: NameSpace -> SDoc
isValNameSpace :: NameSpace -> Bool

-- | Create a name brought into being by the compiler
mkSystemName :: Unique -> OccName -> Name
mkSystemNameAt :: Unique -> OccName -> SrcSpan -> Name

-- | Create a name which is (for now at least) local to the current module
--   and hence does not need a <a>GenModule</a> to disambiguate it from
--   other <a>Name</a>s
mkInternalName :: Unique -> OccName -> SrcSpan -> Name
mkClonedInternalName :: Unique -> Name -> Name
mkDerivedInternalName :: (OccName -> OccName) -> Unique -> Name -> Name

-- | Make a name for a foreign call
mkFCallName :: Unique -> FastString -> Name

-- | Create a name which definitely originates in the given module
mkExternalName :: Unique -> Module -> OccName -> SrcSpan -> Name

-- | Create a name which is actually defined by the compiler itself
mkWiredInName :: Module -> OccName -> Unique -> TyThing -> BuiltInSyntax -> Name
setNameUnique :: Name -> Unique -> Name
nameNameSpace :: Name -> NameSpace
setNameLoc :: Name -> SrcSpan -> Name

-- | Make the <a>Name</a> into an internal name, regardless of what it was
--   to begin with
localiseName :: Name -> Name
namePun_maybe :: Name -> Maybe FastString
nameSrcLoc :: Name -> SrcLoc
pprNameDefnLoc :: Name -> SDoc

-- | Print fully qualified name (with unit-id, module and unique)
pprFullName :: Module -> Name -> SDoc

-- | Print a ticky ticky styled name
--   
--   Module argument is the module to use for internal and system names.
--   When printing the name in a ticky profile, the module name is included
--   even for local things. However, ticky uses the format "x (M)" rather
--   than "M.x". Hence, this function provides a separation from normal
--   styling.
pprTickyName :: Module -> Name -> SDoc
isTyVarName :: Name -> Bool
isTyConName :: Name -> Bool
isDataConName :: Name -> Bool
isValName :: Name -> Bool
isVarName :: Name -> Bool
isWiredInName :: Name -> Bool
isWiredIn :: NamedThing thing => thing -> Bool
isBuiltInSyntax :: Name -> Bool
isHoleName :: Name -> Bool
wiredInNameTyThing_maybe :: Name -> Maybe TyThing

-- | Returns True if the name is external or from the <tt>interactive</tt>
--   package See documentation of <a>nameIsLocalOrFrom</a> function
nameIsExternalOrFrom :: Module -> Name -> Bool
nameIsHomePackage :: Module -> Name -> Bool
nameIsHomePackageImport :: Module -> Name -> Bool

-- | Returns True if the Name comes from some other package: neither this
--   package nor the interactive package.
nameIsFromExternalPackage :: HomeUnit -> Name -> Bool

-- | Compare Names lexicographically This only works for Names that
--   originate in the source code or have been tidied.
stableNameCmp :: Name -> Name -> Ordering
getOccString :: NamedThing a => a -> String
pprModulePrefix :: IsLine doc => PprStyle -> Module -> OccName -> doc

-- | Print the string of Name unqualifiedly directly.
pprNameUnqualified :: Name -> SDoc

-- | Get a string representation of a <a>Name</a> that's unique and stable
--   across recompilations. Used for deterministic generation of binds for
--   derived instances. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal$String"
nameStableString :: Name -> String
srcDataName :: NameSpace
pprNonVarNameSpace :: NameSpace -> SDoc
pprNameSpaceBrief :: IsLine doc => NameSpace -> doc
pprOccName :: IsLine doc => OccName -> doc
mkOccNameFS :: NameSpace -> FastString -> OccName
mkVarOcc :: String -> OccName
mkDataOcc :: String -> OccName
mkDataOccFS :: FastString -> OccName
mkTyVarOcc :: String -> OccName
mkTyVarOccFS :: FastString -> OccName
mkTcOcc :: String -> OccName
mkTcOccFS :: FastString -> OccName
mkClsOcc :: String -> OccName
mkClsOccFS :: FastString -> OccName
mkDFunOcc :: String -> Bool -> OccSet -> OccName
setOccNameSpace :: NameSpace -> OccName -> OccName
demoteOccName :: OccName -> Maybe OccName
promoteOccName :: OccName -> Maybe OccName

-- | Test for definitions internally generated by GHC. This predicate is
--   used to suppress printing of internal definitions in some debug prints
isDerivedOccName :: OccName -> Bool
mkDataConWrapperOcc :: OccName -> OccName
mkWorkerOcc :: OccName -> OccName
mkMatcherOcc :: OccName -> OccName
mkBuilderOcc :: OccName -> OccName
mkDefaultMethodOcc :: OccName -> OccName
isDefaultMethodOcc :: OccName -> Bool

-- | Is an <a>OccName</a> one of a Typeable <tt>TyCon</tt> or
--   <tt>Module</tt> binding? This is needed as these bindings are renamed
--   differently. See Note [Grand plan for Typeable] in
--   <a>GHC.Tc.Instance.Typeable</a>.
isTypeableBindOcc :: OccName -> Bool
mkNewTyCoOcc :: OccName -> OccName
mkClassOpAuxOcc :: OccName -> OccName
mkCon2TagOcc :: OccName -> OccName
mkTag2ConOcc :: OccName -> OccName
mkMaxTagOcc :: OccName -> OccName
mkClassDataConOcc :: OccName -> OccName
mkDictOcc :: OccName -> OccName
mkIPOcc :: OccName -> OccName
mkSpecOcc :: OccName -> OccName
mkForeignExportOcc :: OccName -> OccName
mkRepEqOcc :: OccName -> OccName
mkGenR :: OccName -> OccName
mkGen1R :: OccName -> OccName
mkDataTOcc :: OccName -> OccName
mkDataCOcc :: OccName -> OccName
mkDataConWorkerOcc :: OccName -> OccName
mkSuperDictSelOcc :: Int -> OccName -> OccName
mkSuperDictAuxOcc :: Int -> OccName -> OccName
mkLocalOcc :: Unique -> OccName -> OccName
mkMethodOcc :: OccName -> OccName

-- | Derive a name for the representation type constructor of a
--   <tt>data</tt>/<tt>newtype</tt> instance.
mkInstTyTcOcc :: String -> OccSet -> OccName
mkInstTyCoOcc :: OccName -> OccName
mkEqPredCoOcc :: OccName -> OccName
mkRecFldSelOcc :: FastString -> OccName
mkTyConRepOcc :: OccName -> OccName
isVarOcc :: OccName -> Bool
isTvOcc :: OccName -> Bool
isTcOcc :: OccName -> Bool
isDataOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is a data constructor that starts with a
--   symbol (e.g. <tt>:</tt>, or <tt>[]</tt>)
isDataSymOcc :: OccName -> Bool

-- | <i>Value</i> <tt>OccNames</tt>s are those that are either in the
--   variable or data constructor namespaces
isValOcc :: OccName -> Bool

-- | Wrap parens around an operator
parenSymOcc :: OccName -> SDoc -> SDoc

-- | Haskell 98 encourages compilers to suppress warnings about unused
--   names in a pattern if they start with <tt>_</tt>: this implements that
--   test
startsWithUnderscore :: OccName -> Bool
isTcClsNameSpace :: NameSpace -> Bool
isTvNameSpace :: NameSpace -> Bool
isDataConNameSpace :: NameSpace -> Bool
isVarNameSpace :: NameSpace -> Bool
emptyOccEnv :: OccEnv a
unitOccEnv :: OccName -> a -> OccEnv a
extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
mapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b
lookupOccEnv :: OccEnv a -> OccName -> Maybe a
mkOccEnv :: [(OccName, a)] -> OccEnv a
mkOccEnv_C :: (a -> a -> a) -> [(OccName, a)] -> OccEnv a
extendOccEnvList :: OccEnv a -> [(OccName, a)] -> OccEnv a
elemOccEnv :: OccName -> OccEnv a -> Bool
nonDetOccEnvElts :: OccEnv a -> [a]
foldOccEnv :: (a -> b -> b) -> b -> OccEnv a -> b
plusOccEnv :: OccEnv a -> OccEnv a -> OccEnv a
plusOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccEnv a -> OccEnv a
extendOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccName -> a -> OccEnv a
extendOccEnv_Acc :: (a -> b -> b) -> (a -> b) -> OccEnv b -> OccName -> a -> OccEnv b
filterOccEnv :: (elt -> Bool) -> OccEnv elt -> OccEnv elt
delListFromOccEnv :: OccEnv a -> [OccName] -> OccEnv a
delFromOccEnv :: OccEnv a -> OccName -> OccEnv a
alterOccEnv :: (Maybe elt -> Maybe elt) -> OccEnv elt -> OccName -> OccEnv elt
minusOccEnv :: OccEnv a -> OccEnv b -> OccEnv a

-- | Alters (replaces or removes) those elements of the map that are
--   mentioned in the second map
minusOccEnv_C :: (a -> b -> Maybe a) -> OccEnv a -> OccEnv b -> OccEnv a
pprOccEnv :: (a -> SDoc) -> OccEnv a -> SDoc
emptyOccSet :: OccSet
unitOccSet :: OccName -> OccSet
mkOccSet :: [OccName] -> OccSet
extendOccSet :: OccSet -> OccName -> OccSet
extendOccSetList :: OccSet -> [OccName] -> OccSet
unionOccSets :: OccSet -> OccSet -> OccSet
unionManyOccSets :: [OccSet] -> OccSet
minusOccSet :: OccSet -> OccSet -> OccSet
elemOccSet :: OccName -> OccSet -> Bool
isEmptyOccSet :: OccSet -> Bool
intersectOccSet :: OccSet -> OccSet -> OccSet
filterOccSet :: (OccName -> Bool) -> OccSet -> OccSet

-- | Converts an OccSet to an OccEnv (operationally the identity)
occSetToEnv :: OccSet -> OccEnv OccName
emptyTidyOccEnv :: TidyOccEnv
initTidyOccEnv :: [OccName] -> TidyOccEnv
tidyOccName :: TidyOccEnv -> OccName -> (TidyOccEnv, OccName)
avoidClashesOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv
delTidyOccEnvList :: TidyOccEnv -> [FastString] -> TidyOccEnv

-- | Identifier
type Id = Var

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var
type InId = Id
type InVar = Var
type OutId = Id
type OutVar = Var
type IdUnfoldingFun = Id -> Unfolding
type JoinId = Id
idType :: Id -> Kind

-- | <a>isImplicitId</a> tells whether an <a>Id</a>s info is implied by
--   other declarations, so we don't need to put its signature in an
--   interface file, even if it's mentioned in some other interface
--   unfolding.
isImplicitId :: Id -> Bool
isDeadBinder :: Id -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool
isLocalId :: Var -> Bool
isGlobalId :: Var -> Bool
isRecordSelector :: Id -> Bool
isPrimOpId :: Id -> Bool
isFCallId :: Id -> Bool
isClassOpId_maybe :: Id -> Maybe Class
isDataConWorkId :: Id -> Bool

-- | Get from either the worker or the wrapper <a>Id</a> to the
--   <a>DataCon</a>. Currently used only in the desugarer.
--   
--   INVARIANT: <tt>idDataCon (dataConWrapId d) = d</tt>: remember,
--   <a>dataConWrapId</a> can return either the wrapper or the worker
idDataCon :: Id -> DataCon

-- | Returns true if an application to n args diverges or throws an
--   exception See Note [Dead ends] in <a>GHC.Types.Demand</a>.
isDeadEndId :: Var -> Bool

-- | If the <a>Id</a> is that for a record selector, extract the
--   <a>sel_tycon</a>. Panic otherwise.
recordSelectorTyCon :: Id -> RecSelParent

-- | Is this a value-level (i.e., computationally relevant)
--   <a>Var</a>entifier? Satisfies <tt>isId = not . isTyVar</tt>.
isId :: Var -> Bool
idHasRules :: Id -> Bool
zapStableUnfolding :: Id -> Id
idInlineActivation :: Id -> Activation
setInlineActivation :: Id -> Activation -> Id
infixl 1 `setInlineActivation`
zapIdOccInfo :: Id -> Id
zapIdUsageInfo :: Id -> Id
idInlinePragma :: Id -> InlinePragma
isJoinId :: Var -> Bool

-- | Doesn't return strictness marks
isJoinId_maybe :: Var -> Maybe JoinArity

-- | Returns the <a>Id</a>s unfolding, but does not expose the unfolding of
--   a strong loop breaker. See <a>unfoldingInfo</a>.
--   
--   If you really want the unfolding of a strong loopbreaker, call
--   <a>realIdUnfolding</a>.
idUnfolding :: IdUnfoldingFun
mkSysLocalOrCoVarM :: MonadUnique m => FastString -> Mult -> Type -> m Id
idInfo :: HasDebugCallStack => Id -> IdInfo
isDataConId_maybe :: Id -> Maybe DataCon

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var#globalvslocal</a>
mkLocalId :: HasDebugCallStack => Name -> Mult -> Type -> Id
idName :: Id -> Name
setInlinePragma :: Id -> InlinePragma -> Id
infixl 1 `setInlinePragma`

-- | Expose the unfolding if there is one, including for loop breakers
realIdUnfolding :: Id -> Unfolding

-- | Create a template local for a series of types
mkTemplateLocals :: [Type] -> [Id]
idScaledType :: Id -> Scaled Type

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>GHC.Types.Var.Var#globalvslocal</a>
mkGlobalId :: IdDetails -> Name -> Type -> IdInfo -> Id

-- | Make a global <a>Id</a> without any extra information at all
mkVanillaGlobal :: Name -> Type -> Id

-- | Make a global <a>Id</a> with no global information but some generic
--   <a>IdInfo</a>
mkVanillaGlobalWithInfo :: Name -> Type -> IdInfo -> Id

-- | Make a local CoVar
mkLocalCoVar :: Name -> Type -> CoVar

-- | Like <a>mkLocalId</a>, but checks the type to see if it should make a
--   covar
mkLocalIdOrCoVar :: Name -> Mult -> Type -> Id
mkLocalIdWithInfo :: HasDebugCallStack => Name -> Mult -> Type -> IdInfo -> Id

-- | Create a local <a>Id</a> that is marked as exported. This prevents
--   things attached to it from being removed as dead code. See Note
--   [Exported LocalIds]
mkExportedLocalId :: IdDetails -> Name -> Type -> Id
mkExportedVanillaId :: Name -> Type -> Id

-- | Create a system local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>Var#globalvslocal</a>) that are created by the compiler out of thin
--   air
mkSysLocal :: FastString -> Unique -> Mult -> Type -> Id
mkSysLocalM :: MonadUnique m => FastString -> Mult -> Type -> m Id

-- | Like <a>mkSysLocal</a>, but checks to see if we have a covar type
mkSysLocalOrCoVar :: FastString -> Unique -> Mult -> Type -> Id

-- | Create a user local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>GHC.Types.Var#globalvslocal</a>) with a name and location that the
--   user might recognize
mkUserLocal :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Like <a>mkUserLocal</a>, but checks if we have a coercion type
mkUserLocalOrCoVar :: OccName -> Unique -> Mult -> Type -> SrcSpan -> Id

-- | Create a template local for a series of type, but start from a
--   specified template local
mkTemplateLocalsNum :: Int -> [Type] -> [Id]

-- | Create a <i>template local</i>: a family of system local <a>Id</a>s in
--   bijection with <tt>Int</tt>s, typically used in unfoldings
mkTemplateLocal :: Int -> Type -> Id
mkScaledTemplateLocal :: Int -> Scaled Type -> Id

-- | Workers get local names. <a>CoreTidy</a> will externalise these if
--   necessary
mkWorkerId :: Unique -> Id -> Type -> Id
idMult :: Id -> Mult
idUnique :: Id -> Unique
idDetails :: Id -> IdDetails
recordSelectorTyCon_maybe :: Id -> Maybe RecSelParent
setIdName :: Id -> Name -> Id
setIdUnique :: Id -> Unique -> Id
setIdMult :: Id -> Mult -> Id
updateIdTypeButNotMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMult :: (Type -> Type) -> Id -> Id
updateIdTypeAndMultM :: Monad m => (Type -> m Type) -> Id -> m Id

-- | If it's a local, make it global
globaliseId :: Id -> Id
localiseId :: Id -> Id
setIdInfo :: Id -> IdInfo -> Id
modifyIdInfo :: HasDebugCallStack => (IdInfo -> IdInfo) -> Id -> Id
maybeModifyIdInfo :: Maybe IdInfo -> Id -> Id
zapLamIdInfo :: Id -> Id
zapIdDemandInfo :: Id -> Id
zapIdUsageEnvInfo :: Id -> Id
zapIdUsedOnceInfo :: Id -> Id
zapIdTailCallInfo :: Id -> Id
zapFragileIdInfo :: Id -> Id
zapIdDmdSig :: Id -> Id
transferPolyIdInfo :: Id -> [Var] -> Id -> Id
scaleIdBy :: Mult -> Id -> Id

-- | Like <a>scaleIdBy</a>, but skips non-Ids. Useful for scaling a mixed
--   list of ids and tyvars.
scaleVarBy :: Mult -> Var -> Var

-- | <a>isStrictId</a> says whether either (a) the <a>Id</a> has a strict
--   demand placed on it or (b) definitely has a "strict type", such that
--   it can always be evaluated strictly (i.e an unlifted type) We need to
--   check (b) as well as (a), because when the demand for the given
--   <a>id</a> hasn't been computed yet but <a>id</a> has a strict type, we
--   still want `isStrictId id` to be <a>True</a>. Returns False if the
--   type is levity polymorphic; False is always safe.
isStrictId :: Id -> Bool
isNaughtyRecordSelector :: Id -> Bool
isPatSynRecordSelector :: Id -> Bool
isDataConRecordSelector :: Id -> Bool
isClassOpId :: Id -> Bool
isDFunId :: Id -> Bool
isPrimOpId_maybe :: Id -> Maybe PrimOp
isFCallId_maybe :: Id -> Maybe ForeignCall
isDataConWorkId_maybe :: Id -> Maybe DataCon
isDataConWrapId :: Id -> Bool
isDataConWrapId_maybe :: Id -> Maybe DataCon
isConLikeId :: Id -> Bool

-- | An Id for which we might require all callers to pass strict arguments
--   properly tagged + evaluated.
--   
--   See Note [CBV Function Ids]
isWorkerLikeId :: Id -> Bool
idIsFrom :: Module -> Id -> Bool

-- | Returns <tt>True</tt> of an <a>Id</a> which may not have a binding,
--   even though it is defined in this module.
hasNoBinding :: Id -> Bool
idJoinArity :: JoinId -> JoinArity
asJoinId :: Id -> JoinArity -> JoinId
infixl 1 `asJoinId`
asJoinId_maybe :: Id -> Maybe JoinArity -> Id
infixl 1 `asJoinId_maybe`
zapJoinId :: Id -> Id
modifyInlinePragma :: Id -> (InlinePragma -> InlinePragma) -> Id
idRuleMatchInfo :: Id -> RuleMatchInfo
setOneShotLambda :: Id -> Id
clearOneShotLambda :: Id -> Id
updOneShotInfo :: Id -> OneShotInfo -> Id
setIdOneShotInfo :: Id -> OneShotInfo -> Id
infixl 1 `setIdOneShotInfo`
idArity :: Id -> Arity
idCallArity :: Id -> Arity

-- | This function counts all arguments post-unarisation, which includes
--   arguments with no runtime representation -- see Note [Unarisation and
--   arity]
idFunRepArity :: Id -> RepArity
idSpecialisation :: Id -> RuleInfo
idCoreRules :: Id -> [CoreRule]
idCafInfo :: Id -> CafInfo
infixl 1 `idCafInfo`
idLFInfo_maybe :: Id -> Maybe LambdaFormInfo
idOneShotInfo :: Id -> OneShotInfo
idOccInfo :: Id -> OccInfo

-- | Returns an unfolding only if (a) not a strong loop breaker and (b)
--   always active
alwaysActiveUnfoldingFun :: IdUnfoldingFun

-- | Returns an unfolding only if (a) not a strong loop breaker and (b)
--   active in according to is_active
whenActiveUnfoldingFun :: (Activation -> Bool) -> IdUnfoldingFun
noUnfoldingFun :: IdUnfoldingFun
setIdUnfolding :: Id -> Unfolding -> Id
infixl 1 `setIdUnfolding`

-- | Similar to trimUnfolding, but also removes evaldness info.
zapIdUnfolding :: Id -> Id
setCaseBndrEvald :: StrictnessMark -> Id -> Id
setIdArity :: Id -> Arity -> Id
infixl 1 `setIdArity`
setIdCallArity :: Id -> Arity -> Id
infixl 1 `setIdCallArity`
setIdSpecialisation :: Id -> RuleInfo -> Id
infixl 1 `setIdSpecialisation`
setIdCafInfo :: Id -> CafInfo -> Id
setIdOccInfo :: Id -> OccInfo -> Id
infixl 1 `setIdOccInfo`
setIdLFInfo :: Id -> LambdaFormInfo -> Id
setIdDemandInfo :: Id -> Demand -> Id
infixl 1 `setIdDemandInfo`
setIdDmdSig :: Id -> DmdSig -> Id
infixl 1 `setIdDmdSig`
setIdCprSig :: Id -> CprSig -> Id
infixl 1 `setIdCprSig`

-- | If all marks are NotMarkedStrict we just set nothing.
setIdCbvMarks :: Id -> [CbvMark] -> Id
infixl 1 `setIdCbvMarks`
idCbvMarks_maybe :: Id -> Maybe [CbvMark]
idCbvMarkArity :: Id -> Arity

-- | Turn this id into a WorkerLikeId if possible.
asWorkerLikeId :: Id -> Id

-- | Remove any cbv marks on arguments from a given Id.
asNonWorkerLikeId :: Id -> Id
idDemandInfo :: Id -> Demand

-- | Accesses the <tt>Id'</tt>s <a>dmdSigInfo</a>.
idDmdSig :: Id -> DmdSig
idCprSig :: Id -> CprSig
idTagSig_maybe :: Id -> Maybe TagSig
setIdTagSig :: Id -> TagSig -> Id

-- | Not only does this set the <a>Id</a> <a>Type</a>, it also evaluates
--   the type to try and reduce space usage
setIdType :: Id -> Type -> Id

-- | A set of variables that are in scope at some point.
--   
--   Note that this is a <i>superset</i> of the variables that are
--   currently in scope. See Note [The InScopeSet invariant].
--   
--   "Secrets of the Glasgow Haskell Compiler inliner" Section 3.2 provides
--   the motivation for this abstraction.
data InScopeSet

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A substitution of <tt>Expr</tt>s for non-coercion <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that TyCoSubst Note [The
--   substitution invariant] holds after extending the substitution like
--   this
extendIdSubst :: Subst -> Id -> CoreExpr -> Subst

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that Note [The substitution invariant]
--   holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst

-- | Remove all substitutions that might have been built up while
--   preserving the in-scope set originally called zapSubstEnv
zapSubst :: Subst -> Subst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst
isInScope :: Var -> Subst -> Bool

-- | De-shadowing the program is sometimes a useful pre-pass. It can be
--   done simply by running over the bindings with an empty substitution,
--   because substitution returns a result that has no-shadowing
--   guaranteed.
--   
--   (Actually, within a single <i>type</i> there might still be shadowing,
--   because <tt>substTy</tt> is a no-op for the empty substitution, but
--   that's probably OK.)
--   
--   <ul>
--   <li><i>Aug 09</i> This function is not used in GHC at the moment, but
--   seems so short and simple that I'm going to leave it here</li>
--   </ul>
deShadowBinds :: CoreProgram -> CoreProgram

-- | Substitutes for the <a>Id</a>s within the <a>RuleInfo</a> given the
--   new function <a>Id</a>
substRuleInfo :: Subst -> Id -> RuleInfo -> RuleInfo
substRulesForImportedIds :: Subst -> [CoreRule] -> [CoreRule]

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type

-- | substExpr applies a substitution to an entire <a>CoreExpr</a>.
--   Remember, you may only apply the substitution <i>once</i>: See Note
--   [Substitutions apply only once] in <a>GHC.Core.TyCo.Subst</a>
--   
--   Do *not* attempt to short-cut in the case of an empty substitution!
--   See Note [Extending the IdSubstEnv]
substExpr :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr
substExprSC :: HasDebugCallStack => Subst -> CoreExpr -> CoreExpr

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBind :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBindSC :: HasDebugCallStack => Subst -> CoreBind -> (Subst, CoreBind)

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfolding :: Subst -> Unfolding -> Unfolding

-- | Substitutes for the <a>Id</a>s within an unfolding NB: substUnfolding
--   <i>discards</i> any unfolding without without a Stable source. This is
--   usually what we want, but it may be a bit unexpected
substUnfoldingSC :: Subst -> Unfolding -> Unfolding

-- | Find the substitution for an <a>Id</a> in the <a>Subst</a> The Id
--   should not be a CoVar
lookupIdSubst :: HasDebugCallStack => Subst -> Id -> CoreExpr
lookupIdSubst_maybe :: HasDebugCallStack => Subst -> Id -> Maybe CoreExpr
substIdType :: Subst -> Id -> Id
substIdOcc :: Subst -> Id -> Id
substTickish :: Subst -> CoreTickish -> CoreTickish
substDVarSet :: HasDebugCallStack => Subst -> DVarSet -> DVarSet

-- | Substitute into some <a>IdInfo</a> with regard to the supplied new
--   <a>Id</a>. Discards unfoldings, unless they are Stable
substIdInfo :: Subst -> Id -> IdInfo -> Maybe IdInfo
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst
mkSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> IdSubstEnv -> Subst

-- | Simultaneously substitute for a bunch of variables No left-right
--   shadowing ie the substitution for (x y. e) a1 a2 so neither x nor y
--   scope over a1 a2
mkOpenSubst :: InScopeSet -> [(Var, CoreArg)] -> Subst
isEmptySubst :: Subst -> Bool

-- | Adds multiple <a>Id</a> substitutions to the <a>Subst</a>: see also
--   <a>extendIdSubst</a>
extendIdSubstList :: Subst -> [(Id, CoreExpr)] -> Subst
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst
extendIdSubstWithClone :: Subst -> Id -> Id -> Subst

-- | Add a substitution appropriate to the thing being substituted (whether
--   an expression, type, or coercion). See also <a>extendIdSubst</a>,
--   <a>extendTvSubst</a>, <a>extendCvSubst</a>
extendSubst :: Subst -> Var -> CoreArg -> Subst

-- | Add a substitution as appropriate to each of the terms being
--   substituted (whether expressions, types, or coercions). See also
--   <a>extendSubst</a>.
extendSubstList :: Subst -> [(Var, CoreArg)] -> Subst
extendSubstWithVar :: Subst -> Var -> Var -> Subst

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst
setInScope :: Subst -> InScopeSet -> Subst

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet
delBndr :: Subst -> Var -> Subst
delBndrs :: Subst -> [Var] -> Subst

-- | Substitutes a <a>Expr</a> for another one according to the
--   <a>Subst</a> given, returning the result and an updated <a>Subst</a>
--   that should be used by subsequent substitutions. <a>IdInfo</a> is
--   preserved by this process, although it is substituted into
--   appropriately.
substBndr :: Subst -> Var -> (Subst, Var)

-- | Applies <a>substBndr</a> to a number of <a>Expr</a>s, accumulating a
--   new <a>Subst</a> left-to-right
substBndrs :: Traversable f => Subst -> f Var -> (Subst, f Var)

-- | Substitute in a mutually recursive group of <a>Id</a>s
substRecBndrs :: Traversable f => Subst -> f Id -> (Subst, f Id)
cloneBndr :: Subst -> Unique -> Var -> (Subst, Var)
cloneBndrs :: Subst -> UniqSupply -> [Var] -> (Subst, [Var])

-- | Very similar to <a>substBndr</a>, but it always allocates a new
--   <a>Unique</a> for each variable in its output. It substitutes the
--   IdInfo though. Discards non-Stable unfoldings
cloneIdBndr :: Subst -> UniqSupply -> Id -> (Subst, Id)

-- | Applies <a>cloneIdBndr</a> to a number of <a>Id</a>s, accumulating a
--   final substitution from left to right Discards non-Stable unfoldings
cloneIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])

-- | Clone a mutually recursive group of <a>Id</a>s
cloneRecIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])
data Type

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | Whether an <a>Invisible</a> argument may appear in source Haskell.
data Specificity

-- | the argument may not appear in source Haskell, it is only inferred.
InferredSpec :: Specificity

-- | the argument may appear in source Haskell, but isn't required.
SpecifiedSpec :: Specificity

-- | Type or kind Variable
type TyVar = Var

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var
type TyVarBinder = VarBndr TyVar ForAllTyFlag

-- | Type or Coercion Variable
type TyCoVar = Id

-- | Type &amp; coercion &amp; id substitution
--   
--   The <a>Subst</a> data type defined in this module contains
--   substitution for tyvar, covar and id. However, operations on
--   IdSubstEnv (mapping from <a>Id</a> to <a>CoreExpr</a>) that require
--   the definition of the <a>Expr</a> data type are defined in
--   GHC.Core.Subst to avoid circular module dependency.
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | Mult is a type alias for Type.
--   
--   Mult must contain Type because multiplicity variables are mere type
--   variables (of kind Multiplicity) in Haskell. So the simplest
--   implementation is to make Mult be Type.
--   
--   Multiplicities can be formed with: - One: GHC.Types.One (= oneDataCon)
--   - Many: GHC.Types.Many (= manyDataCon) - Multiplication:
--   GHC.Types.MultMul (= multMulTyCon)
--   
--   So that Mult feels a bit more structured, we provide pattern synonyms
--   and smart constructors for these.
type Mult = Type

-- | A shorthand for data with an attached <a>Mult</a> element (the
--   multiplicity).
data Scaled a

-- | A <a>PiTyBinder</a> represents an argument to a function. PiTyBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [PiTyBinders]
data PiTyBinder

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A substitution of <tt>Expr</tt>s for non-coercion <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | The key representation of types within the compiler
type KindOrType = Type

-- | Type synonym used for types of kind RuntimeRep.
type RuntimeRepType = Type

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   <a>GHC.Tc.TyCl</a>
type KnotTied ty = ty
type FRRType = Type

-- | ForAllTyFlag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, ForAllTyBinders, TyConBinders,
--   and visibility] in <a>GHC.Core.TyCo.Rep</a>
data ForAllTyFlag
Invisible :: Specificity -> ForAllTyFlag
Required :: ForAllTyFlag
pattern Specified :: ForAllTyFlag
pattern Inferred :: ForAllTyFlag

-- | The non-dependent version of <a>ForAllTyFlag</a>. See Note [FunTyFlag]
--   Appears here partly so that it's together with its friends
--   ForAllTyFlag and ForallVisFlag, but also because it is used in
--   IfaceType, rather early in the compilation chain
data FunTyFlag
FTF_T_T :: FunTyFlag
FTF_T_C :: FunTyFlag
FTF_C_T :: FunTyFlag
FTF_C_C :: FunTyFlag
data TyCoFolder env a
TyCoFolder :: (Type -> Maybe Type) -> (env -> TyVar -> a) -> (env -> CoVar -> a) -> (env -> CoercionHole -> a) -> (env -> TyCoVar -> ForAllTyFlag -> env) -> TyCoFolder env a
[tcf_view] :: TyCoFolder env a -> Type -> Maybe Type
[tcf_tyvar] :: TyCoFolder env a -> env -> TyVar -> a
[tcf_covar] :: TyCoFolder env a -> env -> CoVar -> a

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcf_hole] :: TyCoFolder env a -> env -> CoercionHole -> a

-- | The returned env is used in the extended scope
[tcf_tycobinder] :: TyCoFolder env a -> env -> TyCoVar -> ForAllTyFlag -> env

-- | Variable Binder
--   
--   A <a>ForAllTyBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in
--   <a>GHC.Core.TyCo.Rep</a>, because it's used in
--   GHC.Core.DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type ForAllTyBinder = VarBndr TyCoVar ForAllTyFlag

-- | This describes how a "map" operation over a type/coercion should
--   behave
data TyCoMapper env m
TyCoMapper :: (env -> TyVar -> m Type) -> (env -> CoVar -> m Coercion) -> (env -> CoercionHole -> m Coercion) -> (env -> TyCoVar -> ForAllTyFlag -> m (env, TyCoVar)) -> (TyCon -> m TyCon) -> TyCoMapper env m
[tcm_tyvar] :: TyCoMapper env m -> env -> TyVar -> m Type
[tcm_covar] :: TyCoMapper env m -> env -> CoVar -> m Coercion

-- | What to do with coercion holes. See Note [Coercion holes] in
--   <a>GHC.Core.TyCo.Rep</a>.
[tcm_hole] :: TyCoMapper env m -> env -> CoercionHole -> m Coercion

-- | The returned env is used in the extended scope
[tcm_tycobinder] :: TyCoMapper env m -> env -> TyCoVar -> ForAllTyFlag -> m (env, TyCoVar)

-- | This is used only for TcTyCons a) To zonk TcTyCons b) To turn TcTyCons
--   into TyCons. See Note [Type checking recursive type and class
--   declarations] in <a>GHC.Tc.TyCl</a>
[tcm_tycon] :: TyCoMapper env m -> TyCon -> m TyCon
pattern OneTy :: Mult
pattern ManyTy :: Mult

-- | Extract the function result type and panic if that is not possible
funResultTy :: HasDebugCallStack => Type -> Type
mkFunTy :: HasDebugCallStack => FunTyFlag -> Mult -> Type -> Type -> Type
infixr 3 `mkFunTy`

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor. Panics if
--   that is not possible. See also <a>splitTyConApp_maybe</a>
splitTyConApp :: Type -> (TyCon, [Type])

-- | See <a>Type#type_classification</a> for what an algebraic type is.
--   Should only be applied to <i>types</i>, as opposed to e.g. partially
--   saturated type constructors
isAlgType :: Type -> Bool
typeKind :: HasDebugCallStack => Type -> Kind

-- | Take a ForAllTy apart, returning the list of tycovars and the result
--   type. This always succeeds, even if it returns only an empty list.
--   Note that the result type returned may have free variables that were
--   bound by a forall.
splitForAllTyCoVars :: Type -> ([TyCoVar], Type)

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [ForAllTyBinder] -> Type -> Type
mkVisFunTysMany :: [Type] -> Type -> Type

-- | True if the argument types of this function type all have a
--   fixed-runtime-rep
argsHaveFixedRuntimeRep :: Type -> Bool
liftedTypeKind :: Type
unliftedTypeKind :: Type
funTyFlagTyCon :: FunTyFlag -> TyCon

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | Extract the <a>PromDataConInfo</a> of a type. For example,
--   <tt>getLevity Int = Lifted</tt>, or <tt>getLevity (Array# Int) =
--   Unlifted</tt>.
--   
--   Panics if this is not possible. Does not look through type family
--   applications.
getLevity :: HasDebugCallStack => Type -> Type
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]

-- | Make a named binder <tt>var</tt> should be a type variable
mkTyVarBinder :: vis -> TyVar -> VarBndr TyVar vis

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: vis -> [TyVar] -> [VarBndr TyVar vis]

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasDebugCallStack => Subst -> Coercion -> Coercion
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
substTyVarBndr :: HasDebugCallStack => Subst -> TyVar -> (Subst, TyVar)

-- | Scale a payload by Many
unrestricted :: a -> Scaled a

-- | Scale a payload by One
linear :: a -> Scaled a

-- | Scale a payload by Many; used for type arguments in core
tymult :: a -> Scaled a
irrelevantMult :: Scaled a -> a
mkScaled :: Mult -> a -> Scaled a
scaledSet :: Scaled a -> b -> Scaled b
tyConAppArgs :: HasCallStack => Type -> [Type]
tyCoVarsOfType :: Type -> TyCoVarSet

-- | Returns:
--   
--   <ul>
--   <li><a>False</a> if the type is <i>guaranteed</i> lifted or</li>
--   <li><a>True</a> if it is unlifted, OR we aren't sure (e.g. in a
--   representation-polymorphic case)</li>
--   </ul>
mightBeUnliftedType :: Type -> Bool

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | Returns True if a type has a syntactically fixed runtime rep, as per
--   Note [Fixed RuntimeRep] in GHC.Tc.Utils.Concrete.
--   
--   This function is equivalent to `isFixedRuntimeRepKind . typeKind` but
--   much faster.
--   
--   <b>Precondition:</b> The type has kind <tt>(<tt>TYPE</tt> blah)</tt>
typeHasFixedRuntimeRep :: HasDebugCallStack => Type -> Bool

-- | Add a substitution from a <a>CoVar</a> to a <a>Coercion</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set satisfies Note
--   [The substitution invariant] after extending the substitution like
--   this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst
substTyVar :: Subst -> TyVar -> Type

-- | Remove all substitutions that might have been built up while
--   preserving the in-scope set originally called zapSubstEnv
zapSubst :: Subst -> Subst
isPredTy :: HasDebugCallStack => Type -> Bool

-- | Attempts to obtain the type variable underlying a <a>Type</a>
getTyVar_maybe :: Type -> Maybe TyVar

-- | tcSplitTyConApp_maybe splits a type constructor application into its
--   type constructor and applied types.
--   
--   Differs from splitTyConApp_maybe in that it does *not* split types
--   headed with (=&gt;), as that's not a TyCon in the type-checker.
--   
--   Note that this may fail (in funTyConAppTy_maybe) in the case of a
--   <a>FunTy</a> with an argument of unknown kind <a>FunTy</a> (e.g.
--   `FunTy (a :: k) Int`, since the kind of <tt>a</tt> isn't of the form
--   `TYPE rep`. This isn't usually a problem but may be temporarily the
--   cas during canonicalization: see Note [Decomposing FunTy] in
--   GHC.Tc.Solver.Canonical and Note [The Purely Kinded Type Invariant
--   (PKTI)] in GHC.Tc.Gen.HsType, Wrinkle around FunTy
--   
--   Consequently, you may need to zonk your type before using this
--   function.
tcSplitTyConApp_maybe :: HasCallStack => Type -> Maybe (TyCon, [Type])
tyVarKind :: TyVar -> Kind
seqType :: Type -> ()

-- | Is this a type-level (i.e., computationally irrelevant, thus erasable)
--   variable? Satisfies <tt>isTyVar = not . isId</tt>.
isTyVar :: Var -> Bool
cloneTyVarBndr :: Subst -> TyVar -> Unique -> (Subst, TyVar)
typeSize :: Type -> Int

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: Subst -> Type -> Type
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst
mkSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> IdSubstEnv -> Subst
isEmptySubst :: Subst -> Bool
extendTCvSubst :: Subst -> TyCoVar -> Type -> Subst

-- | Add the <a>Var</a> to the in-scope set
extendSubstInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeList :: Subst -> [Var] -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also
--   <tt>extendInScope</tt>
extendSubstInScopeSet :: Subst -> VarSet -> Subst
setInScope :: Subst -> InScopeSet -> Subst

-- | Find the in-scope set: see Note [The substitution invariant]
getSubstInScope :: Subst -> InScopeSet

-- | This function strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   <a>Nothing</a> if there is nothing to look through.
--   
--   This function does not look through type family applications.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type

-- | Just like splitAppTyNoView_maybe, but does not split (c =&gt; t) See
--   Note [Decomposing fat arrow c=&gt;t]
tcSplitAppTyNoView_maybe :: Type -> Maybe (Type, Type)

-- | Does the AppTy split as in <a>splitAppTy_maybe</a>, but assumes that
--   any coreView stuff is already done
splitAppTyNoView_maybe :: HasDebugCallStack => Type -> Maybe (Type, Type)
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in <a>GHC.Utils.FV</a>.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet
tyCoFVsBndr :: ForAllTyBinder -> FV -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in <a>GHC.Utils.FV</a>.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in <a>GHC.Utils.FV</a> for explanation.
tyCoFVsOfType :: Type -> FV
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> CoVarSet
anyFreeVarsOfType :: (TyCoVar -> Bool) -> Type -> Bool
anyFreeVarsOfTypes :: (TyCoVar -> Bool) -> [Type] -> Bool
noFreeVarsOfType :: Type -> Bool

-- | All type constructors occurring in the type; looking through type
--   synonyms, but not newtypes. When it finds a Class, it returns the
--   class TyCon.
tyConsOfType :: Type -> UniqSet TyCon
occCheckExpand :: [Var] -> Type -> Maybe Type

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in <a>GHC.Rename.HsType</a>
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | Get the free vars of a type in scoped order
tyCoVarsOfTypeWellScoped :: Type -> [TyVar]

-- | Get the free vars of types in scoped order
tyCoVarsOfTypesWellScoped :: [Type] -> [TyVar]

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministically ordered list.
closeOverKindsList :: [TyVar] -> [TyVar]
closeOverKinds :: TyCoVarSet -> TyCoVarSet

-- | Given a <a>TyCon</a> and a list of argument types, partition the
--   arguments into:
--   
--   <ol>
--   <li><a>Inferred</a> or <a>Specified</a> (i.e., invisible) arguments
--   and</li>
--   <li><a>Required</a> (i.e., visible) arguments</li>
--   </ol>
partitionInvisibleTypes :: TyCon -> [Type] -> ([Type], [Type])
pickyIsLiftedTypeKind :: Kind -> Bool

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Required</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with <tt>()</tt>.
splitForAllReqTyBinders :: Type -> ([ReqTyBinder], Type)

-- | Like <a>splitForAllTyCoVars</a>, but only splits <a>ForAllTy</a>s with
--   <a>Invisible</a> type variable binders. Furthermore, each returned
--   tyvar is annotated with its <a>Specificity</a>.
splitForAllInvisTyBinders :: Type -> ([InvisTyBinder], Type)
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkVisFunTy :: HasDebugCallStack => Mult -> Type -> Type -> Type
mkScaledFunTys :: HasDebugCallStack => [Scaled Type] -> Type -> Type
mkInvisFunTy :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkInvisFunTy`
mkInvisFunTys :: HasDebugCallStack => [Type] -> Type -> Type
tcMkVisFunTy :: Mult -> Type -> Type -> Type
tcMkInvisFunTy :: TypeOrConstraint -> Type -> Type -> Type
tcMkScaledFunTys :: [Scaled Type] -> Type -> Type

-- | Like <tt>mkTyCoForAllTy</tt>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: ForAllTyBinder -> Type -> Type

-- | Wraps foralls over the type using the provided <a>InvisTVBinder</a>s
--   from left to right
mkInvisForAllTys :: [InvisTVBinder] -> Type -> Type
mkPiTy :: PiTyBinder -> Type -> Type
mkPiTys :: [PiTyBinder] -> Type -> Type

-- | Make nested arrow types | Special, common, case: Arrow type with mult
--   Many
mkVisFunTyMany :: HasDebugCallStack => Type -> Type -> Type
infixr 3 `mkVisFunTyMany`
foldTyCo :: Monoid a => TyCoFolder env a -> env -> (Type -> a, [Type] -> a, Coercion -> a, [Coercion] -> a)

-- | A view function that looks through nothing.
noView :: Type -> Maybe Type

-- | See GHC.Types.Var Note [FunTyFlag]
chooseFunTyFlag :: HasDebugCallStack => Type -> Type -> FunTyFlag
typeTypeOrConstraint :: HasDebugCallStack => Type -> TypeOrConstraint
emptyTvSubstEnv :: TvSubstEnv

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition. This function leaves IdSubstEnv
--   untouched because IdSubstEnv is not used during substitution for
--   types.
composeTCvSubst :: Subst -> Subst -> Subst

-- | Checks whether the tyvar and covar environments are empty. This
--   function should be used over <a>isEmptySubst</a> when substituting for
--   types, because types currently do not contain expressions; we can
--   safely disregard the expression environment when deciding whether to
--   skip a substitution. Using <a>isEmptyTCvSubst</a> gives us a
--   non-trivial performance boost (up to 70% less allocation for T18223)
isEmptyTCvSubst :: Subst -> Bool
getTvSubstEnv :: Subst -> TvSubstEnv

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getSubstRangeTyCoFVs :: Subst -> VarSet
notElemSubst :: Var -> Subst -> Bool
extendTCvSubstWithClone :: Subst -> TyCoVar -> TyCoVar -> Subst
extendTvSubstBinderAndInScope :: Subst -> PiTyBinder -> Type -> Subst
extendTvSubstWithClone :: Subst -> TyVar -> TyVar -> Subst
extendTCvSubstList :: Subst -> [Var] -> [Type] -> Subst
unionSubst :: Subst -> Subst -> Subst

-- | The InScopeSet is just a thunk so with a bit of luck it'll never be
--   evaluated
zipTyEnv :: HasDebugCallStack => [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: HasDebugCallStack => [CoVar] -> [Coercion] -> CvSubstEnv

-- | Generates the in-scope set for the <a>Subst</a> from the types in the
--   incoming environment. No CoVars or Ids, please!
zipTvSubst :: HasDebugCallStack => [TyVar] -> [Type] -> Subst
zipTCvSubst :: HasDebugCallStack => [TyCoVar] -> [Type] -> Subst

-- | Generates the in-scope set for the <tt>TCvSubst</tt> from the types in
--   the incoming environment. No CoVars, please! The InScopeSet is just a
--   thunk so with a bit of luck it'll never be evaluated
mkTvSubstPrs :: [(TyVar, Type)] -> Subst

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasDebugCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: [TyVar] -> [Type] -> [Type] -> [Type]

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: Subst -> Type -> Type
substScaledTy :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: Subst -> [Type] -> [Type]
substScaledTysUnchecked :: Subst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: Subst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type
substScaledTyUnchecked :: HasDebugCallStack => Subst -> Scaled Type -> Scaled Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: Subst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasDebugCallStack => Subst -> [Type] -> [Type]
substScaledTys :: HasDebugCallStack => Subst -> [Scaled Type] -> [Scaled Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasDebugCallStack => Subst -> ThetaType -> ThetaType
lookupTyVar :: Subst -> TyVar -> Maybe Type
cloneTyVarBndrs :: Subst -> [TyVar] -> UniqSupply -> (Subst, [TyVar])
substVarBndr :: HasDebugCallStack => Subst -> TyCoVar -> (Subst, TyCoVar)
substVarBndrs :: HasDebugCallStack => Subst -> [TyCoVar] -> (Subst, [TyCoVar])
substTyVarBndrs :: HasDebugCallStack => Subst -> [TyVar] -> (Subst, [TyVar])
substTyVars :: Subst -> [TyVar] -> [Type]
substTyVarToTyVar :: HasDebugCallStack => Subst -> TyVar -> TyVar
substTyCoBndr :: Subst -> PiTyBinder -> (Subst, PiTyBinder)

-- | Make a <a>CastTy</a>. The Coercion must be nominal. Checks the
--   Coercion for reflexivity, dropping it if it's reflexive. See <tt>Note
--   [Respecting definitional equality]</tt> in <a>GHC.Core.TyCo.Rep</a>
mkCastTy :: Type -> Coercion -> Type

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type
isCoercionTy :: Type -> Bool

-- | Tidy a Type
--   
--   See Note [Strictness in tidyType and friends]
tidyType :: TidyEnv -> Type -> Type

-- | Tidy a list of Types
--   
--   See Note [Strictness in tidyType and friends]
tidyTypes :: TidyEnv -> [Type] -> [Type]
tidyOpenType :: TidyEnv -> Type -> (TidyEnv, Type)

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypes :: TidyEnv -> [Type] -> (TidyEnv, [Type])
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a>
tidyOpenTyCoVar :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)
tidyOpenTyCoVars :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type
tidyForAllTyBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyForAllTyBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])

-- | (mkTyConTy tc) returns (TyConApp tc []) but arranges to share that
--   TyConApp among all calls See Note [Sharing nullary TyConApps] So it's
--   just an alias for tyConNullaryTy!
mkTyConTy :: TyCon -> Type

-- | Returns True if the argument is (lifted) Type or Constraint See Note
--   [TYPE and CONSTRAINT] in GHC.Builtin.Types.Prim
isLiftedTypeKind :: Kind -> Bool

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: HasDebugCallStack => Type -> TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>, without
--   any expansion
repGetTyVar_maybe :: Type -> Maybe TyVar

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind ty
getCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)
mkAppTys :: Type -> [Type] -> Type

-- | Attempts to take a type application apart, as in
--   <a>splitAppTy_maybe</a>, and panics if this is not possible
splitAppTy :: Type -> (Type, Type)

-- | Recursively splits a type as far as is possible, leaving a residual
--   type being applied to and the type arguments applied to it. Never
--   fails, even if that means returning an empty list of type
--   applications.
splitAppTys :: Type -> (Type, [Type])

-- | Like <a>splitAppTys</a>, but doesn't look through type synonyms
splitAppTysNoView :: HasDebugCallStack => Type -> (Type, [Type])

-- | Attempt to take a type application apart, whether it is a function,
--   type constructor, or plain type application. Note that type family
--   applications are NEVER unsaturated by this!
splitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Attempts to extract the multiplicity, argument and result types from a
--   type, and panics if that is not possible. See also
--   <a>splitFunTy_maybe</a>
splitFunTy :: Type -> (Mult, Type, Type)

-- | Attempts to extract the multiplicity, argument and result types from a
--   type
splitFunTy_maybe :: Type -> Maybe (FunTyFlag, Mult, Type, Type)
splitFunTys :: Type -> ([Scaled Type], Type)

-- | Just like <a>piResultTys</a> but for a single argument Try not to
--   iterate <a>piResultTy</a>, because it's inefficient to substitute one
--   variable at a time; instead use 'piResultTys"
--   
--   Extract the function argument type and panic if that is not possible
funArgTy :: Type -> Type

-- | Given the components of a FunTy figure out the corresponding TyConApp.
funTyConAppTy_maybe :: FunTyFlag -> Type -> Type -> Type -> Maybe (TyCon, [Type])

-- | Return Just if this TyConApp should be represented as a FunTy
tyConAppFunTy_maybe :: HasDebugCallStack => TyCon -> [Type] -> Maybe Type

-- | Return Just if this TyConAppCo should be represented as a FunCo
tyConAppFunCo_maybe :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Maybe Coercion

-- | This one works out the FunTyFlag from the argument type See
--   GHC.Types.Var Note [FunTyFlag]
mkFunctionType :: HasDebugCallStack => Mult -> Type -> Type -> Type

-- | Like mkFunctionType, compute the FunTyFlag from the arguments
mkScaledFunctionTys :: [Scaled Type] -> Type -> Type

-- | The same as <tt>fst . splitTyConApp</tt> We can short-cut the FunTy
--   case
tyConAppTyCon_maybe :: Type -> Maybe TyCon

-- | Retrieve the tycon heading this type, if there is one. Does <i>not</i>
--   look through synonyms.
tyConAppTyConPicky_maybe :: Type -> Maybe TyCon

-- | The same as <tt>snd . splitTyConApp</tt>
tyConAppArgs_maybe :: Type -> Maybe [Type]
tyConAppTyCon :: HasDebugCallStack => Type -> TyCon

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor
splitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])
splitTyConAppNoView_maybe :: Type -> Maybe (TyCon, [Type])
tcSplitTyConApp :: Type -> (TyCon, [Type])

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Inferred</a>, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | Like <a>mkForAllTy</a>, but assumes the variable is dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkForAllTys</a>, but assumes all variables are dependent and
--   <a>Specified</a>, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type

-- | Like mkForAllTys, but assumes all variables are dependent and visible
mkVisForAllTys :: [TyVar] -> Type -> Type

-- | Make a dependent forall over an <a>Inferred</a> variable
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTy</a>, but tv should be a tyvar
mkInfForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInfForAllTys :: [TyVar] -> Type -> Type

-- | Like <a>splitForAllTyCoVars</a>, but split only for tyvars. This
--   always succeeds, even if it returns only an empty list. Note that the
--   result type returned may have free variables that were bound by a
--   forall.
splitForAllTyVars :: Type -> ([TyVar], Type)

-- | Take a ForAllTy apart, returning the binders and result type
splitForAllForAllTyBinders :: Type -> ([ForAllTyBinder], Type)

-- | Attempts to take a forall type apart, but only if it's a proper
--   forall, with a named binder
splitForAllTyCoVar_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Take a forall type apart, or panics if that is not possible.
splitForAllTyCoVar :: Type -> (TyCoVar, Type)

-- | Like <a>splitForAllTyCoVar_maybe</a>, but only returns Just if it is a
--   tyvar binder.
splitForAllTyVar_maybe :: Type -> Maybe (TyVar, Type)

-- | Like <a>splitForAllTyCoVar_maybe</a>, but only returns Just if it is a
--   covar binder.
splitForAllCoVar_maybe :: Type -> Maybe (CoVar, Type)

-- | Attempts to take a forall type apart; works with proper foralls and
--   functions
splitPiTy_maybe :: Type -> Maybe (PiTyBinder, Type)

-- | Takes a forall type apart, or panics
splitPiTy :: Type -> (PiTyBinder, Type)

-- | Split off all PiTyBinders to a type, splitting both proper foralls and
--   functions
splitPiTys :: Type -> ([PiTyBinder], Type)

-- | Extracts a list of run-time arguments from a function type, looking
--   through newtypes to the right of arrows.
--   
--   Examples:
--   
--   <pre>
--   newtype Identity a = I a
--   
--   getRuntimeArgTys (Int -&gt; Bool -&gt; Double) == [(Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (Identity Int -&gt; Bool -&gt; Double) == [(Identity Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (Int -&gt; Identity (Bool -&gt; Identity Double)) == [(Int, FTF_T_T), (Bool, FTF_T_T)]
--   getRuntimeArgTys (forall a. Show a =&gt; Identity a -&gt; a -&gt; Int -&gt; Bool)
--            == [(Show a, FTF_C_T), (Identity a, FTF_T_T),(a, FTF_T_T),(Int, FTF_T_T)]
--   </pre>
--   
--   Note that, in the last case, the returned types might mention an
--   out-of-scope type variable. This function is used only when we really
--   care about the <i>kinds</i> of the returned types, so this is OK.
--   
--   <ul>
--   <li>*Warning**: this function can return an infinite list. For
--   example:</li>
--   </ul>
--   
--   <pre>
--   newtype N a = MkN (a -&gt; N a)
--   getRuntimeArgTys (N a) == repeat (a, FTF_T_T)
--   </pre>
getRuntimeArgTys :: Type -> [(Scaled Type, FunTyFlag)]

-- | Given a list of type-level vars and the free vars of a result kind,
--   makes PiTyBinders, preferring anonymous binders if the variable is, in
--   fact, not dependent. e.g. mkTyConBindersPreferAnon
--   <a>(k:*),(b:k),(c:k)</a> We want (k:*) Named, (b:k) Anon, (c:k) Anon
--   
--   All non-coercion binders are <i>visible</i>.
mkTyConBindersPreferAnon :: [TyVar] -> TyCoVarSet -> [TyConBinder]
piResultTy :: HasDebugCallStack => Type -> Type -> Type

-- | (piResultTys f_ty [ty1, .., tyn]) gives the type of (f ty1 .. tyn)
--   where f :: f_ty <a>piResultTys</a> is interesting because: 1.
--   <tt>f_ty</tt> may have more for-alls than there are args 2. Less
--   obviously, it may have fewer for-alls For case 2. think of:
--   piResultTys (forall a.a) [forall b.b, Int] This really can happen, but
--   only (I think) in situations involving undefined. For example:
--   undefined :: forall a. a Term: undefined <tt>(forall b. b-&gt;b)
--   </tt>Int This term should have type (Int -&gt; Int), but notice that
--   there are more type args than foralls in <a>undefined</a>s type.
piResultTys :: HasDebugCallStack => Type -> [Type] -> Type
applyTysX :: HasDebugCallStack => [TyVar] -> Type -> [Type] -> Type

-- | Drops all ForAllTys
dropForAlls :: Type -> Type

-- | Given a family instance TyCon and its arg types, return the
--   corresponding family type. E.g:
--   
--   <pre>
--   data family T a
--   data instance T (Maybe b) = MkT b
--   </pre>
--   
--   Where the instance tycon is :RTL, so:
--   
--   <pre>
--   mkFamilyTyConApp :RTL Int  =  T (Maybe Int)
--   </pre>
mkFamilyTyConApp :: TyCon -> [Type] -> Type
buildSynTyCon :: Name -> [KnotTied TyConBinder] -> Kind -> [Role] -> KnotTied Type -> TyCon
mkNumLitTy :: Integer -> Type

-- | Is this a numeric literal. We also look through type synonyms.
isNumLitTy :: Type -> Maybe Integer
mkStrLitTy :: FastString -> Type

-- | Is this a symbol literal. We also look through type synonyms.
isStrLitTy :: Type -> Maybe FastString
mkCharLitTy :: Char -> Type

-- | Is this a char literal? We also look through type synonyms.
isCharLitTy :: Type -> Maybe Char

-- | Is this a type literal (symbol, numeric, or char)?
isLitTy :: Type -> Maybe TyLit

-- | Extract the RuntimeRep classifier of a type. For instance,
--   <tt>getRuntimeRep_maybe Int = LiftedRep</tt>. Panics if this is not
--   possible.
getRuntimeRep :: HasDebugCallStack => Type -> RuntimeRepType

-- | (splitRuntimeRep_maybe rr) takes a Type rr :: RuntimeRep, and returns
--   the (TyCon,[Type]) for the RuntimeRep, if possible, where the TyCon is
--   one of the promoted DataCons of RuntimeRep. Remember: the unique on
--   TyCon that is a a promoted DataCon is the same as the unique on the
--   DataCon See Note [Promoted data constructors] in GHC.Core.TyCon May
--   not be possible if <tt>rr</tt> is a type variable or type family
--   application
splitRuntimeRep_maybe :: RuntimeRepType -> Maybe (TyCon, [Type])

-- | Given a kind (TYPE rr) or (CONSTRAINT rr), extract its RuntimeRep
--   classifier rr. For example, <tt>kindRep_maybe * = Just LiftedRep</tt>
--   Returns <a>Nothing</a> if the kind is not of form (TYPE rr)
kindRep_maybe :: HasDebugCallStack => Kind -> Maybe RuntimeRepType

-- | Extract the RuntimeRep classifier of a type from its kind. For
--   example, <tt>kindRep * = LiftedRep</tt>; Panics if this is not
--   possible. Treats * and Constraint as the same
kindRep :: HasDebugCallStack => Kind -> RuntimeRepType

-- | <tt>levity_maybe</tt> takes a Type of kind Levity, and returns its
--   levity May not be possible for a type variable or type family
--   application
levityType_maybe :: LevityType -> Maybe Levity
mkCoercionTy :: Coercion -> Type
splitCastTy_maybe :: Type -> Maybe (Type, Coercion)

-- | Is this type a custom user error? If so, give us the kind and the
--   error message.
userTypeError_maybe :: Type -> Maybe Type

-- | Render a type corresponding to a user type error into a SDoc.
pprUserTypeErrorTy :: Type -> SDoc

-- | Get the type on the LHS of a coercion induced by a type/data family
--   instance.
coAxNthLHS :: CoAxiom br -> Int -> Type
stripCoercionTy :: Type -> Coercion

-- | Like <a>splitPiTys</a>, but returns only *invisible* binders,
--   including constraints. Stops at the first visible binder.
splitInvisPiTys :: Type -> ([PiTyBinder], Type)

-- | Same as <a>splitInvisPiTys</a>, but stop when - you have found
--   <tt>n</tt> <a>PiTyBinder</a>s, - or you run out of invisible binders
splitInvisPiTysN :: Int -> Type -> ([PiTyBinder], Type)
invisibleTyBndrCount :: Type -> Int

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   invisible (i.e., <a>Inferred</a> or <a>Specified</a>) arguments.
filterOutInvisibleTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   <a>Inferred</a> arguments.
filterOutInferredTypes :: TyCon -> [Type] -> [Type]

-- | Given a list of things paired with their visibilities, partition the
--   things into (invisible things, visible things).
partitionInvisibles :: [(a, ForAllTyFlag)] -> ([a], [a])

-- | Given a <a>TyCon</a> and a list of argument types to which the
--   <a>TyCon</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Wrinkle: consider the following scenario:
--   
--   <pre>
--   T :: forall k. k -&gt; k
--   tyConForAllTyFlags T [forall m. m -&gt; m -&gt; m, S, R, Q]
--   </pre>
--   
--   After substituting, we get
--   
--   <pre>
--   T (forall m. m -&gt; m -&gt; m) :: (forall m. m -&gt; m -&gt; m) -&gt; forall n. n -&gt; n -&gt; n
--   </pre>
--   
--   Thus, the first argument is invisible, <tt>S</tt> is visible,
--   <tt>R</tt> is invisible again, and <tt>Q</tt> is visible.
tyConForAllTyFlags :: TyCon -> [Type] -> [ForAllTyFlag]

-- | Given a <a>Type</a> and a list of argument types to which the
--   <a>Type</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Most of the time, the arguments will be <a>Required</a>, but not
--   always. Consider <tt>f :: forall a. a -&gt; Type</tt>. In <tt>f Type
--   Bool</tt>, the first argument (<tt>Type</tt>) is <a>Specified</a> and
--   the second argument (<tt>Bool</tt>) is <a>Required</a>. It is
--   precisely this sort of higher-rank situation in which
--   <a>appTyForAllTyFlags</a> comes in handy, since <tt>f Type Bool</tt>
--   would be represented in Core using <a>AppTy</a>s. (See also #15792).
appTyForAllTyFlags :: Type -> [Type] -> [ForAllTyFlag]
mapTyCo :: Monad m => TyCoMapper () m -> (Type -> m Type, [Type] -> m [Type], Coercion -> m Coercion, [Coercion] -> m [Coercion])
mapTyCoX :: Monad m => TyCoMapper env m -> (env -> Type -> m Type, env -> [Type] -> m [Type], env -> Coercion -> m Coercion, env -> [Coercion] -> m [Coercion])

-- | Unwrap one <tt>layer</tt> of newtype on a type constructor and its
--   arguments, using an eta-reduced version of the <tt>newtype</tt> if
--   possible. This requires tys to have at least <tt>newTyConInstArity
--   tycon</tt> elements.
newTyConInstRhs :: TyCon -> [Type] -> Type

-- | Make a named binder
mkForAllTyBinder :: vis -> TyCoVar -> VarBndr TyCoVar vis

-- | Make many named binders
mkForAllTyBinders :: vis -> [TyCoVar] -> [VarBndr TyCoVar vis]
tyVarSpecToBinders :: [VarBndr a Specificity] -> [VarBndr a ForAllTyFlag]

-- | Does this binder bind a variable that is <i>not</i> erased? Returns
--   <a>True</a> for anonymous binders.
isAnonPiTyBinder :: PiTyBinder -> Bool
binderType :: VarBndr TyCoVar argf -> Type
binderFlag :: VarBndr tv argf -> argf
binderFlags :: [VarBndr tv argf] -> [argf]
piTyBinderType :: PiTyBinder -> Type
namedPiTyBinder_maybe :: PiTyBinder -> Maybe TyCoVar

-- | Extract a relevant type, if there is one.
anonPiTyBinderType_maybe :: PiTyBinder -> Maybe Type

-- | Does this <a>ForAllTyFlag</a> classify an argument that is written in
--   Haskell?
isVisibleForAllTyFlag :: ForAllTyFlag -> Bool

-- | Does this <a>ForAllTyFlag</a> classify an argument that is not written
--   in Haskell?
isInvisibleForAllTyFlag :: ForAllTyFlag -> Bool

-- | Does this binder bind a visible argument?
isVisiblePiTyBinder :: PiTyBinder -> Bool

-- | Does this binder bind an invisible argument?
isInvisiblePiTyBinder :: PiTyBinder -> Bool
isNamedPiTyBinder :: PiTyBinder -> Bool
tyConBindersPiTyBinders :: [TyConBinder] -> [PiTyBinder]
isTyVarTy :: Type -> Bool

-- | Is this a function?
isFunTy :: Type -> Bool
isCoercionTy_maybe :: Type -> Maybe Coercion

-- | Checks whether this is a proper forall (with a named binder)
isForAllTy :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a tyvar binder
isForAllTy_ty :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a covar binder
isForAllTy_co :: Type -> Bool

-- | Is this a function or forall?
isPiTy :: Type -> Bool
isTauTy :: Type -> Bool
isFamFreeTy :: Type -> Bool

-- | Does this type classify a core (unlifted) Coercion? At either role
--   nominal or representational (t1 ~# t2) or (t1 ~R# t2) See Note [Types
--   for coercions, predicates, and evidence] in <a>GHC.Core.TyCo.Rep</a>
isCoVarType :: Type -> Bool
isAtomicTy :: Type -> Bool

-- | Determine whether a type could be the type of a join point of given
--   total arity, according to the polymorphism rule. A join point cannot
--   be polymorphic in its return type, since given join j <tt>a </tt>b x y
--   z = e1 in e2, the types of e1 and e2 must be the same, and a and b are
--   not in scope for e2. (See Note [The polymorphism rule of join points]
--   in <a>GHC.Core</a>.) Returns False also if the type simply doesn't
--   have enough arguments.
--   
--   Note that we need to know how many arguments (type *and* value) the
--   putative join point takes; for instance, if j :: forall a. a -&gt; Int
--   then j could be a binary join point returning an Int, but it could
--   *not* be a unary join point returning a -&gt; Int.
--   
--   TODO: See Note [Excess polymorphism and join points]
isValidJoinPointType :: JoinArity -> Type -> Bool

-- | Does a <a>TyCon</a> (that is applied to some number of arguments) need
--   to be ascribed with an explicit kind signature to resolve ambiguity if
--   rendered as a source-syntax type? (See <tt>Note [When does a tycon
--   application need an explicit kind signature?]</tt> for a full
--   explanation of what this function checks for.)
tyConAppNeedsKindSig :: Bool -> TyCon -> Int -> Bool
mkTYPEapp :: RuntimeRepType -> Type

-- | Given a <tt>RuntimeRep</tt>, applies <tt>TYPE</tt> to it. On the fly
--   it rewrites TYPE LiftedRep --&gt; liftedTypeKind (a synonym) TYPE
--   UnliftedRep --&gt; unliftedTypeKind (ditto) TYPE ZeroBitRep --&gt;
--   zeroBitTypeKind (ditto) NB: no need to check for TYPE (BoxedRep
--   Lifted), TYPE (BoxedRep Unlifted) because those inner types should
--   already have been rewritten to LiftedRep and UnliftedRep respectively,
--   by mkTyConApp
--   
--   see Note [TYPE and CONSTRAINT] in GHC.Builtin.Types.Prim. See Note
--   [Using synonyms to compress types] in GHC.Core.Type
mkTYPEapp_maybe :: RuntimeRepType -> Maybe Type

-- | Just like mkTYPEapp
mkCONSTRAINTapp :: RuntimeRepType -> Type

-- | Just like mkTYPEapp_maybe
mkCONSTRAINTapp_maybe :: RuntimeRepType -> Maybe Type

-- | Given a <a>PromDataConInfo</a>, apply <tt>BoxedRep</tt> to it On the
--   fly, rewrite BoxedRep Lifted --&gt; liftedRepTy (a synonym) BoxedRep
--   Unlifted --&gt; unliftedRepTy (ditto) See Note [TYPE and CONSTRAINT]
--   in GHC.Builtin.Types.Prim. See Note [Using synonyms to compress types]
--   in GHC.Core.Type
mkBoxedRepApp_maybe :: LevityType -> Maybe Type

-- | Given a `[RuntimeRep]`, apply <tt>TupleRep</tt> to it On the fly,
--   rewrite TupleRep [] -&gt; zeroBitRepTy (a synonym) See Note [TYPE and
--   CONSTRAINT] in GHC.Builtin.Types.Prim. See Note [Using synonyms to
--   compress types] in GHC.Core.Type
mkTupleRepApp_maybe :: Type -> Maybe Type
typeOrConstraintKind :: TypeOrConstraint -> RuntimeRepType -> Kind
sORTKind_maybe :: Kind -> Maybe (TypeOrConstraint, Type)

-- | Tries to compute the <a>PromDataConInfo</a> of the given type. Returns
--   either a definite <a>PromDataConInfo</a>, or <a>Nothing</a> if we
--   aren't sure (e.g. the type is representation-polymorphic).
--   
--   Panics if the kind does not have the shape <tt>TYPE r</tt>.
typeLevity_maybe :: HasDebugCallStack => Type -> Maybe Levity
tyConIsTYPEorCONSTRAINT :: TyCon -> Bool

-- | Returns True if the kind classifies unlifted types (like 'Int#') and
--   False otherwise. Note that this returns False for
--   representation-polymorphic kinds, which may be specialized to a kind
--   that classifies unlifted types.
isUnliftedTypeKind :: Kind -> Bool

-- | Check whether a type of kind <a>RuntimeRep</a> is lifted.
--   
--   <a>isLiftedRuntimeRep</a> is:
--   
--   <ul>
--   <li>True of <tt>LiftedRep :: RuntimeRep</tt></li>
--   <li>False of type variables, type family applications, and of other
--   reps such as <tt>IntRep :: RuntimeRep</tt>.</li>
--   </ul>
isLiftedRuntimeRep :: RuntimeRepType -> Bool

-- | Check whether a type of kind <a>RuntimeRep</a> is unlifted.
--   
--   <ul>
--   <li>True of definitely unlifted <a>RuntimeRep</a>s such as
--   <a>UnliftedRep</a>, <a>IntRep</a>, <a>FloatRep</a>, ...</li>
--   <li>False of <a>LiftedRep</a>,</li>
--   <li>False for type variables and type family applications.</li>
--   </ul>
isUnliftedRuntimeRep :: RuntimeRepType -> Bool

-- | Check whether a type of kind <a>RuntimeRep</a> is lifted, unlifted, or
--   unknown.
--   
--   `isLiftedRuntimeRep rr` returns:
--   
--   <ul>
--   <li>`Just Lifted` if <tt>rr</tt> is `LiftedRep :: RuntimeRep`</li>
--   <li>`Just Unlifted` if <tt>rr</tt> is definitely unlifted, e.g.
--   <a>IntRep</a></li>
--   <li><a>Nothing</a> if not known (e.g. it's a type variable or a type
--   family application).</li>
--   </ul>
runtimeRepLevity_maybe :: RuntimeRepType -> Maybe Levity

-- | See <a>isBoxedRuntimeRep_maybe</a>.
isBoxedRuntimeRep :: RuntimeRepType -> Bool
isLiftedLevity :: Type -> Bool
isUnliftedLevity :: Type -> Bool

-- | Is the given type definitely unlifted? See
--   <a>Type#type_classification</a> for what an unlifted type is.
--   
--   Panics on representation-polymorphic types; See
--   <a>mightBeUnliftedType</a> for a more approximate predicate that
--   behaves better in the presence of representation polymorphism.
isUnliftedType :: HasDebugCallStack => Type -> Bool

-- | See <a>Type#type_classification</a> for what a boxed type is. Panics
--   on representation-polymorphic types; See <a>mightBeUnliftedType</a>
--   for a more approximate predicate that behaves better in the presence
--   of representation polymorphism.
isBoxedType :: Type -> Bool
isUnboxedTupleType :: Type -> Bool
isUnboxedSumType :: Type -> Bool

-- | Check whether a kind is of the form `TYPE (BoxedRep Lifted)` or `TYPE
--   (BoxedRep Unlifted)`.
--   
--   Returns:
--   
--   <ul>
--   <li>`Just Lifted` for `TYPE (BoxedRep Lifted)` and <a>Type</a>,</li>
--   <li>`Just Unlifted` for `TYPE (BoxedRep Unlifted)` and
--   <tt>UnliftedType</tt>,</li>
--   <li><a>Nothing</a> for anything else, e.g. `TYPE IntRep`, `TYPE
--   (BoxedRep l)`, etc.</li>
--   </ul>
kindBoxedRepLevity_maybe :: Type -> Maybe Levity

-- | Returns:
--   
--   <ul>
--   <li><a>False</a> if the type is <i>guaranteed</i> unlifted or</li>
--   <li><a>True</a> if it lifted, OR we aren't sure (e.g. in a
--   representation-polymorphic case)</li>
--   </ul>
mightBeLiftedType :: Type -> Bool

-- | Check whether a type is a data family type
isDataFamilyAppType :: Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | Computes whether an argument (or let right hand side) should be
--   computed strictly or lazily, based only on its type. Currently, it's
--   just <a>isUnliftedType</a>. Panics on representation-polymorphic
--   types.
isStrictType :: HasDebugCallStack => Type -> Bool

-- | Is this the type <a>PromDataConInfo</a>?
isLevityTy :: Type -> Bool

-- | Is a tyvar of type <a>PromDataConInfo</a>?
isLevityVar :: TyVar -> Bool

-- | Is this the type <a>RuntimeRep</a>?
isRuntimeRepTy :: Type -> Bool

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Is this a type of kind RuntimeRep? (e.g. LiftedRep)
isRuntimeRepKindedTy :: Type -> Bool

-- | Drops prefix of RuntimeRep constructors in <a>TyConApp</a>s. Useful
--   for e.g. dropping 'LiftedRep arguments of unboxed tuple TyCon
--   applications:
--   
--   dropRuntimeRepArgs [ 'LiftedRep, 'IntRep , String, Int# ] == [String,
--   Int#]
dropRuntimeRepArgs :: [Type] -> [Type]

-- | Is this the type <tt>Multiplicity</tt>?
isMultiplicityTy :: Type -> Bool

-- | Is a tyvar of type <tt>Multiplicity</tt>?
isMultiplicityVar :: TyVar -> Bool
isOneTy :: Mult -> Bool
isManyTy :: Mult -> Bool

-- | <tt>isLinear t</tt> returns <tt>True</tt> of a if <tt>t</tt> is a type
--   of (curried) function where at least one argument is linear (or
--   otherwise non-unrestricted). We use this function to check whether it
--   is safe to eta reduce an Id in CorePrep. It is always safe to return
--   <a>True</a>, because <a>True</a> deactivates the optimisation.
isLinearType :: Type -> Bool

-- | Is this kind equivalent to <a>Type</a> i.e. TYPE LiftedRep?
tcIsLiftedTypeKind :: Kind -> Bool
isConstraintKind :: Kind -> Bool
isConstraintLikeKind :: Kind -> Bool
returnsConstraintKind :: Kind -> Bool

-- | Is this kind equivalent to <tt>TYPE (BoxedRep l)</tt> for some <tt>l
--   :: Levity</tt>?
tcIsBoxedTypeKind :: Kind -> Bool

-- | Is this kind equivalent to <tt>TYPE r</tt> (for some unknown r)?
--   
--   This considers <tt>Constraint</tt> to be distinct from <tt>*</tt>.
isTypeLikeKind :: Kind -> Bool

-- | Expand out all type synonyms. Actually, it'd suffice to expand out
--   just the ones that discard type variables (e.g. type Funny a = Int)
--   But we don't know which those are currently, so we just expand all.
--   
--   <a>expandTypeSynonyms</a> only expands out type synonyms mentioned in
--   the type, not in the kinds of any TyCon or TyVar mentioned in the
--   type.
--   
--   Keep this synchronized with <tt>synonymTyConsOfType</tt>
expandTypeSynonyms :: Type -> Type
seqTypes :: [Type] -> ()

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, TYPE Lifted, TYPE IntRep, TYPE v, Constraint.
--   
--   True of a kind `TYPE _` or `CONSTRAINT _`
isTYPEorCONSTRAINT :: Kind -> Bool

-- | Tests whether the given type is concrete, i.e. it whether it consists
--   only of concrete type constructors, concrete type variables, and
--   applications.
--   
--   See Note [Concrete types] in GHC.Tc.Utils.Concrete.
isConcrete :: Type -> Bool

-- | Checks that a kind of the form <a>Type</a>, <tt>Constraint</tt> or
--   <tt>'TYPE r</tt> is concrete. See <a>isConcrete</a>.
--   
--   <b>Precondition:</b> The type has kind `TYPE blah` or `CONSTRAINT
--   blah`
isFixedRuntimeRepKind :: HasDebugCallStack => Kind -> Bool

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion

-- | See Note [Roles] in GHC.Core.Coercion
--   
--   Order of constructors matters: the Ord instance coincides with the
--   *super*typing relation on roles.
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var
type CoercionN = Coercion
type CoercionR = Coercion
type CoercionP = Coercion

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionN = MCoercion
type MCoercionR = MCoercion
data CoSel
SelTyCon :: Int -> Role -> CoSel
SelFun :: FunSel -> CoSel
SelForAll :: CoSel
data FunSel
SelMult :: FunSel
SelArg :: FunSel
SelRes :: FunSel

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight

-- | Coercion Variable
type CoVar = Id

-- | Type or Coercion Variable
type TyCoVar = Id

-- | A function to check if we can reduce a type by one step. Used with
--   <a>topNormaliseTypeX</a>.
type NormaliseStepper ev = RecTcChecker -> TyCon -> [Type] -> NormaliseStepResult ev

-- | The result of stepping in a normalisation function. See
--   <a>topNormaliseTypeX</a>.
data NormaliseStepResult ev

-- | Nothing more to do
NS_Done :: NormaliseStepResult ev

-- | Utter failure. The outer function should fail too.
NS_Abort :: NormaliseStepResult ev

-- | We stepped, yielding new bits; ^ ev is evidence; Usually a co :: old
--   type ~ new type
NS_Step :: RecTcChecker -> Type -> ev -> NormaliseStepResult ev

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion
type LiftCoEnv = VarEnv Coercion
data LiftingContext
LC :: Subst -> LiftCoEnv -> LiftingContext
coHoleCoVar :: CoercionHole -> CoVar
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole
ltRole :: Role -> Role -> Bool
coVarRType :: HasDebugCallStack => CoVar -> Type
coVarLType :: HasDebugCallStack => CoVar -> Type
coVarTypes :: HasDebugCallStack => CoVar -> Pair Type
coVarKind :: CoVar -> Type
coVarKindsTypesRole :: HasDebugCallStack => CoVar -> (Kind, Kind, Type, Type, Role)
coVarRole :: CoVar -> Role
coercionType :: Coercion -> Type

-- | Makes a coercion type from two types: the types whose equality is
--   proven by the relevant <a>Coercion</a>
mkCoercionType :: Role -> Type -> Type -> Type

-- | If it is the case that
--   
--   <pre>
--   c :: (t1 ~ t2)
--   </pre>
--   
--   i.e. the kind of <tt>c</tt> relates <tt>t1</tt> and <tt>t2</tt>, then
--   <tt>coercionKind c = Pair t1 t2</tt>.
coercionKind :: Coercion -> Pair Type
coercionLKind :: Coercion -> Type
coercionRKind :: Coercion -> Type

-- | Apply <a>coercionKind</a> to multiple <a>Coercion</a>s
coercionKinds :: [Coercion] -> Pair [Type]

-- | Retrieve the role from a coercion.
coercionRole :: Coercion -> Role

-- | Get a coercion's kind and role.
coercionKindRole :: Coercion -> (Pair Type, Role)

-- | Make a generalized reflexive coercion
mkGReflCo :: Role -> Type -> MCoercionN -> Coercion

-- | Make a reflexive coercion
mkReflCo :: Role -> Type -> Coercion

-- | Make a representational reflexive coercion
mkRepReflCo :: Type -> Coercion

-- | Make a nominal reflexive coercion
mkNomReflCo :: Type -> Coercion
mkCoVarCo :: CoVar -> Coercion
mkCoVarCos :: [CoVar] -> [Coercion]
mkAxInstCo :: Role -> CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Coercion
mkUnbranchedAxInstCo :: Role -> CoAxiom Unbranched -> [Type] -> [Coercion] -> Coercion
mkAxInstRHS :: CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type
mkUnbranchedAxInstRHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Return the left-hand type of the axiom, when the axiom is instantiated
--   at the types given.
mkAxInstLHS :: CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type

-- | Instantiate the left-hand side of an unbranched axiom
mkUnbranchedAxInstLHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Make a forall <a>Coercion</a>, where both types related by the
--   coercion are quantified over the same variable.
mkPiCo :: Role -> Var -> Coercion -> Coercion
mkPiCos :: Role -> [Var] -> Coercion -> Coercion
mkCoCast :: Coercion -> CoercionR -> Coercion

-- | Create a symmetric version of the given <a>Coercion</a> that asserts
--   equality between the same types but in the other "direction", so a
--   kind of <tt>t1 ~ t2</tt> becomes the kind <tt>t2 ~ t1</tt>.
mkSymCo :: Coercion -> Coercion

-- | Create a new <a>Coercion</a> by composing the two given
--   <a>Coercion</a>s transitively. (co1 ; co2)
mkTransCo :: Coercion -> Coercion -> Coercion
mkSelCo :: HasDebugCallStack => CoSel -> Coercion -> Coercion

-- | Extract the nth field of a FunCo
getNthFun :: FunSel -> a -> a -> a -> a
getNthFromType :: HasDebugCallStack => CoSel -> Type -> Type
mkLRCo :: LeftOrRight -> Coercion -> Coercion

-- | Instantiates a <a>Coercion</a>.
mkInstCo :: Coercion -> CoercionN -> Coercion

-- | Apply a <a>Coercion</a> to another <a>Coercion</a>. The second
--   coercion must be Nominal, unless the first is Phantom. If the first is
--   Phantom, then the second can be either Phantom or Nominal.
mkAppCo :: Coercion -> Coercion -> Coercion

-- | Applies multiple <a>Coercion</a>s to another <a>Coercion</a>, from
--   left to right. See also <a>mkAppCo</a>.
mkAppCos :: Coercion -> [Coercion] -> Coercion

-- | Apply a type constructor to a list of coercions. It is the caller's
--   responsibility to get the roles correct on argument coercions.
mkTyConAppCo :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Coercion

-- | Build a function <a>Coercion</a> from two other <a>Coercion</a>s. That
--   is, given <tt>co1 :: a ~ b</tt> and <tt>co2 :: x ~ y</tt> produce
--   <tt>co :: (a -&gt; x) ~ (b -&gt; y)</tt> or <tt>(a =&gt; x) ~ (b =&gt;
--   y)</tt>, depending on the kind of <tt>a</tt>/<tt>b</tt>. This (most
--   common) version takes a single FunTyFlag, which is used for both
--   fco_afl and ftf_afr of the FunCo
mkFunCo1 :: HasDebugCallStack => Role -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunCo2 :: HasDebugCallStack => Role -> FunTyFlag -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunCoNoFTF :: HasDebugCallStack => Role -> CoercionN -> Coercion -> Coercion -> Coercion
mkFunResCo :: Role -> Id -> Coercion -> Coercion
mkNakedFunCo1 :: Role -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion
mkNakedFunCo2 :: Role -> FunTyFlag -> FunTyFlag -> CoercionN -> Coercion -> Coercion -> Coercion

-- | Make a Coercion from a tycovar, a kind coercion, and a body coercion.
--   The kind of the tycovar should be the left-hand kind of the kind
--   coercion. See Note [Unused coercion variable in ForAllCo]
mkForAllCo :: TyCoVar -> CoercionN -> Coercion -> Coercion

-- | Make nested ForAllCos
mkForAllCos :: [(TyCoVar, CoercionN)] -> Coercion -> Coercion

-- | Make a Coercion quantified over a type/coercion variable; the variable
--   has the same type in both sides of the coercion
mkHomoForAllCos :: [TyCoVar] -> Coercion -> Coercion

-- | Make a phantom coercion between two types. The coercion passed in must
--   be a nominal coercion between the kinds of the types.
mkPhantomCo :: Coercion -> Type -> Type -> Coercion

-- | Make a coercion from a coercion hole
mkHoleCo :: CoercionHole -> Coercion

-- | Make a universal coercion between two arbitrary types.
mkUnivCo :: UnivCoProvenance -> Role -> Type -> Type -> Coercion
mkSubCo :: HasDebugCallStack => Coercion -> Coercion
mkAxiomInstCo :: CoAxiom Branched -> BranchIndex -> [Coercion] -> Coercion

-- | Make a "coercion between coercions".
mkProofIrrelCo :: Role -> CoercionN -> Coercion -> Coercion -> Coercion

-- | Like <a>downgradeRole_maybe</a>, but panics if the change isn't a
--   downgrade. See Note [Role twiddling functions]
downgradeRole :: Role -> Role -> Coercion -> Coercion
mkAxiomRuleCo :: CoAxiomRule -> [Coercion] -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, produces <tt>co' ::
--   ty ~r (ty |&gt; co)</tt>
mkGReflRightCo :: Role -> Type -> CoercionN -> Coercion

-- | Given <tt>r</tt>, <tt>ty :: k1</tt>, and <tt>co :: k1 ~N k2</tt>,
--   produces <tt>co' :: (ty |&gt; co) ~r ty</tt>
mkGReflLeftCo :: Role -> Type -> CoercionN -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty ~r
--   ty'</tt>, produces @co' :: (ty |&gt; co) ~r ty' It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceLeftCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty' ~r
--   ty</tt>, produces @co' :: ty' ~r (ty |&gt; co) It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceRightCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>co :: (a :: k) ~ (b :: k')</tt> produce <tt>co' :: k ~
--   k'</tt>.
mkKindCo :: Coercion -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind g h1 h2</tt>, where <tt>g :: t1 ~r t2</tt>,
--   has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt> and
--   <tt>h2</tt> must be nominal. It calls <tt>coercionKindRole</tt>, so
--   it's quite inefficient (which <tt>I</tt> stands for) Use
--   <tt>castCoercionKind2</tt> instead if <tt>t1</tt>, <tt>t2</tt>, and
--   <tt>r</tt> are known beforehand.
castCoercionKind :: Coercion -> CoercionN -> CoercionN -> Coercion

-- | <tt>castCoercionKind1 g r t1 t2 h</tt> = <tt>coercionKind g r t1 t2 h
--   h</tt> That is, it's a specialised form of castCoercionKind, where the
--   two kind coercions are identical <tt>castCoercionKind1 g r t1 t2
--   h</tt>, where <tt>g :: t1 ~r t2</tt>, has type <tt>(t1 |&gt; h) ~r (t2
--   |&gt; h)</tt>. <tt>h</tt> must be nominal. See Note
--   [castCoercionKind1]
castCoercionKind1 :: Coercion -> Role -> Type -> Type -> CoercionN -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind2 g r t1 t2 h1 h2</tt>, where <tt>g :: t1 ~r
--   t2</tt>, has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt>
--   and <tt>h2</tt> must be nominal.
castCoercionKind2 :: Coercion -> Role -> Type -> Type -> CoercionN -> CoercionN -> Coercion

-- | Creates a primitive type equality predicate. Invariant: the types are
--   not Coercions
mkPrimEqPred :: Type -> Type -> Type
mkReprPrimEqPred :: Type -> Type -> Type

-- | Makes a lifted equality predicate at the given role
mkPrimEqPredRole :: Role -> Type -> Type -> PredType

-- | Creates a primitive type equality predicate with explicit kinds
mkHeteroPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | Creates a primitive representational type equality predicate with
--   explicit kinds
mkHeteroReprPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | If `instNewTyCon_maybe T ts = Just (rep_ty, co)` then `co :: T ts ~R#
--   rep_ty`
--   
--   Checks for a newtype, and for being saturated
instNewTyCon_maybe :: TyCon -> [Type] -> Maybe (Type, Coercion)

-- | Try one stepper and then try the next, if the first doesn't make
--   progress. So if it returns NS_Done, it means that both steppers are
--   satisfied
composeSteppers :: NormaliseStepper ev -> NormaliseStepper ev -> NormaliseStepper ev

-- | A <a>NormaliseStepper</a> that unwraps newtypes, careful not to fall
--   into a loop. If it would fall into a loop, it produces
--   <a>NS_Abort</a>.
unwrapNewTypeStepper :: NormaliseStepper Coercion

-- | Sometimes we want to look through a <tt>newtype</tt> and get its
--   associated coercion. This function strips off <tt>newtype</tt> layers
--   enough to reveal something that isn't a <tt>newtype</tt>.
--   Specifically, here's the invariant:
--   
--   <pre>
--   topNormaliseNewType_maybe rec_nts ty = Just (co, ty')
--   </pre>
--   
--   then (a) <tt>co : ty ~R ty'</tt>. (b) ty' is not a newtype.
--   
--   The function returns <tt>Nothing</tt> for non-<tt>newtypes</tt>, or
--   unsaturated applications
--   
--   This function does *not* look through type families, because it has no
--   access to the type family environment. If you do have that at hand,
--   consider to use topNormaliseType_maybe, which should be a drop-in
--   replacement for topNormaliseNewType_maybe If topNormliseNewType_maybe
--   ty = Just (co, ty'), then co : ty ~R ty'
topNormaliseNewType_maybe :: Type -> Maybe (Coercion, Type)

-- | A general function for normalising the top-level of a type. It
--   continues to use the provided <a>NormaliseStepper</a> until that
--   function fails, and then this function returns. The roles of the
--   coercions produced by the <a>NormaliseStepper</a> must all be the
--   same, which is the role returned from the call to
--   <a>topNormaliseTypeX</a>.
--   
--   Typically ev is Coercion.
--   
--   If topNormaliseTypeX step plus ty = Just (ev, ty') then ty ~ev1~ t1
--   ~ev2~ t2 ... ~evn~ ty' and ev = ev1 <tt>plus</tt> ev2 <tt>plus</tt>
--   ... <tt>plus</tt> evn If it returns Nothing then no newtype unwrapping
--   could happen
topNormaliseTypeX :: NormaliseStepper ev -> (ev -> ev -> ev) -> Type -> Maybe (ev, Type)

-- | This breaks a <a>Coercion</a> with type <tt>T A B C ~ T D E F</tt>
--   into a list of <a>Coercion</a>s of kinds <tt>A ~ D</tt>, <tt>B ~
--   E</tt> and <tt>E ~ F</tt>. Hence:
--   
--   <pre>
--   decomposeCo 3 c [r1, r2, r3] = [nth r1 0 c, nth r2 1 c, nth r3 2 c]
--   </pre>
decomposeCo :: Arity -> Coercion -> Infinite Role -> [Coercion]
decomposeFunCo :: HasDebugCallStack => Coercion -> (CoercionN, Coercion, Coercion)
decomposePiCos :: HasDebugCallStack => CoercionN -> Pair Type -> [Type] -> ([CoercionN], CoercionN)

-- | Extract a covar, if possible. This check is dirty. Be ashamed of
--   yourself. (It's dirty because it cares about the structure of a
--   coercion, which is morally reprehensible.)
getCoVar_maybe :: Coercion -> Maybe CoVar

-- | Attempt to take a coercion application apart.
splitAppCo_maybe :: Coercion -> Maybe (Coercion, Coercion)
splitFunCo_maybe :: Coercion -> Maybe (Coercion, Coercion)
splitForAllCo_maybe :: Coercion -> Maybe (TyCoVar, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for tyvar
--   binder
splitForAllCo_ty_maybe :: Coercion -> Maybe (TyVar, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for covar
--   binder
splitForAllCo_co_maybe :: Coercion -> Maybe (CoVar, Coercion, Coercion)
tyConRole :: Role -> TyCon -> Int -> Role
tyConRolesX :: Role -> TyCon -> Infinite Role
tyConRolesRepresentational :: TyCon -> Infinite Role

-- | Converts a coercion to be nominal, if possible. See Note [Role
--   twiddling functions]
setNominalRole_maybe :: Role -> Coercion -> Maybe CoercionN
tyConRoleListX :: Role -> TyCon -> [Role]
tyConRoleListRepresentational :: TyCon -> [Role]
funRole :: Role -> FunSel -> Role
pickLR :: LeftOrRight -> (a, a) -> a

-- | Tests if this coercion is obviously a generalized reflexive coercion.
--   Guaranteed to work very quickly.
isGReflCo :: Coercion -> Bool

-- | Tests if this coercion is obviously reflexive. Guaranteed to work very
--   quickly. Sometimes a coercion can be reflexive, but not obviously so.
--   c.f. <a>isReflexiveCo</a>
isReflCo :: Coercion -> Bool

-- | Returns the type coerced if this coercion is reflexive. Guaranteed to
--   work very quickly. Sometimes a coercion can be reflexive, but not
--   obviously so. c.f. <a>isReflexiveCo_maybe</a>
isReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Returns the type coerced if this coercion is a generalized reflexive
--   coercion. Guaranteed to work very quickly.
isGReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Slowly checks if the coercion is reflexive. Don't call this in a loop,
--   as it walks over the entire coercion.
isReflexiveCo :: Coercion -> Bool

-- | Extracts the coerced type from a reflexive coercion. This potentially
--   walks over the entire coercion, so avoid doing this in a loop.
isReflexiveCo_maybe :: Coercion -> Maybe (Type, Role)
isReflCoVar_maybe :: Var -> Maybe Coercion

-- | Tests if this MCoercion is obviously generalized reflexive Guaranteed
--   to work very quickly.
isGReflMCo :: MCoercion -> Bool
mkGReflLeftMCo :: Role -> Type -> MCoercionN -> Coercion
mkGReflRightMCo :: Role -> Type -> MCoercionN -> Coercion

-- | Like <a>mkCoherenceRightCo</a>, but with an <a>MCoercion</a>
mkCoherenceRightMCo :: Role -> Type -> MCoercionN -> Coercion -> Coercion
coToMCo :: Coercion -> MCoercion

-- | Compose two MCoercions via transitivity
mkTransMCo :: MCoercion -> MCoercion -> MCoercion
mkTransMCoL :: MCoercion -> Coercion -> MCoercion
mkTransMCoR :: Coercion -> MCoercion -> MCoercion

-- | Cast a type by an <a>MCoercion</a>
mkCastTyMCo :: Type -> MCoercion -> Type

-- | Get the reverse of an <a>MCoercion</a>
mkSymMCo :: MCoercion -> MCoercion
mkHomoForAllMCo :: TyCoVar -> MCoercion -> MCoercion
mkFunResMCo :: Id -> MCoercionR -> MCoercionR
mkPiMCos :: [Var] -> MCoercion -> MCoercion
isReflMCo :: MCoercion -> Bool
checkReflexiveMCo :: MCoercion -> MCoercion
mkCoVar :: Name -> Type -> CoVar

-- | Is this a coercion variable? Satisfies <tt><a>isId</a> v ==&gt;
--   <a>isCoVar</a> v == not (<a>isNonCoVarId</a> v)</tt>.
isCoVar :: Var -> Bool
coVarName :: CoVar -> Name
setCoVarName :: CoVar -> Name -> CoVar
setCoVarUnique :: CoVar -> Unique -> CoVar
tyCoVarsOfCo :: Coercion -> TyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet
coVarsOfCo :: Coercion -> CoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
coercionSize :: Coercion -> Int
anyFreeVarsOfCo :: (TyCoVar -> Bool) -> Coercion -> Bool
emptyCvSubstEnv :: CvSubstEnv
lookupCoVar :: Subst -> Var -> Maybe Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasDebugCallStack => Subst -> [Coercion] -> [Coercion]
substCoVar :: Subst -> CoVar -> Coercion
substCoVars :: Subst -> [CoVar] -> [Coercion]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasDebugCallStack => [TyVar] -> [Type] -> Coercion -> Coercion
substCoVarBndr :: HasDebugCallStack => Subst -> CoVar -> (Subst, CoVar)
extendTvSubstAndInScope :: Subst -> TyVar -> Type -> Subst
getCvSubstEnv :: Subst -> CvSubstEnv

-- | <tt>liftCoSubst role lc ty</tt> produces a coercion (at role
--   <tt>role</tt>) that coerces between <tt>lc_left(ty)</tt> and
--   <tt>lc_right(ty)</tt>, where <tt>lc_left</tt> is a substitution
--   mapping type variables to the left-hand types of the mapped coercions
--   in <tt>lc</tt>, and similar for <tt>lc_right</tt>.
liftCoSubst :: HasDebugCallStack => Role -> LiftingContext -> Type -> Coercion
liftCoSubstTyVar :: LiftingContext -> Role -> TyVar -> Maybe Coercion
liftCoSubstWith :: Role -> [TyCoVar] -> [Coercion] -> Type -> Coercion
liftCoSubstWithEx :: Role -> [TyVar] -> [Coercion] -> [TyCoVar] -> [Type] -> (Type -> Coercion, [Type])
emptyLiftingContext :: InScopeSet -> LiftingContext

-- | Extend a lifting context with a new mapping.
extendLiftingContext :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext

-- | Extend a lifting context with a new mapping, and extend the in-scope
--   set
extendLiftingContextAndInScope :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext
liftCoSubstVarBndrUsing :: (r -> CoercionN) -> (LiftingContext -> Type -> r) -> LiftingContext -> TyCoVar -> (LiftingContext, TyCoVar, r)

-- | Is a var in the domain of a lifting context?
isMappedByLC :: TyCoVar -> LiftingContext -> Bool
mkSubstLiftingContext :: Subst -> LiftingContext

-- | Erase the environments in a lifting context
zapLiftingContext :: LiftingContext -> LiftingContext

-- | Like <a>substForAllCoBndr</a>, but works on a lifting context
substForAllCoBndrUsingLC :: Bool -> (Coercion -> Coercion) -> LiftingContext -> TyCoVar -> Coercion -> (LiftingContext, TyCoVar, Coercion)

-- | Extract the underlying substitution from the LiftingContext
lcSubst :: LiftingContext -> Subst

-- | Get the <a>InScopeSet</a> from a <a>LiftingContext</a>
lcInScopeSet :: LiftingContext -> InScopeSet
liftEnvSubstLeft :: Subst -> LiftCoEnv -> Subst
liftEnvSubstRight :: Subst -> LiftCoEnv -> Subst
substRightCo :: LiftingContext -> Coercion -> Coercion
substLeftCo :: LiftingContext -> Coercion -> Coercion

-- | Apply "sym" to all coercions in a <a>LiftCoEnv</a>
swapLiftCoEnv :: LiftCoEnv -> LiftCoEnv
lcSubstLeft :: LiftingContext -> Subst
lcSubstRight :: LiftingContext -> Subst

-- | Syntactic equality of coercions
eqCoercion :: Coercion -> Coercion -> Bool

-- | Compare two <a>Coercion</a>s, with respect to an RnEnv2
eqCoercionX :: RnEnv2 -> Coercion -> Coercion -> Bool
seqCo :: Coercion -> ()
pprCo :: Coercion -> SDoc
pprParendCo :: Coercion -> SDoc
pprCoAxiom :: CoAxiom br -> SDoc
pprCoAxBranch :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchLHS :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchUser :: TyCon -> CoAxBranch -> SDoc
tidyCoAxBndrsForUser :: TidyEnv -> [Var] -> (TidyEnv, [Var])
etaExpandCoAxBranch :: CoAxBranch -> ([TyVar], [Type], Type)

-- | Tidy a Coercion
--   
--   See Note [Strictness in tidyType and friends]
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]

-- | like mkKindCo, but aggressively &amp; recursively optimizes to avoid
--   using a KindCo constructor. The output role is nominal.
promoteCoercion :: Coercion -> CoercionN

-- | Assuming that two types are the same, ignoring coercions, find a
--   nominal coercion between the types. This is useful when optimizing
--   transitivity over coercion applications, where splitting two AppCos
--   might yield different kinds. See Note [EtaAppCo] in
--   <a>GHC.Core.Coercion.Opt</a>.
buildCoercion :: Type -> Type -> CoercionN
multToCo :: Mult -> Coercion

-- | Given a coercion `co :: (t1 :: TYPE r1) ~ (t2 :: TYPE r2)` produce a
--   coercion `rep_co :: r1 ~ r2` But actually it is possible that co ::
--   (t1 :: CONSTRAINT r1) ~ (t2 :: CONSTRAINT r2) or co :: (t1 :: TYPE r1)
--   ~ (t2 :: CONSTRAINT r2) or co :: (t1 :: CONSTRAINT r1) ~ (t2 :: TYPE
--   r2) See Note [mkRuntimeRepCo]
mkRuntimeRepCo :: HasDebugCallStack => Coercion -> Coercion

-- | Is there a coercion hole in this type?
hasCoercionHoleTy :: Type -> Bool

-- | Is there a coercion hole in this coercion?
hasCoercionHoleCo :: Coercion -> Bool
hasThisCoercionHoleTy :: Type -> CoercionHole -> Bool

-- | Set the type of a <a>CoercionHole</a>
setCoHoleType :: CoercionHole -> Type -> CoercionHole

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique
type PsWarning = PsMessage
type PsError = PsMessage

-- | A collection of messages emitted by GHC during error reporting. A
--   diagnostic message is typically a warning or an error. See Note
--   [Messages].
--   
--   <i>INVARIANT</i>: All the messages in this collection must be
--   relevant, i.e. their <a>Severity</a> should <i>not</i> be
--   <a>SevIgnore</a>. The smart constructor <a>mkMessages</a> will filter
--   out any message which <a>Severity</a> is <a>SevIgnore</a>.
data Messages e
data HsParsedModule

-- | Attempt to convert a Template Haskell name to one that GHC can
--   understand. Original TH names such as those you get when you use the
--   <tt>'foo</tt> syntax will be translated to their equivalent GHC name
--   exactly. Qualified or unqualified TH names will be dynamically bound
--   to names in the module being compiled, if possible. Exact TH names
--   will be bound to the name they represent, exactly.
thNameToGhcName :: Name -> CoreM (Maybe Name)

-- | Attempt to convert a Template Haskell name to one that GHC can
--   understand. Original TH names such as those you get when you use the
--   <tt>'foo</tt> syntax will be translated to their equivalent GHC name
--   exactly. Qualified or unqualified TH names will be dynamically bound
--   to names in the module being compiled, if possible. Exact TH names
--   will be bound to the name they represent, exactly.
--   
--   One must be careful to consistently use the same <a>NameCache</a> to
--   create identifier that might be compared. (C.f. how the <a>ST</a>
--   Monad enforces that variables from separate <a>runST</a> invocations
--   are never intermingled; it would be valid to use the same tricks for
--   <a>Name</a>s and <a>NameCache</a>s.)
--   
--   For now, the easiest and recommended way to ensure a consistent
--   <a>NameCache</a> is used it to retrieve the preexisting one from an
--   active <a>HscEnv</a>. A single <a>HscEnv</a> is created per GHC
--   "session", and this ensures everything in that session will get the
--   same name cache.
thNameToGhcNameIO :: NameCache -> Name -> IO (Maybe Name)
instance GHC.Types.TyThing.MonadThings GHC.Core.Opt.Monad.CoreM


-- | Tidying up Core
module GHC.Iface.Tidy
data TidyOpts
TidyOpts :: !NameCache -> !Bool -> !UnfoldingOpts -> !UnfoldingExposure -> !Bool -> !Bool -> !Maybe StaticPtrOpts -> TidyOpts
[opt_name_cache] :: TidyOpts -> !NameCache

-- | Always true if we compile with -prof
[opt_collect_ccs] :: TidyOpts -> !Bool
[opt_unfolding_opts] :: TidyOpts -> !UnfoldingOpts

-- | Which unfoldings to expose
[opt_expose_unfoldings] :: TidyOpts -> !UnfoldingExposure

-- | trim off the arity, one-shot-ness, strictness etc which were retained
--   for the benefit of the code generator
[opt_trim_ids] :: TidyOpts -> !Bool

-- | Are rules exposed or not?
[opt_expose_rules] :: TidyOpts -> !Bool

-- | Options for generated static pointers, if enabled (/= Nothing).
[opt_static_ptr_opts] :: TidyOpts -> !Maybe StaticPtrOpts
data UnfoldingExposure

-- | Don't expose unfoldings
ExposeNone :: UnfoldingExposure

-- | Only expose required unfoldings
ExposeSome :: UnfoldingExposure

-- | Expose all unfoldings
ExposeAll :: UnfoldingExposure
tidyProgram :: TidyOpts -> ModGuts -> IO (CgGuts, ModDetails)
mkBootModDetailsTc :: Logger -> TcGblEnv -> IO ModDetails
instance GHC.Classes.Ord GHC.Iface.Tidy.UnfoldingExposure
instance GHC.Classes.Eq GHC.Iface.Tidy.UnfoldingExposure
instance GHC.Show.Show GHC.Iface.Tidy.UnfoldingExposure
instance GHC.Base.Functor GHC.Iface.Tidy.DFFV
instance GHC.Base.Applicative GHC.Iface.Tidy.DFFV
instance GHC.Base.Monad GHC.Iface.Tidy.DFFV

module GHC.Driver.Config.Tidy
initTidyOpts :: HscEnv -> IO TidyOpts
initStaticPtrOpts :: HscEnv -> IO StaticPtrOpts

module GHC.CoreToStg.Prep
data CorePrepConfig
CorePrepConfig :: !Bool -> !LitNumType -> Integer -> Maybe CoreExpr -> !Bool -> !Bool -> CorePrepConfig

-- | Whether to generate a default alternative with <a>`error`</a> in these
--   cases. This is helpful when debugging demand analysis or type checker
--   bugs which can sometimes manifest as segmentation faults.
[cp_catchNonexhaustiveCases] :: CorePrepConfig -> !Bool

-- | Convert some numeric literals (Integer, Natural) into their final Core
--   form.
[cp_convertNumLit] :: CorePrepConfig -> !LitNumType -> Integer -> Maybe CoreExpr

-- | Whether to perform speculative evaluation See Note [Controlling
--   Speculative Evaluation]
[cp_specEval] :: CorePrepConfig -> !Bool

-- | Whether to perform speculative evaluation on DFuns
[cp_specEvalDFun] :: CorePrepConfig -> !Bool
data CorePrepPgmConfig
CorePrepPgmConfig :: !EndPassConfig -> !Bool -> CorePrepPgmConfig
[cpPgm_endPassConfig] :: CorePrepPgmConfig -> !EndPassConfig
[cpPgm_generateDebugInfo] :: CorePrepPgmConfig -> !Bool
corePrepPgm :: Logger -> CorePrepConfig -> CorePrepPgmConfig -> Module -> ModLocation -> CoreProgram -> [TyCon] -> IO CoreProgram
corePrepExpr :: Logger -> CorePrepConfig -> CoreExpr -> IO CoreExpr

-- | Create a function that converts Bignum literals into their final
--   CoreExpr
mkConvertNumLiteral :: Platform -> HomeUnit -> (Name -> IO TyThing) -> IO (LitNumType -> Integer -> Maybe CoreExpr)
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.Floats
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.OkToSpec
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.FloatingBind
instance GHC.Utils.Outputable.Outputable GHC.CoreToStg.Prep.ArgInfo

module GHC.Driver.Config.CoreToStg.Prep
initCorePrepConfig :: HscEnv -> IO CorePrepConfig
initCorePrepPgmConfig :: DynFlags -> [Var] -> CorePrepPgmConfig


-- | The <tt>FamInst</tt> type: family instance heads
module GHC.Tc.Instance.Family
type FamInstEnvs = (FamInstEnv, FamInstEnv)
tcGetFamInstEnvs :: TcM FamInstEnvs
checkFamInstConsistency :: [Module] -> TcM ()
tcExtendLocalFamInstEnv :: [FamInst] -> TcM a -> TcM a

-- | Like <a>tcLookupDataFamInst_maybe</a>, but returns the arguments back
--   if there is no data family to unwrap. Returns a Representational
--   coercion
tcLookupDataFamInst :: FamInstEnvs -> TyCon -> [TcType] -> (TyCon, [TcType], Coercion)

-- | Converts a data family type (eg F [a]) to its representation type (eg
--   FList a) and returns a coercion between the two: co :: F [a] ~R FList
--   a.
tcLookupDataFamInst_maybe :: FamInstEnvs -> TyCon -> [TcType] -> Maybe (TyCon, [TcType], Coercion)

-- | If <tt>co :: T ts ~ rep_ty</tt> then:
--   
--   <pre>
--   instNewTyCon_maybe T ts = Just (rep_ty, co)
--   </pre>
--   
--   Checks for a newtype, and for being saturated Just like
--   Coercion.instNewTyCon_maybe, but returns a TcCoercion
tcInstNewTyCon_maybe :: TyCon -> [TcType] -> Maybe (TcType, TcCoercion)

-- | <a>tcTopNormaliseNewTypeTF_maybe</a> gets rid of top-level newtypes,
--   potentially looking through newtype <i>instances</i> and type
--   synonyms.
--   
--   It is only used by the type inference engine (specifically, when
--   solving representational equality), and hence it is careful to unwrap
--   only if the relevant data constructor is in scope. That's why it gets
--   a GlobalRdrEnv argument.
--   
--   It is careful not to unwrap data/newtype instances nor synonyms if it
--   can't continue unwrapping. Such care is necessary for proper error
--   messages.
--   
--   It does not look through type families. It does not normalise
--   arguments to a tycon.
--   
--   If the result is Just ((gres, co), rep_ty), then co : ty ~R rep_ty
--   gres are the GREs for the data constructors that had to be in scope
tcTopNormaliseNewTypeTF_maybe :: FamInstEnvs -> GlobalRdrEnv -> Type -> Maybe ((Bag GlobalRdrElt, TcCoercion), Type)
newFamInst :: FamFlavor -> CoAxiom Unbranched -> TcM FamInst

-- | Report a list of injectivity errors together with their source
--   locations. Looks only at one equation; does not look for conflicts
--   *among* equations.
reportInjectivityErrors :: DynFlags -> CoAxiom br -> CoAxBranch -> [Bool] -> TcM ()

-- | Report error message for a pair of equations violating an injectivity
--   annotation. No error message if there are no branches.
reportConflictingInjectivityErrs :: TyCon -> [CoAxBranch] -> CoAxBranch -> TcM ()

module GHC.Tc.Errors

-- | Report unsolved goals as errors or warnings. We may also turn some
--   into deferred run-time errors if `-fdefer-type-errors` is on.
reportUnsolved :: WantedConstraints -> TcM (Bag EvBind)

-- | Report *all* unsolved goals as errors, even if -fdefer-type-errors is
--   on However, do not make any evidence bindings, because we don't have
--   any convenient place to put them. NB: Type-level holes are OK, because
--   there are no bindings. See Note [Deferring coercion errors to runtime]
--   Used by solveEqualities for kind equalities (see Note [Failure in
--   local type signatures] in GHC.Tc.Solver)
reportAllUnsolved :: WantedConstraints -> TcM ()

-- | Report all unsolved goals as warnings (but without deferring any
--   errors to run-time). See Note [Safe Haskell Overlapping Instances
--   Implementation] in <a>GHC.Tc.Solver</a>
warnAllUnsolved :: WantedConstraints -> TcM ()
warnDefaulting :: TcTyVar -> [Ct] -> Type -> TcM ()

-- | If the <a>TcSolverReportMsg</a> is a type mismatch between an actual
--   and an expected type, return the actual and expected types (in that
--   order).
--   
--   Prefer using this over manually inspecting the
--   <a>TcSolverReportMsg</a> datatype if you just want this information,
--   as the datatype itself is subject to change across GHC versions.
solverReportMsg_ExpectedActuals :: TcSolverReportMsg -> [(Type, Type)]

module GHC.Rename.Fixity
type MiniFixityEnv = FastStringEnv (Located Fixity)
addLocalFixities :: MiniFixityEnv -> [Name] -> RnM a -> RnM a
lookupFixityRn :: Name -> RnM Fixity

-- | <a>lookupFixityRn_help</a> returns <tt>(True, fixity)</tt> if it finds
--   a <a>Fixity</a> in a local environment or from an interface file.
--   Otherwise, it returns <tt>(False, fixity)</tt> (e.g., for unbound
--   <a>Name</a>s or <a>Name</a>s without user-supplied fixity
--   declarations).
lookupFixityRn_help :: Name -> RnM (Bool, Fixity)

-- | Look up the fixity of an occurrence of a record field selector. We use
--   <a>lookupFixityRn'</a> so that we can specify the <a>OccName</a> as
--   the field label, which might be different to the <a>OccName</a> of the
--   selector <a>Name</a> if <tt>DuplicateRecordFields</tt> is in use
--   (#1173).
lookupFieldFixityRn :: FieldOcc GhcRn -> RnM Fixity
lookupTyFixityRn :: LocatedN Name -> RnM Fixity

module GHC.Rename.Env
newTopSrcBinder :: LocatedN RdrName -> RnM Name
lookupLocatedTopBndrRn :: Located RdrName -> RnM (Located Name)
lookupLocatedTopBndrRnN :: LocatedN RdrName -> RnM (LocatedN Name)
lookupTopBndrRn :: WhatLooking -> RdrName -> RnM Name
lookupLocatedTopConstructorRn :: Located RdrName -> RnM (Located Name)
lookupLocatedTopConstructorRnN :: LocatedN RdrName -> RnM (LocatedN Name)
lookupLocatedOccRn :: GenLocated (SrcSpanAnn' ann) RdrName -> TcRn (GenLocated (SrcSpanAnn' ann) Name)
lookupLocatedOccRnConstr :: GenLocated (SrcSpanAnn' ann) RdrName -> TcRn (GenLocated (SrcSpanAnn' ann) Name)
lookupLocatedOccRnRecField :: GenLocated (SrcSpanAnn' ann) RdrName -> TcRn (GenLocated (SrcSpanAnn' ann) Name)
lookupLocatedOccRnNone :: GenLocated (SrcSpanAnn' ann) RdrName -> TcRn (GenLocated (SrcSpanAnn' ann) Name)
lookupOccRn :: RdrName -> RnM Name
lookupOccRn_maybe :: RdrName -> RnM (Maybe Name)
lookupLocalOccRn_maybe :: RdrName -> RnM (Maybe Name)
lookupInfoOccRn :: RdrName -> RnM [Name]
lookupLocalOccThLvl_maybe :: Name -> RnM (Maybe (TopLevelFlag, ThLevel))
lookupLocalOccRn :: RdrName -> RnM Name
lookupTypeOccRn :: RdrName -> RnM Name
lookupGlobalOccRn :: RdrName -> RnM Name
lookupGlobalOccRn_maybe :: RdrName -> RnM (Maybe Name)

-- | Result of looking up an occurrence that might be an ambiguous field.
data AmbiguousResult

-- | Occurrence picked out a single name, which may or may not belong to a
--   field (or might be unbound, if an error has been reported already, per
--   Note [ Unbound vs Ambiguous Names ]).
UnambiguousGre :: GreName -> AmbiguousResult

-- | Occurrence picked out two or more fields, and no non-fields. For now
--   this is allowed by DuplicateRecordFields in certain circumstances, as
--   the type-checker may be able to disambiguate later.
AmbiguousFields :: AmbiguousResult

-- | Look up a <a>RdrName</a> used as a variable in an expression.
--   
--   This may be a local variable, global variable, or one or more record
--   selector functions. It will not return record fields created with the
--   <tt>NoFieldSelectors</tt> extension (see Note [NoFieldSelectors]).
--   
--   If the name is not in scope at the term level, but its promoted
--   equivalent is in scope at the type level, the lookup will succeed (so
--   that the type-checker can report a more informative error later). See
--   Note [Promotion].
lookupExprOccRn :: RdrName -> RnM (Maybe GreName)

-- | Look up an occurrence of a field in record construction or pattern
--   matching (but not update). When the -XDisambiguateRecordFields flag is
--   on, take account of the data constructor name to disambiguate which
--   field to use.
--   
--   See Note [DisambiguateRecordFields] and Note [NoFieldSelectors].
lookupRecFieldOcc :: Maybe Name -> RdrName -> RnM Name

-- | Look up an occurrence of a field in a record update, returning the
--   selector name.
--   
--   Unlike construction and pattern matching with
--   <tt>-XDisambiguateRecordFields</tt> (see <a>lookupRecFieldOcc</a>),
--   there is no data constructor to help disambiguate, so this may be
--   ambiguous if the field is in scope multiple times. However we ignore
--   non-fields in scope with the same name if
--   <tt>-XDisambiguateRecordFields</tt> is on (see Note
--   [DisambiguateRecordFields for updates]).
--   
--   Here a field is in scope even if <tt>NoFieldSelectors</tt> was enabled
--   at its definition site (see Note [NoFieldSelectors]).
lookupRecFieldOcc_update :: DuplicateRecordFields -> RdrName -> RnM AmbiguousResult
data ChildLookupResult
NameNotFound :: ChildLookupResult
IncorrectParent :: Name -> GreName -> [Name] -> ChildLookupResult
FoundChild :: Parent -> GreName -> ChildLookupResult

-- | Used in export lists to lookup the children.
lookupSubBndrOcc_helper :: Bool -> Bool -> Name -> RdrName -> RnM ChildLookupResult

-- | Specialised version of msum for RnM ChildLookupResult
combineChildLookupResult :: [RnM ChildLookupResult] -> RnM ChildLookupResult
data HsSigCtxt
TopSigCtxt :: NameSet -> HsSigCtxt
LocalBindCtxt :: NameSet -> HsSigCtxt
ClsDeclCtxt :: Name -> HsSigCtxt
InstDeclCtxt :: NameSet -> HsSigCtxt
HsBootCtxt :: NameSet -> HsSigCtxt
RoleAnnotCtxt :: NameSet -> HsSigCtxt
lookupLocalTcNames :: HsSigCtxt -> SDoc -> RdrName -> RnM [(RdrName, Name)]
lookupSigOccRn :: HsSigCtxt -> Sig GhcPs -> LocatedA RdrName -> RnM (LocatedA Name)
lookupSigOccRnN :: HsSigCtxt -> Sig GhcPs -> LocatedN RdrName -> RnM (LocatedN Name)

-- | Lookup a name in relation to the names in a <a>HsSigCtxt</a>
lookupSigCtxtOccRn :: HsSigCtxt -> SDoc -> LocatedA RdrName -> RnM (LocatedA Name)

-- | Lookup a name in relation to the names in a <a>HsSigCtxt</a>
lookupSigCtxtOccRnN :: HsSigCtxt -> SDoc -> LocatedN RdrName -> RnM (LocatedN Name)
lookupInstDeclBndr :: Name -> SDoc -> RdrName -> RnM Name
lookupFamInstName :: Maybe Name -> LocatedN RdrName -> RnM (LocatedN Name)
lookupConstructorFields :: Name -> RnM [FieldLabel]
lookupGreAvailRn :: RdrName -> RnM (Name, AvailInfo)
lookupSyntax :: Name -> RnM (SyntaxExpr GhcRn, FreeVars)
lookupSyntaxExpr :: Name -> RnM (HsExpr GhcRn, FreeVars)
lookupSyntaxNames :: [Name] -> RnM ([HsExpr GhcRn], FreeVars)
lookupSyntaxName :: Name -> RnM (Name, FreeVars)
lookupIfThenElse :: RnM (Maybe Name)
lookupQualifiedDoExpr :: HsStmtContext p -> Name -> RnM (HsExpr GhcRn, FreeVars)
lookupQualifiedDo :: HsStmtContext p -> Name -> RnM (SyntaxExpr GhcRn, FreeVars)
lookupQualifiedDoName :: HsStmtContext p -> Name -> RnM (Name, FreeVars)
lookupNameWithQualifier :: Name -> ModuleName -> RnM (Name, FreeVars)
addUsedGRE :: Bool -> GlobalRdrElt -> RnM ()
addUsedGREs :: [GlobalRdrElt] -> RnM ()
addUsedDataCons :: GlobalRdrEnv -> TyCon -> RnM ()
dataTcOccs :: RdrName -> [RdrName]
instance GHC.Classes.Eq GHC.Rename.Env.FieldsOrSelectors
instance GHC.Utils.Outputable.Outputable GHC.Rename.Env.HsSigCtxt
instance GHC.Utils.Outputable.Outputable GHC.Rename.Env.ChildLookupResult
instance GHC.Utils.Outputable.Outputable GHC.Rename.Env.DisambigInfo
instance GHC.Base.Semigroup GHC.Rename.Env.DisambigInfo
instance GHC.Base.Monoid GHC.Rename.Env.DisambigInfo

module GHC.Tc.Instance.Class
matchGlobalInst :: DynFlags -> Bool -> Class -> [Type] -> TcM ClsInstResult
data ClsInstResult
NoInstance :: ClsInstResult
OneInst :: [TcPredType] -> ([EvExpr] -> EvTerm) -> InstanceWhat -> ClsInstResult
[cir_new_theta] :: ClsInstResult -> [TcPredType]
[cir_mk_ev] :: ClsInstResult -> [EvExpr] -> EvTerm
[cir_what] :: ClsInstResult -> InstanceWhat
NotSure :: ClsInstResult
data InstanceWhat
BuiltinEqInstance :: InstanceWhat
BuiltinTypeableInstance :: TyCon -> InstanceWhat
BuiltinInstance :: InstanceWhat
LocalInstance :: InstanceWhat
TopLevInstance :: DFunId -> SafeOverlapping -> InstanceWhat
[iw_dfun_id] :: InstanceWhat -> DFunId
[iw_safe_over] :: InstanceWhat -> SafeOverlapping
safeOverlap :: InstanceWhat -> Bool
instanceReturnsDictCon :: InstanceWhat -> Bool

-- | Extra information about the parent instance declaration, needed when
--   type-checking associated types. The <a>Class</a> is the enclosing
--   class, the [TyVar] are the <i>scoped</i> type variable of the instance
--   decl. The <tt>VarEnv Type</tt> maps class variables to their instance
--   types.
data AssocInstInfo
NotAssociated :: AssocInstInfo
InClsInst :: Class -> [TyVar] -> VarEnv Type -> AssocInstInfo
[ai_class] :: AssocInstInfo -> Class

-- | The <i>scoped</i> tyvars of the instance Why scoped? See bind_me in
--   <a>checkConsistentFamInst</a>
[ai_tyvars] :: AssocInstInfo -> [TyVar]

-- | Maps <i>class</i> tyvars to their instance types See Note [Matching in
--   the consistent-instantiation check]
[ai_inst_env] :: AssocInstInfo -> VarEnv Type
isNotAssociated :: AssocInstInfo -> Bool
instance GHC.Utils.Outputable.Outputable GHC.Tc.Instance.Class.ClsInstResult
instance GHC.Utils.Outputable.Outputable GHC.Tc.Instance.Class.InstanceWhat


-- | Monadic definitions for the constraint solver
module GHC.Tc.Solver.Monad
data TcS a
runTcS :: TcS a -> TcM (a, EvBindMap)

-- | This variant of <a>runTcS</a> will immediately fail upon encountering
--   an insoluble ct. See Note [Speeding up valid hole-fits]. Its one usage
--   site does not need the ev_binds, so we do not return them.
runTcSEarlyAbort :: TcS a -> TcM a
runTcSWithEvBinds :: EvBindsVar -> TcS a -> TcM a

-- | A variant of <a>runTcS</a> that takes and returns an <a>InertSet</a>
--   for later resumption of the <a>TcS</a> session.
runTcSInerts :: InertSet -> TcS a -> TcM (a, InertSet)
failTcS :: TcRnMessage -> TcS a
warnTcS :: TcRnMessage -> TcS ()
addErrTcS :: TcRnMessage -> TcS ()
wrapTcS :: TcM a -> TcS a

-- | Emit a warning within the <a>TcS</a> monad at the location given by
--   the <a>CtLoc</a>.
ctLocWarnTcS :: CtLoc -> TcRnMessage -> TcS ()

-- | This can deal only with equality constraints.
runTcSEqualities :: TcS a -> TcM a
nestTcS :: TcS a -> TcS a
nestImplicTcS :: EvBindsVar -> TcLevel -> TcS a -> TcS a
setEvBindsTcS :: EvBindsVar -> TcS a -> TcS a
emitImplicationTcS :: TcLevel -> SkolemInfoAnon -> [TcTyVar] -> [EvVar] -> Cts -> TcS TcEvBinds
emitTvImplicationTcS :: TcLevel -> SkolemInfoAnon -> [TcTyVar] -> Cts -> TcS ()
selectNextWorkItem :: TcS (Maybe Ct)
getWorkList :: TcS WorkList
updWorkListTcS :: (WorkList -> WorkList) -> TcS ()
pushLevelNoWorkList :: SDoc -> TcS a -> TcS (TcLevel, a)
runTcPluginTcS :: TcPluginM a -> TcS a
recordUsedGREs :: Bag GlobalRdrElt -> TcS ()
matchGlobalInst :: DynFlags -> Bool -> Class -> [Type] -> TcS ClsInstResult
data ClsInstResult
NoInstance :: ClsInstResult
OneInst :: [TcPredType] -> ([EvExpr] -> EvTerm) -> InstanceWhat -> ClsInstResult
[cir_new_theta] :: ClsInstResult -> [TcPredType]
[cir_mk_ev] :: ClsInstResult -> [EvExpr] -> EvTerm
[cir_what] :: ClsInstResult -> InstanceWhat
NotSure :: ClsInstResult
data QCInst
QCI :: CtEvidence -> [TcTyVar] -> TcPredType -> Bool -> QCInst
[qci_ev] :: QCInst -> CtEvidence
[qci_tvs] :: QCInst -> [TcTyVar]
[qci_pred] :: QCInst -> TcPredType
[qci_pend_sc] :: QCInst -> Bool
panicTcS :: SDoc -> TcS a
traceTcS :: String -> SDoc -> TcS ()
traceFireTcS :: CtEvidence -> SDoc -> TcS ()
bumpStepCountTcS :: TcS ()
csTraceTcS :: SDoc -> TcS ()
wrapErrTcS :: TcM a -> TcS a
wrapWarnTcS :: TcM a -> TcS a
resetUnificationFlag :: TcS Bool
setUnificationFlag :: TcLevel -> TcS ()
data MaybeNew
Fresh :: CtEvidence -> MaybeNew
Cached :: EvExpr -> MaybeNew
freshGoals :: [MaybeNew] -> [CtEvidence]
isFresh :: MaybeNew -> Bool
getEvExpr :: MaybeNew -> EvExpr
newTcEvBinds :: TcS EvBindsVar
newNoTcEvBinds :: TcS EvBindsVar

-- | Create a new Wanted constraint holding a coercion hole for an equality
--   between the two types at the given <a>Role</a>.
newWantedEq :: CtLoc -> RewriterSet -> Role -> TcType -> TcType -> TcS (CtEvidence, Coercion)

-- | Emit a new Wanted equality into the work-list
emitNewWantedEq :: CtLoc -> RewriterSet -> Role -> TcType -> TcType -> TcS Coercion

-- | Create a new Wanted constraint, potentially looking up non-equality
--   constraints in the cache instead of creating a new one from scratch.
--   
--   Deals with both equality and non-equality constraints.
newWanted :: CtLoc -> RewriterSet -> PredType -> TcS MaybeNew

-- | Create a new Wanted constraint.
--   
--   Deals with both equality and non-equality constraints.
--   
--   Does not attempt to re-use non-equality constraints that already exist
--   in the inert set.
newWantedNC :: CtLoc -> RewriterSet -> PredType -> TcS CtEvidence

-- | Create a new Wanted constraint holding an evidence variable.
--   
--   Don't use this for equality constraints: use <a>newWantedEq</a>
--   instead.
newWantedEvVarNC :: CtLoc -> RewriterSet -> TcPredType -> TcS CtEvidence

-- | Make a new <a>Id</a> of the given type, bound (in the monad's EvBinds)
--   to the given term
newBoundEvVarId :: TcPredType -> EvTerm -> TcS EvVar
unifyTyVar :: TcTyVar -> TcType -> TcS ()
reportUnifications :: TcS a -> TcS (Int, a)

-- | This is the key test for untouchability: See Note [Unification
--   preconditions] in GHC.Tc.Utils.Unify and Note [Solve by unification]
--   in GHC.Tc.Solver.Interact
--   
--   Returns a new rhs type, as this function can turn make some
--   metavariables concrete.
touchabilityTest :: CtFlavour -> TcTyVar -> TcType -> TcS (TouchabilityTestResult, TcType)
data TouchabilityTestResult
TouchableSameLevel :: TouchabilityTestResult
TouchableOuterLevel :: [TcTyVar] -> TcLevel -> TouchabilityTestResult
Untouchable :: TouchabilityTestResult
setEvBind :: EvBind -> TcS ()

-- | Equalities only
setWantedEq :: HasDebugCallStack => TcEvDest -> Coercion -> TcS ()

-- | Good for both equalities and non-equalities
setWantedEvTerm :: TcEvDest -> EvTerm -> TcS ()
setEvBindIfWanted :: CtEvidence -> EvTerm -> TcS ()
newEvVar :: TcPredType -> TcS EvVar
newGivenEvVar :: CtLoc -> (TcPredType, EvTerm) -> TcS CtEvidence
newGivenEvVars :: CtLoc -> [(TcPredType, EvTerm)] -> TcS [CtEvidence]

-- | Checks if the depth of the given location is too much. Fails if it's
--   too big, with an appropriate error message.
checkReductionDepth :: CtLoc -> TcType -> TcS ()
getSolvedDicts :: TcS (DictMap CtEvidence)
setSolvedDicts :: DictMap CtEvidence -> TcS ()
getInstEnvs :: TcS InstEnvs
getFamInstEnvs :: TcS (FamInstEnv, FamInstEnv)
getTopEnv :: TcS HscEnv
getGblEnv :: TcS TcGblEnv
getLclEnv :: TcS TcLclEnv
setLclEnv :: TcLclEnv -> TcS a -> TcS a
getTcEvBindsVar :: TcS EvBindsVar
getTcLevel :: TcS TcLevel
getTcEvTyCoVars :: EvBindsVar -> TcS TyCoVarSet
getTcEvBindsMap :: EvBindsVar -> TcS EvBindMap
setTcEvBindsMap :: EvBindsVar -> EvBindMap -> TcS ()
tcLookupClass :: Name -> TcS Class
tcLookupId :: Name -> TcS Id
updInertTcS :: (InertSet -> InertSet) -> TcS ()
updInertCans :: (InertCans -> InertCans) -> TcS ()
updInertDicts :: (DictMap Ct -> DictMap Ct) -> TcS ()
updInertIrreds :: (Cts -> Cts) -> TcS ()
getHasGivenEqs :: TcLevel -> TcS (HasGivenEqs, Cts)
setInertCans :: InertCans -> TcS ()
getInertEqs :: TcS InertEqs
getInertCans :: TcS InertCans
getInertGivens :: TcS [Ct]
getInertInsols :: TcS Cts
getInnermostGivenEqLevel :: TcS TcLevel
getTcSInerts :: TcS InertSet
setTcSInerts :: InertSet -> TcS ()
getUnsolvedInerts :: TcS (Bag Implication, Cts)

-- | Remove inert constraints from the <a>InertCans</a>, for use when a
--   typechecker plugin wishes to discard a given.
removeInertCts :: [Ct] -> InertCans -> InertCans
getPendingGivenScs :: TcS [Ct]
addInertCan :: Ct -> TcS ()
insertFunEq :: FunEqMap a -> TyCon -> [Type] -> a -> FunEqMap a
addInertForAll :: QCInst -> TcS ()
emitWorkNC :: [CtEvidence] -> TcS ()
emitWork :: [Ct] -> TcS ()

-- | Look up a dictionary inert.
lookupInertDict :: InertCans -> CtLoc -> Class -> [Type] -> Maybe Ct
kickOutAfterUnification :: TcTyVar -> TcS Int
addInertSafehask :: InertCans -> Ct -> InertCans
insertSafeOverlapFailureTcS :: InstanceWhat -> Ct -> TcS ()
updInertSafehask :: (DictMap Ct -> DictMap Ct) -> TcS ()
getSafeOverlapFailures :: TcS Cts
addSolvedDict :: InstanceWhat -> CtEvidence -> Class -> [Type] -> TcS ()

-- | Look up a solved inert.
lookupSolvedDict :: InertSet -> CtLoc -> Class -> [Type] -> Maybe CtEvidence
foldIrreds :: (Ct -> b -> b) -> Cts -> b -> b

-- | Looks up a family application in the inerts.
lookupFamAppInert :: (CtFlavourRole -> Bool) -> TyCon -> [Type] -> TcS (Maybe (Reduction, CtFlavourRole))
lookupFamAppCache :: TyCon -> [Type] -> TcS (Maybe Reduction)
extendFamAppCache :: TyCon -> [Type] -> Reduction -> TcS ()
pprKicked :: Int -> SDoc
instDFunType :: DFunId -> [DFunInstType] -> TcS ([TcType], TcThetaType)
newFlexiTcSTy :: Kind -> TcS TcType
instFlexiX :: Subst -> [TKVar] -> TcS Subst
cloneMetaTyVar :: TcTyVar -> TcS TcTyVar
tcInstSkolTyVarsX :: SkolemInfo -> Subst -> [TyVar] -> TcS (Subst, [TcTyVar])
data TcLevel
isFilledMetaTyVar_maybe :: TcTyVar -> TcS (Maybe Type)
isFilledMetaTyVar :: TcTyVar -> TcS Bool
zonkTyCoVarsAndFV :: TcTyCoVarSet -> TcS TcTyCoVarSet
zonkTcType :: TcType -> TcS TcType
zonkTcTypes :: [TcType] -> TcS [TcType]
zonkTcTyVar :: TcTyVar -> TcS TcType
zonkCo :: Coercion -> TcS Coercion
zonkTyCoVarsAndFVList :: [TcTyCoVar] -> TcS [TcTyCoVar]
zonkSimples :: Cts -> TcS Cts
zonkWC :: WantedConstraints -> TcS WantedConstraints
zonkTyCoVarKind :: TcTyCoVar -> TcS TcTyCoVar
newTcRef :: a -> TcS (TcRef a)
readTcRef :: TcRef a -> TcS a
writeTcRef :: TcRef a -> a -> TcS ()
updTcRef :: TcRef a -> (a -> a) -> TcS ()
getDefaultInfo :: TcS ([Type], (Bool, Bool))
getDynFlags :: HasDynFlags m => m DynFlags
getGlobalRdrEnvTcS :: TcS GlobalRdrEnv
matchFam :: TyCon -> [Type] -> TcS (Maybe ReductionN)
matchFamTcM :: TyCon -> [Type] -> TcM (Maybe ReductionN)
checkWellStagedDFun :: CtLoc -> InstanceWhat -> PredType -> TcS ()
pprEq :: TcType -> TcType -> SDoc

-- | Conditionally replace all type family applications in the RHS with
--   fresh variables, emitting givens that relate the type family
--   application to the variable. See Note [Type equality cycles] in
--   GHC.Tc.Solver.Canonical. This only works under conditions as described
--   in the Note; otherwise, returns Nothing.
breakTyEqCycle_maybe :: CtEvidence -> CheckTyEqResult -> CanEqLHS -> TcType -> TcS (Maybe ReductionN)
rewriterView :: TcType -> Maybe TcType
instance GHC.Base.Functor GHC.Tc.Solver.Monad.TcS
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.Monad.TouchabilityTestResult
instance Control.Monad.Fix.MonadFix GHC.Tc.Solver.Monad.TcS
instance GHC.Base.Applicative GHC.Tc.Solver.Monad.TcS
instance GHC.Base.Monad GHC.Tc.Solver.Monad.TcS
instance Control.Monad.IO.Class.MonadIO GHC.Tc.Solver.Monad.TcS
instance Control.Monad.Fail.MonadFail GHC.Tc.Solver.Monad.TcS
instance GHC.Types.Unique.Supply.MonadUnique GHC.Tc.Solver.Monad.TcS
instance GHC.Unit.Module.HasModule GHC.Tc.Solver.Monad.TcS
instance GHC.Types.TyThing.MonadThings GHC.Tc.Solver.Monad.TcS
instance GHC.Driver.Session.HasDynFlags GHC.Tc.Solver.Monad.TcS

module GHC.Tc.Solver.Rewrite

-- | See Note [Rewriting]. If (xi, co, rewriters) &lt;- rewrite mode ev ty,
--   then co :: xi ~r ty where r is the role in <tt>ev</tt>. rewriters is
--   the set of coercion holes that have been used to rewrite See Note
--   [Wanteds rewrite Wanteds] in GHC.Tc.Types.Constraint
rewrite :: CtEvidence -> TcType -> TcS (Reduction, RewriterSet)

-- | See Note [Rewriting] <a>rewriteForErrors</a> is a variant of
--   <a>rewrite</a> that rewrites w.r.t. nominal equality only, as this is
--   better than full rewriting for error messages. (This was important
--   when we flirted with rewriting newtypes but perhaps less so now.)
rewriteForErrors :: CtEvidence -> TcType -> TcS (Reduction, RewriterSet)
rewriteArgsNom :: CtEvidence -> TyCon -> [TcType] -> TcS (Reductions, RewriterSet)

-- | Rewrite a type w.r.t. nominal equality. This is useful to rewrite a
--   type w.r.t. any givens. It does not do type-family reduction. This
--   will never emit new constraints. Call this when the inert set contains
--   only givens.
rewriteType :: CtLoc -> TcType -> TcS TcType
instance GHC.Base.Functor GHC.Tc.Solver.Rewrite.RewriteM
instance GHC.Base.Monad GHC.Tc.Solver.Rewrite.RewriteM
instance GHC.Base.Applicative GHC.Tc.Solver.Rewrite.RewriteM
instance GHC.Driver.Session.HasDynFlags GHC.Tc.Solver.Rewrite.RewriteM

module GHC.Tc.Solver.Canonical
canonicalize :: Ct -> TcS (StopOrContinue Ct)
unifyWanted :: RewriterSet -> CtLoc -> Role -> TcType -> TcType -> TcS Coercion
makeSuperClasses :: [Ct] -> TcS [Ct]
data StopOrContinue a
ContinueWith :: a -> StopOrContinue a
Stop :: CtEvidence -> SDoc -> StopOrContinue a
stopWith :: CtEvidence -> String -> TcS (StopOrContinue a)
continueWith :: a -> TcS (StopOrContinue a)
andWhenContinue :: TcS (StopOrContinue a) -> (a -> TcS (StopOrContinue b)) -> TcS (StopOrContinue b)
infixr 0 `andWhenContinue`
rewriteEqEvidence :: RewriterSet -> CtEvidence -> SwapFlag -> Reduction -> Reduction -> TcS CtEvidence
solveCallStack :: CtEvidence -> EvCallStack -> TcS ()
instance GHC.Base.Functor GHC.Tc.Solver.Canonical.StopOrContinue
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Tc.Solver.Canonical.StopOrContinue a)


-- | This module provides an interface for typechecker plugins to access
--   select functions of the <tt>TcM</tt>, principally those to do with
--   reading parts of the state.
module GHC.Tc.Plugin

-- | <a>TcPluginM</a> is the monad in which type-checking plugins operate.
data TcPluginM a

-- | Perform some IO, typically to interact with an external tool.
tcPluginIO :: IO a -> TcPluginM a

-- | Output useful for debugging the compiler.
tcPluginTrace :: String -> SDoc -> TcPluginM ()

-- | This function provides an escape for direct access to the <a>TcM</a>
--   monad. It should not be used lightly, and the provided
--   <a>TcPluginM</a> API should be favoured instead.
unsafeTcPluginTcM :: TcM a -> TcPluginM a

-- | The result of searching for an imported module.
--   
--   NB: FindResult manages both user source-import lookups (which can
--   result in <a>GenModule</a>) as well as direct imports for interfaces
--   (which always result in <a>InstalledModule</a>).
data FindResult

-- | The module was found
Found :: ModLocation -> Module -> FindResult

-- | The requested unit was not found
NoPackage :: Unit -> FindResult

-- | _Error_: both in multiple packages
FoundMultiple :: [(Module, ModuleOrigin)] -> FindResult

-- | Not found
NotFound :: [FilePath] -> Maybe Unit -> [Unit] -> [Unit] -> [UnusableUnit] -> [ModuleSuggestion] -> FindResult

-- | Places where I looked
[fr_paths] :: FindResult -> [FilePath]

-- | Just p =&gt; module is in this unit's manifest, but couldn't find the
--   .hi file
[fr_pkg] :: FindResult -> Maybe Unit

-- | Module is in these units, but the *module* is hidden
[fr_mods_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but the *unit* is hidden
[fr_pkgs_hidden] :: FindResult -> [Unit]

-- | Module is in these units, but it is unusable
[fr_unusables] :: FindResult -> [UnusableUnit]

-- | Possible mis-spelled modules
[fr_suggestions] :: FindResult -> [ModuleSuggestion]
findImportedModule :: ModuleName -> PkgQual -> TcPluginM FindResult
lookupOrig :: Module -> OccName -> TcPluginM Name
tcLookupGlobal :: Name -> TcPluginM TyThing
tcLookupTyCon :: Name -> TcPluginM TyCon
tcLookupDataCon :: Name -> TcPluginM DataCon
tcLookupClass :: Name -> TcPluginM Class
tcLookup :: Name -> TcPluginM TcTyThing
tcLookupId :: Name -> TcPluginM Id
getTopEnv :: TcPluginM HscEnv
getTargetPlatform :: TcPluginM Platform
getEnvs :: TcPluginM (TcGblEnv, TcLclEnv)
getInstEnvs :: TcPluginM InstEnvs
getFamInstEnvs :: TcPluginM (FamInstEnv, FamInstEnv)
matchFam :: TyCon -> [Type] -> TcPluginM (Maybe Reduction)
newUnique :: TcPluginM Unique
newFlexiTyVar :: Kind -> TcPluginM TcTyVar
isTouchableTcPluginM :: TcTyVar -> TcPluginM Bool
zonkTcType :: TcType -> TcPluginM TcType
zonkCt :: Ct -> TcPluginM Ct

-- | Create a new Wanted constraint with the given <a>CtLoc</a>.
newWanted :: CtLoc -> PredType -> TcPluginM CtEvidence

-- | Create a new given constraint, with the supplied evidence.
--   
--   This should only be invoked within <tt>tcPluginSolve</tt>.
newGiven :: EvBindsVar -> CtLoc -> PredType -> EvExpr -> TcPluginM CtEvidence

-- | Create a fresh coercion hole. This should only be invoked within
--   <tt>tcPluginSolve</tt>.
newCoercionHole :: PredType -> TcPluginM CoercionHole

-- | Create a fresh evidence variable.
--   
--   This should only be invoked within <tt>tcPluginSolve</tt>.
newEvVar :: PredType -> TcPluginM EvVar

-- | Bind an evidence variable.
--   
--   This should only be invoked within <tt>tcPluginSolve</tt>.
setEvBind :: EvBindsVar -> EvBind -> TcPluginM ()

module GHC.Tc.Solver.Interact
solveSimpleGivens :: [Ct] -> TcS ()
solveSimpleWanteds :: Cts -> TcS WantedConstraints
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.Interact.InteractResult

module GHC.Tc.Solver

-- | How should we choose which constraints to quantify over?
data InferMode

-- | Apply the monomorphism restriction, never quantifying over any
--   constraints
ApplyMR :: InferMode

-- | See Note [TcRnExprMode] in <a>GHC.Tc.Module</a>, the :type +d case;
--   this mode refuses to quantify over any defaultable constraint
EagerDefaulting :: InferMode

-- | Quantify over any constraint that satisfies pickQuantifiablePreds
NoRestrictions :: InferMode
simplifyInfer :: TcLevel -> InferMode -> [TcIdSigInst] -> [(Name, TcTauType)] -> WantedConstraints -> TcM ([TcTyVar], [EvVar], TcEvBinds, Bool)
findInferredDiff :: TcThetaType -> TcThetaType -> TcM TcThetaType
growThetaTyVars :: ThetaType -> TyCoVarSet -> TyCoVarSet
simplifyAmbiguityCheck :: Type -> WantedConstraints -> TcM ()
simplifyDefault :: ThetaType -> TcM Bool
simplifyTop :: WantedConstraints -> TcM (Bag EvBind)
simplifyTopImplic :: Bag Implication -> TcM ()
simplifyInteractive :: WantedConstraints -> TcM (Bag EvBind)

-- | Type-check a thing that emits only equality constraints, solving any
--   constraints we can and re-emitting constraints that we can't. Use this
--   variant only when we'll get another crack at it later See Note
--   [Failure in local type signatures]
--   
--   Panics if we solve any non-equality constraints. (In runTCSEqualities
--   we use an error thunk for the evidence bindings.)
solveEqualities :: String -> TcM a -> TcM a
pushLevelAndSolveEqualities :: SkolemInfoAnon -> [TyConBinder] -> TcM a -> TcM a
pushLevelAndSolveEqualitiesX :: String -> TcM a -> TcM (TcLevel, WantedConstraints, a)
reportUnsolvedEqualities :: SkolemInfo -> [TcTyVar] -> TcLevel -> WantedConstraints -> TcM ()
simplifyWantedsTcM :: [CtEvidence] -> TcM WantedConstraints

-- | Return (Just new_inerts) if the Givens are satisfiable, Nothing if
--   definitely contradictory.
--   
--   See Note [Pattern match warnings with insoluble Givens] above.
tcCheckGivens :: InertSet -> Bag EvVar -> TcM (Maybe InertSet)

-- | Return True if the Wanteds are soluble, False if not
tcCheckWanteds :: InertSet -> ThetaType -> TcM Bool

-- | Normalise a type as much as possible using the given constraints. See
--   <tt>Note [tcNormalise]</tt>.
tcNormalise :: InertSet -> Type -> TcM Type
captureTopConstraints :: TcM a -> TcM (a, WantedConstraints)

-- | Simplify top-level constraints, but without reporting any unsolved
--   constraints nor unsafe overlapping.
simplifyTopWanteds :: WantedConstraints -> TcS WantedConstraints
promoteTyVarSet :: HasDebugCallStack => TcTyVarSet -> TcM Bool
simplifyAndEmitFlatConstraints :: WantedConstraints -> TcM ()
solveWanteds :: WantedConstraints -> TcS WantedConstraints
approximateWC :: Bool -> WantedConstraints -> Cts
instance GHC.Utils.Outputable.Outputable GHC.Tc.Solver.InferMode

module GHC.Tc.Validity
data Rank
ArbitraryRank :: Rank
LimitedRank :: Bool -> Rank -> Rank
MonoTypeRankZero :: Rank
MonoTypeTyConArg :: Rank
MonoTypeSynArg :: Rank
MonoTypeConstraint :: Rank
MustBeMonoType :: Rank

-- | UserTypeCtxt describes the origin of the polymorphic type in the
--   places where we need an expression to have that type
data UserTypeCtxt
FunSigCtxt :: Name -> ReportRedundantConstraints -> UserTypeCtxt
InfSigCtxt :: Name -> UserTypeCtxt
ExprSigCtxt :: ReportRedundantConstraints -> UserTypeCtxt
KindSigCtxt :: UserTypeCtxt
StandaloneKindSigCtxt :: Name -> UserTypeCtxt
TypeAppCtxt :: UserTypeCtxt
ConArgCtxt :: Name -> UserTypeCtxt
TySynCtxt :: Name -> UserTypeCtxt
PatSynCtxt :: Name -> UserTypeCtxt
PatSigCtxt :: UserTypeCtxt
RuleSigCtxt :: FastString -> Name -> UserTypeCtxt
ForSigCtxt :: Name -> UserTypeCtxt
DefaultDeclCtxt :: UserTypeCtxt
InstDeclCtxt :: Bool -> UserTypeCtxt
SpecInstCtxt :: UserTypeCtxt
GenSigCtxt :: UserTypeCtxt
GhciCtxt :: Bool -> UserTypeCtxt
ClassSCCtxt :: Name -> UserTypeCtxt
SigmaCtxt :: UserTypeCtxt
DataTyCtxt :: Name -> UserTypeCtxt
DerivClauseCtxt :: UserTypeCtxt
TyVarBndrKindCtxt :: Name -> UserTypeCtxt
DataKindCtxt :: Name -> UserTypeCtxt
TySynKindCtxt :: Name -> UserTypeCtxt
TyFamResKindCtxt :: Name -> UserTypeCtxt
checkValidType :: UserTypeCtxt -> Type -> TcM ()
checkValidMonoType :: Type -> TcM ()
checkValidTheta :: UserTypeCtxt -> ThetaType -> TcM ()
checkValidInstance :: UserTypeCtxt -> LHsSigType GhcRn -> Type -> TcM ()
checkValidInstHead :: UserTypeCtxt -> Class -> [Type] -> TcM ()
validDerivPred :: PatersonSize -> PredType -> Bool
checkTySynRhs :: UserTypeCtxt -> TcType -> TcM ()
checkEscapingKind :: Type -> TcM ()
checkValidCoAxiom :: CoAxiom Branched -> TcM ()
checkValidCoAxBranch :: TyCon -> CoAxBranch -> TcM ()

-- | Do validity checks on a type family equation, including consistency
--   with any enclosing class instance head, termination, and lack of
--   polytypes.
checkValidTyFamEqn :: TyCon -> [Var] -> [Type] -> Type -> TcM ()

-- | Checks that an associated type family default:
--   
--   <ol>
--   <li>Only consists of arguments that are bare type variables, and</li>
--   <li>Has a distinct type variable in each argument.</li>
--   </ol>
--   
--   See <tt>Note [Type-checking default assoc decls]</tt> in
--   <a>GHC.Tc.TyCl</a>.
checkValidAssocTyFamDeflt :: TyCon -> [Type] -> TcM ()
checkConsistentFamInst :: AssocInstInfo -> TyCon -> CoAxBranch -> TcM ()
arityErr :: Outputable a => SDoc -> a -> Int -> Int -> TcRnMessage
checkTyConTelescope :: TyCon -> TcM ()
instance GHC.Classes.Eq GHC.Tc.Validity.TypeOrKindCtxt
instance GHC.Utils.Outputable.Outputable GHC.Tc.Validity.ValidityEnv
instance GHC.Utils.Outputable.Outputable GHC.Tc.Validity.ExpandMode
instance GHC.Utils.Outputable.Outputable GHC.Tc.Validity.TypeOrKindCtxt

module GHC.Tc.Errors.Hole
findValidHoleFits :: TidyEnv -> [Implication] -> [CtEvidence] -> Hole -> TcM (TidyEnv, ValidHoleFits)

-- | A tcSubsumes which takes into account relevant constraints, to fix
--   trac #14273. This makes sure that when checking whether a type fits
--   the hole, the type has to be subsumed by type of the hole as well as
--   fulfill all constraints on the type of the hole.
tcCheckHoleFit :: TypedHole -> TcSigmaType -> TcSigmaType -> TcM (Bool, HsWrapper)

-- | Takes a list of free variables and restores any Flexi type variables
--   in free_vars after the action is run.
withoutUnification :: FV -> TcM a -> TcM a

-- | Reports whether first type (ty_a) subsumes the second type (ty_b),
--   discarding any errors. Subsumption here means that the ty_b can fit
--   into the ty_a, i.e. `tcSubsumes a b == True` if b is a subtype of a.
tcSubsumes :: TcSigmaType -> TcSigmaType -> TcM Bool

-- | Checks whether a MetaTyVar is flexible or not.
isFlexiTyVar :: TcTyVar -> TcM Bool

-- | tcFilterHoleFits filters the candidates by whether, given the
--   implications and the relevant constraints, they can be made to match
--   the type by running the type checker. Stops after finding limit
--   matches.
tcFilterHoleFits :: Maybe Int -> TypedHole -> (TcType, [TcTyVar]) -> [HoleFitCandidate] -> TcM (Bool, [HoleFit])
getLocalBindings :: TidyEnv -> CtLoc -> TcM [Id]
pprHoleFit :: HoleFitDispConfig -> HoleFit -> SDoc
addHoleFitDocs :: [HoleFit] -> TcM [HoleFit]
getHoleFitSortingAlg :: TcM HoleFitSortingAlg
getHoleFitDispConfig :: TcM HoleFitDispConfig

-- | Configuration for pretty-printing valid hole fits.
data HoleFitDispConfig
HFDC :: Bool -> HoleFitDispConfig
[showWrap, showWrapVars, showType, showProv, showMatches] :: HoleFitDispConfig -> Bool
data HoleFitSortingAlg
HFSNoSorting :: HoleFitSortingAlg
HFSBySize :: HoleFitSortingAlg
HFSBySubsumption :: HoleFitSortingAlg
relevantCtEvidence :: Type -> [CtEvidence] -> [CtEvidence]
zonkSubs :: TidyEnv -> [HoleFit] -> TcM (TidyEnv, [HoleFit])
sortHoleFitsByGraph :: [HoleFit] -> TcM [HoleFit]

-- | Sort by size uses as a measure for relevance the sizes of the
--   different types needed to instantiate the fit to the type of the hole.
--   This is much quicker than sorting by subsumption, and gives reasonable
--   results in most cases.
sortHoleFitsBySize :: [HoleFit] -> TcM [HoleFit]

-- | A HoleFitPlugin is a pair of candidate and fit plugins.
data HoleFitPlugin
HoleFitPlugin :: CandPlugin -> FitPlugin -> HoleFitPlugin
[candPlugin] :: HoleFitPlugin -> CandPlugin
[fitPlugin] :: HoleFitPlugin -> FitPlugin

-- | HoleFitPluginR adds a TcRef to hole fit plugins so that plugins can
--   track internal state. Note the existential quantification, ensuring
--   that the state cannot be modified from outside the plugin.
data HoleFitPluginR
HoleFitPluginR :: TcM (TcRef s) -> (TcRef s -> HoleFitPlugin) -> (TcRef s -> TcM ()) -> HoleFitPluginR

-- | Initializes the TcRef to be passed to the plugin
[hfPluginInit] :: HoleFitPluginR -> TcM (TcRef s)

-- | The function defining the plugin itself
[hfPluginRun] :: HoleFitPluginR -> TcRef s -> HoleFitPlugin

-- | Cleanup of state, guaranteed to be called even on error
[hfPluginStop] :: HoleFitPluginR -> TcRef s -> TcM ()
instance GHC.Classes.Ord GHC.Tc.Errors.Hole.HoleFitSortingAlg
instance GHC.Classes.Eq GHC.Tc.Errors.Hole.HoleFitSortingAlg

module GHC.Rename.Names

-- | Process Import Decls. See <a>rnImportDecl</a> for a description of
--   what the return types represent. Note: Do the non SOURCE ones first,
--   so that we get a helpful warning for SOURCE ones that are unnecessary
rnImports :: [(LImportDecl GhcPs, SDoc)] -> RnM ([LImportDecl GhcRn], GlobalRdrEnv, ImportAvails, AnyHpcUsage)
getLocalNonValBinders :: MiniFixityEnv -> HsGroup GhcPs -> RnM ((TcGblEnv, TcLclEnv), NameSet)
newRecordSelector :: DuplicateRecordFields -> FieldSelectors -> [Name] -> LFieldOcc GhcPs -> RnM FieldLabel
extendGlobalRdrEnvRn :: [AvailInfo] -> MiniFixityEnv -> RnM (TcGblEnv, TcLclEnv)

-- | make a <a>GlobalRdrEnv</a> where all the elements point to the same
--   Provenance (useful for "hiding" imports, or imports with no details).
gresFromAvails :: Maybe ImportSpec -> [AvailInfo] -> [GlobalRdrElt]

-- | Calculate the <a>ImportAvails</a> induced by an import of a particular
--   interface, but without <a>imp_mods</a>.
calculateAvails :: HomeUnit -> Set UnitId -> ModIface -> IsSafeImport -> IsBootInterface -> ImportedBy -> ImportAvails
reportUnusedNames :: TcGblEnv -> HscSource -> RnM ()
checkConName :: RdrName -> TcRn ()
mkChildEnv :: [GlobalRdrElt] -> NameEnv [GlobalRdrElt]
findChildren :: NameEnv [a] -> Name -> [a]
findImportUsage :: [LImportDecl GhcRn] -> [GlobalRdrElt] -> [ImportDeclUsage]
getMinimalImports :: [ImportDeclUsage] -> RnM [LImportDecl GhcRn]
printMinimalImports :: HscSource -> [ImportDeclUsage] -> RnM ()

-- | Rename raw package imports
renamePkgQual :: UnitEnv -> ModuleName -> Maybe FastString -> PkgQual

-- | Rename raw package imports
renameRawPkgQual :: UnitEnv -> ModuleName -> RawPkgQual -> PkgQual
type ImportDeclUsage = (LImportDecl GhcRn, [GlobalRdrElt], [Name])

module GHC.Rename.Doc
rnHsDoc :: WithHsDocIdentifiers a GhcPs -> RnM (WithHsDocIdentifiers a GhcRn)
rnLHsDoc :: LHsDoc GhcPs -> RnM (LHsDoc GhcRn)
rnLDocDecl :: LDocDecl GhcPs -> RnM (LDocDecl GhcRn)
rnDocDecl :: DocDecl GhcPs -> RnM (DocDecl GhcRn)

module GHC.Tc.Gen.Export
rnExports :: Bool -> Maybe (LocatedL [LIE GhcPs]) -> RnM TcGblEnv
exports_from_avail :: Maybe (LocatedL [LIE GhcPs]) -> GlobalRdrEnv -> ImportAvails -> Module -> RnM (Maybe [(LIE GhcRn, Avails)], Avails)

module GHC.Rename.HsType
rnHsType :: HsDocContext -> HsType GhcPs -> RnM (HsType GhcRn, FreeVars)
rnLHsType :: HsDocContext -> LHsType GhcPs -> RnM (LHsType GhcRn, FreeVars)
rnLHsTypes :: HsDocContext -> [LHsType GhcPs] -> RnM ([LHsType GhcRn], FreeVars)
rnContext :: HsDocContext -> LHsContext GhcPs -> RnM (LHsContext GhcRn, FreeVars)
rnMaybeContext :: HsDocContext -> Maybe (LHsContext GhcPs) -> RnM (Maybe (LHsContext GhcRn), FreeVars)
rnHsKind :: HsDocContext -> HsKind GhcPs -> RnM (HsKind GhcRn, FreeVars)
rnLHsKind :: HsDocContext -> LHsKind GhcPs -> RnM (LHsKind GhcRn, FreeVars)
rnLHsTypeArgs :: HsDocContext -> [LHsTypeArg GhcPs] -> RnM ([LHsTypeArg GhcRn], FreeVars)
rnHsSigType :: HsDocContext -> TypeOrKind -> LHsSigType GhcPs -> RnM (LHsSigType GhcRn, FreeVars)
rnHsWcType :: HsDocContext -> LHsWcType GhcPs -> RnM (LHsWcType GhcRn, FreeVars)
rnHsPatSigTypeBindingVars :: HsDocContext -> HsPatSigType GhcPs -> (HsPatSigType GhcRn -> RnM (r, FreeVars)) -> RnM (r, FreeVars)
data HsPatSigTypeScoping

-- | Always bind any free tyvars of the given type, regardless of whether
--   we have a forall at the top.
--   
--   For pattern type sigs, we <i>do</i> want to bring those type variables
--   into scope, even if there's a forall at the top which usually stops
--   that happening, e.g:
--   
--   <pre>
--   \ (x :: forall a. a -&gt; b) -&gt; e
--   </pre>
--   
--   Here we do bring <tt>b</tt> into scope.
--   
--   RULES can also use <a>AlwaysBind</a>, such as in the following
--   example:
--   
--   <pre>
--   {-# RULES \"f\" forall (x :: forall a. a -&gt; b). f x = ... b ... #-}
--   </pre>
--   
--   This only applies to RULES that do not explicitly bind their type
--   variables. If a RULE explicitly quantifies its type variables, then
--   <a>NeverBind</a> is used instead. See also <tt>Note [Pattern signature
--   binders and scoping]</tt> in <a>GHC.Hs.Type</a>.
AlwaysBind :: HsPatSigTypeScoping

-- | Never bind any free tyvars. This is used for RULES that have both
--   explicit type and term variable binders, e.g.:
--   
--   <pre>
--   {-# RULES \"const\" forall a. forall (x :: a) y. const x y = x #-}
--   </pre>
--   
--   The presence of the type variable binder <tt>forall a.</tt> implies
--   that the free variables in the types of the term variable binders
--   <tt>x</tt> and <tt>y</tt> are <i>not</i> bound. In the example above,
--   there are no such free variables, but if the user had written <tt>(y
--   :: b)</tt> instead of <tt>y</tt> in the term variable binders, then
--   <tt>b</tt> would be rejected for being out of scope. See also <tt>Note
--   [Pattern signature binders and scoping]</tt> in <a>GHC.Hs.Type</a>.
NeverBind :: HsPatSigTypeScoping
rnHsSigWcType :: HsDocContext -> LHsSigWcType GhcPs -> RnM (LHsSigWcType GhcRn, FreeVars)
rnHsPatSigType :: HsPatSigTypeScoping -> HsDocContext -> HsPatSigType GhcPs -> (HsPatSigType GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
newTyVarNameRn :: Maybe a -> LocatedN RdrName -> RnM Name
rnConDeclFields :: HsDocContext -> [FieldLabel] -> [LConDeclField GhcPs] -> RnM ([LConDeclField GhcRn], FreeVars)
lookupField :: FastStringEnv FieldLabel -> FieldOcc GhcPs -> FieldOcc GhcRn
rnLTyVar :: LocatedN RdrName -> RnM (LocatedN Name)
rnScaledLHsType :: HsDocContext -> HsScaled GhcPs (LHsType GhcPs) -> RnM (HsScaled GhcRn (LHsType GhcRn), FreeVars)
data NegationHandling
ReassociateNegation :: NegationHandling
KeepNegationIntact :: NegationHandling
mkOpAppRn :: NegationHandling -> LHsExpr GhcRn -> LHsExpr GhcRn -> Fixity -> LHsExpr GhcRn -> RnM (HsExpr GhcRn)
mkNegAppRn :: LHsExpr GhcRn -> SyntaxExpr GhcRn -> RnM (HsExpr GhcRn)
mkOpFormRn :: LHsCmdTop GhcRn -> LHsExpr GhcRn -> Fixity -> LHsCmdTop GhcRn -> RnM (HsCmd GhcRn)
mkConOpPatRn :: LocatedN Name -> Fixity -> LPat GhcRn -> LPat GhcRn -> RnM (Pat GhcRn)
checkPrecMatch :: Name -> MatchGroup GhcRn body -> RnM ()
checkSectionPrec :: FixityDirection -> HsExpr GhcPs -> LHsExpr GhcRn -> LHsExpr GhcRn -> RnM ()
bindHsOuterTyVarBndrs :: OutputableBndrFlag flag 'Renamed => HsDocContext -> Maybe assoc -> FreeKiTyVars -> HsOuterTyVarBndrs flag GhcPs -> (HsOuterTyVarBndrs flag GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
bindHsForAllTelescope :: HsDocContext -> HsForAllTelescope GhcPs -> (HsForAllTelescope GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
bindLHsTyVarBndr :: HsDocContext -> Maybe a -> LHsTyVarBndr flag GhcPs -> (LHsTyVarBndr flag GhcRn -> RnM (b, FreeVars)) -> RnM (b, FreeVars)
bindLHsTyVarBndrs :: OutputableBndrFlag flag 'Renamed => HsDocContext -> WarnUnusedForalls -> Maybe a -> [LHsTyVarBndr flag GhcPs] -> ([LHsTyVarBndr flag GhcRn] -> RnM (b, FreeVars)) -> RnM (b, FreeVars)

-- | Should GHC warn if a quantified type variable goes unused? Usually,
--   the answer is "yes", but in the particular case of binding
--   <a>LHsQTyVars</a>, we avoid emitting warnings. See <tt>Note [Suppress
--   -Wunused-foralls when binding LHsQTyVars]</tt>.
data WarnUnusedForalls
WarnUnusedForalls :: WarnUnusedForalls
NoWarnUnusedForalls :: WarnUnusedForalls

-- | Create new renamed type variables corresponding to source-level ones.
--   Duplicates are permitted, but will be removed. This is intended
--   especially for the case of handling the implicitly bound free
--   variables of a type signature.
rnImplicitTvOccs :: Maybe assoc -> FreeKiTyVars -> ([Name] -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
bindSigTyVarsFV :: [Name] -> RnM (a, FreeVars) -> RnM (a, FreeVars)
bindHsQTyVars :: forall a b. HsDocContext -> Maybe a -> FreeKiTyVars -> LHsQTyVars GhcPs -> (LHsQTyVars GhcRn -> Bool -> RnM (b, FreeVars)) -> RnM (b, FreeVars)
type FreeKiTyVars = [LocatedN RdrName]

-- | Filter out any type and kind variables that are already in scope in
--   the the environment's LocalRdrEnv. Note that this includes named
--   wildcards, which look like perfectly ordinary type variables at this
--   point.
filterInScopeM :: FreeKiTyVars -> RnM FreeKiTyVars

-- | <a>extractHsTyRdrTyVars</a> finds the type/kind variables of a
--   HsType/HsKind. It's used when making the <tt>forall</tt>s explicit.
--   See Note [Kind and type-variable binders]
extractHsTyRdrTyVars :: LHsType GhcPs -> FreeKiTyVars

-- | Extracts the free type/kind variables from the kind signature of a
--   HsType. This is used to implicitly quantify over <tt>k</tt> in
--   <tt>type T = Nothing :: Maybe k</tt>. The left-to-right order of
--   variables is preserved. See Note [Kind and type-variable binders] and
--   Note [Ordering of implicit variables] and Note [Implicit
--   quantification in type synonyms].
extractHsTyRdrTyVarsKindVars :: LHsType GhcPs -> FreeKiTyVars

-- | Extracts free type and kind variables from types in a list. When the
--   same name occurs multiple times in the types, all occurrences are
--   returned.
extractHsTysRdrTyVars :: [LHsType GhcPs] -> FreeKiTyVars -> FreeKiTyVars
extractRdrKindSigVars :: LFamilyResultSig GhcPs -> FreeKiTyVars

-- | Extracts free type and kind variables from an argument in a GADT
--   constructor, returning variable occurrences in left-to-right order.
--   See <tt>Note [Ordering of implicit variables]</tt>.
extractConDeclGADTDetailsTyVars :: HsConDeclGADTDetails GhcPs -> FreeKiTyVars -> FreeKiTyVars

-- | Get type/kind variables mentioned in the kind signature, preserving
--   left-to-right order:
--   
--   <ul>
--   <li>data T a (b :: k1) :: k2 -&gt; k1 -&gt; k2 -&gt; Type -- result:
--   [k2,k1]</li>
--   <li>data T a (b :: k1) -- result: []</li>
--   </ul>
--   
--   See Note [Ordering of implicit variables].
extractDataDefnKindVars :: HsDataDefn GhcPs -> FreeKiTyVars
extractHsOuterTvBndrs :: HsOuterTyVarBndrs flag GhcPs -> FreeKiTyVars -> FreeKiTyVars
extractHsTyArgRdrKiTyVars :: [LHsTypeArg GhcPs] -> FreeKiTyVars
nubL :: Eq a => [GenLocated l a] -> [GenLocated l a]
nubN :: Eq a => [LocatedN a] -> [LocatedN a]
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.OpName
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.WarnUnusedForalls
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.RnTyKiEnv
instance GHC.Utils.Outputable.Outputable GHC.Rename.HsType.RnTyKiWhat

module GHC.Rename.Pat
rnPat :: HsMatchContext GhcRn -> LPat GhcPs -> (LPat GhcRn -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
rnPats :: Traversable f => HsMatchContext GhcRn -> f (LPat GhcPs) -> (f (LPat GhcRn) -> RnM (a, FreeVars)) -> RnM (a, FreeVars)
rnBindPat :: NameMaker -> LPat GhcPs -> RnM (LPat GhcRn, FreeVars)
data NameMaker
applyNameMaker :: NameMaker -> LocatedN RdrName -> RnM (LocatedN Name)
localRecNameMaker :: MiniFixityEnv -> NameMaker
topRecNameMaker :: MiniFixityEnv -> NameMaker
isTopRecNameMaker :: NameMaker -> Bool
rnHsRecFields :: forall arg. HsRecFieldContext -> (SrcSpan -> RdrName -> arg) -> HsRecFields GhcPs (LocatedA arg) -> RnM ([LHsRecField GhcRn (LocatedA arg)], FreeVars)
data HsRecFieldContext
HsRecFieldCon :: Name -> HsRecFieldContext
HsRecFieldPat :: Name -> HsRecFieldContext
HsRecFieldUpd :: HsRecFieldContext
rnHsRecUpdFields :: [LHsRecUpdField GhcPs] -> RnM ([LHsRecUpdField GhcRn], FreeVars)
data CpsRn b
liftCps :: RnM a -> CpsRn a
liftCpsWithCont :: (forall r. (b -> RnM (r, FreeVars)) -> RnM (r, FreeVars)) -> CpsRn b
rnLit :: HsLit p -> RnM ()
rnOverLit :: XXOverLit t ~ DataConCantHappen => HsOverLit t -> RnM ((HsOverLit GhcRn, Maybe (HsExpr GhcRn)), FreeVars)
instance GHC.Base.Functor GHC.Rename.Pat.CpsRn
instance GHC.Base.Applicative GHC.Rename.Pat.CpsRn
instance GHC.Base.Monad GHC.Rename.Pat.CpsRn

module GHC.Rename.Bind
rnTopBindsLHS :: MiniFixityEnv -> HsValBinds GhcPs -> RnM (HsValBindsLR GhcRn GhcPs)
rnTopBindsLHSBoot :: MiniFixityEnv -> HsValBinds GhcPs -> RnM (HsValBindsLR GhcRn GhcPs)
rnTopBindsBoot :: NameSet -> HsValBindsLR GhcRn GhcPs -> RnM (HsValBinds GhcRn, DefUses)
rnValBindsRHS :: HsSigCtxt -> HsValBindsLR GhcRn GhcPs -> RnM (HsValBinds GhcRn, DefUses)
rnLocalBindsAndThen :: HsLocalBinds GhcPs -> (HsLocalBinds GhcRn -> FreeVars -> RnM (result, FreeVars)) -> RnM (result, FreeVars)
rnLocalValBindsLHS :: MiniFixityEnv -> HsValBinds GhcPs -> RnM ([Name], HsValBindsLR GhcRn GhcPs)
rnLocalValBindsRHS :: NameSet -> HsValBindsLR GhcRn GhcPs -> RnM (HsValBinds GhcRn, DefUses)
rnMethodBinds :: Bool -> Name -> [Name] -> LHsBinds GhcPs -> [LSig GhcPs] -> RnM (LHsBinds GhcRn, [LSig GhcRn], FreeVars)
renameSigs :: HsSigCtxt -> [LSig GhcPs] -> RnM ([LSig GhcRn], FreeVars)
rnMatchGroup :: (Outputable (body GhcPs), AnnoBody body) => HsMatchContext GhcRn -> (LocatedA (body GhcPs) -> RnM (LocatedA (body GhcRn), FreeVars)) -> MatchGroup GhcPs (LocatedA (body GhcPs)) -> RnM (MatchGroup GhcRn (LocatedA (body GhcRn)), FreeVars)
rnGRHSs :: AnnoBody body => HsMatchContext GhcRn -> (LocatedA (body GhcPs) -> RnM (LocatedA (body GhcRn), FreeVars)) -> GRHSs GhcPs (LocatedA (body GhcPs)) -> RnM (GRHSs GhcRn (LocatedA (body GhcRn)), FreeVars)
rnGRHS :: AnnoBody body => HsMatchContext GhcRn -> (LocatedA (body GhcPs) -> RnM (LocatedA (body GhcRn), FreeVars)) -> LGRHS GhcPs (LocatedA (body GhcPs)) -> RnM (LGRHS GhcRn (LocatedA (body GhcRn)), FreeVars)
rnSrcFixityDecl :: HsSigCtxt -> FixitySig GhcPs -> RnM (FixitySig GhcRn)
makeMiniFixityEnv :: [LFixitySig GhcPs] -> RnM MiniFixityEnv
type MiniFixityEnv = FastStringEnv (Located Fixity)
data HsSigCtxt
TopSigCtxt :: NameSet -> HsSigCtxt
LocalBindCtxt :: NameSet -> HsSigCtxt
ClsDeclCtxt :: Name -> HsSigCtxt
InstDeclCtxt :: NameSet -> HsSigCtxt
HsBootCtxt :: NameSet -> HsSigCtxt
RoleAnnotCtxt :: NameSet -> HsSigCtxt

module GHC.Rename.Module

-- | <tt>rnSourceDecl</tt> "renames" declarations. It simultaneously
--   performs dependency analysis and precedence parsing. It also does the
--   following error checks:
--   
--   <ul>
--   <li>Checks that tyvars are used properly. This includes checking for
--   undefined tyvars, and tyvars in contexts that are ambiguous. (Some of
--   this checking has now been moved to module <tt>TcMonoType</tt>, since
--   we don't have functional dependency information at this point.)</li>
--   <li>Checks that all variable occurrences are defined.</li>
--   <li>Checks the <tt>(..)</tt> etc constraints in the export list.</li>
--   </ul>
--   
--   Brings the binders of the group into scope in the appropriate places;
--   does NOT assume that anything is in scope already
rnSrcDecls :: HsGroup GhcPs -> RnM (TcGblEnv, HsGroup GhcRn)
addTcgDUs :: TcGblEnv -> DefUses -> TcGblEnv
findSplice :: [LHsDecl GhcPs] -> RnM (HsGroup GhcPs, Maybe (SpliceDecl GhcPs, [LHsDecl GhcPs]))
rnWarningTxt :: WarningTxt GhcPs -> RnM (WarningTxt GhcRn)

module GHC.Rename.Splice
rnTopSpliceDecls :: HsUntypedSplice GhcPs -> RnM ([LHsDecl GhcPs], FreeVars)
rnTypedSplice :: LHsExpr GhcPs -> RnM (HsExpr GhcRn, FreeVars)
rnSpliceType :: HsUntypedSplice GhcPs -> RnM (HsType GhcRn, FreeVars)
rnUntypedSpliceExpr :: HsUntypedSplice GhcPs -> RnM (HsExpr GhcRn, FreeVars)

-- | Rename a splice pattern. See Note [rnSplicePat]
rnSplicePat :: HsUntypedSplice GhcPs -> RnM ((HsUntypedSplice GhcRn, HsUntypedSpliceResult (LPat GhcPs)), FreeVars)
rnSpliceDecl :: SpliceDecl GhcPs -> RnM (SpliceDecl GhcRn, FreeVars)
rnTypedBracket :: HsExpr GhcPs -> LHsExpr GhcPs -> RnM (HsExpr GhcRn, FreeVars)
rnUntypedBracket :: HsExpr GhcPs -> HsQuote GhcPs -> RnM (HsExpr GhcRn, FreeVars)
checkThLocalName :: Name -> RnM ()

-- | outputs splice information for 2 flags which have different output
--   formats: `-ddump-splices` and `-dth-dec-file`
traceSplice :: SpliceInfo -> TcM ()

-- | The splice data to be logged
data SpliceInfo
SpliceInfo :: String -> Maybe (LHsExpr GhcRn) -> Bool -> SDoc -> SpliceInfo
[spliceDescription] :: SpliceInfo -> String
[spliceSource] :: SpliceInfo -> Maybe (LHsExpr GhcRn)
[spliceIsDecl] :: SpliceInfo -> Bool
[spliceGenerated] :: SpliceInfo -> SDoc

module GHC.Rename.Expr
rnLExpr :: LHsExpr GhcPs -> RnM (LHsExpr GhcRn, FreeVars)
rnExpr :: HsExpr GhcPs -> RnM (HsExpr GhcRn, FreeVars)

-- | Rename some Stmts
rnStmts :: AnnoBody body => HsStmtContext GhcRn -> (body GhcPs -> RnM (body GhcRn, FreeVars)) -> [LStmt GhcPs (LocatedA (body GhcPs))] -> ([Name] -> RnM (thing, FreeVars)) -> RnM (([LStmt GhcRn (LocatedA (body GhcRn))], thing), FreeVars)

-- | Build a <a>HsExpansion</a> out of an extension constructor, and the
--   two components of the expansion: original and desugared expressions.
mkExpandedExpr :: HsExpr GhcRn -> HsExpr GhcRn -> HsExpr GhcRn
type AnnoBody body = (Outputable (body GhcPs))

-- | An existential wrapper around <tt><a>StmtLR</a> GhcPs GhcPs body</tt>.
data UnexpectedStatement
[UnexpectedStatement] :: Outputable (StmtLR GhcPs GhcPs body) => StmtLR GhcPs GhcPs body -> UnexpectedStatement
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Rename.Expr.StmtTree a)
instance GHC.Utils.Outputable.Outputable GHC.Rename.Expr.MonadNames


-- | The loader
--   
--   This module deals with the top-level issues of dynamic linking
--   (loading), calling the object-code linker and the byte-code linker
--   where necessary.
module GHC.Linker.Loader
newtype Loader
Loader :: MVar (Maybe LoaderState) -> Loader
[loader_state] :: Loader -> MVar (Maybe LoaderState)
data LoaderState
LoaderState :: !LinkerEnv -> !LinkableSet -> !LinkableSet -> !PkgsLoaded -> ![(FilePath, String)] -> LoaderState

-- | Current global mapping from Names to their true values
[linker_env] :: LoaderState -> !LinkerEnv

-- | The currently loaded interpreted modules (home package)
[bcos_loaded] :: LoaderState -> !LinkableSet

-- | And the currently-loaded compiled modules (home package)
[objs_loaded] :: LoaderState -> !LinkableSet

-- | The currently-loaded packages; always object code haskell libraries,
--   system libraries, transitive dependencies
[pkgs_loaded] :: LoaderState -> !PkgsLoaded

-- | We need to remember the name of previous temporary DLL/.so libraries
--   so we can link them (see #10322)
[temp_sos] :: LoaderState -> ![(FilePath, String)]

-- | Initialise the dynamic linker. This entails
--   
--   a) Calling the C initialisation procedure,
--   
--   b) Loading any packages specified on the command line,
--   
--   c) Loading any packages specified on the command line, now held in the
--   <tt>-l</tt> options in <tt>v_Opt_l</tt>,
--   
--   d) Loading any <tt>.o/.dll</tt> files specified on the command line,
--   now held in <tt>ldInputs</tt>,
--   
--   e) Loading any MacOS frameworks.
--   
--   NOTE: This function is idempotent; if called more than once, it does
--   nothing. This is useful in Template Haskell, where we call it before
--   trying to link.
initLoaderState :: Interp -> HscEnv -> IO ()
uninitializedLoader :: IO Loader

-- | Display the loader state.
showLoaderState :: Interp -> IO SDoc
getLoaderState :: Interp -> IO (Maybe LoaderState)

-- | Load a single expression, <i>including</i> first loading packages and
--   modules that this expression depends on.
--   
--   Raises an IO exception (<a>ProgramError</a>) if it can't find a
--   compiled version of the dependents to load.
loadExpr :: Interp -> HscEnv -> SrcSpan -> UnlinkedBCO -> IO ForeignHValue
loadDecls :: Interp -> HscEnv -> SrcSpan -> CompiledByteCode -> IO ([(Name, ForeignHValue)], [Linkable], PkgsLoaded)

-- | Load exactly the specified packages, and their dependents (unless of
--   course they are already loaded). The dependents are loaded
--   automatically, and it doesn't matter what order you specify the input
--   packages.
loadPackages :: Interp -> HscEnv -> [UnitId] -> IO ()
loadModule :: Interp -> HscEnv -> Module -> IO ()
loadCmdLineLibs :: Interp -> HscEnv -> IO ()

-- | Load the module containing the given Name and get its associated
--   <a>HValue</a>.
--   
--   Throws a <a>ProgramError</a> if loading fails or the name cannot be
--   found.
loadName :: Interp -> HscEnv -> Name -> IO (ForeignHValue, [Linkable], PkgsLoaded)

-- | Unloading old objects ready for a new compilation sweep.
--   
--   The compilation manager provides us with a list of linkables that it
--   considers "stable", i.e. won't be recompiled this time around. For
--   each of the modules current linked in memory,
--   
--   <ul>
--   <li>if the linkable is stable (and it's the same one -- the user may
--   have recompiled the module on the side), we keep it,</li>
--   <li>otherwise, we unload it.</li>
--   <li>we also implicitly unload all temporary bindings at this
--   point.</li>
--   </ul>
unload :: Interp -> HscEnv -> [Linkable] -> IO ()

-- | Temporarily extend the loaded env.
withExtendedLoadedEnv :: ExceptionMonad m => Interp -> [(Name, ForeignHValue)] -> m a -> m a
extendLoadedEnv :: Interp -> [(Name, ForeignHValue)] -> IO ()
deleteFromLoadedEnv :: Interp -> [Name] -> IO ()


-- | Dynamically lookup up values from modules and loading them.
module GHC.Runtime.Loader

-- | Loads the plugins specified in the pluginModNames field of the dynamic
--   flags. Should be called after command line arguments are parsed, but
--   before actual compilation starts. Idempotent operation. Should be
--   re-called if pluginModNames or pluginModNameOpts changes.
initializePlugins :: HscEnv -> IO HscEnv

-- | Initialise plugins specified by the current DynFlags and update the
--   session.
initializeSessionPlugins :: GhcMonad m => m ()
loadFrontendPlugin :: HscEnv -> ModuleName -> IO (FrontendPlugin, [Linkable], PkgsLoaded)

-- | Force the interfaces for the given modules to be loaded. The
--   <a>SDoc</a> parameter is used for debugging (<tt>-ddump-if-trace</tt>)
--   only: it is shown as the reason why the module is being loaded.
forceLoadModuleInterfaces :: HscEnv -> SDoc -> [Module] -> IO ()

-- | Force the interface for the module containing the name to be loaded.
--   The <a>SDoc</a> parameter is used for debugging
--   (<tt>-ddump-if-trace</tt>) only: it is shown as the reason why the
--   module is being loaded.
forceLoadNameModuleInterface :: HscEnv -> SDoc -> Name -> IO ()

-- | Load the <a>TyCon</a> associated with the given name, come hell or
--   high water. Fails if:
--   
--   <ul>
--   <li>The interface could not be loaded</li>
--   <li>The name is not that of a <a>TyCon</a></li>
--   <li>The name did not exist in the loaded module</li>
--   </ul>
forceLoadTyCon :: HscEnv -> Name -> IO TyCon

-- | Finds the <a>Name</a> corresponding to the given <a>RdrName</a> in the
--   context of the <a>ModuleName</a>. Returns <tt>Nothing</tt> if no such
--   <a>Name</a> could be found. Any other condition results in an
--   exception:
--   
--   <ul>
--   <li>If the module could not be found</li>
--   <li>If we could not determine the imports of the module</li>
--   </ul>
--   
--   Can only be used for looking up names while loading plugins (and is
--   *not* suitable for use within plugins). The interface file is loaded
--   very partially: just enough that it can be used, without its rules and
--   instances affecting (and being linked from!) the module being
--   compiled. This was introduced by 57d6798.
--   
--   Need the module as well to record information in the interface file
lookupRdrNameInModuleForPlugins :: HscEnv -> ModuleName -> RdrName -> IO (Maybe (Name, ModIface))

-- | Loads the value corresponding to a <a>Name</a> if that value has the
--   given <a>Type</a>. This only provides limited safety in that it is up
--   to the user to ensure that that type corresponds to the type you try
--   to use the return value at!
--   
--   If the value found was not of the correct type, returns <tt>Left
--   <a>actual_type</a></tt>. Any other condition results in an exception:
--   
--   <ul>
--   <li>If we could not load the names module</li>
--   <li>If the thing being loaded is not a value</li>
--   <li>If the Name does not exist in the module</li>
--   <li>If the link failed</li>
--   </ul>
getValueSafely :: HscEnv -> Name -> Type -> IO (Either Type (a, [Linkable], PkgsLoaded))
getHValueSafely :: Interp -> HscEnv -> Name -> Type -> IO (Either Type (HValue, [Linkable], PkgsLoaded))

-- | Coerce a value as usual, but:
--   
--   1) Evaluate it immediately to get a segfault early if the coercion was
--   wrong
--   
--   2) Wrap it in some debug messages at verbosity 3 or higher so we can
--   see what happened if it <i>does</i> segfault
lessUnsafeCoerce :: Logger -> String -> a -> IO b

module GHC.IfaceToCore
tcLookupImported_maybe :: Name -> TcM (MaybeErr SDoc TyThing)
importDecl :: Name -> IfM lcl (MaybeErr SDoc TyThing)
checkWiredInTyCon :: TyCon -> TcM ()
tcHiBootIface :: HscSource -> Module -> TcRn SelfBootInfo
typecheckIface :: ModIface -> IfG ModDetails
typecheckWholeCoreBindings :: IORef TypeEnv -> WholeCoreBindings -> IfG [CoreBind]

-- | This is a very interesting function. Like typecheckIface, we want to
--   type check an interface file into a ModDetails. However, the use-case
--   for these ModDetails is different: we want to compare all of the
--   ModDetails to ensure they define compatible declarations, and then
--   merge them together. So in particular, we have to take a different
--   strategy for knot-tying: we first speculatively merge the declarations
--   to get the "base" truth for what we believe the types will be (this is
--   "type computation.") Then we read everything in relative to this truth
--   and check for compatibility.
--   
--   During the merge process, we may need to nondeterministically pick a
--   particular declaration to use, if multiple signatures define the
--   declaration (<a>mergeIfaceDecl</a>). If, for all choices, there are no
--   type synonym cycles in the resulting merged graph, then we can show
--   that our choice cannot matter. Consider the set of entities which the
--   declarations depend on: by assumption of acyclicity, we can assume
--   that these have already been shown to be equal to each other
--   (otherwise merging will fail). Then it must be the case that all
--   candidate declarations here are type-equal (the choice doesn't matter)
--   or there is an inequality (in which case merging will fail.)
--   
--   Unfortunately, the choice can matter if there is a cycle. Consider the
--   following merge:
--   
--   signature H where { type A = C; type B = A; data C } signature H where
--   { type A = (); data B; type C = B }
--   
--   If we pick <tt>type A = C</tt> as our representative, there will be a
--   cycle and merging will fail. But if we pick <tt>type A = ()</tt> as
--   our representative, no cycle occurs, and we instead conclude that all
--   of the types are unit. So it seems that we either (a) need a stronger
--   acyclicity check which considers *all* possible choices from a merge,
--   or (b) we must find a selection of declarations which is acyclic, and
--   show that this is always the "best" choice we could have made (ezyang
--   conjectures this is the case but does not have a proof). For now this
--   is not implemented.
--   
--   It's worth noting that at the moment, a data constructor and a type
--   synonym are never compatible. Consider:
--   
--   signature H where { type Int=C; type B = Int; data C = Int} signature
--   H where { export Prelude.Int; data B; type C = B; }
--   
--   This will be rejected, because the reexported Int in the second
--   signature (a proper data type) is never considered equal to a type
--   synonym. Perhaps this should be relaxed, where a type synonym in a
--   signature is considered implemented by a data type declaration which
--   matches the reference of the type synonym.
typecheckIfacesForMerging :: Module -> [ModIface] -> KnotVars (IORef TypeEnv) -> IfM lcl (TypeEnv, [ModDetails])

-- | Typecheck a signature <a>ModIface</a> under the assumption that we
--   have instantiated it under some implementation (recorded in
--   <a>mi_semantic_module</a>) and want to check if the implementation
--   fills the signature.
--   
--   This needs to operate slightly differently than <a>typecheckIface</a>
--   because (1) we have a <a>NameShape</a>, from the exports of the
--   implementing module, which we will use to give our top-level
--   declarations the correct <a>Name</a>s even when the implementor
--   provided them with a reexport, and (2) we have to deal with DFun
--   silliness (see Note [rnIfaceNeverExported])
typecheckIfaceForInstantiate :: NameShape -> ModIface -> IfM lcl ModDetails
tcIfaceDecl :: Bool -> IfaceDecl -> IfL TyThing
tcIfaceDecls :: Bool -> [(Fingerprint, IfaceDecl)] -> IfL [(Name, TyThing)]
tcIfaceInst :: IfaceClsInst -> IfL ClsInst
tcIfaceFamInst :: IfaceFamInst -> IfL FamInst
tcIfaceRules :: Bool -> [IfaceRule] -> IfL [CoreRule]
tcIfaceAnnotations :: [IfaceAnnotation] -> IfL [Annotation]
tcIfaceCompleteMatches :: [IfaceCompleteMatch] -> IfL [CompleteMatch]
tcIfaceExpr :: IfaceExpr -> IfL CoreExpr
tcIfaceGlobal :: Name -> IfL TyThing
tcIfaceOneShot :: IfaceOneShot -> OneShotInfo
tcTopIfaceBindings :: IORef TypeEnv -> [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo] -> IfL [CoreBind]
hydrateCgBreakInfo :: CgBreakInfo -> IfL ([Maybe (Id, Word16)], Type)


-- | Typechecking user-specified <tt>MonoTypes</tt>
module GHC.Tc.Gen.HsType
kcClassSigType :: [LocatedN Name] -> LHsSigType GhcRn -> TcM ()
tcClassSigType :: [LocatedN Name] -> LHsSigType GhcRn -> TcM Type
tcHsSigType :: UserTypeCtxt -> LHsSigType GhcRn -> TcM Type
tcHsSigWcType :: UserTypeCtxt -> LHsSigWcType GhcRn -> TcM Type
tcHsPartialSigType :: UserTypeCtxt -> LHsSigWcType GhcRn -> TcM ([(Name, TcTyVar)], Maybe TcType, [(Name, InvisTVBinder)], TcThetaType, TcType)
tcStandaloneKindSig :: LStandaloneKindSig GhcRn -> TcM (Name, Kind)
funsSigCtxt :: [LocatedN Name] -> UserTypeCtxt
addSigCtxt :: Outputable hs_ty => UserTypeCtxt -> LocatedA hs_ty -> TcM a -> TcM a
pprSigCtxt :: Outputable hs_ty => UserTypeCtxt -> LocatedA hs_ty -> SDoc
tcHsClsInstType :: UserTypeCtxt -> LHsSigType GhcRn -> TcM Type
tcHsDeriv :: LHsSigType GhcRn -> TcM ([TyVar], Class, [Type], [Kind])

-- | Typecheck a deriving strategy. For most deriving strategies, this is a
--   no-op, but for the <tt>via</tt> strategy, this requires typechecking
--   the <tt>via</tt> type.
tcDerivStrategy :: Maybe (LDerivStrategy GhcRn) -> TcM (Maybe (LDerivStrategy GhcTc), [TcTyVar])

-- | Type-check a visible type application
tcHsTypeApp :: LHsWcType GhcRn -> Kind -> TcM Type

-- | UserTypeCtxt describes the origin of the polymorphic type in the
--   places where we need an expression to have that type
data UserTypeCtxt
FunSigCtxt :: Name -> ReportRedundantConstraints -> UserTypeCtxt
InfSigCtxt :: Name -> UserTypeCtxt
ExprSigCtxt :: ReportRedundantConstraints -> UserTypeCtxt
KindSigCtxt :: UserTypeCtxt
StandaloneKindSigCtxt :: Name -> UserTypeCtxt
TypeAppCtxt :: UserTypeCtxt
ConArgCtxt :: Name -> UserTypeCtxt
TySynCtxt :: Name -> UserTypeCtxt
PatSynCtxt :: Name -> UserTypeCtxt
PatSigCtxt :: UserTypeCtxt
RuleSigCtxt :: FastString -> Name -> UserTypeCtxt
ForSigCtxt :: Name -> UserTypeCtxt
DefaultDeclCtxt :: UserTypeCtxt
InstDeclCtxt :: Bool -> UserTypeCtxt
SpecInstCtxt :: UserTypeCtxt
GenSigCtxt :: UserTypeCtxt
GhciCtxt :: Bool -> UserTypeCtxt
ClassSCCtxt :: Name -> UserTypeCtxt
SigmaCtxt :: UserTypeCtxt
DataTyCtxt :: Name -> UserTypeCtxt
DerivClauseCtxt :: UserTypeCtxt
TyVarBndrKindCtxt :: Name -> UserTypeCtxt
DataKindCtxt :: Name -> UserTypeCtxt
TySynKindCtxt :: Name -> UserTypeCtxt
TyFamResKindCtxt :: Name -> UserTypeCtxt
bindImplicitTKBndrs_Tv :: [Name] -> TcM a -> TcM ([TcTyVar], a)
bindImplicitTKBndrs_Skol :: SkolemInfo -> [Name] -> TcM a -> TcM ([TcTyVar], a)
bindImplicitTKBndrs_Q_Tv :: [Name] -> TcM a -> TcM ([TcTyVar], a)
bindImplicitTKBndrs_Q_Skol :: SkolemInfo -> [Name] -> TcM a -> TcM ([TcTyVar], a)
bindExplicitTKBndrs_Tv :: OutputableBndrFlag flag 'Renamed => [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)

-- | Skolemise the <a>HsTyVarBndr</a>s in an <a>HsForAllTelescope</a> with
--   the supplied <a>TcTyMode</a>.
bindExplicitTKBndrs_Skol :: OutputableBndrFlag flag 'Renamed => SkolemInfo -> [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)
bindExplicitTKBndrs_Q_Tv :: ContextKind -> [LHsTyVarBndr () GhcRn] -> TcM a -> TcM ([TcTyVar], a)
bindExplicitTKBndrs_Q_Skol :: SkolemInfo -> ContextKind -> [LHsTyVarBndr () GhcRn] -> TcM a -> TcM ([TcTyVar], a)
bindOuterFamEqnTKBndrs_Q_Tv :: HsOuterFamEqnTyVarBndrs GhcRn -> TcM a -> TcM (HsOuterFamEqnTyVarBndrs GhcTc, a)
bindOuterFamEqnTKBndrs :: SkolemInfo -> HsOuterFamEqnTyVarBndrs GhcRn -> TcM a -> TcM (HsOuterFamEqnTyVarBndrs GhcTc, a)
tcOuterTKBndrs :: OutputableBndrFlag flag 'Renamed => SkolemInfo -> HsOuterTyVarBndrs flag GhcRn -> TcM a -> TcM (HsOuterTyVarBndrs flag GhcTc, a)
scopedSortOuter :: HsOuterTyVarBndrs flag GhcTc -> TcM (HsOuterTyVarBndrs flag GhcTc)
outerTyVars :: HsOuterTyVarBndrs flag GhcTc -> [TcTyVar]
outerTyVarBndrs :: HsOuterTyVarBndrs Specificity GhcTc -> [InvisTVBinder]
bindOuterSigTKBndrs_Tv :: HsOuterSigTyVarBndrs GhcRn -> TcM a -> TcM (HsOuterSigTyVarBndrs GhcTc, a)
tcExplicitTKBndrs :: OutputableBndrFlag flag 'Renamed => SkolemInfo -> [LHsTyVarBndr flag GhcRn] -> TcM a -> TcM ([VarBndr TyVar flag], a)
bindNamedWildCardBinders :: [Name] -> ([(Name, TcTyVar)] -> TcM a) -> TcM a

-- | Bring into scope the binders of a PolyTcTyCon Used for the type
--   variables of a type or class decl in the "kind checking" and "type
--   checking" pass, but not in the initial-kind run.
bindTyClTyVars :: Name -> ([TcTyConBinder] -> TcKind -> TcM a) -> TcM a
bindTyClTyVarsAndZonk :: Name -> ([TyConBinder] -> Kind -> TcM a) -> TcM a
tcFamTyPats :: TyCon -> HsTyPats GhcRn -> TcM (TcType, TcKind)
etaExpandAlgTyCon :: TyConFlavour -> SkolemInfo -> [TcTyConBinder] -> Kind -> TcM ([TcTyConBinder], Kind)
tcbVisibilities :: TyCon -> [Type] -> [TyConBndrVis]
zonkAndScopedSort :: [TcTyVar] -> TcM [TcTyVar]
data InitialKindStrategy
InitialKindCheck :: SAKS_or_CUSK -> InitialKindStrategy
InitialKindInfer :: InitialKindStrategy
data SAKS_or_CUSK
SAKS :: Kind -> SAKS_or_CUSK
CUSK :: SAKS_or_CUSK

-- | Describes the kind expected in a certain context.
data ContextKind

-- | a specific kind
TheKind :: TcKind -> ContextKind

-- | any kind will do
AnyKind :: ContextKind

-- | something of the form <tt>TYPE _</tt>
OpenKind :: ContextKind
kcDeclHeader :: InitialKindStrategy -> Name -> TyConFlavour -> LHsQTyVars GhcRn -> TcM ContextKind -> TcM TcTyCon
checkForDuplicateScopedTyVars :: [(Name, TcTyVar)] -> TcM ()
tcHsLiftedType :: LHsType GhcRn -> TcM TcType
tcHsOpenType :: LHsType GhcRn -> TcM TcType
tcHsLiftedTypeNC :: LHsType GhcRn -> TcM TcType
tcHsOpenTypeNC :: LHsType GhcRn -> TcM TcType
tcInferLHsType :: LHsType GhcRn -> TcM TcType
tcInferLHsTypeKind :: LHsType GhcRn -> TcM (TcType, TcKind)
tcInferLHsTypeUnsaturated :: LHsType GhcRn -> TcM (TcType, TcKind)
tcCheckLHsType :: LHsType GhcRn -> ContextKind -> TcM TcType
tcHsContext :: Maybe (LHsContext GhcRn) -> TcM [PredType]
tcLHsPredType :: LHsType GhcRn -> TcM PredType

-- | <ul>
--   <li>Specialised version of <a>kindGeneralizeSome</a>, but with empty
--   WantedConstraints, so no filtering is needed i.e. kindGeneraliseAll =
--   kindGeneralizeSome emptyWC</li>
--   </ul>
kindGeneralizeAll :: SkolemInfo -> TcType -> TcM [KindVar]
tcLHsKindSig :: UserTypeCtxt -> LHsKind GhcRn -> TcM Kind

-- | Checks that the return kind in a data declaration's kind signature is
--   permissible. There are three cases:
--   
--   If dealing with a <tt>data</tt>, <tt>newtype</tt>, <tt>data
--   instance</tt>, or <tt>newtype instance</tt> declaration, check that
--   the return kind is <tt>Type</tt>.
--   
--   If the declaration is a <tt>newtype</tt> or <tt>newtype instance</tt>
--   and the <tt>UnliftedNewtypes</tt> extension is enabled, this check is
--   slightly relaxed so that a return kind of the form <tt>TYPE r</tt>
--   (for some <tt>r</tt>) is permitted. See <tt>Note [Implementation of
--   UnliftedNewtypes]</tt> in <a>GHC.Tc.TyCl</a>.
--   
--   If dealing with a <tt>data family</tt> declaration, check that the
--   return kind is either of the form:
--   
--   <ol>
--   <li><tt>TYPE r</tt> (for some <tt>r</tt>), or</li>
--   <li><tt>k</tt> (where <tt>k</tt> is a bare kind variable; see
--   #12369)</li>
--   </ol>
--   
--   See also Note [Datatype return kinds] in <a>GHC.Tc.TyCl</a>
checkDataKindSig :: DataSort -> Kind -> TcM ()

-- | A description of whether something is a
--   
--   <ul>
--   <li><tt>data</tt> or <tt>newtype</tt> (<a>DataDeclSort</a>)</li>
--   <li><tt>data instance</tt> or <tt>newtype instance</tt>
--   (<a>DataInstanceSort</a>)</li>
--   <li><tt>data family</tt> (<a>DataFamilySort</a>)</li>
--   </ul>
--   
--   At present, this data type is only consumed by
--   <tt>checkDataKindSig</tt>.
data DataSort
DataDeclSort :: NewOrData -> DataSort
DataInstanceSort :: NewOrData -> DataSort
DataFamilySort :: DataSort

-- | Checks that the result kind of a class is exactly <tt>Constraint</tt>,
--   rejecting type synonyms and type families that reduce to
--   <tt>Constraint</tt>. See #16826.
checkClassKindSig :: Kind -> TcM ()
tcMult :: HsArrow GhcRn -> TcM Mult
tcHsPatSigType :: UserTypeCtxt -> HoleMode -> HsPatSigType GhcRn -> ContextKind -> TcM ([(Name, TcTyVar)], [(Name, TcTyVar)], TcType)
data HoleMode
HM_Sig :: HoleMode
HM_FamPat :: HoleMode
HM_VTA :: HoleMode
HM_TyAppPat :: HoleMode

-- | Make an appropriate message for an error in a function argument. Used
--   for both expressions and types.
funAppCtxt :: (Outputable fun, Outputable arg) => fun -> arg -> Int -> SDoc

-- | Add a "In the data declaration for T" or some such.
addTyConFlavCtxt :: Name -> TyConFlavour -> TcM a -> TcM a
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.HsType.SAKS_or_CUSK
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.HsType.TcTyMode
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.HsType.HoleMode

module GHC.Tc.Gen.Sig
data TcSigInfo
TcIdSig :: TcIdSigInfo -> TcSigInfo
TcPatSynSig :: TcPatSynInfo -> TcSigInfo
data TcIdSigInfo
CompleteSig :: TcId -> UserTypeCtxt -> SrcSpan -> TcIdSigInfo
[sig_bndr] :: TcIdSigInfo -> TcId
[sig_ctxt] :: TcIdSigInfo -> UserTypeCtxt
[sig_loc] :: TcIdSigInfo -> SrcSpan
PartialSig :: Name -> LHsSigWcType GhcRn -> UserTypeCtxt -> SrcSpan -> TcIdSigInfo
[psig_name] :: TcIdSigInfo -> Name
[psig_hs_ty] :: TcIdSigInfo -> LHsSigWcType GhcRn
[sig_ctxt] :: TcIdSigInfo -> UserTypeCtxt
[sig_loc] :: TcIdSigInfo -> SrcSpan
data TcIdSigInst
data TcPatSynInfo
TPSI :: Name -> [InvisTVBinder] -> [InvisTVBinder] -> TcThetaType -> [InvisTVBinder] -> TcThetaType -> TcSigmaType -> TcPatSynInfo
[patsig_name] :: TcPatSynInfo -> Name
[patsig_implicit_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_univ_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_req] :: TcPatSynInfo -> TcThetaType
[patsig_ex_bndrs] :: TcPatSynInfo -> [InvisTVBinder]
[patsig_prov] :: TcPatSynInfo -> TcThetaType
[patsig_body_ty] :: TcPatSynInfo -> TcSigmaType
type TcSigFun = Name -> Maybe TcSigInfo
isPartialSig :: TcIdSigInst -> Bool

-- | No signature or a partial signature
hasCompleteSig :: TcSigFun -> Name -> Bool
tcIdSigName :: TcIdSigInfo -> Name
tcSigInfoName :: TcSigInfo -> Name
completeSigPolyId_maybe :: TcSigInfo -> Maybe TcId

-- | If there are no wildcards, return a LHsSigWcType
isCompleteHsSig :: LHsSigWcType GhcRn -> Bool

-- | Find the location of the top-level context of a HsType. For example:
--   
--   <pre>
--   forall a b. (Eq a, Ord b) =&gt; blah
--               ^^^^^^^^^^^^^
--   </pre>
--   
--   If there is none, return Nothing
lhsSigWcTypeContextSpan :: LHsSigWcType GhcRn -> ReportRedundantConstraints
lhsSigTypeContextSpan :: LHsSigType GhcRn -> ReportRedundantConstraints
tcTySigs :: [LSig GhcRn] -> TcM ([TcId], TcSigFun)
tcUserTypeSig :: SrcSpan -> LHsSigWcType GhcRn -> Maybe Name -> TcM TcIdSigInfo
completeSigFromId :: UserTypeCtxt -> Id -> TcIdSigInfo
tcInstSig :: TcIdSigInfo -> TcM TcIdSigInst
type TcPragEnv = NameEnv [LSig GhcRn]
emptyPragEnv :: TcPragEnv
lookupPragEnv :: TcPragEnv -> Name -> [LSig GhcRn]
extendPragEnv :: TcPragEnv -> (Name, LSig GhcRn) -> TcPragEnv
mkPragEnv :: [LSig GhcRn] -> LHsBinds GhcRn -> TcPragEnv
tcSpecPrags :: Id -> [LSig GhcRn] -> TcM [LTcSpecPrag]
tcSpecWrapper :: UserTypeCtxt -> TcType -> TcType -> TcM HsWrapper
tcImpPrags :: [LSig GhcRn] -> TcM [LTcSpecPrag]
addInlinePrags :: TcId -> [LSig GhcRn] -> TcM TcId
addInlinePragArity :: Arity -> LSig GhcRn -> LSig GhcRn


-- | Typechecking patterns
module GHC.Tc.Gen.Pat
tcLetPat :: (Name -> Maybe TcId) -> LetBndrSpec -> LPat GhcRn -> Scaled ExpSigmaTypeFRR -> TcM a -> TcM (LPat GhcTc, a)
newLetBndr :: LetBndrSpec -> Name -> Mult -> TcType -> TcM TcId
data LetBndrSpec
LetLclBndr :: LetBndrSpec
LetGblBndr :: TcPragEnv -> LetBndrSpec
tcCheckPat :: HsMatchContext GhcTc -> LPat GhcRn -> Scaled TcSigmaTypeFRR -> TcM a -> TcM (LPat GhcTc, a)

-- | A variant of <tt>tcPat</tt> that takes a custom origin
tcCheckPat_O :: HsMatchContext GhcTc -> CtOrigin -> LPat GhcRn -> Scaled TcSigmaTypeFRR -> TcM a -> TcM (LPat GhcTc, a)
tcInferPat :: FixedRuntimeRepContext -> HsMatchContext GhcTc -> LPat GhcRn -> TcM a -> TcM ((LPat GhcTc, a), TcSigmaTypeFRR)
tcPats :: HsMatchContext GhcTc -> [LPat GhcRn] -> [Scaled ExpSigmaTypeFRR] -> TcM a -> TcM ([LPat GhcTc], a)
addDataConStupidTheta :: DataCon -> [TcType] -> TcM ()
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Pat.LetBndrSpec


-- | Typechecking <tt>default</tt> declarations
module GHC.Tc.Gen.Default
tcDefaults :: [LDefaultDecl GhcRn] -> TcM (Maybe [Type])

module GHC.Tc.Gen.Bind
tcLocalBinds :: HsLocalBinds GhcRn -> TcM thing -> TcM (HsLocalBinds GhcTc, thing)
tcTopBinds :: [(RecFlag, LHsBinds GhcRn)] -> [LSig GhcRn] -> TcM (TcGblEnv, TcLclEnv)
tcValBinds :: TopLevelFlag -> [(RecFlag, LHsBinds GhcRn)] -> [LSig GhcRn] -> TcM thing -> TcM ([(RecFlag, LHsBinds GhcTc)], thing)
tcHsBootSigs :: [(RecFlag, LHsBinds GhcRn)] -> [LSig GhcRn] -> TcM [Id]
tcPolyCheck :: TcPragEnv -> TcIdSigInfo -> LHsBind GhcRn -> TcM (LHsBinds GhcTc, [TcId])
chooseInferredQuantifiers :: WantedConstraints -> TcThetaType -> TcTyVarSet -> [TcTyVar] -> Maybe TcIdSigInst -> TcM ([InvisTVBinder], TcThetaType)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Bind.GeneralisationPlan


-- | Analysis functions over data types. Specifically, detecting recursive
--   types.
--   
--   This stuff is only used for source-code decls; it's recorded in
--   interface files for imported data types.
module GHC.Tc.TyCl.Utils
type RolesInfo = Name -> [Role]
inferRoles :: HscSource -> RoleAnnotEnv -> [TyCon] -> Name -> [Role]

-- | Checks if any of the passed in <a>TyCon</a>s have cycles. Takes the
--   <a>Unit</a> of the home package (as we can avoid checking those
--   TyCons: cycles never go through foreign packages) and the
--   corresponding <tt>LTyClDecl Name</tt> for each <a>TyCon</a>, so we can
--   give better error messages.
checkSynCycles :: Unit -> [TyCon] -> [LTyClDecl GhcRn] -> TcM ()
checkClassCycles :: Class -> Maybe SDoc
addTyConsToGblEnv :: [TyCon] -> TcM (TcGblEnv, ThBindEnv)
mkDefaultMethodType :: Class -> Id -> DefMethSpec Type -> Type
tcRecSelBinds :: [(Id, LHsBind GhcRn)] -> TcM TcGblEnv
mkRecSelBinds :: [TyCon] -> [(Id, LHsBind GhcRn)]
mkOneRecordSelector :: [ConLike] -> RecSelParent -> FieldLabel -> FieldSelectors -> (Id, LHsBind GhcRn)
instance GHC.Base.Functor GHC.Tc.TyCl.Utils.SynCycleM
instance GHC.Base.Functor GHC.Tc.TyCl.Utils.RoleM
instance GHC.Base.Applicative GHC.Tc.TyCl.Utils.RoleM
instance GHC.Base.Monad GHC.Tc.TyCl.Utils.RoleM
instance GHC.Base.Applicative GHC.Tc.TyCl.Utils.SynCycleM
instance GHC.Base.Monad GHC.Tc.TyCl.Utils.SynCycleM

module GHC.Tc.Utils.Backpack

-- | For a module <tt>modname</tt> of type <a>HscSource</a>, determine the
--   list of extra "imports" of other requirements which should be
--   considered part of the import of the requirement, because it
--   transitively depends on those requirements by imports of modules from
--   other packages. The situation is something like this:
--   
--   unit p where signature X signature Y import X
--   
--   unit q where dependency p[X=&lt;A&gt;,Y=&lt;B&gt;] signature A
--   signature B
--   
--   Although q's B does not directly import A, we still have to make sure
--   we process A first, because the merging process will cause B to
--   indirectly import A. This function finds the TRANSITIVE closure of all
--   such imports we need to make.
findExtraSigImports :: HscEnv -> HscSource -> ModuleName -> IO [ModuleName]
implicitRequirements :: HscEnv -> [(PkgQual, Located ModuleName)] -> IO [ModuleName]

-- | Like <tt>implicitRequirements'</tt>, but returns either the module
--   name, if it is a free hole, or the instantiated unit the imported
--   module is from, so that that instantiated unit can be processed and
--   via the batch mod graph (rather than a transitive closure done here)
--   all the free holes are still reachable.
implicitRequirementsShallow :: HscEnv -> [(PkgQual, Located ModuleName)] -> IO ([ModuleName], [InstantiatedUnit])

-- | Given a <a>Unit</a>, make sure it is well typed. This is because unit
--   IDs come from Cabal, which does not know if things are well-typed or
--   not; a component may have been filled with implementations for the
--   holes that don't actually fulfill the requirements.
checkUnit :: Unit -> TcM ()

-- | Top-level driver for signature instantiation (run when compiling an
--   <tt>hsig</tt> file.)
tcRnCheckUnit :: HscEnv -> Unit -> IO (Messages TcRnMessage, Maybe ())

-- | Top-level driver for signature merging (run after typechecking an
--   <tt>hsig</tt> file).
tcRnMergeSignatures :: HscEnv -> HsParsedModule -> TcGblEnv -> ModIface -> IO (Messages TcRnMessage, Maybe TcGblEnv)

-- | Given a local <a>ModIface</a>, merge all inherited requirements from
--   <a>requirementMerges</a> into this signature, producing a final
--   <a>TcGblEnv</a> that matches the local signature and all required
--   signatures.
mergeSignatures :: HsParsedModule -> TcGblEnv -> ModIface -> TcRn TcGblEnv

-- | Top-level driver for signature instantiation (run when compiling an
--   <tt>hsig</tt> file.)
tcRnInstantiateSignature :: HscEnv -> Module -> RealSrcSpan -> IO (Messages TcRnMessage, Maybe TcGblEnv)

-- | Given <a>tcg_mod</a>, instantiate a <a>ModIface</a> from the
--   indefinite library to use the actual implementations of the relevant
--   entities, checking that the implementation matches the signature.
instantiateSignature :: TcRn TcGblEnv


-- | Typechecking pattern synonym declarations
module GHC.Tc.TyCl.PatSyn
tcPatSynDecl :: LocatedA (PatSynBind GhcRn GhcRn) -> TcSigFun -> TcPragEnv -> TcM (LHsBinds GhcTc, TcGblEnv)
tcPatSynBuilderBind :: TcPragEnv -> PatSynBind GhcRn GhcRn -> TcM (LHsBinds GhcTc)
patSynBuilderOcc :: PatSyn -> Maybe (HsExpr GhcTc, TcSigmaType)


-- | Typechecking class declarations
module GHC.Tc.TyCl.Class
tcClassSigs :: Name -> [LSig GhcRn] -> LHsBinds GhcRn -> TcM [TcMethInfo]
tcClassDecl2 :: LTyClDecl GhcRn -> TcM (LHsBinds GhcTc)
findMethodBind :: Name -> LHsBinds GhcRn -> TcPragEnv -> Maybe (LHsBind GhcRn, SrcSpan, [LSig GhcRn])
instantiateMethod :: Class -> TcId -> [TcType] -> TcType
tcClassMinimalDef :: Name -> [LSig GhcRn] -> [TcMethInfo] -> TcM ClassMinimalDef
type HsSigFun = Name -> Maybe (LHsSigType GhcRn)
mkHsSigFun :: [LSig GhcRn] -> HsSigFun
instDeclCtxt1 :: LHsSigType GhcRn -> SDoc
instDeclCtxt2 :: Type -> SDoc
instDeclCtxt3 :: Class -> [Type] -> SDoc

-- | Construct default instances for any associated types that aren't given
--   a user definition Returns [] or singleton
tcATDefault :: SrcSpan -> Subst -> NameSet -> ClassATItem -> TcM [FamInst]

-- | Apply a substitution to the type variable binders of an associated
--   type family. This is used to compute default instances for associated
--   type families (see <a>tcATDefault</a>) as well as
--   <tt>newtype</tt>-derived associated type family instances (see
--   <tt>gen_Newtype_fam_insts</tt> in <a>GHC.Tc.Deriv.Generate</a>).
--   
--   As a concrete example, consider the following class and associated
--   type family:
--   
--   <pre>
--   class C k (a :: k) where
--     type F k a (b :: k) :: Type
--     type F j p q = (Proxy <tt>j p, Proxy </tt>j (q :: j))
--   </pre>
--   
--   If a user defines this instance:
--   
--   <pre>
--   instance C (Type -&gt; Type) Maybe where {}
--   </pre>
--   
--   Then in order to typecheck the default <tt>F</tt> instance, we must
--   apply the substitution <tt>[k :-&gt; (Type -&gt; Type), a :-&gt;
--   Maybe]</tt> to <tt>F</tt>'s binders, which are <tt>[k, a, (b ::
--   k)]</tt>. The result should look like this:
--   
--   <pre>
--   type F (Type -&gt; Type) Maybe (b :: Type -&gt; Type) =
--     (Proxy <tt>(Type -&gt; Type) Maybe, Proxy </tt>(Type -&gt; Type) (b :: Type -&gt; Type))
--   </pre>
--   
--   Making this work requires some care. There are two cases:
--   
--   <ol>
--   <li>If we encounter a type variable in the domain of the substitution
--   (e.g., <tt>k</tt> or <tt>a</tt>), then we apply the substitution
--   directly.</li>
--   <li>Otherwise, we substitute into the type variable's kind (e.g., turn
--   <tt>b :: k</tt> to <tt>b :: Type -&gt; Type</tt>). We then return an
--   extended substitution where the old <tt>b</tt> (of kind <tt>k</tt>)
--   maps to the new <tt>b</tt> (of kind <tt>Type -&gt; Type</tt>).</li>
--   </ol>
--   
--   This step is important to do in case there are later occurrences of
--   <tt>b</tt>, which we must ensure have the correct kind. Otherwise, we
--   might end up with <tt>Proxy @(Type -&gt; Type) (b :: k)</tt> on the
--   right-hand side of the default instance, which would be completely
--   wrong.
--   
--   Contrast <a>substATBndrs</a> function with similar substitution
--   functions:
--   
--   <ul>
--   <li><tt>substTyVars</tt> does not substitute into the kinds of each
--   type variable, nor does it extend the substitution.
--   <tt>substTyVars</tt> is meant for occurrences of type variables,
--   whereas <tt>substATBndr</tt>s is meant for binders.</li>
--   <li><tt>substTyVarBndrs</tt> does substitute into kinds and extends
--   the substitution, but it does not apply the substitution to the
--   variables themselves. As such, <tt>substTyVarBndrs</tt> returns a list
--   of <a>TyVar</a>s rather than a list of <a>Type</a>s.</li>
--   </ul>
substATBndrs :: Subst -> [TyVar] -> (Subst, [Type])


-- | Generating derived instance declarations
--   
--   This module is nominally `<tt>subordinate'</tt> to
--   <a>GHC.Tc.Deriv</a>, which is the `<tt>official'</tt> interface to
--   deriving-related things.
--   
--   This is where we do all the grimy bindings' generation.
module GHC.Tc.Deriv.Generate

-- | A declarative description of an auxiliary binding that should be
--   generated. See <tt>Note [Auxiliary binders]</tt> for a more detailed
--   description of how these are used.
data AuxBindSpec

-- | <tt>$tag2con</tt>: Given a tag, computes the corresponding data
--   constructor
DerivTag2Con :: TyCon -> RdrName -> AuxBindSpec

-- | <tt>$maxtag</tt>: The maximum possible tag value among a data type's
--   constructors
DerivMaxTag :: TyCon -> RdrName -> AuxBindSpec

-- | <tt>$t</tt>: The <tt>DataType</tt> representation for a <tt>Data</tt>
--   instance
DerivDataDataType :: TyCon -> RdrName -> [RdrName] -> AuxBindSpec

-- | <tt>$c</tt>: The <tt>Constr</tt> representation for a <tt>Data</tt>
--   instance
DerivDataConstr :: DataCon -> RdrName -> RdrName -> AuxBindSpec
gen_Eq_binds :: SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Ord_binds :: SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Enum_binds :: SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Bounded_binds :: SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Ix_binds :: SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Show_binds :: (Name -> Fixity) -> SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Read_binds :: (Name -> Fixity) -> SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Data_binds :: SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Lift_binds :: SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Newtype_binds :: SrcSpan -> Class -> [TyVar] -> [Type] -> Type -> (LHsBinds GhcPs, [LSig GhcPs])
gen_Newtype_fam_insts :: SrcSpan -> Class -> [TyVar] -> [Type] -> Type -> TcM [FamInst]
mkCoerceClassMethEqn :: Class -> [TyVar] -> [Type] -> Type -> Id -> Pair Type

-- | Take a <a>Bag</a> of <a>AuxBindSpec</a>s and generate the code for
--   auxiliary bindings based on the declarative descriptions in the
--   supplied <a>AuxBindSpec</a>s. See <tt>Note [Auxiliary binders]</tt>.
genAuxBinds :: SrcSpan -> Bag AuxBindSpec -> Bag (LHsBind GhcPs, LSig GhcPs)
ordOpTbl :: [(Type, (RdrName, RdrName, RdrName, RdrName, RdrName))]
boxConTbl :: [(Type, LHsExpr GhcPs -> LHsExpr GhcPs)]
litConTbl :: [(Type, LHsExpr GhcPs -> LHsExpr GhcPs)]
mkRdrFunBind :: LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsBind GhcPs

-- | Produces a function binding. When no equations are given, it generates
--   a binding of the given arity and an empty case expression for the last
--   argument that it passes to the given function to produce the
--   right-hand side.
mkRdrFunBindEC :: Arity -> (LHsExpr GhcPs -> LHsExpr GhcPs) -> LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsBind GhcPs

-- | Produces a function binding. When there are no equations, it generates
--   a binding with the given arity that produces an error based on the
--   name of the type of the last argument.
mkRdrFunBindSE :: Arity -> LocatedN RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsBind GhcPs
error_Expr :: FastString -> LHsExpr GhcPs

-- | <tt>getPossibleDataCons tycon tycon_args</tt> returns the constructors
--   of <tt>tycon</tt> whose return types match when checked against
--   <tt>tycon_args</tt>.
--   
--   See Note [Filter out impossible GADT data constructors]
getPossibleDataCons :: TyCon -> [Type] -> [DataCon]

-- | Information about the arguments to the class in a stock- or
--   newtype-derived instance. For a <tt>deriving</tt>-generated instance
--   declaration such as this one:
--   
--   <pre>
--   instance Ctx =&gt; Cls cls_ty_1 ... cls_ty_m (TC tc_arg_1 ... tc_arg_n) where ...
--   </pre>
--   
--   <ul>
--   <li><a>dit_cls_tys</a> corresponds to <tt>cls_ty_1 ...
--   cls_ty_m</tt>.</li>
--   <li><a>dit_tc</a> corresponds to <tt>TC</tt>.</li>
--   <li><a>dit_tc_args</a> corresponds to <tt>tc_arg_1 ...
--   tc_arg_n</tt>.</li>
--   </ul>
--   
--   See <tt>Note [DerivEnv and DerivSpecMechanism]</tt> in
--   <a>GHC.Tc.Deriv.Utils</a> for a more in-depth explanation, including
--   the relationship between <a>dit_tc</a><i><a>dit_rep_tc</a> and
--   <a>dit_tc_args</a></i><a>dit_rep_tc_args</a>.
--   
--   A <a>DerivInstTys</a> value can be seen as a more structured
--   representation of the <tt>denv_inst_tys</tt> in a <tt>DerivEnv</tt>,
--   as the <tt>denv_inst_tys</tt> is equal to <tt>dit_cls_tys ++
--   [<a>mkTyConApp</a> dit_tc dit_tc_args]</tt>. Other parts of the
--   instance declaration can be found in the <tt>DerivEnv</tt>. For
--   example, the <tt>Cls</tt> in the example above corresponds to the
--   <tt>denv_cls</tt> field of <tt>DerivEnv</tt>.
--   
--   Similarly, the type variables that appear in a <a>DerivInstTys</a>
--   value are the same type variables as the <tt>denv_tvs</tt> in the
--   parent <tt>DerivEnv</tt>. Accordingly, if we are inferring an instance
--   context, the type variables will be <a>TcTyVar</a> skolems. Otherwise,
--   they will be ordinary <a>TyVar</a>s. See <tt>Note [Overlap and
--   deriving]</tt> in <a>GHC.Tc.Deriv.Infer</a>.
data DerivInstTys
DerivInstTys :: [Type] -> TyCon -> [Type] -> TyCon -> [Type] -> DataConEnv [Type] -> DerivInstTys

-- | Other arguments to the class except the last
[dit_cls_tys] :: DerivInstTys -> [Type]

-- | Type constructor for which the instance is requested (last arguments
--   to the type class)
[dit_tc] :: DerivInstTys -> TyCon

-- | Arguments to the type constructor
[dit_tc_args] :: DerivInstTys -> [Type]

-- | The representation tycon for <a>dit_tc</a> (for data family
--   instances). Otherwise the same as <a>dit_tc</a>.
[dit_rep_tc] :: DerivInstTys -> TyCon

-- | The representation types for <a>dit_tc_args</a> (for data family
--   instances). Otherwise the same as <a>dit_tc_args</a>.
[dit_rep_tc_args] :: DerivInstTys -> [Type]

-- | The cached results of instantiating each data constructor's field
--   types using <tt><a>dataConInstUnivs</a> data_con
--   <a>dit_rep_tc_args</a></tt>. See <tt>Note [Instantiating field types
--   in stock deriving]</tt>.
--   
--   This field is only used for stock-derived instances and goes unused
--   for newtype-derived instances. It is put here mainly for the sake of
--   convenience.
[dit_dc_inst_arg_env] :: DerivInstTys -> DataConEnv [Type]

-- | <tt><a>buildDataConInstArgEnv</a> tycon arg_tys</tt> constructs a
--   cache that maps each of <tt>tycon</tt>'s data constructors to their
--   field types, with are to be instantiated with <tt>arg_tys</tt>. See
--   <tt>Note [Instantiating field types in stock deriving]</tt>.
buildDataConInstArgEnv :: TyCon -> [Type] -> DataConEnv [Type]

-- | Look up a data constructor's instantiated field types in a
--   <a>DerivInstTys</a>. See <tt>Note [Instantiating field types in stock
--   deriving]</tt>.
derivDataConInstArgTys :: DataCon -> DerivInstTys -> [Type]

-- | Apply a substitution to all of the <a>Type</a>s contained in a
--   <a>DerivInstTys</a>. See <tt>Note [Instantiating field types in stock
--   deriving]</tt> for why we need to substitute into a
--   <a>DerivInstTys</a> in the first place.
substDerivInstTys :: Subst -> DerivInstTys -> DerivInstTys

-- | Zonk the <a>TcTyVar</a>s in a <a>DerivInstTys</a> value to
--   <a>TyVar</a>s. See <tt>Note [What is zonking?]</tt> in
--   <a>GHC.Tc.Utils.TcMType</a>.
--   
--   This is only used in the final zonking step when inferring the context
--   for a derived instance. See <tt>Note [Overlap and deriving]</tt> in
--   <a>GHC.Tc.Deriv.Infer</a>.
zonkDerivInstTys :: ZonkEnv -> DerivInstTys -> TcM DerivInstTys
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Generate.DerivInstTys


-- | The deriving code for the Functor, Foldable, and Traversable classes
module GHC.Tc.Deriv.Functor
data FFoldType a
FT :: a -> a -> a -> (a -> a -> a) -> (TyCon -> [a] -> a) -> (Type -> Type -> a -> a) -> a -> (TcTyVar -> a -> a) -> FFoldType a

-- | Does not contain variable
[ft_triv] :: FFoldType a -> a

-- | The variable itself
[ft_var] :: FFoldType a -> a

-- | The variable itself, contravariantly
[ft_co_var] :: FFoldType a -> a

-- | Function type
[ft_fun] :: FFoldType a -> a -> a -> a

-- | Tuple type. The <tt>[a]</tt> is the result of folding over the
--   arguments of the tuple.
[ft_tup] :: FFoldType a -> TyCon -> [a] -> a

-- | Type app, variable only in last argument. The two <a>Type</a>s are the
--   function and argument parts of <tt>fun_ty arg_ty</tt>, respectively.
[ft_ty_app] :: FFoldType a -> Type -> Type -> a -> a

-- | Type app, variable other than in last argument
[ft_bad_app] :: FFoldType a -> a

-- | Forall type
[ft_forall] :: FFoldType a -> TcTyVar -> a -> a
functorLikeTraverse :: forall a. TyVar -> FFoldType a -> Type -> a

-- | Return all syntactic subterms of a <a>Type</a> that are applied to the
--   <a>TyVar</a> argument. This determines what constraints should be
--   inferred for derived <a>Functor</a>, <a>Foldable</a>, and
--   <a>Traversable</a> instances in <a>GHC.Tc.Deriv.Infer</a>. For
--   instance, if we have:
--   
--   <pre>
--   data Foo a = MkFoo Int a (Maybe a) (Either Int (Maybe a))
--   </pre>
--   
--   Then the following would hold:
--   
--   <ul>
--   <li><tt><a>deepSubtypesContaining</a> a Int</tt> would return
--   <tt>[]</tt>, since <tt>Int</tt> does not contain the type variable
--   <tt>a</tt> at all.</li>
--   <li><tt><a>deepSubtypesContaining</a> a a</tt> would return
--   <tt>[]</tt>. Although the type <tt>a</tt> contains the type variable
--   <tt>a</tt>, it is not <i>applied</i> to <tt>a</tt>, which is the
--   criterion that <a>deepSubtypesContaining</a> checks for.</li>
--   <li><tt><a>deepSubtypesContaining</a> a (Maybe a)</tt> would return
--   <tt>[Maybe]</tt>, as <tt>Maybe</tt> is applied to <tt>a</tt>.</li>
--   <li><tt><a>deepSubtypesContaining</a> a (Either Int (Maybe a))</tt>
--   would return <tt>[Either Int, Maybe]</tt>. Both of these types are
--   applied to <tt>a</tt> through composition.</li>
--   </ul>
--   
--   As used in <a>GHC.Tc.Deriv.Infer</a>, the <a>Type</a> argument will
--   always come from <a>derivDataConInstArgTys</a>, so it is important
--   that the <a>TyVar</a> comes from <a>dataConUnivTyVars</a> to match.
--   Make sure <i>not</i> to take the <a>TyVar</a> from <a>tyConTyVars</a>,
--   as these differ from the <a>dataConUnivTyVars</a> when the data type
--   is a GADT. (See #22167 for what goes wrong if <a>tyConTyVars</a> is
--   used.)
deepSubtypesContaining :: TyVar -> Type -> [TcType]
foldDataConArgs :: FFoldType a -> DataCon -> DerivInstTys -> [a]
gen_Functor_binds :: SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Foldable_binds :: SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)
gen_Traversable_binds :: SrcSpan -> DerivInstTys -> (LHsBinds GhcPs, Bag AuxBindSpec)


-- | The deriving code for the Generic class
module GHC.Tc.Deriv.Generics
canDoGenerics :: DerivInstTys -> Validity' [DeriveGenericsErrReason]
canDoGenerics1 :: DerivInstTys -> Validity' [DeriveGenericsErrReason]
data GenericKind
Gen0 :: GenericKind
Gen1 :: GenericKind
gen_Generic_binds :: GenericKind -> SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, [LSig GhcPs])
gen_Generic_fam_inst :: GenericKind -> (Name -> Fixity) -> SrcSpan -> DerivInstTys -> TcM FamInst

-- | Called by <a>inferConstraints</a>; generates a list of types, each of
--   which must be a <a>Functor</a> in order for the <tt>Generic1</tt>
--   instance to work. For instance, if we have:
--   
--   <pre>
--   data Foo a = MkFoo Int a (Maybe a) (Either Int (Maybe a))
--   </pre>
--   
--   Then <tt><a>get_gen1_constrained_tys</a> a (f (g a))</tt> would return
--   <tt>[Either Int]</tt>, as a derived <tt>Generic1</tt> instance would
--   need to call <a>fmap</a> at that type. Invoking
--   <tt><a>get_gen1_constrained_tys</a> a</tt> on any of the other fields
--   would return <tt>[]</tt>.
--   
--   <a>get_gen1_constrained_tys</a> is very similar in spirit to
--   <a>deepSubtypesContaining</a> in <a>GHC.Tc.Deriv.Functor</a>. Just
--   like with <a>deepSubtypesContaining</a>, it is important that the
--   <a>TyVar</a> argument come from <a>dataConUnivTyVars</a>. (See #22167
--   for what goes wrong if <a>tyConTyVars</a> is used.)
get_gen1_constrained_tys :: TyVar -> Type -> [Type]


-- | Error-checking and other utilities for <tt>deriving</tt> clauses or
--   declarations.
module GHC.Tc.Deriv.Utils

-- | To avoid having to manually plumb everything in <a>DerivEnv</a>
--   throughout various functions in <a>GHC.Tc.Deriv</a> and
--   <a>GHC.Tc.Deriv.Infer</a>, we use <a>DerivM</a>, which is a simple
--   reader around <a>TcRn</a>.
type DerivM = ReaderT DerivEnv TcRn

-- | Contains all of the information known about a derived instance when
--   determining what its <tt>EarlyDerivSpec</tt> should be. See <tt>Note
--   [DerivEnv and DerivSpecMechanism]</tt>.
data DerivEnv
DerivEnv :: Maybe OverlapMode -> [TyVar] -> Class -> [Type] -> DerivContext -> SkolemInfo -> Maybe (DerivStrategy GhcTc) -> DerivEnv

-- | Is this an overlapping instance?
[denv_overlap_mode] :: DerivEnv -> Maybe OverlapMode

-- | Universally quantified type variables in the instance. If the
--   <tt>denv_ctxt</tt> is <a>InferContext</a>, these will be
--   <a>TcTyVar</a> skolems. If the <tt>denv_ctxt</tt> is
--   <a>SupplyContext</a>, these will be ordinary <a>TyVar</a>s. See
--   <tt>Note [Overlap and deriving]</tt> in <a>GHC.Tc.Deriv.Infer</a>.
--   
--   All type variables that appear in the <a>denv_inst_tys</a>,
--   <a>denv_ctxt</a>, <a>denv_skol_info</a>, and <a>denv_strat</a> should
--   come from <a>denv_tvs</a>.
[denv_tvs] :: DerivEnv -> [TyVar]

-- | Class for which we need to derive an instance
[denv_cls] :: DerivEnv -> Class

-- | All arguments to <a>denv_cls</a> in the derived instance.
[denv_inst_tys] :: DerivEnv -> [Type]

-- | <tt><a>SupplyContext</a> theta</tt> for standalone deriving (where
--   <tt>theta</tt> is the context of the instance). <a>InferContext</a>
--   for <tt>deriving</tt> clauses, or for standalone deriving that uses a
--   wildcard constraint. See <tt>Note [Inferring the instance
--   context]</tt>.
[denv_ctxt] :: DerivEnv -> DerivContext

-- | The <a>SkolemInfo</a> used to skolemise the <tt>denv_tvs</tt> in the
--   case where the <a>denv_ctxt</a> is <a>InferContext</a>.
[denv_skol_info] :: DerivEnv -> SkolemInfo

-- | <a>Just</a> if user requests a particular deriving strategy.
--   Otherwise, <a>Nothing</a>.
[denv_strat] :: DerivEnv -> Maybe (DerivStrategy GhcTc)
data DerivSpec theta
DS :: SrcSpan -> Name -> [TyVar] -> theta -> Class -> [Type] -> SkolemInfo -> UserTypeCtxt -> Maybe OverlapMode -> Maybe SrcSpan -> DerivSpecMechanism -> DerivSpec theta
[ds_loc] :: DerivSpec theta -> SrcSpan
[ds_name] :: DerivSpec theta -> Name
[ds_tvs] :: DerivSpec theta -> [TyVar]
[ds_theta] :: DerivSpec theta -> theta
[ds_cls] :: DerivSpec theta -> Class
[ds_tys] :: DerivSpec theta -> [Type]
[ds_skol_info] :: DerivSpec theta -> SkolemInfo
[ds_user_ctxt] :: DerivSpec theta -> UserTypeCtxt
[ds_overlap] :: DerivSpec theta -> Maybe OverlapMode
[ds_standalone_wildcard] :: DerivSpec theta -> Maybe SrcSpan
[ds_mechanism] :: DerivSpec theta -> DerivSpecMechanism
pprDerivSpec :: Outputable theta => DerivSpec theta -> SDoc

-- | Set the <a>ds_theta</a> in a <a>DerivSpec</a>.
setDerivSpecTheta :: theta' -> DerivSpec theta -> DerivSpec theta'

-- | Zonk the <a>TcTyVar</a>s in a <a>DerivSpec</a> to <a>TyVar</a>s. See
--   <tt>Note [What is zonking?]</tt> in <a>GHC.Tc.Utils.TcMType</a>.
--   
--   This is only used in the final zonking step when inferring the context
--   for a derived instance. See <tt>Note [Overlap and deriving]</tt> in
--   <a>GHC.Tc.Deriv.Infer</a>.
zonkDerivSpec :: DerivSpec ThetaType -> TcM (DerivSpec ThetaType)

-- | What action to take in order to derive a class instance. See <tt>Note
--   [DerivEnv and DerivSpecMechanism]</tt>, as well as <tt>Note [Deriving
--   strategies]</tt> in <a>GHC.Tc.Deriv</a>.
data DerivSpecMechanism

-- | "Standard" classes
DerivSpecStock :: DerivInstTys -> StockGenFns -> DerivSpecMechanism

-- | Information about the arguments to the class in the derived instance,
--   including what type constructor the last argument is headed by. See
--   <tt>Note [DerivEnv and DerivSpecMechanism]</tt>.
[dsm_stock_dit] :: DerivSpecMechanism -> DerivInstTys

-- | How to generate the instance bindings and associated type family
--   instances.
[dsm_stock_gen_fns] :: DerivSpecMechanism -> StockGenFns

-- | <pre>
--   GeneralizedNewtypeDeriving
--   </pre>
DerivSpecNewtype :: DerivInstTys -> Type -> DerivSpecMechanism

-- | Information about the arguments to the class in the derived instance,
--   including what type constructor the last argument is headed by. See
--   <tt>Note [DerivEnv and DerivSpecMechanism]</tt>.
[dsm_newtype_dit] :: DerivSpecMechanism -> DerivInstTys

-- | The newtype rep type.
[dsm_newtype_rep_ty] :: DerivSpecMechanism -> Type

-- | <pre>
--   DeriveAnyClass
--   </pre>
DerivSpecAnyClass :: DerivSpecMechanism

-- | <pre>
--   DerivingVia
--   </pre>
DerivSpecVia :: [Type] -> Type -> Type -> DerivSpecMechanism

-- | All arguments to the class besides the last one.
[dsm_via_cls_tys] :: DerivSpecMechanism -> [Type]

-- | The last argument to the class.
[dsm_via_inst_ty] :: DerivSpecMechanism -> Type

-- | The <tt>via</tt> type
[dsm_via_ty] :: DerivSpecMechanism -> Type

-- | Convert a <a>DerivSpecMechanism</a> to its corresponding
--   <a>DerivStrategy</a>.
derivSpecMechanismToStrategy :: DerivSpecMechanism -> DerivStrategy GhcTc
isDerivSpecStock :: DerivSpecMechanism -> Bool
isDerivSpecNewtype :: DerivSpecMechanism -> Bool
isDerivSpecAnyClass :: DerivSpecMechanism -> Bool
isDerivSpecVia :: DerivSpecMechanism -> Bool

-- | Zonk the <a>TcTyVar</a>s in a <a>DerivSpecMechanism</a> to
--   <a>TyVar</a>s. See <tt>Note [What is zonking?]</tt> in
--   <a>GHC.Tc.Utils.TcMType</a>.
--   
--   This is only used in the final zonking step when inferring the context
--   for a derived instance. See <tt>Note [Overlap and deriving]</tt> in
--   <a>GHC.Tc.Deriv.Infer</a>.
zonkDerivSpecMechanism :: ZonkEnv -> DerivSpecMechanism -> TcM DerivSpecMechanism

-- | Whether GHC is processing a <tt>deriving</tt> clause or a standalone
--   deriving declaration.
data DerivContext

-- | <tt>'InferContext mb_wildcard</tt> is either:
--   
--   <ul>
--   <li>A <tt>deriving</tt> clause (in which case <tt>mb_wildcard</tt> is
--   <a>Nothing</a>).</li>
--   <li>A standalone deriving declaration with an extra-constraints
--   wildcard as the context (in which case <tt>mb_wildcard</tt> is
--   <tt><a>Just</a> loc</tt>, where <tt>loc</tt> is the location of the
--   wildcard.</li>
--   </ul>
--   
--   GHC should infer the context.
InferContext :: Maybe SrcSpan -> DerivContext

-- | <tt><a>SupplyContext</a> theta</tt> is a standalone deriving
--   declaration, where <tt>theta</tt> is the context supplied by the user.
SupplyContext :: ThetaType -> DerivContext

-- | Records whether a particular class can be derived by way of an
--   <i>originative</i> deriving strategy (i.e., <tt>stock</tt> or
--   <tt>anyclass</tt>).
--   
--   See <tt>Note [Deriving strategies]</tt> in <a>GHC.Tc.Deriv</a>.
data OriginativeDerivStatus
CanDeriveStock :: StockGenFns -> OriginativeDerivStatus
StockClassError :: !DeriveInstanceErrReason -> OriginativeDerivStatus
CanDeriveAnyClass :: OriginativeDerivStatus
NonDerivableClass :: OriginativeDerivStatus

-- | Describes how to generate instance bindings (<a>stock_gen_binds</a>)
--   and associated type family instances (<a>stock_gen_fam_insts</a>) for
--   a particular stock-derived instance.
data StockGenFns
StockGenFns :: (SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, [LSig GhcPs], Bag AuxBindSpec, [Name])) -> (SrcSpan -> DerivInstTys -> TcM [FamInst]) -> StockGenFns

-- | Describes how to generate instance bindings for a stock-derived
--   instance.
--   
--   This function takes two arguments:
--   
--   <ol>
--   <li><a>SrcSpan</a>: the source location where the instance is being
--   derived. This will eventually be instantiated with the <a>ds_loc</a>
--   field of a <a>DerivSpec</a>.</li>
--   <li><a>DerivInstTys</a>: information about the argument types to which
--   a class is applied in a derived instance. This will eventually be
--   instantiated with the <a>dsm_stock_dit</a> field of a
--   <a>DerivSpecMechanism</a>.</li>
--   </ol>
--   
--   This function returns four things:
--   
--   <ol>
--   <li><tt><a>LHsBinds</a> <a>GhcPass</a></tt>: The derived instance's
--   function bindings (e.g., <tt>compare (T x) (T y) = compare x
--   y</tt>)</li>
--   <li><tt>[<a>LSig</a> <a>GhcPass</a>]</tt>: A list of instance specific
--   signatures/pragmas. Most likely <tt>INLINE</tt> pragmas for class
--   methods.</li>
--   <li><tt><a>Bag</a> <a>AuxBindSpec</a></tt>: Auxiliary bindings needed
--   to support the derived instance. As examples, derived <a>Eq</a> and
--   <a>Ord</a> instances sometimes require top-level <tt>con2tag</tt>
--   functions. See <tt>Note [Auxiliary binders]</tt> in
--   <a>GHC.Tc.Deriv.Generate</a>.</li>
--   <li><tt>[<a>Name</a>]</tt>: A list of Names for which
--   <tt>-Wunused-binds</tt> should be suppressed. This is used to suppress
--   unused warnings for record selectors when deriving <a>Read</a>,
--   <a>Show</a>, or <tt>Generic</tt>. See <tt>Note [Deriving and unused
--   record selectors]</tt>.</li>
--   </ol>
[stock_gen_binds] :: StockGenFns -> SrcSpan -> DerivInstTys -> TcM (LHsBinds GhcPs, [LSig GhcPs], Bag AuxBindSpec, [Name])

-- | Describes how to generate associated type family instances for a
--   stock-derived instance. This function takes the same arguments as the
--   <a>stock_gen_binds</a> function but returns a list of <a>FamInst</a>s
--   instead. Generating type family instances is done separately from
--   <a>stock_gen_binds</a> since the type family instances must be
--   generated before the instance bindings can be typechecked. See
--   <tt>Note [Staging of tcDeriving]</tt> in <a>GHC.Tc.Deriv</a>.
[stock_gen_fam_insts] :: StockGenFns -> SrcSpan -> DerivInstTys -> TcM [FamInst]

-- | Is GHC processing a standalone deriving declaration?
isStandaloneDeriv :: DerivM Bool

-- | Is GHC processing a standalone deriving declaration with an
--   extra-constraints wildcard as the context? (e.g., <tt>deriving
--   instance _ =&gt; Eq (Foo a)</tt>)
isStandaloneWildcardDeriv :: DerivM Bool

-- | Return <a>InstDeclCtxt</a> if processing with a standalone
--   <tt>deriving</tt> declaration or <a>DerivClauseCtxt</a> if processing
--   a <tt>deriving</tt> clause.
askDerivUserTypeCtxt :: DerivM UserTypeCtxt

-- | <tt><a>mkDerivOrigin</a> wc</tt> returns <a>StandAloneDerivOrigin</a>
--   if <tt>wc</tt> is <a>True</a>, and <a>DerivClauseOrigin</a> if
--   <tt>wc</tt> is <a>False</a>. Useful for error-reporting.
mkDerivOrigin :: Bool -> CtOrigin

-- | A <a>PredSpec</a> specifies a constraint to emitted when inferring the
--   instance context for a derived instance in <a>simplifyInfer</a>.
data PredSpec

-- | An ordinary <a>PredSpec</a> that directly stores a <a>PredType</a>,
--   which will be emitted as a wanted constraint in the constraint solving
--   machinery. This is the simple case, as there are no skolems,
--   metavariables, or given constraints involved.
SimplePredSpec :: TcPredType -> CtOrigin -> TypeOrKind -> PredSpec

-- | The constraint to emit as a wanted
[sps_pred] :: PredSpec -> TcPredType

-- | The origin of the constraint
[sps_origin] :: PredSpec -> CtOrigin

-- | Whether the constraint is a type or kind
[sps_type_or_kind] :: PredSpec -> TypeOrKind

-- | A special <a>PredSpec</a> that is only used by
--   <tt>DeriveAnyClass</tt>. This will check if <tt>stps_ty_actual</tt> is
--   a subtype of (i.e., more polymorphic than) <tt>stps_ty_expected</tt>
--   in the constraint solving machinery, emitting an implication
--   constraint as a side effect. For more details on how this works, see
--   <tt>Note [Gathering and simplifying constraints for
--   DeriveAnyClass]</tt> in <a>GHC.Tc.Deriv.Infer</a>.
SubTypePredSpec :: TcSigmaType -> TcSigmaType -> CtOrigin -> PredSpec

-- | The actual type. In the context of <tt>DeriveAnyClass</tt>, this is
--   the default method type signature.
[stps_ty_actual] :: PredSpec -> TcSigmaType

-- | The expected type. In the context of <tt>DeriveAnyClass</tt>, this is
--   the original method type signature.
[stps_ty_expected] :: PredSpec -> TcSigmaType

-- | The origin of the constraint
[stps_origin] :: PredSpec -> CtOrigin

-- | A list of <a>PredSpec</a> constraints to simplify when inferring a
--   derived instance's context. For the <tt>stock</tt>, <tt>newtype</tt>,
--   and <tt>via</tt> deriving strategies, these will consist of
--   <a>SimplePredSpec</a>s, and for <tt>DeriveAnyClass</tt>, these will
--   consist of <a>SubTypePredSpec</a>s. Here is an example to illustrate
--   the latter:
--   
--   <pre>
--   class Foo a where
--     bar :: forall b. Ix b =&gt; a -&gt; b -&gt; String
--     default bar :: forall y. (Show a, Ix y) =&gt; a -&gt; y -&gt; String
--     bar x y = show x ++ show (range (y, y))
--   
--     baz :: Eq a =&gt; a -&gt; a -&gt; Bool
--     default baz :: Ord a =&gt; a -&gt; a -&gt; Bool
--     baz x y = compare x y == EQ
--   
--   data Quux q = Quux deriving anyclass Foo
--   </pre>
--   
--   Then it would generate two <a>SubTypePredSpec</a>s, one for each
--   method:
--   
--   <pre>
--   [ SubTypePredSpec
--       { stps_ty_actual   = forall y. (Show (Quux q), Ix y) =&gt; Quux q -&gt; y -&gt; String
--       , stps_ty_expected = forall b.                (Ix b) =&gt; Quux q -&gt; b -&gt; String
--       , stps_ty_origin   = DerivClauseCtxt
--       }
--   , SubTypePredSpec
--       { stps_ty_actual   = Ord (Quux q) =&gt; Quux q -&gt; Quux q -&gt; Bool
--       , stps_ty_expected = Eq  (Quux q) =&gt; Quux q -&gt; Quux q -&gt; Bool
--       , stps_ty_origin   = DerivClauseCtxt
--       }
--   ]
--   </pre>
--   
--   (Note that the type variable <tt>q</tt> is bound by the data type
--   <tt>Quux</tt>, and thus appears free in the <a>stps_ty_actual</a>s and
--   <a>stps_ty_expected</a>s.)
--   
--   See <tt>Note [Gathering and simplifying constraints for
--   DeriveAnyClass]</tt> in <a>GHC.Tc.Deriv.Infer</a> for an explanation
--   of how these <a>SubTypePredSpec</a>s are used to compute implication
--   constraints.
type ThetaSpec = [PredSpec]

-- | Build a list of <a>SimplePredSpec</a>s, using the supplied
--   <a>CtOrigin</a> and <a>TypeOrKind</a> values for each <a>PredType</a>.
mkDirectThetaSpec :: CtOrigin -> TypeOrKind -> ThetaType -> ThetaSpec
substPredSpec :: HasCallStack => Subst -> PredSpec -> PredSpec

-- | Capture wanted constraints from a <a>ThetaSpec</a>.
captureThetaSpecConstraints :: UserTypeCtxt -> ThetaSpec -> TcM (TcLevel, WantedConstraints)
checkOriginativeSideConditions :: DerivInstTys -> DerivM OriginativeDerivStatus
hasStockDeriving :: Class -> Maybe StockGenFns
std_class_via_coercible :: Class -> Bool
non_coercible_class :: Class -> Bool
newDerivClsInst :: DerivSpec ThetaType -> TcM ClsInst
extendLocalInstEnv :: [ClsInst] -> TcM a -> TcM a
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.PredSpec
instance GHC.Utils.Outputable.Outputable theta => GHC.Utils.Outputable.Outputable (GHC.Tc.Deriv.Utils.DerivSpec theta)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.DerivSpecMechanism
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.DerivEnv
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.Utils.DerivContext


-- | Functions for inferring (and simplifying) the context for derived
--   instances.
module GHC.Tc.Deriv.Infer
inferConstraints :: DerivSpecMechanism -> DerivM (ThetaSpec, [TyVar], [TcType], DerivSpecMechanism)
simplifyInstanceContexts :: [DerivSpec ThetaSpec] -> TcM [DerivSpec ThetaType]

module GHC.Tc.Gen.Head
data HsExprArg (p :: TcPass)
EValArg :: AppCtxt -> EValArg p -> !XEVAType p -> HsExprArg (p :: TcPass)
[eva_ctxt] :: HsExprArg (p :: TcPass) -> AppCtxt
[eva_arg] :: HsExprArg (p :: TcPass) -> EValArg p
[eva_arg_ty] :: HsExprArg (p :: TcPass) -> !XEVAType p
ETypeArg :: AppCtxt -> !LHsToken "@" GhcRn -> LHsWcType GhcRn -> !XETAType p -> HsExprArg (p :: TcPass)
[eva_ctxt] :: HsExprArg (p :: TcPass) -> AppCtxt
[eva_at] :: HsExprArg (p :: TcPass) -> !LHsToken "@" GhcRn
[eva_hs_ty] :: HsExprArg (p :: TcPass) -> LHsWcType GhcRn
[eva_ty] :: HsExprArg (p :: TcPass) -> !XETAType p
EPrag :: AppCtxt -> HsPragE (GhcPass (XPass p)) -> HsExprArg (p :: TcPass)
EWrap :: EWrap -> HsExprArg (p :: TcPass)
data EValArg (p :: TcPass)
[ValArg] :: LHsExpr (GhcPass (XPass p)) -> EValArg p
[ValArgQL] :: LHsExpr GhcRn -> (HsExpr GhcTc, AppCtxt) -> [HsExprArg 'TcpInst] -> TcRhoType -> EValArg 'TcpInst
data TcPass
TcpRn :: TcPass
TcpInst :: TcPass
TcpTc :: TcPass
data AppCtxt
VAExpansion :: HsExpr GhcRn -> SrcSpan -> AppCtxt
VACall :: HsExpr GhcRn -> Int -> SrcSpan -> AppCtxt
appCtxtLoc :: AppCtxt -> SrcSpan
insideExpansion :: AppCtxt -> Bool
splitHsApps :: HsExpr GhcRn -> ((HsExpr GhcRn, AppCtxt), [HsExprArg 'TcpRn])

-- | Rebuild an application: takes a type-checked application head
--   expression together with arguments in the form of typechecked
--   <a>HsExprArg</a>s and returns a typechecked application of the head to
--   the arguments.
--   
--   This performs a representation-polymorphism check to ensure that the
--   remaining value arguments in an application have a fixed RuntimeRep.
--   
--   See Note [Checking for representation-polymorphic built-ins].
rebuildHsApps :: HsExpr GhcTc -> AppCtxt -> [HsExprArg 'TcpTc] -> TcRhoType -> TcM (HsExpr GhcTc)
addArgWrap :: HsWrapper -> [HsExprArg 'TcpInst] -> [HsExprArg 'TcpInst]
isHsValArg :: HsExprArg id -> Bool
countLeadingValArgs :: [HsExprArg id] -> Int
isVisibleArg :: HsExprArg id -> Bool
pprHsExprArgTc :: HsExprArg 'TcpInst -> SDoc

-- | Count visible and invisible value arguments in a list of
--   <a>HsExprArg</a> arguments.
countVisAndInvisValArgs :: [HsExprArg id] -> Arity

-- | Counts the number of invisible term-level arguments applied by an
--   <a>HsWrapper</a>. Precondition: this wrapper contains no abstractions.
countHsWrapperInvisArgs :: HsWrapper -> Arity
tcInferAppHead :: (HsExpr GhcRn, AppCtxt) -> [HsExprArg 'TcpRn] -> TcM (HsExpr GhcTc, TcSigmaType)
tcInferAppHead_maybe :: HsExpr GhcRn -> [HsExprArg 'TcpRn] -> TcM (Maybe (HsExpr GhcTc, TcSigmaType))
tcInferId :: Name -> TcM (HsExpr GhcTc, TcSigmaType)
tcCheckId :: Name -> ExpRhoType -> TcM (HsExpr GhcTc)
obviousSig :: HsExpr GhcRn -> Maybe (LHsSigWcType GhcRn)
tyConOf :: FamInstEnvs -> TcSigmaType -> Maybe TyCon
tyConOfET :: FamInstEnvs -> ExpRhoType -> Maybe TyCon
lookupParents :: Bool -> RdrName -> RnM [(RecSelParent, GlobalRdrElt)]
fieldNotInType :: RecSelParent -> RdrName -> TcRnMessage
notSelector :: Name -> TcRnMessage
nonBidirectionalErr :: Name -> TcRnMessage
addHeadCtxt :: AppCtxt -> TcM a -> TcM a
addExprCtxt :: HsExpr GhcRn -> TcRn a -> TcRn a
addFunResCtxt :: HsExpr GhcRn -> [HsExprArg 'TcpRn] -> TcType -> ExpRhoType -> TcM a -> TcM a
instance GHC.Hs.Extension.OutputableBndrId (GHC.Tc.Gen.Head.XPass p) => GHC.Utils.Outputable.Outputable (GHC.Tc.Gen.Head.HsExprArg p)
instance GHC.Hs.Extension.OutputableBndrId (GHC.Tc.Gen.Head.XPass p) => GHC.Utils.Outputable.Outputable (GHC.Tc.Gen.Head.EValArg p)
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Head.EWrap
instance GHC.Utils.Outputable.Outputable GHC.Tc.Gen.Head.AppCtxt


-- | Typecheck some <tt>Matches</tt>
module GHC.Tc.Gen.Match
tcMatchesFun :: LocatedN Name -> MatchGroup GhcRn (LHsExpr GhcRn) -> ExpRhoType -> TcM (HsWrapper, MatchGroup GhcTc (LHsExpr GhcTc))
tcGRHS :: TcMatchCtxt body -> ExpRhoType -> GRHS GhcRn (LocatedA (body GhcRn)) -> TcM (GRHS GhcTc (LocatedA (body GhcTc)))
tcGRHSsPat :: GRHSs GhcRn (LHsExpr GhcRn) -> ExpRhoType -> TcM (GRHSs GhcTc (LHsExpr GhcTc))
tcMatchesCase :: AnnoBody body => TcMatchCtxt body -> Scaled TcSigmaTypeFRR -> MatchGroup GhcRn (LocatedA (body GhcRn)) -> ExpRhoType -> TcM (MatchGroup GhcTc (LocatedA (body GhcTc)))
tcMatchLambda :: ExpectedFunTyOrigin -> TcMatchCtxt HsExpr -> MatchGroup GhcRn (LHsExpr GhcRn) -> ExpRhoType -> TcM (HsWrapper, MatchGroup GhcTc (LHsExpr GhcTc))
data TcMatchCtxt body
MC :: HsMatchContext GhcTc -> (LocatedA (body GhcRn) -> ExpRhoType -> TcM (LocatedA (body GhcTc))) -> TcMatchCtxt body
[mc_what] :: TcMatchCtxt body -> HsMatchContext GhcTc
[mc_body] :: TcMatchCtxt body -> LocatedA (body GhcRn) -> ExpRhoType -> TcM (LocatedA (body GhcTc))
type TcStmtChecker body rho_type = forall thing. HsStmtContext GhcTc -> Stmt GhcRn (LocatedA (body GhcRn)) -> rho_type -> (rho_type -> TcM thing) -> TcM (Stmt GhcTc (LocatedA (body GhcTc)), thing)
type TcExprStmtChecker = TcStmtChecker HsExpr ExpRhoType
type TcCmdStmtChecker = TcStmtChecker HsCmd TcRhoType
tcStmts :: AnnoBody body => HsStmtContext GhcTc -> TcStmtChecker body rho_type -> [LStmt GhcRn (LocatedA (body GhcRn))] -> rho_type -> TcM [LStmt GhcTc (LocatedA (body GhcTc))]
tcStmtsAndThen :: AnnoBody body => HsStmtContext GhcTc -> TcStmtChecker body rho_type -> [LStmt GhcRn (LocatedA (body GhcRn))] -> rho_type -> (rho_type -> TcM thing) -> TcM ([LStmt GhcTc (LocatedA (body GhcTc))], thing)
tcDoStmts :: HsDoFlavour -> LocatedL [LStmt GhcRn (LHsExpr GhcRn)] -> ExpRhoType -> TcM (HsExpr GhcTc)
tcBody :: LHsExpr GhcRn -> ExpRhoType -> TcM (LHsExpr GhcTc)
tcDoStmt :: TcExprStmtChecker
tcGuardStmt :: TcExprStmtChecker

-- | <tt>checkArgCounts</tt> takes a <tt>[RenamedMatch]</tt> and decides
--   whether the same number of args are used in each equation.
checkArgCounts :: AnnoBody body => HsMatchContext GhcTc -> MatchGroup GhcRn (LocatedA (body GhcRn)) -> TcM ()


-- | Typecheck arrow notation
module GHC.Tc.Gen.Arrow
tcProc :: LPat GhcRn -> LHsCmdTop GhcRn -> ExpRhoType -> TcM (LPat GhcTc, LHsCmdTop GhcTc, TcCoercion)

module GHC.Tc.Gen.App
tcApp :: HsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)
tcInferSigma :: Bool -> LHsExpr GhcRn -> TcM TcSigmaType
tcExprPrag :: HsPragE GhcRn -> HsPragE GhcTc

module GHC.Tc.Gen.Expr
tcCheckPolyExpr :: LHsExpr GhcRn -> TcSigmaType -> TcM (LHsExpr GhcTc)
tcCheckPolyExprNC :: LHsExpr GhcRn -> TcSigmaType -> TcM (LHsExpr GhcTc)
tcCheckMonoExpr :: LHsExpr GhcRn -> TcRhoType -> TcM (LHsExpr GhcTc)
tcCheckMonoExprNC :: LHsExpr GhcRn -> TcRhoType -> TcM (LHsExpr GhcTc)
tcMonoExpr :: LHsExpr GhcRn -> ExpRhoType -> TcM (LHsExpr GhcTc)
tcMonoExprNC :: LHsExpr GhcRn -> ExpRhoType -> TcM (LHsExpr GhcTc)
tcInferRho :: LHsExpr GhcRn -> TcM (LHsExpr GhcTc, TcRhoType)
tcInferRhoNC :: LHsExpr GhcRn -> TcM (LHsExpr GhcTc, TcRhoType)
tcPolyExpr :: HsExpr GhcRn -> ExpSigmaType -> TcM (HsExpr GhcTc)
tcExpr :: HsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)

-- | Typecheck a syntax operator The operator is a variable or a lambda at
--   this stage (i.e. renamer output)t
tcSyntaxOp :: CtOrigin -> SyntaxExprRn -> [SyntaxOpType] -> ExpRhoType -> ([TcSigmaType] -> [Mult] -> TcM a) -> TcM (a, SyntaxExprTc)

-- | Slightly more general version of <a>tcSyntaxOp</a> that allows the
--   caller to specify the shape of the result of the syntax operator
tcSyntaxOpGen :: CtOrigin -> SyntaxExprRn -> [SyntaxOpType] -> SyntaxOpType -> ([TcSigmaTypeFRR] -> [Mult] -> TcM a) -> TcM (a, SyntaxExprTc)

-- | What to expect for an argument to a rebindable-syntax operator. Quite
--   like <a>Type</a>, but allows for holes to be filled in by tcSyntaxOp.
--   The callback called from tcSyntaxOp gets a list of types; the meaning
--   of these types is determined by a left-to-right depth-first traversal
--   of the <a>SyntaxOpType</a> tree. So if you pass in
--   
--   <pre>
--   SynAny `SynFun` (SynList `SynFun` SynType Int) `SynFun` SynAny
--   </pre>
--   
--   you'll get three types back: one for the first <a>SynAny</a>, the
--   <i>element</i> type of the list, and one for the last <a>SynAny</a>.
--   You don't get anything for the <a>SynType</a>, because you've said
--   positively that it should be an Int, and so it shall be.
--   
--   You'll also get three multiplicities back: one for each function
--   arrow. See also Note [Linear types] in Multiplicity.
--   
--   This is defined here to avoid defining it in <a>GHC.Tc.Gen.Expr</a>
--   boot file.
data SyntaxOpType

-- | Any type
SynAny :: SyntaxOpType

-- | A rho type, skolemised or instantiated as appropriate
SynRho :: SyntaxOpType

-- | A list type. You get back the element type of the list
SynList :: SyntaxOpType

-- | A function.
SynFun :: SyntaxOpType -> SyntaxOpType -> SyntaxOpType

-- | A known type.
SynType :: ExpType -> SyntaxOpType
infixr 0 `SynFun`

-- | Like <a>SynType</a> but accepts a regular TcType
synKnownType :: TcType -> SyntaxOpType
tcCheckId :: Name -> ExpRhoType -> TcM (HsExpr GhcTc)


-- | Typechecking rewrite rules
module GHC.Tc.Gen.Rule
tcRules :: [LRuleDecls GhcRn] -> TcM [LRuleDecls GhcTc]


-- | Typechecking <tt>foreign</tt> declarations
--   
--   A foreign declaration is used to either give an externally implemented
--   function a Haskell type (and calling interface) or give a Haskell
--   function an external calling interface. Either way, the range of
--   argument and result types these functions can accommodate is
--   restricted to what the outside world understands (read C), and this
--   module checks to see if a foreign declaration has got a legal type.
module GHC.Tc.Gen.Foreign
tcForeignImports :: [LForeignDecl GhcRn] -> TcM ([Id], [LForeignDecl GhcTc], Bag GlobalRdrElt)
tcForeignExports :: [LForeignDecl GhcRn] -> TcM (LHsBinds GhcTc, [LForeignDecl GhcTc], Bag GlobalRdrElt)
isForeignImport :: forall name. UnXRec name => LForeignDecl name -> Bool
isForeignExport :: forall name. UnXRec name => LForeignDecl name -> Bool
tcFImport :: LForeignDecl GhcRn -> TcM (Id, LForeignDecl GhcTc, Bag GlobalRdrElt)
tcFExport :: ForeignDecl GhcRn -> TcM (LHsBind GhcTc, ForeignDecl GhcTc, Bag GlobalRdrElt)
tcForeignImports' :: [LForeignDecl GhcRn] -> TcM ([Id], [LForeignDecl GhcTc], Bag GlobalRdrElt)
tcCheckFIType :: [Scaled Type] -> Type -> ForeignImport GhcRn -> TcM (ForeignImport GhcTc)
checkCTarget :: ForeignImport GhcRn -> CCallTarget -> TcM ()
checkForeignArgs :: (Type -> Validity' IllegalForeignTypeReason) -> [Scaled Type] -> TcM ()

-- | Check that the type has the form (IO t) or (t) , and that t satisfies
--   the given predicate. When calling this function, any newtype wrappers
--   (should) have been already dealt with by normaliseFfiType.
--   
--   We also check that the Safe Haskell condition of FFI imports having
--   results in the IO monad holds.
checkForeignRes :: Bool -> Bool -> (Type -> Validity' IllegalForeignTypeReason) -> Type -> TcM ()
normaliseFfiType :: Type -> TcM (Reduction, Bag GlobalRdrElt)
nonIOok :: Bool
mustBeIO :: Bool
checkSafe :: Bool
noCheckSafe :: Bool
tcForeignExports' :: [LForeignDecl GhcRn] -> TcM (LHsBinds GhcTc, [LForeignDecl GhcTc], Bag GlobalRdrElt)
tcCheckFEType :: Type -> ForeignExport GhcRn -> TcM (ForeignExport GhcTc)


-- | Handles <tt>deriving</tt> clauses on <tt>data</tt> declarations.
module GHC.Tc.Deriv
tcDeriving :: [DerivInfo] -> [LDerivDecl GhcRn] -> TcM (TcGblEnv, Bag (InstInfo GhcRn), HsValBinds GhcRn)

-- | Stuff needed to process a datatype's `deriving` clauses
data DerivInfo
DerivInfo :: TyCon -> ![(Name, TyVar)] -> [LHsDerivingClause GhcRn] -> SDoc -> DerivInfo

-- | The data tycon for normal datatypes, or the *representation* tycon for
--   data families
[di_rep_tc] :: DerivInfo -> TyCon

-- | Variables that scope over the deriving clause. See <tt>Note [Scoped
--   tyvars in a TcTyCon]</tt> in <a>GHC.Core.TyCon</a>.
[di_scoped_tvs] :: DerivInfo -> ![(Name, TyVar)]
[di_clauses] :: DerivInfo -> [LHsDerivingClause GhcRn]

-- | error context
[di_ctxt] :: DerivInfo -> SDoc
instance GHC.Utils.Outputable.Outputable GHC.Tc.Deriv.EarlyDerivSpec


-- | Typecheck type and class declarations
module GHC.Tc.TyCl
tcTyAndClassDecls :: [TyClGroup GhcRn] -> TcM (TcGblEnv, [InstInfo GhcRn], [DerivInfo], ThBindEnv)
kcConDecls :: Foldable f => NewOrData -> TcKind -> f (LConDecl GhcRn) -> TcM ()
tcConDecls :: DataDeclInfo -> KnotTied TyCon -> [TcTyConBinder] -> TcKind -> DataDefnCons (LConDecl GhcRn) -> TcM (DataDefnCons DataCon)
data DataDeclInfo
DDataType :: DataDeclInfo
DDataInstance :: Type -> DataDeclInfo
dataDeclChecks :: Name -> Maybe (LHsContext GhcRn) -> DataDefnCons (LConDecl GhcRn) -> TcM Bool
checkValidTyCon :: TyCon -> TcM ()
tcFamTyPats :: TyCon -> HsTyPats GhcRn -> TcM (TcType, TcKind)
tcTyFamInstEqn :: TcTyCon -> AssocInstInfo -> LTyFamInstEqn GhcRn -> TcM (KnotTied CoAxBranch)
tcAddTyFamInstCtxt :: TyFamInstDecl GhcRn -> TcM a -> TcM a
tcMkDataFamInstCtxt :: DataFamInstDecl GhcRn -> SDoc
tcAddDataFamInstCtxt :: DataFamInstDecl GhcRn -> TcM a -> TcM a
unravelFamInstPats :: TcType -> [TcType]
addConsistencyConstraints :: AssocInstInfo -> TcType -> TcM ()
wrongKindOfFamily :: TyCon -> TcRnMessage
checkFamTelescope :: TcLevel -> HsOuterFamEqnTyVarBndrs GhcRn -> [TcTyVar] -> TcM ()


-- | Typechecking instance declarations
module GHC.Tc.TyCl.Instance
tcInstDecls1 :: [LInstDecl GhcRn] -> TcM (TcGblEnv, [InstInfo GhcRn], [DerivInfo], ThBindEnv)

-- | Use DerivInfo for data family instances (produced by tcInstDecls1),
--   datatype declarations (TyClDecl), and standalone deriving declarations
--   (DerivDecl) to check and process all derived class instances.
tcInstDeclsDeriv :: [DerivInfo] -> [LDerivDecl GhcRn] -> TcM (TcGblEnv, [InstInfo GhcRn], HsValBinds GhcRn)
tcInstDecls2 :: [LTyClDecl GhcRn] -> [InstInfo GhcRn] -> TcM (LHsBinds GhcTc)

module GHC.HsToCore.Monad

-- | Desugaring monad. See also <tt>TcM</tt>.
type DsM = TcRnIf DsGblEnv DsLclEnv

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | Run a <a>DsM</a> action inside the <a>IO</a> monad.
initDs :: HscEnv -> TcGblEnv -> DsM a -> IO (Messages DsMessage, Maybe a)

-- | Run a <a>DsM</a> action inside the <a>TcM</a> monad.
initDsTc :: DsM a -> TcM (Messages DsMessage, Maybe a)
initTcDsForSolver :: TcM a -> DsM a

-- | Run a <a>DsM</a> action in the context of an existing <a>ModGuts</a>
initDsWithModGuts :: HscEnv -> ModGuts -> DsM a -> IO (Messages DsMessage, Maybe a)
fixDs :: (a -> DsM a) -> DsM a

-- | Left-to-right monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, ..., w, x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldlM f z t = do
--       aa &lt;- f z a
--       bb &lt;- f aa b
--       ...
--       xx &lt;- f ww x
--       yy &lt;- f xx y
--       return yy -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldlM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldlM f z t =
--       flip f a &gt;=&gt; flip f b &gt;=&gt; ... &gt;=&gt; flip f x &gt;=&gt; flip f y $ z
--   </pre>
--   
--   The monadic effects of <tt>foldlM</tt> are sequenced from left to
--   right.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from an initial segment of the element
--   sequence. If you want to evaluate the monadic effects in right-to-left
--   order, or perhaps be able to short-circuit after processing a tail of
--   the sequence of elements, you'll need to use <a>foldrM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the rightmost element <tt>y</tt>, so that,
--   ignoring effects, the result looks like a left fold:
--   
--   <pre>
--   ((((z `f` a) `f` b) ... `f` w) `f` x) `f` y
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f a e = do { print e ; return $ e : a }
--   
--   &gt;&gt;&gt; foldlM f [] [0..3]
--   0
--   1
--   2
--   3
--   [3,2,1,0]
--   </pre>
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Right-to-left monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, c, ..., x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldrM f z t = do
--       yy &lt;- f y z
--       xx &lt;- f x yy
--       ...
--       bb &lt;- f b cc
--       aa &lt;- f a bb
--       return aa -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldrM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldrM f z t = f y &gt;=&gt; f x &gt;=&gt; ... &gt;=&gt; f b &gt;=&gt; f a $ z
--   </pre>
--   
--   The monadic effects of <tt>foldrM</tt> are sequenced from right to
--   left, and e.g. folds of infinite lists will diverge.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from a tail of the element sequence. If
--   you want to evaluate the monadic effects in left-to-right order, or
--   perhaps be able to short-circuit after an initial sequence of
--   elements, you'll need to use <a>foldlM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the leftmost element <tt>a</tt>, so that, ignoring
--   effects, the result looks like a right fold:
--   
--   <pre>
--   a `f` (b `f` (c `f` (... (x `f` (y `f` z))))).
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f i acc = do { print i ; return $ i : acc }
--   
--   &gt;&gt;&gt; foldrM f [] [0..3]
--   3
--   2
--   1
--   0
--   [0,1,2,3]
--   </pre>
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
whenGOptM :: GeneralFlag -> TcRnIf gbl lcl () -> TcRnIf gbl lcl ()
unsetGOptM :: GeneralFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
unsetWOptM :: WarningFlag -> TcRnIf gbl lcl a -> TcRnIf gbl lcl a
xoptM :: Extension -> TcRnIf gbl lcl Bool

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>
duplicateLocalDs :: Id -> DsM Id
newSysLocalDs :: Mult -> Type -> DsM Id
newSysLocalsDs :: [Scaled Type] -> DsM [Id]
newUniqueId :: Id -> Mult -> Type -> DsM Id
newFailLocalDs :: Mult -> Type -> DsM Id
newPredVarDs :: PredType -> DsM Var
getSrcSpanDs :: DsM SrcSpan
putSrcSpanDs :: SrcSpan -> DsM a -> DsM a
putSrcSpanDsA :: SrcSpanAnn' ann -> DsM a -> DsM a
mkNamePprCtxDs :: DsM NamePprCtx
newUnique :: TcRnIf gbl lcl Unique

-- | Unique Supply
--   
--   A value of type <a>UniqSupply</a> is unique, and it can supply
--   <i>one</i> distinct <a>Unique</a>. Also, from the supply, one can also
--   manufacture an arbitrary number of further <tt>UniqueSupply</tt>
--   values, which will be distinct from the first and from all others.
data UniqSupply
newUniqueSupply :: TcRnIf gbl lcl UniqSupply
getGhcModeDs :: DsM GhcMode
dsGetFamInstEnvs :: DsM FamInstEnvs
dsLookupGlobal :: Name -> DsM TyThing
dsLookupGlobalId :: Name -> DsM Id
dsLookupTyCon :: Name -> DsM TyCon
dsLookupDataCon :: Name -> DsM DataCon
dsLookupConLike :: Name -> DsM ConLike

-- | See <a>getCCIndexM</a>.
getCCIndexDsM :: FastString -> DsM CostCentreIndex
type DsMetaEnv = NameEnv DsMetaVal
data DsMetaVal
DsBound :: Id -> DsMetaVal
DsSplice :: HsExpr GhcTc -> DsMetaVal
dsGetMetaEnv :: DsM (NameEnv DsMetaVal)
dsLookupMetaEnv :: Name -> DsM (Maybe DsMetaVal)
dsExtendMetaEnv :: DsMetaEnv -> DsM a -> DsM a

-- | Get the current pattern match oracle state. See <a>dsl_nablas</a>.
getPmNablas :: DsM Nablas

-- | Set the pattern match oracle state within the scope of the given
--   action. See <a>dsl_nablas</a>.
updPmNablas :: Nablas -> DsM a -> DsM a

-- | The <tt>COMPLETE</tt> pragmas that are in scope.
dsGetCompleteMatches :: DsM CompleteMatches
type DsWarning = (SrcSpan, SDoc)

-- | Emit a diagnostic for the current source location. In case the
--   diagnostic is a warning, the latter will be ignored and discarded if
--   the relevant <a>WarningFlag</a> is not set in the DynFlags. See Note
--   [Discarding Messages] in <a>Error</a>.
diagnosticDs :: DsMessage -> DsM ()

-- | Issue an error, but return the expression for (), so that we can
--   continue reporting errors.
errDsCoreExpr :: DsMessage -> DsM CoreExpr
failWithDs :: DsMessage -> DsM a
failDs :: DsM a
discardWarningsDs :: DsM a -> DsM a
data DsMatchContext
DsMatchContext :: HsMatchContext GhcRn -> SrcSpan -> DsMatchContext
data EquationInfo
EqnInfo :: [Pat GhcTc] -> Origin -> MatchResult CoreExpr -> EquationInfo

-- | The patterns for an equation
--   
--   NB: We have <i>already</i> applied <tt>decideBangHood</tt> to these
--   patterns. See Note [decideBangHood] in <a>GHC.HsToCore.Utils</a>
[eqn_pats] :: EquationInfo -> [Pat GhcTc]

-- | Was this equation present in the user source?
--   
--   This helps us avoid warnings on patterns that GHC elaborated.
--   
--   For instance, the pattern <tt>-1 :: Word</tt> gets desugared into
--   <tt>W# -1## :: Word</tt>, but we shouldn't warn about an overflowed
--   literal for <i>both</i> of these cases.
[eqn_orig] :: EquationInfo -> Origin

-- | What to do after match
[eqn_rhs] :: EquationInfo -> MatchResult CoreExpr

-- | This is a value of type a with potentially a CoreExpr-shaped hole in
--   it. This is used to deal with cases where we are potentially handling
--   pattern match failure, and want to later specify how failure is
--   handled.
data MatchResult a

-- | We represent the case where there is no hole without a function from
--   <a>CoreExpr</a>, like this, because sometimes we have nothing to put
--   in the hole and so want to be sure there is in fact no hole.
MR_Infallible :: DsM a -> MatchResult a
MR_Fallible :: (CoreExpr -> DsM a) -> MatchResult a
runMatchResult :: CoreExpr -> MatchResult a -> DsM a
type DsWrapper = CoreExpr -> CoreExpr
idDsWrapper :: DsWrapper

-- | Inject a trace message into the compiled program. Whereas pprTrace
--   prints out information *while compiling*, pprRuntimeTrace captures
--   that information and causes it to be printed *at runtime* using
--   Debug.Trace.trace.
--   
--   pprRuntimeTrace hdr doc expr
--   
--   will produce an expression that looks like
--   
--   trace (hdr + doc) expr
--   
--   When using this to debug a module that Debug.Trace depends on, it is
--   necessary to import {-# SOURCE #-} Debug.Trace () in that module. We
--   could avoid this inconvenience by wiring in Debug.Trace.trace, but
--   that doesn't seem worth the effort and maintenance cost.
pprRuntimeTrace :: String -> SDoc -> CoreExpr -> DsM CoreExpr
instance GHC.Base.Functor GHC.HsToCore.Monad.MatchResult
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Monad.EquationInfo
instance GHC.Base.Applicative GHC.HsToCore.Monad.MatchResult
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Monad.DsMatchContext
instance GHC.Types.TyThing.MonadThings (GHC.Data.IOEnv.IOEnv (GHC.Tc.Types.Env GHC.HsToCore.Types.DsGblEnv GHC.HsToCore.Types.DsLclEnv))


-- | Utility module for the pattern-match coverage checker.
module GHC.HsToCore.Pmc.Utils
tracePm :: String -> SDoc -> DsM ()
traceWhenFailPm :: String -> SDoc -> MaybeT DsM a -> MaybeT DsM a

-- | Generate a fresh <a>Id</a> of a given type
mkPmId :: Type -> DsM Id

-- | All warning flags that need to run the pattern match checker.
allPmCheckWarnings :: [WarningFlag]

-- | Check whether the redundancy checker should run (redundancy only)
overlapping :: DynFlags -> HsMatchContext id -> Bool

-- | Check whether the exhaustiveness checker should run (exhaustiveness
--   only)
exhaustive :: DynFlags -> HsMatchContext id -> Bool

-- | Check whether unnecessary bangs should be warned about
redundantBang :: DynFlags -> Bool

-- | Denotes whether an exhaustiveness check is supported, and if so, via
--   which <a>WarningFlag</a> it's controlled. Returns <a>Nothing</a> if
--   check is not supported.
exhaustiveWarningFlag :: HsMatchContext id -> Maybe WarningFlag

-- | Check whether any part of pattern match checking is enabled for this
--   <a>HsMatchContext</a> (does not matter whether it is the redundancy
--   check or the exhaustiveness check).
isMatchContextPmChecked :: DynFlags -> Origin -> HsMatchContext id -> Bool

-- | Return True when any of the pattern match warnings
--   (<a>allPmCheckWarnings</a>) are enabled, in which case we need to run
--   the pattern match checker.
needToRunPmCheck :: DynFlags -> Origin -> Bool


-- | Model refinements type as per the <a>Lower Your Guards paper</a>. The
--   main export of the module are the functions <a>addPhiCtsNablas</a> for
--   adding facts to the oracle, <a>isInhabited</a> to check if a
--   refinement type is inhabited and <a>generateInhabitingPatterns</a> to
--   turn a <a>Nabla</a> into a concrete pattern for an equation.
--   
--   In terms of the LYG paper, this module is concerned with Sections 3.4,
--   3.6 and 3.7. E.g., it represents refinement types directly as a bunch
--   of normalised refinement types <a>Nabla</a>.
module GHC.HsToCore.Pmc.Solver

-- | A normalised refinement type ∇ ("nabla"), comprised of an inert set of
--   canonical (i.e. mutually compatible) term and type constraints that
--   form the refinement type's predicate.
data Nabla

-- | A disjunctive bag of <a>Nabla</a>s, representing a refinement type.
newtype Nablas
MkNablas :: Bag Nabla -> Nablas
initNablas :: Nablas

-- | A high-level pattern-match constraint. Corresponds to φ from Figure 3
--   of the LYG paper.
data PhiCt

-- | A type constraint "T ~ U".
PhiTyCt :: !PredType -> PhiCt

-- | <tt>PhiCoreCt x e</tt> encodes "x ~ e", equating <tt>x</tt> with the
--   <a>CoreExpr</a> <tt>e</tt>.
PhiCoreCt :: !Id -> !CoreExpr -> PhiCt

-- | <tt>PhiConCt x K tvs dicts ys</tt> encodes <tt>K @tvs dicts ys &lt;-
--   x</tt>, matching <tt>x</tt> against the <a>PmAltCon</a> application
--   <tt>K @tvs dicts ys</tt>, binding <tt>tvs</tt>, <tt>dicts</tt> and
--   possibly unlifted fields <tt>ys</tt> in the process. See Note [Strict
--   fields and variables of unlifted type].
PhiConCt :: !Id -> !PmAltCon -> ![TyVar] -> ![PredType] -> ![Id] -> PhiCt

-- | <tt>PhiNotConCt x K</tt> encodes "x ≁ K", asserting that <tt>x</tt>
--   can't be headed by <tt>K</tt>.
PhiNotConCt :: !Id -> !PmAltCon -> PhiCt

-- | <tt>PhiBotCt x</tt> encodes "x ~ ⊥", equating <tt>x</tt> to ⊥. by
--   <tt>K</tt>.
PhiBotCt :: !Id -> PhiCt

-- | <tt>PhiNotBotCt x y</tt> encodes "x ≁ ⊥", asserting that <tt>x</tt>
--   can't be ⊥.
PhiNotBotCt :: !Id -> PhiCt
type PhiCts = Bag PhiCt

-- | <tt>addPmCtsNablas</tt> for a single <tt>PmCt</tt>.
addPhiCtNablas :: Nablas -> PhiCt -> DsM Nablas

-- | Add a bunch of <a>PhiCt</a>s to all the <a>Nabla</a>s. Lifts
--   <a>addPhiCts</a> over many <a>Nablas</a>.
addPhiCtsNablas :: Nablas -> PhiCts -> DsM Nablas

-- | Test if any of the <a>Nabla</a>s is inhabited. Currently this is pure,
--   because we preserve the invariant that there are no uninhabited
--   <a>Nabla</a>s. But that could change in the future, for example by
--   implementing this function in terms of <tt>notNull <a>$</a>
--   generateInhabitingPatterns 1 ds</tt>.
isInhabited :: Nablas -> DsM Bool

-- | <tt>generateInhabitingPatterns vs n nabla</tt> returns a list of at
--   most <tt>n</tt> (but perhaps empty) refinements of <tt>nabla</tt> that
--   represent inhabited patterns. Negative information is only retained if
--   literals are involved or for recursive GADTs.
generateInhabitingPatterns :: GenerateInhabitingPatternsMode -> [Id] -> Int -> Nabla -> DsM [Nabla]

-- | See Note [Case split inhabiting patterns]
data GenerateInhabitingPatternsMode
CaseSplitTopLevel :: GenerateInhabitingPatternsMode
MinimalCover :: GenerateInhabitingPatternsMode
instance GHC.Show.Show GHC.HsToCore.Pmc.Solver.GenerateInhabitingPatternsMode
instance GHC.Classes.Eq GHC.HsToCore.Pmc.Solver.GenerateInhabitingPatternsMode
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.GenerateInhabitingPatternsMode
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.PhiCt
instance GHC.Utils.Outputable.Outputable GHC.HsToCore.Pmc.Solver.TopNormaliseTypeResult


-- | Coverage checking step of the <a>Lower Your Guards paper</a>.
--   
--   Coverage check guard trees (like <tt><a>PmMatch</a> <a>Pre</a></tt>)
--   to get a <a>CheckResult</a>, containing
--   
--   <ol>
--   <li>The set of uncovered values, <a>cr_uncov</a></li>
--   <li>And an annotated tree variant (like <tt><a>PmMatch</a>
--   <a>Post</a></tt>) that captures redundancy and inaccessibility
--   information as <a>RedSets</a> annotations</li>
--   </ol>
--   
--   Basically the UA function from Section 5.1, which is an optimised
--   interleaving of U and A from Section 3.2 (Figure 5). The Normalised
--   Refinement Types <a>Nablas</a> are maintained in
--   <a>GHC.HsToCore.Pmc.Solver</a>.
module GHC.HsToCore.Pmc.Check

-- | Coverage checking action. Can be composed <a>leftToRight</a> or
--   <a>topToBottom</a>.
newtype CheckAction a
CA :: (Nablas -> DsM (CheckResult a)) -> CheckAction a
[unCA] :: CheckAction a -> Nablas -> DsM (CheckResult a)
checkMatchGroup :: PmMatchGroup Pre -> CheckAction (PmMatchGroup Post)
checkGRHSs :: PmGRHSs Pre -> CheckAction (PmGRHSs Post)
checkPatBind :: PmPatBind Pre -> CheckAction (PmPatBind Post)
checkEmptyCase :: PmEmptyCase -> CheckAction PmEmptyCase
instance GHC.Base.Functor GHC.HsToCore.Pmc.Check.CheckAction


-- | Utility functions for constructing Core syntax, principally for
--   desugaring
module GHC.HsToCore.Utils
data EquationInfo
EqnInfo :: [Pat GhcTc] -> Origin -> MatchResult CoreExpr -> EquationInfo

-- | The patterns for an equation
--   
--   NB: We have <i>already</i> applied <tt>decideBangHood</tt> to these
--   patterns. See Note [decideBangHood] in <a>GHC.HsToCore.Utils</a>
[eqn_pats] :: EquationInfo -> [Pat GhcTc]

-- | Was this equation present in the user source?
--   
--   This helps us avoid warnings on patterns that GHC elaborated.
--   
--   For instance, the pattern <tt>-1 :: Word</tt> gets desugared into
--   <tt>W# -1## :: Word</tt>, but we shouldn't warn about an overflowed
--   literal for <i>both</i> of these cases.
[eqn_orig] :: EquationInfo -> Origin

-- | What to do after match
[eqn_rhs] :: EquationInfo -> MatchResult CoreExpr
firstPat :: EquationInfo -> Pat GhcTc
shiftEqns :: Functor f => f EquationInfo -> f EquationInfo

-- | This is a value of type a with potentially a CoreExpr-shaped hole in
--   it. This is used to deal with cases where we are potentially handling
--   pattern match failure, and want to later specify how failure is
--   handled.
data MatchResult a

-- | We represent the case where there is no hole without a function from
--   <a>CoreExpr</a>, like this, because sometimes we have nothing to put
--   in the hole and so want to be sure there is in fact no hole.
MR_Infallible :: DsM a -> MatchResult a
MR_Fallible :: (CoreExpr -> DsM a) -> MatchResult a
data CaseAlt a
MkCaseAlt :: a -> [Var] -> HsWrapper -> MatchResult CoreExpr -> CaseAlt a
[alt_pat] :: CaseAlt a -> a
[alt_bndrs] :: CaseAlt a -> [Var]
[alt_wrapper] :: CaseAlt a -> HsWrapper
[alt_result] :: CaseAlt a -> MatchResult CoreExpr
cantFailMatchResult :: CoreExpr -> MatchResult CoreExpr
alwaysFailMatchResult :: MatchResult CoreExpr
extractMatchResult :: MatchResult CoreExpr -> CoreExpr -> DsM CoreExpr
combineMatchResults :: MatchResult CoreExpr -> MatchResult CoreExpr -> MatchResult CoreExpr
adjustMatchResultDs :: (a -> DsM b) -> MatchResult a -> MatchResult b
shareFailureHandler :: MatchResult CoreExpr -> MatchResult CoreExpr
dsHandleMonadicFailure :: HsDoFlavour -> LPat GhcTc -> MatchResult CoreExpr -> FailOperator GhcTc -> DsM CoreExpr
mkCoLetMatchResult :: CoreBind -> MatchResult CoreExpr -> MatchResult CoreExpr
mkViewMatchResult :: Id -> CoreExpr -> MatchResult CoreExpr -> MatchResult CoreExpr
mkGuardedMatchResult :: CoreExpr -> MatchResult CoreExpr -> MatchResult CoreExpr
matchCanFail :: MatchResult a -> Bool
mkEvalMatchResult :: Id -> Type -> MatchResult CoreExpr -> MatchResult CoreExpr
mkCoPrimCaseMatchResult :: Id -> Type -> [(Literal, MatchResult CoreExpr)] -> MatchResult CoreExpr
mkCoAlgCaseMatchResult :: Id -> Type -> NonEmpty (CaseAlt DataCon) -> MatchResult CoreExpr
mkCoSynCaseMatchResult :: Id -> Type -> CaseAlt PatSyn -> MatchResult CoreExpr
wrapBind :: Var -> Var -> CoreExpr -> CoreExpr
wrapBinds :: [(Var, Var)] -> CoreExpr -> CoreExpr
mkErrorAppDs :: Id -> Type -> SDoc -> DsM CoreExpr
mkCoreAppDs :: SDoc -> CoreExpr -> CoreExpr -> CoreExpr
mkCoreAppsDs :: SDoc -> CoreExpr -> [CoreExpr] -> CoreExpr
mkCastDs :: CoreExpr -> Coercion -> CoreExpr
mkFailExpr :: HsMatchContext GhcRn -> Type -> DsM CoreExpr
seqVar :: Var -> CoreExpr -> CoreExpr
mkLHsPatTup :: [LPat GhcTc] -> LPat GhcTc
mkVanillaTuplePat :: [LPat GhcTc] -> Boxity -> Pat GhcTc
mkBigLHsVarTupId :: [Id] -> LHsExpr GhcTc
mkBigLHsTupId :: [LHsExpr GhcTc] -> LHsExpr GhcTc
mkBigLHsVarPatTupId :: [Id] -> LPat GhcTc
mkBigLHsPatTupId :: [LPat GhcTc] -> LPat GhcTc
mkSelectorBinds :: [[CoreTickish]] -> LPat GhcTc -> CoreExpr -> DsM (Id, [(Id, CoreExpr)])
selectSimpleMatchVarL :: Mult -> LPat GhcTc -> DsM Id
selectMatchVars :: [(Mult, Pat GhcTc)] -> DsM [Id]
selectMatchVar :: Mult -> Pat GhcTc -> DsM Id
mkOptTickBox :: [CoreTickish] -> CoreExpr -> CoreExpr
mkBinaryTickBox :: Int -> Int -> CoreExpr -> DsM CoreExpr

-- | Use -XStrict to add a ! or remove a ~ See Note [decideBangHood]
decideBangHood :: DynFlags -> LPat GhcTc -> LPat GhcTc
isTrueLHsExpr :: LHsExpr GhcTc -> Maybe (CoreExpr -> DsM CoreExpr)

module GHC.HsToCore.Foreign.Call
dsCCall :: CLabelString -> [CoreExpr] -> Safety -> Type -> DsM CoreExpr
mkFCall :: Unique -> ForeignCall -> [CoreExpr] -> Type -> CoreExpr
unboxArg :: CoreExpr -> DsM (CoreExpr, CoreExpr -> CoreExpr)
boxResult :: Type -> DsM (Type, CoreExpr -> CoreExpr)
resultWrapper :: Type -> DsM (Maybe Type, CoreExpr -> CoreExpr)


-- | Foreign primitive calls
--   
--   This is for `<tt>foreign import prim</tt>' declarations.
--   
--   Currently, at the core level we pretend that these primitive calls are
--   foreign calls. It may make more sense in future to have them as a
--   distinct kind of Id, or perhaps to bundle them with PrimOps since
--   semantically and for calling convention they are really prim ops.
module GHC.HsToCore.Foreign.Prim
dsPrimCall :: Id -> Coercion -> ForeignCall -> DsM ([(Id, Expr TyVar)], CHeader, CStub)


-- | Handling of JavaScript foreign imports/exports
module GHC.HsToCore.Foreign.JavaScript

-- | Desugaring of JavaScript foreign imports
dsJsImport :: Id -> Coercion -> CImportSpec -> CCallConv -> Safety -> Maybe Header -> DsM ([Binding], CHeader, CStub)
dsJsFExport :: Id -> Coercion -> CLabelString -> CCallConv -> Bool -> DsM (CHeader, CStub, String, Int)
dsJsFExportDynamic :: Id -> Coercion -> CCallConv -> DsM ([Binding], CHeader, CStub)


-- | Handling of C foreign imports/exports
module GHC.HsToCore.Foreign.C
dsCImport :: Id -> Coercion -> CImportSpec -> CCallConv -> Safety -> Maybe Header -> DsM ([Binding], CHeader, CStub)
dsCFExport :: Id -> Coercion -> CLabelString -> CCallConv -> Bool -> DsM (CHeader, CStub, String, Int)
dsCFExportDynamic :: Id -> Coercion -> CCallConv -> DsM ([Binding], CHeader, CStub)


-- | Desugaring foreign declarations
module GHC.HsToCore.Foreign.Decl
dsForeigns :: [LForeignDecl GhcTc] -> DsM (ForeignStubs, OrdList Binding)

module GHC.HsToCore.Match.Literal
dsLit :: HsLit GhcRn -> DsM CoreExpr

-- | Post-typechecker, the <a>HsExpr</a> field of an <a>OverLit</a>
--   contains (an expression for) the literal value itself.
dsOverLit :: HsOverLit GhcTc -> DsM CoreExpr
hsLitKey :: Platform -> HsLit GhcTc -> Literal
tidyLitPat :: HsLit GhcTc -> Pat GhcTc
tidyNPat :: HsOverLit GhcTc -> Maybe (SyntaxExpr GhcTc) -> SyntaxExpr GhcTc -> Type -> Pat GhcTc
matchLiterals :: NonEmpty Id -> Type -> NonEmpty (NonEmpty EquationInfo) -> DsM (MatchResult CoreExpr)
matchNPlusKPats :: NonEmpty Id -> Type -> NonEmpty EquationInfo -> DsM (MatchResult CoreExpr)
matchNPats :: NonEmpty Id -> Type -> NonEmpty EquationInfo -> DsM (MatchResult CoreExpr)
warnAboutIdentities :: DynFlags -> Id -> Type -> DsM ()

-- | Emit warnings on overloaded integral literals which overflow the
--   bounds implied by their type.
warnAboutOverflowedOverLit :: HsOverLit GhcTc -> DsM ()

-- | Emit warnings on integral literals which overflow the bounds implied
--   by their type.
warnAboutOverflowedLit :: HsLit GhcTc -> DsM ()

-- | Warns about <tt>[2,3 .. 1]</tt> or <tt>[<tt>b</tt> .. <tt>a</tt>]</tt>
--   which return the empty list. For numeric literals, only works for
--   integral types, not floating point.
warnAboutEmptyEnumerations :: FamInstEnvs -> DynFlags -> LHsExpr GhcTc -> Maybe (LHsExpr GhcTc) -> LHsExpr GhcTc -> DsM ()

module GHC.HsToCore.GuardedRHSs
dsGuarded :: GRHSs GhcTc (LHsExpr GhcTc) -> Type -> NonEmpty Nablas -> DsM CoreExpr
dsGRHSs :: HsMatchContext GhcRn -> GRHSs GhcTc (LHsExpr GhcTc) -> Type -> NonEmpty Nablas -> DsM (MatchResult CoreExpr)
isTrueLHsExpr :: LHsExpr GhcTc -> Maybe (CoreExpr -> DsM CoreExpr)


-- | Desugaring step of the <a>Lower Your Guards paper</a>.
--   
--   Desugars Haskell source syntax into guard tree variants Pm*. In terms
--   of the paper, this module is concerned with Sections 3.1, Figure 4, in
--   particular.
module GHC.HsToCore.Pmc.Desugar
desugarPatBind :: SrcSpan -> Id -> Pat GhcTc -> DsM (PmPatBind Pre)
desugarGRHSs :: SrcSpan -> SDoc -> GRHSs GhcTc (LHsExpr GhcTc) -> DsM (PmGRHSs Pre)

-- | Desugar the non-empty <a>Match</a>es of a <a>MatchGroup</a>.
desugarMatches :: [Id] -> NonEmpty (LMatch GhcTc (LHsExpr GhcTc)) -> DsM (PmMatchGroup Pre)
desugarEmptyCase :: Id -> DsM PmEmptyCase


-- | This module coverage checks pattern matches. It finds
--   
--   <ul>
--   <li>Uncovered patterns, certifying non-exhaustivity</li>
--   <li>Redundant equations</li>
--   <li>Equations with an inaccessible right-hand-side</li>
--   </ul>
--   
--   The algorithm is based on the paper <a>Lower Your Guards: A
--   Compositional Pattern-Match Coverage Checker"</a>
--   
--   There is an overview Figure 2 in there that's probably helpful. Here
--   is an overview of how it's implemented, which follows the structure of
--   the entry points such as <a>pmcMatches</a>:
--   
--   <ol>
--   <li>Desugar source syntax (like <a>LMatch</a>) to guard tree variants
--   (like <tt>GrdMatch</tt>), with one of the desugaring functions (like
--   <tt>desugarMatch</tt>). See <a>GHC.HsToCore.Pmc.Desugar</a>. Follows
--   Section 3.1 in the paper.</li>
--   <li>Coverage check guard trees (with a function like
--   <tt>checkMatch</tt>) to get a <a>CheckResult</a>. See
--   <a>GHC.HsToCore.Pmc.Check</a>. The normalised refinement types
--   <a>Nabla</a> are tested for inhabitants by
--   <a>GHC.HsToCore.Pmc.Solver</a>.</li>
--   <li>Collect redundancy information into a <a>CIRB</a> with a function
--   such as <a>cirbsMatch</a>. Follows the R function from Figure 6 of the
--   paper.</li>
--   <li>Format and report uncovered patterns and redundant equations
--   (<a>CIRB</a>) with <a>formatReportWarnings</a>. Basically job of the G
--   function, plus proper pretty printing of the warnings (Section 5.4 of
--   the paper).</li>
--   <li>Return <a>Nablas</a> reaching syntactic sub-components for Note
--   [Long-distance information]. Collected by functions such as
--   <a>ldiMatch</a>. See Section 4.1 of the paper.</li>
--   </ol>
module GHC.HsToCore.Pmc

-- | Check a pattern binding (let, where) for exhaustiveness.
pmcPatBind :: DsMatchContext -> Id -> Pat GhcTc -> DsM ()

-- | Check a list of syntactic <a>Match</a>es (part of case, functions,
--   etc.), each with a <a>Pat</a> and one or more <a>GRHSs</a>:
--   
--   <pre>
--   f x y | x == y    = 1   -- match on x and y with two guarded RHSs
--         | otherwise = 2
--   f _ _             = 3   -- clause with a single, un-guarded RHS
--   </pre>
--   
--   Returns one non-empty <a>Nablas</a> for 1.) each pattern of a
--   <a>Match</a> and 2.) each of a <a>Match</a>es <a>GRHS</a> for Note
--   [Long-distance information].
--   
--   Special case: When there are <i>no matches</i>, then the function
--   assumes it checks an <tt>-XEmptyCase</tt> with only a single match
--   variable. See Note [Checking EmptyCase].
pmcMatches :: DsMatchContext -> [Id] -> [LMatch GhcTc (LHsExpr GhcTc)] -> DsM [(Nablas, NonEmpty Nablas)]

-- | Exhaustive for guard matches, is used for guards in pattern bindings
--   and in <tt>MultiIf</tt> expressions. Returns the <a>Nablas</a> covered
--   by the RHSs.
pmcGRHSs :: HsMatchContext GhcRn -> GRHSs GhcTc (LHsExpr GhcTc) -> DsM (NonEmpty Nablas)

-- | Check whether any part of pattern match checking is enabled for this
--   <a>HsMatchContext</a> (does not matter whether it is the redundancy
--   check or the exhaustiveness check).
isMatchContextPmChecked :: DynFlags -> Origin -> HsMatchContext id -> Bool

-- | Add in-scope type constraints if the coverage checker might run and
--   then run the given action.
addTyCs :: Origin -> Bag EvVar -> DsM a -> DsM a

-- | Add equalities for the <a>CoreExpr</a> scrutinees to the local
--   <a>DsM</a> environment, e.g. when checking a case expression: case e
--   of x { matches } When checking matches we record that (x ~ e) where x
--   is the initial uncovered. All matches will have to satisfy this
--   equality. This is also used for the Arrows cases command, where these
--   equalities have to be added for multiple scrutinees rather than just
--   one.
addCoreScrutTmCs :: [CoreExpr] -> [Id] -> DsM a -> DsM a

-- | <a>addCoreScrutTmCs</a>, but desugars the <a>LHsExpr</a>s first.
addHsScrutTmCs :: [LHsExpr GhcTc] -> [Id] -> DsM a -> DsM a

-- | A non-empty delta that is initialised from the ambient refinement type
--   capturing long-distance information, or the trivially habitable
--   <a>Nablas</a> if the former is uninhabited. See Note [Recovering from
--   unsatisfiable pattern-matching constraints].
getLdiNablas :: DsM Nablas
instance GHC.Classes.Eq (GHC.HsToCore.Pmc.FormatReportWarningsMode ann)
instance GHC.Base.Semigroup GHC.HsToCore.Pmc.CIRB
instance GHC.Base.Monoid GHC.HsToCore.Pmc.CIRB

module GHC.HsToCore.Binds

-- | Desugar top level binds, strict binds are treated like normal binds
--   since there is no good time to force before first usage.
dsTopLHsBinds :: LHsBinds GhcTc -> DsM (OrdList (Id, CoreExpr))

-- | Desugar all other kind of bindings, Ids of strict binds are returned
--   to later be forced in the binding group body, see Note [Desugar Strict
--   binds]
dsLHsBinds :: LHsBinds GhcTc -> DsM ([Id], [(Id, CoreExpr)])
decomposeRuleLhs :: DynFlags -> [Var] -> CoreExpr -> VarSet -> Either DsMessage ([Var], Id, [CoreExpr])
dsSpec :: Maybe CoreExpr -> Located TcSpecPrag -> DsM (Maybe (OrdList (Id, CoreExpr), CoreRule))
dsHsWrapper :: HsWrapper -> DsM (CoreExpr -> CoreExpr)
dsEvTerm :: EvTerm -> DsM CoreExpr
dsTcEvBinds :: TcEvBinds -> DsM [CoreBind]
dsTcEvBinds_s :: [TcEvBinds] -> DsM [CoreBind]
dsEvBinds :: Bag EvBind -> DsM [CoreBind]
dsWarnOrphanRule :: CoreRule -> DsM ()

module GHC.HsToCore.Quote
dsBracket :: HsBracketTc -> DsM CoreExpr
instance GHC.HsToCore.Quote.RepTV () ()
instance GHC.HsToCore.Quote.RepTV GHC.Types.Var.Specificity Language.Haskell.TH.Syntax.Specificity

module GHC.HsToCore.Match.Constructor
matchConFamily :: NonEmpty Id -> Type -> NonEmpty (NonEmpty EquationInfo) -> DsM (MatchResult CoreExpr)
matchPatSyn :: NonEmpty Id -> Type -> NonEmpty EquationInfo -> DsM (MatchResult CoreExpr)

module GHC.HsToCore.Match
match :: [MatchId] -> Type -> [EquationInfo] -> DsM (MatchResult CoreExpr)
matchEquations :: HsMatchContext GhcRn -> [MatchId] -> [EquationInfo] -> Type -> DsM CoreExpr
matchWrapper :: HsMatchContext GhcRn -> Maybe [LHsExpr GhcTc] -> MatchGroup GhcTc (LHsExpr GhcTc) -> DsM ([Id], CoreExpr)

-- | <tt>matchSimply</tt> is a wrapper for <a>match</a> which deals with
--   the situation where we want to match a single expression against a
--   single pattern. It returns an expression.
matchSimply :: CoreExpr -> HsMatchContext GhcRn -> LPat GhcTc -> CoreExpr -> CoreExpr -> DsM CoreExpr
matchSinglePat :: CoreExpr -> HsMatchContext GhcRn -> LPat GhcTc -> Type -> MatchResult CoreExpr -> DsM (MatchResult CoreExpr)
matchSinglePatVar :: Id -> Maybe CoreExpr -> HsMatchContext GhcRn -> LPat GhcTc -> Type -> MatchResult CoreExpr -> DsM (MatchResult CoreExpr)

module GHC.HsToCore.ListComp
dsListComp :: [ExprLStmt GhcTc] -> Type -> DsM CoreExpr
dsMonadComp :: [ExprLStmt GhcTc] -> DsM CoreExpr

module GHC.HsToCore.Arrows
dsProcExpr :: LPat GhcTc -> LHsCmdTop GhcTc -> DsM CoreExpr

module GHC.HsToCore.Expr
dsExpr :: HsExpr GhcTc -> DsM CoreExpr

-- | Replace the body of the function with this block to test the
--   hsExprType function in GHC.Tc.Utils.Zonk: putSrcSpanDs loc $ do {
--   core_expr &lt;- dsExpr e ; massertPpr (exprType core_expr
--   <a>eqType</a> hsExprType e) (ppr e <a>+</a> dcolon <a>+</a> ppr
--   (hsExprType e) $$ ppr core_expr <a>+</a> dcolon <a>+</a> ppr (exprType
--   core_expr)) ; return core_expr }
dsLExpr :: LHsExpr GhcTc -> DsM CoreExpr
dsLocalBinds :: HsLocalBinds GhcTc -> CoreExpr -> DsM CoreExpr
dsValBinds :: HsValBinds GhcTc -> CoreExpr -> DsM CoreExpr
dsLit :: HsLit GhcRn -> DsM CoreExpr
dsSyntaxExpr :: SyntaxExpr GhcTc -> [CoreExpr] -> DsM CoreExpr


-- | Module for detecting if recompilation is required
module GHC.Iface.Recomp

-- | Top level function to check if the version of an old interface file is
--   equivalent to the current source file the user asked us to compile. If
--   the same, we can avoid recompilation.
--   
--   We return on the outside whether the interface file is up to date,
--   providing evidence that is with a <a>ModIface</a>. In the case that it
--   isn't, we may also return a found or provided <a>ModIface</a>. Why we
--   don't always return the old one, if it exists, is unclear to me,
--   except that I tried it and some tests failed (see #18205).
checkOldIface :: HscEnv -> ModSummary -> Maybe ModIface -> IO (MaybeValidated ModIface)
data RecompileRequired

-- | everything is up to date, recompilation is not required
UpToDate :: RecompileRequired

-- | Need to compile the module
NeedsRecompile :: !CompileReason -> RecompileRequired
needsRecompileBecause :: RecompReason -> RecompileRequired
recompThen :: Monad m => m RecompileRequired -> m RecompileRequired -> m RecompileRequired
data MaybeValidated a

-- | The item contained is validated to be up to date
UpToDateItem :: a -> MaybeValidated a

-- | The item is are absent altogether or out of date, for the reason
--   given.
OutOfDateItem :: !CompileReason -> Maybe a -> MaybeValidated a
outOfDateItemBecause :: RecompReason -> Maybe a -> MaybeValidated a
data RecompReason
UnitDepRemoved :: UnitId -> RecompReason
ModulePackageChanged :: FastString -> RecompReason
SourceFileChanged :: RecompReason
ThisUnitIdChanged :: RecompReason
ImpurePlugin :: RecompReason
PluginsChanged :: RecompReason
PluginFingerprintChanged :: RecompReason
ModuleInstChanged :: RecompReason
HieMissing :: RecompReason
HieOutdated :: RecompReason
SigsMergeChanged :: RecompReason
ModuleChanged :: ModuleName -> RecompReason
ModuleRemoved :: (UnitId, ModuleName) -> RecompReason
ModuleAdded :: (UnitId, ModuleName) -> RecompReason
ModuleChangedRaw :: ModuleName -> RecompReason
ModuleChangedIface :: ModuleName -> RecompReason
FileChanged :: FilePath -> RecompReason
CustomReason :: String -> RecompReason
FlagsChanged :: RecompReason
OptimFlagsChanged :: RecompReason
HpcFlagsChanged :: RecompReason
MissingBytecode :: RecompReason
MissingObjectFile :: RecompReason
MissingDynObjectFile :: RecompReason
MissingDynHiFile :: RecompReason
MismatchedDynHiFile :: RecompReason
ObjectsChanged :: RecompReason
LibraryChanged :: RecompReason
data CompileReason

-- | The .hs file has been touched, or the .o/.hi file does not exist
MustCompile :: CompileReason

-- | The .o/.hi files are up to date, but something else has changed to
--   force recompilation; the String says what (one-line summary)
RecompBecause :: !RecompReason -> CompileReason
recompileRequired :: RecompileRequired -> Bool

-- | Add fingerprints for top-level declarations to a <a>ModIface</a>.
--   
--   See Note [Fingerprinting IfaceDecls]
addFingerprints :: HscEnv -> PartialModIface -> IO ModIface
instance GHC.Classes.Eq GHC.Iface.Recomp.RecompReason
instance GHC.Classes.Eq GHC.Iface.Recomp.CompileReason
instance GHC.Base.Functor GHC.Iface.Recomp.MaybeValidated
instance GHC.Classes.Eq GHC.Iface.Recomp.RecompileRequired
instance GHC.Utils.Outputable.Outputable GHC.Iface.Recomp.IfaceDeclExtras
instance GHC.Utils.Binary.Binary GHC.Iface.Recomp.IfaceDeclExtras
instance GHC.Utils.Binary.Binary GHC.Iface.Recomp.IfaceIdExtras
instance GHC.Utils.Outputable.Outputable GHC.Iface.Recomp.RecompileRequired
instance GHC.Base.Semigroup GHC.Iface.Recomp.RecompileRequired
instance GHC.Base.Monoid GHC.Iface.Recomp.RecompileRequired
instance GHC.Utils.Outputable.Outputable a => GHC.Utils.Outputable.Outputable (GHC.Iface.Recomp.MaybeValidated a)
instance GHC.Utils.Outputable.Outputable GHC.Iface.Recomp.CompileReason
instance GHC.Utils.Outputable.Outputable GHC.Iface.Recomp.RecompReason

module GHC.HsToCore.Usage
mkUsageInfo :: UsageConfig -> Plugins -> FinderCache -> UnitEnv -> Module -> ImportedMods -> NameSet -> [FilePath] -> [(Module, Fingerprint)] -> [Linkable] -> PkgsLoaded -> IfG [Usage]
mkUsedNames :: TcGblEnv -> NameSet
data UsageConfig
UsageConfig :: !Bool -> UsageConfig

-- | Are all implicit imports required to be safe for this Safe Haskell
--   mode?
[uc_safe_implicit_imps_req] :: UsageConfig -> !Bool

module GHC.Driver.Config.HsToCore.Usage
initUsageConfig :: HscEnv -> UsageConfig

module GHC.Builtin.PrimOps.Casts

-- | `getCasts from_rep to_rep` gives us a list of primops which when
--   applied in order convert from_rep to to_rep. See Note [PrimRep based
--   casting]
getCasts :: PrimRep -> PrimRep -> [(PrimOp, Type)]

module GHC.Stg.Unarise
unarise :: UniqSupply -> [StgTopBinding] -> [StgTopBinding]
instance GHC.Utils.Outputable.Outputable GHC.Stg.Unarise.UnariseVal

module GHC.Stg.Pipeline
data StgPipelineOpts
StgPipelineOpts :: ![StgToDo] -> !Maybe DiagOpts -> !StgPprOpts -> !Platform -> !Bool -> StgPipelineOpts

-- | Spec of what stg-to-stg passes to do
[stgPipeline_phases] :: StgPipelineOpts -> ![StgToDo]

-- | Should we lint the STG at various stages of the pipeline?
[stgPipeline_lint] :: StgPipelineOpts -> !Maybe DiagOpts
[stgPipeline_pprOpts] :: StgPipelineOpts -> !StgPprOpts
[stgPlatform] :: StgPipelineOpts -> !Platform
[stgPipeline_forBytecode] :: StgPipelineOpts -> !Bool

-- | Optional Stg-to-Stg passes.
data StgToDo

-- | Common subexpression elimination
StgCSE :: StgToDo

-- | Lambda lifting closure variables, trading stack/register allocation
--   for heap allocation
StgLiftLams :: StgLiftConfig -> StgToDo
StgStats :: StgToDo

-- | Mandatory unarise pass, desugaring unboxed tuple and sum binders
StgUnarise :: StgToDo

-- | Mandatory when compiling to bytecode
StgBcPrep :: StgToDo

-- | Useful for building up <tt>getStgToDo</tt>
StgDoNothing :: StgToDo
stg2stg :: Logger -> [Var] -> StgPipelineOpts -> Module -> [StgTopBinding] -> IO ([CgStgTopBinding], StgCgInfos)

-- | Information to be exposed in interface files which is produced by the
--   stg2stg passes.
type StgCgInfos = NameEnv TagSig
instance Control.Monad.IO.Class.MonadIO GHC.Stg.Pipeline.StgM
instance GHC.Base.Monad GHC.Stg.Pipeline.StgM
instance GHC.Base.Applicative GHC.Stg.Pipeline.StgM
instance GHC.Base.Functor GHC.Stg.Pipeline.StgM
instance GHC.Classes.Ord GHC.Stg.Pipeline.StgToDo
instance GHC.Classes.Eq GHC.Stg.Pipeline.StgToDo
instance GHC.Read.Read GHC.Stg.Pipeline.StgToDo
instance GHC.Show.Show GHC.Stg.Pipeline.StgToDo
instance GHC.Types.Unique.Supply.MonadUnique GHC.Stg.Pipeline.StgM


-- | Module for constructing <tt>ModIface</tt> values (interface files),
--   writing them to disk and comparing two versions to see if
--   recompilation is required.
module GHC.Iface.Make
mkPartialIface :: HscEnv -> CoreProgram -> ModDetails -> ModSummary -> ModGuts -> PartialModIface

-- | Fully instantiate an interface. Adds fingerprints and potentially code
--   generator produced information.
--   
--   CmmCgInfos is not available when not generating code (-fno-code), or
--   when not generating interface pragmas (-fomit-interface-pragmas). See
--   also Note [Conveying CAF-info and LFInfo between modules] in
--   GHC.StgToCmm.Types.
mkFullIface :: HscEnv -> PartialModIface -> Maybe StgCgInfos -> Maybe CmmCgInfos -> IO ModIface

-- | Make an interface from the results of typechecking only. Useful for
--   non-optimising compilation, or where we aren't generating any object
--   code at all (<tt>NoBackend</tt>).
mkIfaceTc :: HscEnv -> SafeHaskellMode -> ModDetails -> ModSummary -> Maybe CoreProgram -> TcGblEnv -> IO ModIface
mkIfaceExports :: [AvailInfo] -> [IfaceExport]
coAxiomToIfaceDecl :: CoAxiom br -> IfaceDecl
tyThingToIfaceDecl :: Bool -> TyThing -> IfaceDecl

module GHC.Types.TyThing.Ppr

-- | Pretty-prints a <a>TyThing</a>.
pprTyThing :: ShowSub -> TyThing -> SDoc

-- | Pretty-prints a <a>TyThing</a> in context: that is, if the entity is a
--   data constructor, record selector, or class method, then the entity's
--   parent declaration is pretty-printed with irrelevant parts omitted.
pprTyThingInContext :: ShowSub -> TyThing -> SDoc

-- | Pretty-prints a <a>TyThing</a> with its defining location.
pprTyThingLoc :: TyThing -> SDoc

-- | Like <a>pprTyThingInContext</a>, but adds the defining location.
pprTyThingInContextLoc :: TyThing -> SDoc

-- | Pretty-prints the <a>TyThing</a> header. For functions and data
--   constructors the function is equivalent to <a>pprTyThing</a> but for
--   type constructors and classes it prints only the header part of the
--   declaration.
pprTyThingHdr :: TyThing -> SDoc

-- | Pretty-prints a <a>FamInst</a> (type/data family instance) with its
--   defining location.
pprFamInst :: FamInst -> SDoc


-- | Typechecking a whole module
--   
--   
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/type-checker</a>
module GHC.Tc.Module

-- | The returned [Id] is the list of new Ids bound by this statement. It
--   can be used to extend the InteractiveContext via
--   extendInteractiveContext.
--   
--   The returned TypecheckedHsExpr is of type IO [ () ], a list of the
--   bound values, coerced to ().
tcRnStmt :: HscEnv -> GhciLStmt GhcPs -> IO (Messages TcRnMessage, Maybe ([Id], LHsExpr GhcTc, FixityEnv))

-- | tcRnExpr just finds the type of an expression for :type
tcRnExpr :: HscEnv -> TcRnExprMode -> LHsExpr GhcPs -> IO (Messages TcRnMessage, Maybe Type)

-- | How should we infer a type? See Note [TcRnExprMode]
data TcRnExprMode

-- | Instantiate inferred quantifiers only (:type)
TM_Inst :: TcRnExprMode

-- | Instantiate all quantifiers, and do eager defaulting (:type +d)
TM_Default :: TcRnExprMode
tcRnType :: HscEnv -> ZonkFlexi -> Bool -> LHsType GhcPs -> IO (Messages TcRnMessage, Maybe (Type, Kind))
tcRnImportDecls :: HscEnv -> [LImportDecl GhcPs] -> IO (Messages TcRnMessage, Maybe GlobalRdrEnv)

-- | Find all the Names that this RdrName could mean, in GHCi
tcRnLookupRdrName :: HscEnv -> LocatedN RdrName -> IO (Messages TcRnMessage, Maybe [Name])

-- | ASSUMES that the module is either in the <tt>HomePackageTable</tt> or
--   is a package module with an interface on disk. If neither of these is
--   true, then the result will be an error indicating the interface could
--   not be found.
getModuleInterface :: HscEnv -> Module -> IO (Messages TcRnMessage, Maybe ModIface)
tcRnDeclsi :: HscEnv -> [LHsDecl GhcPs] -> IO (Messages TcRnMessage, Maybe TcGblEnv)
isGHCiMonad :: HscEnv -> String -> IO (Messages TcRnMessage, Maybe Name)
runTcInteractive :: HscEnv -> TcRn a -> IO (Messages TcRnMessage, Maybe a)
withTcPlugins :: HscEnv -> TcM a -> TcM a
withHoleFitPlugins :: HscEnv -> TcM a -> TcM a
tcRnLookupName :: HscEnv -> Name -> IO (Messages TcRnMessage, Maybe TyThing)
tcRnGetInfo :: HscEnv -> Name -> IO (Messages TcRnMessage, Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))

-- | Top level entry point for typechecker and renamer
tcRnModule :: HscEnv -> ModSummary -> Bool -> HsParsedModule -> IO (Messages TcRnMessage, Maybe TcGblEnv)
tcRnModuleTcRnM :: HscEnv -> ModSummary -> HsParsedModule -> (Module, SrcSpan) -> TcRn TcGblEnv
tcTopSrcDecls :: HsGroup GhcRn -> TcM (TcGblEnv, TcLclEnv)
rnTopSrcDecls :: HsGroup GhcPs -> TcM (TcGblEnv, HsGroup GhcRn)

-- | Compares the two things for equivalence between boot-file and normal
--   code. Returns <tt>Nothing</tt> on success or <tt>Just "some helpful
--   info for user"</tt> failure. If the difference will be apparent to the
--   user, <tt>Just empty</tt> is perfectly suitable.
checkBootDecl :: Bool -> TyThing -> TyThing -> Maybe SDoc
checkHiBootIface' :: [ClsInst] -> TypeEnv -> [AvailInfo] -> ModDetails -> TcM [(Id, Id)]

-- | For a module <tt>modname</tt> of type <a>HscSource</a>, determine the
--   list of extra "imports" of other requirements which should be
--   considered part of the import of the requirement, because it
--   transitively depends on those requirements by imports of modules from
--   other packages. The situation is something like this:
--   
--   unit p where signature X signature Y import X
--   
--   unit q where dependency p[X=&lt;A&gt;,Y=&lt;B&gt;] signature A
--   signature B
--   
--   Although q's B does not directly import A, we still have to make sure
--   we process A first, because the merging process will cause B to
--   indirectly import A. This function finds the TRANSITIVE closure of all
--   such imports we need to make.
findExtraSigImports :: HscEnv -> HscSource -> ModuleName -> IO [ModuleName]
implicitRequirements :: HscEnv -> [(PkgQual, Located ModuleName)] -> IO [ModuleName]

-- | Given a <a>Unit</a>, make sure it is well typed. This is because unit
--   IDs come from Cabal, which does not know if things are well-typed or
--   not; a component may have been filled with implementations for the
--   holes that don't actually fulfill the requirements.
checkUnit :: Unit -> TcM ()

-- | Given a local <a>ModIface</a>, merge all inherited requirements from
--   <a>requirementMerges</a> into this signature, producing a final
--   <a>TcGblEnv</a> that matches the local signature and all required
--   signatures.
mergeSignatures :: HsParsedModule -> TcGblEnv -> ModIface -> TcRn TcGblEnv

-- | Top-level driver for signature merging (run after typechecking an
--   <tt>hsig</tt> file).
tcRnMergeSignatures :: HscEnv -> HsParsedModule -> TcGblEnv -> ModIface -> IO (Messages TcRnMessage, Maybe TcGblEnv)

-- | Given <a>tcg_mod</a>, instantiate a <a>ModIface</a> from the
--   indefinite library to use the actual implementations of the relevant
--   entities, checking that the implementation matches the signature.
instantiateSignature :: TcRn TcGblEnv

-- | Top-level driver for signature instantiation (run when compiling an
--   <tt>hsig</tt> file.)
tcRnInstantiateSignature :: HscEnv -> Module -> RealSrcSpan -> IO (Messages TcRnMessage, Maybe TcGblEnv)
loadUnqualIfaces :: HscEnv -> InteractiveContext -> TcM ()
badReexportedBootThing :: Bool -> Name -> Name -> TcRnMessage

-- | Compares two things for equivalence between boot-file and normal code,
--   reporting an error if they don't match up.
checkBootDeclM :: Bool -> TyThing -> TyThing -> TcM ()
missingBootThing :: Bool -> Name -> String -> TcRnMessage

-- | Extract the renamed information from TcGblEnv.
getRenamedStuff :: TcGblEnv -> RenamedStuff
type RenamedStuff = (Maybe (HsGroup GhcRn, [LImportDecl GhcRn], Maybe [(LIE GhcRn, Avails)], Maybe (LHsDoc GhcRn)))

module GHC.HsToCore

-- | Main entry point to the desugarer.
deSugar :: HscEnv -> ModLocation -> TcGblEnv -> IO (Messages DsMessage, Maybe ModGuts)
deSugarExpr :: HscEnv -> LHsExpr GhcTc -> IO (Messages DsMessage, Maybe CoreExpr)

module GHC.Iface.Ext.Ast

-- | Construct an <a>HieFile</a> from the outputs of the typechecker.
mkHieFile :: MonadIO m => ModSummary -> TcGblEnv -> RenamedSource -> m HieFile

-- | Construct an <a>HieFile</a> from the outputs of the typechecker but
--   don't read the source file again from disk.
mkHieFileWithSource :: FilePath -> ByteString -> ModSummary -> TcGblEnv -> RenamedSource -> HieFile
getCompressedAsts :: TypecheckedSource -> RenamedSource -> Bag EvBind -> [ClsInst] -> [TyCon] -> (HieASTs TypeIndex, Array TypeIndex HieTypeFlat)
enrichHie :: TypecheckedSource -> RenamedSource -> Bag EvBind -> [ClsInst] -> [TyCon] -> HieASTs Type
instance Data.Data.Data a => Data.Data.Data (GHC.Iface.Ext.Ast.PScoped a)
instance (GHC.Iface.Ext.Ast.HiePass p, GHC.Iface.Ext.Ast.AnnoBody p body, GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.MatchGroup (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))))
instance (GHC.Iface.Ext.Ast.HiePass p, Data.Data.Data (body (GHC.Hs.Extension.GhcPass p)), GHC.Iface.Ext.Ast.AnnoBody p body, GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))) => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.Match (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))), GHC.Iface.Ext.Ast.HiePass p, GHC.Iface.Ext.Ast.AnnoBody p body) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.GRHSs (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))), GHC.Iface.Ext.Ast.HiePass p, GHC.Iface.Ext.Ast.AnnoBody p body) => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Expr.GRHS (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p)))))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))), GHC.Iface.Ext.Ast.AnnoBody p body, GHC.Iface.Ext.Ast.HiePass p) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.Stmt (GHC.Hs.Extension.GhcPass p) (GHC.Parser.Annotation.LocatedA (body (GHC.Hs.Extension.GhcPass p))))))
instance (GHC.Iface.Ext.Ast.HasLoc a, GHC.Iface.Ext.Ast.HiePass p) => GHC.Iface.Ext.Ast.HasLoc (Language.Haskell.Syntax.Decls.FamEqn (GHC.Hs.Extension.GhcPass p) a)
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.HasType (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.HsBind (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.HasType (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Pat.Pat (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.HasType (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass 'GHC.Hs.Extension.Renamed
instance GHC.Iface.Ext.Ast.HiePass 'GHC.Hs.Extension.Typechecked
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.BindContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.HsBind (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located (Language.Haskell.Syntax.Binds.PatSynBind (GHC.Hs.Extension.GhcPass p) (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Binds.HsPatSynDir (GHC.Hs.Extension.GhcPass p))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.HsMatchContext (GHC.Hs.Extension.GhcPass p))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.HsStmtContext (GHC.Hs.Extension.GhcPass p))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.PScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Pat.Pat (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsExpr (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.HsTupArg (GHC.Hs.Extension.GhcPass p))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (Language.Haskell.Syntax.Binds.HsLocalBinds (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.IPBind (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (Language.Haskell.Syntax.Binds.HsValBindsLR (GHC.Hs.Extension.GhcPass p) (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Hs.Binds.NHsValBindsLR (GHC.Hs.Extension.GhcPass p)))
instance (GHC.Iface.Ext.Ast.ToHie arg, GHC.Iface.Ext.Ast.HasLoc arg, Data.Data.Data arg, GHC.Iface.Ext.Ast.HiePass p) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RContext (Language.Haskell.Syntax.Pat.HsRecFields (GHC.Hs.Extension.GhcPass p) arg))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RFContext (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Type.FieldOcc (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RFContext (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Type.AmbiguousFieldOcc (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (Language.Haskell.Syntax.Expr.ApplicativeArg (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Expr.HsCmdTop (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsCmd (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.SigContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.Sig (GHC.Hs.Extension.GhcPass p))))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Expr.HsUntypedSplice (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (Language.Haskell.Syntax.Type.FieldOcc (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.HiePass p => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.PatSynFieldContext (Language.Haskell.Syntax.Binds.RecordPatSynField (GHC.Hs.Extension.GhcPass p)))
instance GHC.Iface.Ext.Ast.ToHie GHC.Base.Void
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie [a]
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (GHC.Base.NonEmpty a)
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.DataDefnCons a)
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (GHC.Data.Bag.Bag a)
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (GHC.Maybe.Maybe a)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Parser.Annotation.LocatedA Language.Haskell.Syntax.Module.Name.ModuleName))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located a)) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Parser.Annotation.LocatedN a))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located a)) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Parser.Annotation.LocatedA a))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located GHC.Types.Var.Var))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located GHC.Types.Name.Name))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.EvBindContext (GHC.Parser.Annotation.LocatedA GHC.Tc.Types.Evidence.TcEvBinds))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA GHC.Tc.Types.Evidence.HsWrapper)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.Context (GHC.Types.SrcLoc.Located Language.Haskell.Syntax.Extension.NoExtField))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.HsPatSigType GHC.Hs.Extension.GhcRn))
instance (GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RFContext label), GHC.Iface.Ext.Ast.ToHie arg, GHC.Iface.Ext.Ast.HasLoc arg, Data.Data.Data arg, Data.Data.Data label) => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Pat.HsFieldBind label arg)))
instance (GHC.Iface.Ext.Ast.ToHie tyarg, GHC.Iface.Ext.Ast.ToHie arg, GHC.Iface.Ext.Ast.ToHie rec) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Type.HsConDetails tyarg arg rec)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.HsConDeclGADTDetails GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.TyClGroup GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.TyClDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.FamilyDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.FamilyInfo GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.FamilyResultSig GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.FunDep GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn))))
instance (GHC.Iface.Ext.Ast.ToHie rhs, GHC.Iface.Ext.Ast.HasLoc rhs) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.FamEqn GHC.Hs.Extension.GhcRn rhs)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.InjectivityAnn GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Types.SrcLoc.Located [GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcRn)])
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.HsDerivingClause GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedC (Language.Haskell.Syntax.Decls.DerivClauseTys GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.DerivStrategy GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedP GHC.Types.Basic.OverlapMode)
instance GHC.Iface.Ext.Ast.ToHie a => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Type.HsScaled GHC.Hs.Extension.GhcRn a)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ConDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedL [GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcRn)])
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcRn))))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.HsWildCardBndrs GHC.Hs.Extension.GhcRn (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn))))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.StandaloneKindSig GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsSigType GHC.Hs.Extension.GhcRn)))
instance Data.Data.Data flag => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TVScoped (Language.Haskell.Syntax.Type.HsOuterTyVarBndrs flag GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn))
instance (GHC.Iface.Ext.Ast.ToHie tm, GHC.Iface.Ext.Ast.ToHie ty) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Type.HsArg tm ty)
instance Data.Data.Data flag => GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TVScoped (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsTyVarBndr flag GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.TScoped (Language.Haskell.Syntax.Type.LHsQTyVars GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedC [GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.HsType GHC.Hs.Extension.GhcRn)])
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Type.ConDeclField GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.LHsExpr a) => GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.ArithSeqInfo a)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.SpliceDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Expr.HsQuote GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie GHC.Hs.Expr.PendingRnSplice
instance GHC.Iface.Ext.Ast.ToHie GHC.Hs.Expr.PendingTcSplice
instance GHC.Iface.Ext.Ast.ToHie (GHC.Data.BooleanFormula.LBooleanFormula (GHC.Parser.Annotation.LocatedN GHC.Types.Name.Name))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns Language.Haskell.Syntax.Type.HsIPName)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.RoleAnnotDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.InstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ClsInstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DataFamInstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.TyFamInstDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DerivDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Binds.FixitySig GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DefaultDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.ForeignDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.ForeignImport GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.ForeignExport GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.WarnDecls GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.WarnDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.AnnDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (Language.Haskell.Syntax.Decls.AnnProvenance GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.RuleDecls GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.RuleDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.RScoped (GHC.Parser.Annotation.LocatedAn GHC.Parser.Annotation.NoEpAnns (Language.Haskell.Syntax.Decls.RuleBndr GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.ImpExp.ImportDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.ImpExp.IE GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.ImpExp.IEWrappedName GHC.Hs.Extension.GhcRn)))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Iface.Ext.Ast.IEContext (GHC.Types.SrcLoc.Located GHC.Types.FieldLabel.FieldLabel))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Parser.Annotation.LocatedA (Language.Haskell.Syntax.Decls.DocDecl GHC.Hs.Extension.GhcRn))
instance GHC.Iface.Ext.Ast.ToHie (GHC.Hs.Doc.LHsDoc GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.HasLoc thing => GHC.Iface.Ext.Ast.HasLoc (GHC.Iface.Ext.Ast.PScoped thing)
instance GHC.Iface.Ext.Ast.HasLoc (GHC.Types.SrcLoc.Located a)
instance GHC.Iface.Ext.Ast.HasLoc (GHC.Parser.Annotation.LocatedA a)
instance GHC.Iface.Ext.Ast.HasLoc (GHC.Parser.Annotation.LocatedN a)
instance GHC.Iface.Ext.Ast.HasLoc a => GHC.Iface.Ext.Ast.HasLoc [a]
instance GHC.Iface.Ext.Ast.HasLoc a => GHC.Iface.Ext.Ast.HasLoc (Language.Haskell.Syntax.Decls.DataDefnCons a)
instance (GHC.Iface.Ext.Ast.HasLoc tm, GHC.Iface.Ext.Ast.HasLoc ty) => GHC.Iface.Ext.Ast.HasLoc (Language.Haskell.Syntax.Type.HsArg tm ty)
instance GHC.Iface.Ext.Ast.HasLoc (Language.Haskell.Syntax.Decls.HsDataDefn GHC.Hs.Extension.GhcRn)
instance GHC.Iface.Ext.Ast.ModifyState GHC.Types.Name.Name
instance GHC.Iface.Ext.Ast.ModifyState GHC.Types.Var.Id

module GHC.Driver.Config.Stg.Pipeline

-- | Initialize STG pretty-printing options from DynFlags
initStgPipelineOpts :: DynFlags -> Bool -> StgPipelineOpts


-- | Main API for compiling plain Haskell source code.
--   
--   This module implements compilation of a Haskell source. It is
--   <i>not</i> concerned with preprocessing of source files; this is
--   handled in <a>GHC.Driver.Pipeline</a>
--   
--   There are various entry points depending on what mode we're in:
--   "batch" mode (<tt>--make</tt>), "one-shot" mode (<tt>-c</tt>,
--   <tt>-S</tt> etc.), and "interactive" mode (GHCi). There are also entry
--   points for individual passes: parsing, typechecking/renaming,
--   desugaring, and simplification.
--   
--   All the functions here take an <a>HscEnv</a> as a parameter, but none
--   of them return a new one: <a>HscEnv</a> is treated as an immutable
--   value from here on in (although it has mutable components, for the
--   caches).
--   
--   We use the Hsc monad to deal with warning messages consistently:
--   specifically, while executing within an Hsc monad, warnings are
--   collected. When a Hsc monad returns to an IO monad, the warnings are
--   printed, or compilation aborts if the <tt>-Werror</tt> flag is
--   enabled.
--   
--   (c) The GRASP/AQUA Project, Glasgow University, 1993-2000
module GHC.Driver.Main
newHscEnv :: FilePath -> DynFlags -> IO HscEnv
newHscEnvWithHUG :: FilePath -> DynFlags -> UnitId -> HomeUnitGraph -> IO HscEnv

-- | Initialize HscEnv from an optional top_dir path
initHscEnv :: Maybe FilePath -> IO HscEnv
type Messager = HscEnv -> (Int, Int) -> RecompileRequired -> ModuleGraphNode -> IO ()
batchMsg :: Messager
batchMultiMsg :: Messager

-- | Action to perform in backend compilation
data HscBackendAction

-- | Update the boot and signature file results.
HscUpdate :: ModIface -> HscBackendAction

-- | Recompile this module.
HscRecomp :: CgGuts -> !ModLocation -> !PartialModIface -> !Maybe Fingerprint -> HscBackendAction

-- | Information for the code generator.
[hscs_guts] :: HscBackendAction -> CgGuts

-- | Module info
[hscs_mod_location] :: HscBackendAction -> !ModLocation

-- | Partial interface
[hscs_partial_iface] :: HscBackendAction -> !PartialModIface

-- | Old interface hash for this compilation, if an old interface file
--   exists. Pass to <tt>hscMaybeWriteIface</tt> when writing the interface
--   to avoid updating the existing interface when the interface isn't
--   changed.
[hscs_old_iface_hash] :: HscBackendAction -> !Maybe Fingerprint

-- | Status of a module in incremental compilation
data HscRecompStatus

-- | Nothing to do because code already exists.
HscUpToDate :: ModIface -> HomeModLinkable -> HscRecompStatus

-- | Recompilation of module, or update of interface is required.
--   Optionally pass the old interface hash to avoid updating the existing
--   interface when it has not changed.
HscRecompNeeded :: Maybe Fingerprint -> HscRecompStatus
initModDetails :: HscEnv -> ModIface -> IO ModDetails
initWholeCoreBindings :: HscEnv -> ModIface -> ModDetails -> Linkable -> IO Linkable

-- | Write interface files
hscMaybeWriteIface :: Logger -> DynFlags -> Bool -> ModIface -> Maybe Fingerprint -> ModLocation -> IO ()
hscCompileCmmFile :: HscEnv -> FilePath -> FilePath -> FilePath -> IO (Maybe FilePath)

-- | Compile to hard-code.
hscGenHardCode :: HscEnv -> CgGuts -> ModLocation -> FilePath -> IO (FilePath, Maybe FilePath, [(ForeignSrcLang, FilePath)], Maybe StgCgInfos, Maybe CmmCgInfos)
hscInteractive :: HscEnv -> CgInteractiveGuts -> ModLocation -> IO (Maybe FilePath, CompiledByteCode, [SptEntry])
mkCgInteractiveGuts :: CgGuts -> CgInteractiveGuts
data CgInteractiveGuts
generateByteCode :: HscEnv -> CgInteractiveGuts -> ModLocation -> IO [Unlinked]
generateFreshByteCode :: HscEnv -> ModuleName -> CgInteractiveGuts -> ModLocation -> IO Linkable

-- | Do the recompilation avoidance checks for both one-shot and --make
--   modes This function is the *only* place in the compiler where we
--   decide whether to recompile a module or not!
hscRecompStatus :: Maybe Messager -> HscEnv -> ModSummary -> Maybe ModIface -> HomeModLinkable -> (Int, Int) -> IO HscRecompStatus

-- | parse a file, returning the abstract syntax
hscParse :: HscEnv -> ModSummary -> IO HsParsedModule

-- | Rename and typecheck a module, additionally returning the renamed
--   syntax
hscTypecheckRename :: HscEnv -> ModSummary -> HsParsedModule -> IO (TcGblEnv, RenamedStuff)

-- | Do Typechecking without throwing SourceError exception with -Werror
hscTypecheckAndGetWarnings :: HscEnv -> ModSummary -> IO (FrontendResult, WarningMessages)

-- | Convert a typechecked module to Core
hscDesugar :: HscEnv -> ModSummary -> TcGblEnv -> IO ModGuts

-- | Make a <a>ModDetails</a> from the results of typechecking. Used when
--   typechecking only, as opposed to full compilation.
makeSimpleDetails :: Logger -> TcGblEnv -> IO ModDetails

-- | Run Core2Core simplifier. The list of String is a list of (Core)
--   plugin module names added via TH (cf <tt>addCorePlugin</tt>).
hscSimplify :: HscEnv -> [String] -> ModGuts -> IO ModGuts
hscDesugarAndSimplify :: ModSummary -> FrontendResult -> Messages GhcMessage -> Maybe Fingerprint -> Hsc HscBackendAction

-- | Check that a module is safe to import.
--   
--   We return True to indicate the import is safe and False otherwise
--   although in the False case an exception may be thrown first.
hscCheckSafe :: HscEnv -> Module -> SrcSpan -> IO Bool

-- | Return if a module is trusted and the pkgs it depends on to be
--   trusted.
hscGetSafe :: HscEnv -> Module -> SrcSpan -> IO (Bool, Set UnitId)
hscParseIdentifier :: HscEnv -> String -> IO (LocatedN RdrName)
hscTcRcLookupName :: HscEnv -> Name -> IO (Maybe TyThing)
hscTcRnGetInfo :: HscEnv -> Name -> IO (Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))
hscIsGHCiMonad :: HscEnv -> String -> IO Name
hscGetModuleInterface :: HscEnv -> Module -> IO ModIface

-- | Rename some import declarations
hscRnImportDecls :: HscEnv -> [LImportDecl GhcPs] -> IO GlobalRdrEnv

-- | Lookup things in the compiler's environment
hscTcRnLookupRdrName :: HscEnv -> LocatedN RdrName -> IO (NonEmpty Name)

-- | Compile a stmt all the way to an HValue, but don't run it
--   
--   We return Nothing to indicate an empty statement (or comment only),
--   not a parse error.
hscStmt :: HscEnv -> String -> IO (Maybe ([Id], ForeignHValue, FixityEnv))
hscParseStmtWithLocation :: String -> Int -> String -> Hsc (Maybe (GhciLStmt GhcPs))

-- | Compile a stmt all the way to an HValue, but don't run it
--   
--   We return Nothing to indicate an empty statement (or comment only),
--   not a parse error.
hscStmtWithLocation :: HscEnv -> String -> String -> Int -> IO (Maybe ([Id], ForeignHValue, FixityEnv))
hscParsedStmt :: HscEnv -> GhciLStmt GhcPs -> IO (Maybe ([Id], ForeignHValue, FixityEnv))

-- | Compile a decls
hscDecls :: HscEnv -> String -> IO ([TyThing], InteractiveContext)
hscParseDeclsWithLocation :: HscEnv -> String -> Int -> String -> IO [LHsDecl GhcPs]

-- | Compile a decls
hscDeclsWithLocation :: HscEnv -> String -> String -> Int -> IO ([TyThing], InteractiveContext)
hscParsedDecls :: HscEnv -> [LHsDecl GhcPs] -> IO ([TyThing], InteractiveContext)
hscParseModuleWithLocation :: HscEnv -> String -> Int -> String -> IO (HsModule GhcPs)

-- | Typecheck an expression (but don't run it)
hscTcExpr :: HscEnv -> TcRnExprMode -> String -> IO Type

-- | How should we infer a type? See Note [TcRnExprMode]
data TcRnExprMode

-- | Instantiate inferred quantifiers only (:type)
TM_Inst :: TcRnExprMode

-- | Instantiate all quantifiers, and do eager defaulting (:type +d)
TM_Default :: TcRnExprMode
hscImport :: HscEnv -> String -> IO (ImportDecl GhcPs)

-- | Find the kind of a type, after generalisation
hscKcType :: HscEnv -> Bool -> String -> IO (Type, Kind)
hscParseExpr :: String -> Hsc (LHsExpr GhcPs)
hscParseType :: String -> Hsc (LHsType GhcPs)
hscCompileCoreExpr :: HscEnv -> SrcSpan -> CoreExpr -> IO (ForeignHValue, [Linkable], PkgsLoaded)
hscTidy :: HscEnv -> ModGuts -> IO (CgGuts, ModDetails)
hscCompileCoreExpr' :: HscEnv -> SrcSpan -> CoreExpr -> IO (ForeignHValue, [Linkable], PkgsLoaded)
hscParse' :: ModSummary -> Hsc HsParsedModule

-- | Run Core2Core simplifier. The list of String is a list of (Core)
--   plugin module names added via TH (cf <tt>addCorePlugin</tt>).
hscSimplify' :: [String] -> ModGuts -> Hsc ModGuts
hscDesugar' :: ModLocation -> TcGblEnv -> Hsc ModGuts
tcRnModule' :: ModSummary -> Bool -> HsParsedModule -> Hsc TcGblEnv
doCodeGen :: HscEnv -> Module -> InfoTableProvMap -> [TyCon] -> CollectedCCs -> [CgStgTopBinding] -> HpcInfo -> IO (Stream IO CmmGroupSRTs CmmCgInfos)
getHscEnv :: Hsc HscEnv
hscSimpleIface' :: Maybe CoreProgram -> TcGblEnv -> ModSummary -> Hsc (ModIface, ModDetails)
oneShotMsg :: Logger -> RecompileRequired -> IO ()
dumpIfaceStats :: HscEnv -> IO ()

-- | Deal with errors and warnings returned by a compilation step
--   
--   In order to reduce dependencies to other parts of the compiler,
--   functions outside the "main" parts of GHC return warnings and errors
--   as a parameter and signal success via by wrapping the result in a
--   <a>Maybe</a> type. This function logs the returned warnings and
--   propagates errors as exceptions (of type <a>SourceError</a>).
--   
--   This function assumes the following invariants:
--   
--   <ol>
--   <li>If the second result indicates success (is of the form 'Just x'),
--   there must be no error messages in the first result.</li>
--   <li>If there are no error messages, but the second result indicates
--   failure there should be warnings in the first result. That is, if the
--   action failed, it must have been due to the warnings (i.e.,
--   <tt>-Werror</tt>).</li>
--   </ol>
ioMsgMaybe :: IO (Messages GhcMessage, Maybe a) -> Hsc a
showModuleIndex :: (Int, Int) -> SDoc

-- | Load the given static-pointer table entries into the interpreter. See
--   Note [Grand plan for static forms] in
--   <a>GHC.Iface.Tidy.StaticPtrTable</a>.
hscAddSptEntries :: HscEnv -> [SptEntry] -> IO ()
writeInterfaceOnlyMode :: DynFlags -> Bool


-- | Template Haskell splices
module GHC.Tc.Gen.Splice
tcTypedSplice :: Name -> LHsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)
tcTypedBracket :: HsExpr GhcRn -> LHsExpr GhcRn -> ExpRhoType -> TcM (HsExpr GhcTc)
tcUntypedBracket :: HsExpr GhcRn -> HsQuote GhcRn -> [PendingRnSplice] -> ExpRhoType -> TcM (HsExpr GhcTc)
runAnnotation :: CoreAnnTarget -> LHsExpr GhcRn -> TcM Annotation
runMetaE :: LHsExpr GhcTc -> TcM (LHsExpr GhcPs)
runMetaP :: LHsExpr GhcTc -> TcM (LPat GhcPs)
runMetaT :: LHsExpr GhcTc -> TcM (LHsType GhcPs)
runMetaD :: LHsExpr GhcTc -> TcM [LHsDecl GhcPs]
runQuasi :: Q a -> TcM a
tcTopSpliceExpr :: SpliceType -> TcM (LHsExpr GhcTc) -> TcM (LHsExpr GhcTc)
lookupThName_maybe :: Name -> TcM (Maybe Name)
defaultRunMeta :: MetaHook TcM
runMeta' :: Bool -> (hs_syn -> SDoc) -> (SrcSpan -> ForeignHValue -> TcM (Either RunSpliceFailReason hs_syn)) -> LHsExpr GhcTc -> TcM hs_syn
runRemoteModFinalizers :: ThModFinalizers -> TcM ()

-- | Releases the external interpreter state.
finishTH :: TcM ()
runTopSplice :: DelayedSplice -> TcM (HsExpr GhcTc)
instance GHC.Tc.Gen.Splice.ReifyFlag () ()
instance GHC.Tc.Gen.Splice.ReifyFlag GHC.Types.Var.Specificity Language.Haskell.TH.Syntax.Specificity
instance Language.Haskell.TH.Syntax.Quasi GHC.Tc.Types.TcM

module GHC.Runtime.Eval
data Resume
Resume :: String -> ForeignRef (ResumeContext [HValueRef]) -> ResumeBindings -> [Id] -> ForeignHValue -> Maybe BreakInfo -> SrcSpan -> String -> RemotePtr CostCentreStack -> [History] -> Int -> Resume
[resumeStmt] :: Resume -> String
[resumeContext] :: Resume -> ForeignRef (ResumeContext [HValueRef])
[resumeBindings] :: Resume -> ResumeBindings
[resumeFinalIds] :: Resume -> [Id]
[resumeApStack] :: Resume -> ForeignHValue
[resumeBreakInfo] :: Resume -> Maybe BreakInfo
[resumeSpan] :: Resume -> SrcSpan
[resumeDecl] :: Resume -> String
[resumeCCS] :: Resume -> RemotePtr CostCentreStack
[resumeHistory] :: Resume -> [History]
[resumeHistoryIx] :: Resume -> Int
data History
History :: ForeignHValue -> BreakInfo -> [String] -> History
[historyApStack] :: History -> ForeignHValue
[historyBreakInfo] :: History -> BreakInfo
[historyEnclosingDecls] :: History -> [String]

-- | Run a statement in the current interactive context.
execStmt :: GhcMonad m => String -> ExecOptions -> m ExecResult

-- | Like <a>execStmt</a>, but takes a parsed statement as argument. Useful
--   when doing preprocessing on the AST before execution, e.g. in GHCi
--   (see GHCi.UI.runStmt).
execStmt' :: GhcMonad m => GhciLStmt GhcPs -> String -> ExecOptions -> m ExecResult
data ExecOptions
ExecOptions :: SingleStep -> String -> Int -> (ForeignHValue -> EvalExpr ForeignHValue) -> ExecOptions

-- | stepping mode
[execSingleStep] :: ExecOptions -> SingleStep

-- | filename (for errors)
[execSourceFile] :: ExecOptions -> String

-- | line number (for errors)
[execLineNumber] :: ExecOptions -> Int
[execWrap] :: ExecOptions -> ForeignHValue -> EvalExpr ForeignHValue

-- | default ExecOptions
execOptions :: ExecOptions
data ExecResult
ExecComplete :: Either SomeException [Name] -> Word64 -> ExecResult
[execResult] :: ExecResult -> Either SomeException [Name]
[execAllocation] :: ExecResult -> Word64
ExecBreak :: [Name] -> Maybe BreakInfo -> ExecResult
[breakNames] :: ExecResult -> [Name]
[breakInfo] :: ExecResult -> Maybe BreakInfo
resumeExec :: GhcMonad m => (SrcSpan -> Bool) -> SingleStep -> Maybe Int -> m ExecResult
runDecls :: GhcMonad m => String -> m [Name]

-- | Run some declarations and return any user-visible names that were
--   brought into scope.
runDeclsWithLocation :: GhcMonad m => String -> Int -> String -> m [Name]

-- | Like <a>runDeclsWithLocation</a>, but takes parsed declarations as
--   argument. Useful when doing preprocessing on the AST before execution,
--   e.g. in GHCi (see GHCi.UI.runStmt).
runParsedDecls :: GhcMonad m => [LHsDecl GhcPs] -> m [Name]
parseImportDecl :: GhcMonad m => String -> m (ImportDecl GhcPs)
data SingleStep
RunToCompletion :: SingleStep
SingleStep :: SingleStep
RunAndLogSteps :: SingleStep
abandon :: GhcMonad m => m Bool
abandonAll :: GhcMonad m => m Bool
getResumeContext :: GhcMonad m => m [Resume]
getHistorySpan :: HscEnv -> History -> SrcSpan
getModBreaks :: HomeModInfo -> ModBreaks
getHistoryModule :: History -> Module
setupBreakpoint :: GhcMonad m => HscEnv -> BreakInfo -> Int -> m ()
back :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)
forward :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)

-- | Set the interactive evaluation context.
--   
--   (setContext imports) sets the ic_imports field (which in turn
--   determines what is in scope at the prompt) to <tt>imports</tt>, and
--   updates the icReaderEnv environment to reflect it.
--   
--   We retain in scope all the things defined at the prompt, and kept in
--   ic_tythings. (Indeed, they shadow stuff from ic_imports.)
setContext :: GhcMonad m => [InteractiveImport] -> m ()

-- | Get the interactive evaluation context, consisting of a pair of the
--   set of modules from which we take the full top-level scope, and the
--   set of modules from which we take just the exports respectively.
getContext :: GhcMonad m => m [InteractiveImport]

-- | Returns all names in scope in the current interactive context
getNamesInScope :: GhcMonad m => m [Name]

-- | Returns all <a>RdrName</a>s in scope in the current interactive
--   context, excluding any that are internally-generated.
getRdrNamesInScope :: GhcMonad m => m [RdrName]

-- | Returns <tt>True</tt> if the specified module is interpreted, and
--   hence has its full top-level scope available.
moduleIsInterpreted :: GhcMonad m => Module -> m Bool

-- | Looks up an identifier in the current interactive context (for :info)
--   Filter the instances by the ones whose tycons (or classes resp) are in
--   scope (qualified or otherwise). Otherwise we list a whole lot too
--   many! The exact choice of which ones to show, and which to hide, is a
--   judgement call. (see #1581)
getInfo :: GhcMonad m => Bool -> Name -> m (Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))

-- | Get the type of an expression Returns the type as described by
--   <a>TcRnExprMode</a>
exprType :: GhcMonad m => TcRnExprMode -> String -> m Type

-- | Get the kind of a type
typeKind :: GhcMonad m => Bool -> String -> m (Type, Kind)

-- | Parses a string as an identifier, and returns the list of <a>Name</a>s
--   that the identifier can refer to in the current interactive context.
parseName :: GhcMonad m => String -> m (NonEmpty Name)
parseInstanceHead :: GhcMonad m => String -> m Type
getInstancesForType :: GhcMonad m => Type -> m [ClsInst]
getDocs :: GhcMonad m => Name -> m (Either GetDocsFailure (Maybe [HsDoc GhcRn], IntMap (HsDoc GhcRn)))

-- | Failure modes for <a>getDocs</a>.
data GetDocsFailure

-- | <a>nameModule_maybe</a> returned <a>Nothing</a>.
NameHasNoModule :: Name -> GetDocsFailure

-- | The module was loaded without <tt>-haddock</tt>,
NoDocsInIface :: Module -> Bool -> GetDocsFailure

-- | The <a>Name</a> was defined interactively.
InteractiveName :: GetDocsFailure
showModule :: GhcMonad m => ModSummary -> m String
moduleIsBootOrNotObjectLinkable :: GhcMonad m => ModSummary -> m Bool

-- | Parse an expression, the parsed expression can be further processed
--   and passed to compileParsedExpr.
parseExpr :: GhcMonad m => String -> m (LHsExpr GhcPs)
compileParsedExpr :: GhcMonad m => LHsExpr GhcPs -> m HValue

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExpr :: GhcMonad m => String -> m HValue

-- | Compile an expression, run it and return the result as a Dynamic.
dynCompileExpr :: GhcMonad m => String -> m Dynamic

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExprRemote :: GhcMonad m => String -> m ForeignHValue

-- | Compile a parsed expression (before renaming), run it, and deliver the
--   resulting HValue.
compileParsedExprRemote :: GhcMonad m => LHsExpr GhcPs -> m ForeignHValue
data Term
Term :: RttiType -> Either String DataCon -> ForeignHValue -> [Term] -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[val] :: Term -> ForeignHValue
[subTerms] :: Term -> [Term]
Prim :: RttiType -> [Word] -> Term
[ty] :: Term -> RttiType
[valRaw] :: Term -> [Word]
Suspension :: ClosureType -> RttiType -> ForeignHValue -> Maybe Name -> Term
[ctype] :: Term -> ClosureType
[ty] :: Term -> RttiType
[val] :: Term -> ForeignHValue
[bound_to] :: Term -> Maybe Name
NewtypeWrap :: RttiType -> Either String DataCon -> Term -> Term
[ty] :: Term -> RttiType
[dc] :: Term -> Either String DataCon
[wrapped_term] :: Term -> Term
RefWrap :: RttiType -> Term -> Term
[ty] :: Term -> RttiType
[wrapped_term] :: Term -> Term
obtainTermFromId :: HscEnv -> Int -> Bool -> Id -> IO Term
obtainTermFromVal :: HscEnv -> Int -> Bool -> Type -> a -> IO Term
reconstructType :: HscEnv -> Int -> Id -> IO (Maybe Type)
instance GHC.Utils.Outputable.Outputable GHC.Runtime.Eval.GetDocsFailure

module GHC.Driver.Pipeline.Execute
newtype HookedUse a
HookedUse :: ((Hooks, PhaseHook) -> IO a) -> HookedUse a
[runHookedUse] :: HookedUse a -> (Hooks, PhaseHook) -> IO a

-- | The default mechanism to run a pipeline, see Note [The Pipeline Monad]
runPipeline :: Hooks -> HookedUse a -> IO a

-- | Default interpretation of each phase, in terms of IO.
runPhase :: TPhase out -> IO out
runLlvmManglePhase :: PipeEnv -> HscEnv -> FilePath -> IO [Char]
runMergeForeign :: PipeEnv -> HscEnv -> FilePath -> [FilePath] -> IO FilePath
runLlvmLlcPhase :: PipeEnv -> HscEnv -> FilePath -> IO FilePath
runLlvmOptPhase :: PipeEnv -> HscEnv -> FilePath -> IO FilePath
runAsPhase :: Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> IO FilePath

-- | Run the JS Backend postHsc phase.
runJsPhase :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> IO FilePath

-- | Deal with foreign JS files (embed them into .o files)
runForeignJsPhase :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> IO FilePath
applyAssemblerInfoGetter :: DefunctionalizedAssemblerInfoGetter -> Logger -> DynFlags -> Platform -> IO CompilerInfo
applyAssemblerProg :: DefunctionalizedAssemblerProg -> Logger -> DynFlags -> Platform -> [Option] -> IO ()
runCcPhase :: Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> IO FilePath
runHscBackendPhase :: PipeEnv -> HscEnv -> ModuleName -> HscSource -> ModLocation -> HscBackendAction -> IO ([FilePath], ModIface, HomeModLinkable, FilePath)
runUnlitPhase :: HscEnv -> FilePath -> FilePath -> IO FilePath
getFileArgs :: HscEnv -> FilePath -> IO (DynFlags, Messages PsMessage, [Warn])
runCppPhase :: HscEnv -> FilePath -> FilePath -> IO FilePath
runHscPhase :: PipeEnv -> HscEnv -> FilePath -> HscSource -> IO (HscEnv, ModSummary, HscRecompStatus)

-- | Calculate the ModLocation from the provided DynFlags. This function is
--   only used in one-shot mode and therefore takes into account the effect
--   of -o/-ohi flags (which do nothing in --make mode)
mkOneShotModLocation :: PipeEnv -> DynFlags -> HscSource -> ModuleName -> IO ModLocation
runHscTcPhase :: HscEnv -> ModSummary -> IO (FrontendResult, Messages GhcMessage)
runHscPostTcPhase :: HscEnv -> ModSummary -> FrontendResult -> Messages GhcMessage -> Maybe Fingerprint -> IO HscBackendAction
runHsPpPhase :: HscEnv -> FilePath -> FilePath -> FilePath -> IO FilePath
phaseOutputFilenameNew :: Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> IO FilePath

-- | Computes the next output filename for something in the compilation
--   pipeline. This is controlled by several variables:
--   
--   <ol>
--   <li><a>Phase</a>: the last phase to be run (e.g. <tt>stopPhase</tt>).
--   This is used to tell if we're in the last phase or not, because in
--   that case flags like <tt>-o</tt> may be important.</li>
--   <li><a>PipelineOutput</a>: is this intended to be a <a>Temporary</a>
--   or <a>Persistent</a> build output? Temporary files just go in a fresh
--   temporary name.</li>
--   <li><a>String</a>: what was the basename of the original input
--   file?</li>
--   <li><a>DynFlags</a>: the obvious thing</li>
--   <li><a>Phase</a>: the phase we want to determine the output filename
--   of.</li>
--   <li><tt>Maybe ModLocation</tt>: the <a>ModLocation</a> of the module
--   we're compiling; this can be used to override the default output of an
--   object file. (TODO: do we actually need this?)</li>
--   </ol>
getOutputFilename :: Logger -> TmpFs -> Phase -> PipelineOutput -> String -> DynFlags -> Phase -> Maybe ModLocation -> IO FilePath

-- | LLVM Options. These are flags to be passed to opt and llc, to ensure
--   consistency we list them in pairs, so that they form groups.
llvmOptions :: LlvmConfig -> DynFlags -> [(String, String)]

-- | What phase to run after one of the backend code generators has run
hscPostBackendPhase :: HscSource -> Backend -> Phase
compileStub :: HscEnv -> FilePath -> IO FilePath

-- | See Note [Object merging].
joinObjectFiles :: HscEnv -> [FilePath] -> FilePath -> IO ()
getHCFilePackages :: FilePath -> IO [UnitId]
linkDynLibCheck :: Logger -> TmpFs -> DynFlags -> UnitEnv -> [String] -> [UnitId] -> IO ()
touchObjectFile :: Logger -> DynFlags -> FilePath -> IO ()
instance Control.Monad.Catch.MonadCatch GHC.Driver.Pipeline.Execute.HookedUse
instance Control.Monad.Catch.MonadThrow GHC.Driver.Pipeline.Execute.HookedUse
instance Control.Monad.IO.Class.MonadIO GHC.Driver.Pipeline.Execute.HookedUse
instance GHC.Base.Monad GHC.Driver.Pipeline.Execute.HookedUse
instance GHC.Base.Applicative GHC.Driver.Pipeline.Execute.HookedUse
instance GHC.Base.Functor GHC.Driver.Pipeline.Execute.HookedUse
instance GHC.Driver.Pipeline.Monad.MonadUse GHC.Driver.Pipeline.Phases.TPhase GHC.Driver.Pipeline.Execute.HookedUse

module GHC.Driver.Pipeline
oneShot :: HscEnv -> StopPhase -> [(String, Maybe Phase)] -> IO ()
compileFile :: HscEnv -> StopPhase -> (FilePath, Maybe Phase) -> IO (Maybe FilePath)

-- | Just preprocess a file, put the result in a temp. file (used by the
--   compilation manager during the summary phase).
--   
--   We return the augmented DynFlags, because they contain the result of
--   slurping in the OPTIONS pragmas
preprocess :: HscEnv -> FilePath -> Maybe InputFileBuffer -> Maybe Phase -> IO (Either DriverMessages (DynFlags, FilePath))

-- | Compile
--   
--   Compile a single module, under the control of the compilation manager.
--   
--   This is the interface between the compilation manager and the compiler
--   proper (hsc), where we deal with tedious details like reading the
--   OPTIONS pragma from the source file, converting the C or assembly that
--   GHC produces into an object file, and compiling FFI stub files.
--   
--   NB. No old interface can also mean that the source has changed.
compileOne :: HscEnv -> ModSummary -> Int -> Int -> Maybe ModIface -> HomeModLinkable -> IO HomeModInfo
compileOne' :: Maybe Messager -> HscEnv -> ModSummary -> Int -> Int -> Maybe ModIface -> HomeModLinkable -> IO HomeModInfo
compileForeign :: HscEnv -> ForeignSrcLang -> FilePath -> IO FilePath
compileEmptyStub :: DynFlags -> HscEnv -> FilePath -> ModLocation -> ModuleName -> IO ()
link :: GhcLink -> Logger -> TmpFs -> Hooks -> DynFlags -> UnitEnv -> Bool -> Maybe (RecompileRequired -> IO ()) -> HomePackageTable -> IO SuccessFlag
linkingNeeded :: Logger -> DynFlags -> UnitEnv -> Bool -> [Linkable] -> [UnitId] -> IO RecompileRequired
checkLinkInfo :: Logger -> DynFlags -> UnitEnv -> [UnitId] -> FilePath -> IO Bool
data PipeEnv
PipeEnv :: StopPhase -> String -> String -> String -> Phase -> PipelineOutput -> PipeEnv

-- | Stop just after this phase
[stop_phase] :: PipeEnv -> StopPhase

-- | basename of original input source
[src_filename] :: PipeEnv -> String

-- | basename of original input source
[src_basename] :: PipeEnv -> String

-- | its extension
[src_suffix] :: PipeEnv -> String
[start_phase] :: PipeEnv -> Phase

-- | says where to put the pipeline output
[output_spec] :: PipeEnv -> PipelineOutput
mkPipeEnv :: StopPhase -> FilePath -> Maybe Phase -> PipelineOutput -> PipeEnv
phaseOutputFilenameNew :: Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> IO FilePath
data TPhase res
[T_Unlit] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_FileArgs] :: HscEnv -> FilePath -> TPhase (DynFlags, Messages PsMessage, [Warn])
[T_Cpp] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_HsPp] :: PipeEnv -> HscEnv -> FilePath -> FilePath -> TPhase FilePath
[T_HscRecomp] :: PipeEnv -> HscEnv -> FilePath -> HscSource -> TPhase (HscEnv, ModSummary, HscRecompStatus)
[T_Hsc] :: HscEnv -> ModSummary -> TPhase (FrontendResult, Messages GhcMessage)
[T_HscPostTc] :: HscEnv -> ModSummary -> FrontendResult -> Messages GhcMessage -> Maybe Fingerprint -> TPhase HscBackendAction
[T_HscBackend] :: PipeEnv -> HscEnv -> ModuleName -> HscSource -> ModLocation -> HscBackendAction -> TPhase ([FilePath], ModIface, HomeModLinkable, FilePath)
[T_CmmCpp] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_Cmm] :: PipeEnv -> HscEnv -> FilePath -> TPhase ([FilePath], FilePath)
[T_Cc] :: Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase FilePath
[T_As] :: Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase FilePath
[T_Js] :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase FilePath
[T_ForeignJs] :: PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> TPhase FilePath
[T_LlvmOpt] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_LlvmLlc] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_LlvmMangle] :: PipeEnv -> HscEnv -> FilePath -> TPhase FilePath
[T_MergeForeign] :: PipeEnv -> HscEnv -> FilePath -> [FilePath] -> TPhase FilePath

-- | Default interpretation of each phase, in terms of IO.
runPhase :: TPhase out -> IO out

-- | What phase to run after one of the backend code generators has run
hscPostBackendPhase :: HscSource -> Backend -> Phase
type TPipelineClass (f :: Type -> Type) (m :: Type -> Type) = (Functor m, MonadIO m, Applicative m, Monad m, MonadUse f m)

-- | Lift a <tt>f</tt> action into an <tt>m</tt> action.
class MonadUse f m
use :: MonadUse f m => f a -> m a

-- | The preprocessor pipeline
preprocessPipeline :: P m => PipeEnv -> HscEnv -> FilePath -> m (DynFlags, FilePath)

-- | The complete compilation pipeline, from start to finish
fullPipeline :: P m => PipeEnv -> HscEnv -> FilePath -> HscSource -> m (ModIface, HomeModLinkable)

-- | Everything after preprocess
hscPipeline :: P m => PipeEnv -> (HscEnv, ModSummary, HscRecompStatus) -> m (ModIface, HomeModLinkable)
hscBackendPipeline :: P m => PipeEnv -> HscEnv -> ModSummary -> HscBackendAction -> m (ModIface, HomeModLinkable)
hscPostBackendPipeline :: P m => PipeEnv -> HscEnv -> HscSource -> Backend -> Maybe ModLocation -> FilePath -> m (Maybe FilePath)
hscGenBackendPipeline :: P m => PipeEnv -> HscEnv -> ModSummary -> HscBackendAction -> m (ModIface, HomeModLinkable)
asPipeline :: P m => Bool -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m (Maybe ObjFile)
viaCPipeline :: P m => Phase -> PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m (Maybe FilePath)
cmmCppPipeline :: P m => PipeEnv -> HscEnv -> FilePath -> m (Maybe FilePath)
cmmPipeline :: P m => PipeEnv -> HscEnv -> FilePath -> m (Maybe FilePath)
jsPipeline :: P m => PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m FilePath
llvmPipeline :: P m => PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m (Maybe FilePath)
llvmLlcPipeline :: P m => PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m (Maybe FilePath)
llvmManglePipeline :: P m => PipeEnv -> HscEnv -> Maybe ModLocation -> FilePath -> m (Maybe FilePath)
pipelineStart :: P m => PipeEnv -> HscEnv -> FilePath -> Maybe Phase -> m (Maybe FilePath)

-- | The default mechanism to run a pipeline, see Note [The Pipeline Monad]
runPipeline :: Hooks -> HookedUse a -> IO a

module GHC.Driver.Make

-- | Perform a dependency analysis starting from the current targets and
--   update the session with the new module graph.
--   
--   Dependency analysis entails parsing the <tt>import</tt> directives and
--   may therefore require running certain preprocessors.
--   
--   Note that each <a>ModSummary</a> in the module graph caches its
--   <a>DynFlags</a>. These <a>DynFlags</a> are determined by the
--   <i>current</i> session <a>DynFlags</a> and the <tt>OPTIONS</tt> and
--   <tt>LANGUAGE</tt> pragmas of the parsed module. Thus if you want
--   changes to the <a>DynFlags</a> to take effect you need to call this
--   function again. In case of errors, just throw them.
depanal :: GhcMonad m => [ModuleName] -> Bool -> m ModuleGraph

-- | Perform dependency analysis like in <a>depanal</a>. In case of errors,
--   the errors and an empty module graph are returned.
depanalE :: GhcMonad m => [ModuleName] -> Bool -> m (DriverMessages, ModuleGraph)

-- | Perform dependency analysis like <a>depanal</a> but return a partial
--   module graph even in the face of problems with some modules.
--   
--   Modules which have parse errors in the module header, failing
--   preprocessors or other issues preventing them from being summarised
--   will simply be absent from the returned module graph.
--   
--   Unlike <a>depanal</a> this function will not update
--   <a>hsc_mod_graph</a> with the new module graph.
depanalPartial :: GhcMonad m => [ModuleName] -> Bool -> m (DriverMessages, ModuleGraph)

-- | This function checks then important property that if both p and q are
--   home units then any dependency of p, which transitively depends on q
--   is also a home unit.
--   
--   See Note [Multiple Home Units], section 'Closure Property'.
checkHomeUnitsClosed :: UnitEnv -> [DriverMessages]

-- | Try to load the program. See <a>LoadHowMuch</a> for the different
--   modes.
--   
--   This function implements the core of GHC's <tt>--make</tt> mode. It
--   preprocesses, compiles and loads the specified modules, avoiding
--   re-compilation wherever possible. Depending on the backend (see
--   <a>backend</a> field) compiling and loading may result in files being
--   created on disk.
--   
--   Calls the <a>defaultWarnErrLogger</a> after each compiling each
--   module, whether successful or not.
--   
--   If errors are encountered during dependency analysis, the module
--   <a>depanalE</a> returns together with the errors an empty ModuleGraph.
--   After processing this empty ModuleGraph, the errors of depanalE are
--   thrown. All other errors are reported using the
--   <a>defaultWarnErrLogger</a>.
load :: GhcMonad f => LoadHowMuch -> f SuccessFlag
loadWithCache :: GhcMonad m => Maybe ModIfaceCache -> LoadHowMuch -> m SuccessFlag

-- | Generalized version of <a>load</a> which also supports a custom
--   <a>Messager</a> (for reporting progress) and <a>ModuleGraph</a>
--   (generally produced by calling <a>depanal</a>.
load' :: GhcMonad m => Maybe ModIfaceCache -> LoadHowMuch -> Maybe Messager -> ModuleGraph -> m SuccessFlag

-- | Describes which modules of the module graph need to be loaded.
data LoadHowMuch

-- | Load all targets and its dependencies.
LoadAllTargets :: LoadHowMuch

-- | Load only the given module and its dependencies.
LoadUpTo :: HomeUnitModule -> LoadHowMuch

-- | Load only the dependencies of the given module, but not the module
--   itself.
LoadDependenciesOf :: HomeUnitModule -> LoadHowMuch
data ModIfaceCache
ModIfaceCache :: IO [CachedIface] -> (CachedIface -> IO ()) -> ModIfaceCache
[iface_clearCache] :: ModIfaceCache -> IO [CachedIface]
[iface_addToCache] :: ModIfaceCache -> CachedIface -> IO ()
noIfaceCache :: Maybe ModIfaceCache
newIfaceCache :: IO ModIfaceCache

-- | Collect the instantiations of dependencies to create
--   <a>InstantiationNode</a> work graph nodes. These are used to represent
--   the type checking that is done after all the free holes (sigs in
--   current package) relevant to that instantiation are compiled. This is
--   necessary to catch some instantiation errors.
--   
--   In the future, perhaps more of the work of instantiation could be
--   moved here, instead of shoved in with the module compilation nodes.
--   That could simplify backpack, and maybe hs-boot too.
instantiationNodes :: UnitId -> UnitState -> [ModuleGraphNode]

-- | Downsweep (dependency analysis)
--   
--   Chase downwards from the specified root set, returning summaries for
--   all home modules encountered. Only follow source-import links.
--   
--   We pass in the previous collection of summaries, which is used as a
--   cache to avoid recalculating a module summary if the source is
--   unchanged.
--   
--   The returned list of [ModSummary] nodes has one node for each
--   home-package module, plus one for any hs-boot files. The imports of
--   these nodes are all there, including the imports of non-home-package
--   modules.
downsweep :: HscEnv -> [ModSummary] -> [ModuleName] -> Bool -> IO ([DriverMessages], [ModuleGraphNode])

-- | Topological sort of the module graph
--   
--   Calculate SCCs of the module graph, possibly dropping the hi-boot
--   nodes The resulting list of strongly-connected-components is in
--   topologically sorted order, starting with the module(s) at the bottom
--   of the dependency graph (ie compile them first) and ending with the
--   ones at the top.
--   
--   Drop hi-boot nodes (first boolean arg)?
--   
--   <ul>
--   <li><tt>False</tt>: treat the hi-boot summaries as nodes of the graph,
--   so the graph must be acyclic</li>
--   <li><tt>True</tt>: eliminate the hi-boot nodes, and instead pretend
--   the a source-import of Foo is an import of Foo The resulting graph has
--   no hi-boot nodes, but can be cyclic</li>
--   </ul>
topSortModuleGraph :: Bool -> ModuleGraph -> Maybe HomeUnitModule -> [SCC ModuleGraphNode]

-- | Like <a>ms_home_imps</a>, but for SOURCE imports.
ms_home_srcimps :: ModSummary -> [Located ModuleName]

-- | All of the (possibly) home module imports from a <a>ModSummary</a>;
--   that is to say, each of these module names could be a home import if
--   an appropriately named file existed. (This is in contrast to package
--   qualified imports, which are guaranteed not to be home imports.)
ms_home_imps :: ModSummary -> [(PkgQual, Located ModuleName)]
summariseModule :: HscEnv -> HomeUnit -> Map (UnitId, FilePath) ModSummary -> IsBootInterface -> Located ModuleName -> PkgQual -> Maybe (StringBuffer, UTCTime) -> [ModuleName] -> IO SummariseResult
data SummariseResult
FoundInstantiation :: InstantiatedUnit -> SummariseResult
FoundHomeWithError :: (UnitId, DriverMessages) -> SummariseResult
FoundHome :: ModSummary -> SummariseResult
External :: UnitId -> SummariseResult
NotThere :: SummariseResult
summariseFile :: HscEnv -> HomeUnit -> Map (UnitId, FilePath) ModSummary -> FilePath -> Maybe Phase -> Maybe (StringBuffer, UTCTime) -> IO (Either DriverMessages ModSummary)

-- | Tests if an <a>HscSource</a> is a boot file, primarily for
--   constructing elements of <tt>BuildModule</tt>. We conflate signatures
--   and modules because they are bound in the same namespace; only boot
--   interfaces can be disambiguated with `import {-# SOURCE #-}`.
hscSourceToIsBoot :: HscSource -> IsBootInterface

-- | For a module <tt>modname</tt> of type <a>HscSource</a>, determine the
--   list of extra "imports" of other requirements which should be
--   considered part of the import of the requirement, because it
--   transitively depends on those requirements by imports of modules from
--   other packages. The situation is something like this:
--   
--   unit p where signature X signature Y import X
--   
--   unit q where dependency p[X=&lt;A&gt;,Y=&lt;B&gt;] signature A
--   signature B
--   
--   Although q's B does not directly import A, we still have to make sure
--   we process A first, because the merging process will cause B to
--   indirectly import A. This function finds the TRANSITIVE closure of all
--   such imports we need to make.
findExtraSigImports :: HscEnv -> HscSource -> ModuleName -> IO [ModuleName]

-- | Like <tt>implicitRequirements'</tt>, but returns either the module
--   name, if it is a free hole, or the instantiated unit the imported
--   module is from, so that that instantiated unit can be processed and
--   via the batch mod graph (rather than a transitive closure done here)
--   all the free holes are still reachable.
implicitRequirementsShallow :: HscEnv -> [(PkgQual, Located ModuleName)] -> IO ([ModuleName], [InstantiatedUnit])
noModError :: HscEnv -> SrcSpan -> ModuleName -> FindResult -> MsgEnvelope GhcMessage
cyclicModuleErr :: [ModuleGraphNode] -> SDoc
type SummaryNode = Node Int ModuleGraphNode

-- | Indicates whether a module name is referring to a boot interface
--   (hs-boot file) or regular module (hs file). We need to treat boot
--   modules specially when building compilation graphs, since they break
--   cycles. Regular source files and signature files are treated
--   equivalently.
data IsBootInterface
NotBoot :: IsBootInterface
IsBoot :: IsBootInterface
mkNodeKey :: ModuleGraphNode -> NodeKey
type ModNodeKey = ModuleNameWithIsBoot
data ModNodeKeyWithUid
ModNodeKeyWithUid :: !ModuleNameWithIsBoot -> !UnitId -> ModNodeKeyWithUid
[mnkModuleName] :: ModNodeKeyWithUid -> !ModuleNameWithIsBoot
[mnkUnitId] :: ModNodeKeyWithUid -> !UnitId
newtype ModNodeMap a
ModNodeMap :: Map ModNodeKey a -> ModNodeMap a
[unModNodeMap] :: ModNodeMap a -> Map ModNodeKey a
emptyModNodeMap :: ModNodeMap a
modNodeMapElems :: ModNodeMap a -> [a]
modNodeMapLookup :: ModNodeKey -> ModNodeMap a -> Maybe a
modNodeMapInsert :: ModNodeKey -> a -> ModNodeMap a -> ModNodeMap a
modNodeMapSingleton :: ModNodeKey -> a -> ModNodeMap a
modNodeMapUnionWith :: (a -> a -> a) -> ModNodeMap a -> ModNodeMap a -> ModNodeMap a
instance GHC.Show.Show GHC.Driver.Make.ResultLoopOrigin
instance GHC.Show.Show GHC.Driver.Make.ResultOrigin
instance Data.Foldable.Foldable GHC.Driver.Make.ModNodeMap
instance Data.Traversable.Traversable GHC.Driver.Make.ModNodeMap
instance GHC.Base.Functor GHC.Driver.Make.ModNodeMap
instance GHC.Classes.Ord GHC.Driver.Make.CodeGenEnable
instance GHC.Show.Show GHC.Driver.Make.CodeGenEnable
instance GHC.Classes.Eq GHC.Driver.Make.CodeGenEnable
instance GHC.Base.Functor GHC.Driver.Make.ResultVar
instance GHC.Utils.Outputable.Outputable GHC.Driver.Make.CodeGenEnable
instance GHC.Utils.Outputable.Outputable GHC.Driver.Make.BuildPlan
instance GHC.Utils.Outputable.Outputable GHC.Driver.Make.ModuleGraphNodeWithBootFile
instance GHC.Utils.Outputable.Outputable GHC.Driver.Make.CachedIface

module GHC

-- | Install some default exception handlers and run the inner computation.
--   Unless you want to handle exceptions yourself, you should wrap this
--   around the top level of your program. The default handlers output the
--   error message(s) to stderr and exit cleanly.
defaultErrorHandler :: ExceptionMonad m => FatalMessager -> FlushOut -> m a -> m a

-- | This function is no longer necessary, cleanup is now done by
--   runGhc/runGhcT.

-- | <i>Deprecated: Cleanup is now done by runGhc/runGhcT</i>
defaultCleanupHandler :: ExceptionMonad m => DynFlags -> m a -> m a
prettyPrintGhcErrors :: ExceptionMonad m => Logger -> m a -> m a

-- | Temporarily install standard signal handlers for catching ^C, which
--   just throw an exception in the current thread.
withSignalHandlers :: ExceptionMonad m => m a -> m a
withCleanupSession :: GhcMonad m => m a -> m a

-- | A minimal implementation of a <a>GhcMonad</a>. If you need a custom
--   monad, e.g., to maintain additional state consider wrapping this monad
--   or using <a>GhcT</a>.
data Ghc a

-- | A monad transformer to add GHC specific features to another monad.
--   
--   Note that the wrapped monad must support IO and handling of
--   exceptions.
data GhcT m a

-- | A monad that has all the features needed by GHC API calls.
--   
--   In short, a GHC monad
--   
--   <ul>
--   <li>allows embedding of IO actions,</li>
--   <li>can log warnings,</li>
--   <li>allows handling of (extensible) exceptions, and</li>
--   <li>maintains a current session.</li>
--   </ul>
--   
--   If you do not use <a>Ghc</a> or <a>GhcT</a>, make sure to call
--   <a>initGhcMonad</a> before any call to the GHC API functions can
--   occur.
class (Functor m, ExceptionMonad m, HasDynFlags m, HasLogger m) => GhcMonad m
getSession :: GhcMonad m => m HscEnv
setSession :: GhcMonad m => HscEnv -> m ()

-- | HscEnv is like <a>Session</a>, except that some of the fields are
--   immutable. An HscEnv is used to compile a single module from plain
--   Haskell source code (after preprocessing) to either C, assembly or
--   C--. It's also used to store the dynamic linker state to allow for
--   multiple linkers in the same address space. Things like the module
--   graph don't change during a single compilation.
--   
--   Historical note: "hsc" used to be the name of the compiler binary,
--   when there was a separate driver and compiler. To compile a single
--   module, the driver would invoke hsc on the source code... so nowadays
--   we think of hsc as the layer of the compiler that deals with compiling
--   a single module.
data HscEnv

-- | Run function for the <a>Ghc</a> monad.
--   
--   It initialises the GHC session and warnings via <a>initGhcMonad</a>.
--   Each call to this function will create a new session which should not
--   be shared among several threads.
--   
--   Any errors not handled inside the <a>Ghc</a> action are propagated as
--   IO exceptions.
runGhc :: Maybe FilePath -> Ghc a -> IO a

-- | Run function for <a>GhcT</a> monad transformer.
--   
--   It initialises the GHC session and warnings via <a>initGhcMonad</a>.
--   Each call to this function will create a new session which should not
--   be shared among several threads.
runGhcT :: ExceptionMonad m => Maybe FilePath -> GhcT m a -> m a

-- | Initialise a GHC session.
--   
--   If you implement a custom <a>GhcMonad</a> you must call this function
--   in the monad run function. It will initialise the session variable and
--   clear all warnings.
--   
--   The first argument should point to the directory where GHC's library
--   files reside. More precisely, this should be the output of <tt>ghc
--   --print-libdir</tt> of the version of GHC the module using this API is
--   compiled with. For portability, you should use the <tt>ghc-paths</tt>
--   package, available at
--   <a>http://hackage.haskell.org/package/ghc-paths</a>.
initGhcMonad :: GhcMonad m => Maybe FilePath -> m ()

-- | Print the all diagnostics in a <a>SourceError</a>. Useful inside
--   exception handlers.
printException :: (HasLogger m, MonadIO m, HasDynFlags m) => SourceError -> m ()

-- | Perform the given action and call the exception handler if the action
--   throws a <a>SourceError</a>. See <a>SourceError</a> for more
--   information.
handleSourceError :: MonadCatch m => (SourceError -> m a) -> m a -> m a

-- | Contains not only a collection of <a>GeneralFlag</a>s but also a
--   plethora of information relating to the compilation of a single file
--   or GHC session
data DynFlags
DynFlags :: GhcMode -> GhcLink -> !Backend -> {-# UNPACK #-} !GhcNameVersion -> {-# UNPACK #-} !FileSettings -> Platform -> {-# UNPACK #-} !ToolSettings -> {-# UNPACK #-} !PlatformMisc -> [(String, String)] -> TempDir -> Int -> Int -> Int -> Int -> Int -> Maybe String -> [Int] -> Maybe Int -> Bool -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Int -> Int -> Int -> !Int -> Maybe Int -> Maybe Int -> Int -> Maybe Word -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> Maybe Int -> Int -> [FilePath] -> ModuleName -> Maybe String -> IntWithInf -> IntWithInf -> UnitId -> Maybe UnitId -> [(ModuleName, Module)] -> Maybe FilePath -> Maybe String -> Set ModuleName -> Set ModuleName -> Ways -> Maybe (String, Int) -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> String -> String -> String -> String -> String -> String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> DynLibLoader -> !Bool -> FilePath -> Maybe FilePath -> [Option] -> IncludeSpecs -> [String] -> [String] -> [String] -> Maybe String -> RtsOptsEnabled -> Bool -> String -> [ModuleName] -> [(ModuleName, String)] -> [String] -> [ExternalPluginSpec] -> FilePath -> Bool -> Bool -> [ModuleName] -> [String] -> [PackageDBFlag] -> [IgnorePackageFlag] -> [PackageFlag] -> [PackageFlag] -> [TrustFlag] -> Maybe FilePath -> EnumSet DumpFlag -> EnumSet GeneralFlag -> EnumSet WarningFlag -> EnumSet WarningFlag -> Maybe Language -> SafeHaskellMode -> Bool -> Bool -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> [OnOff Extension] -> EnumSet Extension -> !UnfoldingOpts -> Int -> Int -> FlushOut -> Maybe FilePath -> Maybe String -> [String] -> Int -> Int -> Bool -> OverridingBool -> Bool -> Scheme -> ProfAuto -> [CallerCcFilter] -> Maybe String -> Maybe SseVersion -> Maybe BmiVersion -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> IORef (Maybe LinkerInfo) -> IORef (Maybe CompilerInfo) -> IORef (Maybe CompilerInfo) -> Int -> Int -> Int -> Bool -> Maybe Int -> Word64 -> Int -> Weights -> DynFlags
[ghcMode] :: DynFlags -> GhcMode
[ghcLink] :: DynFlags -> GhcLink

-- | The backend to use (if any).
--   
--   Whenever you change the backend, also make sure to set <a>ghcLink</a>
--   to something sensible.
--   
--   <tt>NoBackend</tt> can be used to avoid generating any output,
--   however, note that:
--   
--   <ul>
--   <li>If a program uses Template Haskell the typechecker may need to run
--   code from an imported module. To facilitate this, code generation is
--   enabled for modules imported by modules that use template haskell,
--   using the default backend for the platform. See Note [-fno-code
--   mode].</li>
--   </ul>
[backend] :: DynFlags -> !Backend
[ghcNameVersion] :: DynFlags -> {-# UNPACK #-} !GhcNameVersion
[fileSettings] :: DynFlags -> {-# UNPACK #-} !FileSettings
[targetPlatform] :: DynFlags -> Platform
[toolSettings] :: DynFlags -> {-# UNPACK #-} !ToolSettings
[platformMisc] :: DynFlags -> {-# UNPACK #-} !PlatformMisc
[rawSettings] :: DynFlags -> [(String, String)]
[tmpDir] :: DynFlags -> TempDir

-- | LLVM optimisation level
[llvmOptLevel] :: DynFlags -> Int

-- | Verbosity level: see Note [Verbosity levels]
[verbosity] :: DynFlags -> Int

-- | How much debug information to produce
[debugLevel] :: DynFlags -> Int

-- | Number of simplifier phases
[simplPhases] :: DynFlags -> Int

-- | Max simplifier iterations
[maxSimplIterations] :: DynFlags -> Int
[ruleCheck] :: DynFlags -> Maybe String

-- | Additional demand analysis
[strictnessBefore] :: DynFlags -> [Int]

-- | The number of modules to compile in parallel in --make mode, where
--   Nothing ==&gt; compile as many in parallel as there are CPUs.
[parMakeCount] :: DynFlags -> Maybe Int

-- | Enable RTS timing statistics?
[enableTimeStats] :: DynFlags -> Bool

-- | The heap size to set.
[ghcHeapSize] :: DynFlags -> Maybe Int

-- | Maximum number of bindings from the type envt to show in type error
--   messages
[maxRelevantBinds] :: DynFlags -> Maybe Int

-- | Maximum number of hole fits to show in typed hole error messages
[maxValidHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of refinement hole fits to show in typed hole error
--   messages
[maxRefHoleFits] :: DynFlags -> Maybe Int

-- | Maximum level of refinement for refinement hole fits in typed hole
--   error messages
[refLevelHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of unmatched patterns to show in non-exhaustiveness
--   warnings
[maxUncoveredPatterns] :: DynFlags -> Int

-- | Soft limit on the number of models the pattern match checker checks a
--   pattern against. A safe guard against exponential blow-up.
[maxPmCheckModels] :: DynFlags -> Int

-- | Multiplier for simplifier ticks
[simplTickFactor] :: DynFlags -> Int

-- | Whether DmdAnal should optimistically put an Unboxed demand on
--   returned products with at most this number of fields
[dmdUnboxWidth] :: DynFlags -> !Int

-- | Threshold for SpecConstr
[specConstrThreshold] :: DynFlags -> Maybe Int

-- | Max number of specialisations for any one function
[specConstrCount] :: DynFlags -> Maybe Int

-- | Max number of specialisations for recursive types Not optional;
--   otherwise ForceSpecConstr can diverge.
[specConstrRecursive] :: DynFlags -> Int

-- | Binary literals (e.g. strings) whose size is above this threshold will
--   be dumped in a binary file by the assembler code generator. 0 and
--   Nothing disables this feature. See <a>Config</a>.
[binBlobThreshold] :: DynFlags -> Maybe Word

-- | Threshold for LiberateCase
[liberateCaseThreshold] :: DynFlags -> Maybe Int

-- | Arg count for lambda floating See <a>FloatOutSwitches</a>
[floatLamArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a recursive function.
[liftLamsRecArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a non-recursive
--   function.
[liftLamsNonRecArgs] :: DynFlags -> Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[liftLamsKnown] :: DynFlags -> Bool

-- | Align Cmm functions at this boundary or use default.
[cmmProcAlignment] :: DynFlags -> Maybe Int

-- | Simplification history size
[historySize] :: DynFlags -> Int
[importPaths] :: DynFlags -> [FilePath]
[mainModuleNameIs] :: DynFlags -> ModuleName
[mainFunIs] :: DynFlags -> Maybe String

-- | Typechecker maximum stack depth
[reductionDepth] :: DynFlags -> IntWithInf

-- | Number of iterations in the constraints solver Typically only 1 is
--   needed
[solverIterations] :: DynFlags -> IntWithInf

-- | Target home unit-id
[homeUnitId_] :: DynFlags -> UnitId

-- | Id of the unit to instantiate
[homeUnitInstanceOf_] :: DynFlags -> Maybe UnitId

-- | Module instantiations
[homeUnitInstantiations_] :: DynFlags -> [(ModuleName, Module)]
[workingDirectory] :: DynFlags -> Maybe FilePath

-- | What the package is called, use with multiple home units
[thisPackageName] :: DynFlags -> Maybe String
[hiddenModules] :: DynFlags -> Set ModuleName
[reexportedModules] :: DynFlags -> Set ModuleName

-- | Target way flags from the command line
[targetWays_] :: DynFlags -> Ways
[splitInfo] :: DynFlags -> Maybe (String, Int)
[objectDir] :: DynFlags -> Maybe String
[dylibInstallName] :: DynFlags -> Maybe String
[hiDir] :: DynFlags -> Maybe String
[hieDir] :: DynFlags -> Maybe String
[stubDir] :: DynFlags -> Maybe String
[dumpDir] :: DynFlags -> Maybe String
[objectSuf_] :: DynFlags -> String
[hcSuf] :: DynFlags -> String
[hiSuf_] :: DynFlags -> String
[hieSuf] :: DynFlags -> String
[dynObjectSuf_] :: DynFlags -> String
[dynHiSuf_] :: DynFlags -> String
[outputFile_] :: DynFlags -> Maybe String
[dynOutputFile_] :: DynFlags -> Maybe String
[outputHi] :: DynFlags -> Maybe String
[dynOutputHi] :: DynFlags -> Maybe String
[dynLibLoader] :: DynFlags -> DynLibLoader

-- | Indicate if we are now generating dynamic output because of
--   -dynamic-too. This predicate is used to query the appropriate fields
--   (outputFile/dynOutputFile, ways, etc.)
[dynamicNow] :: DynFlags -> !Bool

-- | This defaults to 'non-module'. It can be set by <a>setDumpPrefix</a>
--   or 'ghc.GHCi.UI.runStmt' based on where its output is going.
[dumpPrefix] :: DynFlags -> FilePath

-- | Override the <a>dumpPrefix</a> set by <a>setDumpPrefix</a> or
--   'ghc.GHCi.UI.runStmt'. Set by <tt>-ddump-file-prefix</tt>
[dumpPrefixForce] :: DynFlags -> Maybe FilePath
[ldInputs] :: DynFlags -> [Option]
[includePaths] :: DynFlags -> IncludeSpecs
[libraryPaths] :: DynFlags -> [String]
[frameworkPaths] :: DynFlags -> [String]
[cmdlineFrameworks] :: DynFlags -> [String]
[rtsOpts] :: DynFlags -> Maybe String
[rtsOptsEnabled] :: DynFlags -> RtsOptsEnabled
[rtsOptsSuggestions] :: DynFlags -> Bool

-- | Path to store the .mix files
[hpcDir] :: DynFlags -> String

-- | the <tt>-fplugin</tt> flags given on the command line, in *reverse*
--   order that they're specified on the command line.
[pluginModNames] :: DynFlags -> [ModuleName]
[pluginModNameOpts] :: DynFlags -> [(ModuleName, String)]

-- | the <tt>-ffrontend-opt</tt> flags given on the command line, in
--   *reverse* order that they're specified on the command line.
[frontendPluginOpts] :: DynFlags -> [String]

-- | External plugins loaded from shared libraries
[externalPluginSpecs] :: DynFlags -> [ExternalPluginSpec]
[depMakefile] :: DynFlags -> FilePath
[depIncludePkgDeps] :: DynFlags -> Bool
[depIncludeCppDeps] :: DynFlags -> Bool
[depExcludeMods] :: DynFlags -> [ModuleName]
[depSuffixes] :: DynFlags -> [String]

-- | The <tt>-package-db</tt> flags given on the command line, In *reverse*
--   order that they're specified on the command line. This is intended to
--   be applied with the list of "initial" package databases derived from
--   <tt>GHC_PACKAGE_PATH</tt>; see <tt>getUnitDbRefs</tt>.
[packageDBFlags] :: DynFlags -> [PackageDBFlag]

-- | The <tt>-ignore-package</tt> flags from the command line. In *reverse*
--   order that they're specified on the command line.
[ignorePackageFlags] :: DynFlags -> [IgnorePackageFlag]

-- | The <tt>-package</tt> and <tt>-hide-package</tt> flags from the
--   command-line. In *reverse* order that they're specified on the command
--   line.
[packageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-plugin-package-id</tt> flags from command line. In *reverse*
--   order that they're specified on the command line.
[pluginPackageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-trust</tt> and <tt>-distrust</tt> flags. In *reverse* order
--   that they're specified on the command line.
[trustFlags] :: DynFlags -> [TrustFlag]

-- | Filepath to the package environment file (if overriding default)
[packageEnv] :: DynFlags -> Maybe FilePath
[dumpFlags] :: DynFlags -> EnumSet DumpFlag
[generalFlags] :: DynFlags -> EnumSet GeneralFlag
[warningFlags] :: DynFlags -> EnumSet WarningFlag
[fatalWarningFlags] :: DynFlags -> EnumSet WarningFlag
[language] :: DynFlags -> Maybe Language

-- | Safe Haskell mode
[safeHaskell] :: DynFlags -> SafeHaskellMode
[safeInfer] :: DynFlags -> Bool
[safeInferred] :: DynFlags -> Bool
[thOnLoc] :: DynFlags -> SrcSpan
[newDerivOnLoc] :: DynFlags -> SrcSpan
[deriveViaOnLoc] :: DynFlags -> SrcSpan
[overlapInstLoc] :: DynFlags -> SrcSpan
[incoherentOnLoc] :: DynFlags -> SrcSpan
[pkgTrustOnLoc] :: DynFlags -> SrcSpan
[warnSafeOnLoc] :: DynFlags -> SrcSpan
[warnUnsafeOnLoc] :: DynFlags -> SrcSpan
[trustworthyOnLoc] :: DynFlags -> SrcSpan
[extensions] :: DynFlags -> [OnOff Extension]
[extensionFlags] :: DynFlags -> EnumSet Extension

-- | Unfolding control See Note [Discounts and thresholds] in
--   GHC.Core.Unfold
[unfoldingOpts] :: DynFlags -> !UnfoldingOpts
[maxWorkerArgs] :: DynFlags -> Int
[ghciHistSize] :: DynFlags -> Int
[flushOut] :: DynFlags -> FlushOut
[ghcVersionFile] :: DynFlags -> Maybe FilePath
[haddockOptions] :: DynFlags -> Maybe String

-- | GHCi scripts specified by -ghci-script, in reverse order
[ghciScripts] :: DynFlags -> [String]
[pprUserLength] :: DynFlags -> Int
[pprCols] :: DynFlags -> Int
[useUnicode] :: DynFlags -> Bool
[useColor] :: DynFlags -> OverridingBool
[canUseColor] :: DynFlags -> Bool
[colScheme] :: DynFlags -> Scheme

-- | what kind of {-# SCC #-} to add automatically
[profAuto] :: DynFlags -> ProfAuto
[callerCcFilters] :: DynFlags -> [CallerCcFilter]
[interactivePrint] :: DynFlags -> Maybe String

-- | Machine dependent flags (-m&lt;blah&gt; stuff)
[sseVersion] :: DynFlags -> Maybe SseVersion
[bmiVersion] :: DynFlags -> Maybe BmiVersion
[avx] :: DynFlags -> Bool
[avx2] :: DynFlags -> Bool
[avx512cd] :: DynFlags -> Bool
[avx512er] :: DynFlags -> Bool
[avx512f] :: DynFlags -> Bool
[avx512pf] :: DynFlags -> Bool

-- | Run-time linker information (what options we need, etc.)
[rtldInfo] :: DynFlags -> IORef (Maybe LinkerInfo)

-- | Run-time C compiler information
[rtccInfo] :: DynFlags -> IORef (Maybe CompilerInfo)

-- | Run-time assembler information
[rtasmInfo] :: DynFlags -> IORef (Maybe CompilerInfo)

-- | Max size, in bytes, of inline array allocations.
[maxInlineAllocSize] :: DynFlags -> Int

-- | Only inline memcpy if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemcpyInsns] :: DynFlags -> Int

-- | Only inline memset if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemsetInsns] :: DynFlags -> Int

-- | Reverse the order of error messages in GHC/GHCi
[reverseErrors] :: DynFlags -> Bool

-- | Limit the maximum number of errors to show
[maxErrors] :: DynFlags -> Maybe Int

-- | Unique supply configuration for testing build determinism
[initialUnique] :: DynFlags -> Word64
[uniqueIncrement] :: DynFlags -> Int

-- | Temporary: CFG Edge weights for fast iterations
[cfgWeights] :: DynFlags -> Weights

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag

-- | Use foo.ways.<a>dumpFlag</a> instead of foo.<a>dumpFlag</a>
Opt_DumpWithWays :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoLinearCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_DoBoundsChecking :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_NoTypeableBinds :: GeneralFlag
Opt_DistinctConstructorTables :: GeneralFlag
Opt_InfoTableMap :: GeneralFlag
Opt_InfoTableMapWithFallback :: GeneralFlag
Opt_InfoTableMapWithStack :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintAxiomIncomps :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintRedundantPromotionTicks :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag

-- | Enable floating out of let-bindings in the simplifier
Opt_LocalFloatOut :: GeneralFlag

-- | Enable floating out of let-bindings at the top level in the simplifier
--   N.B. See Note [RHS Floating]
Opt_LocalFloatOutTopLevel :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_PolymorphicSpecialisation :: GeneralFlag
Opt_InlineGenerics :: GeneralFlag
Opt_InlineGenericsAggressively :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_EnableThSpliceWarnings :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmTBAA :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmStaticPred :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_CmmControlFlow :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag

-- | deprecated, no effect and behaviour is now default. Allowed switching
--   of a special demand transformer for dictionary selectors
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag

-- | Do W/W split for unlifting even if we won't unbox anything.
Opt_WorkerWrapperUnlift :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchNonexhaustiveCases :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_CoreConstantFolding :: GeneralFlag
Opt_FastPAPCalls :: GeneralFlag
Opt_SpecEval :: GeneralFlag
Opt_SpecEvalDictFun :: GeneralFlag
Opt_DoTagInferenceChecks :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_ProfLateInlineCcs :: GeneralFlag
Opt_ProfLateCcs :: GeneralFlag

-- | Ignore manual SCC annotations
Opt_ProfManualCcs :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_Ticky_Tag :: GeneralFlag

-- | Use regular thunks even when we could use std ap thunks in order to
--   get entry counts
Opt_Ticky_AP :: GeneralFlag
Opt_CmmThreadSanitizer :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag

-- | <pre>
--   -fcompact-unwind
--   </pre>
Opt_CompactUnwind :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FamAppCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_ExposeInternalSymbols :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_KeepGoing :: GeneralFlag
Opt_ByteCode :: GeneralFlag
Opt_ByteCodeAndObjectCode :: GeneralFlag
Opt_LinkRts :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DeferDiagnostics :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressCoercionTypes :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressStgReps :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag

-- | Suppress per binding Core size stats in dumps
Opt_SuppressCoreSizes :: GeneralFlag
Opt_ShowErrorContext :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_WriteIfSimplifiedCore :: GeneralFlag
Opt_UseBytecodeRatherThanObjects :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_PluginTrustworthy :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag

-- | Used to describe warnings and errors o The message has a
--   file/line/column heading, plus "warning:" or "error:", added by
--   mkLocMessage o With <a>SevIgnore</a> the message is suppressed o
--   Output is intended for end users
data Severity

-- | Ignore this message, for example in case of suppression of warnings
--   users don't want to see. See Note [Suppressing Messages]
SevIgnore :: Severity
SevWarning :: Severity
SevError :: Severity

-- | A value of type <tt>Backend</tt> represents one of GHC's back ends.
--   The set of back ends cannot be extended except by modifying the
--   definition of <tt>Backend</tt> in this module.
--   
--   The <tt>Backend</tt> type is abstract; that is, its value constructors
--   are not exported. It's crucial that they not be exported, because a
--   value of type <tt>Backend</tt> carries only the back end's
--   <i>name</i>, not its behavior or properties. If <tt>Backend</tt> were
--   not abstract, then code elsewhere in the compiler could depend
--   directly on the name, not on the semantics, which would make it
--   challenging to create a new back end. Because <tt>Backend</tt>
--   <i>is</i> abstract, all the obligations of a new back end are
--   enumerated in this module, in the form of functions that take
--   <tt>Backend</tt> as an argument.
--   
--   The issue of abstraction is discussed at great length in #20927 and
--   !7442.
data Backend

-- | Test whether a <a>GeneralFlag</a> is set
--   
--   Note that <a>dynamicNow</a> (i.e., dynamic objects built with
--   `-dynamic-too`) always implicitly enables Opt_PIC,
--   Opt_ExternalDynamicRefs, and disables Opt_SplitSections.
gopt :: GeneralFlag -> DynFlags -> Bool

-- | The native code generator. Compiles Cmm code into textual assembler,
--   then relies on an external assembler toolchain to produce machine
--   code.
--   
--   Only supports a few platforms (X86, PowerPC, SPARC).
--   
--   See <a>GHC.CmmToAsm</a>.
ncgBackend :: Backend

-- | The LLVM backend.
--   
--   Compiles Cmm code into LLVM textual IR, then relies on LLVM toolchain
--   to produce machine code.
--   
--   It relies on LLVM support for the calling convention used by the NCG
--   backend to produce code objects ABI compatible with it (see "cc 10" or
--   "ghccc" calling convention in
--   <a>https://llvm.org/docs/LangRef.html#calling-conventions)</a>.
--   
--   Supports a few platforms (X86, AArch64, s390x, ARM).
--   
--   See <a>GHC.CmmToLlvm</a>
llvmBackend :: Backend

-- | Via-C ("unregisterised") backend.
--   
--   Compiles Cmm code into C code, then relies on a C compiler to produce
--   machine code.
--   
--   It produces code objects that are <i>not</i> ABI compatible with those
--   produced by NCG and LLVM backends.
--   
--   Produced code is expected to be less efficient than the one produced
--   by NCG and LLVM backends because STG registers are not pinned into
--   real registers. On the other hand, it supports more target platforms
--   (those having a valid C toolchain).
--   
--   See <a>GHC.CmmToC</a>
viaCBackend :: Backend

-- | The ByteCode interpreter.
--   
--   Produce ByteCode objects (BCO, see <a>GHC.ByteCode</a>) that can be
--   interpreted. It is used by GHCi.
--   
--   Currently some extensions are not supported (foreign primops).
--   
--   See <a>GHC.StgToByteCode</a>
interpreterBackend :: Backend

-- | A dummy back end that generates no code.
--   
--   Use this back end to disable code generation. It is particularly
--   useful when GHC is used as a library for other purpose than generating
--   code (e.g. to generate documentation with Haddock) or when the user
--   requested it (via `-fno-code`) for some reason.
noBackend :: Backend

-- | The <a>GhcMode</a> tells us whether we're doing multi-module
--   compilation (controlled via the <a>GHC</a> API) or one-shot
--   (single-module) compilation. This makes a difference primarily to the
--   <a>GHC.Unit.Finder</a>: in one-shot mode we look for interface files
--   for imported modules, but in multi-module mode we look for source
--   files in order to check whether they need to be recompiled.
data GhcMode

-- | <tt>--make</tt>, GHCi, etc.
CompManager :: GhcMode

-- | <pre>
--   ghc -c Foo.hs
--   </pre>
OneShot :: GhcMode

-- | <tt>ghc -M</tt>, see <a>GHC.Unit.Finder</a> for why we need this
MkDepend :: GhcMode

-- | What to do in the link step, if there is one.
data GhcLink

-- | Don't link at all
NoLink :: GhcLink

-- | Link object code into a binary
LinkBinary :: GhcLink

-- | Use the in-memory dynamic linker (works for both bytecode and object
--   code).
LinkInMemory :: GhcLink

-- | Link objects into a dynamic lib (DLL on Windows, DSO on ELF platforms)
LinkDynLib :: GhcLink

-- | Link objects into a static lib
LinkStaticLib :: GhcLink

-- | Link objects into a merged "GHCi object"
LinkMergedObj :: GhcLink
parseDynamicFlags :: MonadIO m => Logger -> DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | Parse command line arguments that look like files. First normalises
--   its arguments and then splits them into source files and object files.
--   A source file can be turned into a <a>Target</a> via
--   <a>guessTarget</a>
parseTargetFiles :: DynFlags -> [String] -> (DynFlags, [(String, Maybe Phase)], [String])

-- | Grabs the DynFlags from the Session
getSessionDynFlags :: GhcMonad m => m DynFlags
setTopSessionDynFlags :: GhcMonad m => DynFlags -> m ()
setSessionDynFlags :: (HasCallStack, GhcMonad m) => DynFlags -> m ()
setUnitDynFlags :: GhcMonad m => UnitId -> DynFlags -> m ()

-- | Returns the program <a>DynFlags</a>.
getProgramDynFlags :: GhcMonad m => m DynFlags

-- | Sets the program <a>DynFlags</a>. Note: this invalidates the internal
--   cached module graph, causing more work to be done the next time
--   <a>load</a> is called.
--   
--   Returns a boolean indicating if preload units have changed and need to
--   be reloaded.
setProgramDynFlags :: GhcMonad m => DynFlags -> m Bool

-- | Get the <a>DynFlags</a> used to evaluate interactive expressions.
getInteractiveDynFlags :: GhcMonad m => m DynFlags

-- | Set the <a>DynFlags</a> used to evaluate interactive expressions. Also
--   initialise (load) plugins.
--   
--   Note: this cannot be used for changes to packages. Use
--   <a>setSessionDynFlags</a>, or <a>setProgramDynFlags</a> and then copy
--   the <tt>unitState</tt> into the interactive <tt>DynFlags</tt>.
setInteractiveDynFlags :: GhcMonad m => DynFlags -> m ()

-- | Find the package environment (if one exists)
--   
--   We interpret the package environment as a set of package flags; to be
--   specific, if we find a package environment file like
--   
--   <pre>
--   clear-package-db
--   global-package-db
--   package-db blah/package.conf.d
--   package-id id1
--   package-id id2
--   </pre>
--   
--   we interpret this as
--   
--   <pre>
--   [ -hide-all-packages
--   , -clear-package-db
--   , -global-package-db
--   , -package-db blah/package.conf.d
--   , -package-id id1
--   , -package-id id2
--   ]
--   </pre>
--   
--   There's also an older syntax alias for package-id, which is just an
--   unadorned package id
--   
--   <pre>
--   id1
--   id2
--   </pre>
interpretPackageEnv :: Logger -> DynFlags -> IO DynFlags
data Logger
getLogger :: HasLogger m => m Logger

-- | Push a log hook
pushLogHook :: (LogAction -> LogAction) -> Logger -> Logger

-- | Pop a log hook
popLogHook :: Logger -> Logger

-- | Push a log hook on the stack
pushLogHookM :: GhcMonad m => (LogAction -> LogAction) -> m ()

-- | Pop a log hook from the stack
popLogHookM :: GhcMonad m => m ()

-- | Modify the logger
modifyLogger :: GhcMonad m => (Logger -> Logger) -> m ()

-- | Put a log message
putMsgM :: GhcMonad m => SDoc -> m ()

-- | Put a log message
putLogMsgM :: GhcMonad m => MessageClass -> SrcSpan -> SDoc -> m ()

-- | A compilation target.
--   
--   A target may be supplied with the actual text of the module. If so,
--   use this instead of the file contents (this is for use in an IDE where
--   the file hasn't been saved by the user yet).
--   
--   These fields are strict because Targets are long lived.
data Target
Target :: !TargetId -> !Bool -> !UnitId -> !Maybe (InputFileBuffer, UTCTime) -> Target

-- | module or filename
[targetId] :: Target -> !TargetId

-- | object code allowed?
[targetAllowObjCode] :: Target -> !Bool

-- | id of the unit this target is part of
[targetUnitId] :: Target -> !UnitId

-- | Optional in-memory buffer containing the source code GHC should use
--   for this target instead of reading it from disk.
--   
--   Since GHC version 8.10 modules which require preprocessors such as
--   Literate Haskell or CPP to run are also supported.
--   
--   If a corresponding source file does not exist on disk this will result
--   in a <tt>SourceError</tt> exception if <tt>targetId = TargetModule
--   _</tt> is used. However together with <tt>targetId = TargetFile _</tt>
--   GHC will not complain about the file missing.
[targetContents] :: Target -> !Maybe (InputFileBuffer, UTCTime)
data TargetId

-- | A module name: search for the file
TargetModule :: !ModuleName -> TargetId

-- | A filename: preprocess &amp; parse it to find the module name. If
--   specified, the Phase indicates how to compile this file (which phase
--   to start from). Nothing indicates the starting phase should be
--   determined from the suffix of the filename.
TargetFile :: !FilePath -> !Maybe Phase -> TargetId

-- | Untyped Phase description
data Phase

-- | Sets the targets for this session. Each target may be a module name or
--   a filename. The targets correspond to the set of root modules for the
--   program/library. Unloading the current program is achieved by setting
--   the current set of targets to be empty, followed by <a>load</a>.
setTargets :: GhcMonad m => [Target] -> m ()

-- | Returns the current set of targets
getTargets :: GhcMonad m => m [Target]

-- | Add another target.
addTarget :: GhcMonad m => Target -> m ()

-- | Remove a target
removeTarget :: GhcMonad m => TargetId -> m ()

-- | Attempts to guess what Target a string refers to. This function
--   implements the <tt>--make</tt>/GHCi command-line syntax for filenames:
--   
--   <ul>
--   <li>if the string looks like a Haskell source filename, then interpret
--   it as such</li>
--   <li>if adding a .hs or .lhs suffix yields the name of an existing
--   file, then use that</li>
--   <li>otherwise interpret the string as a module name</li>
--   </ul>
guessTarget :: GhcMonad m => String -> Maybe UnitId -> Maybe Phase -> m Target

-- | Perform a dependency analysis starting from the current targets and
--   update the session with the new module graph.
--   
--   Dependency analysis entails parsing the <tt>import</tt> directives and
--   may therefore require running certain preprocessors.
--   
--   Note that each <a>ModSummary</a> in the module graph caches its
--   <a>DynFlags</a>. These <a>DynFlags</a> are determined by the
--   <i>current</i> session <a>DynFlags</a> and the <tt>OPTIONS</tt> and
--   <tt>LANGUAGE</tt> pragmas of the parsed module. Thus if you want
--   changes to the <a>DynFlags</a> to take effect you need to call this
--   function again. In case of errors, just throw them.
depanal :: GhcMonad m => [ModuleName] -> Bool -> m ModuleGraph

-- | Perform dependency analysis like in <a>depanal</a>. In case of errors,
--   the errors and an empty module graph are returned.
depanalE :: GhcMonad m => [ModuleName] -> Bool -> m (DriverMessages, ModuleGraph)

-- | Try to load the program. See <a>LoadHowMuch</a> for the different
--   modes.
--   
--   This function implements the core of GHC's <tt>--make</tt> mode. It
--   preprocesses, compiles and loads the specified modules, avoiding
--   re-compilation wherever possible. Depending on the backend (see
--   <a>backend</a> field) compiling and loading may result in files being
--   created on disk.
--   
--   Calls the <a>defaultWarnErrLogger</a> after each compiling each
--   module, whether successful or not.
--   
--   If errors are encountered during dependency analysis, the module
--   <a>depanalE</a> returns together with the errors an empty ModuleGraph.
--   After processing this empty ModuleGraph, the errors of depanalE are
--   thrown. All other errors are reported using the
--   <a>defaultWarnErrLogger</a>.
load :: GhcMonad f => LoadHowMuch -> f SuccessFlag
loadWithCache :: GhcMonad m => Maybe ModIfaceCache -> LoadHowMuch -> m SuccessFlag

-- | Describes which modules of the module graph need to be loaded.
data LoadHowMuch

-- | Load all targets and its dependencies.
LoadAllTargets :: LoadHowMuch

-- | Load only the given module and its dependencies.
LoadUpTo :: HomeUnitModule -> LoadHowMuch

-- | Load only the dependencies of the given module, but not the module
--   itself.
LoadDependenciesOf :: HomeUnitModule -> LoadHowMuch
data InteractiveImport

-- | Bring the exports of a particular module (filtered by an import decl)
--   into scope
IIDecl :: ImportDecl GhcPs -> InteractiveImport

-- | Bring into scope the entire top-level envt of of this module,
--   including the things imported into it.
IIModule :: ModuleName -> InteractiveImport
data SuccessFlag
Succeeded :: SuccessFlag
Failed :: SuccessFlag
succeeded :: SuccessFlag -> Bool
failed :: SuccessFlag -> Bool
defaultWarnErrLogger :: WarnErrLogger

-- | A function called to log warnings and errors.
type WarnErrLogger = forall m. (HasDynFlags m, MonadIO m, HasLogger m) => Maybe SourceError -> m ()

-- | Inform GHC that the working directory has changed. GHC will flush its
--   cache of module locations, since it may no longer be valid.
--   
--   Note: Before changing the working directory make sure all threads
--   running in the same session have stopped. If you change the working
--   directory, you should also unload the current program (set targets to
--   empty, followed by load).
workingDirectoryChanged :: GhcMonad m => m ()

-- | Parse a module.
--   
--   Throws a <a>SourceError</a> on parse error.
parseModule :: GhcMonad m => ModSummary -> m ParsedModule

-- | Typecheck and rename a parsed module.
--   
--   Throws a <a>SourceError</a> if either fails.
typecheckModule :: GhcMonad m => ParsedModule -> m TypecheckedModule

-- | Desugar a typechecked module.
desugarModule :: GhcMonad m => TypecheckedModule -> m DesugaredModule

-- | The result of successful parsing.
data ParsedModule
ParsedModule :: ModSummary -> ParsedSource -> [FilePath] -> ParsedModule
[pm_mod_summary] :: ParsedModule -> ModSummary
[pm_parsed_source] :: ParsedModule -> ParsedSource
[pm_extra_src_files] :: ParsedModule -> [FilePath]

-- | The result of successful typechecking. It also contains the parser
--   result.
data TypecheckedModule
TypecheckedModule :: ParsedModule -> Maybe RenamedSource -> TypecheckedSource -> ModuleInfo -> (TcGblEnv, ModDetails) -> TypecheckedModule
[tm_parsed_module] :: TypecheckedModule -> ParsedModule
[tm_renamed_source] :: TypecheckedModule -> Maybe RenamedSource
[tm_typechecked_source] :: TypecheckedModule -> TypecheckedSource
[tm_checked_module_info] :: TypecheckedModule -> ModuleInfo
[tm_internals_] :: TypecheckedModule -> (TcGblEnv, ModDetails)

-- | The result of successful desugaring (i.e., translation to core). Also
--   contains all the information of a typechecked module.
data DesugaredModule
DesugaredModule :: TypecheckedModule -> ModGuts -> DesugaredModule
[dm_typechecked_module] :: DesugaredModule -> TypecheckedModule
[dm_core_module] :: DesugaredModule -> ModGuts
type TypecheckedSource = LHsBinds GhcTc
type ParsedSource = Located (HsModule GhcPs)
type RenamedSource = (HsGroup GhcRn, [LImportDecl GhcRn], Maybe [(LIE GhcRn, Avails)], Maybe (LHsDoc GhcRn))
class ParsedMod m => TypecheckedMod m
class ParsedMod m
moduleInfo :: TypecheckedMod m => m -> ModuleInfo
renamedSource :: TypecheckedMod m => m -> Maybe RenamedSource
typecheckedSource :: TypecheckedMod m => m -> TypecheckedSource
parsedSource :: ParsedMod m => m -> ParsedSource
coreModule :: DesugaredMod m => m -> ModGuts

-- | Package-qualifier after renaming
--   
--   Renaming detects if "this" or the unit-id of the home-unit was used as
--   a package qualifier.
data PkgQual

-- | No package qualifier
NoPkgQual :: PkgQual

-- | Import from home-unit
ThisPkg :: UnitId -> PkgQual

-- | Import from another unit
OtherPkg :: UnitId -> PkgQual

-- | A CoreModule consists of just the fields of a <a>ModGuts</a> that are
--   needed for the <a>compileToCoreModule</a> interface.
data CoreModule
CoreModule :: !Module -> !TypeEnv -> CoreProgram -> SafeHaskellMode -> CoreModule

-- | Module name
[cm_module] :: CoreModule -> !Module

-- | Type environment for types declared in this module
[cm_types] :: CoreModule -> !TypeEnv

-- | Declarations
[cm_binds] :: CoreModule -> CoreProgram

-- | Safe Haskell mode
[cm_safe] :: CoreModule -> SafeHaskellMode

-- | This is the way to get access to the Core bindings corresponding to a
--   module. <tt>compileToCore</tt> parses, typechecks, and desugars the
--   module, then returns the resulting Core module (consisting of the
--   module name, type declarations, and function declarations) if
--   successful.
compileToCoreModule :: GhcMonad m => FilePath -> m CoreModule

-- | Like compileToCoreModule, but invokes the simplifier, so as to return
--   simplified and tidied Core.
compileToCoreSimplified :: GhcMonad m => FilePath -> m CoreModule

-- | A '<tt>ModuleGraph</tt>' contains all the nodes from the home package
--   (only). See '<tt>ModuleGraphNode</tt>' for information about the
--   nodes.
--   
--   Modules need to be compiled. hs-boots need to be typechecked before
--   the associated "real" module so modules with {-# SOURCE #-} imports
--   can be built. Instantiations also need to be typechecked to ensure
--   that the module fits the signature. Substantiation typechecking is
--   roughly comparable to the check that the module and its hs-boot agree.
--   
--   The graph is not necessarily stored in topologically-sorted order. Use
--   <a>topSortModuleGraph</a> and <a>flattenSCC</a> to achieve this.
data ModuleGraph
emptyMG :: ModuleGraph

-- | Map a function <tt>f</tt> over all the <tt>ModSummaries</tt>. To
--   preserve invariants <tt>f</tt> can't change the isBoot status.
mapMG :: (ModSummary -> ModSummary) -> ModuleGraph -> ModuleGraph
mkModuleGraph :: [ModuleGraphNode] -> ModuleGraph
mgModSummaries :: ModuleGraph -> [ModSummary]

-- | Look up a ModSummary in the ModuleGraph Looks up the non-boot
--   ModSummary Linear in the size of the module graph
mgLookupModule :: ModuleGraph -> Module -> Maybe ModSummary

-- | Data for a module node in a <tt>ModuleGraph</tt>. Module nodes of the
--   module graph are one of:
--   
--   <ul>
--   <li>A regular Haskell source module</li>
--   <li>A hi-boot source module</li>
--   </ul>
data ModSummary
ModSummary :: Module -> HscSource -> ModLocation -> Fingerprint -> Maybe UTCTime -> !Maybe UTCTime -> Maybe UTCTime -> Maybe UTCTime -> [(PkgQual, Located ModuleName)] -> [(PkgQual, Located ModuleName)] -> !Bool -> Maybe HsParsedModule -> FilePath -> DynFlags -> Maybe StringBuffer -> ModSummary

-- | Identity of the module
[ms_mod] :: ModSummary -> Module

-- | The module source either plain Haskell, hs-boot, or hsig
[ms_hsc_src] :: ModSummary -> HscSource

-- | Location of the various files belonging to the module
[ms_location] :: ModSummary -> ModLocation

-- | Content hash of source file
[ms_hs_hash] :: ModSummary -> Fingerprint

-- | Timestamp of object, if we have one
[ms_obj_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of dynamic object, if we have one
[ms_dyn_obj_date] :: ModSummary -> !Maybe UTCTime

-- | Timestamp of hi file, if we have one See Note [When source is
--   considered modified] and #9243
[ms_iface_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of hie file, if we have one
[ms_hie_date] :: ModSummary -> Maybe UTCTime

-- | Source imports of the module
[ms_srcimps] :: ModSummary -> [(PkgQual, Located ModuleName)]

-- | Non-source imports of the module from the module *text*
[ms_textual_imps] :: ModSummary -> [(PkgQual, Located ModuleName)]

-- | Whether the special module GHC.Prim was imported explicitly
[ms_ghc_prim_import] :: ModSummary -> !Bool

-- | The parsed, nonrenamed source, if we have it. This is also used to
--   support "inline module syntax" in Backpack files.
[ms_parsed_mod] :: ModSummary -> Maybe HsParsedModule

-- | Filename of preprocessed source file
[ms_hspp_file] :: ModSummary -> FilePath

-- | Cached flags from <tt>OPTIONS</tt>, <tt>INCLUDE</tt> and
--   <tt>LANGUAGE</tt> pragmas in the modules source code
[ms_hspp_opts] :: ModSummary -> DynFlags

-- | The actual preprocessed source, if we have it
[ms_hspp_buf] :: ModSummary -> Maybe StringBuffer
ms_mod_name :: ModSummary -> ModuleName

-- | Module Location
--   
--   Where a module lives on the file system: the actual locations of the
--   .hs, .hi, .dyn_hi, .o, .dyn_o and .hie files, if we have them.
--   
--   For a module in another unit, the ml_hs_file and ml_obj_file
--   components of ModLocation are undefined.
--   
--   The locations specified by a ModLocation may or may not correspond to
--   actual files yet: for example, even if the object file doesn't exist,
--   the ModLocation still contains the path to where the object file will
--   reside if/when it is created.
--   
--   The paths of anything which can affect recompilation should be placed
--   inside ModLocation.
--   
--   When a ModLocation is created none of the filepaths will have -boot
--   suffixes. This is because in --make mode the ModLocation is put in the
--   finder cache which is indexed by ModuleName, when a ModLocation is
--   retrieved from the FinderCache the boot suffixes are appended. The
--   other case is in -c mode, there the ModLocation immediately gets given
--   the boot suffixes in mkOneShotModLocation.
data ModLocation
ModLocation :: Maybe FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> ModLocation

-- | The source file, if we have one. Package modules probably don't have
--   source files.
[ml_hs_file] :: ModLocation -> Maybe FilePath

-- | Where the .hi file is, whether or not it exists yet. Always of form
--   foo.hi, even if there is an hi-boot file (we add the -boot suffix
--   later)
[ml_hi_file] :: ModLocation -> FilePath

-- | Where the .dyn_hi file is, whether or not it exists yet.
[ml_dyn_hi_file] :: ModLocation -> FilePath

-- | Where the .o file is, whether or not it exists yet. (might not exist
--   either because the module hasn't been compiled yet, or because it is
--   part of a unit with a .a file)
[ml_obj_file] :: ModLocation -> FilePath

-- | Where the .dy file is, whether or not it exists yet.
[ml_dyn_obj_file] :: ModLocation -> FilePath

-- | Where the .hie file is, whether or not it exists yet.
[ml_hie_file] :: ModLocation -> FilePath

-- | Return the <a>ModSummary</a> of a module with the given name.
--   
--   The module must be part of the module graph (see <a>hsc_mod_graph</a>
--   and <a>ModuleGraph</a>). If this is not the case, this function will
--   throw a <a>GhcApiError</a>.
--   
--   This function ignores boot modules and requires that there is only one
--   non-boot module with the given name.
getModSummary :: GhcMonad m => ModuleName -> m ModSummary

-- | Get the module dependency graph.
getModuleGraph :: GhcMonad m => m ModuleGraph

-- | Return <tt>True</tt> &lt;==&gt; module is loaded.
isLoaded :: GhcMonad m => ModuleName -> m Bool
isLoadedModule :: GhcMonad m => UnitId -> ModuleName -> m Bool

-- | Topological sort of the module graph
--   
--   Calculate SCCs of the module graph, possibly dropping the hi-boot
--   nodes The resulting list of strongly-connected-components is in
--   topologically sorted order, starting with the module(s) at the bottom
--   of the dependency graph (ie compile them first) and ending with the
--   ones at the top.
--   
--   Drop hi-boot nodes (first boolean arg)?
--   
--   <ul>
--   <li><tt>False</tt>: treat the hi-boot summaries as nodes of the graph,
--   so the graph must be acyclic</li>
--   <li><tt>True</tt>: eliminate the hi-boot nodes, and instead pretend
--   the a source-import of Foo is an import of Foo The resulting graph has
--   no hi-boot nodes, but can be cyclic</li>
--   </ul>
topSortModuleGraph :: Bool -> ModuleGraph -> Maybe HomeUnitModule -> [SCC ModuleGraphNode]

-- | Container for information about a <a>GenModule</a>.
data ModuleInfo

-- | Request information about a loaded <a>GenModule</a>
getModuleInfo :: GhcMonad m => Module -> m (Maybe ModuleInfo)

-- | The list of top-level entities defined in a module
modInfoTyThings :: ModuleInfo -> [TyThing]
modInfoTopLevelScope :: ModuleInfo -> Maybe [Name]
modInfoExports :: ModuleInfo -> [Name]
modInfoExportsWithSelectors :: ModuleInfo -> [Name]

-- | Returns the instances defined by the specified module. Warning:
--   currently unimplemented for package modules.
modInfoInstances :: ModuleInfo -> [ClsInst]
modInfoIsExportedName :: ModuleInfo -> Name -> Bool
modInfoLookupName :: GhcMonad m => ModuleInfo -> Name -> m (Maybe TyThing)
modInfoIface :: ModuleInfo -> Maybe ModIface
modInfoRdrEnv :: ModuleInfo -> Maybe GlobalRdrEnv

-- | Retrieve module safe haskell mode
modInfoSafe :: ModuleInfo -> SafeHaskellMode

-- | Looks up a global name: that is, any top-level name in any visible
--   module. Unlike <a>lookupName</a>, lookupGlobalName does not use the
--   interactive context, and therefore does not require a preceding
--   <a>setContext</a>.
lookupGlobalName :: GhcMonad m => Name -> m (Maybe TyThing)
findGlobalAnns :: (GhcMonad m, Typeable a) => ([Word8] -> a) -> AnnTarget Name -> m [a]
mkNamePprCtxForModule :: GhcMonad m => ModuleInfo -> m (Maybe NamePprCtx)
type ModIface = ModIface_ 'ModIfaceFinal

-- | A <a>ModIface</a> plus a <tt>ModDetails</tt> summarises everything we
--   know about a compiled module. The <a>ModIface</a> is the stuff
--   *before* linking, and can be written out to an interface file. The
--   'ModDetails is after linking and can be completely recovered from just
--   the <a>ModIface</a>.
--   
--   When we read an interface file, we also construct a <a>ModIface</a>
--   from it, except that we explicitly make the <a>mi_decls</a> and a few
--   other fields empty; as when reading we consolidate the declarations
--   etc. into a number of indexed maps and environments in the
--   <tt>ExternalPackageState</tt>.
--   
--   See Note [Strictness in ModIface] to learn about why some fields are
--   strict and others are not.
data ModIface_ (phase :: ModIfacePhase)
ModIface :: !Module -> !Maybe Module -> !HscSource -> Dependencies -> [Usage] -> ![IfaceExport] -> !Bool -> [(OccName, Fixity)] -> Warnings GhcRn -> [IfaceAnnotation] -> [IfaceDeclExts phase] -> Maybe [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo] -> !Maybe GlobalRdrEnv -> [IfaceClsInst] -> [IfaceFamInst] -> [IfaceRule] -> !AnyHpcUsage -> !IfaceTrustInfo -> !Bool -> ![IfaceCompleteMatch] -> !Maybe Docs -> !IfaceBackendExts phase -> !ExtensibleFields -> !Fingerprint -> ModIface_ (phase :: ModIfacePhase)

-- | Name of the module we are for
[mi_module] :: ModIface_ (phase :: ModIfacePhase) -> !Module

-- | Are we a sig of another mod?
[mi_sig_of] :: ModIface_ (phase :: ModIfacePhase) -> !Maybe Module

-- | Boot? Signature?
[mi_hsc_src] :: ModIface_ (phase :: ModIfacePhase) -> !HscSource

-- | The dependencies of the module. This is consulted for
--   directly-imported modules, but not for anything else (hence lazy)
[mi_deps] :: ModIface_ (phase :: ModIfacePhase) -> Dependencies

-- | Usages; kept sorted so that it's easy to decide whether to write a new
--   iface file (changing usages doesn't affect the hash of this module)
--   NOT STRICT! we read this field lazily from the interface file It is
--   *only* consulted by the recompilation checker
[mi_usages] :: ModIface_ (phase :: ModIfacePhase) -> [Usage]

-- | Exports Kept sorted by (mod,occ), to make version comparisons easier
--   Records the modules that are the declaration points for things
--   exported by this module, and the <a>OccName</a>s of those things
[mi_exports] :: ModIface_ (phase :: ModIfacePhase) -> ![IfaceExport]

-- | Module required TH splices when it was compiled. This disables
--   recompilation avoidance (see #481).
[mi_used_th] :: ModIface_ (phase :: ModIfacePhase) -> !Bool

-- | Fixities NOT STRICT! we read this field lazily from the interface file
[mi_fixities] :: ModIface_ (phase :: ModIfacePhase) -> [(OccName, Fixity)]

-- | Warnings NOT STRICT! we read this field lazily from the interface file
[mi_warns] :: ModIface_ (phase :: ModIfacePhase) -> Warnings GhcRn

-- | Annotations NOT STRICT! we read this field lazily from the interface
--   file
[mi_anns] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceAnnotation]

-- | Type, class and variable declarations The hash of an Id changes if its
--   fixity or deprecations change (as well as its type of course) Ditto
--   data constructors, class operations, except that the hash of the
--   parent class/tycon changes
[mi_decls] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceDeclExts phase]

-- | Extra variable definitions which are **NOT** exposed but when combined
--   with mi_decls allows us to restart code generation. See Note
--   [Interface Files with Core Definitions] and Note [Interface File with
--   Core: Sharing RHSs]
[mi_extra_decls] :: ModIface_ (phase :: ModIfacePhase) -> Maybe [IfaceBindingX IfaceMaybeRhs IfaceTopBndrInfo]

-- | Binds all the things defined at the top level in the <i>original
--   source</i> code for this module. which is NOT the same as mi_exports,
--   nor mi_decls (which may contains declarations for things not actually
--   defined by the user). Used for GHCi and for inspecting the contents of
--   modules via the GHC API only.
--   
--   (We need the source file to figure out the top-level environment, if
--   we didn't compile this module from source then this field contains
--   <tt>Nothing</tt>).
--   
--   Strictly speaking this field should live in the <tt>HomeModInfo</tt>,
--   but that leads to more plumbing.
[mi_globals] :: ModIface_ (phase :: ModIfacePhase) -> !Maybe GlobalRdrEnv

-- | Sorted class instance
[mi_insts] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceClsInst]

-- | Sorted family instances
[mi_fam_insts] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceFamInst]

-- | Sorted rules
[mi_rules] :: ModIface_ (phase :: ModIfacePhase) -> [IfaceRule]

-- | True if this program uses Hpc at any point in the program.
[mi_hpc] :: ModIface_ (phase :: ModIfacePhase) -> !AnyHpcUsage

-- | Safe Haskell Trust information for this module.
[mi_trust] :: ModIface_ (phase :: ModIfacePhase) -> !IfaceTrustInfo

-- | Do we require the package this module resides in be trusted to trust
--   this module? This is used for the situation where a module is Safe (so
--   doesn't require the package be trusted itself) but imports some
--   trustworthy modules from its own package (which does require its own
--   package be trusted). See Note [Trust Own Package] in GHC.Rename.Names
[mi_trust_pkg] :: ModIface_ (phase :: ModIfacePhase) -> !Bool
[mi_complete_matches] :: ModIface_ (phase :: ModIfacePhase) -> ![IfaceCompleteMatch]

-- | Docstrings and related data for use by haddock, the ghci <tt>:doc</tt>
--   command, and other tools.
--   
--   <tt>Just _</tt> <tt><a>=</a></tt> the module was built with
--   <tt>-haddock</tt>.
[mi_docs] :: ModIface_ (phase :: ModIfacePhase) -> !Maybe Docs

-- | Either <tt>()</tt> or <a>ModIfaceBackend</a> for a fully instantiated
--   interface.
[mi_final_exts] :: ModIface_ (phase :: ModIfacePhase) -> !IfaceBackendExts phase

-- | Additional optional fields, where the Map key represents the field
--   name, resulting in a (size, serialized data) pair. Because the data is
--   intended to be serialized through the internal <a>Binary</a> class
--   (increasing compatibility with types using <a>Name</a> and
--   <tt>FastString</tt>, such as HIE), this format is chosen over
--   <tt>ByteString</tt>s.
[mi_ext_fields] :: ModIface_ (phase :: ModIfacePhase) -> !ExtensibleFields

-- | Hash of the .hs source, used for recompilation checking.
[mi_src_hash] :: ModIface_ (phase :: ModIfacePhase) -> !Fingerprint

-- | The various Safe Haskell modes
data SafeHaskellMode

-- | inferred unsafe
Sf_None :: SafeHaskellMode

-- | declared and checked
Sf_Unsafe :: SafeHaskellMode

-- | declared and checked
Sf_Trustworthy :: SafeHaskellMode

-- | declared and checked
Sf_Safe :: SafeHaskellMode

-- | inferred as safe
Sf_SafeInferred :: SafeHaskellMode

-- | <tt>-fno-safe-haskell</tt> state
Sf_Ignore :: SafeHaskellMode

-- | When printing code that contains original names, we need to map the
--   original names back to something the user understands. This is the
--   purpose of the triple of functions that gets passed around when
--   rendering <a>SDoc</a>.
data NamePprCtx
alwaysQualify :: NamePprCtx

-- | Run a statement in the current interactive context.
execStmt :: GhcMonad m => String -> ExecOptions -> m ExecResult

-- | Like <a>execStmt</a>, but takes a parsed statement as argument. Useful
--   when doing preprocessing on the AST before execution, e.g. in GHCi
--   (see GHCi.UI.runStmt).
execStmt' :: GhcMonad m => GhciLStmt GhcPs -> String -> ExecOptions -> m ExecResult
data ExecOptions
ExecOptions :: SingleStep -> String -> Int -> (ForeignHValue -> EvalExpr ForeignHValue) -> ExecOptions

-- | stepping mode
[execSingleStep] :: ExecOptions -> SingleStep

-- | filename (for errors)
[execSourceFile] :: ExecOptions -> String

-- | line number (for errors)
[execLineNumber] :: ExecOptions -> Int
[execWrap] :: ExecOptions -> ForeignHValue -> EvalExpr ForeignHValue

-- | default ExecOptions
execOptions :: ExecOptions
data ExecResult
ExecComplete :: Either SomeException [Name] -> Word64 -> ExecResult
[execResult] :: ExecResult -> Either SomeException [Name]
[execAllocation] :: ExecResult -> Word64
ExecBreak :: [Name] -> Maybe BreakInfo -> ExecResult
[breakNames] :: ExecResult -> [Name]
[breakInfo] :: ExecResult -> Maybe BreakInfo
resumeExec :: GhcMonad m => (SrcSpan -> Bool) -> SingleStep -> Maybe Int -> m ExecResult
runDecls :: GhcMonad m => String -> m [Name]

-- | Run some declarations and return any user-visible names that were
--   brought into scope.
runDeclsWithLocation :: GhcMonad m => String -> Int -> String -> m [Name]

-- | Like <a>runDeclsWithLocation</a>, but takes parsed declarations as
--   argument. Useful when doing preprocessing on the AST before execution,
--   e.g. in GHCi (see GHCi.UI.runStmt).
runParsedDecls :: GhcMonad m => [LHsDecl GhcPs] -> m [Name]
parseImportDecl :: GhcMonad m => String -> m (ImportDecl GhcPs)

-- | Set the interactive evaluation context.
--   
--   (setContext imports) sets the ic_imports field (which in turn
--   determines what is in scope at the prompt) to <tt>imports</tt>, and
--   updates the icReaderEnv environment to reflect it.
--   
--   We retain in scope all the things defined at the prompt, and kept in
--   ic_tythings. (Indeed, they shadow stuff from ic_imports.)
setContext :: GhcMonad m => [InteractiveImport] -> m ()

-- | Get the interactive evaluation context, consisting of a pair of the
--   set of modules from which we take the full top-level scope, and the
--   set of modules from which we take just the exports respectively.
getContext :: GhcMonad m => m [InteractiveImport]

-- | Set the monad GHCi lifts user statements into.
--   
--   Checks that a type (in string form) is an instance of the
--   <tt>GHC.GHCi.GHCiSandboxIO</tt> type class. Sets it to be the GHCi
--   monad if it is, throws an error otherwise.
setGHCiMonad :: GhcMonad m => String -> m ()

-- | Get the monad GHCi lifts user statements into.
getGHCiMonad :: GhcMonad m => m Name

-- | Return the bindings for the current interactive session.
getBindings :: GhcMonad m => m [TyThing]

-- | Return the instances for the current interactive session.
getInsts :: GhcMonad m => m ([ClsInst], [FamInst])
getNamePprCtx :: GhcMonad m => m NamePprCtx

-- | Takes a <a>ModuleName</a> and possibly a <a>UnitId</a>, and consults
--   the filesystem and package database to find the corresponding
--   <a>GenModule</a>, using the algorithm that is used for an
--   <tt>import</tt> declaration.
findModule :: GhcMonad m => ModuleName -> Maybe FastString -> m Module

-- | Like <a>findModule</a>, but differs slightly when the module refers to
--   a source file, and the file has not been loaded via <a>load</a>. In
--   this case, <a>findModule</a> will throw an error (module not loaded),
--   but <a>lookupModule</a> will check to see whether the module can also
--   be found in a package, and if so, that package <a>GenModule</a> will
--   be returned. If not, the usual module-not-found error will be thrown.
lookupModule :: GhcMonad m => ModuleName -> Maybe FastString -> m Module
findQualifiedModule :: GhcMonad m => PkgQual -> ModuleName -> m Module
lookupQualifiedModule :: GhcMonad m => PkgQual -> ModuleName -> m Module
renamePkgQualM :: GhcMonad m => ModuleName -> Maybe FastString -> m PkgQual
renameRawPkgQualM :: GhcMonad m => ModuleName -> RawPkgQual -> m PkgQual

-- | Check that a module is safe to import (according to Safe Haskell).
--   
--   We return True to indicate the import is safe and False otherwise
--   although in the False case an error may be thrown first.
isModuleTrusted :: GhcMonad m => Module -> m Bool

-- | Return if a module is trusted and the pkgs it depends on to be
--   trusted.
moduleTrustReqs :: GhcMonad m => Module -> m (Bool, Set UnitId)

-- | Returns all names in scope in the current interactive context
getNamesInScope :: GhcMonad m => m [Name]

-- | Returns all <a>RdrName</a>s in scope in the current interactive
--   context, excluding any that are internally-generated.
getRdrNamesInScope :: GhcMonad m => m [RdrName]

-- | get the GlobalRdrEnv for a session
getGRE :: GhcMonad m => m GlobalRdrEnv

-- | Returns <tt>True</tt> if the specified module is interpreted, and
--   hence has its full top-level scope available.
moduleIsInterpreted :: GhcMonad m => Module -> m Bool

-- | Looks up an identifier in the current interactive context (for :info)
--   Filter the instances by the ones whose tycons (or classes resp) are in
--   scope (qualified or otherwise). Otherwise we list a whole lot too
--   many! The exact choice of which ones to show, and which to hide, is a
--   judgement call. (see #1581)
getInfo :: GhcMonad m => Bool -> Name -> m (Maybe (TyThing, Fixity, [ClsInst], [FamInst], SDoc))
showModule :: GhcMonad m => ModSummary -> m String
moduleIsBootOrNotObjectLinkable :: GhcMonad m => ModSummary -> m Bool

-- | Retrieve all type and family instances in the environment, indexed by
--   <a>Name</a>. Each name's lists will contain every instance in which
--   that name is mentioned in the instance head.
getNameToInstancesIndex :: GhcMonad m => [Module] -> Maybe [Module] -> m (Messages TcRnMessage, Maybe (NameEnv ([ClsInst], [FamInst])))

-- | Get the type of an expression Returns the type as described by
--   <a>TcRnExprMode</a>
exprType :: GhcMonad m => TcRnExprMode -> String -> m Type

-- | How should we infer a type? See Note [TcRnExprMode]
data TcRnExprMode

-- | Instantiate inferred quantifiers only (:type)
TM_Inst :: TcRnExprMode

-- | Instantiate all quantifiers, and do eager defaulting (:type +d)
TM_Default :: TcRnExprMode

-- | Get the kind of a type
typeKind :: GhcMonad m => Bool -> String -> m (Type, Kind)

-- | Parses a string as an identifier, and returns the list of <a>Name</a>s
--   that the identifier can refer to in the current interactive context.
parseName :: GhcMonad m => String -> m (NonEmpty Name)

-- | Returns the <a>TyThing</a> for a <a>Name</a>. The <a>Name</a> may
--   refer to any entity known to GHC, including <a>Name</a>s defined using
--   <tt>runStmt</tt>.
lookupName :: GhcMonad m => Name -> m (Maybe TyThing)
data () => HValue

-- | Parse an expression, the parsed expression can be further processed
--   and passed to compileParsedExpr.
parseExpr :: GhcMonad m => String -> m (LHsExpr GhcPs)
compileParsedExpr :: GhcMonad m => LHsExpr GhcPs -> m HValue

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExpr :: GhcMonad m => String -> m HValue

-- | Compile an expression, run it and return the result as a Dynamic.
dynCompileExpr :: GhcMonad m => String -> m Dynamic
type ForeignHValue = ForeignRef HValue

-- | Compile an expression, run it, and deliver the resulting HValue.
compileExprRemote :: GhcMonad m => String -> m ForeignHValue

-- | Compile a parsed expression (before renaming), run it, and deliver the
--   resulting HValue.
compileParsedExprRemote :: GhcMonad m => LHsExpr GhcPs -> m ForeignHValue
getDocs :: GhcMonad m => Name -> m (Either GetDocsFailure (Maybe [HsDoc GhcRn], IntMap (HsDoc GhcRn)))

-- | Failure modes for <a>getDocs</a>.
data GetDocsFailure

-- | <a>nameModule_maybe</a> returned <a>Nothing</a>.
NameHasNoModule :: Name -> GetDocsFailure

-- | The module was loaded without <tt>-haddock</tt>,
NoDocsInIface :: Module -> Bool -> GetDocsFailure

-- | The <a>Name</a> was defined interactively.
InteractiveName :: GetDocsFailure
runTcInteractive :: HscEnv -> TcRn a -> IO (Messages TcRnMessage, Maybe a)

-- | Returns <tt>True</tt> if passed string is a statement.
isStmt :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string has an import declaration.
hasImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is an import declaration.
isImport :: ParserOpts -> String -> Bool

-- | Returns <tt>True</tt> if passed string is a declaration but <b><i>not
--   a splice</i></b>.
isDecl :: ParserOpts -> String -> Bool
data SingleStep
RunToCompletion :: SingleStep
SingleStep :: SingleStep
RunAndLogSteps :: SingleStep
data Resume
Resume :: String -> ForeignRef (ResumeContext [HValueRef]) -> ResumeBindings -> [Id] -> ForeignHValue -> Maybe BreakInfo -> SrcSpan -> String -> RemotePtr CostCentreStack -> [History] -> Int -> Resume
[resumeStmt] :: Resume -> String
[resumeContext] :: Resume -> ForeignRef (ResumeContext [HValueRef])
[resumeBindings] :: Resume -> ResumeBindings
[resumeFinalIds] :: Resume -> [Id]
[resumeApStack] :: Resume -> ForeignHValue
[resumeBreakInfo] :: Resume -> Maybe BreakInfo
[resumeSpan] :: Resume -> SrcSpan
[resumeDecl] :: Resume -> String
[resumeCCS] :: Resume -> RemotePtr CostCentreStack
[resumeHistory] :: Resume -> [History]
[resumeHistoryIx] :: Resume -> Int
data History
getHistorySpan :: GhcMonad m => History -> m SrcSpan
getHistoryModule :: History -> Module
abandon :: GhcMonad m => m Bool
abandonAll :: GhcMonad m => m Bool
getResumeContext :: GhcMonad m => m [Resume]
obtainTermFromId :: GhcMonad m => Int -> Bool -> Id -> m Term
obtainTermFromVal :: GhcMonad m => Int -> Bool -> Type -> a -> m Term
reconstructType :: HscEnv -> Int -> Id -> IO (Maybe Type)
modInfoModBreaks :: ModuleInfo -> ModBreaks

-- | All the information about the breakpoints for a module
data ModBreaks
ModBreaks :: ForeignRef BreakArray -> !Array BreakIndex SrcSpan -> !Array BreakIndex [OccName] -> !Array BreakIndex [String] -> !Array BreakIndex (RemotePtr CostCentre) -> IntMap CgBreakInfo -> RemotePtr ModuleName -> ModBreaks

-- | The array of flags, one per breakpoint, indicating which breakpoints
--   are enabled.
[modBreaks_flags] :: ModBreaks -> ForeignRef BreakArray

-- | An array giving the source span of each breakpoint.
[modBreaks_locs] :: ModBreaks -> !Array BreakIndex SrcSpan

-- | An array giving the names of the free variables at each breakpoint.
[modBreaks_vars] :: ModBreaks -> !Array BreakIndex [OccName]

-- | An array giving the names of the declarations enclosing each
--   breakpoint. See Note [Field modBreaks_decls]
[modBreaks_decls] :: ModBreaks -> !Array BreakIndex [String]

-- | Array pointing to cost centre for each breakpoint
[modBreaks_ccs] :: ModBreaks -> !Array BreakIndex (RemotePtr CostCentre)

-- | info about each breakpoint from the bytecode generator
[modBreaks_breakInfo] :: ModBreaks -> IntMap CgBreakInfo
[modBreaks_module] :: ModBreaks -> RemotePtr ModuleName

-- | Breakpoint index
type BreakIndex = Int
data BreakInfo
BreakInfo :: Module -> Int -> BreakInfo
[breakInfo_module] :: BreakInfo -> Module
[breakInfo_number] :: BreakInfo -> Int
back :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)
forward :: GhcMonad m => Int -> m ([Name], Int, SrcSpan, String)
setupBreakpoint :: GhcMonad m => HscEnv -> BreakInfo -> Int -> m ()
type Unit = GenUnit UnitId

-- | A Module is a pair of a <a>Unit</a> and a <a>ModuleName</a>.
type Module = GenModule Unit
mkModule :: u -> ModuleName -> GenModule u
pprModule :: IsLine doc => Module -> doc

-- | Module name (e.g. A.B.C)
moduleName :: GenModule unit -> ModuleName

-- | Unit the module belongs to
moduleUnit :: GenModule unit -> unit

-- | A unique, unambiguous name for something, containing information about
--   where that thing originated.
data Name
isExternalName :: Name -> Bool
nameModule :: HasDebugCallStack => Name -> Module

-- | print a <a>NamedThing</a>, adding parentheses if the name is an
--   operator.
pprParenSymName :: NamedThing a => a -> SDoc
nameSrcSpan :: Name -> SrcSpan

-- | A class allowing convenient access to the <a>Name</a> of various
--   datatypes
class NamedThing a
getOccName :: NamedThing a => a -> OccName
getName :: NamedThing a => a -> Name

-- | Reader Name
--   
--   Do not use the data constructors of RdrName directly: prefer the
--   family of functions that creates them, such as <a>mkRdrUnqual</a>
--   
--   <ul>
--   <li>Note: A Located RdrName will only have API Annotations if it is a
--   compound one, e.g.</li>
--   </ul>
--   
--   <pre>
--   `bar`
--   ( ~ )
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnOpen</a> <tt>'('</tt>
--   or <tt>'['</tt> or <tt>'[:'</tt>, <a>AnnClose</a> <tt>')'</tt> or
--   <tt>']'</tt> or <tt>':]'</tt>,, <a>AnnBackquote</a> <tt>'`'</tt>,
--   <a>AnnVal</a> <a>AnnTilde</a>,</li>
--   </ul>
data RdrName

-- | Unqualified name
--   
--   Used for ordinary, unqualified occurrences, e.g. <tt>x</tt>,
--   <tt>y</tt> or <tt>Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrUnqual</a>
Unqual :: OccName -> RdrName

-- | Qualified name
--   
--   A qualified name written by the user in <i>source</i> code. The module
--   isn't necessarily the module where the thing is defined; just the one
--   from which it is imported. Examples are <tt>Bar.x</tt>, <tt>Bar.y</tt>
--   or <tt>Bar.Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrQual</a>
Qual :: ModuleName -> OccName -> RdrName

-- | Identifier
type Id = Var
idType :: Id -> Kind

-- | <a>isImplicitId</a> tells whether an <a>Id</a>s info is implied by
--   other declarations, so we don't need to put its signature in an
--   interface file, even if it's mentioned in some other interface
--   unfolding.
isImplicitId :: Id -> Bool
isDeadBinder :: Id -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool
isLocalId :: Var -> Bool
isGlobalId :: Var -> Bool
isRecordSelector :: Id -> Bool
isPrimOpId :: Id -> Bool
isFCallId :: Id -> Bool
isClassOpId_maybe :: Id -> Maybe Class
isDataConWorkId :: Id -> Bool

-- | Get from either the worker or the wrapper <a>Id</a> to the
--   <a>DataCon</a>. Currently used only in the desugarer.
--   
--   INVARIANT: <tt>idDataCon (dataConWrapId d) = d</tt>: remember,
--   <a>dataConWrapId</a> can return either the wrapper or the worker
idDataCon :: Id -> DataCon

-- | Returns true if an application to n args diverges or throws an
--   exception See Note [Dead ends] in <a>GHC.Types.Demand</a>.
isDeadEndId :: Var -> Bool
isDictonaryId :: Id -> Bool

-- | If the <a>Id</a> is that for a record selector, extract the
--   <a>sel_tycon</a>. Panic otherwise.
recordSelectorTyCon :: Id -> RecSelParent

-- | TyCons represent type constructors. Type constructors are introduced
--   by things such as:
--   
--   1) Data declarations: <tt>data Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor of kind <tt>*</tt>
--   
--   2) Type synonyms: <tt>type Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor
--   
--   3) Newtypes: <tt>newtype Foo a = MkFoo ...</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>* -&gt; *</tt>
--   
--   4) Class declarations: <tt>class Foo where</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>*</tt>
--   
--   This data type also encodes a number of primitive, built in type
--   constructors such as those for function and tuple types.
--   
--   If you edit this type, you may need to update the GHC formalism See
--   Note [GHC Formalism] in GHC.Core.Lint
data TyCon

-- | TyVar binders
tyConTyVars :: TyCon -> [TyVar]

-- | As <a>tyConDataCons_maybe</a>, but returns the empty list of
--   constructors if no constructors could be found
tyConDataCons :: TyCon -> [DataCon]

-- | Arity
tyConArity :: TyCon -> Arity

-- | Is this <a>TyCon</a> that for a class instance?
isClassTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a> representing a regular H98 type synonym
--   (<tt>type</tt>)?
isTypeSynonymTyCon :: TyCon -> Bool

-- | Is this a synonym <a>TyCon</a> that can have may have further
--   instances appear?
isTypeFamilyTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a <tt>newtype</tt>
isNewTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent something that cannot be defined in
--   Haskell?
isPrimTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family?
isFamilyTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family
--   with instances?
isOpenFamilyTyCon :: TyCon -> Bool

-- | Is this an open type family TyCon?
isOpenTypeFamilyTyCon :: TyCon -> Bool

-- | If this <a>TyCon</a> is that for a class instance, return the class it
--   is for. Otherwise returns <tt>Nothing</tt>
tyConClass_maybe :: TyCon -> Maybe Class

-- | Extract the information pertaining to the right hand side of a type
--   synonym (<tt>type</tt>) declaration.
synTyConRhs_maybe :: TyCon -> Maybe Type

-- | Extract the <a>TyVar</a>s bound by a vanilla type synonym and the
--   corresponding (unsubstituted) right hand side.
synTyConDefn_maybe :: TyCon -> Maybe ([TyVar], Type)

-- | Kind of this TyCon
tyConKind :: TyCon -> Kind

-- | Type or kind Variable
type TyVar = Var
alphaTyVars :: [TyVar]

-- | A data constructor
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnClose</a>,<a>AnnComma</a></li>
--   </ul>
data DataCon
dataConType :: DataCon -> Type

-- | The type constructor that we are building via this data constructor
dataConTyCon :: DataCon -> TyCon

-- | The labels for the fields of this particular <a>DataCon</a>
dataConFieldLabels :: DataCon -> [FieldLabel]

-- | Should the <a>DataCon</a> be presented infix?
dataConIsInfix :: DataCon -> Bool

-- | Vanilla <a>DataCon</a>s are those that are nice boring Haskell 98
--   constructors
isVanillaDataCon :: DataCon -> Bool

-- | The user-declared type of the data constructor in the nice-to-read
--   form:
--   
--   <pre>
--   T :: forall a b. a -&gt; b -&gt; T [a]
--   </pre>
--   
--   rather than:
--   
--   <pre>
--   T :: forall a c. forall b. (c~[a]) =&gt; a -&gt; b -&gt; T c
--   </pre>
--   
--   The type variables are quantified in the order that the user wrote
--   them. See <tt>Note [DataCon user type variable binders]</tt>.
--   
--   NB: If the constructor is part of a data instance, the result type
--   mentions the family tycon, not the internal one.
dataConWrapperType :: DataCon -> Type

-- | Strictness/unpack annotations, from user; or, for imported DataCons,
--   from the interface file The list is in one-to-one correspondence with
--   the arity of the <a>DataCon</a>
dataConSrcBangs :: DataCon -> [HsSrcBang]
data StrictnessMark
MarkedStrict :: StrictnessMark
NotMarkedStrict :: StrictnessMark
isMarkedStrict :: StrictnessMark -> Bool
data Class
classMethods :: Class -> [Id]
classSCTheta :: Class -> [PredType]
classTvsFds :: Class -> ([TyVar], [FunDep TyVar])
classATs :: Class -> [TyCon]
pprFundeps :: Outputable a => [FunDep a] -> SDoc

-- | A type-class instance. Note that there is some tricky laziness at work
--   here. See Note [ClsInst laziness and the rough-match fields] for more
--   details.
data ClsInst
instanceDFunId :: ClsInst -> DFunId
pprInstance :: ClsInst -> SDoc
pprInstanceHdr :: ClsInst -> SDoc

-- | Pretty-prints a <a>FamInst</a> (type/data family instance) with its
--   defining location.
pprFamInst :: FamInst -> SDoc
data FamInst
data Type

-- | Take a ForAllTy apart, returning the list of tycovars and the result
--   type. This always succeeds, even if it returns only an empty list.
--   Note that the result type returned may have free variables that were
--   bound by a forall.
splitForAllTyCoVars :: Type -> ([TyCoVar], Type)

-- | Extract the function result type and panic if that is not possible
funResultTy :: HasDebugCallStack => Type -> Type
pprParendType :: Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | A type of the form <tt>p</tt> of constraint kind represents a value
--   whose type is the Haskell predicate <tt>p</tt>, where a predicate is
--   what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]
pprForAll :: [ForAllTyBinder] -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
parseInstanceHead :: GhcMonad m => String -> m Type
getInstancesForType :: GhcMonad m => Type -> m [ClsInst]

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See
--   <a>GHC.Tc.Utils.Env</a> for how to retrieve a <a>TyThing</a> given a
--   <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
defaultFixity :: Fixity
maxPrecedence :: Int
negateFixity :: Fixity
compareFixity :: Fixity -> Fixity -> (Bool, Bool)

-- | Captures the fixity of declarations as they are parsed. This is not
--   necessarily the same as the fixity declaration, as the normal fixity
--   may be overridden using parens or backticks.
data LexicalFixity
Prefix :: LexicalFixity
Infix :: LexicalFixity

-- | Source Location
data SrcLoc
RealSrcLoc :: !RealSrcLoc -> !Maybe BufPos -> SrcLoc
UnhelpfulLoc :: !FastString -> SrcLoc

-- | Real Source Location
--   
--   Represents a single point within a file
data RealSrcLoc
mkSrcLoc :: FastString -> Int -> Int -> SrcLoc

-- | Built-in "bad" <a>RealSrcLoc</a> values for particular locations
noSrcLoc :: SrcLoc

-- | Gives the filename of the <a>RealSrcLoc</a>
srcLocFile :: RealSrcLoc -> FastString

-- | Raises an error when used on a "bad" <a>RealSrcLoc</a>
srcLocLine :: RealSrcLoc -> Int

-- | Raises an error when used on a "bad" <a>RealSrcLoc</a>
srcLocCol :: RealSrcLoc -> Int

-- | Source Span
--   
--   A <a>SrcSpan</a> identifies either a specific portion of a text file
--   or a human-readable description of a location.
data SrcSpan
RealSrcSpan :: !RealSrcSpan -> !Maybe BufSpan -> SrcSpan
UnhelpfulSpan :: !UnhelpfulSpanReason -> SrcSpan

-- | A <a>RealSrcSpan</a> delimits a portion of a text file. It could be
--   represented by a pair of (line,column) coordinates, but in fact we
--   optimise slightly by using more compact representations for
--   single-line and zero-length spans, both of which are quite common.
--   
--   The end position is defined to be the column <i>after</i> the end of
--   the span. That is, a span of (1,1)-(1,2) is one character long, and a
--   span of (1,1)-(1,1) is zero characters long.
--   
--   Real Source Span
data RealSrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkSrcSpan :: SrcLoc -> SrcLoc -> SrcSpan

-- | Create a <a>SrcSpan</a> corresponding to a single point
srcLocSpan :: SrcLoc -> SrcSpan

-- | Test if a <a>SrcSpan</a> is "good", i.e. has precise location
--   information
isGoodSrcSpan :: SrcSpan -> Bool

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
noSrcSpan :: SrcSpan

-- | Returns the location at the start of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanStart :: SrcSpan -> SrcLoc

-- | Returns the location at the end of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanEnd :: SrcSpan -> SrcLoc
srcSpanFile :: RealSrcSpan -> FastString
srcSpanStartLine :: RealSrcSpan -> Int
srcSpanEndLine :: RealSrcSpan -> Int
srcSpanStartCol :: RealSrcSpan -> Int
srcSpanEndCol :: RealSrcSpan -> Int

-- | We attach SrcSpans to lots of things, so let's have a datatype for it.
data GenLocated l e
L :: l -> e -> GenLocated l e
type Located = GenLocated SrcSpan
type RealLocated = GenLocated RealSrcSpan
noLoc :: e -> Located e
mkGeneralLocated :: String -> e -> Located e
getLoc :: GenLocated l e -> l
unLoc :: GenLocated l e -> e
getRealSrcSpan :: RealLocated a -> RealSrcSpan
unRealSrcSpan :: RealLocated a -> a

-- | Tests whether the two located things are equal
eqLocated :: Eq a => GenLocated l a -> GenLocated l a -> Bool

-- | Tests the ordering of the two located things
cmpLocated :: Ord a => GenLocated l a -> GenLocated l a -> Ordering
combineLocs :: Located a -> Located b -> SrcSpan

-- | Combine locations from two <a>Located</a> things and add them to a
--   third thing
addCLoc :: Located a -> Located b -> c -> Located c

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
leftmost_largest :: SrcSpan -> SrcSpan -> Ordering

-- | Strategies for ordering <a>SrcSpan</a>s
rightmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Determines whether a span encloses a given line and column index
spans :: SrcSpan -> (Int, Int) -> Bool

-- | Determines whether a span is enclosed by another one
isSubspanOf :: SrcSpan -> SrcSpan -> Bool

-- | GHC's own exception type error messages all take the form:
--   
--   <pre>
--   &lt;location&gt;: &lt;error&gt;
--   
--   </pre>
--   
--   If the location is on the command line, or in GHC itself, then
--   &lt;location&gt;="ghc". All of the error types below correspond to a
--   &lt;location&gt; of "ghc", except for ProgramError (where the string
--   is assumed to contain a location already, so we don't print one).
data GhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
Signal :: Int -> GhcException

-- | Prints the short usage msg after the error
UsageError :: String -> GhcException

-- | A problem with the command line arguments, but don't print usage.
CmdLineError :: String -> GhcException

-- | The <tt>impossible</tt> happened.
Panic :: String -> GhcException
PprPanic :: String -> SDoc -> GhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
Sorry :: String -> GhcException
PprSorry :: String -> SDoc -> GhcException

-- | An installation problem.
InstallationError :: String -> GhcException

-- | An error in the user's code, probably.
ProgramError :: String -> GhcException
PprProgramError :: String -> SDoc -> GhcException

-- | Append a description of the given exception to this string.
showGhcException :: SDocContext -> GhcException -> ShowS

-- | An error thrown if the GHC API is used in an incorrect fashion.
newtype GhcApiError
GhcApiError :: String -> GhcApiError
data Token

-- | Return module source as token stream, including comments.
--   
--   A <a>GenModule</a> can be turned into a <a>ModSummary</a> using
--   <a>getModSummary</a> if your session is fully initialised. Throws a
--   <a>SourceError</a> on parse error.
getTokenStream :: ModSummary -> IO [Located Token]

-- | Give even more information on the source than <a>getTokenStream</a>
--   This function allows reconstructing the source completely with
--   <a>showRichTokenStream</a>.
getRichTokenStream :: ModSummary -> IO [(Located Token, String)]

-- | Take a rich token stream such as produced from
--   <a>getRichTokenStream</a> and return source code almost identical to
--   the original code (except for insignificant whitespace.)
showRichTokenStream :: [(Located Token, String)] -> String

-- | Given a source location and a StringBuffer corresponding to this
--   location, return a rich token stream with the source associated to the
--   tokens.
addSourceToTokens :: RealSrcLoc -> StringBuffer -> [Located Token] -> [(Located Token, String)]

-- | A pure interface to the module parser.
parser :: String -> DynFlags -> FilePath -> (WarningMessages, Either ErrorMessages (Located (HsModule GhcPs)))

-- | Exact print annotations exist so that tools can perform source to
--   source conversions of Haskell code. They are used to keep track of the
--   various syntactic keywords that are not otherwise captured in the AST.
--   
--   The wiki page describing this feature is
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/api-annotations</a>
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/implementing-trees-that-grow/in-tree-api-annotations</a>
--   
--   Note: in general the names of these are taken from the corresponding
--   token, unless otherwise noted See Note [exact print annotations] above
--   for details of the usage
data AnnKeywordId
AnnAnyclass :: AnnKeywordId
AnnAs :: AnnKeywordId

-- | <tt>!</tt>
AnnBang :: AnnKeywordId

-- | '`'
AnnBackquote :: AnnKeywordId
AnnBy :: AnnKeywordId

-- | case or lambda case
AnnCase :: AnnKeywordId

-- | lambda cases
AnnCases :: AnnKeywordId
AnnClass :: AnnKeywordId

-- | '#)' or '#-}' etc
AnnClose :: AnnKeywordId

-- | '|)'
AnnCloseB :: AnnKeywordId

-- | '|)', unicode variant
AnnCloseBU :: AnnKeywordId

-- | '}'
AnnCloseC :: AnnKeywordId

-- | '|]'
AnnCloseQ :: AnnKeywordId

-- | '|]', unicode variant
AnnCloseQU :: AnnKeywordId

-- | ')'
AnnCloseP :: AnnKeywordId

-- | '#)'
AnnClosePH :: AnnKeywordId

-- | ']'
AnnCloseS :: AnnKeywordId
AnnColon :: AnnKeywordId

-- | as a list separator
AnnComma :: AnnKeywordId

-- | in a RdrName for a tuple
AnnCommaTuple :: AnnKeywordId

-- | '=&gt;'
AnnDarrow :: AnnKeywordId

-- | '=&gt;', unicode variant
AnnDarrowU :: AnnKeywordId
AnnData :: AnnKeywordId

-- | '::'
AnnDcolon :: AnnKeywordId

-- | '::', unicode variant
AnnDcolonU :: AnnKeywordId
AnnDefault :: AnnKeywordId
AnnDeriving :: AnnKeywordId
AnnDo :: AnnKeywordId

-- | <a>.</a>
AnnDot :: AnnKeywordId

-- | '..'
AnnDotdot :: AnnKeywordId
AnnElse :: AnnKeywordId
AnnEqual :: AnnKeywordId
AnnExport :: AnnKeywordId
AnnFamily :: AnnKeywordId
AnnForall :: AnnKeywordId

-- | Unicode variant
AnnForallU :: AnnKeywordId
AnnForeign :: AnnKeywordId

-- | for function name in matches where there are multiple equations for
--   the function.
AnnFunId :: AnnKeywordId
AnnGroup :: AnnKeywordId

-- | for CType
AnnHeader :: AnnKeywordId
AnnHiding :: AnnKeywordId
AnnIf :: AnnKeywordId
AnnImport :: AnnKeywordId
AnnIn :: AnnKeywordId

-- | 'infix' or 'infixl' or 'infixr'
AnnInfix :: AnnKeywordId
AnnInstance :: AnnKeywordId
AnnLam :: AnnKeywordId

-- | '&lt;-'
AnnLarrow :: AnnKeywordId

-- | '&lt;-', unicode variant
AnnLarrowU :: AnnKeywordId
AnnLet :: AnnKeywordId

-- | The <tt>⊸</tt> unicode arrow
AnnLollyU :: AnnKeywordId
AnnMdo :: AnnKeywordId

-- | <a>-</a>
AnnMinus :: AnnKeywordId
AnnModule :: AnnKeywordId
AnnNewtype :: AnnKeywordId

-- | where a name loses its location in the AST, this carries it
AnnName :: AnnKeywordId
AnnOf :: AnnKeywordId

-- | '{-# DEPRECATED' etc. Opening of pragmas where the capitalisation of
--   the string can be changed by the user. The actual text used is stored
--   in a <tt>SourceText</tt> on the relevant pragma item.
AnnOpen :: AnnKeywordId

-- | '(|'
AnnOpenB :: AnnKeywordId

-- | '(|', unicode variant
AnnOpenBU :: AnnKeywordId

-- | '{'
AnnOpenC :: AnnKeywordId

-- | '[e|' or '[e||'
AnnOpenE :: AnnKeywordId

-- | '[|'
AnnOpenEQ :: AnnKeywordId

-- | '[|', unicode variant
AnnOpenEQU :: AnnKeywordId

-- | '('
AnnOpenP :: AnnKeywordId

-- | '['
AnnOpenS :: AnnKeywordId

-- | '(#'
AnnOpenPH :: AnnKeywordId

-- | prefix <a>$</a> -- TemplateHaskell
AnnDollar :: AnnKeywordId

-- | prefix <a>$$</a> -- TemplateHaskell
AnnDollarDollar :: AnnKeywordId
AnnPackageName :: AnnKeywordId
AnnPattern :: AnnKeywordId

-- | <tt>%</tt> -- for HsExplicitMult
AnnPercent :: AnnKeywordId

-- | '%1' -- for HsLinearArrow
AnnPercentOne :: AnnKeywordId
AnnProc :: AnnKeywordId
AnnQualified :: AnnKeywordId

-- | <tt>-&gt;</tt>
AnnRarrow :: AnnKeywordId

-- | <tt>-&gt;</tt>, unicode variant
AnnRarrowU :: AnnKeywordId
AnnRec :: AnnKeywordId
AnnRole :: AnnKeywordId
AnnSafe :: AnnKeywordId

-- | ';'
AnnSemi :: AnnKeywordId

-- | '''
AnnSimpleQuote :: AnnKeywordId
AnnSignature :: AnnKeywordId

-- | <tt>static</tt>
AnnStatic :: AnnKeywordId
AnnStock :: AnnKeywordId
AnnThen :: AnnKeywordId

-- | double '''
AnnThTyQuote :: AnnKeywordId

-- | <a>~</a>
AnnTilde :: AnnKeywordId
AnnType :: AnnKeywordId

-- | <tt>()</tt> for types
AnnUnit :: AnnKeywordId
AnnUsing :: AnnKeywordId

-- | e.g. INTEGER
AnnVal :: AnnKeywordId

-- | String value, will need quotes when output
AnnValStr :: AnnKeywordId

-- | '|'
AnnVbar :: AnnKeywordId

-- | <tt>via</tt>
AnnVia :: AnnKeywordId
AnnWhere :: AnnKeywordId

-- | <tt>-&lt;</tt>
Annlarrowtail :: AnnKeywordId

-- | <tt>-&lt;</tt>, unicode variant
AnnlarrowtailU :: AnnKeywordId

-- | <tt>-&gt;</tt>
Annrarrowtail :: AnnKeywordId

-- | <tt>-&gt;</tt>, unicode variant
AnnrarrowtailU :: AnnKeywordId

-- | <tt>-&lt;&lt;</tt>
AnnLarrowtail :: AnnKeywordId

-- | <tt>-&lt;&lt;</tt>, unicode variant
AnnLarrowtailU :: AnnKeywordId

-- | <tt>&gt;&gt;-</tt>
AnnRarrowtail :: AnnKeywordId

-- | <tt>&gt;&gt;-</tt>, unicode variant
AnnRarrowtailU :: AnnKeywordId
data EpaComment
EpaComment :: EpaCommentTok -> RealSrcSpan -> EpaComment
[ac_tok] :: EpaComment -> EpaCommentTok

-- | The location of the prior token, used in exact printing. The
--   <a>EpaComment</a> appears as an <a>LEpaComment</a> containing its
--   location. The difference between the end of the prior token and the
--   start of this location is used for the spacing when exact printing the
--   comment.
[ac_prior_tok] :: EpaComment -> RealSrcSpan
cyclicModuleErr :: [ModuleGraphNode] -> SDoc
instance GHC.Show.Show GHC.GhcApiError
instance GHC.Exception.Type.Exception GHC.GhcApiError
instance GHC.DesugaredMod GHC.DesugaredModule
instance GHC.TypecheckedMod GHC.TypecheckedModule
instance GHC.TypecheckedMod GHC.DesugaredModule
instance GHC.ParsedMod GHC.DesugaredModule
instance GHC.ParsedMod GHC.TypecheckedModule
instance GHC.Utils.Outputable.Outputable GHC.CoreModule
instance GHC.ParsedMod GHC.ParsedModule

module GHC.Runtime.Debugger

-- | The :print &amp; friends commands
pprintClosureCommand :: GhcMonad m => Bool -> Bool -> String -> m ()
showTerm :: GhcMonad m => Term -> m SDoc
pprTypeAndContents :: GhcMonad m => Id -> m SDoc

module GHC.Driver.MakeFile
doMkDependHS :: GhcMonad m => [FilePath] -> m ()


-- | This is the driver for the 'ghc --backpack' mode, which is a
--   reimplementation of the "package manager" bits of Backpack directly in
--   GHC. The basic method of operation is to compile packages and then
--   directly insert them into GHC's in memory database.
--   
--   The compilation products of this mode aren't really suitable for
--   Cabal, because GHC makes up component IDs for the things it builds and
--   doesn't serialize out the database contents. But it's still handy for
--   constructing tests.
module GHC.Driver.Backpack

-- | Entry point to compile a Backpack file.
doBackpack :: [FilePath] -> Ghc ()
instance GHC.Classes.Eq GHC.Driver.Backpack.SessionType
instance GHC.Driver.Session.HasDynFlags GHC.Driver.Backpack.BkpM
instance GHC.Utils.Logger.HasLogger GHC.Driver.Backpack.BkpM
instance GHC.Driver.Monad.GhcMonad GHC.Driver.Backpack.BkpM
