<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>GHC.Types.Name.Shape</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">ghc-9.6.6: The GHC API</span><ul class="links" id="page-menu"><li><a href="src/GHC.Types.Name.Shape.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">GHC.Types.Name.Shape</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:NameShape">NameShape</a> = <a href="#v:NameShape">NameShape</a> {<ul class="subs"><li><a href="#v:ns_mod_name">ns_mod_name</a> :: <a href="Language-Haskell-Syntax-Module-Name.html#t:ModuleName" title="Language.Haskell.Syntax.Module.Name">ModuleName</a></li><li><a href="#v:ns_exports">ns_exports</a> :: [<a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a>]</li><li><a href="#v:ns_map">ns_map</a> :: <a href="GHC-Types-Name-Occurrence.html#t:OccEnv" title="GHC.Types.Name.Occurrence">OccEnv</a> <a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a></li></ul>}</li><li class="src short"><a href="#v:emptyNameShape">emptyNameShape</a> :: <a href="Language-Haskell-Syntax-Module-Name.html#t:ModuleName" title="Language.Haskell.Syntax.Module.Name">ModuleName</a> -&gt; <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></li><li class="src short"><a href="#v:mkNameShape">mkNameShape</a> :: <a href="Language-Haskell-Syntax-Module-Name.html#t:ModuleName" title="Language.Haskell.Syntax.Module.Name">ModuleName</a> -&gt; [<a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a>] -&gt; <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></li><li class="src short"><a href="#v:extendNameShape">extendNameShape</a> :: <a href="GHC-Driver-Env-Types.html#t:HscEnv" title="GHC.Driver.Env.Types">HscEnv</a> -&gt; <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a> -&gt; [<a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a>] -&gt; <a href="GHC-Prelude-Basic.html#t:IO" title="GHC.Prelude.Basic">IO</a> (<a href="GHC-Prelude-Basic.html#t:Either" title="GHC.Prelude.Basic">Either</a> <a href="GHC-Utils-Outputable.html#t:SDoc" title="GHC.Utils.Outputable">SDoc</a> <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a>)</li><li class="src short"><a href="#v:nameShapeExports">nameShapeExports</a> :: <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a> -&gt; [<a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a>]</li><li class="src short"><a href="#v:substNameShape">substNameShape</a> :: <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a> -&gt; <a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a> -&gt; <a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a></li><li class="src short"><a href="#v:maybeSubstNameShape">maybeSubstNameShape</a> :: <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a> -&gt; <a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a> -&gt; <a href="GHC-Prelude-Basic.html#t:Maybe" title="GHC.Prelude.Basic">Maybe</a> <a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:NameShape" class="def">NameShape</a> <a href="src/GHC.Tc.Types.html#NameShape" class="link">Source</a> <a href="#t:NameShape" class="selflink">#</a></p><div class="doc"><p>A <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code> is a substitution on <code><a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a></code>s that can be used
 to refine the identities of a hole while we are renaming interfaces
 (see <a href="GHC-Iface-Rename.html">GHC.Iface.Rename</a>).  Specifically, a <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code> for
 <code>ns_module_name</code> <code>A</code>, defines a mapping from <code>{A.T}</code>
 (for some <code><a href="GHC-Types-Name-Occurrence.html#t:OccName" title="GHC.Types.Name.Occurrence">OccName</a></code> <code>T</code>) to some arbitrary other <code><a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a></code>.</p><p>The most intriguing thing about a <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code>, however, is
 how it's constructed.  A <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code> is *implied* by the
 exported <code><a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a></code>s of the implementor of an interface:
 if an implementor of signature <code>&lt;H&gt;</code> exports <code>M.T</code>, you implicitly
 define a substitution from <code>{H.T}</code> to <code>M.T</code>.  So a <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code>
 is computed from the list of <code><a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a></code>s that are exported
 by the implementation of a module, or successively merged
 together by the export lists of signatures which are joining
 together.</p><p>It's not the most obvious way to go about doing this, but it
 does seem to work!</p><p>NB: Can't boot this and put it in NameShape because then we
 start pulling in too many DynFlags things.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:NameShape" class="def">NameShape</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:ns_mod_name" class="def">ns_mod_name</a> :: <a href="Language-Haskell-Syntax-Module-Name.html#t:ModuleName" title="Language.Haskell.Syntax.Module.Name">ModuleName</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:ns_exports" class="def">ns_exports</a> :: [<a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a>]</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:ns_map" class="def">ns_map</a> :: <a href="GHC-Types-Name-Occurrence.html#t:OccEnv" title="GHC.Types.Name.Occurrence">OccEnv</a> <a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a></dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><a id="v:emptyNameShape" class="def">emptyNameShape</a> :: <a href="Language-Haskell-Syntax-Module-Name.html#t:ModuleName" title="Language.Haskell.Syntax.Module.Name">ModuleName</a> -&gt; <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a> <a href="src/GHC.Types.Name.Shape.html#emptyNameShape" class="link">Source</a> <a href="#v:emptyNameShape" class="selflink">#</a></p><div class="doc"><p>Create an empty <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code> (i.e., the renaming that
 would occur with an implementing module with no exports)
 for a specific hole <code>mod_name</code>.</p></div></div><div class="top"><p class="src"><a id="v:mkNameShape" class="def">mkNameShape</a> :: <a href="Language-Haskell-Syntax-Module-Name.html#t:ModuleName" title="Language.Haskell.Syntax.Module.Name">ModuleName</a> -&gt; [<a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a>] -&gt; <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a> <a href="src/GHC.Types.Name.Shape.html#mkNameShape" class="link">Source</a> <a href="#v:mkNameShape" class="selflink">#</a></p><div class="doc"><p>Create a <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code> corresponding to an implementing
 module for the hole <code>mod_name</code> that exports a list of <code><a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a></code>s.</p></div></div><div class="top"><p class="src"><a id="v:extendNameShape" class="def">extendNameShape</a> :: <a href="GHC-Driver-Env-Types.html#t:HscEnv" title="GHC.Driver.Env.Types">HscEnv</a> -&gt; <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a> -&gt; [<a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a>] -&gt; <a href="GHC-Prelude-Basic.html#t:IO" title="GHC.Prelude.Basic">IO</a> (<a href="GHC-Prelude-Basic.html#t:Either" title="GHC.Prelude.Basic">Either</a> <a href="GHC-Utils-Outputable.html#t:SDoc" title="GHC.Utils.Outputable">SDoc</a> <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a>) <a href="src/GHC.Types.Name.Shape.html#extendNameShape" class="link">Source</a> <a href="#v:extendNameShape" class="selflink">#</a></p><div class="doc"><p>Given an existing <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code>, merge it with a list of <code><a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a></code>s
 with Backpack style mix-in linking.  This is used solely when merging
 signatures together: we successively merge the exports of each
 signature until we have the final, full exports of the merged signature.</p><p>What makes this operation nontrivial is what we are supposed to do when
 we want to merge in an export for M.T when we already have an existing
 export {H.T}.  What should happen in this case is that {H.T} should be
 unified with <code>M.T</code>: we've determined a more *precise* identity for the
 export at <code><a href="GHC-Types-Name-Occurrence.html#t:OccName" title="GHC.Types.Name.Occurrence">OccName</a></code> <code>T</code>.</p><p>Note that we don't do unrestricted unification: only name holes from
 <code>ns_mod_name ns</code> are flexible.  This is because we have a much more
 restricted notion of shaping than in Backpack'14: we do shaping
 *as* we do type-checking.  Thus, once we shape a signature, its
 exports are *final* and we're not allowed to refine them further,</p></div></div><div class="top"><p class="src"><a id="v:nameShapeExports" class="def">nameShapeExports</a> :: <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a> -&gt; [<a href="GHC-Types-Avail.html#t:AvailInfo" title="GHC.Types.Avail">AvailInfo</a>] <a href="src/GHC.Types.Name.Shape.html#nameShapeExports" class="link">Source</a> <a href="#v:nameShapeExports" class="selflink">#</a></p><div class="doc"><p>The export list associated with this <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code> (i.e., what
 the exports of an implementing module which induces this <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code>
 would be.)</p></div></div><div class="top"><p class="src"><a id="v:substNameShape" class="def">substNameShape</a> :: <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a> -&gt; <a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a> -&gt; <a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a> <a href="src/GHC.Types.Name.Shape.html#substNameShape" class="link">Source</a> <a href="#v:substNameShape" class="selflink">#</a></p><div class="doc"><p>Given a <code><a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a></code>, substitute it according to the <code><a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a></code> implied
 substitution, i.e. map <code>{A.T}</code> to <code>M.T</code>, if the implementing module
 exports <code>M.T</code>.</p></div></div><div class="top"><p class="src"><a id="v:maybeSubstNameShape" class="def">maybeSubstNameShape</a> :: <a href="GHC-Types-Name-Shape.html#t:NameShape" title="GHC.Types.Name.Shape">NameShape</a> -&gt; <a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a> -&gt; <a href="GHC-Prelude-Basic.html#t:Maybe" title="GHC.Prelude.Basic">Maybe</a> <a href="GHC-Types-Name.html#t:Name" title="GHC.Types.Name">Name</a> <a href="src/GHC.Types.Name.Shape.html#maybeSubstNameShape" class="link">Source</a> <a href="#v:maybeSubstNameShape" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="GHC-Types-Name-Shape.html#v:substNameShape" title="GHC.Types.Name.Shape">substNameShape</a></code>, but returns <code>Nothing</code> if no substitution
 works.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>