<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>GHC.Stg.CSE</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">ghc-9.6.6: The GHC API</span><ul class="links" id="page-menu"><li><a href="src/GHC.Stg.CSE.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">GHC.Stg.CSE</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Note [CSE for Stg]
~~~~~~~~~~~~~~~~~~</p><p>This module implements a simple common subexpression elimination pass for STG.
This is useful because there are expressions that we want to common up (because
they are operationally equivalent), but that we cannot common up in Core, because
their types differ.
This was originally reported as #9291.</p><p>There are two types of common code occurrences that we aim for, see
Note [Case 1: CSEing allocated closures] and
Note [Case 2: CSEing case binders] below.</p><p>Note [Case 1: CSEing allocated closures]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>The first kind of CSE opportunity we aim for is generated by this Haskell code:</p><p>bar :: a -&gt; (Either Int a, Either Bool a)
    bar x = (Right x, Right x)</p><p>which produces this Core:</p><p>bar :: forall a. a -&gt; (Either Int a, Either Bool a)
    bar <code>a x = (Right </code>Int <code>a x, Right </code>Bool @a x)</p><p>where the two components of the tuple are different terms, and cannot be
commoned up (easily). On the STG level we have</p><p>bar [x] = let c1 = Right [x]
                  c2 = Right [x]
              in (c1,c2)</p><p>and now it is obvious that we can write</p><p>bar [x] = let c1 = Right [x]
              in (c1,c1)</p><p>instead.</p><p>Note [Case 2: CSEing case binders]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>The second kind of CSE opportunity we aim for is more interesting, and
came up in #9291 and #5344: The Haskell code</p><p>foo :: Either Int a -&gt; Either Bool a
    foo (Right x) = Right x
    foo _         = Left False</p><p>produces this Core</p><p>foo :: forall a. Either Int a -&gt; Either Bool a
    foo <code>a e = case e of b { Left n -&gt; &#8230;
                           , Right x -&gt; Right </code>Bool @a x }</p><p>where we cannot CSE `Right <code>Bool </code>a x` with the case binder <code>b</code> as they have
different types. But in STG we have</p><p>foo [e] = case e of b { Left [n] -&gt; &#8230;
                          , Right [x] -&gt; Right [x] }</p><p>and nothing stops us from transforming that to</p><p>foo [e] = case e of b { Left [n] -&gt; &#8230;
                          , Right [x] -&gt; b}</p><p>Note [StgCse after unarisation]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>Consider two unboxed sum terms:</p><p>(# 1 | #) :: (# Int | Int# #)
    (# 1 | #) :: (# Int | Int  #)</p><p>These two terms are not equal as they unarise to different unboxed
tuples. However if we run StgCse before Unarise, it'll think the two
terms (# 1 | #) are equal, and replace one of these with a binder to
the other. That's bad -- #15300.</p><p>Solution: do unarise first.</p></div></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:stgCse" class="def">stgCse</a> :: [<a href="GHC-Stg-Syntax.html#t:InStgTopBinding" title="GHC.Stg.Syntax">InStgTopBinding</a>] -&gt; [<a href="GHC-Stg-Syntax.html#t:OutStgTopBinding" title="GHC.Stg.Syntax">OutStgTopBinding</a>] <a href="src/GHC.Stg.CSE.html#stgCse" class="link">Source</a> <a href="#v:stgCse" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>