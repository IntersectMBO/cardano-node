<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>GHC.Stg.FVs</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">ghc-9.6.6: The GHC API</span><ul class="links" id="page-menu"><li><a href="src/GHC.Stg.FVs.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">GHC.Stg.FVs</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Non-global free variable analysis on STG terms. This pass annotates
non-top-level closure bindings with captured variables. Global variables are not
captured. For example, in a top-level binding like (pseudo-STG)</p><p>f = [x,y] .
      let g = [p] . reverse (x ++ p)
      in g y</p><p>In g, <code><a href="GHC-Prelude-Basic.html#v:reverse" title="GHC.Prelude.Basic">reverse</a></code> and <code><a href="GHC-Prelude-Basic.html#v:-43--43-" title="GHC.Prelude.Basic">(++)</a></code> are global variables so they're not considered free.
<code>p</code> is an argument, so <code>x</code> is the only actual free variable here. The annotated
version is thus:</p><p>f = [x,y] .
      let g = [x] [p] . reverse (x ++ p)
      in g y</p><p>Note that non-top-level recursive bindings are also considered free within the
group:</p><p>map = {} r [f xs0]
      let {
        Rec {
          go = {f, go} r [xs1]
            case xs1 of {
              [] -&gt; [] [];
              : x xs2 -&gt;
                  let { xs' = {go, xs2} u [] go xs2; } in
                  let { x' = {f, x} u [] f x; } in
                  : [x' xs'];
            };
        end Rec }
      } in go xs0;</p><p>Here go is free in its RHS.</p><p>Top-level closure bindings never capture variables as all of their free
variables are global.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:depSortWithAnnotStgPgm">depSortWithAnnotStgPgm</a> :: <a href="GHC-Unit-Types.html#t:Module" title="GHC.Unit.Types">Module</a> -&gt; [<a href="GHC-Stg-Syntax.html#t:StgTopBinding" title="GHC.Stg.Syntax">StgTopBinding</a>] -&gt; [<a href="GHC-Stg-Syntax.html#t:CgStgTopBinding" title="GHC.Stg.Syntax">CgStgTopBinding</a>]</li><li class="src short"><a href="#v:annBindingFreeVars">annBindingFreeVars</a> :: <a href="GHC-Unit-Types.html#t:Module" title="GHC.Unit.Types">Module</a> -&gt; <a href="GHC-Stg-Syntax.html#t:StgBinding" title="GHC.Stg.Syntax">StgBinding</a> -&gt; <a href="GHC-Stg-Syntax.html#t:CgStgBinding" title="GHC.Stg.Syntax">CgStgBinding</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:depSortWithAnnotStgPgm" class="def">depSortWithAnnotStgPgm</a> :: <a href="GHC-Unit-Types.html#t:Module" title="GHC.Unit.Types">Module</a> -&gt; [<a href="GHC-Stg-Syntax.html#t:StgTopBinding" title="GHC.Stg.Syntax">StgTopBinding</a>] -&gt; [<a href="GHC-Stg-Syntax.html#t:CgStgTopBinding" title="GHC.Stg.Syntax">CgStgTopBinding</a>] <a href="src/GHC.Stg.FVs.html#depSortWithAnnotStgPgm" class="link">Source</a> <a href="#v:depSortWithAnnotStgPgm" class="selflink">#</a></p><div class="doc"><p>Dependency sort a STG program, and annotate it with free variables
 The returned bindings:
   * Are in dependency order
   * Each StgRhsClosure is correctly annotated (in its extension field)
     with the free variables needed in the closure
   * Each StgCase is correctly annotated (in its extension field) with
     the variables that must be saved across the case</p></div></div><div class="top"><p class="src"><a id="v:annBindingFreeVars" class="def">annBindingFreeVars</a> :: <a href="GHC-Unit-Types.html#t:Module" title="GHC.Unit.Types">Module</a> -&gt; <a href="GHC-Stg-Syntax.html#t:StgBinding" title="GHC.Stg.Syntax">StgBinding</a> -&gt; <a href="GHC-Stg-Syntax.html#t:CgStgBinding" title="GHC.Stg.Syntax">CgStgBinding</a> <a href="src/GHC.Stg.FVs.html#annBindingFreeVars" class="link">Source</a> <a href="#v:annBindingFreeVars" class="selflink">#</a></p><div class="doc"><p>Dependency analysis on STG terms.</p><p>Dependencies of a binding are just free variables in the binding. This
 includes imported ids and ids in the current module. For recursive groups we
 just return one set of free variables which is just the union of dependencies
 of all bindings in the group.</p><p>Implementation: pass bound variables (NestedIds) to recursive calls, get free
 variables (TopFVs) back. We ignore imported TopFVs as they do not change the
 ordering but it improves performance (see <code>nameIsExternalFrom</code> call in <code>vars_fvs</code>).</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>