<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span> </span><span class="hs-comment">-- Wrinkle in Note [Trees That Grow]</span><span>
</span><span id="line-8"></span><span>                                      </span><span class="hs-comment">-- in module Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE ViewPatterns #-}</span><span>
</span><span id="line-10"></span><span>
</span><span id="line-11"></span><span>
</span><span id="line-12"></span><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998

\section[HsBinds]{Abstract syntax: top-level bindings and signatures}

Datatype for: @BindGroup@, @Bind@, @Sig@, @Bind@.
-}</span><span>
</span><span id="line-20"></span><span>
</span><span id="line-21"></span><span class="hs-comment">-- See Note [Language.Haskell.Syntax.* Hierarchy] for why not GHC.Hs.*</span><span>
</span><span id="line-22"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.Syntax.Binds</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-23"></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="hs-pragma">{-# SOURCE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html"><span class="hs-identifier">Language.Haskell.Syntax.Expr</span></a></span><span>
</span><span id="line-25"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier">LHsExpr</span></a></span><span>
</span><span id="line-26"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier">MatchGroup</span></a></span><span>
</span><span id="line-27"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHSs"><span class="hs-identifier">GRHSs</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="hs-pragma">{-# SOURCE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html"><span class="hs-identifier">Language.Haskell.Syntax.Pat</span></a></span><span>
</span><span id="line-29"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier">LPat</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-30"></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html"><span class="hs-identifier">Language.Haskell.Syntax.Extension</span></a></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html"><span class="hs-identifier">Language.Haskell.Syntax.Type</span></a></span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html"><span class="hs-identifier">GHC.Types.Fixity</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Fixity.html#Fixity"><span class="hs-identifier">Fixity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html"><span class="hs-identifier">GHC.Data.Bag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier">Bag</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html"><span class="hs-identifier">GHC.Types.Basic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Basic.html#InlinePragma"><span class="hs-identifier">InlinePragma</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.BooleanFormula.html"><span class="hs-identifier">GHC.Data.BooleanFormula</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Data.BooleanFormula.html#LBooleanFormula"><span class="hs-identifier">LBooleanFormula</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html"><span class="hs-identifier">GHC.Types.SourceText</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SourceText.html#StringLiteral"><span class="hs-identifier">StringLiteral</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-40"></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Void.html#/Data.Void.html"><span class="hs-identifier">Data.Void</span></a></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Bool.html#/Data.Bool.html"><span class="hs-identifier">Data.Bool</span></a></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Maybe.html#/Data.Maybe.html"><span class="hs-identifier">Data.Maybe</span></a></span><span>
</span><span id="line-44"></span><span>
</span><span id="line-45"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Bindings: @BindGroup@}
*                                                                      *
************************************************************************

Global bindings (where clauses)
-}</span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span class="hs-comment">-- During renaming, we need bindings where the left-hand sides</span><span>
</span><span id="line-56"></span><span class="hs-comment">-- have been renamed but the right-hand sides have not.</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- Other than during renaming, these will be the same.</span><span>
</span><span id="line-58"></span><span>
</span><span id="line-59"></span><span class="annot"><span class="hs-comment">-- | Haskell Local Bindings</span></span><span>
</span><span id="line-60"></span><span class="hs-keyword">type</span><span> </span><span id="HsLocalBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBinds"><span class="hs-identifier hs-var">HsLocalBinds</span></a></span></span><span> </span><span id="local-6989586621681630481"><span class="annot"><a href="#local-6989586621681630481"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBindsLR"><span class="hs-identifier hs-type">HsLocalBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630481"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630481"><span class="hs-identifier hs-type">id</span></a></span><span>
</span><span id="line-61"></span><span>
</span><span id="line-62"></span><span class="annot"><span class="hs-comment">-- | Located Haskell local bindings</span></span><span>
</span><span id="line-63"></span><span class="hs-keyword">type</span><span> </span><span id="LHsLocalBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsLocalBinds"><span class="hs-identifier hs-var">LHsLocalBinds</span></a></span></span><span> </span><span id="local-6989586621681630484"><span class="annot"><a href="#local-6989586621681630484"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630484"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBinds"><span class="hs-identifier hs-type">HsLocalBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630484"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span class="hs-comment">-- | Haskell Local Bindings with separate Left and Right identifier types</span><span>
</span><span id="line-66"></span><span class="hs-comment">--</span><span>
</span><span id="line-67"></span><span class="hs-comment">-- Bindings in a 'let' expression</span><span>
</span><span id="line-68"></span><span class="hs-comment">-- or a 'where' clause</span><span>
</span><span id="line-69"></span><span class="hs-keyword">data</span><span> </span><span id="HsLocalBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBindsLR"><span class="hs-identifier hs-var">HsLocalBindsLR</span></a></span></span><span> </span><span id="local-6989586621681630485"><span class="annot"><a href="#local-6989586621681630485"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681630486"><span class="annot"><a href="#local-6989586621681630486"><span class="hs-identifier hs-type">idR</span></a></span></span><span>
</span><span id="line-70"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsValBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBinds"><span class="hs-identifier hs-var">HsValBinds</span></a></span></span><span>
</span><span id="line-71"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsValBinds"><span class="hs-identifier hs-type">XHsValBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630485"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630486"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-72"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBindsLR"><span class="hs-identifier hs-type">HsValBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630485"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630486"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-73"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ Haskell Value Bindings</span></span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span>         </span><span class="hs-comment">-- There should be no pattern synonyms in the HsValBindsLR</span><span>
</span><span id="line-76"></span><span>         </span><span class="hs-comment">-- These are *local* (not top level) bindings</span><span>
</span><span id="line-77"></span><span>         </span><span class="hs-comment">-- The parser accepts them, however, leaving the</span><span>
</span><span id="line-78"></span><span>         </span><span class="hs-comment">-- renamer to report them</span><span>
</span><span id="line-79"></span><span>
</span><span id="line-80"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsIPBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsIPBinds"><span class="hs-identifier hs-var">HsIPBinds</span></a></span></span><span>
</span><span id="line-81"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsIPBinds"><span class="hs-identifier hs-type">XHsIPBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630485"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630486"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-82"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsIPBinds"><span class="hs-identifier hs-type">HsIPBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630486"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-83"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ Haskell Implicit Parameter Bindings</span></span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="EmptyLocalBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#EmptyLocalBinds"><span class="hs-identifier hs-var">EmptyLocalBinds</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XEmptyLocalBinds"><span class="hs-identifier hs-type">XEmptyLocalBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630485"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630486"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-86"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ Empty Local Bindings</span></span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsLocalBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XHsLocalBindsLR"><span class="hs-identifier hs-var">XHsLocalBindsLR</span></a></span></span><span>
</span><span id="line-89"></span><span>        </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsLocalBindsLR"><span class="hs-identifier hs-type">XXHsLocalBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630485"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630486"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="hs-keyword">type</span><span> </span><span id="LHsLocalBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsLocalBindsLR"><span class="hs-identifier hs-var">LHsLocalBindsLR</span></a></span></span><span> </span><span id="local-6989586621681630498"><span class="annot"><a href="#local-6989586621681630498"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681630499"><span class="annot"><a href="#local-6989586621681630499"><span class="hs-identifier hs-type">idR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630498"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBindsLR"><span class="hs-identifier hs-type">HsLocalBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630498"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630499"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-92"></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span class="annot"><span class="hs-comment">-- | Haskell Value Bindings</span></span><span>
</span><span id="line-95"></span><span class="hs-keyword">type</span><span> </span><span id="HsValBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBinds"><span class="hs-identifier hs-var">HsValBinds</span></a></span></span><span> </span><span id="local-6989586621681630501"><span class="annot"><a href="#local-6989586621681630501"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBindsLR"><span class="hs-identifier hs-type">HsValBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630501"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630501"><span class="hs-identifier hs-type">id</span></a></span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span class="hs-comment">-- | Haskell Value bindings with separate Left and Right identifier types</span><span>
</span><span id="line-98"></span><span class="hs-comment">-- (not implicit parameters)</span><span>
</span><span id="line-99"></span><span class="hs-comment">-- Used for both top level and nested bindings</span><span>
</span><span id="line-100"></span><span class="hs-comment">-- May contain pattern synonym bindings</span><span>
</span><span id="line-101"></span><span class="hs-keyword">data</span><span> </span><span id="HsValBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBindsLR"><span class="hs-identifier hs-var">HsValBindsLR</span></a></span></span><span> </span><span id="local-6989586621681630502"><span class="annot"><a href="#local-6989586621681630502"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681630503"><span class="annot"><a href="#local-6989586621681630503"><span class="hs-identifier hs-type">idR</span></a></span></span><span>
</span><span id="line-102"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | Value Bindings In</span><span>
</span><span id="line-103"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-104"></span><span>    </span><span class="hs-comment">-- Before renaming RHS; idR is always RdrName</span><span>
</span><span id="line-105"></span><span>    </span><span class="hs-comment">-- Not dependency analysed</span><span>
</span><span id="line-106"></span><span>    </span><span class="hs-comment">-- Recursive by default</span><span>
</span><span id="line-107"></span><span>    </span><span id="ValBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ValBinds"><span class="hs-identifier hs-var">ValBinds</span></a></span></span><span>
</span><span id="line-108"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XValBinds"><span class="hs-identifier hs-type">XValBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630502"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630503"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-109"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindsLR"><span class="hs-identifier hs-type">LHsBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630502"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630503"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630503"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span>    </span><span class="hs-comment">-- | Value Bindings Out</span><span>
</span><span id="line-112"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-113"></span><span>    </span><span class="hs-comment">-- After renaming RHS; idR can be Name or Id Dependency analysed,</span><span>
</span><span id="line-114"></span><span>    </span><span class="hs-comment">-- later bindings in the list may depend on earlier ones.</span><span>
</span><span id="line-115"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XValBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XValBindsLR"><span class="hs-identifier hs-var">XValBindsLR</span></a></span></span><span>
</span><span id="line-116"></span><span>      </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXValBindsLR"><span class="hs-identifier hs-type">XXValBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630502"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630503"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-119"></span><span>
</span><span id="line-120"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Binding</span></span><span>
</span><span id="line-121"></span><span class="hs-keyword">type</span><span> </span><span id="LHsBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBind"><span class="hs-identifier hs-var">LHsBind</span></a></span></span><span>  </span><span id="local-6989586621681630510"><span class="annot"><a href="#local-6989586621681630510"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindLR"><span class="hs-identifier hs-type">LHsBindLR</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681630510"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630510"><span class="hs-identifier hs-type">id</span></a></span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Bindings</span></span><span>
</span><span id="line-124"></span><span class="hs-keyword">type</span><span> </span><span id="LHsBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBinds"><span class="hs-identifier hs-var">LHsBinds</span></a></span></span><span> </span><span id="local-6989586621681630513"><span class="annot"><a href="#local-6989586621681630513"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindsLR"><span class="hs-identifier hs-type">LHsBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630513"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630513"><span class="hs-identifier hs-type">id</span></a></span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span class="annot"><span class="hs-comment">-- | Haskell Binding</span></span><span>
</span><span id="line-127"></span><span class="hs-keyword">type</span><span> </span><span id="HsBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBind"><span class="hs-identifier hs-var">HsBind</span></a></span></span><span>   </span><span id="local-6989586621681630515"><span class="annot"><a href="#local-6989586621681630515"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBindLR"><span class="hs-identifier hs-type">HsBindLR</span></a></span><span>   </span><span class="annot"><a href="#local-6989586621681630515"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630515"><span class="hs-identifier hs-type">id</span></a></span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Bindings with separate Left and Right identifier types</span></span><span>
</span><span id="line-130"></span><span class="hs-keyword">type</span><span> </span><span id="LHsBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindsLR"><span class="hs-identifier hs-var">LHsBindsLR</span></a></span></span><span> </span><span id="local-6989586621681630516"><span class="annot"><a href="#local-6989586621681630516"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681630517"><span class="annot"><a href="#local-6989586621681630517"><span class="hs-identifier hs-type">idR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindLR"><span class="hs-identifier hs-type">LHsBindLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630516"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630517"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Binding with separate Left and Right identifier types</span></span><span>
</span><span id="line-133"></span><span class="hs-keyword">type</span><span> </span><span id="LHsBindLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindLR"><span class="hs-identifier hs-var">LHsBindLR</span></a></span></span><span>  </span><span id="local-6989586621681630518"><span class="annot"><a href="#local-6989586621681630518"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681630519"><span class="annot"><a href="#local-6989586621681630519"><span class="hs-identifier hs-type">idR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630518"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBindLR"><span class="hs-identifier hs-type">HsBindLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630518"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630519"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-134"></span><span>
</span><span id="line-135"></span><span class="hs-comment">{- Note [FunBind vs PatBind]
   ~~~~~~~~~~~~~~~~~~~~~~~~~
The distinction between FunBind and PatBind is a bit subtle. FunBind covers
patterns which resemble function bindings and simple variable bindings.

    f x = e
    f !x = e
    f = e
    !x = e          -- FunRhs has SrcStrict
    x `f` y = e     -- FunRhs has Infix

The actual patterns and RHSs of a FunBind are encoding in fun_matches.
The m_ctxt field of each Match in fun_matches will be FunRhs and carries
two bits of information about the match,

  * The mc_fixity field on each Match describes the fixity of the
    function binder in that match.  E.g. this is legal:
         f True False  = e1
         True `f` True = e2

  * The mc_strictness field is used /only/ for nullary FunBinds: ones
    with one Match, which has no pats. For these, it describes whether
    the match is decorated with a bang (e.g. `!x = e`).

By contrast, PatBind represents data constructor patterns, as well as a few
other interesting cases. Namely,

    Just x = e
    (x) = e
    x :: Ty = e
-}</span><span>
</span><span id="line-166"></span><span>
</span><span id="line-167"></span><span class="annot"><span class="hs-comment">-- | Haskell Binding with separate Left and Right id's</span></span><span>
</span><span id="line-168"></span><span class="hs-keyword">data</span><span> </span><span id="HsBindLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBindLR"><span class="hs-identifier hs-var">HsBindLR</span></a></span></span><span> </span><span id="local-6989586621681630408"><span class="annot"><a href="#local-6989586621681630408"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681630409"><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span></span><span>
</span><span id="line-169"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | Function-like Binding</span><span>
</span><span id="line-170"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-171"></span><span>    </span><span class="hs-comment">-- FunBind is used for both functions     @f x = e@</span><span>
</span><span id="line-172"></span><span>    </span><span class="hs-comment">-- and variables                          @f = \x -&gt; e@</span><span>
</span><span id="line-173"></span><span>    </span><span class="hs-comment">-- and strict variables                   @!x = x + 1@</span><span>
</span><span id="line-174"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-175"></span><span>    </span><span class="hs-comment">-- Reason 1: Special case for type inference: see 'GHC.Tc.Gen.Bind.tcMonoBinds'.</span><span>
</span><span id="line-176"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-177"></span><span>    </span><span class="hs-comment">-- Reason 2: Instance decls can only have FunBinds, which is convenient.</span><span>
</span><span id="line-178"></span><span>    </span><span class="hs-comment">--           If you change this, you'll need to change e.g. rnMethodBinds</span><span>
</span><span id="line-179"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-180"></span><span>    </span><span class="hs-comment">-- But note that the form                 @f :: a-&gt;a = ...@</span><span>
</span><span id="line-181"></span><span>    </span><span class="hs-comment">-- parses as a pattern binding, just like</span><span>
</span><span id="line-182"></span><span>    </span><span class="hs-comment">--                                        @(f :: a -&gt; a) = ... @</span><span>
</span><span id="line-183"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-184"></span><span>    </span><span class="hs-comment">-- Strict bindings have their strictness recorded in the 'SrcStrictness' of their</span><span>
</span><span id="line-185"></span><span>    </span><span class="hs-comment">-- 'MatchContext'. See Note [FunBind vs PatBind] for</span><span>
</span><span id="line-186"></span><span>    </span><span class="hs-comment">-- details about the relationship between FunBind and PatBind.</span><span>
</span><span id="line-187"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-188"></span><span>    </span><span class="hs-comment">--  'GHC.Parser.Annotation.AnnKeywordId's</span><span>
</span><span id="line-189"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-190"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnFunId', attached to each element of fun_matches</span><span>
</span><span id="line-191"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-192"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnWhere',</span><span>
</span><span id="line-193"></span><span>    </span><span class="hs-comment">--    'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose',</span><span>
</span><span id="line-194"></span><span>
</span><span id="line-195"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-196"></span><span>    </span><span id="FunBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FunBind"><span class="hs-identifier hs-var">FunBind</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-197"></span><span>
</span><span id="line-198"></span><span>        </span><span id="fun_ext"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; XFunBind idL idR
</span><a href="Language.Haskell.Syntax.Binds.html#fun_ext"><span class="hs-identifier hs-var hs-var">fun_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XFunBind"><span class="hs-identifier hs-type">XFunBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630408"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-199"></span><span>
</span><span id="line-200"></span><span>        </span><span id="fun_id"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; LIdP idL
</span><a href="Language.Haskell.Syntax.Binds.html#fun_id"><span class="hs-identifier hs-var hs-var">fun_id</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630408"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- Note [fun_id in Match] in GHC.Hs.Expr</span><span>
</span><span id="line-201"></span><span>
</span><span id="line-202"></span><span>        </span><span id="fun_matches"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; MatchGroup idR (LHsExpr idR)
</span><a href="Language.Haskell.Syntax.Binds.html#fun_matches"><span class="hs-identifier hs-var hs-var">fun_matches</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>  </span><span class="annot"><span class="hs-comment">-- ^ The payload</span></span><span>
</span><span id="line-203"></span><span>
</span><span id="line-204"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-205"></span><span>
</span><span id="line-206"></span><span>  </span><span class="hs-comment">-- | Pattern Binding</span><span>
</span><span id="line-207"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-208"></span><span>  </span><span class="hs-comment">-- The pattern is never a simple variable;</span><span>
</span><span id="line-209"></span><span>  </span><span class="hs-comment">-- That case is done by FunBind.</span><span>
</span><span id="line-210"></span><span>  </span><span class="hs-comment">-- See Note [FunBind vs PatBind] for details about the</span><span>
</span><span id="line-211"></span><span>  </span><span class="hs-comment">-- relationship between FunBind and PatBind.</span><span>
</span><span id="line-212"></span><span>
</span><span id="line-213"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-214"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnBang',</span><span>
</span><span id="line-215"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnWhere',</span><span>
</span><span id="line-216"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose',</span><span>
</span><span id="line-217"></span><span>
</span><span id="line-218"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-219"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatBind"><span class="hs-identifier hs-var">PatBind</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-220"></span><span>        </span><span id="pat_ext"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; XPatBind idL idR
</span><a href="Language.Haskell.Syntax.Binds.html#pat_ext"><span class="hs-identifier hs-var hs-var">pat_ext</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPatBind"><span class="hs-identifier hs-type">XPatBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630408"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-221"></span><span>        </span><span id="pat_lhs"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; LPat idL
</span><a href="Language.Haskell.Syntax.Binds.html#pat_lhs"><span class="hs-identifier hs-var hs-var">pat_lhs</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630408"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-222"></span><span>        </span><span id="pat_rhs"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; GRHSs idR (LHsExpr idR)
</span><a href="Language.Haskell.Syntax.Binds.html#pat_rhs"><span class="hs-identifier hs-var hs-var">pat_rhs</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHSs"><span class="hs-identifier hs-type">GRHSs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-223"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-224"></span><span>
</span><span id="line-225"></span><span>  </span><span class="hs-comment">-- | Variable Binding</span><span>
</span><span id="line-226"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-227"></span><span>  </span><span class="hs-comment">-- Dictionary binding and suchlike.</span><span>
</span><span id="line-228"></span><span>  </span><span class="hs-comment">-- All VarBinds are introduced by the type checker</span><span>
</span><span id="line-229"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="VarBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#VarBind"><span class="hs-identifier hs-var">VarBind</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-230"></span><span>        </span><span id="var_ext"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; XVarBind idL idR
</span><a href="Language.Haskell.Syntax.Binds.html#var_ext"><span class="hs-identifier hs-var hs-var">var_ext</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XVarBind"><span class="hs-identifier hs-type">XVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630408"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-231"></span><span>        </span><span id="var_id"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; IdP idL
</span><a href="Language.Haskell.Syntax.Binds.html#var_id"><span class="hs-identifier hs-var hs-var">var_id</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630408"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-232"></span><span>        </span><span id="var_rhs"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; LHsExpr idR
</span><a href="Language.Haskell.Syntax.Binds.html#var_rhs"><span class="hs-identifier hs-var hs-var">var_rhs</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ Located only for consistency</span></span><span>
</span><span id="line-233"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-234"></span><span>
</span><span id="line-235"></span><span>  </span><span class="annot"><span class="hs-comment">-- | Patterns Synonym Binding</span></span><span>
</span><span id="line-236"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatSynBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatSynBind"><span class="hs-identifier hs-var">PatSynBind</span></a></span></span><span>
</span><span id="line-237"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPatSynBind"><span class="hs-identifier hs-type">XPatSynBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630408"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-238"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatSynBind"><span class="hs-identifier hs-type">PatSynBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630408"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-239"></span><span>        </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnPattern',</span><span>
</span><span id="line-240"></span><span>        </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnLarrow','GHC.Parser.Annotation.AnnEqual',</span><span>
</span><span id="line-241"></span><span>        </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnWhere'</span><span>
</span><span id="line-242"></span><span>        </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnOpen' @'{'@,'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-243"></span><span>
</span><span id="line-244"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-245"></span><span>
</span><span id="line-246"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XHsBindsLR"><span class="hs-identifier hs-var">XHsBindsLR</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsBindsLR"><span class="hs-identifier hs-type">XXHsBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630408"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630409"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-247"></span><span>
</span><span id="line-248"></span><span>
</span><span id="line-249"></span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnPattern',</span><span>
</span><span id="line-250"></span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnLarrow',</span><span>
</span><span id="line-251"></span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnWhere','GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-252"></span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnClose' @'}'@,</span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-255"></span><span>
</span><span id="line-256"></span><span class="annot"><span class="hs-comment">-- | Pattern Synonym binding</span></span><span>
</span><span id="line-257"></span><span class="hs-keyword">data</span><span> </span><span id="PatSynBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatSynBind"><span class="hs-identifier hs-var">PatSynBind</span></a></span></span><span> </span><span id="local-6989586621681630438"><span class="annot"><a href="#local-6989586621681630438"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681630439"><span class="annot"><a href="#local-6989586621681630439"><span class="hs-identifier hs-type">idR</span></a></span></span><span>
</span><span id="line-258"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="PSB"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PSB"><span class="hs-identifier hs-var">PSB</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="psb_ext"><span class="annot"><span class="annottext">forall idL idR. PatSynBind idL idR -&gt; XPSB idL idR
</span><a href="Language.Haskell.Syntax.Binds.html#psb_ext"><span class="hs-identifier hs-var hs-var">psb_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPSB"><span class="hs-identifier hs-type">XPSB</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630438"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630439"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-259"></span><span>          </span><span id="psb_id"><span class="annot"><span class="annottext">forall idL idR. PatSynBind idL idR -&gt; LIdP idL
</span><a href="Language.Haskell.Syntax.Binds.html#psb_id"><span class="hs-identifier hs-var hs-var">psb_id</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630438"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">,</span><span>                </span><span class="annot"><span class="hs-comment">-- ^ Name of the pattern synonym</span></span><span>
</span><span id="line-260"></span><span>          </span><span id="psb_args"><span class="annot"><span class="annottext">forall idL idR. PatSynBind idL idR -&gt; HsPatSynDetails idR
</span><a href="Language.Haskell.Syntax.Binds.html#psb_args"><span class="hs-identifier hs-var hs-var">psb_args</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsPatSynDetails"><span class="hs-identifier hs-type">HsPatSynDetails</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630439"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Formal parameter names</span></span><span>
</span><span id="line-261"></span><span>          </span><span id="psb_def"><span class="annot"><span class="annottext">forall idL idR. PatSynBind idL idR -&gt; LPat idR
</span><a href="Language.Haskell.Syntax.Binds.html#psb_def"><span class="hs-identifier hs-var hs-var">psb_def</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630439"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>                </span><span class="annot"><span class="hs-comment">-- ^ Right-hand side</span></span><span>
</span><span id="line-262"></span><span>          </span><span id="psb_dir"><span class="annot"><span class="annottext">forall idL idR. PatSynBind idL idR -&gt; HsPatSynDir idR
</span><a href="Language.Haskell.Syntax.Binds.html#psb_dir"><span class="hs-identifier hs-var hs-var">psb_dir</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsPatSynDir"><span class="hs-identifier hs-type">HsPatSynDir</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630439"><span class="hs-identifier hs-type">idR</span></a></span><span>          </span><span class="annot"><span class="hs-comment">-- ^ Directionality</span></span><span>
</span><span id="line-263"></span><span>     </span><span class="hs-special">}</span><span>
</span><span id="line-264"></span><span>   </span><span class="hs-glyph">|</span><span> </span><span id="XPatSynBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XPatSynBind"><span class="hs-identifier hs-var">XPatSynBind</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPatSynBind"><span class="hs-identifier hs-type">XXPatSynBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630438"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630439"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-265"></span><span>
</span><span id="line-266"></span><span>
</span><span id="line-267"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                Implicit parameter bindings
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-274"></span><span>
</span><span id="line-275"></span><span class="annot"><span class="hs-comment">-- | Haskell Implicit Parameter Bindings</span></span><span>
</span><span id="line-276"></span><span class="hs-keyword">data</span><span> </span><span id="HsIPBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsIPBinds"><span class="hs-identifier hs-var">HsIPBinds</span></a></span></span><span> </span><span id="local-6989586621681630544"><span class="annot"><a href="#local-6989586621681630544"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-277"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="IPBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IPBinds"><span class="hs-identifier hs-var">IPBinds</span></a></span></span><span>
</span><span id="line-278"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XIPBinds"><span class="hs-identifier hs-type">XIPBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630544"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-279"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LIPBind"><span class="hs-identifier hs-type">LIPBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630544"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-280"></span><span>        </span><span class="hs-comment">-- TcEvBinds       -- Only in typechecker output; binds</span><span>
</span><span id="line-281"></span><span>        </span><span class="hs-comment">--                 -- uses of the implicit parameters</span><span>
</span><span id="line-282"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsIPBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XHsIPBinds"><span class="hs-identifier hs-var">XHsIPBinds</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsIPBinds"><span class="hs-identifier hs-type">XXHsIPBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630544"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-283"></span><span>
</span><span id="line-284"></span><span>
</span><span id="line-285"></span><span class="annot"><span class="hs-comment">-- | Located Implicit Parameter Binding</span></span><span>
</span><span id="line-286"></span><span class="hs-keyword">type</span><span> </span><span id="LIPBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LIPBind"><span class="hs-identifier hs-var">LIPBind</span></a></span></span><span> </span><span id="local-6989586621681630550"><span class="annot"><a href="#local-6989586621681630550"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630550"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IPBind"><span class="hs-identifier hs-type">IPBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630550"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span class="hs-comment">-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when in a</span><span>
</span><span id="line-288"></span><span class="hs-comment">--   list</span><span>
</span><span id="line-289"></span><span>
</span><span id="line-290"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-291"></span><span>
</span><span id="line-292"></span><span class="hs-comment">-- | Implicit parameter bindings.</span><span>
</span><span id="line-293"></span><span class="hs-comment">--</span><span>
</span><span id="line-294"></span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnEqual'</span><span>
</span><span id="line-295"></span><span>
</span><span id="line-296"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-297"></span><span class="hs-keyword">data</span><span> </span><span id="IPBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IPBind"><span class="hs-identifier hs-var">IPBind</span></a></span></span><span> </span><span id="local-6989586621681630552"><span class="annot"><a href="#local-6989586621681630552"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-298"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="IPBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IPBind"><span class="hs-identifier hs-var">IPBind</span></a></span></span><span>
</span><span id="line-299"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCIPBind"><span class="hs-identifier hs-type">XCIPBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630552"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-300"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630552"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier hs-type">HsIPName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-301"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630552"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-302"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XIPBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XIPBind"><span class="hs-identifier hs-var">XIPBind</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXIPBind"><span class="hs-identifier hs-type">XXIPBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630552"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{@Sig@: type signatures and value-modifying user pragmas}
*                                                                      *
************************************************************************

It is convenient to lump ``value-modifying'' user-pragmas (e.g.,
``specialise this function to these four types...'') in with type
signatures.  Then all the machinery to move them into place, etc.,
serves for both.
-}</span><span>
</span><span id="line-316"></span><span>
</span><span id="line-317"></span><span class="annot"><span class="hs-comment">-- | Located Signature</span></span><span>
</span><span id="line-318"></span><span class="hs-keyword">type</span><span> </span><span id="LSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-var">LSig</span></a></span></span><span> </span><span id="local-6989586621681630558"><span class="annot"><a href="#local-6989586621681630558"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630558"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#Sig"><span class="hs-identifier hs-type">Sig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630558"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-319"></span><span>
</span><span id="line-320"></span><span class="annot"><span class="hs-comment">-- | Signatures and pragmas</span></span><span>
</span><span id="line-321"></span><span class="hs-keyword">data</span><span> </span><span id="Sig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#Sig"><span class="hs-identifier hs-var">Sig</span></a></span></span><span> </span><span id="local-6989586621681630559"><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-322"></span><span>  </span><span class="hs-glyph">=</span><span>   </span><span class="hs-comment">-- | An ordinary type signature</span><span>
</span><span id="line-323"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-324"></span><span>      </span><span class="hs-comment">-- &gt; f :: Num a =&gt; a -&gt; a</span><span>
</span><span id="line-325"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-326"></span><span>      </span><span class="hs-comment">-- After renaming, this list of Names contains the named</span><span>
</span><span id="line-327"></span><span>      </span><span class="hs-comment">-- wildcards brought into scope by this signature. For a signature</span><span>
</span><span id="line-328"></span><span>      </span><span class="hs-comment">-- @_ -&gt; _a -&gt; Bool@, the renamer will leave the unnamed wildcard @_@</span><span>
</span><span id="line-329"></span><span>      </span><span class="hs-comment">-- untouched, and the named wildcard @_a@ is then replaced with</span><span>
</span><span id="line-330"></span><span>      </span><span class="hs-comment">-- fresh meta vars in the type. Their names are stored in the type</span><span>
</span><span id="line-331"></span><span>      </span><span class="hs-comment">-- signature that brought them into scope, in this third field to be</span><span>
</span><span id="line-332"></span><span>      </span><span class="hs-comment">-- more specific.</span><span>
</span><span id="line-333"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-334"></span><span>      </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon',</span><span>
</span><span id="line-335"></span><span>      </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnComma'</span><span>
</span><span id="line-336"></span><span>
</span><span id="line-337"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-338"></span><span>    </span><span id="TypeSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TypeSig"><span class="hs-identifier hs-var">TypeSig</span></a></span></span><span>
</span><span id="line-339"></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTypeSig"><span class="hs-identifier hs-type">XTypeSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-340"></span><span>       </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>           </span><span class="hs-comment">-- LHS of the signature; e.g.  f,g,h :: blah</span><span>
</span><span id="line-341"></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigWcType"><span class="hs-identifier hs-type">LHsSigWcType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- RHS of the signature; can have wildcards</span><span>
</span><span id="line-342"></span><span>
</span><span id="line-343"></span><span>      </span><span class="hs-comment">-- | A pattern synonym type signature</span><span>
</span><span id="line-344"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-345"></span><span>      </span><span class="hs-comment">-- &gt; pattern Single :: () =&gt; (Show a) =&gt; a -&gt; [a]</span><span>
</span><span id="line-346"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-347"></span><span>      </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnPattern',</span><span>
</span><span id="line-348"></span><span>      </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnDcolon','GHC.Parser.Annotation.AnnForall'</span><span>
</span><span id="line-349"></span><span>      </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnDot','GHC.Parser.Annotation.AnnDarrow'</span><span>
</span><span id="line-350"></span><span>
</span><span id="line-351"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-352"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatSynSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatSynSig"><span class="hs-identifier hs-var">PatSynSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPatSynSig"><span class="hs-identifier hs-type">XPatSynSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-353"></span><span>      </span><span class="hs-comment">-- P :: forall a b. Req =&gt; Prov =&gt; ty</span><span>
</span><span id="line-354"></span><span>
</span><span id="line-355"></span><span>      </span><span class="hs-comment">-- | A signature for a class method</span><span>
</span><span id="line-356"></span><span>      </span><span class="hs-comment">--   False: ordinary class-method signature</span><span>
</span><span id="line-357"></span><span>      </span><span class="hs-comment">--   True:  generic-default class method signature</span><span>
</span><span id="line-358"></span><span>      </span><span class="hs-comment">-- e.g.   class C a where</span><span>
</span><span id="line-359"></span><span>      </span><span class="hs-comment">--          op :: a -&gt; a                   -- Ordinary</span><span>
</span><span id="line-360"></span><span>      </span><span class="hs-comment">--          default op :: Eq a =&gt; a -&gt; a   -- Generic default</span><span>
</span><span id="line-361"></span><span>      </span><span class="hs-comment">-- No wildcards allowed here</span><span>
</span><span id="line-362"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-363"></span><span>      </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDefault',</span><span>
</span><span id="line-364"></span><span>      </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnDcolon'</span><span>
</span><span id="line-365"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ClassOpSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ClassOpSig"><span class="hs-identifier hs-var">ClassOpSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XClassOpSig"><span class="hs-identifier hs-type">XClassOpSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-366"></span><span>
</span><span id="line-367"></span><span>        </span><span class="hs-comment">-- | An ordinary fixity declaration</span><span>
</span><span id="line-368"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-369"></span><span>        </span><span class="hs-comment">-- &gt;     infixl 8 ***</span><span>
</span><span id="line-370"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-371"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-372"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnInfix',</span><span>
</span><span id="line-373"></span><span>        </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnVal'</span><span>
</span><span id="line-374"></span><span>
</span><span id="line-375"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-376"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FixSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixSig"><span class="hs-identifier hs-var">FixSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XFixSig"><span class="hs-identifier hs-type">XFixSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixitySig"><span class="hs-identifier hs-type">FixitySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-377"></span><span>
</span><span id="line-378"></span><span>        </span><span class="hs-comment">-- | An inline pragma</span><span>
</span><span id="line-379"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-380"></span><span>        </span><span class="hs-comment">-- &gt; {#- INLINE f #-}</span><span>
</span><span id="line-381"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-382"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' :</span><span>
</span><span id="line-383"></span><span>        </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen' @'{-\# INLINE'@ and @'['@,</span><span>
</span><span id="line-384"></span><span>        </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose','GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-385"></span><span>        </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnVal','GHC.Parser.Annotation.AnnTilde',</span><span>
</span><span id="line-386"></span><span>        </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-387"></span><span>
</span><span id="line-388"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-389"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InlineSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#InlineSig"><span class="hs-identifier hs-var">InlineSig</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XInlineSig"><span class="hs-identifier hs-type">XInlineSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-390"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- Function name</span><span>
</span><span id="line-391"></span><span>                </span><span class="annot"><a href="GHC.Types.Basic.html#InlinePragma"><span class="hs-identifier hs-type">InlinePragma</span></a></span><span>       </span><span class="hs-comment">-- Never defaultInlinePragma</span><span>
</span><span id="line-392"></span><span>
</span><span id="line-393"></span><span>        </span><span class="hs-comment">-- | A specialisation pragma</span><span>
</span><span id="line-394"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-395"></span><span>        </span><span class="hs-comment">-- &gt; {-# SPECIALISE f :: Int -&gt; Int #-}</span><span>
</span><span id="line-396"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-397"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-398"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnOpen' @'{-\# SPECIALISE'@ and @'['@,</span><span>
</span><span id="line-399"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnTilde',</span><span>
</span><span id="line-400"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnVal',</span><span>
</span><span id="line-401"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnClose' @']'@ and @'\#-}'@,</span><span>
</span><span id="line-402"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnDcolon'</span><span>
</span><span id="line-403"></span><span>
</span><span id="line-404"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-405"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SpecSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecSig"><span class="hs-identifier hs-var">SpecSig</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSpecSig"><span class="hs-identifier hs-type">XSpecSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-406"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- Specialise a function or datatype  ...</span><span>
</span><span id="line-407"></span><span>                </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- ... to these types</span><span>
</span><span id="line-408"></span><span>                </span><span class="annot"><a href="GHC.Types.Basic.html#InlinePragma"><span class="hs-identifier hs-type">InlinePragma</span></a></span><span>       </span><span class="hs-comment">-- The pragma on SPECIALISE_INLINE form.</span><span>
</span><span id="line-409"></span><span>                                   </span><span class="hs-comment">-- If it's just defaultInlinePragma, then we said</span><span>
</span><span id="line-410"></span><span>                                   </span><span class="hs-comment">--    SPECIALISE, not SPECIALISE_INLINE</span><span>
</span><span id="line-411"></span><span>
</span><span id="line-412"></span><span>        </span><span class="hs-comment">-- | A specialisation pragma for instance declarations only</span><span>
</span><span id="line-413"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-414"></span><span>        </span><span class="hs-comment">-- &gt; {-# SPECIALISE instance Eq [Int] #-}</span><span>
</span><span id="line-415"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-416"></span><span>        </span><span class="hs-comment">-- (Class tys); should be a specialisation of the</span><span>
</span><span id="line-417"></span><span>        </span><span class="hs-comment">-- current instance declaration</span><span>
</span><span id="line-418"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-419"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-420"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnInstance','GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-421"></span><span>
</span><span id="line-422"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-423"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SpecInstSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecInstSig"><span class="hs-identifier hs-var">SpecInstSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSpecInstSig"><span class="hs-identifier hs-type">XSpecInstSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-424"></span><span>
</span><span id="line-425"></span><span>        </span><span class="hs-comment">-- | A minimal complete definition pragma</span><span>
</span><span id="line-426"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-427"></span><span>        </span><span class="hs-comment">-- &gt; {-# MINIMAL a | (b, c | (d | e)) #-}</span><span>
</span><span id="line-428"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-429"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-430"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnVbar','GHC.Parser.Annotation.AnnComma',</span><span>
</span><span id="line-431"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-432"></span><span>
</span><span id="line-433"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-434"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MinimalSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#MinimalSig"><span class="hs-identifier hs-var">MinimalSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XMinimalSig"><span class="hs-identifier hs-type">XMinimalSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Data.BooleanFormula.html#LBooleanFormula"><span class="hs-identifier hs-type">LBooleanFormula</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-435"></span><span>
</span><span id="line-436"></span><span>        </span><span class="hs-comment">-- | A &quot;set cost centre&quot; pragma for declarations</span><span>
</span><span id="line-437"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-438"></span><span>        </span><span class="hs-comment">-- &gt; {-# SCC funName #-}</span><span>
</span><span id="line-439"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-440"></span><span>        </span><span class="hs-comment">-- or</span><span>
</span><span id="line-441"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-442"></span><span>        </span><span class="hs-comment">-- &gt; {-# SCC funName &quot;cost_centre_name&quot; #-}</span><span>
</span><span id="line-443"></span><span>
</span><span id="line-444"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SCCFunSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SCCFunSig"><span class="hs-identifier hs-var">SCCFunSig</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSCCFunSig"><span class="hs-identifier hs-type">XSCCFunSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-445"></span><span>               </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- Function name</span><span>
</span><span id="line-446"></span><span>               </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html#StringLiteral"><span class="hs-identifier hs-type">StringLiteral</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-447"></span><span>       </span><span class="hs-comment">-- | A complete match pragma</span><span>
</span><span id="line-448"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-449"></span><span>       </span><span class="hs-comment">-- &gt; {-# COMPLETE C, D [:: T] #-}</span><span>
</span><span id="line-450"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-451"></span><span>       </span><span class="hs-comment">-- Used to inform the pattern match checker about additional</span><span>
</span><span id="line-452"></span><span>       </span><span class="hs-comment">-- complete matchings which, for example, arise from pattern</span><span>
</span><span id="line-453"></span><span>       </span><span class="hs-comment">-- synonym definitions.</span><span>
</span><span id="line-454"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="CompleteMatchSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#CompleteMatchSig"><span class="hs-identifier hs-var">CompleteMatchSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCompleteMatchSig"><span class="hs-identifier hs-type">XCompleteMatchSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-455"></span><span>                     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-456"></span><span>                     </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-457"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XSig"><span class="hs-identifier hs-var">XSig</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXSig"><span class="hs-identifier hs-type">XXSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630559"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-458"></span><span>
</span><span id="line-459"></span><span class="annot"><span class="hs-comment">-- | Located Fixity Signature</span></span><span>
</span><span id="line-460"></span><span class="hs-keyword">type</span><span> </span><span id="LFixitySig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LFixitySig"><span class="hs-identifier hs-var">LFixitySig</span></a></span></span><span> </span><span id="local-6989586621681630586"><span class="annot"><a href="#local-6989586621681630586"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630586"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixitySig"><span class="hs-identifier hs-type">FixitySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630586"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-461"></span><span>
</span><span id="line-462"></span><span class="annot"><span class="hs-comment">-- | Fixity Signature</span></span><span>
</span><span id="line-463"></span><span class="hs-keyword">data</span><span> </span><span id="FixitySig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixitySig"><span class="hs-identifier hs-var">FixitySig</span></a></span></span><span> </span><span id="local-6989586621681630587"><span class="annot"><a href="#local-6989586621681630587"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="FixitySig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixitySig"><span class="hs-identifier hs-var">FixitySig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XFixitySig"><span class="hs-identifier hs-type">XFixitySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630587"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630587"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a></span><span>
</span><span id="line-464"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span id="XFixitySig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XFixitySig"><span class="hs-identifier hs-var">XFixitySig</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXFixitySig"><span class="hs-identifier hs-type">XXFixitySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630587"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-465"></span><span>
</span><span id="line-466"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isFixityLSig"><span class="hs-identifier hs-type">isFixityLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681630454"><span class="annot"><a href="#local-6989586621681630454"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630454"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630454"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-467"></span><span id="isFixityLSig"><span class="annot"><span class="annottext">isFixityLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isFixityLSig"><span class="hs-identifier hs-var hs-var">isFixityLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630454"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixSig"><span class="hs-identifier hs-type">FixSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-468"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isFixityLSig"><span class="hs-identifier hs-var">isFixityLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-469"></span><span>
</span><span id="line-470"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isTypeLSig"><span class="hs-identifier hs-type">isTypeLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681630597"><span class="annot"><a href="#local-6989586621681630597"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630597"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630597"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>  </span><span class="hs-comment">-- Type signatures</span><span>
</span><span id="line-471"></span><span id="isTypeLSig"><span class="annot"><span class="annottext">isTypeLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isTypeLSig"><span class="hs-identifier hs-var hs-var">isTypeLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630597"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TypeSig"><span class="hs-identifier hs-type">TypeSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-472"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isTypeLSig"><span class="hs-identifier hs-var">isTypeLSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630597"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ClassOpSig"><span class="hs-identifier hs-type">ClassOpSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-473"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isTypeLSig"><span class="hs-identifier hs-var">isTypeLSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630597"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XSig"><span class="hs-identifier hs-type">XSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-474"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isTypeLSig"><span class="hs-identifier hs-var">isTypeLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-475"></span><span>
</span><span id="line-476"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSpecLSig"><span class="hs-identifier hs-type">isSpecLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681630603"><span class="annot"><a href="#local-6989586621681630603"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630603"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630603"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-477"></span><span id="isSpecLSig"><span class="annot"><span class="annottext">isSpecLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isSpecLSig"><span class="hs-identifier hs-var hs-var">isSpecLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630603"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecSig"><span class="hs-identifier hs-type">SpecSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-478"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSpecLSig"><span class="hs-identifier hs-var">isSpecLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-479"></span><span>
</span><span id="line-480"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSpecInstLSig"><span class="hs-identifier hs-type">isSpecInstLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681630607"><span class="annot"><a href="#local-6989586621681630607"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630607"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630607"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-481"></span><span id="isSpecInstLSig"><span class="annot"><span class="annottext">isSpecInstLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isSpecInstLSig"><span class="hs-identifier hs-var hs-var">isSpecInstLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630607"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecInstSig"><span class="hs-identifier hs-type">SpecInstSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-482"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSpecInstLSig"><span class="hs-identifier hs-var">isSpecInstLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-483"></span><span>
</span><span id="line-484"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-type">isPragLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681630611"><span class="annot"><a href="#local-6989586621681630611"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630611"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630611"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-485"></span><span class="hs-comment">-- Identifies pragmas</span><span>
</span><span id="line-486"></span><span id="isPragLSig"><span class="annot"><span class="annottext">isPragLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-var hs-var">isPragLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630611"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecSig"><span class="hs-identifier hs-type">SpecSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-487"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-var">isPragLSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630611"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#InlineSig"><span class="hs-identifier hs-type">InlineSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-488"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-var">isPragLSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630611"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SCCFunSig"><span class="hs-identifier hs-type">SCCFunSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-489"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-var">isPragLSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630611"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#CompleteMatchSig"><span class="hs-identifier hs-type">CompleteMatchSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-490"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-var">isPragLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-491"></span><span>
</span><span id="line-492"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isInlineLSig"><span class="hs-identifier hs-type">isInlineLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681630618"><span class="annot"><a href="#local-6989586621681630618"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630618"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630618"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-493"></span><span class="hs-comment">-- Identifies inline pragmas</span><span>
</span><span id="line-494"></span><span id="isInlineLSig"><span class="annot"><span class="annottext">isInlineLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isInlineLSig"><span class="hs-identifier hs-var hs-var">isInlineLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630618"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#InlineSig"><span class="hs-identifier hs-type">InlineSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-495"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isInlineLSig"><span class="hs-identifier hs-var">isInlineLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-496"></span><span>
</span><span id="line-497"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isMinimalLSig"><span class="hs-identifier hs-type">isMinimalLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681630622"><span class="annot"><a href="#local-6989586621681630622"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630622"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630622"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-498"></span><span id="isMinimalLSig"><span class="annot"><span class="annottext">isMinimalLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isMinimalLSig"><span class="hs-identifier hs-var hs-var">isMinimalLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630622"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#MinimalSig"><span class="hs-identifier hs-type">MinimalSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-499"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isMinimalLSig"><span class="hs-identifier hs-var">isMinimalLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-500"></span><span>
</span><span id="line-501"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSCCFunSig"><span class="hs-identifier hs-type">isSCCFunSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681630626"><span class="annot"><a href="#local-6989586621681630626"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630626"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630626"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-502"></span><span id="isSCCFunSig"><span class="annot"><span class="annottext">isSCCFunSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isSCCFunSig"><span class="hs-identifier hs-var hs-var">isSCCFunSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630626"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SCCFunSig"><span class="hs-identifier hs-type">SCCFunSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-503"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSCCFunSig"><span class="hs-identifier hs-var">isSCCFunSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-504"></span><span>
</span><span id="line-505"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isCompleteMatchSig"><span class="hs-identifier hs-type">isCompleteMatchSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681630630"><span class="annot"><a href="#local-6989586621681630630"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630630"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630630"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-506"></span><span id="isCompleteMatchSig"><span class="annot"><span class="annottext">isCompleteMatchSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isCompleteMatchSig"><span class="hs-identifier hs-var hs-var">isCompleteMatchSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681630630"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#CompleteMatchSig"><span class="hs-identifier hs-type">CompleteMatchSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-507"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isCompleteMatchSig"><span class="hs-identifier hs-var">isCompleteMatchSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-508"></span><span>
</span><span id="line-509"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection[PatSynBind]{A pattern synonym definition}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-516"></span><span>
</span><span id="line-517"></span><span class="annot"><span class="hs-comment">-- | Haskell Pattern Synonym Details</span></span><span>
</span><span id="line-518"></span><span class="hs-keyword">type</span><span> </span><span id="HsPatSynDetails"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsPatSynDetails"><span class="hs-identifier hs-var">HsPatSynDetails</span></a></span></span><span> </span><span id="local-6989586621681630633"><span class="annot"><a href="#local-6989586621681630633"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsConDetails"><span class="hs-identifier hs-type">HsConDetails</span></a></span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/GHC.Base.html#Void/GHC.Base.html#Void"><span class="hs-identifier hs-type">Void</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630633"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#RecordPatSynField"><span class="hs-identifier hs-type">RecordPatSynField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630633"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-519"></span><span>
</span><span id="line-520"></span><span class="hs-comment">-- See Note [Record PatSyn Fields]</span><span>
</span><span id="line-521"></span><span class="annot"><span class="hs-comment">-- | Record Pattern Synonym Field</span></span><span>
</span><span id="line-522"></span><span class="hs-keyword">data</span><span> </span><span id="RecordPatSynField"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#RecordPatSynField"><span class="hs-identifier hs-var">RecordPatSynField</span></a></span></span><span> </span><span id="local-6989586621681630470"><span class="annot"><a href="#local-6989586621681630470"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-523"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="RecordPatSynField"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#RecordPatSynField"><span class="hs-identifier hs-var">RecordPatSynField</span></a></span></span><span>
</span><span id="line-524"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="recordPatSynField"><span class="annot"><span class="annottext">forall pass. RecordPatSynField pass -&gt; FieldOcc pass
</span><a href="Language.Haskell.Syntax.Binds.html#recordPatSynField"><span class="hs-identifier hs-var hs-var">recordPatSynField</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#FieldOcc"><span class="hs-identifier hs-type">FieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630470"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-525"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ Field label visible in rest of the file</span></span><span>
</span><span id="line-526"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="recordPatSynPatVar"><span class="annot"><span class="annottext">forall pass. RecordPatSynField pass -&gt; LIdP pass
</span><a href="Language.Haskell.Syntax.Binds.html#recordPatSynPatVar"><span class="hs-identifier hs-var hs-var">recordPatSynPatVar</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630470"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-527"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ Filled in by renamer, the name used internally by the pattern</span></span><span>
</span><span id="line-528"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-529"></span><span>
</span><span id="line-530"></span><span>
</span><span id="line-531"></span><span class="hs-comment">{-
Note [Record PatSyn Fields]
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider the following two pattern synonyms.

  pattern P x y = ([x,True], [y,'v'])
  pattern Q{ x, y } =([x,True], [y,'v'])

In P, we just have two local binders, x and y.

In Q, we have local binders but also top-level record selectors
  x :: ([Bool], [Char]) -&gt; Bool
  y :: ([Bool], [Char]) -&gt; Char

Both are recorded in the `RecordPatSynField`s for `x` and `y`:
* recordPatSynField: the top-level record selector
* recordPatSynPatVar: the local `x`, bound only in the RHS of the pattern synonym.

It would make sense to support record-like syntax

  pattern Q{ x=x1, y=y1 } = ([x1,True], [y1,'v'])

when we have a different name for the local and top-level binder,
making the distinction between the two names clear.

-}</span><span>
</span><span id="line-558"></span><span>
</span><span id="line-559"></span><span class="annot"><span class="hs-comment">-- | Haskell Pattern Synonym Direction</span></span><span>
</span><span id="line-560"></span><span class="hs-keyword">data</span><span> </span><span id="HsPatSynDir"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsPatSynDir"><span class="hs-identifier hs-var">HsPatSynDir</span></a></span></span><span> </span><span id="local-6989586621681630638"><span class="annot"><a href="#local-6989586621681630638"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-561"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Unidirectional"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#Unidirectional"><span class="hs-identifier hs-var">Unidirectional</span></a></span></span><span>
</span><span id="line-562"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ImplicitBidirectional"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ImplicitBidirectional"><span class="hs-identifier hs-var">ImplicitBidirectional</span></a></span></span><span>
</span><span id="line-563"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitBidirectional"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ExplicitBidirectional"><span class="hs-identifier hs-var">ExplicitBidirectional</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630638"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681630638"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-564"></span></pre></body></html>