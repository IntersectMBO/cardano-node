<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621681706716"><span id="local-6989586621681706717"><span id="local-6989586621681706718"><span id="local-6989586621681706719"></span></span></span></span><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE ViewPatterns #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE LambdaCase #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-11"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span> </span><span class="hs-comment">-- Wrinkle in Note [Trees That Grow]</span><span>
</span><span id="line-12"></span><span>                                      </span><span class="hs-comment">-- in module Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wno-orphans #-}</span><span> </span><span class="hs-comment">-- Outputable</span><span>
</span><span id="line-15"></span><span>
</span><span id="line-16"></span><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998

\section[PatSyntax]{Abstract Haskell syntax---patterns}
-}</span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">GHC.Hs.Pat</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-24"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier">Pat</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier">LPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier">EpAnnSumPat</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier">ConPatTc</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier">ConLikeP</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpansion"><span class="hs-identifier">HsPatExpansion</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#XXPatGhcTc"><span class="hs-identifier">XXPatGhcTc</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>
</span><span id="line-31"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier">HsConPatDetails</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier">hsConPatArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatTyArg"><span class="hs-identifier">HsConPatTyArg</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier">HsRecFields</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier">HsFieldBind</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsFieldBind"><span class="hs-identifier">LHsFieldBind</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier">HsRecField</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecField"><span class="hs-identifier">LHsRecField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-35"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecUpdField"><span class="hs-identifier">HsRecUpdField</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecUpdField"><span class="hs-identifier">LHsRecUpdField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-36"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier">RecFieldsDotDot</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-37"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFields"><span class="hs-identifier">hsRecFields</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldSel"><span class="hs-identifier">hsRecFieldSel</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#hsRecFieldId"><span class="hs-identifier">hsRecFieldId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldsArgs"><span class="hs-identifier">hsRecFieldsArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldId"><span class="hs-identifier">hsRecUpdFieldId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldOcc"><span class="hs-identifier">hsRecUpdFieldOcc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldRdr"><span class="hs-identifier">hsRecUpdFieldRdr</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier">mkPrefixConPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#mkCharLitPat"><span class="hs-identifier">mkCharLitPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#mkNilPat"><span class="hs-identifier">mkNilPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-41"></span><span>
</span><span id="line-42"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier">isSimplePat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier">looksLazyPatBind</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-44"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier">isBangedLPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-45"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#gParPat"><span class="hs-identifier">gParPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier">patNeedsParens</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#parenthesizePat"><span class="hs-identifier">parenthesizePat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-46"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#isIrrefutableHsPat"><span class="hs-identifier">isIrrefutableHsPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier">collectEvVarsPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPats"><span class="hs-identifier">collectEvVarsPats</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-49"></span><span>
</span><span id="line-50"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier">pprParendLPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier">pprConArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-51"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#pprLPat"><span class="hs-identifier">pprLPat</span></a></span><span>
</span><span id="line-52"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Prelude.html"><span class="hs-identifier">GHC.Prelude</span></a></span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html"><span class="hs-identifier">Language.Haskell.Syntax.Pat</span></a></span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html"><span class="hs-identifier">Language.Haskell.Syntax.Expr</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier">HsExpr</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-58"></span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="hs-pragma">{-# SOURCE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html"><span class="hs-identifier">GHC.Hs.Expr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Expr.html#pprLExpr"><span class="hs-identifier">pprLExpr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#pprUntypedSplice"><span class="hs-identifier">pprUntypedSplice</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#HsUntypedSpliceResult"><span class="hs-identifier">HsUntypedSpliceResult</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span class="hs-comment">-- friends:</span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Binds.html"><span class="hs-identifier">GHC.Hs.Binds</span></a></span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Lit.html"><span class="hs-identifier">GHC.Hs.Lit</span></a></span><span>
</span><span id="line-64"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html"><span class="hs-identifier">Language.Haskell.Syntax.Extension</span></a></span><span>
</span><span id="line-65"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html"><span class="hs-identifier">GHC.Parser.Annotation</span></a></span><span>
</span><span id="line-66"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html"><span class="hs-identifier">GHC.Hs.Extension</span></a></span><span>
</span><span id="line-67"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Type.html"><span class="hs-identifier">GHC.Hs.Type</span></a></span><span>
</span><span id="line-68"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html"><span class="hs-identifier">GHC.Tc.Types.Evidence</span></a></span><span>
</span><span id="line-69"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html"><span class="hs-identifier">GHC.Types.Basic</span></a></span><span>
</span><span id="line-70"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html"><span class="hs-identifier">GHC.Types.SourceText</span></a></span><span>
</span><span id="line-71"></span><span class="hs-comment">-- others:</span><span>
</span><span id="line-72"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Ppr.html"><span class="hs-identifier">GHC.Core.Ppr</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="hs-comment">{- instance OutputableBndr TyVar -}</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-73"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Builtin.Types.html"><span class="hs-identifier">GHC.Builtin.Types</span></a></span><span>
</span><span id="line-74"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Var.html"><span class="hs-identifier">GHC.Types.Var</span></a></span><span>
</span><span id="line-75"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html"><span class="hs-identifier">GHC.Types.Name.Reader</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier">RdrName</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-76"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.ConLike.html"><span class="hs-identifier">GHC.Core.ConLike</span></a></span><span>
</span><span id="line-77"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html"><span class="hs-identifier">GHC.Core.DataCon</span></a></span><span>
</span><span id="line-78"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.TyCon.html"><span class="hs-identifier">GHC.Core.TyCon</span></a></span><span>
</span><span id="line-79"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html"><span class="hs-identifier">GHC.Utils.Outputable</span></a></span><span>
</span><span id="line-80"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Type.html"><span class="hs-identifier">GHC.Core.Type</span></a></span><span>
</span><span id="line-81"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html"><span class="hs-identifier">GHC.Types.SrcLoc</span></a></span><span>
</span><span id="line-82"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html"><span class="hs-identifier">GHC.Data.Bag</span></a></span><span> </span><span class="hs-comment">-- collect ev vars from pats</span><span>
</span><span id="line-83"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.Maybe.html"><span class="hs-identifier">GHC.Data.Maybe</span></a></span><span>
</span><span id="line-84"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.html"><span class="hs-identifier">GHC.Types.Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Name.html#Name"><span class="hs-identifier">Name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.Name.Occurrence.html#dataName"><span class="hs-identifier">dataName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-85"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Driver.Session.html"><span class="hs-identifier">GHC.Driver.Session</span></a></span><span>
</span><span id="line-86"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../ghc-boot-9.6.7/src/GHC.LanguageExtensions.html#/GHC.LanguageExtensions.html"><span class="hs-identifier">GHC.LanguageExtensions</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">LangExt</span></span><span>
</span><span id="line-87"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Data.html#/Data.Data.html"><span class="hs-identifier">Data.Data</span></a></span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XWildPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildPat"><span class="hs-identifier hs-var">XWildPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-91"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XWildPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildPat"><span class="hs-identifier hs-var">XWildPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-92"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XWildPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildPat"><span class="hs-identifier hs-var">XWildPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XVarPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XVarPat"><span class="hs-identifier hs-var">XVarPat</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLazyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLazyPat"><span class="hs-identifier hs-var">XLazyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- For '~'</span><span>
</span><span id="line-97"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLazyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLazyPat"><span class="hs-identifier hs-var">XLazyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-98"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLazyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLazyPat"><span class="hs-identifier hs-var">XLazyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XAsPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAsPat"><span class="hs-identifier hs-var">XAsPat</span></a></span></span><span>   </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnnCO"><span class="hs-identifier hs-type">EpAnnCO</span></a></span><span>
</span><span id="line-101"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XAsPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAsPat"><span class="hs-identifier hs-var">XAsPat</span></a></span></span><span>   </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-102"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XAsPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAsPat"><span class="hs-identifier hs-var">XAsPat</span></a></span></span><span>   </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-103"></span><span>
</span><span id="line-104"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XParPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParPat"><span class="hs-identifier hs-var">XParPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnnCO"><span class="hs-identifier hs-type">EpAnnCO</span></a></span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XBangPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangPat"><span class="hs-identifier hs-var">XBangPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- For '!'</span><span>
</span><span id="line-107"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XBangPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangPat"><span class="hs-identifier hs-var">XBangPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-108"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XBangPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangPat"><span class="hs-identifier hs-var">XBangPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-109"></span><span>
</span><span id="line-110"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XListPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListPat"><span class="hs-identifier hs-var">XListPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#AnnList"><span class="hs-identifier hs-type">AnnList</span></a></span><span>
</span><span id="line-111"></span><span>  </span><span class="hs-comment">-- After parsing, ListPat can refer to a built-in Haskell list pattern</span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-comment">-- or an overloaded list pattern.</span><span>
</span><span id="line-113"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XListPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListPat"><span class="hs-identifier hs-var">XListPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-comment">-- Built-in list patterns only.</span><span>
</span><span id="line-115"></span><span>  </span><span class="hs-comment">-- After renaming, overloaded list patterns are expanded to view patterns.</span><span>
</span><span id="line-116"></span><span>  </span><span class="hs-comment">-- See Note [Desugaring overloaded list patterns]</span><span>
</span><span id="line-117"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XListPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListPat"><span class="hs-identifier hs-var">XListPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-118"></span><span>  </span><span class="hs-comment">-- List element type, for use in hsPatType.</span><span>
</span><span id="line-119"></span><span>
</span><span id="line-120"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XTuplePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTuplePat"><span class="hs-identifier hs-var">XTuplePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-121"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XTuplePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTuplePat"><span class="hs-identifier hs-var">XTuplePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-122"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XTuplePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTuplePat"><span class="hs-identifier hs-var">XTuplePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-123"></span><span>
</span><span id="line-124"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSumPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumPat"><span class="hs-identifier hs-var">XSumPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-type">EpAnnSumPat</span></a></span><span>
</span><span id="line-125"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSumPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumPat"><span class="hs-identifier hs-var">XSumPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-126"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSumPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumPat"><span class="hs-identifier hs-var">XSumPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConPat"><span class="hs-identifier hs-var">XConPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-129"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConPat"><span class="hs-identifier hs-var">XConPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-130"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConPat"><span class="hs-identifier hs-var">XConPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XViewPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViewPat"><span class="hs-identifier hs-var">XViewPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-133"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XViewPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViewPat"><span class="hs-identifier hs-var">XViewPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-134"></span><span>  </span><span class="hs-comment">-- The @HsExpr GhcRn@ gives an inverse to the view function.</span><span>
</span><span id="line-135"></span><span>  </span><span class="hs-comment">-- This is used for overloaded lists in particular.</span><span>
</span><span id="line-136"></span><span>  </span><span class="hs-comment">-- See Note [Invertible view patterns] in GHC.Tc.TyCl.PatSyn.</span><span>
</span><span id="line-137"></span><span>
</span><span id="line-138"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XViewPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViewPat"><span class="hs-identifier hs-var">XViewPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-139"></span><span>  </span><span class="hs-comment">-- Overall type of the pattern</span><span>
</span><span id="line-140"></span><span>  </span><span class="hs-comment">-- (= the argument type of the view function), for hsPatType.</span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSplicePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSplicePat"><span class="hs-identifier hs-var">XSplicePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-143"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSplicePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSplicePat"><span class="hs-identifier hs-var">XSplicePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#HsUntypedSpliceResult"><span class="hs-identifier hs-type">HsUntypedSpliceResult</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- See Note [Lifecycle of a splice] in GHC.Hs.Expr</span><span>
</span><span id="line-144"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSplicePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSplicePat"><span class="hs-identifier hs-var">XSplicePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#DataConCantHappen"><span class="hs-identifier hs-type">DataConCantHappen</span></a></span><span>
</span><span id="line-145"></span><span>
</span><span id="line-146"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLitPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLitPat"><span class="hs-identifier hs-var">XLitPat</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-147"></span><span>
</span><span id="line-148"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPat"><span class="hs-identifier hs-var">XNPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-149"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPat"><span class="hs-identifier hs-var">XNPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-150"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPat"><span class="hs-identifier hs-var">XNPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-151"></span><span>
</span><span id="line-152"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPlusKPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPlusKPat"><span class="hs-identifier hs-var">XNPlusKPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span> </span><span class="hs-comment">-- Of the &quot;+&quot;</span><span>
</span><span id="line-153"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPlusKPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPlusKPat"><span class="hs-identifier hs-var">XNPlusKPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-154"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPlusKPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPlusKPat"><span class="hs-identifier hs-var">XNPlusKPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-155"></span><span>
</span><span id="line-156"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSigPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigPat"><span class="hs-identifier hs-var">XSigPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-157"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSigPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigPat"><span class="hs-identifier hs-var">XSigPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-158"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSigPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigPat"><span class="hs-identifier hs-var">XSigPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XXPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPat"><span class="hs-identifier hs-var">XXPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#DataConCantHappen"><span class="hs-identifier hs-type">DataConCantHappen</span></a></span><span>
</span><span id="line-161"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XXPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPat"><span class="hs-identifier hs-var">XXPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpansion"><span class="hs-identifier hs-type">HsPatExpansion</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-162"></span><span>  </span><span class="hs-comment">-- Original pattern and its desugaring/expansion.</span><span>
</span><span id="line-163"></span><span>  </span><span class="hs-comment">-- See Note [Rebindable syntax and HsExpansion].</span><span>
</span><span id="line-164"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XXPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPat"><span class="hs-identifier hs-var">XXPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#XXPatGhcTc"><span class="hs-identifier hs-type">XXPatGhcTc</span></a></span><span>
</span><span id="line-165"></span><span>  </span><span class="hs-comment">-- After typechecking, we add extra constructors: CoPat and HsExpansion.</span><span>
</span><span id="line-166"></span><span>  </span><span class="hs-comment">-- HsExpansion allows us to handle RebindableSyntax in pattern position:</span><span>
</span><span id="line-167"></span><span>  </span><span class="hs-comment">-- see &quot;XXExpr GhcTc&quot; for the counterpart in expressions.</span><span>
</span><span id="line-168"></span><span>
</span><span id="line-169"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="ConLikeP"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-var">ConLikeP</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span> </span><span class="hs-comment">-- IdP GhcPs</span><span>
</span><span id="line-170"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="ConLikeP"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-var">ConLikeP</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.Name.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>    </span><span class="hs-comment">-- IdP GhcRn</span><span>
</span><span id="line-171"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="ConLikeP"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-var">ConLikeP</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.ConLike.html#ConLike"><span class="hs-identifier hs-type">ConLike</span></a></span><span>
</span><span id="line-172"></span><span>
</span><span id="line-173"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XHsFieldBind"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsFieldBind"><span class="hs-identifier hs-var">XHsFieldBind</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-174"></span><span>
</span><span id="line-175"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-176"></span><span>
</span><span id="line-177"></span><span class="hs-comment">-- API Annotations types</span><span>
</span><span id="line-178"></span><span>
</span><span id="line-179"></span><span class="hs-keyword">data</span><span> </span><span id="EpAnnSumPat"><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-var">EpAnnSumPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="EpAnnSumPat"><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-var">EpAnnSumPat</span></a></span></span><span>
</span><span id="line-180"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="sumPatParens"><span class="annot"><span class="annottext">EpAnnSumPat -&gt; [AddEpAnn]
</span><a href="GHC.Hs.Pat.html#sumPatParens"><span class="hs-identifier hs-var hs-var">sumPatParens</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-181"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="sumPatVbarsBefore"><span class="annot"><span class="annottext">EpAnnSumPat -&gt; [EpaLocation]
</span><a href="GHC.Hs.Pat.html#sumPatVbarsBefore"><span class="hs-identifier hs-var hs-var">sumPatVbarsBefore</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-182"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="sumPatVbarsAfter"><span class="annot"><span class="annottext">EpAnnSumPat -&gt; [EpaLocation]
</span><a href="GHC.Hs.Pat.html#sumPatVbarsAfter"><span class="hs-identifier hs-var hs-var">sumPatVbarsAfter</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-183"></span><span>      </span><span class="hs-special">}</span><span> </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681706761"><span id="local-6989586621681706769"><span id="local-6989586621681706776"><span id="local-6989586621681706778"><span id="local-6989586621681706780"><span id="local-6989586621681706786"><span id="local-6989586621681706791"><span id="local-6989586621681706794"><span id="local-6989586621681706797"><span id="local-6989586621681706800"><span id="local-6989586621681706803"><span id="local-6989586621681706806"><span id="local-6989586621681706811"><span id="local-6989586621681706816"><span class="annot"><span class="annottext">Typeable EpAnnSumPat
Typeable EpAnnSumPat =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat)
-&gt; (EpAnnSumPat -&gt; Constr)
-&gt; (EpAnnSumPat -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c EpAnnSumPat))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat)
-&gt; Data EpAnnSumPat
EpAnnSumPat -&gt; Constr
EpAnnSumPat -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c EpAnnSumPat)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat
$ctoConstr :: EpAnnSumPat -&gt; Constr
toConstr :: EpAnnSumPat -&gt; Constr
$cdataTypeOf :: EpAnnSumPat -&gt; DataType
dataTypeOf :: EpAnnSumPat -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c EpAnnSumPat)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c EpAnnSumPat)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
</span><a href="../../base-4.18.3.0/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-184"></span><span>
</span><span id="line-185"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-186"></span><span>
</span><span id="line-187"></span><span class="annot"><span class="hs-comment">-- | Extension constructor for Pat, added after typechecking.</span></span><span>
</span><span id="line-188"></span><span class="hs-keyword">data</span><span> </span><span id="XXPatGhcTc"><span class="annot"><a href="GHC.Hs.Pat.html#XXPatGhcTc"><span class="hs-identifier hs-var">XXPatGhcTc</span></a></span></span><span>
</span><span id="line-189"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | Coercion Pattern (translation only)</span><span>
</span><span id="line-190"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-191"></span><span>    </span><span class="hs-comment">-- During desugaring a (CoPat co pat) turns into a cast with 'co' on the</span><span>
</span><span id="line-192"></span><span>    </span><span class="hs-comment">-- scrutinee, followed by a match on 'pat'.</span><span>
</span><span id="line-193"></span><span>    </span><span id="CoPat"><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-var">CoPat</span></a></span></span><span>
</span><span id="line-194"></span><span>      </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- | Coercion Pattern</span><span>
</span><span id="line-195"></span><span>        </span><span class="hs-comment">-- If co :: t1 ~ t2, p :: t2,</span><span>
</span><span id="line-196"></span><span>        </span><span class="hs-comment">-- then (CoPat co p) :: t1</span><span>
</span><span id="line-197"></span><span>        </span><span id="co_cpt_wrap"><span class="annot"><span class="annottext">XXPatGhcTc -&gt; HsWrapper
</span><a href="GHC.Hs.Pat.html#co_cpt_wrap"><span class="hs-identifier hs-var hs-var">co_cpt_wrap</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#HsWrapper"><span class="hs-identifier hs-type">HsWrapper</span></a></span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-comment">-- | Why not LPat?  Ans: existing locn will do</span></span><span>
</span><span id="line-200"></span><span>        </span><span id="co_pat_inner"><span class="annot"><span class="annottext">XXPatGhcTc -&gt; Pat GhcTc
</span><a href="GHC.Hs.Pat.html#co_pat_inner"><span class="hs-identifier hs-var hs-var">co_pat_inner</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-201"></span><span>
</span><span id="line-202"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-comment">-- | Type of whole pattern, t1</span></span><span>
</span><span id="line-203"></span><span>        </span><span id="co_pat_ty"><span class="annot"><span class="annottext">XXPatGhcTc -&gt; Type
</span><a href="GHC.Hs.Pat.html#co_pat_ty"><span class="hs-identifier hs-var hs-var">co_pat_ty</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-204"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-205"></span><span>  </span><span class="hs-comment">-- | Pattern expansion: original pattern, and desugared pattern,</span><span>
</span><span id="line-206"></span><span>  </span><span class="hs-comment">-- for RebindableSyntax and other overloaded syntax such as OverloadedLists.</span><span>
</span><span id="line-207"></span><span>  </span><span class="hs-comment">-- See Note [Rebindable syntax and HsExpansion].</span><span>
</span><span id="line-208"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExpansionPat"><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-var">ExpansionPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-209"></span><span>
</span><span id="line-210"></span><span>
</span><span id="line-211"></span><span class="hs-comment">-- See Note [Rebindable syntax and HsExpansion].</span><span>
</span><span id="line-212"></span><span class="hs-keyword">data</span><span> </span><span id="HsPatExpansion"><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpansion"><span class="hs-identifier hs-var">HsPatExpansion</span></a></span></span><span> </span><span id="local-6989586621681706828"><span class="annot"><a href="#local-6989586621681706828"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621681706829"><span class="annot"><a href="#local-6989586621681706829"><span class="hs-identifier hs-type">b</span></a></span></span><span>
</span><span id="line-213"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsPatExpanded"><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-var">HsPatExpanded</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621681706828"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706829"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-214"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681706838"><span id="local-6989586621681706842"><span id="local-6989586621681706846"><span id="local-6989586621681706848"><span id="local-6989586621681706850"><span id="local-6989586621681706856"><span id="local-6989586621681706863"><span id="local-6989586621681706866"><span id="local-6989586621681706869"><span id="local-6989586621681706872"><span id="local-6989586621681706875"><span id="local-6989586621681706878"><span id="local-6989586621681706883"><span id="local-6989586621681706888"><span class="annot"><span class="annottext">Typeable (HsPatExpansion a b)
Typeable (HsPatExpansion a b) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; HsPatExpansion a b
 -&gt; c (HsPatExpansion a b))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsPatExpansion a b))
-&gt; (HsPatExpansion a b -&gt; Constr)
-&gt; (HsPatExpansion a b -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (HsPatExpansion a b)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (HsPatExpansion a b)))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; HsPatExpansion a b -&gt; HsPatExpansion a b)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b))
-&gt; Data (HsPatExpansion a b)
HsPatExpansion a b -&gt; Constr
HsPatExpansion a b -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; HsPatExpansion a b -&gt; HsPatExpansion a b
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; [u]
forall a b. (Data a, Data b) =&gt; Typeable (HsPatExpansion a b)
forall a b. (Data a, Data b) =&gt; HsPatExpansion a b -&gt; Constr
forall a b. (Data a, Data b) =&gt; HsPatExpansion a b -&gt; DataType
forall a b.
(Data a, Data b) =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; HsPatExpansion a b -&gt; HsPatExpansion a b
forall a b u.
(Data a, Data b) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; u
forall a b u.
(Data a, Data b) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; [u]
forall a b r r'.
(Data a, Data b) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
forall a b r r'.
(Data a, Data b) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
forall a b (m :: * -&gt; *).
(Data a, Data b, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
forall a b (m :: * -&gt; *).
(Data a, Data b, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
forall a b (c :: * -&gt; *).
(Data a, Data b) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsPatExpansion a b)
forall a b (c :: * -&gt; *).
(Data a, Data b) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsPatExpansion a b
-&gt; c (HsPatExpansion a b)
forall a b (t :: * -&gt; *) (c :: * -&gt; *).
(Data a, Data b, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (HsPatExpansion a b))
forall a b (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data a, Data b, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsPatExpansion a b))
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsPatExpansion a b)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsPatExpansion a b
-&gt; c (HsPatExpansion a b)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (HsPatExpansion a b))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsPatExpansion a b))
$cgfoldl :: forall a b (c :: * -&gt; *).
(Data a, Data b) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsPatExpansion a b
-&gt; c (HsPatExpansion a b)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsPatExpansion a b
-&gt; c (HsPatExpansion a b)
$cgunfold :: forall a b (c :: * -&gt; *).
(Data a, Data b) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsPatExpansion a b)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsPatExpansion a b)
$ctoConstr :: forall a b. (Data a, Data b) =&gt; HsPatExpansion a b -&gt; Constr
toConstr :: HsPatExpansion a b -&gt; Constr
$cdataTypeOf :: forall a b. (Data a, Data b) =&gt; HsPatExpansion a b -&gt; DataType
dataTypeOf :: HsPatExpansion a b -&gt; DataType
$cdataCast1 :: forall a b (t :: * -&gt; *) (c :: * -&gt; *).
(Data a, Data b, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (HsPatExpansion a b))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (HsPatExpansion a b))
$cdataCast2 :: forall a b (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data a, Data b, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsPatExpansion a b))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsPatExpansion a b))
$cgmapT :: forall a b.
(Data a, Data b) =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; HsPatExpansion a b -&gt; HsPatExpansion a b
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; HsPatExpansion a b -&gt; HsPatExpansion a b
$cgmapQl :: forall a b r r'.
(Data a, Data b) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
$cgmapQr :: forall a b r r'.
(Data a, Data b) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsPatExpansion a b -&gt; r
$cgmapQ :: forall a b u.
(Data a, Data b) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; [u]
$cgmapQi :: forall a b u.
(Data a, Data b) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsPatExpansion a b -&gt; u
$cgmapM :: forall a b (m :: * -&gt; *).
(Data a, Data b, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
$cgmapMp :: forall a b (m :: * -&gt; *).
(Data a, Data b, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
$cgmapMo :: forall a b (m :: * -&gt; *).
(Data a, Data b, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsPatExpansion a b -&gt; m (HsPatExpansion a b)
</span><a href="../../base-4.18.3.0/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-215"></span><span>
</span><span id="line-216"></span><span class="hs-comment">-- | This is the extension field for ConPat, added after typechecking</span><span>
</span><span id="line-217"></span><span class="hs-comment">-- It adds quite a few extra fields, to support elaboration of pattern matching.</span><span>
</span><span id="line-218"></span><span class="hs-keyword">data</span><span> </span><span id="ConPatTc"><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-var">ConPatTc</span></a></span></span><span>
</span><span id="line-219"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ConPatTc"><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-var">ConPatTc</span></a></span></span><span>
</span><span id="line-220"></span><span>    </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- | The universal arg types  1-1 with the universal</span><span>
</span><span id="line-221"></span><span>      </span><span class="hs-comment">-- tyvars of the constructor/pattern synonym</span><span>
</span><span id="line-222"></span><span>      </span><span class="hs-comment">-- Use (conLikeResTy pat_con cpt_arg_tys) to get</span><span>
</span><span id="line-223"></span><span>      </span><span class="hs-comment">-- the type of the pattern</span><span>
</span><span id="line-224"></span><span>      </span><span id="cpt_arg_tys"><span class="annot"><span class="annottext">ConPatTc -&gt; [Type]
</span><a href="GHC.Hs.Pat.html#cpt_arg_tys"><span class="hs-identifier hs-var hs-var">cpt_arg_tys</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-225"></span><span>
</span><span id="line-226"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Existentially bound type variables</span><span>
</span><span id="line-227"></span><span>      </span><span class="hs-comment">-- in correctly-scoped order e.g. [k:*  x:k]</span><span>
</span><span id="line-228"></span><span>      </span><span id="cpt_tvs"><span class="annot"><span class="annottext">ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_tvs"><span class="hs-identifier hs-var hs-var">cpt_tvs</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Ditto *coercion variables* and *dictionaries*</span><span>
</span><span id="line-231"></span><span>      </span><span class="hs-comment">-- One reason for putting coercion variable here  I think</span><span>
</span><span id="line-232"></span><span>      </span><span class="hs-comment">--      is to ensure their kinds are zonked</span><span>
</span><span id="line-233"></span><span>      </span><span id="cpt_dicts"><span class="annot"><span class="annottext">ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var hs-var">cpt_dicts</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-234"></span><span>
</span><span id="line-235"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-comment">-- | Bindings involving those dictionaries</span></span><span>
</span><span id="line-236"></span><span>      </span><span id="cpt_binds"><span class="annot"><span class="annottext">ConPatTc -&gt; TcEvBinds
</span><a href="GHC.Hs.Pat.html#cpt_binds"><span class="hs-identifier hs-var hs-var">cpt_binds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#TcEvBinds"><span class="hs-identifier hs-type">TcEvBinds</span></a></span><span>
</span><span id="line-237"></span><span>
</span><span id="line-238"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Extra wrapper to pass to the matcher</span><span>
</span><span id="line-239"></span><span>      </span><span class="hs-comment">-- Only relevant for pattern-synonyms;</span><span>
</span><span id="line-240"></span><span>      </span><span class="hs-comment">--   ignored for data cons</span><span>
</span><span id="line-241"></span><span>      </span><span id="cpt_wrap"><span class="annot"><span class="annottext">ConPatTc -&gt; HsWrapper
</span><a href="GHC.Hs.Pat.html#cpt_wrap"><span class="hs-identifier hs-var hs-var">cpt_wrap</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#HsWrapper"><span class="hs-identifier hs-type">HsWrapper</span></a></span><span>
</span><span id="line-242"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-243"></span><span>
</span><span id="line-244"></span><span id="local-6989586621681706412"><span class="annot"><a href="GHC.Hs.Pat.html#hsRecFieldId"><span class="hs-identifier hs-type">hsRecFieldId</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier hs-type">HsRecField</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706412"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Var.html#Id"><span class="hs-identifier hs-type">Id</span></a></span></span><span>
</span><span id="line-245"></span><span id="hsRecFieldId"><span class="annot"><span class="annottext">hsRecFieldId :: forall arg. HsRecField GhcTc arg -&gt; TyVar
</span><a href="GHC.Hs.Pat.html#hsRecFieldId"><span class="hs-identifier hs-var hs-var">hsRecFieldId</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsRecField GhcTc arg -&gt; XCFieldOcc GhcTc
HsRecField GhcTc arg -&gt; TyVar
forall p arg. UnXRec p =&gt; HsRecField p arg -&gt; XCFieldOcc p
</span><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldSel"><span class="hs-identifier hs-var">hsRecFieldSel</span></a></span><span>
</span><span id="line-246"></span><span>
</span><span id="line-247"></span><span id="local-6989586621681706418"><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldRdr"><span class="hs-identifier hs-type">hsRecUpdFieldRdr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecUpdField"><span class="hs-identifier hs-type">HsRecUpdField</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706418"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span></span><span>
</span><span id="line-248"></span><span id="hsRecUpdFieldRdr"><span class="annot"><span class="annottext">hsRecUpdFieldRdr :: forall (p :: Pass). HsRecUpdField (GhcPass p) -&gt; Located RdrName
</span><a href="GHC.Hs.Pat.html#hsRecUpdFieldRdr"><span class="hs-identifier hs-var hs-var">hsRecUpdFieldRdr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(AmbiguousFieldOcc (GhcPass p) -&gt; RdrName)
-&gt; GenLocated SrcSpan (AmbiguousFieldOcc (GhcPass p))
-&gt; Located RdrName
forall a b.
(a -&gt; b) -&gt; GenLocated SrcSpan a -&gt; GenLocated SrcSpan b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#fmap/GHC.Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">AmbiguousFieldOcc (GhcPass p) -&gt; RdrName
forall (p :: Pass). AmbiguousFieldOcc (GhcPass p) -&gt; RdrName
</span><a href="GHC.Hs.Type.html#rdrNameAmbiguousFieldOcc"><span class="hs-identifier hs-var">rdrNameAmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpan (AmbiguousFieldOcc (GhcPass p))
 -&gt; Located RdrName)
-&gt; (HsFieldBind
      (LocatedAn NoEpAnns (AmbiguousFieldOcc (GhcPass p)))
      (GenLocated (Anno (HsExpr (GhcPass p))) (HsExpr (GhcPass p)))
    -&gt; GenLocated SrcSpan (AmbiguousFieldOcc (GhcPass p)))
-&gt; HsFieldBind
     (LocatedAn NoEpAnns (AmbiguousFieldOcc (GhcPass p)))
     (GenLocated (Anno (HsExpr (GhcPass p))) (HsExpr (GhcPass p)))
-&gt; Located RdrName
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedAn NoEpAnns (AmbiguousFieldOcc (GhcPass p))
-&gt; GenLocated SrcSpan (AmbiguousFieldOcc (GhcPass p))
forall a e. LocatedAn a e -&gt; Located e
</span><a href="GHC.Parser.Annotation.html#reLoc"><span class="hs-identifier hs-var">reLoc</span></a></span><span> </span><span class="annot"><span class="annottext">(LocatedAn NoEpAnns (AmbiguousFieldOcc (GhcPass p))
 -&gt; GenLocated SrcSpan (AmbiguousFieldOcc (GhcPass p)))
-&gt; (HsFieldBind
      (LocatedAn NoEpAnns (AmbiguousFieldOcc (GhcPass p)))
      (GenLocated (Anno (HsExpr (GhcPass p))) (HsExpr (GhcPass p)))
    -&gt; LocatedAn NoEpAnns (AmbiguousFieldOcc (GhcPass p)))
-&gt; HsFieldBind
     (LocatedAn NoEpAnns (AmbiguousFieldOcc (GhcPass p)))
     (GenLocated (Anno (HsExpr (GhcPass p))) (HsExpr (GhcPass p)))
-&gt; GenLocated SrcSpan (AmbiguousFieldOcc (GhcPass p))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">HsFieldBind
  (LocatedAn NoEpAnns (AmbiguousFieldOcc (GhcPass p)))
  (GenLocated (Anno (HsExpr (GhcPass p))) (HsExpr (GhcPass p)))
-&gt; LocatedAn NoEpAnns (AmbiguousFieldOcc (GhcPass p))
forall lhs rhs. HsFieldBind lhs rhs -&gt; lhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbLHS"><span class="hs-identifier hs-var">hfbLHS</span></a></span><span>
</span><span id="line-249"></span><span>
</span><span id="line-250"></span><span id="local-6989586621681706445"><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldId"><span class="hs-identifier hs-type">hsRecUpdFieldId</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LAmbiguousFieldOcc"><span class="hs-identifier hs-type">LAmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681706445"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#Id"><span class="hs-identifier hs-type">Id</span></a></span></span><span>
</span><span id="line-251"></span><span id="hsRecUpdFieldId"><span class="annot"><span class="annottext">hsRecUpdFieldId :: forall arg.
HsFieldBind (LAmbiguousFieldOcc GhcTc) arg -&gt; Located TyVar
</span><a href="GHC.Hs.Pat.html#hsRecUpdFieldId"><span class="hs-identifier hs-var hs-var">hsRecUpdFieldId</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(FieldOcc GhcTc -&gt; TyVar)
-&gt; GenLocated SrcSpan (FieldOcc GhcTc) -&gt; Located TyVar
forall a b.
(a -&gt; b) -&gt; GenLocated SrcSpan a -&gt; GenLocated SrcSpan b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#fmap/GHC.Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">FieldOcc GhcTc -&gt; XCFieldOcc GhcTc
FieldOcc GhcTc -&gt; TyVar
forall pass. FieldOcc pass -&gt; XCFieldOcc pass
</span><a href="Language.Haskell.Syntax.Type.html#foExt"><span class="hs-identifier hs-var">foExt</span></a></span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpan (FieldOcc GhcTc) -&gt; Located TyVar)
-&gt; (HsFieldBind
      (GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)) arg
    -&gt; GenLocated SrcSpan (FieldOcc GhcTc))
-&gt; HsFieldBind
     (GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)) arg
-&gt; Located TyVar
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedAn NoEpAnns (FieldOcc GhcTc)
-&gt; GenLocated SrcSpan (FieldOcc GhcTc)
forall a e. LocatedAn a e -&gt; Located e
</span><a href="GHC.Parser.Annotation.html#reLoc"><span class="hs-identifier hs-var">reLoc</span></a></span><span> </span><span class="annot"><span class="annottext">(LocatedAn NoEpAnns (FieldOcc GhcTc)
 -&gt; GenLocated SrcSpan (FieldOcc GhcTc))
-&gt; (HsFieldBind
      (GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)) arg
    -&gt; LocatedAn NoEpAnns (FieldOcc GhcTc))
-&gt; HsFieldBind
     (GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)) arg
-&gt; GenLocated SrcSpan (FieldOcc GhcTc)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">HsFieldBind (LAmbiguousFieldOcc GhcTc) arg -&gt; LFieldOcc GhcTc
HsFieldBind
  (GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)) arg
-&gt; LocatedAn NoEpAnns (FieldOcc GhcTc)
forall arg.
HsFieldBind (LAmbiguousFieldOcc GhcTc) arg -&gt; LFieldOcc GhcTc
</span><a href="GHC.Hs.Pat.html#hsRecUpdFieldOcc"><span class="hs-identifier hs-var">hsRecUpdFieldOcc</span></a></span><span>
</span><span id="line-252"></span><span>
</span><span id="line-253"></span><span id="local-6989586621681706451"><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldOcc"><span class="hs-identifier hs-type">hsRecUpdFieldOcc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LAmbiguousFieldOcc"><span class="hs-identifier hs-type">LAmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681706451"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LFieldOcc"><span class="hs-identifier hs-type">LFieldOcc</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span></span><span>
</span><span id="line-254"></span><span id="hsRecUpdFieldOcc"><span class="annot"><span class="annottext">hsRecUpdFieldOcc :: forall arg.
HsFieldBind (LAmbiguousFieldOcc GhcTc) arg -&gt; LFieldOcc GhcTc
</span><a href="GHC.Hs.Pat.html#hsRecUpdFieldOcc"><span class="hs-identifier hs-var hs-var">hsRecUpdFieldOcc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(AmbiguousFieldOcc GhcTc -&gt; FieldOcc GhcTc)
-&gt; GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)
-&gt; LocatedAn NoEpAnns (FieldOcc GhcTc)
forall a b.
(a -&gt; b)
-&gt; GenLocated (SrcAnn NoEpAnns) a -&gt; GenLocated (SrcAnn NoEpAnns) b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#fmap/GHC.Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">AmbiguousFieldOcc GhcTc -&gt; FieldOcc GhcTc
</span><a href="GHC.Hs.Type.html#unambiguousFieldOcc"><span class="hs-identifier hs-var">unambiguousFieldOcc</span></a></span><span> </span><span class="annot"><span class="annottext">(GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)
 -&gt; LocatedAn NoEpAnns (FieldOcc GhcTc))
-&gt; (HsFieldBind
      (GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)) arg
    -&gt; GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc))
-&gt; HsFieldBind
     (GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)) arg
-&gt; LocatedAn NoEpAnns (FieldOcc GhcTc)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">HsFieldBind
  (GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)) arg
-&gt; GenLocated (SrcAnn NoEpAnns) (AmbiguousFieldOcc GhcTc)
forall lhs rhs. HsFieldBind lhs rhs -&gt; lhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbLHS"><span class="hs-identifier hs-var">hfbLHS</span></a></span><span>
</span><span id="line-255"></span><span>
</span><span id="line-256"></span><span>
</span><span id="line-257"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
*              Printing patterns
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-264"></span><span>
</span><span id="line-265"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681706459"><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsPatSigType"><span class="hs-identifier hs-type">HsPatSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706459"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatTyArg"><span class="hs-identifier hs-type">HsConPatTyArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706459"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-266"></span><span>  </span><span id="local-6989586621681706922"><span class="annot"><span class="annottext">ppr :: HsConPatTyArg p -&gt; SDoc
</span><a href="#local-6989586621681706922"><span class="hs-identifier hs-var hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatTyArg"><span class="hs-identifier hs-type">HsConPatTyArg</span></a></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;@&quot; p
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681706925"><span class="annot"><span class="annottext">HsPatSigType p
</span><a href="#local-6989586621681706925"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'@'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">HsPatSigType p -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsPatSigType p
</span><a href="#local-6989586621681706925"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-267"></span><span>
</span><span id="line-268"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681706467"><span id="local-6989586621681706468"><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706467"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706468"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier hs-type">HsRecField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706468"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706467"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706468"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-type">RecFieldsDotDot</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~</span></span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-type">RecFieldsDotDot</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-269"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706468"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706467"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-270"></span><span>  </span><span id="local-6989586621681706950"><span class="annot"><span class="annottext">ppr :: HsRecFields p arg -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">rec_flds :: forall p arg. HsRecFields p arg -&gt; [LHsRecField p arg]
</span><a href="Language.Haskell.Syntax.Pat.html#rec_flds"><span class="hs-identifier hs-var">rec_flds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681706953"><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)]
</span><a href="#local-6989586621681706953"><span class="hs-identifier hs-var">flds</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">rec_dotdot :: forall p arg. HsRecFields p arg -&gt; Maybe (XRec p RecFieldsDotDot)
</span><a href="Language.Haskell.Syntax.Pat.html#rec_dotdot"><span class="hs-identifier hs-var">rec_dotdot</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (XRec p RecFieldsDotDot)
</span><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Nothing/GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-271"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#braces"><span class="hs-identifier hs-var">braces</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SDoc -&gt; [SDoc] -&gt; [SDoc]
forall doc. IsLine doc =&gt; doc -&gt; [doc] -&gt; [doc]
</span><a href="GHC.Utils.Outputable.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
forall doc. IsLine doc =&gt; doc
</span><a href="GHC.Utils.Outputable.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(XRec p (HsRecField p arg) -&gt; SDoc)
-&gt; [XRec p (HsRecField p arg)] -&gt; [SDoc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">XRec p (HsRecField p arg) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)]
</span><a href="#local-6989586621681706953"><span class="hs-identifier hs-var">flds</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-272"></span><span>  </span><span class="annot"><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">rec_flds :: forall p arg. HsRecFields p arg -&gt; [LHsRecField p arg]
</span><a href="Language.Haskell.Syntax.Pat.html#rec_flds"><span class="hs-identifier hs-var">rec_flds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681706959"><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)]
</span><a href="#local-6989586621681706959"><span class="hs-identifier hs-var">flds</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">rec_dotdot :: forall p arg. HsRecFields p arg -&gt; Maybe (XRec p RecFieldsDotDot)
</span><a href="Language.Haskell.Syntax.Pat.html#rec_dotdot"><span class="hs-identifier hs-var">rec_dotdot</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">XRec p RecFieldsDotDot -&gt; RecFieldsDotDot
Located RecFieldsDotDot -&gt; RecFieldsDotDot
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-type">RecFieldsDotDot</span></a></span><span> </span><span id="local-6989586621681706962"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681706962"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-273"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#braces"><span class="hs-identifier hs-var">braces</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SDoc -&gt; [SDoc] -&gt; [SDoc]
forall doc. IsLine doc =&gt; doc -&gt; [doc] -&gt; [doc]
</span><a href="GHC.Utils.Outputable.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
forall doc. IsLine doc =&gt; doc
</span><a href="GHC.Utils.Outputable.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(XRec p (HsRecField p arg) -&gt; SDoc)
-&gt; [XRec p (HsRecField p arg)] -&gt; [SDoc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">XRec p (HsRecField p arg) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; [XRec p (HsRecField p arg)] -&gt; [XRec p (HsRecField p arg)]
forall a. Int -&gt; [a] -&gt; [a]
</span><a href="../../base-4.18.3.0/src/GHC.List.html#take/GHC.List.html#take"><span class="hs-identifier hs-var">take</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681706962"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)]
</span><a href="#local-6989586621681706959"><span class="hs-identifier hs-var">flds</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; [SDoc] -&gt; [SDoc]
forall a. [a] -&gt; [a] -&gt; [a]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%2B%2B/GHC.Base.html#%2B%2B"><span class="hs-operator hs-var">++</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681706964"><span class="hs-identifier hs-var">dotdot</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-274"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-275"></span><span>          </span><span id="local-6989586621681706964"><span class="annot"><span class="annottext">dotdot :: SDoc
</span><a href="#local-6989586621681706964"><span class="hs-identifier hs-var hs-var">dotdot</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;..&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsOutput doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#whenPprDebug"><span class="hs-identifier hs-var">whenPprDebug</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)] -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; [XRec p (HsRecField p arg)] -&gt; [XRec p (HsRecField p arg)]
forall a. Int -&gt; [a] -&gt; [a]
</span><a href="../../base-4.18.3.0/src/GHC.List.html#drop/GHC.List.html#drop"><span class="hs-identifier hs-var">drop</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681706962"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[XRec p (HsRecField p arg)]
</span><a href="#local-6989586621681706959"><span class="hs-identifier hs-var">flds</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-276"></span><span>
</span><span id="line-277"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681706492"><span id="local-6989586621681706493"><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706492"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#OutputableBndr"><span class="hs-identifier hs-type">OutputableBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706492"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706493"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-278"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706492"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706493"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-279"></span><span>  </span><span id="local-6989586621681706980"><span class="annot"><span class="annottext">ppr :: HsFieldBind p arg -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">hfbLHS :: forall lhs rhs. HsFieldBind lhs rhs -&gt; lhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbLHS"><span class="hs-identifier hs-var">hfbLHS</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681706982"><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621681706982"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">hfbRHS :: forall lhs rhs. HsFieldBind lhs rhs -&gt; rhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbRHS"><span class="hs-identifier hs-var">hfbRHS</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681706984"><span class="annot"><span class="annottext">arg
</span><a href="#local-6989586621681706984"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-special">,</span><span>
</span><span id="line-280"></span><span>                     </span><span class="annot"><span class="annottext">hfbPun :: forall lhs rhs. HsFieldBind lhs rhs -&gt; Bool
</span><a href="Language.Haskell.Syntax.Pat.html#hfbPun"><span class="hs-identifier hs-var">hfbPun</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681706986"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681706986"><span class="hs-identifier hs-var">pun</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-281"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">p -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621681706982"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; SDoc -&gt; SDoc
forall doc. IsOutput doc =&gt; Bool -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#ppUnless"><span class="hs-identifier hs-var">ppUnless</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681706986"><span class="hs-identifier hs-var">pun</span></a></span><span> </span><span class="annot"><span class="annottext">(SDoc -&gt; SDoc) -&gt; SDoc -&gt; SDoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
forall doc. IsLine doc =&gt; doc
</span><a href="GHC.Utils.Outputable.html#equals"><span class="hs-identifier hs-var">equals</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">arg -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">arg
</span><a href="#local-6989586621681706984"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-282"></span><span>
</span><span id="line-283"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681706505"><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706505"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706505"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-284"></span><span>    </span><span id="local-6989586621681706994"><span class="annot"><span class="annottext">ppr :: Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span>
</span><span id="line-285"></span><span>
</span><span id="line-286"></span><span class="hs-comment">-- See Note [Rebindable syntax and HsExpansion].</span><span>
</span><span id="line-287"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681706508"><span id="local-6989586621681706509"><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706508"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706509"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpansion"><span class="hs-identifier hs-type">HsPatExpansion</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706508"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706509"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-288"></span><span>  </span><span id="local-6989586621681707006"><span class="annot"><span class="annottext">ppr :: HsPatExpansion a b -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-type">HsPatExpanded</span></a></span><span> </span><span id="local-6989586621681707007"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681707007"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621681707008"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621681707008"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsOutput doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#ifPprDebug"><span class="hs-identifier hs-var">ifPprDebug</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsDoc doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681707007"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621681707008"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681707007"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-289"></span><span>
</span><span id="line-290"></span><span id="local-6989586621681706513"><span class="annot"><a href="GHC.Hs.Pat.html#pprLPat"><span class="hs-identifier hs-type">pprLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706513"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706513"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-291"></span><span id="pprLPat"><span class="annot"><span class="annottext">pprLPat :: forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprLPat"><span class="hs-identifier hs-var hs-var">pprLPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnA
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707014"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707014"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707014"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-292"></span><span>
</span><span id="line-293"></span><span class="annot"><span class="hs-comment">-- | Print with type info if -dppr-debug is on</span></span><span>
</span><span id="line-294"></span><span id="local-6989586621681707015"><span class="annot"><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-type">pprPatBndr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#OutputableBndr"><span class="hs-identifier hs-type">OutputableBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681707015"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681707015"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-295"></span><span id="pprPatBndr"><span class="annot"><span class="annottext">pprPatBndr :: forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-var hs-var">pprPatBndr</span></a></span></span><span> </span><span id="local-6989586621681707022"><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621681707022"><span class="hs-identifier hs-var">var</span></a></span></span><span>
</span><span id="line-296"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; SDoc) -&gt; SDoc
forall doc. IsOutput doc =&gt; (Bool -&gt; doc) -&gt; doc
</span><a href="GHC.Utils.Outputable.html#getPprDebug"><span class="hs-identifier hs-var">getPprDebug</span></a></span><span> </span><span class="annot"><span class="annottext">((Bool -&gt; SDoc) -&gt; SDoc) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-297"></span><span>      </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BindingSite -&gt; name -&gt; SDoc
forall a. OutputableBndr a =&gt; BindingSite -&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprBndr"><span class="hs-identifier hs-var">pprBndr</span></a></span><span> </span><span class="annot"><span class="annottext">BindingSite
</span><a href="GHC.Utils.Outputable.html#LambdaBind"><span class="hs-identifier hs-var">LambdaBind</span></a></span><span> </span><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621681707022"><span class="hs-identifier hs-var">var</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Could pass the site to pprPat</span><span>
</span><span id="line-298"></span><span>                                              </span><span class="hs-comment">-- but is it worth it?</span><span>
</span><span id="line-299"></span><span>      </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">name -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621681707022"><span class="hs-identifier hs-var">var</span></a></span><span>
</span><span id="line-300"></span><span>
</span><span id="line-301"></span><span id="local-6989586621681706520"><span class="annot"><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-type">pprParendLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706520"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-302"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706520"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-303"></span><span id="pprParendLPat"><span class="annot"><span class="annottext">pprParendLPat :: forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var hs-var">pprParendLPat</span></a></span></span><span> </span><span id="local-6989586621681707029"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707029"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-var">pprParendPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707029"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat (GhcPass p) -&gt; SDoc)
-&gt; (GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p))
-&gt; SDoc
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-304"></span><span>
</span><span id="line-305"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-type">pprParendPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681706523"><span class="annot"><a href="#local-6989586621681706523"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706523"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-306"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span>
</span><span id="line-307"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706523"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-308"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span>
</span><span id="line-309"></span><span id="pprParendPat"><span class="annot"><span class="annottext">pprParendPat :: forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-var hs-var">pprParendPat</span></a></span></span><span> </span><span id="local-6989586621681707038"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707038"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621681707039"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707039"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(SDocContext -&gt; Bool) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a. (SDocContext -&gt; a) -&gt; (a -&gt; SDoc) -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#sdocOption"><span class="hs-identifier hs-var">sdocOption</span></a></span><span> </span><span class="annot"><span class="annottext">SDocContext -&gt; Bool
</span><a href="GHC.Utils.Outputable.html#sdocPrintTypecheckerElaboration"><span class="hs-identifier hs-var">sdocPrintTypecheckerElaboration</span></a></span><span> </span><span class="annot"><span class="annottext">((Bool -&gt; SDoc) -&gt; SDoc) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621681707042"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681707042"><span class="hs-identifier hs-var">print_tc_elab</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-310"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707043"><span class="hs-identifier hs-var">need_parens</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681707042"><span class="hs-identifier hs-var">print_tc_elab</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707039"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-311"></span><span>    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707039"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-312"></span><span>    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707039"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-313"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-314"></span><span>    </span><span id="local-6989586621681707043"><span class="annot"><span class="annottext">need_parens :: Bool -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707043"><span class="hs-identifier hs-var hs-var">need_parens</span></a></span></span><span> </span><span id="local-6989586621681707044"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681707044"><span class="hs-identifier hs-var">print_tc_elab</span></a></span></span><span> </span><span id="local-6989586621681707045"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707045"><span class="hs-identifier hs-var">pat</span></a></span></span><span>
</span><span id="line-315"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681706523"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-316"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707045"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-317"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681707044"><span class="hs-identifier hs-var">print_tc_elab</span></a></span><span>
</span><span id="line-318"></span><span>
</span><span id="line-319"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#otherwise/GHC.Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>
</span><span id="line-320"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
forall (p :: Pass). IsPass p =&gt; PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-var">patNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707038"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707045"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-321"></span><span>      </span><span class="hs-comment">-- For a CoPat we need parens if we are going to show it, which</span><span>
</span><span id="line-322"></span><span>      </span><span class="hs-comment">-- we do if -fprint-typechecker-elaboration is on (c.f. pprHsWrapper)</span><span>
</span><span id="line-323"></span><span>      </span><span class="hs-comment">-- But otherwise the CoPat is discarded, so it</span><span>
</span><span id="line-324"></span><span>      </span><span class="hs-comment">-- is the pattern inside that matters.  Sigh.</span><span>
</span><span id="line-325"></span><span>
</span><span id="line-326"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-type">pprPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681707050"><span class="annot"><a href="#local-6989586621681707050"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681707050"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681707050"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span>
</span><span id="line-327"></span><span id="pprPat"><span class="annot"><span class="annottext">pprPat :: forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var hs-var">pprPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="annot"><span class="annottext">XVarPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707119"><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681707119"><span class="hs-identifier hs-var">lvar</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IdGhcP p -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-var">pprPatBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated (Anno (IdGhcP p)) (IdGhcP p) -&gt; IdGhcP p
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
GenLocated (Anno (IdGhcP p)) (IdGhcP p)
</span><a href="#local-6989586621681707119"><span class="hs-identifier hs-var">lvar</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-328"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="annot"><span class="annottext">XWildPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'_'</span></span><span>
</span><span id="line-329"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707122"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707122"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'~'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707122"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-330"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707125"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707125"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'!'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707125"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-331"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707127"><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681707127"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;@&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707128"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707128"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">IdGhcP p -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated (Anno (IdGhcP p)) (IdGhcP p) -&gt; IdGhcP p
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
GenLocated (Anno (IdGhcP p)) (IdGhcP p)
</span><a href="#local-6989586621681707127"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'@'</span></span><span class="hs-special">,</span><span>
</span><span id="line-332"></span><span>                                        </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707128"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-333"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-type">ViewPat</span></a></span><span> </span><span class="annot"><span class="annottext">XViewPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707131"><span class="annot"><span class="annottext">LHsExpr (GhcPass p)
</span><a href="#local-6989586621681707131"><span class="hs-identifier hs-var">expr</span></a></span></span><span> </span><span id="local-6989586621681707132"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707132"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LHsExpr (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
LHsExpr (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Expr.html#pprLExpr"><span class="hs-identifier hs-var">pprLExpr</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass p)
</span><a href="#local-6989586621681707131"><span class="hs-identifier hs-var">expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; -&gt; &quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621681707132"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-334"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;(&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707134"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707134"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;)&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621681707134"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-335"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-type">LitPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLitPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707136"><span class="annot"><span class="annottext">HsLit (GhcPass p)
</span><a href="#local-6989586621681707136"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsLit (GhcPass p) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsLit (GhcPass p)
</span><a href="#local-6989586621681707136"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-336"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707138"><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681707138"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (SyntaxExpr (GhcPass p))
</span><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Nothing/GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>  </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated (SrcAnn NoEpAnns) (HsOverLit (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
GenLocated (SrcAnn NoEpAnns) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681707138"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-337"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707139"><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681707139"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'-'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated (SrcAnn NoEpAnns) (HsOverLit (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
GenLocated (SrcAnn NoEpAnns) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681707139"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-338"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-type">NPlusKPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPlusKPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707141"><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681707141"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621681707142"><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681707142"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsOverLit (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681707143"><span class="hs-identifier hs-var">ppr_n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
forall doc. IsLine doc =&gt; Char -&gt; doc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'+'</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">GenLocated (SrcAnn NoEpAnns) (HsOverLit (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
GenLocated (SrcAnn NoEpAnns) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681707142"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-339"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681707143"><span class="annot"><span class="annottext">ppr_n :: SDoc
</span><a href="#local-6989586621681707143"><span class="hs-identifier hs-var hs-var">ppr_n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681707050"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-340"></span><span>                  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681707141"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-341"></span><span>                  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN Name -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
GenLocated SrcSpanAnnN Name
</span><a href="#local-6989586621681707141"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-342"></span><span>                  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN TyVar -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
GenLocated SrcSpanAnnN TyVar
</span><a href="#local-6989586621681707141"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-343"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-type">SplicePat</span></a></span><span> </span><span id="local-6989586621681707156"><span class="annot"><span class="annottext">XSplicePat (GhcPass p)
</span><a href="#local-6989586621681707156"><span class="hs-identifier hs-var">ext</span></a></span></span><span> </span><span id="local-6989586621681707157"><span class="annot"><span class="annottext">HsUntypedSplice (GhcPass p)
</span><a href="#local-6989586621681707157"><span class="hs-identifier hs-var">splice</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span>
</span><span id="line-344"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681707050"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-345"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Name -&gt; HsUntypedSplice (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
Bool -&gt; Maybe Name -&gt; HsUntypedSplice (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Expr.html#pprUntypedSplice"><span class="hs-identifier hs-var">pprUntypedSplice</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Maybe Name
forall a. Maybe a
</span><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Nothing/GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="annot"><span class="annottext">HsUntypedSplice (GhcPass p)
</span><a href="#local-6989586621681707157"><span class="hs-identifier hs-var">splice</span></a></span><span>
</span><span id="line-346"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#HsUntypedSpliceNested"><span class="hs-identifier hs-type">HsUntypedSpliceNested</span></a></span><span> </span><span id="local-6989586621681707165"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681707165"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">XSplicePat (GhcPass p)
</span><a href="#local-6989586621681707156"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Name -&gt; HsUntypedSplice (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
Bool -&gt; Maybe Name -&gt; HsUntypedSplice (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Expr.html#pprUntypedSplice"><span class="hs-identifier hs-var">pprUntypedSplice</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Maybe Name
forall a. a -&gt; Maybe a
</span><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621681707165"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsUntypedSplice (GhcPass p)
</span><a href="#local-6989586621681707157"><span class="hs-identifier hs-var">splice</span></a></span><span>
</span><span id="line-347"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#HsUntypedSpliceTop"><span class="hs-identifier hs-type">HsUntypedSpliceTop</span></a></span><span> </span><span class="annot"><span class="annottext">ThModFinalizers
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707171"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621681707171"><span class="hs-identifier hs-var">p</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">XSplicePat (GhcPass p)
</span><a href="#local-6989586621681707156"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621681707171"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-348"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DataConCantHappen -&gt; SDoc
forall a. DataConCantHappen -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#dataConCantHappen"><span class="hs-identifier hs-var">dataConCantHappen</span></a></span><span> </span><span class="annot"><span class="annottext">XSplicePat (GhcPass p)
DataConCantHappen
</span><a href="#local-6989586621681707156"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-349"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSigPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707175"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707175"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621681707176"><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass p))
</span><a href="#local-6989586621681707176"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621681707175"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="GHC.Utils.Outputable.html#dcolon"><span class="hs-identifier hs-var">dcolon</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (GhcPass (NoGhcTcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass p))
HsPatSigType (GhcPass (NoGhcTcPass p))
</span><a href="#local-6989586621681707176"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-350"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="annot"><span class="annottext">XListPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707179"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681707179"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#brackets"><span class="hs-identifier hs-var">brackets</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; SDoc
forall a. Outputable a =&gt; [a] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#interpp%27SP"><span class="hs-identifier hs-var">interpp'SP</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
[GenLocated SrcSpanAnnA (Pat (GhcPass p))]
</span><a href="#local-6989586621681707179"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-351"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707183"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681707183"><span class="hs-identifier hs-var">pats</span></a></span></span><span> </span><span id="local-6989586621681707184"><span class="annot"><span class="annottext">Boxity
</span><a href="#local-6989586621681707184"><span class="hs-identifier hs-var">bx</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-352"></span><span>    </span><span class="hs-comment">-- Special-case unary boxed tuples so that they are pretty-printed as</span><span>
</span><span id="line-353"></span><span>    </span><span class="hs-comment">-- `MkSolo x`, not `(x)`</span><span>
</span><span id="line-354"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">[</span><span id="local-6989586621681707185"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707185"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681707183"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-355"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="Language.Haskell.Syntax.Basic.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="#local-6989586621681707184"><span class="hs-identifier hs-var">bx</span></a></span><span>
</span><span id="line-356"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">String -&gt; SDoc
forall doc. IsLine doc =&gt; String -&gt; doc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Boxity -&gt; NameSpace -&gt; Int -&gt; String
</span><a href="GHC.Builtin.Types.html#mkTupleStr"><span class="hs-identifier hs-var">mkTupleStr</span></a></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="Language.Haskell.Syntax.Basic.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="GHC.Types.Name.Occurrence.html#dataName"><span class="hs-identifier hs-var">dataName</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707185"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-357"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#otherwise/GHC.Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>
</span><span id="line-358"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TupleSort -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Types.Basic.html#tupleParens"><span class="hs-identifier hs-var">tupleParens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Boxity -&gt; TupleSort
</span><a href="GHC.Types.Basic.html#boxityTupleSort"><span class="hs-identifier hs-var">boxityTupleSort</span></a></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="#local-6989586621681707184"><span class="hs-identifier hs-var">bx</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc)
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; SDoc
forall a. (a -&gt; SDoc) -&gt; [a] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprWithCommas"><span class="hs-identifier hs-var">pprWithCommas</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
[GenLocated SrcSpanAnnA (Pat (GhcPass p))]
</span><a href="#local-6989586621681707183"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-359"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSumPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707192"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707192"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621681707193"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681707193"><span class="hs-identifier hs-var">alt</span></a></span></span><span> </span><span id="local-6989586621681707194"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681707194"><span class="hs-identifier hs-var">arity</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
</span><a href="GHC.Types.Basic.html#sumParens"><span class="hs-identifier hs-var">sumParens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc)
-&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Int -&gt; Int -&gt; SDoc
forall a. (a -&gt; SDoc) -&gt; a -&gt; Int -&gt; Int -&gt; SDoc
</span><a href="GHC.Types.Basic.html#pprAlternative"><span class="hs-identifier hs-var">pprAlternative</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621681707192"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681707193"><span class="hs-identifier hs-var">alt</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681707194"><span class="hs-identifier hs-var">arity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-360"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_con :: forall p. Pat p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707199"><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621681707199"><span class="hs-identifier hs-var">con</span></a></span></span><span>
</span><span id="line-361"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707201"><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681707201"><span class="hs-identifier hs-var">details</span></a></span></span><span>
</span><span id="line-362"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_con_ext :: forall p. Pat p -&gt; XConPat p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con_ext"><span class="hs-identifier hs-var">pat_con_ext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707203"><span class="annot"><span class="annottext">XConPat (GhcPass p)
</span><a href="#local-6989586621681707203"><span class="hs-identifier hs-var">ext</span></a></span></span><span>
</span><span id="line-363"></span><span>               </span><span class="hs-special">}</span><span>
</span><span id="line-364"></span><span>       </span><span class="hs-special">)</span><span>
</span><span id="line-365"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681707050"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-366"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">RdrName -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName -&gt; RdrName
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681707199"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681707201"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-367"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN Name -&gt; Name
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
GenLocated SrcSpanAnnN Name
</span><a href="#local-6989586621681707199"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681707201"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-368"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(SDocContext -&gt; Bool) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a. (SDocContext -&gt; a) -&gt; (a -&gt; SDoc) -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#sdocOption"><span class="hs-identifier hs-var">sdocOption</span></a></span><span> </span><span class="annot"><span class="annottext">SDocContext -&gt; Bool
</span><a href="GHC.Utils.Outputable.html#sdocPrintTypecheckerElaboration"><span class="hs-identifier hs-var">sdocPrintTypecheckerElaboration</span></a></span><span> </span><span class="annot"><span class="annottext">((Bool -&gt; SDoc) -&gt; SDoc) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-369"></span><span>        </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ConLike -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN ConLike -&gt; ConLike
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
GenLocated SrcSpanAnnN ConLike
</span><a href="#local-6989586621681707199"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681707201"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-370"></span><span>        </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-371"></span><span>          </span><span class="hs-comment">-- Tiresome; in 'GHC.Tc.Gen.Bind.tcRhs' we print out a typechecked Pat in an</span><span>
</span><span id="line-372"></span><span>          </span><span class="hs-comment">-- error message, and we want to make sure it prints nicely</span><span>
</span><span id="line-373"></span><span>          </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN ConLike -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
GenLocated SrcSpanAnnN ConLike
</span><a href="#local-6989586621681707199"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-374"></span><span>            </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#braces"><span class="hs-identifier hs-var">braces</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#sep"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#hsep"><span class="hs-identifier hs-var">hsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVar -&gt; SDoc) -&gt; [TyVar] -&gt; [SDoc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">TyVar -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-var">pprPatBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681707250"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVar] -&gt; [TyVar] -&gt; [TyVar]
forall a. [a] -&gt; [a] -&gt; [a]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%2B%2B/GHC.Base.html#%2B%2B"><span class="hs-operator hs-var">++</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681707251"><span class="hs-identifier hs-var">dicts</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-375"></span><span>                           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">TcEvBinds -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">TcEvBinds
</span><a href="#local-6989586621681707252"><span class="hs-identifier hs-var">binds</span></a></span><span> </span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-376"></span><span>            </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p) -&gt; SDoc
forall (p :: Pass).
(OutputableBndrId p, Outputable (Anno (IdGhcP p))) =&gt;
HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681707201"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-377"></span><span>        </span><span class="hs-keyword">where</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cpt_tvs :: ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_tvs"><span class="hs-identifier hs-var">cpt_tvs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707250"><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681707250"><span class="hs-identifier hs-var">tvs</span></a></span></span><span>
</span><span id="line-378"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_dicts :: ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var">cpt_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707251"><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681707251"><span class="hs-identifier hs-var">dicts</span></a></span></span><span>
</span><span id="line-379"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_binds :: ConPatTc -&gt; TcEvBinds
</span><a href="GHC.Hs.Pat.html#cpt_binds"><span class="hs-identifier hs-var">cpt_binds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707252"><span class="annot"><span class="annottext">TcEvBinds
</span><a href="#local-6989586621681707252"><span class="hs-identifier hs-var">binds</span></a></span></span><span>
</span><span id="line-380"></span><span>                       </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">XConPat (GhcPass p)
</span><a href="#local-6989586621681707203"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-381"></span><span>
</span><span id="line-382"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621681707253"><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681707253"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681707050"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 811
</span><span>  </span><span class="hs-identifier">GhcPs</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataConCantHappen</span><span> </span><span class="hs-identifier">ext</span><span class="hs-cpp">
#endif
</span><span>  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681707253"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-387"></span><span>    </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-type">HsPatExpanded</span></a></span><span> </span><span id="local-6989586621681707257"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621681707257"><span class="hs-identifier hs-var">orig</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621681707257"><span class="hs-identifier hs-var">orig</span></a></span><span>
</span><span id="line-388"></span><span>  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681707253"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-389"></span><span>    </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span id="local-6989586621681707267"><span class="annot"><span class="annottext">HsWrapper
</span><a href="#local-6989586621681707267"><span class="hs-identifier hs-var">co</span></a></span></span><span> </span><span id="local-6989586621681707268"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707268"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-390"></span><span>      </span><span class="annot"><span class="annottext">HsWrapper -&gt; (Bool -&gt; SDoc) -&gt; SDoc
</span><a href="GHC.Tc.Types.Evidence.html#pprHsWrapper"><span class="hs-identifier hs-var">pprHsWrapper</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><a href="#local-6989586621681707267"><span class="hs-identifier hs-var">co</span></a></span><span> </span><span class="annot"><span class="annottext">((Bool -&gt; SDoc) -&gt; SDoc) -&gt; (Bool -&gt; SDoc) -&gt; SDoc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681707270"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681707270"><span class="hs-identifier hs-var">parens</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-391"></span><span>        </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681707270"><span class="hs-identifier hs-var">parens</span></a></span><span>
</span><span id="line-392"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; Pat GhcTc -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-var">pprParendPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707268"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-393"></span><span>        </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707268"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-394"></span><span>    </span><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-type">ExpansionPat</span></a></span><span> </span><span id="local-6989586621681707271"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621681707271"><span class="hs-identifier hs-var">orig</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; SDoc
forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621681707271"><span class="hs-identifier hs-var">orig</span></a></span><span>
</span><span id="line-395"></span><span>
</span><span id="line-396"></span><span id="local-6989586621681706594"><span id="local-6989586621681706595"><span class="annot"><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-type">pprUserCon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#OutputableBndr"><span class="hs-identifier hs-type">OutputableBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706594"><span class="hs-identifier hs-type">con</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706595"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-397"></span><span>                     </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-type">Anno</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#IdGhcP"><span class="hs-identifier hs-type">IdGhcP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706595"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-398"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681706594"><span class="hs-identifier hs-type">con</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier hs-type">HsConPatDetails</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706595"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span></span><span>
</span><span id="line-399"></span><span id="pprUserCon"><span class="annot"><span class="annottext">pprUserCon :: forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var hs-var">pprUserCon</span></a></span></span><span> </span><span id="local-6989586621681707287"><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621681707287"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-type">InfixCon</span></a></span><span> </span><span id="local-6989586621681707289"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707289"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span id="local-6989586621681707290"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707290"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621681707289"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">con -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprInfixOcc"><span class="hs-identifier hs-var">pprInfixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621681707287"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
GenLocated SrcSpanAnnA (Pat (GhcPass p))
</span><a href="#local-6989586621681707290"><span class="hs-identifier hs-var">p2</span></a></span><span>
</span><span id="line-400"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span id="local-6989586621681707292"><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621681707292"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621681707293"><span class="annot"><span class="annottext">HsConDetails
  (HsConPatTyArg (NoGhcTc (GhcPass p)))
  (LPat (GhcPass p))
  (HsRecFields (GhcPass p) (LPat (GhcPass p)))
</span><a href="#local-6989586621681707293"><span class="hs-identifier hs-var">details</span></a></span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">con -&gt; SDoc
forall a. OutputableBndr a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621681707292"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
forall doc. IsLine doc =&gt; doc -&gt; doc -&gt; doc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">HsConDetails
  (HsConPatTyArg (NoGhcTc (GhcPass p)))
  (LPat (GhcPass p))
  (HsRecFields (GhcPass p) (LPat (GhcPass p)))
-&gt; SDoc
forall (p :: Pass).
(OutputableBndrId p, Outputable (Anno (IdGhcP p))) =&gt;
HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConDetails
  (HsConPatTyArg (NoGhcTc (GhcPass p)))
  (LPat (GhcPass p))
  (HsRecFields (GhcPass p) (LPat (GhcPass p)))
</span><a href="#local-6989586621681707293"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-401"></span><span>
</span><span id="line-402"></span><span id="local-6989586621681706597"><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-type">pprConArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706597"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-403"></span><span>                     </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-type">Anno</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#IdGhcP"><span class="hs-identifier hs-type">IdGhcP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706597"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-404"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier hs-type">HsConPatDetails</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706597"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-405"></span><span id="pprConArgs"><span class="annot"><span class="annottext">pprConArgs :: forall (p :: Pass).
(OutputableBndrId p, Outputable (Anno (IdGhcP p))) =&gt;
HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var hs-var">pprConArgs</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-type">PrefixCon</span></a></span><span> </span><span id="local-6989586621681707342"><span class="annot"><span class="annottext">[HsConPatTyArg (NoGhcTc (GhcPass p))]
</span><a href="#local-6989586621681707342"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621681707343"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681707343"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[HsConPatTyArg (GhcPass (NoGhcTcPass p))] -&gt; SDoc
forall a. Outputable a =&gt; [a] -&gt; SDoc
</span><a href="#local-6989586621681707344"><span class="hs-identifier hs-var">pprTyArgs</span></a></span><span> </span><span class="annot"><span class="annottext">[HsConPatTyArg (NoGhcTc (GhcPass p))]
[HsConPatTyArg (GhcPass (NoGhcTcPass p))]
</span><a href="#local-6989586621681707342"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; [SDoc] -&gt; [SDoc]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; SDoc)
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; [SDoc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
[GenLocated SrcSpanAnnA (Pat (GhcPass p))]
</span><a href="#local-6989586621681707343"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-406"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681707344"><span class="annot"><span class="annottext">pprTyArgs :: [a] -&gt; SDoc
</span><a href="#local-6989586621681707344"><span class="hs-identifier hs-var hs-var">pprTyArgs</span></a></span></span><span> </span><span id="local-6989586621681707348"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681707348"><span class="hs-identifier hs-var">tyargs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; SDoc) -&gt; [a] -&gt; [SDoc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681707348"><span class="hs-identifier hs-var">tyargs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-407"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-type">InfixCon</span></a></span><span> </span><span id="local-6989586621681707349"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707349"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span id="local-6989586621681707350"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707350"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
forall doc. IsLine doc =&gt; [doc] -&gt; doc
</span><a href="GHC.Utils.Outputable.html#sep"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707349"><span class="hs-identifier hs-var">p1</span></a></span><span>
</span><span id="line-408"></span><span>                                     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707350"><span class="hs-identifier hs-var">p2</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-409"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#RecCon"><span class="hs-identifier hs-type">RecCon</span></a></span><span> </span><span id="local-6989586621681707352"><span class="annot"><span class="annottext">HsRecFields (GhcPass p) (LPat (GhcPass p))
</span><a href="#local-6989586621681707352"><span class="hs-identifier hs-var">rpats</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsRecFields (GhcPass p) (GenLocated SrcSpanAnnA (Pat (GhcPass p)))
-&gt; SDoc
forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsRecFields (GhcPass p) (LPat (GhcPass p))
HsRecFields (GhcPass p) (GenLocated SrcSpanAnnA (Pat (GhcPass p)))
</span><a href="#local-6989586621681707352"><span class="hs-identifier hs-var">rpats</span></a></span><span>
</span><span id="line-410"></span><span>
</span><span id="line-411"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
*              Building patterns
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-418"></span><span>
</span><span id="line-419"></span><span class="annot"><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-type">mkPrefixConPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-420"></span><span>                  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-421"></span><span class="hs-comment">-- Make a vanilla Prefix constructor pattern</span><span>
</span><span id="line-422"></span><span id="mkPrefixConPat"><span class="annot"><span class="annottext">mkPrefixConPat :: DataCon -&gt; [LPat GhcTc] -&gt; [Type] -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-var hs-var">mkPrefixConPat</span></a></span></span><span> </span><span id="local-6989586621681707353"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681707353"><span class="hs-identifier hs-var">dc</span></a></span></span><span> </span><span id="local-6989586621681707354"><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621681707354"><span class="hs-identifier hs-var">pats</span></a></span></span><span> </span><span id="local-6989586621681707355"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681707355"><span class="hs-identifier hs-var">tys</span></a></span></span><span>
</span><span id="line-423"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; LocatedAn AnnListItem (Pat GhcTc)
forall a an. a -&gt; LocatedAn an a
</span><a href="GHC.Parser.Annotation.html#noLocA"><span class="hs-identifier hs-var">noLocA</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat GhcTc -&gt; LocatedAn AnnListItem (Pat GhcTc))
-&gt; Pat GhcTc -&gt; LocatedAn AnnListItem (Pat GhcTc)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_con :: XRec GhcTc (ConLikeP GhcTc)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConLike -&gt; GenLocated SrcSpanAnnN ConLike
forall a an. a -&gt; LocatedAn an a
</span><a href="GHC.Parser.Annotation.html#noLocA"><span class="hs-identifier hs-var">noLocA</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DataCon -&gt; ConLike
</span><a href="GHC.Core.ConLike.html#RealDataCon"><span class="hs-identifier hs-var">RealDataCon</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681707353"><span class="hs-identifier hs-var">dc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-424"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_args :: HsConPatDetails GhcTc
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[HsConPatTyArg GhcRn]
-&gt; [LocatedAn AnnListItem (Pat GhcTc)]
-&gt; HsConDetails
     (HsConPatTyArg GhcRn)
     (LocatedAn AnnListItem (Pat GhcTc))
     (HsRecFields GhcTc (LocatedAn AnnListItem (Pat GhcTc)))
forall tyarg arg rec.
[tyarg] -&gt; [arg] -&gt; HsConDetails tyarg arg rec
</span><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-var">PrefixCon</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">[LPat GhcTc]
[LocatedAn AnnListItem (Pat GhcTc)]
</span><a href="#local-6989586621681707354"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-425"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_con_ext :: XConPat GhcTc
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con_ext"><span class="hs-identifier hs-var">pat_con_ext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span>
</span><span id="line-426"></span><span>                      </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cpt_tvs :: [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_tvs"><span class="hs-identifier hs-var">cpt_tvs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-427"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_dicts :: [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var">cpt_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-428"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_binds :: TcEvBinds
</span><a href="GHC.Hs.Pat.html#cpt_binds"><span class="hs-identifier hs-var">cpt_binds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcEvBinds
</span><a href="GHC.Tc.Types.Evidence.html#emptyTcEvBinds"><span class="hs-identifier hs-var">emptyTcEvBinds</span></a></span><span>
</span><span id="line-429"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_arg_tys :: [Type]
</span><a href="GHC.Hs.Pat.html#cpt_arg_tys"><span class="hs-identifier hs-var">cpt_arg_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681707355"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-430"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_wrap :: HsWrapper
</span><a href="GHC.Hs.Pat.html#cpt_wrap"><span class="hs-identifier hs-var">cpt_wrap</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><a href="GHC.Tc.Types.Evidence.html#idHsWrapper"><span class="hs-identifier hs-var">idHsWrapper</span></a></span><span>
</span><span id="line-431"></span><span>                      </span><span class="hs-special">}</span><span>
</span><span id="line-432"></span><span>                    </span><span class="hs-special">}</span><span>
</span><span id="line-433"></span><span>
</span><span id="line-434"></span><span class="annot"><a href="GHC.Hs.Pat.html#mkNilPat"><span class="hs-identifier hs-type">mkNilPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-435"></span><span id="mkNilPat"><span class="annot"><span class="annottext">mkNilPat :: Type -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkNilPat"><span class="hs-identifier hs-var hs-var">mkNilPat</span></a></span></span><span> </span><span id="local-6989586621681707360"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681707360"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DataCon -&gt; [LPat GhcTc] -&gt; [Type] -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-var">mkPrefixConPat</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="GHC.Builtin.Types.html#nilDataCon"><span class="hs-identifier hs-var">nilDataCon</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681707360"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-436"></span><span>
</span><span id="line-437"></span><span class="annot"><a href="GHC.Hs.Pat.html#mkCharLitPat"><span class="hs-identifier hs-type">mkCharLitPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html#SourceText"><span class="hs-identifier hs-type">SourceText</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-438"></span><span id="mkCharLitPat"><span class="annot"><span class="annottext">mkCharLitPat :: SourceText -&gt; Char -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkCharLitPat"><span class="hs-identifier hs-var hs-var">mkCharLitPat</span></a></span></span><span> </span><span id="local-6989586621681707362"><span class="annot"><span class="annottext">SourceText
</span><a href="#local-6989586621681707362"><span class="hs-identifier hs-var">src</span></a></span></span><span> </span><span id="local-6989586621681707363"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621681707363"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DataCon -&gt; [LPat GhcTc] -&gt; [Type] -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-var">mkPrefixConPat</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="GHC.Builtin.Types.html#charDataCon"><span class="hs-identifier hs-var">charDataCon</span></a></span><span>
</span><span id="line-439"></span><span>                          </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Pat GhcTc -&gt; LocatedAn AnnListItem (Pat GhcTc)
forall a an. a -&gt; LocatedAn an a
</span><a href="GHC.Parser.Annotation.html#noLocA"><span class="hs-identifier hs-var">noLocA</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat GhcTc -&gt; LocatedAn AnnListItem (Pat GhcTc))
-&gt; Pat GhcTc -&gt; LocatedAn AnnListItem (Pat GhcTc)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">XLitPat GhcTc -&gt; HsLit GhcTc -&gt; Pat GhcTc
forall p. XLitPat p -&gt; HsLit p -&gt; Pat p
</span><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-var">LitPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLitPat GhcTc
NoExtField
</span><a href="Language.Haskell.Syntax.Extension.html#noExtField"><span class="hs-identifier hs-var">noExtField</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">XHsCharPrim GhcTc -&gt; Char -&gt; HsLit GhcTc
forall x. XHsCharPrim x -&gt; Char -&gt; HsLit x
</span><a href="Language.Haskell.Syntax.Lit.html#HsCharPrim"><span class="hs-identifier hs-var">HsCharPrim</span></a></span><span> </span><span class="annot"><span class="annottext">XHsCharPrim GhcTc
SourceText
</span><a href="#local-6989586621681707362"><span class="hs-identifier hs-var">src</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621681707363"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-440"></span><span>
</span><span id="line-441"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
* Predicates for checking things about pattern-lists in EquationInfo   *
*                                                                      *
************************************************************************

\subsection[Pat-list-predicates]{Look for interesting things in patterns}

Unlike in the Wadler chapter, where patterns are either ``variables''
or ``constructors,'' here we distinguish between:
\begin{description}
\item[unfailable:]
Patterns that cannot fail to match: variables, wildcards, and lazy
patterns.

These are the irrefutable patterns; the two other categories
are refutable patterns.

\item[constructor:]
A non-literal constructor pattern (see next category).

\item[literal patterns:]
At least the numeric ones may be overloaded.
\end{description}

A pattern is in {\em exactly one} of the above three categories; `as'
patterns are treated specially, of course.

The 1.3 report defines what ``irrefutable'' and ``failure-free'' patterns are.
-}</span><span>
</span><span id="line-472"></span><span>
</span><span id="line-473"></span><span id="local-6989586621681706618"><span class="annot"><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier hs-type">isBangedLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706618"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-474"></span><span id="isBangedLPat"><span class="annot"><span class="annottext">isBangedLPat :: forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier hs-var hs-var">isBangedLPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var">isBangedPat</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat (GhcPass p) -&gt; Bool)
-&gt; (GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p))
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-475"></span><span>
</span><span id="line-476"></span><span id="local-6989586621681706620"><span class="annot"><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-type">isBangedPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706620"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-477"></span><span id="isBangedPat"><span class="annot"><span class="annottext">isBangedPat :: forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var hs-var">isBangedPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;(&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707368"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707368"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;)&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier hs-var">isBangedLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707368"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-478"></span><span class="annot"><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var">isBangedPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-479"></span><span class="annot"><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var">isBangedPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-480"></span><span>
</span><span id="line-481"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-type">looksLazyPatBind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBind"><span class="hs-identifier hs-type">HsBind</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-482"></span><span class="hs-comment">-- Returns True of anything *except*</span><span>
</span><span id="line-483"></span><span class="hs-comment">--     a StrictHsBind (as above) or</span><span>
</span><span id="line-484"></span><span class="hs-comment">--     a VarPat</span><span>
</span><span id="line-485"></span><span class="hs-comment">-- In particular, returns True of a pattern binding with a compound pattern, like (I# x)</span><span>
</span><span id="line-486"></span><span class="hs-comment">-- Looks through AbsBinds</span><span>
</span><span id="line-487"></span><span id="looksLazyPatBind"><span class="annot"><span class="annottext">looksLazyPatBind :: HsBind GhcTc -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var hs-var">looksLazyPatBind</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatBind"><span class="hs-identifier hs-type">PatBind</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_lhs :: forall idL idR. HsBindLR idL idR -&gt; LPat idL
</span><a href="Language.Haskell.Syntax.Binds.html#pat_lhs"><span class="hs-identifier hs-var">pat_lhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707371"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707371"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-488"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bool
forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var">looksLazyLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707371"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-489"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var">looksLazyPatBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XHsBindsLR"><span class="hs-identifier hs-type">XHsBindsLR</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Binds.html#AbsBinds"><span class="hs-identifier hs-type">AbsBinds</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">abs_binds :: AbsBinds -&gt; LHsBinds GhcTc
</span><a href="GHC.Hs.Binds.html#abs_binds"><span class="hs-identifier hs-var">abs_binds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707376"><span class="annot"><span class="annottext">LHsBinds GhcTc
</span><a href="#local-6989586621681707376"><span class="hs-identifier hs-var">binds</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-490"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (HsBind GhcTc) -&gt; Bool)
-&gt; Bag (GenLocated SrcSpanAnnA (HsBind GhcTc)) -&gt; Bool
forall a. (a -&gt; Bool) -&gt; Bag a -&gt; Bool
</span><a href="GHC.Data.Bag.html#anyBag"><span class="hs-identifier hs-var">anyBag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsBind GhcTc -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var">looksLazyPatBind</span></a></span><span> </span><span class="annot"><span class="annottext">(HsBind GhcTc -&gt; Bool)
-&gt; (GenLocated SrcSpanAnnA (HsBind GhcTc) -&gt; HsBind GhcTc)
-&gt; GenLocated SrcSpanAnnA (HsBind GhcTc)
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (HsBind GhcTc) -&gt; HsBind GhcTc
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">LHsBinds GhcTc
Bag (GenLocated SrcSpanAnnA (HsBind GhcTc))
</span><a href="#local-6989586621681707376"><span class="hs-identifier hs-var">binds</span></a></span><span>
</span><span id="line-491"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var">looksLazyPatBind</span></a></span><span> </span><span class="annot"><span class="annottext">HsBind GhcTc
</span><span class="hs-identifier">_</span></span><span>
</span><span id="line-492"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-493"></span><span>
</span><span id="line-494"></span><span id="local-6989586621681707378"><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-type">looksLazyLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681707378"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-495"></span><span id="looksLazyLPat"><span class="annot"><span class="annottext">looksLazyLPat :: forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var hs-var">looksLazyLPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat (GhcPass p) -&gt; Bool)
-&gt; (GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p))
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-496"></span><span>
</span><span id="line-497"></span><span id="local-6989586621681707380"><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-type">looksLazyPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681707380"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-498"></span><span id="looksLazyPat"><span class="annot"><span class="annottext">looksLazyPat :: forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var hs-var">looksLazyPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;(&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707381"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707381"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;)&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var">looksLazyLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707381"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-499"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;@&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707382"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707382"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var">looksLazyLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707382"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-500"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-501"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-502"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-503"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-504"></span><span>
</span><span id="line-505"></span><span class="annot"><a href="GHC.Hs.Pat.html#isIrrefutableHsPat"><span class="hs-identifier hs-type">isIrrefutableHsPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681706633"><span class="annot"><a href="#local-6989586621681706633"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706633"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-506"></span><span>                   </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Driver.Session.html#DynFlags"><span class="hs-identifier hs-type">DynFlags</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706633"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-507"></span><span class="hs-comment">-- (isIrrefutableHsPat p) is true if matching against p cannot fail,</span><span>
</span><span id="line-508"></span><span class="hs-comment">-- in the sense of falling through to the next pattern.</span><span>
</span><span id="line-509"></span><span class="hs-comment">--      (NB: this is not quite the same as the (silly) defn</span><span>
</span><span id="line-510"></span><span class="hs-comment">--      in 3.17.2 of the Haskell 98 report.)</span><span>
</span><span id="line-511"></span><span class="hs-comment">--</span><span>
</span><span id="line-512"></span><span class="hs-comment">-- WARNING: isIrrefutableHsPat returns False if it's in doubt.</span><span>
</span><span id="line-513"></span><span class="hs-comment">-- Specifically on a ConPatIn, which is what it sees for a</span><span>
</span><span id="line-514"></span><span class="hs-comment">-- (LPat Name) in the renamer, it doesn't know the size of the</span><span>
</span><span id="line-515"></span><span class="hs-comment">-- constructor family, so it returns False.  Result: only</span><span>
</span><span id="line-516"></span><span class="hs-comment">-- tuple patterns are considered irrefutable at the renamer stage.</span><span>
</span><span id="line-517"></span><span class="hs-comment">--</span><span>
</span><span id="line-518"></span><span class="hs-comment">-- But if it returns True, the pattern is definitely irrefutable</span><span>
</span><span id="line-519"></span><span id="isIrrefutableHsPat"><span class="annot"><span class="annottext">isIrrefutableHsPat :: forall (p :: Pass).
OutputableBndrId p =&gt;
DynFlags -&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isIrrefutableHsPat"><span class="hs-identifier hs-var hs-var">isIrrefutableHsPat</span></a></span></span><span> </span><span id="local-6989586621681707385"><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621681707385"><span class="hs-identifier hs-var">dflags</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-520"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; XRec (GhcPass p) (Pat (GhcPass p)) -&gt; Bool
forall (p :: Pass).
OutputableBndrId p =&gt;
Bool -&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isIrrefutableHsPat%27"><span class="hs-identifier hs-var">isIrrefutableHsPat'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Extension -&gt; DynFlags -&gt; Bool
</span><a href="GHC.Driver.Session.html#xopt"><span class="hs-identifier hs-var">xopt</span></a></span><span> </span><span class="annot"><span class="annottext">Extension
</span><span class="hs-identifier hs-var">LangExt.Strict</span></span><span> </span><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621681707385"><span class="hs-identifier hs-var">dflags</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-521"></span><span>
</span><span id="line-522"></span><span class="hs-comment">{-
Note [-XStrict and irrefutability]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When -XStrict is enabled the rules for irrefutability are slightly modified.
Specifically, the pattern in a program like

    do ~(Just hi) &lt;- expr

cannot be considered irrefutable. The ~ here merely disables the bang that
-XStrict would usually apply, rendering the program equivalent to the following
without -XStrict

    do Just hi &lt;- expr

To achieve make this pattern irrefutable with -XStrict the user would rather
need to write

    do ~(~(Just hi)) &lt;- expr

Failing to account for this resulted in #19027. To fix this isIrrefutableHsPat
takes care to check for two the irrefutability of the inner pattern when it
encounters a LazyPat and -XStrict is enabled.

See also Note [decideBangHood] in GHC.HsToCore.Utils.
-}</span><span>
</span><span id="line-547"></span><span>
</span><span id="line-548"></span><span class="annot"><a href="GHC.Hs.Pat.html#isIrrefutableHsPat%27"><span class="hs-identifier hs-type">isIrrefutableHsPat'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681706636"><span class="annot"><a href="#local-6989586621681706636"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706636"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-549"></span><span>                    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-comment">-- ^ Are we in a @-XStrict@ context?</span><span>
</span><span id="line-550"></span><span>                            </span><span class="hs-comment">-- See Note [-XStrict and irrefutability]</span><span>
</span><span id="line-551"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706636"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-552"></span><span id="isIrrefutableHsPat%27"><span class="annot"><span class="annottext">isIrrefutableHsPat' :: forall (p :: Pass).
OutputableBndrId p =&gt;
Bool -&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isIrrefutableHsPat%27"><span class="hs-identifier hs-var hs-var">isIrrefutableHsPat'</span></a></span></span><span> </span><span id="local-6989586621681707396"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681707396"><span class="hs-identifier hs-var">is_strict</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707397"><span class="hs-identifier hs-var">goL</span></a></span><span>
</span><span id="line-553"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-554"></span><span>    </span><span class="annot"><a href="#local-6989586621681707397"><span class="hs-identifier hs-type">goL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706636"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-555"></span><span>    </span><span id="local-6989586621681707397"><span class="annot"><span class="annottext">goL :: LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707397"><span class="hs-identifier hs-var hs-var">goL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat (GhcPass p) -&gt; Bool)
-&gt; (GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p))
-&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Pat (GhcPass p)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-556"></span><span>
</span><span id="line-557"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706636"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-558"></span><span>    </span><span id="local-6989586621681707398"><span class="annot"><span class="annottext">go :: Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707398"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-559"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-560"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707399"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707399"><span class="hs-identifier hs-var">p'</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-561"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681707396"><span class="hs-identifier hs-var">is_strict</span></a></span><span>
</span><span id="line-562"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; LPat (GhcPass p) -&gt; Bool
forall (p :: Pass).
OutputableBndrId p =&gt;
Bool -&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isIrrefutableHsPat%27"><span class="hs-identifier hs-var">isIrrefutableHsPat'</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707399"><span class="hs-identifier hs-var">p'</span></a></span><span>
</span><span id="line-563"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#otherwise/GHC.Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-564"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707400"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707400"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707397"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707400"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-565"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;(&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707401"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707401"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;)&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707397"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707401"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-566"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;@&quot; (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707402"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707402"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707397"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707402"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-567"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-type">ViewPat</span></a></span><span> </span><span class="annot"><span class="annottext">XViewPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707403"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707403"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707397"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707403"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-568"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSigPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707404"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707404"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass p))
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707397"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707404"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-569"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707405"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681707405"><span class="hs-identifier hs-var">pats</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool)
-&gt; [GenLocated SrcSpanAnnA (Pat (GhcPass p))] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><a href="../../base-4.18.3.0/src/Data.Foldable.html#all/Data.Foldable.html#all"><span class="hs-identifier hs-var">all</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
GenLocated SrcSpanAnnA (Pat (GhcPass p)) -&gt; Bool
</span><a href="#local-6989586621681707397"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
[GenLocated SrcSpanAnnA (Pat (GhcPass p))]
</span><a href="#local-6989586621681707405"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-570"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-571"></span><span>                    </span><span class="hs-comment">-- See Note [Unboxed sum patterns aren't irrefutable]</span><span>
</span><span id="line-572"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-573"></span><span>
</span><span id="line-574"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span>
</span><span id="line-575"></span><span>        </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_con :: forall p. Pat p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707407"><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621681707407"><span class="hs-identifier hs-var">con</span></a></span></span><span>
</span><span id="line-576"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707408"><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681707408"><span class="hs-identifier hs-var">details</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-577"></span><span>                           </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681706636"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-578"></span><span>       </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- Conservative</span><span>
</span><span id="line-579"></span><span>       </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- Conservative</span><span>
</span><span id="line-580"></span><span>       </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621681707407"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-581"></span><span>         </span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnN
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.ConLike.html#PatSynCon"><span class="hs-identifier hs-type">PatSynCon</span></a></span><span> </span><span id="local-6989586621681707415"><span class="annot"><span class="annottext">PatSyn
</span><a href="#local-6989586621681707415"><span class="hs-identifier hs-var">_pat</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- Conservative</span><span>
</span><span id="line-582"></span><span>         </span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnN
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.ConLike.html#RealDataCon"><span class="hs-identifier hs-type">RealDataCon</span></a></span><span> </span><span id="local-6989586621681707416"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681707416"><span class="hs-identifier hs-var">con</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-583"></span><span>           </span><span class="annot"><span class="annottext">Maybe DataCon -&gt; Bool
forall a. Maybe a -&gt; Bool
</span><a href="../../base-4.18.3.0/src/Data.Maybe.html#isJust/Data.Maybe.html#isJust"><span class="hs-identifier hs-var">isJust</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyCon -&gt; Maybe DataCon
</span><a href="GHC.Core.TyCon.html#tyConSingleDataCon_maybe"><span class="hs-identifier hs-var">tyConSingleDataCon_maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DataCon -&gt; TyCon
</span><a href="GHC.Core.DataCon.html#dataConTyCon"><span class="hs-identifier hs-var">dataConTyCon</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681707416"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-584"></span><span>           </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">(LocatedAn AnnListItem (Pat GhcTc) -&gt; Bool)
-&gt; [LocatedAn AnnListItem (Pat GhcTc)] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><a href="../../base-4.18.3.0/src/Data.Foldable.html#all/Data.Foldable.html#all"><span class="hs-identifier hs-var">all</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
LocatedAn AnnListItem (Pat GhcTc) -&gt; Bool
</span><a href="#local-6989586621681707397"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p) -&gt; [LPat (GhcPass p)]
forall p. UnXRec p =&gt; HsConPatDetails p -&gt; [LPat p]
</span><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-var">hsConPatArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681707408"><span class="hs-identifier hs-var">details</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-585"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-type">LitPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-586"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-587"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-type">NPlusKPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-588"></span><span>
</span><span id="line-589"></span><span>    </span><span class="hs-comment">-- We conservatively assume that no TH splices are irrefutable</span><span>
</span><span id="line-590"></span><span>    </span><span class="hs-comment">-- since we cannot know until the splice is evaluated.</span><span>
</span><span id="line-591"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-type">SplicePat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-592"></span><span>
</span><span id="line-593"></span><span>    </span><span class="annot"><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621681707421"><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681707421"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681706636"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 811
</span><span>      </span><span class="hs-identifier">GhcPs</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataConCantHappen</span><span> </span><span class="hs-identifier">ext</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681707421"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-598"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-type">HsPatExpanded</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707423"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707423"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707423"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-599"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681707421"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-600"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707425"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707425"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
Pat GhcTc
</span><a href="#local-6989586621681707425"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-601"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-type">ExpansionPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707426"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707426"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681707398"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
Pat GhcTc
</span><a href="#local-6989586621681707426"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-602"></span><span>
</span><span id="line-603"></span><span class="hs-comment">-- | Is the pattern any of combination of:</span><span>
</span><span id="line-604"></span><span class="hs-comment">--</span><span>
</span><span id="line-605"></span><span class="hs-comment">-- - (pat)</span><span>
</span><span id="line-606"></span><span class="hs-comment">-- - pat :: Type</span><span>
</span><span id="line-607"></span><span class="hs-comment">-- - ~pat</span><span>
</span><span id="line-608"></span><span class="hs-comment">-- - !pat</span><span>
</span><span id="line-609"></span><span class="hs-comment">-- - x (variable)</span><span>
</span><span id="line-610"></span><span id="local-6989586621681706645"><span class="annot"><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-type">isSimplePat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706645"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706645"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-611"></span><span id="isSimplePat"><span class="annot"><span class="annottext">isSimplePat :: forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var hs-var">isSimplePat</span></a></span></span><span> </span><span id="local-6989586621681707427"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681707427"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (Pat (GhcPass x)) -&gt; Pat (GhcPass x)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
GenLocated SrcSpanAnnA (Pat (GhcPass x))
</span><a href="#local-6989586621681707427"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-612"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;(&quot; (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707428"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681707428"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;)&quot; (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681707428"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-613"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSigPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707429"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681707429"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass x))
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681707429"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-614"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707430"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681707430"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681707430"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-615"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707431"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681707431"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681707431"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-616"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="annot"><span class="annottext">XVarPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707432"><span class="annot"><span class="annottext">LIdP (GhcPass x)
</span><a href="#local-6989586621681707432"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">IdGhcP x -&gt; Maybe (IdGhcP x)
forall a. a -&gt; Maybe a
</span><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated (Anno (IdGhcP x)) (IdGhcP x) -&gt; IdGhcP x
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass x)
GenLocated (Anno (IdGhcP x)) (IdGhcP x)
</span><a href="#local-6989586621681707432"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-617"></span><span>  </span><span class="annot"><span class="annottext">Pat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (IdP (GhcPass x))
Maybe (IdGhcP x)
forall a. Maybe a
</span><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Nothing/GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-618"></span><span>
</span><span id="line-619"></span><span>
</span><span id="line-620"></span><span class="hs-comment">{- Note [Unboxed sum patterns aren't irrefutable]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Unlike unboxed tuples, unboxed sums are *not* irrefutable when used as
patterns. A simple example that demonstrates this is from #14228:

  pattern Just' x = (# x | #)
  pattern Nothing' = (# | () #)

  foo x = case x of
    Nothing' -&gt; putStrLn &quot;nothing&quot;
    Just'    -&gt; putStrLn &quot;just&quot;

In foo, the pattern Nothing' (that is, (# x | #)) is certainly not irrefutable,
as does not match an unboxed sum value of the same arity&#8212;namely, (# | y #)
(covered by Just'). In fact, no unboxed sum pattern is irrefutable, since the
minimum unboxed sum arity is 2.

Failing to mark unboxed sum patterns as non-irrefutable would cause the Just'
case in foo to be unreachable, as GHC would mistakenly believe that Nothing'
is the only thing that could possibly be matched!
-}</span><span>
</span><span id="line-641"></span><span>
</span><span id="line-642"></span><span class="hs-comment">-- | @'patNeedsParens' p pat@ returns 'True' if the pattern @pat@ needs</span><span>
</span><span id="line-643"></span><span class="hs-comment">-- parentheses under precedence @p@.</span><span>
</span><span id="line-644"></span><span class="annot"><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-type">patNeedsParens</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681706534"><span class="annot"><a href="#local-6989586621681706534"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#IsPass"><span class="hs-identifier hs-type">IsPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706534"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706534"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-645"></span><span id="patNeedsParens"><span class="annot"><span class="annottext">patNeedsParens :: forall (p :: Pass). IsPass p =&gt; PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-var hs-var">patNeedsParens</span></a></span></span><span> </span><span id="local-6989586621681707435"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707435"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (q :: Pass). IsPass q =&gt; Pat (GhcPass q) -&gt; Bool
</span><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681706534"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-646"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-647"></span><span>    </span><span class="hs-comment">-- Remark: go needs to be polymorphic, as we call it recursively</span><span>
</span><span id="line-648"></span><span>    </span><span class="hs-comment">-- at a different GhcPass (see the case for GhcTc XPat below).</span><span>
</span><span id="line-649"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681706649"><span class="annot"><a href="#local-6989586621681706649"><span class="hs-identifier hs-type">q</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#IsPass"><span class="hs-identifier hs-type">IsPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706649"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706649"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-650"></span><span>    </span><span id="local-6989586621681707436"><span class="annot"><span class="annottext">go :: forall (q :: Pass). IsPass q =&gt; Pat (GhcPass q) -&gt; Bool
</span><a href="#local-6989586621681707436"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-type">NPlusKPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707435"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#opPrec"><span class="hs-identifier hs-var">opPrec</span></a></span><span>
</span><span id="line-651"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-type">SplicePat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-652"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707446"><span class="annot"><span class="annottext">HsConPatDetails (GhcPass q)
</span><a href="#local-6989586621681707446"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-653"></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
-&gt; HsConDetails
     (HsConPatTyArg (GhcPass (NoGhcTcPass q)))
     (GenLocated SrcSpanAnnA (Pat (GhcPass q)))
     (HsRecFields
        (GhcPass q) (GenLocated SrcSpanAnnA (Pat (GhcPass q))))
-&gt; Bool
forall t a b. PprPrec -&gt; HsConDetails t a b -&gt; Bool
</span><a href="GHC.Hs.Pat.html#conPatNeedsParens"><span class="hs-identifier hs-var">conPatNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707435"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass q)
HsConDetails
  (HsConPatTyArg (GhcPass (NoGhcTcPass q)))
  (GenLocated SrcSpanAnnA (Pat (GhcPass q)))
  (HsRecFields
     (GhcPass q) (GenLocated SrcSpanAnnA (Pat (GhcPass q))))
</span><a href="#local-6989586621681707446"><span class="hs-identifier hs-var">ds</span></a></span><span>
</span><span id="line-654"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707435"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#sigPrec"><span class="hs-identifier hs-var">sigPrec</span></a></span><span>
</span><span id="line-655"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-type">ViewPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-656"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621681707449"><span class="annot"><span class="annottext">XXPat (GhcPass q)
</span><a href="#local-6989586621681707449"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681706649"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-keyword">of</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 901
</span><span>      </span><span class="hs-identifier">GhcPs</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataConCantHappen</span><span> </span><span class="hs-identifier">ext</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="annot"><span class="annottext">GhcPass q
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass q)
</span><a href="#local-6989586621681707449"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-661"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#HsPatExpanded"><span class="hs-identifier hs-type">HsPatExpanded</span></a></span><span> </span><span id="local-6989586621681707453"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621681707453"><span class="hs-identifier hs-var">orig</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; Bool
forall (q :: Pass). IsPass q =&gt; Pat (GhcPass q) -&gt; Bool
</span><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621681707453"><span class="hs-identifier hs-var">orig</span></a></span><span>
</span><span id="line-662"></span><span>      </span><span class="annot"><span class="annottext">GhcPass q
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass q)
</span><a href="#local-6989586621681707449"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-663"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707459"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707459"><span class="hs-identifier hs-var">inner</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bool
forall (q :: Pass). IsPass q =&gt; Pat (GhcPass q) -&gt; Bool
</span><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707459"><span class="hs-identifier hs-var">inner</span></a></span><span>
</span><span id="line-664"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-type">ExpansionPat</span></a></span><span> </span><span id="local-6989586621681707460"><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621681707460"><span class="hs-identifier hs-var">orig</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcRn -&gt; Bool
forall (q :: Pass). IsPass q =&gt; Pat (GhcPass q) -&gt; Bool
</span><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><a href="#local-6989586621681707460"><span class="hs-identifier hs-var">orig</span></a></span><span>
</span><span id="line-665"></span><span>          </span><span class="hs-comment">--                   ^^^^^^^</span><span>
</span><span id="line-666"></span><span>          </span><span class="hs-comment">-- NB: recursive call of go at a different GhcPass.</span><span>
</span><span id="line-667"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-668"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-669"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-670"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-671"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-672"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-673"></span><span>    </span><span class="hs-comment">-- Special-case unary boxed tuple applications so that they are</span><span>
</span><span id="line-674"></span><span>    </span><span class="hs-comment">-- parenthesized as `Identity (Solo x)`, not `Identity Solo x` (#18612)</span><span>
</span><span id="line-675"></span><span>    </span><span class="hs-comment">-- See Note [One-tuples] in GHC.Builtin.Types</span><span>
</span><span id="line-676"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat (GhcPass q)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass q)
</span><span class="hs-identifier">_</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="Language.Haskell.Syntax.Basic.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-677"></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707435"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span>
</span><span id="line-678"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-679"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-680"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-681"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-type">LitPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLitPat (GhcPass q)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707461"><span class="annot"><span class="annottext">HsLit (GhcPass q)
</span><a href="#local-6989586621681707461"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; HsLit (GhcPass q) -&gt; Bool
forall x. PprPrec -&gt; HsLit x -&gt; Bool
</span><a href="GHC.Hs.Lit.html#hsLitNeedsParens"><span class="hs-identifier hs-var">hsLitNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707435"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">HsLit (GhcPass q)
</span><a href="#local-6989586621681707461"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-682"></span><span>    </span><span class="annot"><a href="#local-6989586621681707436"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPat (GhcPass q)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707463"><span class="annot"><span class="annottext">XRec (GhcPass q) (HsOverLit (GhcPass q))
</span><a href="#local-6989586621681707463"><span class="hs-identifier hs-var">lol</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (SyntaxExpr (GhcPass q))
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass q)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; HsOverLit (GhcPass q) -&gt; Bool
forall x. PprPrec -&gt; HsOverLit x -&gt; Bool
</span><a href="GHC.Hs.Lit.html#hsOverLitNeedsParens"><span class="hs-identifier hs-var">hsOverLitNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707435"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GenLocated (SrcAnn NoEpAnns) (HsOverLit (GhcPass q))
-&gt; HsOverLit (GhcPass q)
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass q) (HsOverLit (GhcPass q))
GenLocated (SrcAnn NoEpAnns) (HsOverLit (GhcPass q))
</span><a href="#local-6989586621681707463"><span class="hs-identifier hs-var">lol</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-683"></span><span>
</span><span id="line-684"></span><span class="hs-comment">-- | @'conPatNeedsParens' p cp@ returns 'True' if the constructor patterns @cp@</span><span>
</span><span id="line-685"></span><span class="hs-comment">-- needs parentheses under precedence @p@.</span><span>
</span><span id="line-686"></span><span id="local-6989586621681706652"><span id="local-6989586621681706653"><span id="local-6989586621681706654"><span class="annot"><a href="GHC.Hs.Pat.html#conPatNeedsParens"><span class="hs-identifier hs-type">conPatNeedsParens</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsConDetails"><span class="hs-identifier hs-type">HsConDetails</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706652"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706653"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706654"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-687"></span><span id="conPatNeedsParens"><span class="annot"><span class="annottext">conPatNeedsParens :: forall t a b. PprPrec -&gt; HsConDetails t a b -&gt; Bool
</span><a href="GHC.Hs.Pat.html#conPatNeedsParens"><span class="hs-identifier hs-var hs-var">conPatNeedsParens</span></a></span></span><span> </span><span id="local-6989586621681707469"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707469"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsConDetails t a b -&gt; Bool
</span><a href="#local-6989586621681707470"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-688"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-689"></span><span>    </span><span id="local-6989586621681707470"><span class="annot"><span class="annottext">go :: HsConDetails t a b -&gt; Bool
</span><a href="#local-6989586621681707470"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-type">PrefixCon</span></a></span><span> </span><span id="local-6989586621681707471"><span class="annot"><span class="annottext">[t]
</span><a href="#local-6989586621681707471"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621681707472"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681707472"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707469"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[a] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><a href="../../base-4.18.3.0/src/Data.Foldable.html#null/Data.Foldable.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681707472"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[t] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><a href="../../base-4.18.3.0/src/Data.Foldable.html#null/Data.Foldable.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">[t]
</span><a href="#local-6989586621681707471"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-690"></span><span>    </span><span class="annot"><a href="#local-6989586621681707470"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-type">InfixCon</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707469"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; PprPrec -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#opPrec"><span class="hs-identifier hs-var">opPrec</span></a></span><span> </span><span class="hs-comment">-- type args should be empty in this case</span><span>
</span><span id="line-691"></span><span>    </span><span class="annot"><a href="#local-6989586621681707470"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#RecCon"><span class="hs-identifier hs-type">RecCon</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-692"></span><span>
</span><span id="line-693"></span><span>
</span><span id="line-694"></span><span class="annot"><span class="hs-comment">-- | Parenthesize a pattern without token information</span></span><span>
</span><span id="line-695"></span><span id="local-6989586621681706662"><span class="annot"><a href="GHC.Hs.Pat.html#gParPat"><span class="hs-identifier hs-type">gParPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706662"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706662"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-696"></span><span id="gParPat"><span class="annot"><span class="annottext">gParPat :: forall (pass :: Pass). LPat (GhcPass pass) -&gt; Pat (GhcPass pass)
</span><a href="GHC.Hs.Pat.html#gParPat"><span class="hs-identifier hs-var hs-var">gParPat</span></a></span></span><span> </span><span id="local-6989586621681707476"><span class="annot"><span class="annottext">LPat (GhcPass pass)
</span><a href="#local-6989586621681707476"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass pass)
-&gt; LHsToken &quot;(&quot; (GhcPass pass)
-&gt; LPat (GhcPass pass)
-&gt; LHsToken &quot;)&quot; (GhcPass pass)
-&gt; Pat (GhcPass pass)
forall p.
XParPat p -&gt; LHsToken &quot;(&quot; p -&gt; LPat p -&gt; LHsToken &quot;)&quot; p -&gt; Pat p
</span><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-var">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass pass)
EpAnn NoEpAnns
forall a. EpAnn a
</span><a href="GHC.Parser.Annotation.html#noAnn"><span class="hs-identifier hs-var">noAnn</span></a></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;(&quot; (GhcPass pass)
GenLocated TokenLocation (HsToken &quot;(&quot;)
forall (tok :: Symbol). GenLocated TokenLocation (HsToken tok)
</span><a href="GHC.Hs.Extension.html#noHsTok"><span class="hs-identifier hs-var">noHsTok</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass pass)
</span><a href="#local-6989586621681707476"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;)&quot; (GhcPass pass)
GenLocated TokenLocation (HsToken &quot;)&quot;)
forall (tok :: Symbol). GenLocated TokenLocation (HsToken tok)
</span><a href="GHC.Hs.Extension.html#noHsTok"><span class="hs-identifier hs-var">noHsTok</span></a></span><span>
</span><span id="line-697"></span><span>
</span><span id="line-698"></span><span class="hs-comment">-- | @'parenthesizePat' p pat@ checks if @'patNeedsParens' p pat@ is true, and</span><span>
</span><span id="line-699"></span><span class="hs-comment">-- if so, surrounds @pat@ with a 'ParPat'. Otherwise, it simply returns @pat@.</span><span>
</span><span id="line-700"></span><span id="local-6989586621681706668"><span class="annot"><a href="GHC.Hs.Pat.html#parenthesizePat"><span class="hs-identifier hs-type">parenthesizePat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#IsPass"><span class="hs-identifier hs-type">IsPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706668"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-701"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span>
</span><span id="line-702"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706668"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-703"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681706668"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-704"></span><span id="parenthesizePat"><span class="annot"><span class="annottext">parenthesizePat :: forall (p :: Pass).
IsPass p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; LPat (GhcPass p)
</span><a href="GHC.Hs.Pat.html#parenthesizePat"><span class="hs-identifier hs-var hs-var">parenthesizePat</span></a></span></span><span> </span><span id="local-6989586621681707481"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707481"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621681707482"><span class="annot"><span class="annottext">lpat :: LPat (GhcPass p)
</span><a href="#local-6989586621681707482"><span class="hs-identifier hs-var">lpat</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span id="local-6989586621681707483"><span class="annot"><span class="annottext">SrcSpanAnnA
</span><a href="#local-6989586621681707483"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621681707484"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707484"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-705"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
forall (p :: Pass). IsPass p =&gt; PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-var">patNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681707481"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681707484"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnA
-&gt; Pat (GhcPass p) -&gt; GenLocated SrcSpanAnnA (Pat (GhcPass p))
forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnA
</span><a href="#local-6989586621681707483"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Pat (GhcPass p)
forall (pass :: Pass). LPat (GhcPass pass) -&gt; Pat (GhcPass pass)
</span><a href="GHC.Hs.Pat.html#gParPat"><span class="hs-identifier hs-var">gParPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707482"><span class="hs-identifier hs-var">lpat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-706"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#otherwise/GHC.Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681707482"><span class="hs-identifier hs-var">lpat</span></a></span><span>
</span><span id="line-707"></span><span>
</span><span id="line-708"></span><span class="hs-comment">{-
% Collect all EvVars from all constructor patterns
-}</span><span>
</span><span id="line-711"></span><span>
</span><span id="line-712"></span><span class="hs-comment">-- May need to add more cases</span><span>
</span><span id="line-713"></span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPats"><span class="hs-identifier hs-type">collectEvVarsPats</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span>
</span><span id="line-714"></span><span id="collectEvVarsPats"><span class="annot"><span class="annottext">collectEvVarsPats :: [Pat GhcTc] -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPats"><span class="hs-identifier hs-var hs-var">collectEvVarsPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Bag TyVar] -&gt; Bag TyVar
forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span> </span><span class="annot"><span class="annottext">([Bag TyVar] -&gt; Bag TyVar)
-&gt; ([Pat GhcTc] -&gt; [Bag TyVar]) -&gt; [Pat GhcTc] -&gt; Bag TyVar
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat GhcTc -&gt; Bag TyVar) -&gt; [Pat GhcTc] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span>
</span><span id="line-715"></span><span>
</span><span id="line-716"></span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-type">collectEvVarsLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span>
</span><span id="line-717"></span><span id="collectEvVarsLPat"><span class="annot"><span class="annottext">collectEvVarsLPat :: LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var hs-var">collectEvVarsLPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span> </span><span class="annot"><span class="annottext">(Pat GhcTc -&gt; Bag TyVar)
-&gt; (LocatedAn AnnListItem (Pat GhcTc) -&gt; Pat GhcTc)
-&gt; LocatedAn AnnListItem (Pat GhcTc)
-&gt; Bag TyVar
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedAn AnnListItem (Pat GhcTc) -&gt; Pat GhcTc
forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-718"></span><span>
</span><span id="line-719"></span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-type">collectEvVarsPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span>
</span><span id="line-720"></span><span id="collectEvVarsPat"><span class="annot"><span class="annottext">collectEvVarsPat :: Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var hs-var">collectEvVarsPat</span></a></span></span><span> </span><span id="local-6989586621681707487"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707487"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-721"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707487"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-722"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707488"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707488"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707488"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-723"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;@&quot; GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707489"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707489"><span class="hs-identifier hs-var">p</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707489"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-724"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span>  </span><span class="annot"><span class="annottext">XParPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;(&quot; GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707490"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707490"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">LHsToken &quot;)&quot; GhcTc
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707490"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-725"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707491"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707491"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707491"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-726"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="annot"><span class="annottext">XListPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707492"><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621681707492"><span class="hs-identifier hs-var">ps</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Bag TyVar] -&gt; Bag TyVar
forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span> </span><span class="annot"><span class="annottext">([Bag TyVar] -&gt; Bag TyVar) -&gt; [Bag TyVar] -&gt; Bag TyVar
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">(LocatedAn AnnListItem (Pat GhcTc) -&gt; Bag TyVar)
-&gt; [LocatedAn AnnListItem (Pat GhcTc)] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
LocatedAn AnnListItem (Pat GhcTc) -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat GhcTc]
[LocatedAn AnnListItem (Pat GhcTc)]
</span><a href="#local-6989586621681707492"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-727"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707493"><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621681707493"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Bag TyVar] -&gt; Bag TyVar
forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span> </span><span class="annot"><span class="annottext">([Bag TyVar] -&gt; Bag TyVar) -&gt; [Bag TyVar] -&gt; Bag TyVar
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">(LocatedAn AnnListItem (Pat GhcTc) -&gt; Bag TyVar)
-&gt; [LocatedAn AnnListItem (Pat GhcTc)] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
LocatedAn AnnListItem (Pat GhcTc) -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat GhcTc]
[LocatedAn AnnListItem (Pat GhcTc)]
</span><a href="#local-6989586621681707493"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-728"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSumPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707494"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707494"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707494"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-729"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span>
</span><span id="line-730"></span><span>      </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707495"><span class="annot"><span class="annottext">HsConPatDetails GhcTc
</span><a href="#local-6989586621681707495"><span class="hs-identifier hs-var">args</span></a></span></span><span>
</span><span id="line-731"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_con_ext :: forall p. Pat p -&gt; XConPat p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con_ext"><span class="hs-identifier hs-var">pat_con_ext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span>
</span><span id="line-732"></span><span>        </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cpt_dicts :: ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var">cpt_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681707496"><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681707496"><span class="hs-identifier hs-var">dicts</span></a></span></span><span>
</span><span id="line-733"></span><span>        </span><span class="hs-special">}</span><span>
</span><span id="line-734"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-735"></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bag TyVar -&gt; Bag TyVar -&gt; Bag TyVar
forall a. Bag a -&gt; Bag a -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionBags"><span class="hs-identifier hs-var">unionBags</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVar] -&gt; Bag TyVar
forall a. [a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#listToBag"><span class="hs-identifier hs-var">listToBag</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681707496"><span class="hs-identifier hs-var">dicts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-736"></span><span>                                   </span><span class="annot"><span class="annottext">(Bag TyVar -&gt; Bag TyVar) -&gt; Bag TyVar -&gt; Bag TyVar
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">[Bag TyVar] -&gt; Bag TyVar
forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span>
</span><span id="line-737"></span><span>                                   </span><span class="annot"><span class="annottext">([Bag TyVar] -&gt; Bag TyVar) -&gt; [Bag TyVar] -&gt; Bag TyVar
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">(LocatedAn AnnListItem (Pat GhcTc) -&gt; Bag TyVar)
-&gt; [LocatedAn AnnListItem (Pat GhcTc)] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
LocatedAn AnnListItem (Pat GhcTc) -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span>
</span><span id="line-738"></span><span>                                   </span><span class="annot"><span class="annottext">([LocatedAn AnnListItem (Pat GhcTc)] -&gt; [Bag TyVar])
-&gt; [LocatedAn AnnListItem (Pat GhcTc)] -&gt; [Bag TyVar]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.3.0/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails GhcTc -&gt; [LPat GhcTc]
forall p. UnXRec p =&gt; HsConPatDetails p -&gt; [LPat p]
</span><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-var">hsConPatArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails GhcTc
</span><a href="#local-6989586621681707495"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-739"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span>  </span><span class="annot"><span class="annottext">XSigPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707499"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707499"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc GhcTc)
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681707499"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-740"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621681707500"><span class="annot"><span class="annottext">XXPat GhcTc
</span><a href="#local-6989586621681707500"><span class="hs-identifier hs-var">ext</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XXPat GhcTc
</span><a href="#local-6989586621681707500"><span class="hs-identifier hs-var">ext</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-741"></span><span>      </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707501"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707501"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707501"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-742"></span><span>      </span><span class="annot"><a href="GHC.Hs.Pat.html#ExpansionPat"><span class="hs-identifier hs-type">ExpansionPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcRn
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681707502"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707502"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707502"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-743"></span><span>    </span><span id="local-6989586621681707503"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681707503"><span class="hs-identifier hs-var">_other_pat</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bag TyVar
forall a. Bag a
</span><a href="GHC.Data.Bag.html#emptyBag"><span class="hs-identifier hs-var">emptyBag</span></a></span><span>
</span><span id="line-744"></span><span>
</span><span id="line-745"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Anno instances}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-752"></span><span>
</span><span id="line-753"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621681707505"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681707505"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnA"><span class="hs-identifier hs-type">SrcSpanAnnA</span></a></span><span>
</span><span id="line-754"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621681707506"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsOverLit"><span class="hs-identifier hs-type">HsOverLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681707506"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcAnn"><span class="hs-identifier hs-type">SrcAnn</span></a></span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#NoEpAnns"><span class="hs-identifier hs-type">NoEpAnns</span></a></span><span>
</span><span id="line-755"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span class="annot"><a href="GHC.Core.ConLike.html#ConLike"><span class="hs-identifier hs-type">ConLike</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnN"><span class="hs-identifier hs-type">SrcSpanAnnN</span></a></span><span>
</span><span id="line-756"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621681707507"><span id="local-6989586621681707508"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681707507"><span class="hs-identifier hs-type">lhs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681707508"><span class="hs-identifier hs-type">rhs</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnA"><span class="hs-identifier hs-type">SrcSpanAnnA</span></a></span><span>
</span><span id="line-757"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-type">RecFieldsDotDot</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#SrcSpan"><span class="hs-identifier hs-type">SrcSpan</span></a></span><span>
</span><span id="line-758"></span></pre></body></html>