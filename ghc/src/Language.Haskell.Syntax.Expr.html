<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621681598052"><span id="local-6989586621681598053"><span id="local-6989586621681598054"><span id="local-6989586621681598055"><span id="local-6989586621681598056"><span id="local-6989586621681598057"><span id="local-6989586621681598058"><span id="local-6989586621681598059"><span id="local-6989586621681598060"></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE DataKinds #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE ExistentialQuantification #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilyDependencies #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span> </span><span class="hs-comment">-- Wrinkle in Note [Trees That Grow]</span><span>
</span><span id="line-11"></span><span>                                      </span><span class="hs-comment">-- in module Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-12"></span><span>
</span><span id="line-13"></span><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
-}</span><span>
</span><span id="line-17"></span><span>
</span><span id="line-18"></span><span class="hs-comment">-- See Note [Language.Haskell.Syntax.* Hierarchy] for why not GHC.Hs.*</span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span class="annot"><span class="hs-comment">-- | Abstract Haskell syntax for expressions.</span></span><span>
</span><span id="line-21"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.Syntax.Expr</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html"><span class="hs-identifier">Language.Haskell.Syntax.Basic</span></a></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html"><span class="hs-identifier">Language.Haskell.Syntax.Decls</span></a></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html"><span class="hs-identifier">Language.Haskell.Syntax.Pat</span></a></span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html"><span class="hs-identifier">Language.Haskell.Syntax.Lit</span></a></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html"><span class="hs-identifier">Language.Haskell.Syntax.Concrete</span></a></span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html"><span class="hs-identifier">Language.Haskell.Syntax.Extension</span></a></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html"><span class="hs-identifier">Language.Haskell.Syntax.Type</span></a></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html"><span class="hs-identifier">Language.Haskell.Syntax.Binds</span></a></span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-comment">-- others:</span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html"><span class="hs-identifier">GHC.Types.Fixity</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier">LexicalFixity</span></a></span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Fixity.html#Infix"><span class="hs-identifier">Infix</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#Fixity"><span class="hs-identifier">Fixity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html"><span class="hs-identifier">GHC.Types.SourceText</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SourceText.html#StringLiteral"><span class="hs-identifier">StringLiteral</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html#SourceText"><span class="hs-identifier">SourceText</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Unit.Module.html"><span class="hs-identifier">GHC.Unit.Module</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Module.Name.html#ModuleName"><span class="hs-identifier">ModuleName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.FastString.html"><span class="hs-identifier">GHC.Data.FastString</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Data.FastString.html#FastString"><span class="hs-identifier">FastString</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span class="hs-comment">-- libraries:</span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Data.html#/Data.Data.html"><span class="hs-identifier">Data.Data</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Data.html#Fixity/Data.Data.html#Fixity"><span class="hs-identifier">Fixity</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Bool.html#/Data.Bool.html"><span class="hs-identifier">Data.Bool</span></a></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Either.html#/Data.Either.html"><span class="hs-identifier">Data.Either</span></a></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Eq.html#/Data.Eq.html"><span class="hs-identifier">Data.Eq</span></a></span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Maybe.html#/Data.Maybe.html"><span class="hs-identifier">Data.Maybe</span></a></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.List.NonEmpty.html#/Data.List.NonEmpty.html"><span class="hs-identifier">Data.List.NonEmpty</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#NonEmpty/GHC.Base.html#NonEmpty"><span class="hs-identifier">NonEmpty</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html"><span class="hs-identifier">GHC.Types.Name.Reader</span></a></span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span class="hs-comment">{- Note [RecordDotSyntax field updates]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The extensions @OverloadedRecordDot@ @OverloadedRecordUpdate@ together
enable record updates like @a{foo.bar.baz = 1}@. Introducing this
syntax slightly complicates parsing. This note explains how it's done.

In the event a record is being constructed or updated, it's this
production that's in play:
@
aexp1 -&gt; aexp1 '{' fbinds '}' {
  ...
  mkHsRecordPV ... $1 (snd $3)
}
@
@fbinds@ is a list of field bindings. @mkHsRecordPV@ is a function of
the @DisambECP b@ typeclass, see Note [Ambiguous syntactic
categories].

The &quot;normal&quot; rules for an @fbind@ are:
@
fbind
        : qvar '=' texp
        | qvar
@
These rules compute values of @LHsRecField GhcPs (Located b)@. They
apply in the context of record construction, record updates, record
patterns and record expressions. That is, @b@ ranges over @HsExpr
GhcPs@, @HsPat GhcPs@ and @HsCmd GhcPs@.

When @OverloadedRecordDot@ and @OverloadedRecordUpdate@ are both
enabled, two additional @fbind@ rules are admitted:
@
        | field TIGHT_INFIX_PROJ fieldToUpdate '=' texp
        | field TIGHT_INFIX_PROJ fieldToUpdate
@

These rules only make sense when parsing record update expressions
(that is, patterns and commands cannot be parsed by these rules and
neither record constructions).

The results of these new rules cannot be represented by @LHsRecField
GhcPs (LHsExpr GhcPs)@ values as the type is defined today. We
minimize modifying existing code by having these new rules calculate
@LHsRecProj GhcPs (LHsExpr GhcPs)@ (&quot;record projection&quot;) values
instead:
@
newtype FieldLabelStrings = FieldLabelStrings [XRec p (DotFieldOcc p)]
type RecProj arg = HsFieldBind FieldLabelStrings arg
type LHsRecProj p arg = XRec p (RecProj arg)
@

The @fbind@ rule is then given the type @fbind :: { forall b.
DisambECP b =&gt; PV (Fbind b) }@ accommodating both alternatives:
@
type Fbind b = Either
                  (LHsRecField GhcPs (LocatedA b))
                  ( LHsRecProj GhcPs (LocatedA b))
@

In @data HsExpr p@, the @RecordUpd@ constuctor indicates regular
updates vs. projection updates by means of the @rupd_flds@ member
type, an @Either@ instance:
@
  | RecordUpd
      { rupd_ext  :: XRecordUpd p
      , rupd_expr :: LHsExpr p
      , rupd_flds :: Either [LHsRecUpdField p] [LHsRecUpdProj p]
      }
@
Here,
@
type RecUpdProj p = RecProj p (LHsExpr p)
type LHsRecUpdProj p = XRec p (RecUpdProj p)
@
and @Left@ values indicating regular record update, @Right@ values
updates desugared to @setField@s.

If @OverloadedRecordUpdate@ is enabled, any updates parsed as
@LHsRecField GhcPs@ values are converted to @LHsRecUpdProj GhcPs@
values (see function @mkRdrRecordUpd@ in 'GHC.Parser.PostProcess').
-}</span><span>
</span><span id="line-129"></span><span>
</span><span id="line-130"></span><span class="annot"><span class="hs-comment">-- | RecordDotSyntax field updates</span></span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span class="hs-keyword">type</span><span> </span><span id="LFieldLabelStrings"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LFieldLabelStrings"><span class="hs-identifier hs-var">LFieldLabelStrings</span></a></span></span><span> </span><span id="local-6989586621681598068"><span class="annot"><a href="#local-6989586621681598068"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598068"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-type">FieldLabelStrings</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598068"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-133"></span><span>
</span><span id="line-134"></span><span class="hs-keyword">newtype</span><span> </span><span id="FieldLabelStrings"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-var">FieldLabelStrings</span></a></span></span><span> </span><span id="local-6989586621681598070"><span class="annot"><a href="#local-6989586621681598070"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-135"></span><span>  </span><span id="FieldLabelStrings"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-var">FieldLabelStrings</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598070"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DotFieldOcc"><span class="hs-identifier hs-type">DotFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598070"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-136"></span><span>
</span><span id="line-137"></span><span class="hs-comment">-- Field projection updates (e.g. @foo.bar.baz = 1@). See Note</span><span>
</span><span id="line-138"></span><span class="hs-comment">-- [RecordDotSyntax field updates].</span><span>
</span><span id="line-139"></span><span class="hs-keyword">type</span><span> </span><span id="RecProj"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecProj"><span class="hs-identifier hs-var">RecProj</span></a></span></span><span> </span><span id="local-6989586621681598073"><span class="annot"><a href="#local-6989586621681598073"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681598074"><span class="annot"><a href="#local-6989586621681598074"><span class="hs-identifier hs-type">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LFieldLabelStrings"><span class="hs-identifier hs-type">LFieldLabelStrings</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598073"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681598074"><span class="hs-identifier hs-type">arg</span></a></span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span class="hs-comment">-- The phantom type parameter @p@ is for symmetry with @LHsRecField p</span><span>
</span><span id="line-142"></span><span class="hs-comment">-- arg@ in the definition of @data Fbind@ (see GHC.Parser.Process).</span><span>
</span><span id="line-143"></span><span class="hs-keyword">type</span><span> </span><span id="LHsRecProj"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsRecProj"><span class="hs-identifier hs-var">LHsRecProj</span></a></span></span><span> </span><span id="local-6989586621681598077"><span class="annot"><a href="#local-6989586621681598077"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681598078"><span class="annot"><a href="#local-6989586621681598078"><span class="hs-identifier hs-type">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598077"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecProj"><span class="hs-identifier hs-type">RecProj</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598077"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598078"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-144"></span><span>
</span><span id="line-145"></span><span class="hs-comment">-- These two synonyms are used in the definition of syntax @RecordUpd@</span><span>
</span><span id="line-146"></span><span class="hs-comment">-- below.</span><span>
</span><span id="line-147"></span><span class="hs-keyword">type</span><span> </span><span id="RecUpdProj"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecUpdProj"><span class="hs-identifier hs-var">RecUpdProj</span></a></span></span><span> </span><span id="local-6989586621681598080"><span class="annot"><a href="#local-6989586621681598080"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecProj"><span class="hs-identifier hs-type">RecProj</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598080"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598080"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-148"></span><span class="hs-keyword">type</span><span> </span><span id="LHsRecUpdProj"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsRecUpdProj"><span class="hs-identifier hs-var">LHsRecUpdProj</span></a></span></span><span> </span><span id="local-6989586621681598081"><span class="annot"><a href="#local-6989586621681598081"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598081"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecUpdProj"><span class="hs-identifier hs-type">RecUpdProj</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598081"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-149"></span><span>
</span><span id="line-150"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Expressions proper}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-157"></span><span>
</span><span id="line-158"></span><span class="annot"><span class="hs-comment">-- * Expressions proper</span></span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Expression</span></span><span>
</span><span id="line-161"></span><span class="hs-keyword">type</span><span> </span><span id="LHsExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-var">LHsExpr</span></a></span></span><span> </span><span id="local-6989586621681598082"><span class="annot"><a href="#local-6989586621681598082"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598082"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598082"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-162"></span><span>  </span><span class="hs-comment">-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when</span><span>
</span><span id="line-163"></span><span>  </span><span class="hs-comment">--   in a list</span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-166"></span><span>
</span><span id="line-167"></span><span class="hs-comment">-------------------------</span><span>
</span><span id="line-168"></span><span class="hs-comment">{- Note [NoSyntaxExpr]
~~~~~~~~~~~~~~~~~~~~~~
Syntax expressions can be missing (NoSyntaxExprRn or NoSyntaxExprTc)
for several reasons:

 1. As described in Note [Rebindable if]

 2. In order to suppress &quot;not in scope: xyz&quot; messages when a bit of
    rebindable syntax does not apply. For example, when using an irrefutable
    pattern in a BindStmt, we don't need a `fail` operator.

 3. Rebindable syntax might just not make sense. For example, a BodyStmt
    contains the syntax for `guard`, but that's used only in monad comprehensions.
    If we had more of a whiz-bang type system, we might be able to rule this
    case out statically.
-}</span><span>
</span><span id="line-184"></span><span>
</span><span id="line-185"></span><span class="hs-comment">-- | Syntax Expression</span><span>
</span><span id="line-186"></span><span class="hs-comment">--</span><span>
</span><span id="line-187"></span><span class="hs-comment">-- SyntaxExpr is represents the function used in interpreting rebindable</span><span>
</span><span id="line-188"></span><span class="hs-comment">-- syntax. In the parser, we have no information to supply; in the renamer,</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- we have the name of the function (but see</span><span>
</span><span id="line-190"></span><span class="hs-comment">-- Note [Monad fail : Rebindable syntax, overloaded strings] for a wrinkle)</span><span>
</span><span id="line-191"></span><span class="hs-comment">-- and in the type-checker we have a more elaborate structure 'SyntaxExprTc'.</span><span>
</span><span id="line-192"></span><span class="hs-comment">--</span><span>
</span><span id="line-193"></span><span class="hs-comment">-- In some contexts, rebindable syntax is not implemented, and so we have</span><span>
</span><span id="line-194"></span><span class="hs-comment">-- constructors to represent that possibility in both the renamer and</span><span>
</span><span id="line-195"></span><span class="hs-comment">-- typechecker instantiations.</span><span>
</span><span id="line-196"></span><span class="hs-comment">--</span><span>
</span><span id="line-197"></span><span class="hs-comment">-- E.g. @(&gt;&gt;=)@ is filled in before the renamer by the appropriate 'Name' for</span><span>
</span><span id="line-198"></span><span class="hs-comment">--      @(&gt;&gt;=)@, and then instantiated by the type checker with its type args</span><span>
</span><span id="line-199"></span><span class="hs-comment">--      etc</span><span>
</span><span id="line-200"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="SyntaxExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-var">SyntaxExpr</span></a></span></span><span> </span><span id="local-6989586621681598083"><span class="annot"><a href="#local-6989586621681598083"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-201"></span><span>
</span><span id="line-202"></span><span class="hs-comment">{-
Note [Record selectors in the AST]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Here is how record selectors are expressed in GHC's AST:

Example data type
  data T = MkT { size :: Int }

Record selectors:
                      |    GhcPs     |   GhcRn              |    GhcTc            |
----------------------------------------------------------------------------------|
size (assuming one    | HsVar        | HsRecSel             | HsRecSel            |
     'size' in scope) |              |                      |                     |
----------------------|--------------|----------------------|---------------------|
.size (assuming       | HsProjection | getField @&quot;size&quot;     | getField @&quot;size&quot;    |
 OverloadedRecordDot) |              |                      |                     |
----------------------|--------------|----------------------|---------------------|
e.size (assuming      | HsGetField   | getField @&quot;size&quot; e   | getField @&quot;size&quot; e  |
 OverloadedRecordDot) |              |                      |                     |

NB 1: DuplicateRecordFields makes no difference to the first row of
this table, except that if 'size' is a field of more than one data
type, then a naked use of the record selector 'size' may well be
ambiguous. You have to use a qualified name. And there is no way to do
this if both data types are declared in the same module.

NB 2: The notation getField @&quot;size&quot; e is short for
HsApp (HsAppType (HsVar &quot;getField&quot;) (HsWC (HsTyLit (HsStrTy &quot;size&quot;)) [])) e.
We track the original parsed syntax via HsExpanded.

-}</span><span>
</span><span id="line-233"></span><span>
</span><span id="line-234"></span><span class="hs-comment">{-
Note [Non-overloaded record field selectors]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider
    data T = MkT { x,y :: Int }
    f r x = x + y r

This parses with HsVar for x, y, r on the RHS of f. Later, the renamer
recognises that y in the RHS of f is really a record selector, and
changes it to a HsRecSel. In contrast x is locally bound, shadowing
the record selector, and stays as an HsVar.

The renamer adds the Name of the record selector into the XCFieldOcc
extension field, The typechecker keeps HsRecSel as HsRecSel, and
transforms the record-selector Name to an Id.
-}</span><span>
</span><span id="line-250"></span><span>
</span><span id="line-251"></span><span class="annot"><span class="hs-comment">-- | A Haskell expression.</span></span><span>
</span><span id="line-252"></span><span class="hs-keyword">data</span><span> </span><span id="HsExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-var">HsExpr</span></a></span></span><span> </span><span id="local-6989586621681597776"><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-253"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsVar"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsVar"><span class="hs-identifier hs-var">HsVar</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XVar"><span class="hs-identifier hs-type">XVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-254"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ Variable</span><span>
</span><span id="line-255"></span><span>                       </span><span class="hs-comment">-- See Note [Located RdrNames]</span><span>
</span><span id="line-256"></span><span>
</span><span id="line-257"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsUnboundVar"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUnboundVar"><span class="hs-identifier hs-var">HsUnboundVar</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XUnboundVar"><span class="hs-identifier hs-type">XUnboundVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-258"></span><span>                 </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span>     </span><span class="hs-comment">-- ^ Unbound variable; also used for &quot;holes&quot;</span><span>
</span><span id="line-259"></span><span>                             </span><span class="hs-comment">--   (_ or _x).</span><span>
</span><span id="line-260"></span><span>                             </span><span class="hs-comment">-- Turned from HsVar to HsUnboundVar by the</span><span>
</span><span id="line-261"></span><span>                             </span><span class="hs-comment">--   renamer, when it finds an out-of-scope</span><span>
</span><span id="line-262"></span><span>                             </span><span class="hs-comment">--   variable or hole.</span><span>
</span><span id="line-263"></span><span>                             </span><span class="hs-comment">-- The (XUnboundVar p) field becomes an HoleExprRef</span><span>
</span><span id="line-264"></span><span>                             </span><span class="hs-comment">--   after typechecking; this is where the</span><span>
</span><span id="line-265"></span><span>                             </span><span class="hs-comment">--   erroring expression will be written after</span><span>
</span><span id="line-266"></span><span>                             </span><span class="hs-comment">--   solving. See Note [Holes] in GHC.Tc.Types.Constraint.</span><span>
</span><span id="line-267"></span><span>
</span><span id="line-268"></span><span>
</span><span id="line-269"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsRecSel"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsRecSel"><span class="hs-identifier hs-var">HsRecSel</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRecSel"><span class="hs-identifier hs-type">XRecSel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-270"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#FieldOcc"><span class="hs-identifier hs-type">FieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ Variable pointing to record selector</span><span>
</span><span id="line-271"></span><span>                           </span><span class="hs-comment">-- See Note [Non-overloaded record field selectors] and</span><span>
</span><span id="line-272"></span><span>                           </span><span class="hs-comment">-- Note [Record selectors in the AST]</span><span>
</span><span id="line-273"></span><span>
</span><span id="line-274"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsOverLabel"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsOverLabel"><span class="hs-identifier hs-var">HsOverLabel</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XOverLabel"><span class="hs-identifier hs-type">XOverLabel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html#SourceText"><span class="hs-identifier hs-type">SourceText</span></a></span><span> </span><span class="annot"><a href="GHC.Data.FastString.html#FastString"><span class="hs-identifier hs-type">FastString</span></a></span><span>
</span><span id="line-275"></span><span>     </span><span class="hs-comment">-- ^ Overloaded label (Note [Overloaded labels] in GHC.OverloadedLabels)</span><span>
</span><span id="line-276"></span><span>     </span><span class="hs-comment">-- Note [Pragma source text] in GHC.Types.SourceText</span><span>
</span><span id="line-277"></span><span>
</span><span id="line-278"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsIPVar"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsIPVar"><span class="hs-identifier hs-var">HsIPVar</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XIPVar"><span class="hs-identifier hs-type">XIPVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-279"></span><span>              </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier hs-type">HsIPName</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ Implicit parameter (not in use after typechecking)</span></span><span>
</span><span id="line-280"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsOverLit"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsOverLit"><span class="hs-identifier hs-var">HsOverLit</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XOverLitE"><span class="hs-identifier hs-type">XOverLitE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-281"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsOverLit"><span class="hs-identifier hs-type">HsOverLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Overloaded literals</span></span><span>
</span><span id="line-282"></span><span>
</span><span id="line-283"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsLit"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsLit"><span class="hs-identifier hs-var">HsLit</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLitE"><span class="hs-identifier hs-type">XLitE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-284"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsLit"><span class="hs-identifier hs-type">HsLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>      </span><span class="annot"><span class="hs-comment">-- ^ Simple (non-overloaded) literals</span></span><span>
</span><span id="line-285"></span><span>
</span><span id="line-286"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsLam"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsLam"><span class="hs-identifier hs-var">HsLam</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLam"><span class="hs-identifier hs-type">XLam</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-288"></span><span>                       </span><span class="hs-comment">-- ^ Lambda abstraction. Currently always a single match</span><span>
</span><span id="line-289"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-290"></span><span>       </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span><span>
</span><span id="line-291"></span><span>       </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnRarrow',</span><span>
</span><span id="line-292"></span><span>
</span><span id="line-293"></span><span>       </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-294"></span><span>
</span><span id="line-295"></span><span>  </span><span class="hs-comment">-- | Lambda-case</span><span>
</span><span id="line-296"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-297"></span><span>  </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span><span>
</span><span id="line-298"></span><span>  </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnCase','GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-299"></span><span>  </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-300"></span><span>  </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span><span>
</span><span id="line-301"></span><span>  </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnCases','GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-302"></span><span>  </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-305"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsLamCase"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsLamCase"><span class="hs-identifier hs-var">HsLamCase</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLamCase"><span class="hs-identifier hs-type">XLamCase</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LamCaseVariant"><span class="hs-identifier hs-type">LamCaseVariant</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-306"></span><span>
</span><span id="line-307"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsApp"><span class="hs-identifier hs-var">HsApp</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XApp"><span class="hs-identifier hs-type">XApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Application</span></span><span>
</span><span id="line-308"></span><span>
</span><span id="line-309"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsAppType"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsAppType"><span class="hs-identifier hs-var">HsAppType</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAppTypeE"><span class="hs-identifier hs-type">XAppTypeE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- After typechecking: the type argument</span><span>
</span><span id="line-310"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-311"></span><span>             </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;@&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-312"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsWcType"><span class="hs-identifier hs-type">LHsWcType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoGhcTc"><span class="hs-identifier hs-type">NoGhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^ Visible type application</span><span>
</span><span id="line-313"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-314"></span><span>       </span><span class="hs-comment">-- Explicit type argument; e.g  f @Int x y</span><span>
</span><span id="line-315"></span><span>       </span><span class="hs-comment">-- NB: Has wildcards, but no implicit quantification</span><span>
</span><span id="line-316"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-317"></span><span>       </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnAt',</span><span>
</span><span id="line-318"></span><span>
</span><span id="line-319"></span><span>  </span><span class="hs-comment">-- | Operator applications:</span><span>
</span><span id="line-320"></span><span>  </span><span class="hs-comment">-- NB Bracketed ops such as (+) come out as Vars.</span><span>
</span><span id="line-321"></span><span>
</span><span id="line-322"></span><span>  </span><span class="hs-comment">-- NB Sadly, we need an expr for the operator in an OpApp/Section since</span><span>
</span><span id="line-323"></span><span>  </span><span class="hs-comment">-- the renamer may turn a HsVar into HsRecSel or HsUnboundVar</span><span>
</span><span id="line-324"></span><span>
</span><span id="line-325"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="OpApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#OpApp"><span class="hs-identifier hs-var">OpApp</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XOpApp"><span class="hs-identifier hs-type">XOpApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-326"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- left operand</span><span>
</span><span id="line-327"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- operator</span><span>
</span><span id="line-328"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- right operand</span><span>
</span><span id="line-329"></span><span>
</span><span id="line-330"></span><span>  </span><span class="hs-comment">-- | Negation operator. Contains the negated expression and the name</span><span>
</span><span id="line-331"></span><span>  </span><span class="hs-comment">-- of 'negate'</span><span>
</span><span id="line-332"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-333"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnMinus'</span><span>
</span><span id="line-334"></span><span>
</span><span id="line-335"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-336"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NegApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#NegApp"><span class="hs-identifier hs-var">NegApp</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNegApp"><span class="hs-identifier hs-type">XNegApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-337"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-338"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-339"></span><span>
</span><span id="line-340"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span><span>
</span><span id="line-341"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnClose' @')'@</span><span>
</span><span id="line-342"></span><span>
</span><span id="line-343"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-344"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsPar"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsPar"><span class="hs-identifier hs-var">HsPar</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPar"><span class="hs-identifier hs-type">XPar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-345"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;(&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-346"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Parenthesised expr; see Note [Parens in HsSyn]</span></span><span>
</span><span id="line-347"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;)&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-348"></span><span>
</span><span id="line-349"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SectionL"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SectionL"><span class="hs-identifier hs-var">SectionL</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSectionL"><span class="hs-identifier hs-type">XSectionL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-350"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- operand; see Note [Sections in HsSyn]</span><span>
</span><span id="line-351"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- operator</span><span>
</span><span id="line-352"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SectionR"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SectionR"><span class="hs-identifier hs-var">SectionR</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSectionR"><span class="hs-identifier hs-type">XSectionR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-353"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- operator; see Note [Sections in HsSyn]</span><span>
</span><span id="line-354"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- operand</span><span>
</span><span id="line-355"></span><span>
</span><span id="line-356"></span><span>  </span><span class="hs-comment">-- | Used for explicit tuples and sections thereof</span><span>
</span><span id="line-357"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-358"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-359"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-360"></span><span>
</span><span id="line-361"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-362"></span><span>  </span><span class="hs-comment">-- Note [ExplicitTuple]</span><span>
</span><span id="line-363"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitTuple"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExplicitTuple"><span class="hs-identifier hs-var">ExplicitTuple</span></a></span></span><span>
</span><span id="line-364"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExplicitTuple"><span class="hs-identifier hs-type">XExplicitTuple</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-365"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTupArg"><span class="hs-identifier hs-type">HsTupArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-366"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html#Boxity"><span class="hs-identifier hs-type">Boxity</span></a></span><span>
</span><span id="line-367"></span><span>
</span><span id="line-368"></span><span>  </span><span class="hs-comment">-- | Used for unboxed sum types</span><span>
</span><span id="line-369"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-370"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'(#'@,</span><span>
</span><span id="line-371"></span><span>  </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnVbar', 'GHC.Parser.Annotation.AnnClose' @'#)'@,</span><span>
</span><span id="line-372"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-373"></span><span>  </span><span class="hs-comment">--  There will be multiple 'GHC.Parser.Annotation.AnnVbar', (1 - alternative) before</span><span>
</span><span id="line-374"></span><span>  </span><span class="hs-comment">--  the expression, (arity - alternative) after it</span><span>
</span><span id="line-375"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitSum"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExplicitSum"><span class="hs-identifier hs-var">ExplicitSum</span></a></span></span><span>
</span><span id="line-376"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExplicitSum"><span class="hs-identifier hs-type">XExplicitSum</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-377"></span><span>          </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html#ConTag"><span class="hs-identifier hs-type">ConTag</span></a></span><span>   </span><span class="hs-comment">--  Alternative (one-based)</span><span>
</span><span id="line-378"></span><span>          </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html#SumWidth"><span class="hs-identifier hs-type">SumWidth</span></a></span><span> </span><span class="hs-comment">--  Sum arity</span><span>
</span><span id="line-379"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-380"></span><span>
</span><span id="line-381"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnCase',</span><span>
</span><span id="line-382"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOf','GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-383"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-384"></span><span>
</span><span id="line-385"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-386"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCase"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCase"><span class="hs-identifier hs-var">HsCase</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCase"><span class="hs-identifier hs-type">XCase</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-387"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-388"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-389"></span><span>
</span><span id="line-390"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnIf',</span><span>
</span><span id="line-391"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-392"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnThen','GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-393"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnElse',</span><span>
</span><span id="line-394"></span><span>
</span><span id="line-395"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-396"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsIf"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsIf"><span class="hs-identifier hs-var">HsIf</span></a></span></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XIf"><span class="hs-identifier hs-type">XIf</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- GhcPs: this is a Bool; False &lt;=&gt; do not use</span><span>
</span><span id="line-397"></span><span>                               </span><span class="hs-comment">--  rebindable syntax</span><span>
</span><span id="line-398"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">--  predicate</span><span>
</span><span id="line-399"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">--  then part</span><span>
</span><span id="line-400"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">--  else part</span><span>
</span><span id="line-401"></span><span>
</span><span id="line-402"></span><span>  </span><span class="hs-comment">-- | Multi-way if</span><span>
</span><span id="line-403"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-404"></span><span>  </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnIf'</span><span>
</span><span id="line-405"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose',</span><span>
</span><span id="line-406"></span><span>
</span><span id="line-407"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-408"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsMultiIf"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMultiIf"><span class="hs-identifier hs-var">HsMultiIf</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XMultiIf"><span class="hs-identifier hs-type">XMultiIf</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LGRHS"><span class="hs-identifier hs-type">LGRHS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-409"></span><span>
</span><span id="line-410"></span><span>  </span><span class="hs-comment">-- | let(rec)</span><span>
</span><span id="line-411"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-412"></span><span>  </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLet',</span><span>
</span><span id="line-413"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-414"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'}'@,'GHC.Parser.Annotation.AnnIn'</span><span>
</span><span id="line-415"></span><span>
</span><span id="line-416"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-417"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsLet"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsLet"><span class="hs-identifier hs-var">HsLet</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLet"><span class="hs-identifier hs-type">XLet</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-418"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;let&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-419"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBinds"><span class="hs-identifier hs-type">HsLocalBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-420"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;in&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-421"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-422"></span><span>
</span><span id="line-423"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDo',</span><span>
</span><span id="line-424"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnOpen', 'GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-425"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnVbar',</span><span>
</span><span id="line-426"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-427"></span><span>
</span><span id="line-428"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-429"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsDo"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDo"><span class="hs-identifier hs-var">HsDo</span></a></span></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDo"><span class="hs-identifier hs-type">XDo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>                  </span><span class="hs-comment">-- Type of the whole expression</span><span>
</span><span id="line-430"></span><span>                </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoFlavour"><span class="hs-identifier hs-type">HsDoFlavour</span></a></span><span>
</span><span id="line-431"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprLStmt"><span class="hs-identifier hs-type">ExprLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- &quot;do&quot;:one or more stmts</span><span>
</span><span id="line-432"></span><span>
</span><span id="line-433"></span><span>  </span><span class="hs-comment">-- | Syntactic list: [a,b,c,...]</span><span>
</span><span id="line-434"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-435"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'['@,</span><span>
</span><span id="line-436"></span><span>  </span><span class="hs-comment">--              'GHC.Parser.Annotation.AnnClose' @']'@</span><span>
</span><span id="line-437"></span><span>
</span><span id="line-438"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-439"></span><span>  </span><span class="hs-comment">-- See Note [Empty lists]</span><span>
</span><span id="line-440"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitList"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExplicitList"><span class="hs-identifier hs-var">ExplicitList</span></a></span></span><span>
</span><span id="line-441"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExplicitList"><span class="hs-identifier hs-type">XExplicitList</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- Gives type of components of list</span><span>
</span><span id="line-442"></span><span>                </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-443"></span><span>
</span><span id="line-444"></span><span>  </span><span class="hs-comment">-- | Record construction</span><span>
</span><span id="line-445"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-446"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-447"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnDotdot','GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-448"></span><span>
</span><span id="line-449"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-450"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecordCon"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecordCon"><span class="hs-identifier hs-var">RecordCon</span></a></span></span><span>
</span><span id="line-451"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="rcon_ext"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XRecordCon p
</span><a href="Language.Haskell.Syntax.Expr.html#rcon_ext"><span class="hs-identifier hs-var hs-var">rcon_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRecordCon"><span class="hs-identifier hs-type">XRecordCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-452"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="rcon_con"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Expr.html#rcon_con"><span class="hs-identifier hs-var hs-var">rcon_con</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-type">ConLikeP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- The constructor</span><span>
</span><span id="line-453"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="rcon_flds"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; HsRecordBinds p
</span><a href="Language.Haskell.Syntax.Expr.html#rcon_flds"><span class="hs-identifier hs-var hs-var">rcon_flds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsRecordBinds"><span class="hs-identifier hs-type">HsRecordBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">}</span><span>    </span><span class="hs-comment">-- The fields</span><span>
</span><span id="line-454"></span><span>
</span><span id="line-455"></span><span>  </span><span class="hs-comment">-- | Record update</span><span>
</span><span id="line-456"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-457"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-458"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnDotdot','GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-459"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnComma, 'GHC.Parser.Annotation.AnnDot',</span><span>
</span><span id="line-460"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-461"></span><span>
</span><span id="line-462"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-463"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecordUpd"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecordUpd"><span class="hs-identifier hs-var">RecordUpd</span></a></span></span><span>
</span><span id="line-464"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="rupd_ext"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XRecordUpd p
</span><a href="Language.Haskell.Syntax.Expr.html#rupd_ext"><span class="hs-identifier hs-var hs-var">rupd_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRecordUpd"><span class="hs-identifier hs-type">XRecordUpd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-465"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="rupd_expr"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; LHsExpr p
</span><a href="Language.Haskell.Syntax.Expr.html#rupd_expr"><span class="hs-identifier hs-var hs-var">rupd_expr</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-466"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="rupd_flds"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; Either [LHsRecUpdField p] [LHsRecUpdProj p]
</span><a href="Language.Haskell.Syntax.Expr.html#rupd_flds"><span class="hs-identifier hs-var hs-var">rupd_flds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Either.html#Either/Data.Either.html#Either"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecUpdField"><span class="hs-identifier hs-type">LHsRecUpdField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsRecUpdProj"><span class="hs-identifier hs-type">LHsRecUpdProj</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-467"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-468"></span><span>  </span><span class="hs-comment">-- For a type family, the arg types are of the *instance* tycon,</span><span>
</span><span id="line-469"></span><span>  </span><span class="hs-comment">-- not the family tycon</span><span>
</span><span id="line-470"></span><span>
</span><span id="line-471"></span><span>  </span><span class="hs-comment">-- | Record field selection e.g @z.x@.</span><span>
</span><span id="line-472"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-473"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDot'</span><span>
</span><span id="line-474"></span><span>
</span><span id="line-475"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-476"></span><span>
</span><span id="line-477"></span><span>  </span><span class="hs-comment">-- This case only arises when the OverloadedRecordDot langauge</span><span>
</span><span id="line-478"></span><span>  </span><span class="hs-comment">-- extension is enabled. See Note [Record selectors in the AST].</span><span>
</span><span id="line-479"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsGetField"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsGetField"><span class="hs-identifier hs-var">HsGetField</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-480"></span><span>        </span><span id="gf_ext"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XGetField p
</span><a href="Language.Haskell.Syntax.Expr.html#gf_ext"><span class="hs-identifier hs-var hs-var">gf_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XGetField"><span class="hs-identifier hs-type">XGetField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-481"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="gf_expr"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; LHsExpr p
</span><a href="Language.Haskell.Syntax.Expr.html#gf_expr"><span class="hs-identifier hs-var hs-var">gf_expr</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-482"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="gf_field"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XRec p (DotFieldOcc p)
</span><a href="Language.Haskell.Syntax.Expr.html#gf_field"><span class="hs-identifier hs-var hs-var">gf_field</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DotFieldOcc"><span class="hs-identifier hs-type">DotFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-483"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-484"></span><span>
</span><span id="line-485"></span><span>  </span><span class="hs-comment">-- | Record field selector. e.g. @(.x)@ or @(.x.y)@</span><span>
</span><span id="line-486"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-487"></span><span>  </span><span class="hs-comment">-- This case only arises when the OverloadedRecordDot langauge</span><span>
</span><span id="line-488"></span><span>  </span><span class="hs-comment">-- extensions is enabled. See Note [Record selectors in the AST].</span><span>
</span><span id="line-489"></span><span>
</span><span id="line-490"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpenP'</span><span>
</span><span id="line-491"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnDot', 'GHC.Parser.Annotation.AnnCloseP'</span><span>
</span><span id="line-492"></span><span>
</span><span id="line-493"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-494"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsProjection"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsProjection"><span class="hs-identifier hs-var">HsProjection</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-495"></span><span>        </span><span id="proj_ext"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XProjection p
</span><a href="Language.Haskell.Syntax.Expr.html#proj_ext"><span class="hs-identifier hs-var hs-var">proj_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XProjection"><span class="hs-identifier hs-type">XProjection</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-496"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="proj_flds"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; NonEmpty (XRec p (DotFieldOcc p))
</span><a href="Language.Haskell.Syntax.Expr.html#proj_flds"><span class="hs-identifier hs-var hs-var">proj_flds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#NonEmpty/GHC.Base.html#NonEmpty"><span class="hs-identifier hs-type">NonEmpty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DotFieldOcc"><span class="hs-identifier hs-type">DotFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-497"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-498"></span><span>
</span><span id="line-499"></span><span>  </span><span class="hs-comment">-- | Expression with an explicit type signature. @e :: type@</span><span>
</span><span id="line-500"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-501"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span><span>
</span><span id="line-502"></span><span>
</span><span id="line-503"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-504"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExprWithTySig"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprWithTySig"><span class="hs-identifier hs-var">ExprWithTySig</span></a></span></span><span>
</span><span id="line-505"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExprWithTySig"><span class="hs-identifier hs-type">XExprWithTySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-506"></span><span>
</span><span id="line-507"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-508"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigWcType"><span class="hs-identifier hs-type">LHsSigWcType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoGhcTc"><span class="hs-identifier hs-type">NoGhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-509"></span><span>
</span><span id="line-510"></span><span>  </span><span class="hs-comment">-- | Arithmetic sequence</span><span>
</span><span id="line-511"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-512"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'['@,</span><span>
</span><span id="line-513"></span><span>  </span><span class="hs-comment">--              'GHC.Parser.Annotation.AnnComma','GHC.Parser.Annotation.AnnDotdot',</span><span>
</span><span id="line-514"></span><span>  </span><span class="hs-comment">--              'GHC.Parser.Annotation.AnnClose' @']'@</span><span>
</span><span id="line-515"></span><span>
</span><span id="line-516"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-517"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArithSeq"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArithSeq"><span class="hs-identifier hs-var">ArithSeq</span></a></span></span><span>
</span><span id="line-518"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XArithSeq"><span class="hs-identifier hs-type">XArithSeq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-519"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-520"></span><span>                                  </span><span class="hs-comment">-- For OverloadedLists, the fromList witness</span><span>
</span><span id="line-521"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArithSeqInfo"><span class="hs-identifier hs-type">ArithSeqInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-522"></span><span>
</span><span id="line-523"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-524"></span><span>
</span><span id="line-525"></span><span>  </span><span class="hs-comment">-----------------------------------------------------------</span><span>
</span><span id="line-526"></span><span>  </span><span class="hs-comment">-- MetaHaskell Extensions</span><span>
</span><span id="line-527"></span><span>
</span><span id="line-528"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-529"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnOpenE','GHC.Parser.Annotation.AnnOpenEQ',</span><span>
</span><span id="line-530"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose','GHC.Parser.Annotation.AnnCloseQ'</span><span>
</span><span id="line-531"></span><span>
</span><span id="line-532"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-533"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsTypedBracket"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTypedBracket"><span class="hs-identifier hs-var">HsTypedBracket</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTypedBracket"><span class="hs-identifier hs-type">XTypedBracket</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-534"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsUntypedBracket"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedBracket"><span class="hs-identifier hs-var">HsUntypedBracket</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XUntypedBracket"><span class="hs-identifier hs-type">XUntypedBracket</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsQuote"><span class="hs-identifier hs-type">HsQuote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-535"></span><span>
</span><span id="line-536"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-537"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-538"></span><span>
</span><span id="line-539"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-540"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsTypedSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTypedSplice"><span class="hs-identifier hs-var">HsTypedSplice</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTypedSplice"><span class="hs-identifier hs-type">XTypedSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- `$$z` or `$$(f 4)`</span><span>
</span><span id="line-541"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsUntypedSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSplice"><span class="hs-identifier hs-var">HsUntypedSplice</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XUntypedSplice"><span class="hs-identifier hs-type">XUntypedSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSplice"><span class="hs-identifier hs-type">HsUntypedSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-542"></span><span>
</span><span id="line-543"></span><span>  </span><span class="hs-comment">-----------------------------------------------------------</span><span>
</span><span id="line-544"></span><span>  </span><span class="hs-comment">-- Arrow notation extension</span><span>
</span><span id="line-545"></span><span>
</span><span id="line-546"></span><span>  </span><span class="hs-comment">-- | @proc@ notation for Arrows</span><span>
</span><span id="line-547"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-548"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnProc',</span><span>
</span><span id="line-549"></span><span>  </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnRarrow'</span><span>
</span><span id="line-550"></span><span>
</span><span id="line-551"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-552"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsProc"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsProc"><span class="hs-identifier hs-var">HsProc</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XProc"><span class="hs-identifier hs-type">XProc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-553"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>               </span><span class="hs-comment">-- arrow abstraction, proc</span><span>
</span><span id="line-554"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmdTop"><span class="hs-identifier hs-type">LHsCmdTop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>          </span><span class="hs-comment">-- body of the abstraction</span><span>
</span><span id="line-555"></span><span>                                       </span><span class="hs-comment">-- always has an empty stack</span><span>
</span><span id="line-556"></span><span>
</span><span id="line-557"></span><span>  </span><span class="hs-comment">---------------------------------------</span><span>
</span><span id="line-558"></span><span>  </span><span class="hs-comment">-- static pointers extension</span><span>
</span><span id="line-559"></span><span>  </span><span class="annot"><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnStatic',</span></span><span>
</span><span id="line-560"></span><span>
</span><span id="line-561"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-562"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsStatic"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStatic"><span class="hs-identifier hs-var">HsStatic</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XStatic"><span class="hs-identifier hs-type">XStatic</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Free variables of the body, and type after typechecking</span><span>
</span><span id="line-563"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- Body</span><span>
</span><span id="line-564"></span><span>
</span><span id="line-565"></span><span>  </span><span class="hs-comment">---------------------------------------</span><span>
</span><span id="line-566"></span><span>  </span><span class="hs-comment">-- Expressions annotated with pragmas, written as {-# ... #-}</span><span>
</span><span id="line-567"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsPragE"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsPragE"><span class="hs-identifier hs-var">HsPragE</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPragE"><span class="hs-identifier hs-type">XPragE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsPragE"><span class="hs-identifier hs-type">HsPragE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-568"></span><span>
</span><span id="line-569"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XExpr"><span class="hs-identifier hs-var">XExpr</span></a></span></span><span>       </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXExpr"><span class="hs-identifier hs-type">XXExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597776"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-570"></span><span>  </span><span class="hs-comment">-- Note [Trees That Grow] in Language.Haskell.Syntax.Extension for the</span><span>
</span><span id="line-571"></span><span>  </span><span class="hs-comment">-- general idea, and Note [Rebindable syntax and HsExpansion] in GHC.Hs.Expr</span><span>
</span><span id="line-572"></span><span>  </span><span class="hs-comment">-- for an example of how we use it.</span><span>
</span><span id="line-573"></span><span>
</span><span id="line-574"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-575"></span><span>
</span><span id="line-576"></span><span class="hs-keyword">data</span><span> </span><span id="DotFieldOcc"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DotFieldOcc"><span class="hs-identifier hs-var">DotFieldOcc</span></a></span></span><span> </span><span id="local-6989586621681597800"><span class="annot"><a href="#local-6989586621681597800"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-577"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DotFieldOcc"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DotFieldOcc"><span class="hs-identifier hs-var">DotFieldOcc</span></a></span></span><span>
</span><span id="line-578"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="dfoExt"><span class="annot"><span class="annottext">forall p. DotFieldOcc p -&gt; XCDotFieldOcc p
</span><a href="Language.Haskell.Syntax.Expr.html#dfoExt"><span class="hs-identifier hs-var hs-var">dfoExt</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCDotFieldOcc"><span class="hs-identifier hs-type">XCDotFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597800"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-579"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="dfoLabel"><span class="annot"><span class="annottext">forall p. DotFieldOcc p -&gt; XRec p FieldLabelString
</span><a href="Language.Haskell.Syntax.Expr.html#dfoLabel"><span class="hs-identifier hs-var hs-var">dfoLabel</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597800"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html#FieldLabelString"><span class="hs-identifier hs-type">FieldLabelString</span></a></span><span>
</span><span id="line-580"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-581"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XDotFieldOcc"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XDotFieldOcc"><span class="hs-identifier hs-var">XDotFieldOcc</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXDotFieldOcc"><span class="hs-identifier hs-type">XXDotFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597800"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-582"></span><span>
</span><span id="line-583"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-584"></span><span>
</span><span id="line-585"></span><span class="annot"><span class="hs-comment">-- | A pragma, written as {-# ... #-}, that may appear within an expression.</span></span><span>
</span><span id="line-586"></span><span class="hs-keyword">data</span><span> </span><span id="HsPragE"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsPragE"><span class="hs-identifier hs-var">HsPragE</span></a></span></span><span> </span><span id="local-6989586621681598189"><span class="annot"><a href="#local-6989586621681598189"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-587"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsPragSCC"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsPragSCC"><span class="hs-identifier hs-var">HsPragSCC</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSCC"><span class="hs-identifier hs-type">XSCC</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598189"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-588"></span><span>                </span><span class="annot"><a href="GHC.Types.SourceText.html#StringLiteral"><span class="hs-identifier hs-type">StringLiteral</span></a></span><span>         </span><span class="hs-comment">-- &quot;set cost centre&quot; SCC pragma</span><span>
</span><span id="line-589"></span><span>
</span><span id="line-590"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-591"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen' @'{-\# GENERATED'@,</span><span>
</span><span id="line-592"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnVal','GHC.Parser.Annotation.AnnVal',</span><span>
</span><span id="line-593"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnColon','GHC.Parser.Annotation.AnnVal',</span><span>
</span><span id="line-594"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnMinus',</span><span>
</span><span id="line-595"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnVal','GHC.Parser.Annotation.AnnColon',</span><span>
</span><span id="line-596"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnVal',</span><span>
</span><span id="line-597"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'\#-}'@</span><span>
</span><span id="line-598"></span><span>
</span><span id="line-599"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsPragE"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XHsPragE"><span class="hs-identifier hs-var">XHsPragE</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPragE"><span class="hs-identifier hs-type">XXPragE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598189"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-600"></span><span>
</span><span id="line-601"></span><span class="hs-comment">-- | Located Haskell Tuple Argument</span><span>
</span><span id="line-602"></span><span class="hs-comment">--</span><span>
</span><span id="line-603"></span><span class="hs-comment">-- 'HsTupArg' is used for tuple sections</span><span>
</span><span id="line-604"></span><span class="hs-comment">-- @(,a,)@ is represented by</span><span>
</span><span id="line-605"></span><span class="hs-comment">-- @ExplicitTuple [Missing ty1, Present a, Missing ty3]@</span><span>
</span><span id="line-606"></span><span class="hs-comment">-- Which in turn stands for @(\x:ty1 \y:ty2. (x,a,y))@</span><span>
</span><span id="line-607"></span><span class="hs-keyword">type</span><span> </span><span id="LHsTupArg"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsTupArg"><span class="hs-identifier hs-var">LHsTupArg</span></a></span></span><span> </span><span id="local-6989586621681598195"><span class="annot"><a href="#local-6989586621681598195"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598195"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTupArg"><span class="hs-identifier hs-type">HsTupArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598195"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-608"></span><span class="annot"><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma'</span></span><span>
</span><span id="line-609"></span><span>
</span><span id="line-610"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-611"></span><span>
</span><span id="line-612"></span><span class="annot"><span class="hs-comment">-- | Haskell Tuple Argument</span></span><span>
</span><span id="line-613"></span><span class="hs-keyword">data</span><span> </span><span id="HsTupArg"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTupArg"><span class="hs-identifier hs-var">HsTupArg</span></a></span></span><span> </span><span id="local-6989586621681598196"><span class="annot"><a href="#local-6989586621681598196"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-614"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Present"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Present"><span class="hs-identifier hs-var">Present</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPresent"><span class="hs-identifier hs-type">XPresent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598196"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598196"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="annot"><span class="hs-comment">-- ^ The argument</span></span><span>
</span><span id="line-615"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Missing"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Missing"><span class="hs-identifier hs-var">Missing</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XMissing"><span class="hs-identifier hs-type">XMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598196"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>    </span><span class="annot"><span class="hs-comment">-- ^ The argument is missing, but this is its type</span></span><span>
</span><span id="line-616"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XTupArg"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XTupArg"><span class="hs-identifier hs-var">XTupArg</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXTupArg"><span class="hs-identifier hs-type">XXTupArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598196"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- ^ Extension point; see Note [Trees That Grow]</span><span>
</span><span id="line-617"></span><span>                             </span><span class="hs-comment">-- in Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-618"></span><span>
</span><span id="line-619"></span><span class="annot"><span class="hs-comment">-- | Which kind of lambda case are we dealing with?</span></span><span>
</span><span id="line-620"></span><span class="hs-keyword">data</span><span> </span><span id="LamCaseVariant"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LamCaseVariant"><span class="hs-identifier hs-var">LamCaseVariant</span></a></span></span><span>
</span><span id="line-621"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="LamCase"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LamCase"><span class="hs-identifier hs-var">LamCase</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ `\case`</span></span><span>
</span><span id="line-622"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LamCases"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LamCases"><span class="hs-identifier hs-var">LamCases</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ `\cases`</span></span><span>
</span><span id="line-623"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621681598208"><span id="local-6989586621681598210"><span id="local-6989586621681598212"><span id="local-6989586621681598214"><span id="local-6989586621681598216"><span id="local-6989586621681598222"><span id="local-6989586621681598227"><span id="local-6989586621681598230"><span id="local-6989586621681598233"><span id="local-6989586621681598236"><span id="local-6989586621681598239"><span id="local-6989586621681598242"><span id="local-6989586621681598247"><span id="local-6989586621681598252"><span class="annot"><span class="annottext">Typeable LamCaseVariant
Typeable LamCaseVariant =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; LamCaseVariant -&gt; c LamCaseVariant)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c LamCaseVariant)
-&gt; (LamCaseVariant -&gt; Constr)
-&gt; (LamCaseVariant -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c LamCaseVariant))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c LamCaseVariant))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; LamCaseVariant -&gt; LamCaseVariant)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; LamCaseVariant -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; LamCaseVariant -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; LamCaseVariant -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; LamCaseVariant -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; LamCaseVariant -&gt; m LamCaseVariant)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; LamCaseVariant -&gt; m LamCaseVariant)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; LamCaseVariant -&gt; m LamCaseVariant)
-&gt; Data LamCaseVariant
LamCaseVariant -&gt; Constr
LamCaseVariant -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; LamCaseVariant -&gt; LamCaseVariant
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; LamCaseVariant -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; LamCaseVariant -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; LamCaseVariant -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; LamCaseVariant -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; LamCaseVariant -&gt; m LamCaseVariant
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; LamCaseVariant -&gt; m LamCaseVariant
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c LamCaseVariant
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; LamCaseVariant -&gt; c LamCaseVariant
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c LamCaseVariant)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c LamCaseVariant)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; LamCaseVariant -&gt; c LamCaseVariant
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; LamCaseVariant -&gt; c LamCaseVariant
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c LamCaseVariant
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c LamCaseVariant
$ctoConstr :: LamCaseVariant -&gt; Constr
toConstr :: LamCaseVariant -&gt; Constr
$cdataTypeOf :: LamCaseVariant -&gt; DataType
dataTypeOf :: LamCaseVariant -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c LamCaseVariant)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c LamCaseVariant)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c LamCaseVariant)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c LamCaseVariant)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; LamCaseVariant -&gt; LamCaseVariant
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; LamCaseVariant -&gt; LamCaseVariant
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; LamCaseVariant -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; LamCaseVariant -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; LamCaseVariant -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; LamCaseVariant -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; LamCaseVariant -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; LamCaseVariant -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; LamCaseVariant -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; LamCaseVariant -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; LamCaseVariant -&gt; m LamCaseVariant
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; LamCaseVariant -&gt; m LamCaseVariant
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; LamCaseVariant -&gt; m LamCaseVariant
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; LamCaseVariant -&gt; m LamCaseVariant
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; LamCaseVariant -&gt; m LamCaseVariant
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; LamCaseVariant -&gt; m LamCaseVariant
</span><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681598258"><span id="local-6989586621681598260"><span class="annot"><span class="annottext">LamCaseVariant -&gt; LamCaseVariant -&gt; Bool
(LamCaseVariant -&gt; LamCaseVariant -&gt; Bool)
-&gt; (LamCaseVariant -&gt; LamCaseVariant -&gt; Bool) -&gt; Eq LamCaseVariant
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: LamCaseVariant -&gt; LamCaseVariant -&gt; Bool
== :: LamCaseVariant -&gt; LamCaseVariant -&gt; Bool
$c/= :: LamCaseVariant -&gt; LamCaseVariant -&gt; Bool
/= :: LamCaseVariant -&gt; LamCaseVariant -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-624"></span><span>
</span><span id="line-625"></span><span class="hs-comment">{-
Note [Parens in HsSyn]
~~~~~~~~~~~~~~~~~~~~~~
HsPar (and ParPat in patterns, HsParTy in types) is used as follows

  * HsPar is required; the pretty printer does not add parens.

  * HsPars are respected when rearranging operator fixities.
    So   a * (b + c)  means what it says (where the parens are an HsPar)

  * For ParPat and HsParTy the pretty printer does add parens but this should be
    a no-op for ParsedSource, based on the pretty printer round trip feature
    introduced in
    https://phabricator.haskell.org/rGHC499e43824bda967546ebf95ee33ec1f84a114a7c

  * ParPat and HsParTy are pretty printed as '( .. )' regardless of whether or
    not they are strictly necessary. This should be addressed when #13238 is
    completed, to be treated the same as HsPar.


Note [Sections in HsSyn]
~~~~~~~~~~~~~~~~~~~~~~~~
Sections should always appear wrapped in an HsPar, thus
         HsPar (SectionR ...)
The parser parses sections in a wider variety of situations
(See Note [Parsing sections]), but the renamer checks for those
parens.  This invariant makes pretty-printing easier; we don't need
a special case for adding the parens round sections.

Note [Rebindable if]
~~~~~~~~~~~~~~~~~~~~
The rebindable syntax for 'if' is a bit special, because when
rebindable syntax is *off* we do not want to treat
   (if c then t else e)
as if it was an application (ifThenElse c t e).  Why not?
Because we allow an 'if' to return *unboxed* results, thus
  if blah then 3# else 4#
whereas that would not be possible using a all to a polymorphic function
(because you can't call a polymorphic function at an unboxed type).

So we use NoSyntaxExpr to mean &quot;use the old built-in typing rule&quot;.

A further complication is that, in the `deriving` code, we never want
to use rebindable syntax. So, even in GhcPs, we want to denote whether
to use rebindable syntax or not. This is done via the type instance
for XIf GhcPs.

Note [Record Update HsWrapper]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
There is a wrapper in RecordUpd which is used for the *required*
constraints for pattern synonyms. This wrapper is created in the
typechecking and is then directly used in the desugaring without
modification.

For example, if we have the record pattern synonym P,
  pattern P :: (Show a) =&gt; a -&gt; Maybe a
  pattern P{x} = Just x

  foo = (Just True) { x = False }
then `foo` desugars to something like
  foo = case Just True of
          P x -&gt; P False
hence we need to provide the correct dictionaries to P's matcher on
the RHS so that we can build the expression.

Note [Located RdrNames]
~~~~~~~~~~~~~~~~~~~~~~~
A number of syntax elements have seemingly redundant locations
attached to them.  This is deliberate, to allow transformations making
use of the exact print annotations to easily correlate a Located Name
in the RenamedSource with a Located RdrName in the ParsedSource.

There are unfortunately enough differences between the ParsedSource
and the RenamedSource that the exact print annotations cannot be used
directly with RenamedSource, so this allows a simple mapping to be
used based on the location.

Note [ExplicitTuple]
~~~~~~~~~~~~~~~~~~~~
An ExplicitTuple is never just a data constructor like (,,,).
That is, the `[LHsTupArg p]` argument of `ExplicitTuple` has at least
one `Present` member (and is thus never empty).

A tuple data constructor like () or (,,,) is parsed as an `HsVar`, not an
`ExplicitTuple`, and stays that way. This is important for two reasons:

  1. We don't need -XTupleSections for (,,,)
  2. The type variables in (,,,) can be instantiated with visible type application.
     That is,

       (,,)     :: forall a b c. a -&gt; b -&gt; c -&gt; (a,b,c)
       (True,,) :: forall {b} {c}. b -&gt; c -&gt; (Bool,b,c)

     Note that the tuple section has *inferred* arguments, while the data
     constructor has *specified* ones.
     (See Note [Required, Specified, and Inferred for types] in GHC.Tc.TyCl
     for background.)

Sadly, the grammar for this is actually ambiguous, and it's only thanks to the
preference of a shift in a shift/reduce conflict that the parser works as this
Note details. Search for a reference to this Note in GHC.Parser for further
explanation.

Note [Empty lists]
~~~~~~~~~~~~~~~~~~
An empty list could be considered either a data constructor (stored with
HsVar) or an ExplicitList. This Note describes how empty lists flow through the
various phases and why.

Parsing
-------
An empty list is parsed by the sysdcon nonterminal. It thus comes to life via
HsVar nilDataCon (defined in GHC.Builtin.Types). A freshly-parsed (HsExpr GhcPs) empty list
is never a ExplicitList.

Renaming
--------
If -XOverloadedLists is enabled, we must type-check the empty list as if it
were a call to fromListN. (This is true regardless of the setting of
-XRebindableSyntax.) This is very easy if the empty list is an ExplicitList,
but an annoying special case if it's an HsVar. So the renamer changes a
HsVar nilDataCon to an ExplicitList [], but only if -XOverloadedLists is on.
(Why not always? Read on, dear friend.) This happens in the HsVar case of rnExpr.

Type-checking
-------------
We want to accept an expression like [] @Int. To do this, we must infer that
[] :: forall a. [a]. This is easy if [] is a HsVar with the right DataCon inside.
However, the type-checking for explicit lists works differently: [x,y,z] is never
polymorphic. Instead, we unify the types of x, y, and z together, and use the
unified type as the argument to the cons and nil constructors. Thus, treating
[] as an empty ExplicitList in the type-checker would prevent [] @Int from working.

However, if -XOverloadedLists is on, then [] @Int really shouldn't be allowed:
it's just like fromListN 0 [] @Int. Since
  fromListN :: forall list. IsList list =&gt; Int -&gt; [Item list] -&gt; list
that expression really should be rejected. Thus, the renamer's behaviour is
exactly what we want: treat [] as a datacon when -XNoOverloadedLists, and as
an empty ExplicitList when -XOverloadedLists.

See also #13680, which requested [] @Int to work.
-}</span><span>
</span><span id="line-767"></span><span>
</span><span id="line-768"></span><span>
</span><span id="line-769"></span><span class="hs-comment">{-
HsSyn records exactly where the user put parens, with HsPar.
So generally speaking we print without adding any parens.
However, some code is internally generated, and in some places
parens are absolutely required; so for these places we use
pprParendLExpr (but don't print double parens of course).

For operator applications we don't add parens, because the operator
fixities should do the job, except in debug mode (-dppr-debug) so we
can see the structure of the parse tree.
-}</span><span>
</span><span id="line-780"></span><span>
</span><span id="line-781"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Commands (in arrow abstractions)}
*                                                                      *
************************************************************************

We re-use HsExpr to represent these.
-}</span><span>
</span><span id="line-790"></span><span>
</span><span id="line-791"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Command (for arrow syntax)</span></span><span>
</span><span id="line-792"></span><span class="hs-keyword">type</span><span> </span><span id="LHsCmd"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-var">LHsCmd</span></a></span></span><span> </span><span id="local-6989586621681598265"><span class="annot"><a href="#local-6989586621681598265"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598265"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmd"><span class="hs-identifier hs-type">HsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598265"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-793"></span><span>
</span><span id="line-794"></span><span class="annot"><span class="hs-comment">-- | Haskell Command (e.g. a &quot;statement&quot; in an Arrow proc block)</span></span><span>
</span><span id="line-795"></span><span class="hs-keyword">data</span><span> </span><span id="HsCmd"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmd"><span class="hs-identifier hs-var">HsCmd</span></a></span></span><span> </span><span id="local-6989586621681598267"><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-796"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.Annlarrowtail',</span><span>
</span><span id="line-797"></span><span>  </span><span class="hs-comment">--          'GHC.Parser.Annotation.Annrarrowtail','GHC.Parser.Annotation.AnnLarrowtail',</span><span>
</span><span id="line-798"></span><span>  </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnRarrowtail'</span><span>
</span><span id="line-799"></span><span>
</span><span id="line-800"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-801"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsCmdArrApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdArrApp"><span class="hs-identifier hs-var">HsCmdArrApp</span></a></span></span><span>          </span><span class="hs-comment">-- Arrow tail, or arrow application (f -&lt; arg)</span><span>
</span><span id="line-802"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdArrApp"><span class="hs-identifier hs-type">XCmdArrApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- type of the arrow expressions f,</span><span>
</span><span id="line-803"></span><span>                         </span><span class="hs-comment">-- of the form a t t', where arg :: t</span><span>
</span><span id="line-804"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- arrow expression, f</span><span>
</span><span id="line-805"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- input expression, arg</span><span>
</span><span id="line-806"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsArrAppType"><span class="hs-identifier hs-type">HsArrAppType</span></a></span><span>     </span><span class="hs-comment">-- higher-order (-&lt;&lt;) or first-order (-&lt;)</span><span>
</span><span id="line-807"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>             </span><span class="hs-comment">-- True =&gt; right-to-left (f -&lt; arg)</span><span>
</span><span id="line-808"></span><span>                         </span><span class="hs-comment">-- False =&gt; left-to-right (arg &gt;- f)</span><span>
</span><span id="line-809"></span><span>
</span><span id="line-810"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpenB' @'(|'@,</span><span>
</span><span id="line-811"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnCloseB' @'|)'@</span><span>
</span><span id="line-812"></span><span>
</span><span id="line-813"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-814"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdArrForm"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdArrForm"><span class="hs-identifier hs-var">HsCmdArrForm</span></a></span></span><span>         </span><span class="hs-comment">-- Command formation,  (| e cmd1 .. cmdn |)</span><span>
</span><span id="line-815"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdArrForm"><span class="hs-identifier hs-type">XCmdArrForm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-816"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- The operator.</span><span>
</span><span id="line-817"></span><span>                         </span><span class="hs-comment">-- After type-checking, a type abstraction to be</span><span>
</span><span id="line-818"></span><span>                         </span><span class="hs-comment">-- applied to the type of the local environment tuple</span><span>
</span><span id="line-819"></span><span>        </span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier hs-type">LexicalFixity</span></a></span><span>    </span><span class="hs-comment">-- Whether the operator appeared prefix or infix when</span><span>
</span><span id="line-820"></span><span>                         </span><span class="hs-comment">-- parsed.</span><span>
</span><span id="line-821"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- fixity (filled in by the renamer), for forms that</span><span>
</span><span id="line-822"></span><span>                         </span><span class="hs-comment">-- were converted from OpApp's by the renamer</span><span>
</span><span id="line-823"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmdTop"><span class="hs-identifier hs-type">LHsCmdTop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">]</span><span>   </span><span class="hs-comment">-- argument commands</span><span>
</span><span id="line-824"></span><span>
</span><span id="line-825"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdApp"><span class="hs-identifier hs-var">HsCmdApp</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdApp"><span class="hs-identifier hs-type">XCmdApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-826"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-827"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-828"></span><span>
</span><span id="line-829"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdLam"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdLam"><span class="hs-identifier hs-var">HsCmdLam</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdLam"><span class="hs-identifier hs-type">XCmdLam</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-830"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- kappa</span><span>
</span><span id="line-831"></span><span>       </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span><span>
</span><span id="line-832"></span><span>       </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnRarrow',</span><span>
</span><span id="line-833"></span><span>
</span><span id="line-834"></span><span>       </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-835"></span><span>
</span><span id="line-836"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdPar"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdPar"><span class="hs-identifier hs-var">HsCmdPar</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdPar"><span class="hs-identifier hs-type">XCmdPar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-837"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;(&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-838"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>                     </span><span class="hs-comment">-- parenthesised command</span><span>
</span><span id="line-839"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;)&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-840"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span><span>
</span><span id="line-841"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnClose' @')'@</span><span>
</span><span id="line-842"></span><span>
</span><span id="line-843"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-844"></span><span>
</span><span id="line-845"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdCase"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdCase"><span class="hs-identifier hs-var">HsCmdCase</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdCase"><span class="hs-identifier hs-type">XCmdCase</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-846"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-847"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- bodies are HsCmd's</span><span>
</span><span id="line-848"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnCase',</span><span>
</span><span id="line-849"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOf','GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-850"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-851"></span><span>
</span><span id="line-852"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-853"></span><span>
</span><span id="line-854"></span><span>  </span><span class="hs-comment">-- | Lambda-case</span><span>
</span><span id="line-855"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-856"></span><span>  </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span><span>
</span><span id="line-857"></span><span>  </span><span class="hs-comment">--     'GHC.Parser.Annotation.AnnCase','GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-858"></span><span>  </span><span class="hs-comment">--     'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-859"></span><span>  </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span><span>
</span><span id="line-860"></span><span>  </span><span class="hs-comment">--     'GHC.Parser.Annotation.AnnCases','GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-861"></span><span>  </span><span class="hs-comment">--     'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-862"></span><span>
</span><span id="line-863"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-864"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdLamCase"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdLamCase"><span class="hs-identifier hs-var">HsCmdLamCase</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdLamCase"><span class="hs-identifier hs-type">XCmdLamCase</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LamCaseVariant"><span class="hs-identifier hs-type">LamCaseVariant</span></a></span><span>
</span><span id="line-865"></span><span>                 </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- bodies are HsCmd's</span><span>
</span><span id="line-866"></span><span>
</span><span id="line-867"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdIf"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdIf"><span class="hs-identifier hs-var">HsCmdIf</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdIf"><span class="hs-identifier hs-type">XCmdIf</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-868"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- cond function</span><span>
</span><span id="line-869"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>            </span><span class="hs-comment">-- predicate</span><span>
</span><span id="line-870"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- then part</span><span>
</span><span id="line-871"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- else part</span><span>
</span><span id="line-872"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnIf',</span><span>
</span><span id="line-873"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-874"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnThen','GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-875"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnElse',</span><span>
</span><span id="line-876"></span><span>
</span><span id="line-877"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-878"></span><span>
</span><span id="line-879"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdLet"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdLet"><span class="hs-identifier hs-var">HsCmdLet</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdLet"><span class="hs-identifier hs-type">XCmdLet</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-880"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;let&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-881"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBinds"><span class="hs-identifier hs-type">HsLocalBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- let(rec)</span><span>
</span><span id="line-882"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;in&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-883"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-884"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLet',</span><span>
</span><span id="line-885"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-886"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'}'@,'GHC.Parser.Annotation.AnnIn'</span><span>
</span><span id="line-887"></span><span>
</span><span id="line-888"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-889"></span><span>
</span><span id="line-890"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdDo"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdDo"><span class="hs-identifier hs-var">HsCmdDo</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdDo"><span class="hs-identifier hs-type">XCmdDo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>                     </span><span class="hs-comment">-- Type of the whole expression</span><span>
</span><span id="line-891"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#CmdLStmt"><span class="hs-identifier hs-type">CmdLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-892"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDo',</span><span>
</span><span id="line-893"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnOpen', 'GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-894"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnVbar',</span><span>
</span><span id="line-895"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-896"></span><span>
</span><span id="line-897"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-898"></span><span>
</span><span id="line-899"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XCmd"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XCmd"><span class="hs-identifier hs-var">XCmd</span></a></span></span><span>        </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXCmd"><span class="hs-identifier hs-type">XXCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598267"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- Extension point; see Note [Trees That Grow]</span><span>
</span><span id="line-900"></span><span>                                </span><span class="hs-comment">-- in Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-901"></span><span>
</span><span id="line-902"></span><span>
</span><span id="line-903"></span><span class="annot"><span class="hs-comment">-- | Haskell arrow application type.</span></span><span>
</span><span id="line-904"></span><span class="hs-keyword">data</span><span> </span><span id="HsArrAppType"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsArrAppType"><span class="hs-identifier hs-var">HsArrAppType</span></a></span></span><span>
</span><span id="line-905"></span><span>  </span><span class="annot"><span class="hs-comment">-- | First order arrow application '-&lt;'</span></span><span>
</span><span id="line-906"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsHigherOrderApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsHigherOrderApp"><span class="hs-identifier hs-var">HsHigherOrderApp</span></a></span></span><span>
</span><span id="line-907"></span><span>  </span><span class="annot"><span class="hs-comment">-- | Higher order arrow application '-&lt;&lt;'</span></span><span>
</span><span id="line-908"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsFirstOrderApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsFirstOrderApp"><span class="hs-identifier hs-var">HsFirstOrderApp</span></a></span></span><span>
</span><span id="line-909"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681598296"><span id="local-6989586621681598298"><span id="local-6989586621681598300"><span id="local-6989586621681598302"><span id="local-6989586621681598304"><span id="local-6989586621681598310"><span id="local-6989586621681598315"><span id="local-6989586621681598318"><span id="local-6989586621681598321"><span id="local-6989586621681598324"><span id="local-6989586621681598327"><span id="local-6989586621681598330"><span id="local-6989586621681598335"><span id="local-6989586621681598340"><span class="annot"><span class="annottext">Typeable HsArrAppType
Typeable HsArrAppType =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; HsArrAppType -&gt; c HsArrAppType)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsArrAppType)
-&gt; (HsArrAppType -&gt; Constr)
-&gt; (HsArrAppType -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsArrAppType))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c HsArrAppType))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; HsArrAppType -&gt; HsArrAppType)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType)
-&gt; Data HsArrAppType
HsArrAppType -&gt; Constr
HsArrAppType -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; HsArrAppType -&gt; HsArrAppType
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsArrAppType
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsArrAppType -&gt; c HsArrAppType
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsArrAppType)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c HsArrAppType)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsArrAppType -&gt; c HsArrAppType
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsArrAppType -&gt; c HsArrAppType
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsArrAppType
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsArrAppType
$ctoConstr :: HsArrAppType -&gt; Constr
toConstr :: HsArrAppType -&gt; Constr
$cdataTypeOf :: HsArrAppType -&gt; DataType
dataTypeOf :: HsArrAppType -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsArrAppType)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsArrAppType)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c HsArrAppType)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c HsArrAppType)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; HsArrAppType -&gt; HsArrAppType
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; HsArrAppType -&gt; HsArrAppType
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
</span><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-910"></span><span>
</span><span id="line-911"></span><span class="annot"><span class="hs-comment">{- | Top-level command, introducing a new arrow.
This may occur inside a proc (where the stack is empty) or as an
argument of a command-forming operator.
-}</span></span><span>
</span><span id="line-915"></span><span>
</span><span id="line-916"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Top-level Command</span></span><span>
</span><span id="line-917"></span><span class="hs-keyword">type</span><span> </span><span id="LHsCmdTop"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmdTop"><span class="hs-identifier hs-var">LHsCmdTop</span></a></span></span><span> </span><span id="local-6989586621681598344"><span class="annot"><a href="#local-6989586621681598344"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598344"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdTop"><span class="hs-identifier hs-type">HsCmdTop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598344"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-918"></span><span>
</span><span id="line-919"></span><span class="annot"><span class="hs-comment">-- | Haskell Top-level Command</span></span><span>
</span><span id="line-920"></span><span class="hs-keyword">data</span><span> </span><span id="HsCmdTop"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdTop"><span class="hs-identifier hs-var">HsCmdTop</span></a></span></span><span> </span><span id="local-6989586621681598346"><span class="annot"><a href="#local-6989586621681598346"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-921"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsCmdTop"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdTop"><span class="hs-identifier hs-var">HsCmdTop</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdTop"><span class="hs-identifier hs-type">XCmdTop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598346"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-922"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598346"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-923"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XCmdTop"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XCmdTop"><span class="hs-identifier hs-var">XCmdTop</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXCmdTop"><span class="hs-identifier hs-type">XXCmdTop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598346"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- Extension point; see Note [Trees That Grow]</span><span>
</span><span id="line-924"></span><span>                                 </span><span class="hs-comment">-- in Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-925"></span><span>
</span><span id="line-926"></span><span class="hs-comment">-----------------------</span><span>
</span><span id="line-927"></span><span>
</span><span id="line-928"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Record binds}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-935"></span><span>
</span><span id="line-936"></span><span class="annot"><span class="hs-comment">-- | Haskell Record Bindings</span></span><span>
</span><span id="line-937"></span><span class="hs-keyword">type</span><span> </span><span id="HsRecordBinds"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsRecordBinds"><span class="hs-identifier hs-var">HsRecordBinds</span></a></span></span><span> </span><span id="local-6989586621681598351"><span class="annot"><a href="#local-6989586621681598351"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598351"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598351"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-938"></span><span>
</span><span id="line-939"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{@Match@, @GRHSs@, and @GRHS@ datatypes}
*                                                                      *
************************************************************************

@Match@es are sets of pattern bindings and right hand sides for
functions, patterns or case branches. For example, if a function @g@
is defined as:
\begin{verbatim}
g (x,y) = y
g ((x:ys),y) = y+1,
\end{verbatim}
then \tr{g} has two @Match@es: @(x,y) = y@ and @((x:ys),y) = y+1@.

It is always the case that each element of an @[Match]@ list has the
same number of @pats@s inside it.  This corresponds to saying that
a function defined by pattern matching must have the same number of
patterns in each equation.
-}</span><span>
</span><span id="line-960"></span><span>
</span><span id="line-961"></span><span class="hs-keyword">data</span><span> </span><span id="MatchGroup"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-var">MatchGroup</span></a></span></span><span> </span><span id="local-6989586621681597850"><span class="annot"><a href="#local-6989586621681597850"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681597851"><span class="annot"><a href="#local-6989586621681597851"><span class="hs-identifier hs-type">body</span></a></span></span><span>
</span><span id="line-962"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="MG"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MG"><span class="hs-identifier hs-var">MG</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="mg_ext"><span class="annot"><span class="annottext">forall p body. MatchGroup p body -&gt; XMG p body
</span><a href="Language.Haskell.Syntax.Expr.html#mg_ext"><span class="hs-identifier hs-var hs-var">mg_ext</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XMG"><span class="hs-identifier hs-type">XMG</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597850"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597851"><span class="hs-identifier hs-type">body</span></a></span><span> </span><span class="hs-comment">-- Post-typechecker, types of args and result, and origin</span><span>
</span><span id="line-963"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="mg_alts"><span class="annot"><span class="annottext">forall p body. MatchGroup p body -&gt; XRec p [LMatch p body]
</span><a href="Language.Haskell.Syntax.Expr.html#mg_alts"><span class="hs-identifier hs-var hs-var">mg_alts</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597850"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-type">LMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597850"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597851"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-comment">-- The alternatives</span><span>
</span><span id="line-964"></span><span>     </span><span class="hs-comment">-- The type is the type of the entire group</span><span>
</span><span id="line-965"></span><span>     </span><span class="hs-comment">--      t1 -&gt; ... -&gt; tn -&gt; tr</span><span>
</span><span id="line-966"></span><span>     </span><span class="hs-comment">-- where there are n patterns</span><span>
</span><span id="line-967"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XMatchGroup"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XMatchGroup"><span class="hs-identifier hs-var">XMatchGroup</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXMatchGroup"><span class="hs-identifier hs-type">XXMatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597850"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597851"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-968"></span><span>
</span><span id="line-969"></span><span class="annot"><span class="hs-comment">-- | Located Match</span></span><span>
</span><span id="line-970"></span><span class="hs-keyword">type</span><span> </span><span id="LMatch"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-var">LMatch</span></a></span></span><span> </span><span id="local-6989586621681598358"><span class="annot"><a href="#local-6989586621681598358"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span id="local-6989586621681598359"><span class="annot"><a href="#local-6989586621681598359"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598358"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598358"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598359"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-971"></span><span class="hs-comment">-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when in a</span><span>
</span><span id="line-972"></span><span class="hs-comment">--   list</span><span>
</span><span id="line-973"></span><span>
</span><span id="line-974"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-975"></span><span class="hs-keyword">data</span><span> </span><span id="Match"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span id="local-6989586621681597859"><span class="annot"><a href="#local-6989586621681597859"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681597860"><span class="annot"><a href="#local-6989586621681597860"><span class="hs-identifier hs-type">body</span></a></span></span><span>
</span><span id="line-976"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Match"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-977"></span><span>        </span><span id="m_ext"><span class="annot"><span class="annottext">forall p body. Match p body -&gt; XCMatch p body
</span><a href="Language.Haskell.Syntax.Expr.html#m_ext"><span class="hs-identifier hs-var hs-var">m_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCMatch"><span class="hs-identifier hs-type">XCMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597859"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597860"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-978"></span><span>        </span><span id="m_ctxt"><span class="annot"><span class="annottext">forall p body. Match p body -&gt; HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#m_ctxt"><span class="hs-identifier hs-var hs-var">m_ctxt</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597859"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-979"></span><span>          </span><span class="hs-comment">-- See Note [m_ctxt in Match]</span><span>
</span><span id="line-980"></span><span>        </span><span id="m_pats"><span class="annot"><span class="annottext">forall p body. Match p body -&gt; [LPat p]
</span><a href="Language.Haskell.Syntax.Expr.html#m_pats"><span class="hs-identifier hs-var hs-var">m_pats</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597859"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- The patterns</span><span>
</span><span id="line-981"></span><span>        </span><span id="m_grhss"><span class="annot"><span class="annottext">forall p body. Match p body -&gt; GRHSs p body
</span><a href="Language.Haskell.Syntax.Expr.html#m_grhss"><span class="hs-identifier hs-var hs-var">m_grhss</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHSs"><span class="hs-identifier hs-type">GRHSs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597859"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597860"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-982"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-983"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XMatch"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XMatch"><span class="hs-identifier hs-var">XMatch</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXMatch"><span class="hs-identifier hs-type">XXMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597859"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597860"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-984"></span><span>
</span><span id="line-985"></span><span class="hs-comment">{-
Note [m_ctxt in Match]
~~~~~~~~~~~~~~~~~~~~~~

A Match can occur in a number of contexts, such as a FunBind, HsCase, HsLam and
so on.

In order to simplify tooling processing and pretty print output, the provenance
is captured in an HsMatchContext.

This is particularly important for the exact print annotations for a
multi-equation FunBind.

The parser initially creates a FunBind with a single Match in it for
every function definition it sees.

These are then grouped together by getMonoBind into a single FunBind,
where all the Matches are combined.

In the process, all the original FunBind fun_id's bar one are
discarded, including the locations.

This causes a problem for source to source conversions via exact print
annotations, so the original fun_ids and infix flags are preserved in
the Match, when it originates from a FunBind.

Example infix function definition requiring individual exact print
annotations

    (&amp;&amp;&amp;  ) [] [] =  []
    xs    &amp;&amp;&amp;   [] =  xs
    (  &amp;&amp;&amp;  ) [] ys =  ys



-}</span><span>
</span><span id="line-1021"></span><span>
</span><span id="line-1022"></span><span>
</span><span id="line-1023"></span><span id="local-6989586621681597874"><span id="local-6989586621681597875"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isInfixMatch"><span class="hs-identifier hs-type">isInfixMatch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597874"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597875"><span class="hs-identifier hs-type">body</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-1024"></span><span id="isInfixMatch"><span class="annot"><span class="annottext">isInfixMatch :: forall id body. Match id body -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isInfixMatch"><span class="hs-identifier hs-var hs-var">isInfixMatch</span></a></span></span><span> </span><span id="local-6989586621681598368"><span class="annot"><span class="annottext">Match id body
</span><a href="#local-6989586621681598368"><span class="hs-identifier hs-var">match</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Match id body -&gt; HsMatchContext id
forall p body. Match p body -&gt; HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#m_ctxt"><span class="hs-identifier hs-var">m_ctxt</span></a></span><span> </span><span class="annot"><span class="annottext">Match id body
</span><a href="#local-6989586621681598368"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1025"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FunRhs"><span class="hs-identifier hs-type">FunRhs</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">mc_fixity :: forall p. HsMatchContext p -&gt; LexicalFixity
</span><a href="Language.Haskell.Syntax.Expr.html#mc_fixity"><span class="hs-identifier hs-var">mc_fixity</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LexicalFixity
</span><a href="GHC.Types.Fixity.html#Infix"><span class="hs-identifier hs-var">Infix</span></a></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1026"></span><span>  </span><span class="annot"><span class="annottext">HsMatchContext id
</span><span class="hs-identifier">_</span></span><span>                          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1027"></span><span>
</span><span id="line-1028"></span><span class="hs-comment">-- | Guarded Right-Hand Sides</span><span>
</span><span id="line-1029"></span><span class="hs-comment">--</span><span>
</span><span id="line-1030"></span><span class="hs-comment">-- GRHSs are used both for pattern bindings and for Matches</span><span>
</span><span id="line-1031"></span><span class="hs-comment">--</span><span>
</span><span id="line-1032"></span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnVbar',</span><span>
</span><span id="line-1033"></span><span class="hs-comment">--        'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnWhere',</span><span>
</span><span id="line-1034"></span><span class="hs-comment">--        'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-1035"></span><span class="hs-comment">--        'GHC.Parser.Annotation.AnnRarrow','GHC.Parser.Annotation.AnnSemi'</span><span>
</span><span id="line-1036"></span><span>
</span><span id="line-1037"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1038"></span><span class="hs-keyword">data</span><span> </span><span id="GRHSs"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHSs"><span class="hs-identifier hs-var">GRHSs</span></a></span></span><span> </span><span id="local-6989586621681597880"><span class="annot"><a href="#local-6989586621681597880"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681597881"><span class="annot"><a href="#local-6989586621681597881"><span class="hs-identifier hs-type">body</span></a></span></span><span>
</span><span id="line-1039"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="GRHSs"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHSs"><span class="hs-identifier hs-var">GRHSs</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-1040"></span><span>      </span><span id="grhssExt"><span class="annot"><span class="annottext">forall p body. GRHSs p body -&gt; XCGRHSs p body
</span><a href="Language.Haskell.Syntax.Expr.html#grhssExt"><span class="hs-identifier hs-var hs-var">grhssExt</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCGRHSs"><span class="hs-identifier hs-type">XCGRHSs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597880"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597881"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1041"></span><span>      </span><span id="grhssGRHSs"><span class="annot"><span class="annottext">forall p body. GRHSs p body -&gt; [LGRHS p body]
</span><a href="Language.Haskell.Syntax.Expr.html#grhssGRHSs"><span class="hs-identifier hs-var hs-var">grhssGRHSs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LGRHS"><span class="hs-identifier hs-type">LGRHS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597880"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597881"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Guarded RHSs</span></span><span>
</span><span id="line-1042"></span><span>      </span><span id="grhssLocalBinds"><span class="annot"><span class="annottext">forall p body. GRHSs p body -&gt; HsLocalBinds p
</span><a href="Language.Haskell.Syntax.Expr.html#grhssLocalBinds"><span class="hs-identifier hs-var hs-var">grhssLocalBinds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBinds"><span class="hs-identifier hs-type">HsLocalBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597880"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ The where clause</span></span><span>
</span><span id="line-1043"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-1044"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XGRHSs"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XGRHSs"><span class="hs-identifier hs-var">XGRHSs</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXGRHSs"><span class="hs-identifier hs-type">XXGRHSs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597880"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597881"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1045"></span><span>
</span><span id="line-1046"></span><span class="annot"><span class="hs-comment">-- | Located Guarded Right-Hand Side</span></span><span>
</span><span id="line-1047"></span><span class="hs-keyword">type</span><span> </span><span id="LGRHS"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LGRHS"><span class="hs-identifier hs-var">LGRHS</span></a></span></span><span> </span><span id="local-6989586621681598377"><span class="annot"><a href="#local-6989586621681598377"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span id="local-6989586621681598378"><span class="annot"><a href="#local-6989586621681598378"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598377"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHS"><span class="hs-identifier hs-type">GRHS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598377"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598378"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1048"></span><span>
</span><span id="line-1049"></span><span class="annot"><span class="hs-comment">-- | Guarded Right Hand Side.</span></span><span>
</span><span id="line-1050"></span><span class="hs-keyword">data</span><span> </span><span id="GRHS"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHS"><span class="hs-identifier hs-var">GRHS</span></a></span></span><span> </span><span id="local-6989586621681598380"><span class="annot"><a href="#local-6989586621681598380"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681598381"><span class="annot"><a href="#local-6989586621681598381"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="GRHS"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHS"><span class="hs-identifier hs-var">GRHS</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCGRHS"><span class="hs-identifier hs-type">XCGRHS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598380"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598381"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1051"></span><span>                        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GuardLStmt"><span class="hs-identifier hs-type">GuardLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598380"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- Guards</span><span>
</span><span id="line-1052"></span><span>                        </span><span class="annot"><a href="#local-6989586621681598381"><span class="hs-identifier hs-type">body</span></a></span><span>           </span><span class="hs-comment">-- Right hand side</span><span>
</span><span id="line-1053"></span><span>                  </span><span class="hs-glyph">|</span><span> </span><span id="XGRHS"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XGRHS"><span class="hs-identifier hs-var">XGRHS</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXGRHS"><span class="hs-identifier hs-type">XXGRHS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598380"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598381"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1054"></span><span>
</span><span id="line-1055"></span><span class="hs-comment">-- We know the list must have at least one @Match@ in it.</span><span>
</span><span id="line-1056"></span><span>
</span><span id="line-1057"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Do stmts and list comprehensions}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1064"></span><span>
</span><span id="line-1065"></span><span class="annot"><span class="hs-comment">-- | Located @do@ block Statement</span></span><span>
</span><span id="line-1066"></span><span class="hs-keyword">type</span><span> </span><span id="LStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmt"><span class="hs-identifier hs-var">LStmt</span></a></span></span><span> </span><span id="local-6989586621681598388"><span class="annot"><a href="#local-6989586621681598388"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span id="local-6989586621681598389"><span class="annot"><a href="#local-6989586621681598389"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598388"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtLR"><span class="hs-identifier hs-type">StmtLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598388"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598388"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598389"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1067"></span><span>
</span><span id="line-1068"></span><span class="annot"><span class="hs-comment">-- | Located Statement with separate Left and Right id's</span></span><span>
</span><span id="line-1069"></span><span class="hs-keyword">type</span><span> </span><span id="LStmtLR"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmtLR"><span class="hs-identifier hs-var">LStmtLR</span></a></span></span><span> </span><span id="local-6989586621681598390"><span class="annot"><a href="#local-6989586621681598390"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681598391"><span class="annot"><a href="#local-6989586621681598391"><span class="hs-identifier hs-type">idR</span></a></span></span><span> </span><span id="local-6989586621681598392"><span class="annot"><a href="#local-6989586621681598392"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598390"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtLR"><span class="hs-identifier hs-type">StmtLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598390"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598391"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598392"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1070"></span><span>
</span><span id="line-1071"></span><span class="annot"><span class="hs-comment">-- | @do@ block Statement</span></span><span>
</span><span id="line-1072"></span><span class="hs-keyword">type</span><span> </span><span id="Stmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Stmt"><span class="hs-identifier hs-var">Stmt</span></a></span></span><span> </span><span id="local-6989586621681598394"><span class="annot"><a href="#local-6989586621681598394"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span id="local-6989586621681598395"><span class="annot"><a href="#local-6989586621681598395"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtLR"><span class="hs-identifier hs-type">StmtLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598394"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598394"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598395"><span class="hs-identifier hs-type">body</span></a></span><span>
</span><span id="line-1073"></span><span>
</span><span id="line-1074"></span><span class="annot"><span class="hs-comment">-- | Command Located Statement</span></span><span>
</span><span id="line-1075"></span><span class="hs-keyword">type</span><span> </span><span id="CmdLStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#CmdLStmt"><span class="hs-identifier hs-var">CmdLStmt</span></a></span></span><span>   </span><span id="local-6989586621681598396"><span class="annot"><a href="#local-6989586621681598396"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmt"><span class="hs-identifier hs-type">LStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598396"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681598396"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1076"></span><span>
</span><span id="line-1077"></span><span class="annot"><span class="hs-comment">-- | Command Statement</span></span><span>
</span><span id="line-1078"></span><span class="hs-keyword">type</span><span> </span><span id="CmdStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#CmdStmt"><span class="hs-identifier hs-var">CmdStmt</span></a></span></span><span>    </span><span id="local-6989586621681598398"><span class="annot"><a href="#local-6989586621681598398"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681598398"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681598398"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1079"></span><span>
</span><span id="line-1080"></span><span class="annot"><span class="hs-comment">-- | Expression Located Statement</span></span><span>
</span><span id="line-1081"></span><span class="hs-keyword">type</span><span> </span><span id="ExprLStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprLStmt"><span class="hs-identifier hs-var">ExprLStmt</span></a></span></span><span>  </span><span id="local-6989586621681598399"><span class="annot"><a href="#local-6989586621681598399"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmt"><span class="hs-identifier hs-type">LStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598399"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598399"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1082"></span><span>
</span><span id="line-1083"></span><span class="annot"><span class="hs-comment">-- | Expression Statement</span></span><span>
</span><span id="line-1084"></span><span class="hs-keyword">type</span><span> </span><span id="ExprStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprStmt"><span class="hs-identifier hs-var">ExprStmt</span></a></span></span><span>   </span><span id="local-6989586621681598401"><span class="annot"><a href="#local-6989586621681598401"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681598401"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598401"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1085"></span><span>
</span><span id="line-1086"></span><span class="annot"><span class="hs-comment">-- | Guard Located Statement</span></span><span>
</span><span id="line-1087"></span><span class="hs-keyword">type</span><span> </span><span id="GuardLStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GuardLStmt"><span class="hs-identifier hs-var">GuardLStmt</span></a></span></span><span> </span><span id="local-6989586621681598402"><span class="annot"><a href="#local-6989586621681598402"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmt"><span class="hs-identifier hs-type">LStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598402"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598402"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1088"></span><span>
</span><span id="line-1089"></span><span class="annot"><span class="hs-comment">-- | Guard Statement</span></span><span>
</span><span id="line-1090"></span><span class="hs-keyword">type</span><span> </span><span id="GuardStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GuardStmt"><span class="hs-identifier hs-var">GuardStmt</span></a></span></span><span>  </span><span id="local-6989586621681598404"><span class="annot"><a href="#local-6989586621681598404"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681598404"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598404"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1091"></span><span>
</span><span id="line-1092"></span><span class="annot"><span class="hs-comment">-- | Ghci Located Statement</span></span><span>
</span><span id="line-1093"></span><span class="hs-keyword">type</span><span> </span><span id="GhciLStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GhciLStmt"><span class="hs-identifier hs-var">GhciLStmt</span></a></span></span><span>  </span><span id="local-6989586621681598406"><span class="annot"><a href="#local-6989586621681598406"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmt"><span class="hs-identifier hs-type">LStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598406"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598406"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1094"></span><span>
</span><span id="line-1095"></span><span class="annot"><span class="hs-comment">-- | Ghci Statement</span></span><span>
</span><span id="line-1096"></span><span class="hs-keyword">type</span><span> </span><span id="GhciStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GhciStmt"><span class="hs-identifier hs-var">GhciStmt</span></a></span></span><span>   </span><span id="local-6989586621681598408"><span class="annot"><a href="#local-6989586621681598408"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681598408"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598408"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1097"></span><span>
</span><span id="line-1098"></span><span class="hs-comment">-- The SyntaxExprs in here are used *only* for do-notation and monad</span><span>
</span><span id="line-1099"></span><span class="hs-comment">-- comprehensions, which have rebindable syntax. Otherwise they are unused.</span><span>
</span><span id="line-1100"></span><span class="hs-comment">-- | Exact print annotations when in qualifier lists or guards</span><span>
</span><span id="line-1101"></span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnVbar',</span><span>
</span><span id="line-1102"></span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnComma','GHC.Parser.Annotation.AnnThen',</span><span>
</span><span id="line-1103"></span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnBy','GHC.Parser.Annotation.AnnBy',</span><span>
</span><span id="line-1104"></span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnGroup','GHC.Parser.Annotation.AnnUsing'</span><span>
</span><span id="line-1105"></span><span>
</span><span id="line-1106"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1107"></span><span class="hs-keyword">data</span><span> </span><span id="StmtLR"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtLR"><span class="hs-identifier hs-var">StmtLR</span></a></span></span><span> </span><span id="local-6989586621681597891"><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681597892"><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span></span><span> </span><span id="local-6989586621681597893"><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-comment">-- body should always be (LHs**** idR)</span><span>
</span><span id="line-1108"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="LastStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LastStmt"><span class="hs-identifier hs-var">LastStmt</span></a></span></span><span>  </span><span class="hs-comment">-- Always the last Stmt in ListComp, MonadComp,</span><span>
</span><span id="line-1109"></span><span>              </span><span class="hs-comment">-- and (after the renamer, see GHC.Rename.Expr.checkLastStmt) DoExpr, MDoExpr</span><span>
</span><span id="line-1110"></span><span>              </span><span class="hs-comment">-- Not used for GhciStmtCtxt, PatGuard, which scope over other stuff</span><span>
</span><span id="line-1111"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLastStmt"><span class="hs-identifier hs-type">XLastStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1112"></span><span>          </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span>
</span><span id="line-1113"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- Whether return was stripped</span><span>
</span><span id="line-1114"></span><span>            </span><span class="hs-comment">-- Just True &lt;=&gt; return with a dollar was stripped by ApplicativeDo</span><span>
</span><span id="line-1115"></span><span>            </span><span class="hs-comment">-- Just False &lt;=&gt; return without a dollar was stripped by ApplicativeDo</span><span>
</span><span id="line-1116"></span><span>            </span><span class="hs-comment">-- Nothing &lt;=&gt; Nothing was stripped</span><span>
</span><span id="line-1117"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- The return operator</span><span>
</span><span id="line-1118"></span><span>            </span><span class="hs-comment">-- The return operator is used only for MonadComp</span><span>
</span><span id="line-1119"></span><span>            </span><span class="hs-comment">-- For ListComp we use the baked-in 'return'</span><span>
</span><span id="line-1120"></span><span>            </span><span class="hs-comment">-- For DoExpr, MDoExpr, we don't apply a 'return' at all</span><span>
</span><span id="line-1121"></span><span>            </span><span class="hs-comment">-- See Note [Monad Comprehensions]</span><span>
</span><span id="line-1122"></span><span>            </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLarrow'</span><span>
</span><span id="line-1123"></span><span>
</span><span id="line-1124"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1125"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BindStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#BindStmt"><span class="hs-identifier hs-var">BindStmt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBindStmt"><span class="hs-identifier hs-type">XBindStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1126"></span><span>             </span><span class="hs-comment">-- ^ Post renaming has optional fail and bind / (&gt;&gt;=) operator.</span><span>
</span><span id="line-1127"></span><span>             </span><span class="hs-comment">-- Post typechecking, also has multiplicity of the argument</span><span>
</span><span id="line-1128"></span><span>             </span><span class="hs-comment">-- and the result type of the function passed to bind;</span><span>
</span><span id="line-1129"></span><span>             </span><span class="hs-comment">-- that is, (P, S) in (&gt;&gt;=) :: Q -&gt; (R % P -&gt; S) -&gt; T</span><span>
</span><span id="line-1130"></span><span>             </span><span class="hs-comment">-- See Note [The type of bind in Stmts]</span><span>
</span><span id="line-1131"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1132"></span><span>             </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span>
</span><span id="line-1133"></span><span>
</span><span id="line-1134"></span><span>  </span><span class="hs-comment">-- | 'ApplicativeStmt' represents an applicative expression built with</span><span>
</span><span id="line-1135"></span><span>  </span><span class="hs-comment">-- '&lt;$&gt;' and '&lt;*&gt;'.  It is generated by the renamer, and is desugared into the</span><span>
</span><span id="line-1136"></span><span>  </span><span class="hs-comment">-- appropriate applicative expression by the desugarer, but it is intended</span><span>
</span><span id="line-1137"></span><span>  </span><span class="hs-comment">-- to be invisible in error messages.</span><span>
</span><span id="line-1138"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1139"></span><span>  </span><span class="hs-comment">-- For full details, see Note [ApplicativeDo] in &quot;GHC.Rename.Expr&quot;</span><span>
</span><span id="line-1140"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1141"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ApplicativeStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeStmt"><span class="hs-identifier hs-var">ApplicativeStmt</span></a></span></span><span>
</span><span id="line-1142"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XApplicativeStmt"><span class="hs-identifier hs-type">XApplicativeStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Post typecheck, Type of the body</span><span>
</span><span id="line-1143"></span><span>             </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span>
</span><span id="line-1144"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeArg"><span class="hs-identifier hs-type">ApplicativeArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1145"></span><span>                      </span><span class="hs-comment">-- [(&lt;$&gt;, e1), (&lt;*&gt;, e2), ..., (&lt;*&gt;, en)]</span><span>
</span><span id="line-1146"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- 'join', if necessary</span><span>
</span><span id="line-1147"></span><span>
</span><span id="line-1148"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BodyStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#BodyStmt"><span class="hs-identifier hs-var">BodyStmt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBodyStmt"><span class="hs-identifier hs-type">XBodyStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Post typecheck, element type</span><span>
</span><span id="line-1149"></span><span>                                      </span><span class="hs-comment">-- of the RHS (used for arrows)</span><span>
</span><span id="line-1150"></span><span>             </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span>              </span><span class="hs-comment">-- See Note [BodyStmt]</span><span>
</span><span id="line-1151"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- The (&gt;&gt;) operator</span><span>
</span><span id="line-1152"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- The `guard` operator; used only in MonadComp</span><span>
</span><span id="line-1153"></span><span>                               </span><span class="hs-comment">-- See notes [Monad Comprehensions]</span><span>
</span><span id="line-1154"></span><span>
</span><span id="line-1155"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLet'</span><span>
</span><span id="line-1156"></span><span>  </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnOpen' @'{'@,'GHC.Parser.Annotation.AnnClose' @'}'@,</span><span>
</span><span id="line-1157"></span><span>
</span><span id="line-1158"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1159"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LetStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LetStmt"><span class="hs-identifier hs-var">LetStmt</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLetStmt"><span class="hs-identifier hs-type">XLetStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBindsLR"><span class="hs-identifier hs-type">HsLocalBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1160"></span><span>
</span><span id="line-1161"></span><span>  </span><span class="hs-comment">-- ParStmts only occur in a list/monad comprehension</span><span>
</span><span id="line-1162"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ParStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmt"><span class="hs-identifier hs-var">ParStmt</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParStmt"><span class="hs-identifier hs-type">XParStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- Post typecheck,</span><span>
</span><span id="line-1163"></span><span>                                        </span><span class="hs-comment">-- S in (&gt;&gt;=) :: Q -&gt; (R -&gt; S) -&gt; T</span><span>
</span><span id="line-1164"></span><span>             </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtBlock"><span class="hs-identifier hs-type">ParStmtBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1165"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>               </span><span class="hs-comment">-- Polymorphic `mzip` for monad comprehensions</span><span>
</span><span id="line-1166"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- The `&gt;&gt;=` operator</span><span>
</span><span id="line-1167"></span><span>                                        </span><span class="hs-comment">-- See notes [Monad Comprehensions]</span><span>
</span><span id="line-1168"></span><span>            </span><span class="hs-comment">-- After renaming, the ids are the binders</span><span>
</span><span id="line-1169"></span><span>            </span><span class="hs-comment">-- bound by the stmts and used after them</span><span>
</span><span id="line-1170"></span><span>
</span><span id="line-1171"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TransStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransStmt"><span class="hs-identifier hs-var">TransStmt</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-1172"></span><span>      </span><span id="trS_ext"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; XTransStmt idL idR body
</span><a href="Language.Haskell.Syntax.Expr.html#trS_ext"><span class="hs-identifier hs-var hs-var">trS_ext</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTransStmt"><span class="hs-identifier hs-type">XTransStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- Post typecheck,</span><span>
</span><span id="line-1173"></span><span>                                            </span><span class="hs-comment">-- R in (&gt;&gt;=) :: Q -&gt; (R -&gt; S) -&gt; T</span><span>
</span><span id="line-1174"></span><span>      </span><span id="trS_form"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; TransForm
</span><a href="Language.Haskell.Syntax.Expr.html#trS_form"><span class="hs-identifier hs-var hs-var">trS_form</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransForm"><span class="hs-identifier hs-type">TransForm</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1175"></span><span>      </span><span id="trS_stmts"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; [ExprLStmt idL]
</span><a href="Language.Haskell.Syntax.Expr.html#trS_stmts"><span class="hs-identifier hs-var hs-var">trS_stmts</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprLStmt"><span class="hs-identifier hs-type">ExprLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>   </span><span class="hs-comment">-- Stmts to the *left* of the 'group'</span><span>
</span><span id="line-1176"></span><span>                                      </span><span class="hs-comment">-- which generates the tuples to be grouped</span><span>
</span><span id="line-1177"></span><span>
</span><span id="line-1178"></span><span>      </span><span id="trS_bndrs"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; [(IdP idR, IdP idR)]
</span><a href="Language.Haskell.Syntax.Expr.html#trS_bndrs"><span class="hs-identifier hs-var hs-var">trS_bndrs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- See Note [TransStmt binder map]</span><span>
</span><span id="line-1179"></span><span>
</span><span id="line-1180"></span><span>      </span><span id="trS_using"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; LHsExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#trS_using"><span class="hs-identifier hs-var hs-var">trS_using</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1181"></span><span>      </span><span id="trS_by"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; Maybe (LHsExpr idR)
</span><a href="Language.Haskell.Syntax.Expr.html#trS_by"><span class="hs-identifier hs-var hs-var">trS_by</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>  </span><span class="hs-comment">-- &quot;by e&quot; (optional)</span><span>
</span><span id="line-1182"></span><span>        </span><span class="hs-comment">-- Invariant: if trS_form = GroupBy, then grp_by = Just e</span><span>
</span><span id="line-1183"></span><span>
</span><span id="line-1184"></span><span>      </span><span id="trS_ret"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; SyntaxExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#trS_ret"><span class="hs-identifier hs-var hs-var">trS_ret</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>      </span><span class="hs-comment">-- The monomorphic 'return' function for</span><span>
</span><span id="line-1185"></span><span>                                      </span><span class="hs-comment">-- the inner monad comprehensions</span><span>
</span><span id="line-1186"></span><span>      </span><span id="trS_bind"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; SyntaxExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#trS_bind"><span class="hs-identifier hs-var hs-var">trS_bind</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>     </span><span class="hs-comment">-- The '(&gt;&gt;=)' operator</span><span>
</span><span id="line-1187"></span><span>      </span><span id="trS_fmap"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; HsExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#trS_fmap"><span class="hs-identifier hs-var hs-var">trS_fmap</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span>          </span><span class="hs-comment">-- The polymorphic 'fmap' function for desugaring</span><span>
</span><span id="line-1188"></span><span>                                      </span><span class="hs-comment">-- Only for 'group' forms</span><span>
</span><span id="line-1189"></span><span>                                      </span><span class="hs-comment">-- Just a simple HsExpr, because it's</span><span>
</span><span id="line-1190"></span><span>                                      </span><span class="hs-comment">-- too polymorphic for tcSyntaxOp</span><span>
</span><span id="line-1191"></span><span>    </span><span class="hs-special">}</span><span>                                 </span><span class="hs-comment">-- See Note [Monad Comprehensions]</span><span>
</span><span id="line-1192"></span><span>
</span><span id="line-1193"></span><span>  </span><span class="hs-comment">-- Recursive statement (see Note [How RecStmt works] below)</span><span>
</span><span id="line-1194"></span><span>  </span><span class="annot"><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnRec'</span></span><span>
</span><span id="line-1195"></span><span>
</span><span id="line-1196"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1197"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecStmt"><span class="hs-identifier hs-var">RecStmt</span></a></span></span><span>
</span><span id="line-1198"></span><span>     </span><span class="hs-special">{</span><span> </span><span id="recS_ext"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; XRecStmt idL idR body
</span><a href="Language.Haskell.Syntax.Expr.html#recS_ext"><span class="hs-identifier hs-var hs-var">recS_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRecStmt"><span class="hs-identifier hs-type">XRecStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span>
</span><span id="line-1199"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_stmts"><span class="annot"><span class="annottext">forall idL idR body.
StmtLR idL idR body -&gt; XRec idR [LStmtLR idL idR body]
</span><a href="Language.Haskell.Syntax.Expr.html#recS_stmts"><span class="hs-identifier hs-var hs-var">recS_stmts</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmtLR"><span class="hs-identifier hs-type">LStmtLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1200"></span><span>     </span><span class="hs-comment">-- Assume XRec is the same for idL and idR, pick one arbitrarily</span><span>
</span><span id="line-1201"></span><span>
</span><span id="line-1202"></span><span>        </span><span class="hs-comment">-- The next two fields are only valid after renaming</span><span>
</span><span id="line-1203"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_later_ids"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; [IdP idR]
</span><a href="Language.Haskell.Syntax.Expr.html#recS_later_ids"><span class="hs-identifier hs-var hs-var">recS_later_ids</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1204"></span><span>                         </span><span class="hs-comment">-- The ids are a subset of the variables bound by the</span><span>
</span><span id="line-1205"></span><span>                         </span><span class="hs-comment">-- stmts that are used in stmts that follow the RecStmt</span><span>
</span><span id="line-1206"></span><span>
</span><span id="line-1207"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_rec_ids"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; [IdP idR]
</span><a href="Language.Haskell.Syntax.Expr.html#recS_rec_ids"><span class="hs-identifier hs-var hs-var">recS_rec_ids</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1208"></span><span>                         </span><span class="hs-comment">-- Ditto, but these variables are the &quot;recursive&quot; ones,</span><span>
</span><span id="line-1209"></span><span>                         </span><span class="hs-comment">-- that are used before they are bound in the stmts of</span><span>
</span><span id="line-1210"></span><span>                         </span><span class="hs-comment">-- the RecStmt.</span><span>
</span><span id="line-1211"></span><span>        </span><span class="hs-comment">-- An Id can be in both groups</span><span>
</span><span id="line-1212"></span><span>        </span><span class="hs-comment">-- Both sets of Ids are (now) treated monomorphically</span><span>
</span><span id="line-1213"></span><span>        </span><span class="hs-comment">-- See Note [How RecStmt works] for why they are separate</span><span>
</span><span id="line-1214"></span><span>
</span><span id="line-1215"></span><span>        </span><span class="hs-comment">-- Rebindable syntax</span><span>
</span><span id="line-1216"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_bind_fn"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; SyntaxExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#recS_bind_fn"><span class="hs-identifier hs-var hs-var">recS_bind_fn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-comment">-- The bind function</span><span>
</span><span id="line-1217"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_ret_fn"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; SyntaxExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#recS_ret_fn"><span class="hs-identifier hs-var hs-var">recS_ret_fn</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-comment">-- The return function</span><span>
</span><span id="line-1218"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_mfix_fn"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; SyntaxExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#recS_mfix_fn"><span class="hs-identifier hs-var hs-var">recS_mfix_fn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-comment">-- The mfix function</span><span>
</span><span id="line-1219"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-1220"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XStmtLR"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XStmtLR"><span class="hs-identifier hs-var">XStmtLR</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXStmtLR"><span class="hs-identifier hs-type">XXStmtLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597891"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597892"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597893"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1221"></span><span>
</span><span id="line-1222"></span><span class="hs-keyword">data</span><span> </span><span id="TransForm"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransForm"><span class="hs-identifier hs-var">TransForm</span></a></span></span><span>   </span><span class="hs-comment">-- The 'f' below is the 'using' function, 'e' is the by function</span><span>
</span><span id="line-1223"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ThenForm"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ThenForm"><span class="hs-identifier hs-var">ThenForm</span></a></span></span><span>     </span><span class="hs-comment">-- then f               or    then f by e             (depending on trS_by)</span><span>
</span><span id="line-1224"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="GroupForm"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GroupForm"><span class="hs-identifier hs-var">GroupForm</span></a></span></span><span>    </span><span class="hs-comment">-- then group using f   or    then group by e using f (depending on trS_by)</span><span>
</span><span id="line-1225"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681598448"><span id="local-6989586621681598450"><span id="local-6989586621681598452"><span id="local-6989586621681598454"><span id="local-6989586621681598456"><span id="local-6989586621681598462"><span id="local-6989586621681598467"><span id="local-6989586621681598470"><span id="local-6989586621681598473"><span id="local-6989586621681598476"><span id="local-6989586621681598479"><span id="local-6989586621681598482"><span id="local-6989586621681598487"><span id="local-6989586621681598492"><span class="annot"><span class="annottext">Typeable TransForm
Typeable TransForm =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; TransForm -&gt; c TransForm)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TransForm)
-&gt; (TransForm -&gt; Constr)
-&gt; (TransForm -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TransForm))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TransForm))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; TransForm -&gt; TransForm)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm)
-&gt; Data TransForm
TransForm -&gt; Constr
TransForm -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; TransForm -&gt; TransForm
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TransForm
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TransForm -&gt; c TransForm
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TransForm)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TransForm)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TransForm -&gt; c TransForm
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TransForm -&gt; c TransForm
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TransForm
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TransForm
$ctoConstr :: TransForm -&gt; Constr
toConstr :: TransForm -&gt; Constr
$cdataTypeOf :: TransForm -&gt; DataType
dataTypeOf :: TransForm -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TransForm)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TransForm)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TransForm)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TransForm)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TransForm -&gt; TransForm
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TransForm -&gt; TransForm
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
</span><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-1226"></span><span>
</span><span id="line-1227"></span><span class="annot"><span class="hs-comment">-- | Parenthesised Statement Block</span></span><span>
</span><span id="line-1228"></span><span class="hs-keyword">data</span><span> </span><span id="ParStmtBlock"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtBlock"><span class="hs-identifier hs-var">ParStmtBlock</span></a></span></span><span> </span><span id="local-6989586621681598496"><span class="annot"><a href="#local-6989586621681598496"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681598497"><span class="annot"><a href="#local-6989586621681598497"><span class="hs-identifier hs-type">idR</span></a></span></span><span>
</span><span id="line-1229"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ParStmtBlock"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtBlock"><span class="hs-identifier hs-var">ParStmtBlock</span></a></span></span><span>
</span><span id="line-1230"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParStmtBlock"><span class="hs-identifier hs-type">XParStmtBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598496"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598497"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1231"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprLStmt"><span class="hs-identifier hs-type">ExprLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598496"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1232"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598497"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">]</span><span>          </span><span class="hs-comment">-- The variables to be returned</span><span>
</span><span id="line-1233"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598497"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- The return operator</span><span>
</span><span id="line-1234"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XParStmtBlock"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XParStmtBlock"><span class="hs-identifier hs-var">XParStmtBlock</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXParStmtBlock"><span class="hs-identifier hs-type">XXParStmtBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598496"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598497"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1235"></span><span>
</span><span id="line-1236"></span><span class="hs-comment">-- | The fail operator</span><span>
</span><span id="line-1237"></span><span class="hs-comment">--</span><span>
</span><span id="line-1238"></span><span class="hs-comment">-- This is used for `.. &lt;-` &quot;bind statements&quot; in do notation, including</span><span>
</span><span id="line-1239"></span><span class="hs-comment">-- non-monadic &quot;binds&quot; in applicative.</span><span>
</span><span id="line-1240"></span><span class="hs-comment">--</span><span>
</span><span id="line-1241"></span><span class="hs-comment">-- The fail operator is 'Just expr' if it potentially fail monadically. if the</span><span>
</span><span id="line-1242"></span><span class="hs-comment">-- pattern match cannot fail, or shouldn't fail monadically (regular incomplete</span><span>
</span><span id="line-1243"></span><span class="hs-comment">-- pattern exception), it is 'Nothing'.</span><span>
</span><span id="line-1244"></span><span class="hs-comment">--</span><span>
</span><span id="line-1245"></span><span class="hs-comment">-- See Note [Monad fail : Rebindable syntax, overloaded strings] for the type of</span><span>
</span><span id="line-1246"></span><span class="hs-comment">-- expression in the 'Just' case, and why it is so.</span><span>
</span><span id="line-1247"></span><span class="hs-comment">--</span><span>
</span><span id="line-1248"></span><span class="hs-comment">-- See Note [Failing pattern matches in Stmts] for which contexts for</span><span>
</span><span id="line-1249"></span><span class="hs-comment">-- '@BindStmt@'s should use the monadic fail and which shouldn't.</span><span>
</span><span id="line-1250"></span><span class="hs-keyword">type</span><span> </span><span id="FailOperator"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FailOperator"><span class="hs-identifier hs-var">FailOperator</span></a></span></span><span> </span><span id="local-6989586621681598503"><span class="annot"><a href="#local-6989586621681598503"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598503"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1251"></span><span>
</span><span id="line-1252"></span><span class="annot"><span class="hs-comment">-- | Applicative Argument</span></span><span>
</span><span id="line-1253"></span><span class="hs-keyword">data</span><span> </span><span id="ApplicativeArg"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeArg"><span class="hs-identifier hs-var">ApplicativeArg</span></a></span></span><span> </span><span id="local-6989586621681597955"><span class="annot"><a href="#local-6989586621681597955"><span class="hs-identifier hs-type">idL</span></a></span></span><span>
</span><span id="line-1254"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ApplicativeArgOne"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeArgOne"><span class="hs-identifier hs-var">ApplicativeArgOne</span></a></span></span><span>      </span><span class="hs-comment">-- A single statement (BindStmt or BodyStmt)</span><span>
</span><span id="line-1255"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="xarg_app_arg_one"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; XApplicativeArgOne idL
</span><a href="Language.Haskell.Syntax.Expr.html#xarg_app_arg_one"><span class="hs-identifier hs-var hs-var">xarg_app_arg_one</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XApplicativeArgOne"><span class="hs-identifier hs-type">XApplicativeArgOne</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597955"><span class="hs-identifier hs-type">idL</span></a></span><span>
</span><span id="line-1256"></span><span>      </span><span class="hs-comment">-- ^ The fail operator, after renaming</span><span>
</span><span id="line-1257"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-1258"></span><span>      </span><span class="hs-comment">-- The fail operator is needed if this is a BindStmt</span><span>
</span><span id="line-1259"></span><span>      </span><span class="hs-comment">-- where the pattern can fail. E.g.:</span><span>
</span><span id="line-1260"></span><span>      </span><span class="hs-comment">-- (Just a) &lt;- stmt</span><span>
</span><span id="line-1261"></span><span>      </span><span class="hs-comment">-- The fail operator will be invoked if the pattern</span><span>
</span><span id="line-1262"></span><span>      </span><span class="hs-comment">-- match fails.</span><span>
</span><span id="line-1263"></span><span>      </span><span class="hs-comment">-- It is also used for guards in MonadComprehensions.</span><span>
</span><span id="line-1264"></span><span>      </span><span class="hs-comment">-- The fail operator is Nothing</span><span>
</span><span id="line-1265"></span><span>      </span><span class="hs-comment">-- if the pattern match can't fail</span><span>
</span><span id="line-1266"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="app_arg_pattern"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; LPat idL
</span><a href="Language.Haskell.Syntax.Expr.html#app_arg_pattern"><span class="hs-identifier hs-var hs-var">app_arg_pattern</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597955"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="hs-comment">-- WildPat if it was a BodyStmt (see below)</span><span>
</span><span id="line-1267"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="arg_expr"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; LHsExpr idL
</span><a href="Language.Haskell.Syntax.Expr.html#arg_expr"><span class="hs-identifier hs-var hs-var">arg_expr</span></a></span></span><span>          </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597955"><span class="hs-identifier hs-type">idL</span></a></span><span>
</span><span id="line-1268"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="is_body_stmt"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#is_body_stmt"><span class="hs-identifier hs-var hs-var">is_body_stmt</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1269"></span><span>      </span><span class="hs-comment">-- ^ True &lt;=&gt; was a BodyStmt,</span><span>
</span><span id="line-1270"></span><span>      </span><span class="hs-comment">-- False &lt;=&gt; was a BindStmt.</span><span>
</span><span id="line-1271"></span><span>      </span><span class="hs-comment">-- See Note [Applicative BodyStmt]</span><span>
</span><span id="line-1272"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-1273"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ApplicativeArgMany"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeArgMany"><span class="hs-identifier hs-var">ApplicativeArgMany</span></a></span></span><span>     </span><span class="hs-comment">-- do { stmts; return vars }</span><span>
</span><span id="line-1274"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="xarg_app_arg_many"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; XApplicativeArgMany idL
</span><a href="Language.Haskell.Syntax.Expr.html#xarg_app_arg_many"><span class="hs-identifier hs-var hs-var">xarg_app_arg_many</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XApplicativeArgMany"><span class="hs-identifier hs-type">XApplicativeArgMany</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597955"><span class="hs-identifier hs-type">idL</span></a></span><span>
</span><span id="line-1275"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="app_stmts"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; [ExprLStmt idL]
</span><a href="Language.Haskell.Syntax.Expr.html#app_stmts"><span class="hs-identifier hs-var hs-var">app_stmts</span></a></span></span><span>         </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprLStmt"><span class="hs-identifier hs-type">ExprLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597955"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- stmts</span><span>
</span><span id="line-1276"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="final_expr"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; HsExpr idL
</span><a href="Language.Haskell.Syntax.Expr.html#final_expr"><span class="hs-identifier hs-var hs-var">final_expr</span></a></span></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597955"><span class="hs-identifier hs-type">idL</span></a></span><span>    </span><span class="hs-comment">-- return (v1,..,vn), or just (v1,..,vn)</span><span>
</span><span id="line-1277"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="bv_pattern"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; LPat idL
</span><a href="Language.Haskell.Syntax.Expr.html#bv_pattern"><span class="hs-identifier hs-var hs-var">bv_pattern</span></a></span></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597955"><span class="hs-identifier hs-type">idL</span></a></span><span>      </span><span class="hs-comment">-- (v1,...,vn)</span><span>
</span><span id="line-1278"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="stmt_context"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; HsDoFlavour
</span><a href="Language.Haskell.Syntax.Expr.html#stmt_context"><span class="hs-identifier hs-var hs-var">stmt_context</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoFlavour"><span class="hs-identifier hs-type">HsDoFlavour</span></a></span><span>
</span><span id="line-1279"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ context of the do expression, used in pprArg</span></span><span>
</span><span id="line-1280"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-1281"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XApplicativeArg"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XApplicativeArg"><span class="hs-identifier hs-var">XApplicativeArg</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXApplicativeArg"><span class="hs-identifier hs-type">XXApplicativeArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597955"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1282"></span><span>
</span><span id="line-1283"></span><span class="hs-comment">{-
Note [The type of bind in Stmts]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Some Stmts, notably BindStmt, keep the (&gt;&gt;=) bind operator.
We do NOT assume that it has type
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
In some cases (see #303, #1537) it might have a more
exotic type, such as
    (&gt;&gt;=) :: m i j a -&gt; (a -&gt; m j k b) -&gt; m i k b
So we must be careful not to make assumptions about the type.
In particular, the monad may not be uniform throughout.

Note [TransStmt binder map]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
The [(idR,idR)] in a TransStmt behaves as follows:

  * Before renaming: []

  * After renaming:
          [ (x27,x27), ..., (z35,z35) ]
    These are the variables
       bound by the stmts to the left of the 'group'
       and used either in the 'by' clause,
                or     in the stmts following the 'group'
    Each item is a pair of identical variables.

  * After typechecking:
          [ (x27:Int, x27:[Int]), ..., (z35:Bool, z35:[Bool]) ]
    Each pair has the same unique, but different *types*.

Note [BodyStmt]
~~~~~~~~~~~~~~~
BodyStmts are a bit tricky, because what they mean
depends on the context.  Consider the following contexts:

        A do expression of type (m res_ty)
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        * BodyStmt E any_ty:   do { ....; E; ... }
                E :: m any_ty
          Translation: E &gt;&gt; ...

        A list comprehensions of type [elt_ty]
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        * BodyStmt E Bool:   [ .. | .... E ]
                        [ .. | ..., E, ... ]
                        [ .. | .... | ..., E | ... ]
                E :: Bool
          Translation: if E then fail else ...

        A guard list, guarding a RHS of type rhs_ty
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        * BodyStmt E BooParStmtBlockl:   f x | ..., E, ... = ...rhs...
                E :: Bool
          Translation: if E then fail else ...

        A monad comprehension of type (m res_ty)
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        * BodyStmt E Bool:   [ .. | .... E ]
                E :: Bool
          Translation: guard E &gt;&gt; ...

Array comprehensions are handled like list comprehensions.

Note [How RecStmt works]
~~~~~~~~~~~~~~~~~~~~~~~~
Example:
   HsDo [ BindStmt x ex

        , RecStmt { recS_rec_ids   = [a, c]
                  , recS_stmts     = [ BindStmt b (return (a,c))
                                     , LetStmt a = ...b...
                                     , BindStmt c ec ]
                  , recS_later_ids = [a, b]

        , return (a b) ]

Here, the RecStmt binds a,b,c; but
  - Only a,b are used in the stmts *following* the RecStmt,
  - Only a,c are used in the stmts *inside* the RecStmt
        *before* their bindings

Why do we need *both* rec_ids and later_ids?  For monads they could be
combined into a single set of variables, but not for arrows.  That
follows from the types of the respective feedback operators:

        mfix :: MonadFix m =&gt; (a -&gt; m a) -&gt; m a
        loop :: ArrowLoop a =&gt; a (b,d) (c,d) -&gt; a b c

* For mfix, the 'a' covers the union of the later_ids and the rec_ids
* For 'loop', 'c' is the later_ids and 'd' is the rec_ids

Note [Typing a RecStmt]
~~~~~~~~~~~~~~~~~~~~~~~
A (RecStmt stmts) types as if you had written

  (v1,..,vn, _, ..., _) &lt;- mfix (\~(_, ..., _, r1, ..., rm) -&gt;
                                 do { stmts
                                    ; return (v1,..vn, r1, ..., rm) })

where v1..vn are the later_ids
      r1..rm are the rec_ids

Note [Monad Comprehensions]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Monad comprehensions require separate functions like 'return' and
'&gt;&gt;=' for desugaring. These functions are stored in the statements
used in monad comprehensions. For example, the 'return' of the 'LastStmt'
expression is used to lift the body of the monad comprehension:

  [ body | stmts ]
   =&gt;
  stmts &gt;&gt;= \bndrs -&gt; return body

In transform and grouping statements ('then ..' and 'then group ..') the
'return' function is required for nested monad comprehensions, for example:

  [ body | stmts, then f, rest ]
   =&gt;
  f [ env | stmts ] &gt;&gt;= \bndrs -&gt; [ body | rest ]

BodyStmts require the 'Control.Monad.guard' function for boolean
expressions:

  [ body | exp, stmts ]
   =&gt;
  guard exp &gt;&gt; [ body | stmts ]

Parallel statements require the 'Control.Monad.Zip.mzip' function:

  [ body | stmts1 | stmts2 | .. ]
   =&gt;
  mzip stmts1 (mzip stmts2 (..)) &gt;&gt;= \(bndrs1, (bndrs2, ..)) -&gt; return body

In any other context than 'MonadComp', the fields for most of these
'SyntaxExpr's stay bottom.


Note [Applicative BodyStmt]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
(#12143) For the purposes of ApplicativeDo, we treat any BodyStmt
as if it was a BindStmt with a wildcard pattern.  For example,

  do
    x &lt;- A
    B
    return x

is transformed as if it were

  do
    x &lt;- A
    _ &lt;- B
    return x

so it transforms to

  (\(x,_) -&gt; x) &lt;$&gt; A &lt;*&gt; B

But we have to remember when we treat a BodyStmt like a BindStmt,
because in error messages we want to emit the original syntax the user
wrote, not our internal representation.  So ApplicativeArgOne has a
Bool flag that is True when the original statement was a BodyStmt, so
that we can pretty-print it correctly.
-}</span><span>
</span><span id="line-1447"></span><span>
</span><span id="line-1448"></span><span>
</span><span id="line-1449"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                Template Haskell quotation brackets
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1456"></span><span>
</span><span id="line-1457"></span><span class="hs-comment">{-
Note [Quasi-quote overview]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
The &quot;quasi-quote&quot; extension is described by Geoff Mainland's paper
&quot;Why it's nice to be quoted: quasiquoting for Haskell&quot; (Haskell
Workshop 2007).

Briefly, one writes
        [p| stuff |]
and the arbitrary string &quot;stuff&quot; gets parsed by the parser 'p', whose type
should be Language.Haskell.TH.Quote.QuasiQuoter.  'p' must be defined in
another module, because we are going to run it here.  It's a bit like an
/untyped/ TH splice where the parser is applied the &quot;stuff&quot; as a string, thus:
     $(p &quot;stuff&quot;)

Notice that it's an /untyped/ TH splice: it can occur in patterns and types, as well
as in expressions; and it runs in the renamer.
-}</span><span>
</span><span id="line-1475"></span><span>
</span><span id="line-1476"></span><span class="annot"><span class="hs-comment">-- | Haskell Splice</span></span><span>
</span><span id="line-1477"></span><span class="hs-keyword">data</span><span> </span><span id="HsUntypedSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSplice"><span class="hs-identifier hs-var">HsUntypedSplice</span></a></span></span><span> </span><span id="local-6989586621681598517"><span class="annot"><a href="#local-6989586621681598517"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-1478"></span><span>   </span><span class="hs-glyph">=</span><span> </span><span id="HsUntypedSpliceExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSpliceExpr"><span class="hs-identifier hs-var">HsUntypedSpliceExpr</span></a></span></span><span> </span><span class="hs-comment">--  $z  or $(f 4)</span><span>
</span><span id="line-1479"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XUntypedSpliceExpr"><span class="hs-identifier hs-type">XUntypedSpliceExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598517"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1480"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598517"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1481"></span><span>
</span><span id="line-1482"></span><span>   </span><span class="hs-glyph">|</span><span> </span><span id="HsQuasiQuote"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsQuasiQuote"><span class="hs-identifier hs-var">HsQuasiQuote</span></a></span></span><span>            </span><span class="hs-comment">-- See Note [Quasi-quote overview]</span><span>
</span><span id="line-1483"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XQuasiQuote"><span class="hs-identifier hs-type">XQuasiQuote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598517"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1484"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598517"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- The quoter (the bit between `[` and `|`)</span><span>
</span><span id="line-1485"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598517"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="GHC.Data.FastString.html#FastString"><span class="hs-identifier hs-type">FastString</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- The enclosed string</span><span>
</span><span id="line-1486"></span><span>
</span><span id="line-1487"></span><span>   </span><span class="hs-glyph">|</span><span> </span><span id="XUntypedSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XUntypedSplice"><span class="hs-identifier hs-var">XUntypedSplice</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXUntypedSplice"><span class="hs-identifier hs-type">XXUntypedSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598517"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Extension point; see Note [Trees That Grow]</span><span>
</span><span id="line-1488"></span><span>                                          </span><span class="hs-comment">-- in Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-1489"></span><span>
</span><span id="line-1490"></span><span class="annot"><span class="hs-comment">-- | Haskell (Untyped) Quote = Expr + Pat + Type + Var</span></span><span>
</span><span id="line-1491"></span><span class="hs-keyword">data</span><span> </span><span id="HsQuote"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsQuote"><span class="hs-identifier hs-var">HsQuote</span></a></span></span><span> </span><span id="local-6989586621681598524"><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-1492"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ExpBr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExpBr"><span class="hs-identifier hs-var">ExpBr</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExpBr"><span class="hs-identifier hs-type">XExpBr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- [|  expr  |]</span><span>
</span><span id="line-1493"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatBr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatBr"><span class="hs-identifier hs-var">PatBr</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPatBr"><span class="hs-identifier hs-type">XPatBr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- [p| pat   |]</span><span>
</span><span id="line-1494"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DecBrL"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DecBrL"><span class="hs-identifier hs-var">DecBrL</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDecBrL"><span class="hs-identifier hs-type">XDecBrL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LHsDecl"><span class="hs-identifier hs-type">LHsDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>   </span><span class="hs-comment">-- [d| decls |]; result of parser</span><span>
</span><span id="line-1495"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DecBrG"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DecBrG"><span class="hs-identifier hs-var">DecBrG</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDecBrG"><span class="hs-identifier hs-type">XDecBrG</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsGroup"><span class="hs-identifier hs-type">HsGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- [d| decls |]; result of renamer</span><span>
</span><span id="line-1496"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypBr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TypBr"><span class="hs-identifier hs-var">TypBr</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTypBr"><span class="hs-identifier hs-type">XTypBr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- [t| type  |]</span><span>
</span><span id="line-1497"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="VarBr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#VarBr"><span class="hs-identifier hs-var">VarBr</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XVarBr"><span class="hs-identifier hs-type">XVarBr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- True: 'x, False: ''T</span><span>
</span><span id="line-1498"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XQuote"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XQuote"><span class="hs-identifier hs-var">XQuote</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXQuote"><span class="hs-identifier hs-type">XXQuote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598524"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Extension point; see Note [Trees That Grow]</span><span>
</span><span id="line-1499"></span><span>                        </span><span class="hs-comment">-- in Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-1500"></span><span>
</span><span id="line-1501"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Enumerations and list comprehensions}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1508"></span><span>
</span><span id="line-1509"></span><span class="annot"><span class="hs-comment">-- | Arithmetic Sequence Information</span></span><span>
</span><span id="line-1510"></span><span class="hs-keyword">data</span><span> </span><span id="ArithSeqInfo"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArithSeqInfo"><span class="hs-identifier hs-var">ArithSeqInfo</span></a></span></span><span> </span><span id="local-6989586621681598542"><span class="annot"><a href="#local-6989586621681598542"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-1511"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="From"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#From"><span class="hs-identifier hs-var">From</span></a></span></span><span>            </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598542"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1512"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FromThen"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FromThen"><span class="hs-identifier hs-var">FromThen</span></a></span></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598542"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1513"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598542"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1514"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FromTo"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FromTo"><span class="hs-identifier hs-var">FromTo</span></a></span></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598542"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1515"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598542"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1516"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FromThenTo"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FromThenTo"><span class="hs-identifier hs-var">FromThenTo</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598542"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1517"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598542"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1518"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598542"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1519"></span><span class="hs-comment">-- AZ: Should ArithSeqInfo have a TTG extension?</span><span>
</span><span id="line-1520"></span><span>
</span><span id="line-1521"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{HsMatchCtxt}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1528"></span><span>
</span><span id="line-1529"></span><span class="hs-comment">-- | Haskell Match Context</span><span>
</span><span id="line-1530"></span><span class="hs-comment">--</span><span>
</span><span id="line-1531"></span><span class="hs-comment">-- Context of a pattern match. This is more subtle than it would seem. See</span><span>
</span><span id="line-1532"></span><span class="hs-comment">-- Note [FunBind vs PatBind].</span><span>
</span><span id="line-1533"></span><span class="hs-keyword">data</span><span> </span><span id="HsMatchContext"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-var">HsMatchContext</span></a></span></span><span> </span><span id="local-6989586621681597878"><span class="annot"><a href="#local-6989586621681597878"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-1534"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="FunRhs"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FunRhs"><span class="hs-identifier hs-var">FunRhs</span></a></span></span><span>
</span><span id="line-1535"></span><span>    </span><span class="hs-comment">-- ^ A pattern matching on an argument of a</span><span>
</span><span id="line-1536"></span><span>    </span><span class="hs-comment">-- function binding</span><span>
</span><span id="line-1537"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="mc_fun"><span class="annot"><span class="annottext">forall p. HsMatchContext p -&gt; LIdP (NoGhcTc p)
</span><a href="Language.Haskell.Syntax.Expr.html#mc_fun"><span class="hs-identifier hs-var hs-var">mc_fun</span></a></span></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoGhcTc"><span class="hs-identifier hs-type">NoGhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597878"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ function binder of @f@</span><span>
</span><span id="line-1538"></span><span>                                             </span><span class="hs-comment">-- See Note [mc_fun field of FunRhs]</span><span>
</span><span id="line-1539"></span><span>                                             </span><span class="hs-comment">-- See #20415 for a long discussion about</span><span>
</span><span id="line-1540"></span><span>                                             </span><span class="hs-comment">-- this field and why it uses NoGhcTc.</span><span>
</span><span id="line-1541"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="mc_fixity"><span class="annot"><span class="annottext">forall p. HsMatchContext p -&gt; LexicalFixity
</span><a href="Language.Haskell.Syntax.Expr.html#mc_fixity"><span class="hs-identifier hs-var hs-var">mc_fixity</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier hs-type">LexicalFixity</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ fixing of @f@</span></span><span>
</span><span id="line-1542"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="mc_strictness"><span class="annot"><span class="annottext">forall p. HsMatchContext p -&gt; SrcStrictness
</span><a href="Language.Haskell.Syntax.Expr.html#mc_strictness"><span class="hs-identifier hs-var hs-var">mc_strictness</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html#SrcStrictness"><span class="hs-identifier hs-type">SrcStrictness</span></a></span><span> </span><span class="hs-comment">-- ^ was @f@ banged?</span><span>
</span><span id="line-1543"></span><span>                                       </span><span class="hs-comment">-- See Note [FunBind vs PatBind]</span><span>
</span><span id="line-1544"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-1545"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LambdaExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LambdaExpr"><span class="hs-identifier hs-var">LambdaExpr</span></a></span></span><span>                  </span><span class="annot"><span class="hs-comment">-- ^Patterns of a lambda</span></span><span>
</span><span id="line-1546"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="CaseAlt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#CaseAlt"><span class="hs-identifier hs-var">CaseAlt</span></a></span></span><span>                     </span><span class="annot"><span class="hs-comment">-- ^Patterns and guards in a case alternative</span></span><span>
</span><span id="line-1547"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LamCaseAlt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LamCaseAlt"><span class="hs-identifier hs-var">LamCaseAlt</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LamCaseVariant"><span class="hs-identifier hs-type">LamCaseVariant</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^Patterns and guards in @\case@ and @\cases@</span></span><span>
</span><span id="line-1548"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="IfAlt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#IfAlt"><span class="hs-identifier hs-var">IfAlt</span></a></span></span><span>                       </span><span class="annot"><span class="hs-comment">-- ^Guards of a multi-way if alternative</span></span><span>
</span><span id="line-1549"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArrowMatchCtxt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowMatchCtxt"><span class="hs-identifier hs-var">ArrowMatchCtxt</span></a></span></span><span>              </span><span class="annot"><span class="hs-comment">-- ^A pattern match inside arrow notation</span></span><span>
</span><span id="line-1550"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsArrowMatchContext"><span class="hs-identifier hs-type">HsArrowMatchContext</span></a></span><span>
</span><span id="line-1551"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatBindRhs"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatBindRhs"><span class="hs-identifier hs-var">PatBindRhs</span></a></span></span><span>                  </span><span class="annot"><span class="hs-comment">-- ^A pattern binding  eg [y] &lt;- e = e</span></span><span>
</span><span id="line-1552"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatBindGuards"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatBindGuards"><span class="hs-identifier hs-var">PatBindGuards</span></a></span></span><span>               </span><span class="hs-comment">-- ^Guards of pattern bindings, e.g.,</span><span>
</span><span id="line-1553"></span><span>                                </span><span class="hs-comment">--    (Just b) | Just _ &lt;- x = e</span><span>
</span><span id="line-1554"></span><span>                                </span><span class="hs-comment">--             | otherwise   = e'</span><span>
</span><span id="line-1555"></span><span>
</span><span id="line-1556"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecUpd"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecUpd"><span class="hs-identifier hs-var">RecUpd</span></a></span></span><span>                      </span><span class="hs-comment">-- ^Record update [used only in GHC.HsToCore.Expr to</span><span>
</span><span id="line-1557"></span><span>                                </span><span class="hs-comment">--    tell matchWrapper what sort of</span><span>
</span><span id="line-1558"></span><span>                                </span><span class="hs-comment">--    runtime error message to generate]</span><span>
</span><span id="line-1559"></span><span>
</span><span id="line-1560"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="StmtCtxt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtCtxt"><span class="hs-identifier hs-var">StmtCtxt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597878"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^Pattern of a do-stmt, list comprehension,</span><span>
</span><span id="line-1561"></span><span>                                </span><span class="hs-comment">-- pattern guard, etc</span><span>
</span><span id="line-1562"></span><span>
</span><span id="line-1563"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ThPatSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ThPatSplice"><span class="hs-identifier hs-var">ThPatSplice</span></a></span></span><span>            </span><span class="annot"><span class="hs-comment">-- ^A Template Haskell pattern splice</span></span><span>
</span><span id="line-1564"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ThPatQuote"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ThPatQuote"><span class="hs-identifier hs-var">ThPatQuote</span></a></span></span><span>             </span><span class="annot"><span class="hs-comment">-- ^A Template Haskell pattern quotation [p| (a,b) |]</span></span><span>
</span><span id="line-1565"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatSyn"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatSyn"><span class="hs-identifier hs-var">PatSyn</span></a></span></span><span>                 </span><span class="annot"><span class="hs-comment">-- ^A pattern synonym declaration</span></span><span>
</span><span id="line-1566"></span><span>
</span><span id="line-1567"></span><span class="hs-comment">{-
Note [mc_fun field of FunRhs]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The mc_fun field of FunRhs has type `LIdP (NoGhcTc p)`, which means it will be
a `RdrName` in pass `GhcPs`, a `Name` in `GhcRn`, and (importantly) still a
`Name` in `GhcTc` -- not an `Id`.  See Note [NoGhcTc] in GHC.Hs.Extension.

Why a `Name` in the typechecker phase?  Because:
* A `Name` is all we need, as it turns out.
* Using an `Id` involves knot-tying in the monad, which led to #22695.

See #20415 for a long discussion.

-}</span><span>
</span><span id="line-1581"></span><span>
</span><span id="line-1582"></span><span id="local-6989586621681597975"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isPatSynCtxt"><span class="hs-identifier hs-type">isPatSynCtxt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597975"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1583"></span><span id="isPatSynCtxt"><span class="annot"><span class="annottext">isPatSynCtxt :: forall p. HsMatchContext p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isPatSynCtxt"><span class="hs-identifier hs-var hs-var">isPatSynCtxt</span></a></span></span><span> </span><span id="local-6989586621681598563"><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="#local-6989586621681598563"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1584"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="#local-6989586621681598563"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1585"></span><span>    </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#PatSyn"><span class="hs-identifier hs-var">PatSyn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1586"></span><span>    </span><span class="annot"><span class="annottext">HsMatchContext p
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1587"></span><span>
</span><span id="line-1588"></span><span class="annot"><span class="hs-comment">-- | Haskell Statement Context.</span></span><span>
</span><span id="line-1589"></span><span class="hs-keyword">data</span><span> </span><span id="HsStmtContext"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-var">HsStmtContext</span></a></span></span><span> </span><span id="local-6989586621681598564"><span class="annot"><a href="#local-6989586621681598564"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-1590"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsDoStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoStmt"><span class="hs-identifier hs-var">HsDoStmt</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoFlavour"><span class="hs-identifier hs-type">HsDoFlavour</span></a></span><span>             </span><span class="annot"><span class="hs-comment">-- ^Context for HsDo (do-notation and comprehensions)</span></span><span>
</span><span id="line-1591"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatGuard"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatGuard"><span class="hs-identifier hs-var">PatGuard</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598564"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>      </span><span class="annot"><span class="hs-comment">-- ^Pattern guard for specified thing</span></span><span>
</span><span id="line-1592"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ParStmtCtxt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtCtxt"><span class="hs-identifier hs-var">ParStmtCtxt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598564"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="annot"><span class="hs-comment">-- ^A branch of a parallel stmt</span></span><span>
</span><span id="line-1593"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TransStmtCtxt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransStmtCtxt"><span class="hs-identifier hs-var">TransStmtCtxt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598564"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="annot"><span class="hs-comment">-- ^A branch of a transform stmt</span></span><span>
</span><span id="line-1594"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArrowExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowExpr"><span class="hs-identifier hs-var">ArrowExpr</span></a></span></span><span>                        </span><span class="annot"><span class="hs-comment">-- ^do-notation in an arrow-command context</span></span><span>
</span><span id="line-1595"></span><span>
</span><span id="line-1596"></span><span class="annot"><span class="hs-comment">-- | Haskell arrow match context.</span></span><span>
</span><span id="line-1597"></span><span class="hs-keyword">data</span><span> </span><span id="HsArrowMatchContext"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsArrowMatchContext"><span class="hs-identifier hs-var">HsArrowMatchContext</span></a></span></span><span>
</span><span id="line-1598"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ProcExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ProcExpr"><span class="hs-identifier hs-var">ProcExpr</span></a></span></span><span>                       </span><span class="annot"><span class="hs-comment">-- ^ A proc expression</span></span><span>
</span><span id="line-1599"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArrowCaseAlt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowCaseAlt"><span class="hs-identifier hs-var">ArrowCaseAlt</span></a></span></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ A case alternative inside arrow notation</span></span><span>
</span><span id="line-1600"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArrowLamCaseAlt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowLamCaseAlt"><span class="hs-identifier hs-var">ArrowLamCaseAlt</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LamCaseVariant"><span class="hs-identifier hs-type">LamCaseVariant</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ A \case or \cases alternative inside arrow notation</span></span><span>
</span><span id="line-1601"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="KappaExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#KappaExpr"><span class="hs-identifier hs-var">KappaExpr</span></a></span></span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ An arrow kappa abstraction</span></span><span>
</span><span id="line-1602"></span><span>
</span><span id="line-1603"></span><span class="hs-keyword">data</span><span> </span><span id="HsDoFlavour"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoFlavour"><span class="hs-identifier hs-var">HsDoFlavour</span></a></span></span><span>
</span><span id="line-1604"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DoExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DoExpr"><span class="hs-identifier hs-var">DoExpr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Module.Name.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span class="hs-special">)</span><span>        </span><span class="annot"><span class="hs-comment">-- ^[ModuleName.]do { ... }</span></span><span>
</span><span id="line-1605"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MDoExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MDoExpr"><span class="hs-identifier hs-var">MDoExpr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Module.Name.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span class="hs-special">)</span><span>       </span><span class="annot"><span class="hs-comment">-- ^[ModuleName.]mdo { ... }  ie recursive do-expression</span></span><span>
</span><span id="line-1606"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="GhciStmtCtxt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GhciStmtCtxt"><span class="hs-identifier hs-var">GhciStmtCtxt</span></a></span></span><span>                     </span><span class="annot"><span class="hs-comment">-- ^A command-line Stmt in GHCi pat &lt;- rhs</span></span><span>
</span><span id="line-1607"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ListComp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ListComp"><span class="hs-identifier hs-var">ListComp</span></a></span></span><span>
</span><span id="line-1608"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MonadComp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MonadComp"><span class="hs-identifier hs-var">MonadComp</span></a></span></span><span>
</span><span id="line-1609"></span><span>
</span><span id="line-1610"></span><span id="local-6989586621681597977"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#qualifiedDoModuleName_maybe"><span class="hs-identifier hs-type">qualifiedDoModuleName_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597977"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Module.Name.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span></span><span>
</span><span id="line-1611"></span><span id="qualifiedDoModuleName_maybe"><span class="annot"><span class="annottext">qualifiedDoModuleName_maybe :: forall p. HsStmtContext p -&gt; Maybe ModuleName
</span><a href="Language.Haskell.Syntax.Expr.html#qualifiedDoModuleName_maybe"><span class="hs-identifier hs-var hs-var">qualifiedDoModuleName_maybe</span></a></span></span><span> </span><span id="local-6989586621681598580"><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681598580"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681598580"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1612"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoStmt"><span class="hs-identifier hs-type">HsDoStmt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DoExpr"><span class="hs-identifier hs-type">DoExpr</span></a></span><span> </span><span id="local-6989586621681598581"><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681598581"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681598581"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-1613"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoStmt"><span class="hs-identifier hs-type">HsDoStmt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MDoExpr"><span class="hs-identifier hs-type">MDoExpr</span></a></span><span> </span><span id="local-6989586621681598582"><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681598582"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681598582"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-1614"></span><span>  </span><span class="annot"><span class="annottext">HsStmtContext p
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
forall a. Maybe a
</span><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Nothing/GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-1615"></span><span>
</span><span id="line-1616"></span><span id="local-6989586621681597982"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-type">isComprehensionContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597982"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1617"></span><span class="hs-comment">-- Uses comprehension syntax [ e | quals ]</span><span>
</span><span id="line-1618"></span><span id="isComprehensionContext"><span class="annot"><span class="annottext">isComprehensionContext :: forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var hs-var">isComprehensionContext</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtCtxt"><span class="hs-identifier hs-type">ParStmtCtxt</span></a></span><span> </span><span id="local-6989586621681598584"><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681598584"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsStmtContext id -&gt; Bool
forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681598584"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-1619"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransStmtCtxt"><span class="hs-identifier hs-type">TransStmtCtxt</span></a></span><span> </span><span id="local-6989586621681598585"><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681598585"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsStmtContext id -&gt; Bool
forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681598585"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-1620"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="Language.Haskell.Syntax.Expr.html#ArrowExpr"><span class="hs-identifier hs-var">ArrowExpr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1621"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatGuard"><span class="hs-identifier hs-type">PatGuard</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext id
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1622"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoStmt"><span class="hs-identifier hs-type">HsDoStmt</span></a></span><span> </span><span id="local-6989586621681598586"><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="#local-6989586621681598586"><span class="hs-identifier hs-var">flavour</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsDoFlavour -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isDoComprehensionContext"><span class="hs-identifier hs-var">isDoComprehensionContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="#local-6989586621681598586"><span class="hs-identifier hs-var">flavour</span></a></span><span>
</span><span id="line-1623"></span><span>
</span><span id="line-1624"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isDoComprehensionContext"><span class="hs-identifier hs-type">isDoComprehensionContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoFlavour"><span class="hs-identifier hs-type">HsDoFlavour</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1625"></span><span id="isDoComprehensionContext"><span class="annot"><span class="annottext">isDoComprehensionContext :: HsDoFlavour -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isDoComprehensionContext"><span class="hs-identifier hs-var hs-var">isDoComprehensionContext</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="Language.Haskell.Syntax.Expr.html#GhciStmtCtxt"><span class="hs-identifier hs-var">GhciStmtCtxt</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1626"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isDoComprehensionContext"><span class="hs-identifier hs-var">isDoComprehensionContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DoExpr"><span class="hs-identifier hs-type">DoExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1627"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isDoComprehensionContext"><span class="hs-identifier hs-var">isDoComprehensionContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MDoExpr"><span class="hs-identifier hs-type">MDoExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1628"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isDoComprehensionContext"><span class="hs-identifier hs-var">isDoComprehensionContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="Language.Haskell.Syntax.Expr.html#ListComp"><span class="hs-identifier hs-var">ListComp</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1629"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isDoComprehensionContext"><span class="hs-identifier hs-var">isDoComprehensionContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="Language.Haskell.Syntax.Expr.html#MonadComp"><span class="hs-identifier hs-var">MonadComp</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1630"></span><span>
</span><span id="line-1631"></span><span class="annot"><span class="hs-comment">-- | Is this a monadic context?</span></span><span>
</span><span id="line-1632"></span><span id="local-6989586621681598588"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-type">isMonadStmtContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598588"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1633"></span><span id="isMonadStmtContext"><span class="annot"><span class="annottext">isMonadStmtContext :: forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var hs-var">isMonadStmtContext</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtCtxt"><span class="hs-identifier hs-type">ParStmtCtxt</span></a></span><span> </span><span id="local-6989586621681598590"><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681598590"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsStmtContext id -&gt; Bool
forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681598590"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1634"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransStmtCtxt"><span class="hs-identifier hs-type">TransStmtCtxt</span></a></span><span> </span><span id="local-6989586621681598591"><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681598591"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsStmtContext id -&gt; Bool
forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681598591"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1635"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoStmt"><span class="hs-identifier hs-type">HsDoStmt</span></a></span><span> </span><span id="local-6989586621681598592"><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="#local-6989586621681598592"><span class="hs-identifier hs-var">flavour</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsDoFlavour -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadDoStmtContext"><span class="hs-identifier hs-var">isMonadDoStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="#local-6989586621681598592"><span class="hs-identifier hs-var">flavour</span></a></span><span>
</span><span id="line-1636"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatGuard"><span class="hs-identifier hs-type">PatGuard</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext id
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1637"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="Language.Haskell.Syntax.Expr.html#ArrowExpr"><span class="hs-identifier hs-var">ArrowExpr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1638"></span><span>
</span><span id="line-1639"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadDoStmtContext"><span class="hs-identifier hs-type">isMonadDoStmtContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoFlavour"><span class="hs-identifier hs-type">HsDoFlavour</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1640"></span><span id="isMonadDoStmtContext"><span class="annot"><span class="annottext">isMonadDoStmtContext :: HsDoFlavour -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadDoStmtContext"><span class="hs-identifier hs-var hs-var">isMonadDoStmtContext</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="Language.Haskell.Syntax.Expr.html#ListComp"><span class="hs-identifier hs-var">ListComp</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1641"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadDoStmtContext"><span class="hs-identifier hs-var">isMonadDoStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="Language.Haskell.Syntax.Expr.html#MonadComp"><span class="hs-identifier hs-var">MonadComp</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1642"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadDoStmtContext"><span class="hs-identifier hs-var">isMonadDoStmtContext</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DoExpr"><span class="hs-identifier hs-type">DoExpr</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1643"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadDoStmtContext"><span class="hs-identifier hs-var">isMonadDoStmtContext</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MDoExpr"><span class="hs-identifier hs-type">MDoExpr</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1644"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadDoStmtContext"><span class="hs-identifier hs-var">isMonadDoStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="Language.Haskell.Syntax.Expr.html#GhciStmtCtxt"><span class="hs-identifier hs-var">GhciStmtCtxt</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1645"></span><span>
</span><span id="line-1646"></span><span id="local-6989586621681598594"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadCompContext"><span class="hs-identifier hs-type">isMonadCompContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681598594"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1647"></span><span id="isMonadCompContext"><span class="annot"><span class="annottext">isMonadCompContext :: forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadCompContext"><span class="hs-identifier hs-var hs-var">isMonadCompContext</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoStmt"><span class="hs-identifier hs-type">HsDoStmt</span></a></span><span> </span><span id="local-6989586621681598596"><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="#local-6989586621681598596"><span class="hs-identifier hs-var">flavour</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsDoFlavour -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadDoCompContext"><span class="hs-identifier hs-var">isMonadDoCompContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="#local-6989586621681598596"><span class="hs-identifier hs-var">flavour</span></a></span><span>
</span><span id="line-1648"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadCompContext"><span class="hs-identifier hs-var">isMonadCompContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtCtxt"><span class="hs-identifier hs-type">ParStmtCtxt</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1649"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadCompContext"><span class="hs-identifier hs-var">isMonadCompContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransStmtCtxt"><span class="hs-identifier hs-type">TransStmtCtxt</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1650"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadCompContext"><span class="hs-identifier hs-var">isMonadCompContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatGuard"><span class="hs-identifier hs-type">PatGuard</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext id
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1651"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadCompContext"><span class="hs-identifier hs-var">isMonadCompContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="Language.Haskell.Syntax.Expr.html#ArrowExpr"><span class="hs-identifier hs-var">ArrowExpr</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1652"></span><span>
</span><span id="line-1653"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadDoCompContext"><span class="hs-identifier hs-type">isMonadDoCompContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoFlavour"><span class="hs-identifier hs-type">HsDoFlavour</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1654"></span><span id="isMonadDoCompContext"><span class="annot"><span class="annottext">isMonadDoCompContext :: HsDoFlavour -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadDoCompContext"><span class="hs-identifier hs-var hs-var">isMonadDoCompContext</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="Language.Haskell.Syntax.Expr.html#MonadComp"><span class="hs-identifier hs-var">MonadComp</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1655"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadDoCompContext"><span class="hs-identifier hs-var">isMonadDoCompContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="Language.Haskell.Syntax.Expr.html#ListComp"><span class="hs-identifier hs-var">ListComp</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1656"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadDoCompContext"><span class="hs-identifier hs-var">isMonadDoCompContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsDoFlavour
</span><a href="Language.Haskell.Syntax.Expr.html#GhciStmtCtxt"><span class="hs-identifier hs-var">GhciStmtCtxt</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1657"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadDoCompContext"><span class="hs-identifier hs-var">isMonadDoCompContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DoExpr"><span class="hs-identifier hs-type">DoExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1658"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadDoCompContext"><span class="hs-identifier hs-var">isMonadDoCompContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MDoExpr"><span class="hs-identifier hs-type">MDoExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1659"></span></pre></body></html>