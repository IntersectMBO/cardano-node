<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621681596847"><span id="local-6989586621681596848"><span id="local-6989586621681596849"><span id="local-6989586621681596850"><span id="local-6989586621681596851"><span id="local-6989586621681596852"><span id="local-6989586621681596853"><span id="local-6989586621681596854"><span id="local-6989586621681596855"><span id="local-6989586621681596856"><span id="local-6989586621681596857"><span id="local-6989586621681596858"><span id="local-6989586621681596859"><span id="local-6989586621681596860"><span id="local-6989586621681596861"><span id="local-6989586621681596862"><span id="local-6989586621681596863"><span id="local-6989586621681596864"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE DataKinds #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE DeriveTraversable #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE LambdaCase #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications #-}</span><span>
</span><span id="line-11"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-12"></span><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving #-}</span><span>
</span><span id="line-13"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span> </span><span class="hs-comment">-- Wrinkle in Note [Trees That Grow]</span><span>
</span><span id="line-14"></span><span>                                      </span><span class="hs-comment">-- in module Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-15"></span><span class="hs-pragma">{-# LANGUAGE ViewPatterns #-}</span><span>
</span><span id="line-16"></span><span>
</span><span id="line-17"></span><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/@type@AQUA Project, Glasgow University, 1992-1998
-}</span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span class="hs-comment">-- See Note [Language.Haskell.Syntax.* Hierarchy] for why not GHC.Hs.*</span><span>
</span><span id="line-23"></span><span>
</span><span id="line-24"></span><span class="hs-comment">-- | Abstract syntax of global declarations.</span><span>
</span><span id="line-25"></span><span class="hs-comment">--</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- Definitions for: @SynDecl@ and @ConDecl@, @ClassDecl@,</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- @InstDecl@, @DefaultDecl@ and @ForeignDecl@.</span><span>
</span><span id="line-28"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.Syntax.Decls</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-29"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Toplevel declarations</span></span><span>
</span><span id="line-30"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDecl"><span class="hs-identifier">HsDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LHsDecl"><span class="hs-identifier">LHsDecl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDataDefn"><span class="hs-identifier">HsDataDefn</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDeriving"><span class="hs-identifier">HsDeriving</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LHsFunDep"><span class="hs-identifier">LHsFunDep</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FunDep"><span class="hs-identifier">FunDep</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDerivingClause"><span class="hs-identifier">HsDerivingClause</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LHsDerivingClause"><span class="hs-identifier">LHsDerivingClause</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivClauseTys"><span class="hs-identifier">DerivClauseTys</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDerivClauseTys"><span class="hs-identifier">LDerivClauseTys</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#NewOrData"><span class="hs-identifier">NewOrData</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataDefnCons"><span class="hs-identifier">DataDefnCons</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#dataDefnConsNewOrData"><span class="hs-identifier">dataDefnConsNewOrData</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isTypeDataDefnCons"><span class="hs-identifier">isTypeDataDefnCons</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#StandaloneKindSig"><span class="hs-identifier">StandaloneKindSig</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LStandaloneKindSig"><span class="hs-identifier">LStandaloneKindSig</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Class or type declarations</span></span><span>
</span><span id="line-37"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier">TyClDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyClDecl"><span class="hs-identifier">LTyClDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClGroup"><span class="hs-identifier">TyClGroup</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClGroupTyClDecls"><span class="hs-identifier">tyClGroupTyClDecls</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClGroupInstDecls"><span class="hs-identifier">tyClGroupInstDecls</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClGroupRoleDecls"><span class="hs-identifier">tyClGroupRoleDecls</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-40"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClGroupKindSigs"><span class="hs-identifier">tyClGroupKindSigs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-41"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isClassDecl"><span class="hs-identifier">isClassDecl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isDataDecl"><span class="hs-identifier">isDataDecl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isSynDecl"><span class="hs-identifier">isSynDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-42"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isFamilyDecl"><span class="hs-identifier">isFamilyDecl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isTypeFamilyDecl"><span class="hs-identifier">isTypeFamilyDecl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isDataFamilyDecl"><span class="hs-identifier">isDataFamilyDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isOpenTypeFamilyInfo"><span class="hs-identifier">isOpenTypeFamilyInfo</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isClosedTypeFamilyInfo"><span class="hs-identifier">isClosedTypeFamilyInfo</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-44"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClDeclTyVars"><span class="hs-identifier">tyClDeclTyVars</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-45"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyDecl"><span class="hs-identifier">FamilyDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LFamilyDecl"><span class="hs-identifier">LFamilyDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-46"></span><span>
</span><span id="line-47"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Instance declarations</span></span><span>
</span><span id="line-48"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#InstDecl"><span class="hs-identifier">InstDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LInstDecl"><span class="hs-identifier">LInstDecl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyInfo"><span class="hs-identifier">FamilyInfo</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-49"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstDecl"><span class="hs-identifier">TyFamInstDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyFamInstDecl"><span class="hs-identifier">LTyFamInstDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-50"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamDefltDecl"><span class="hs-identifier">TyFamDefltDecl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyFamDefltDecl"><span class="hs-identifier">LTyFamDefltDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-51"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataFamInstDecl"><span class="hs-identifier">DataFamInstDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDataFamInstDecl"><span class="hs-identifier">LDataFamInstDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-52"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamEqn"><span class="hs-identifier">FamEqn</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstEqn"><span class="hs-identifier">TyFamInstEqn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyFamInstEqn"><span class="hs-identifier">LTyFamInstEqn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsTyPats"><span class="hs-identifier">HsTyPats</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-53"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LClsInstDecl"><span class="hs-identifier">LClsInstDecl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClsInstDecl"><span class="hs-identifier">ClsInstDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Standalone deriving declarations</span></span><span>
</span><span id="line-56"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivDecl"><span class="hs-identifier">DerivDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDerivDecl"><span class="hs-identifier">LDerivDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-57"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Deriving strategies</span></span><span>
</span><span id="line-58"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivStrategy"><span class="hs-identifier">DerivStrategy</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDerivStrategy"><span class="hs-identifier">LDerivStrategy</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-59"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** @RULE@ declarations</span></span><span>
</span><span id="line-60"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRuleDecls"><span class="hs-identifier">LRuleDecls</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleDecls"><span class="hs-identifier">RuleDecls</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleDecl"><span class="hs-identifier">RuleDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRuleDecl"><span class="hs-identifier">LRuleDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-61"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleBndr"><span class="hs-identifier">RuleBndr</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRuleBndr"><span class="hs-identifier">LRuleBndr</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-62"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#collectRuleBndrSigTys"><span class="hs-identifier">collectRuleBndrSigTys</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-63"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** @default@ declarations</span></span><span>
</span><span id="line-64"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DefaultDecl"><span class="hs-identifier">DefaultDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDefaultDecl"><span class="hs-identifier">LDefaultDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-65"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Template haskell declaration splice</span></span><span>
</span><span id="line-66"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SpliceDecoration"><span class="hs-identifier">SpliceDecoration</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-67"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SpliceDecl"><span class="hs-identifier">SpliceDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LSpliceDecl"><span class="hs-identifier">LSpliceDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-68"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Foreign function interface declarations</span></span><span>
</span><span id="line-69"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignDecl"><span class="hs-identifier">ForeignDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LForeignDecl"><span class="hs-identifier">LForeignDecl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignImport"><span class="hs-identifier">ForeignImport</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignExport"><span class="hs-identifier">ForeignExport</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-70"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#CImportSpec"><span class="hs-identifier">CImportSpec</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-71"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Data-constructor declarations</span></span><span>
</span><span id="line-72"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ConDecl"><span class="hs-identifier">ConDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LConDecl"><span class="hs-identifier">LConDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-73"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsConDeclH98Details"><span class="hs-identifier">HsConDeclH98Details</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsConDeclGADTDetails"><span class="hs-identifier">HsConDeclGADTDetails</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-74"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Document comments</span></span><span>
</span><span id="line-75"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocDecl"><span class="hs-identifier">DocDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDocDecl"><span class="hs-identifier">LDocDecl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#docDeclDoc"><span class="hs-identifier">docDeclDoc</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-76"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Deprecations</span></span><span>
</span><span id="line-77"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#WarnDecl"><span class="hs-identifier">WarnDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LWarnDecl"><span class="hs-identifier">LWarnDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-78"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#WarnDecls"><span class="hs-identifier">WarnDecls</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LWarnDecls"><span class="hs-identifier">LWarnDecls</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-79"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Annotations</span></span><span>
</span><span id="line-80"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#AnnDecl"><span class="hs-identifier">AnnDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LAnnDecl"><span class="hs-identifier">LAnnDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-81"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#AnnProvenance"><span class="hs-identifier">AnnProvenance</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#annProvenanceName_maybe"><span class="hs-identifier">annProvenanceName_maybe</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-82"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Role annotations</span></span><span>
</span><span id="line-83"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RoleAnnotDecl"><span class="hs-identifier">RoleAnnotDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRoleAnnotDecl"><span class="hs-identifier">LRoleAnnotDecl</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-84"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Injective type families</span></span><span>
</span><span id="line-85"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyResultSig"><span class="hs-identifier">FamilyResultSig</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LFamilyResultSig"><span class="hs-identifier">LFamilyResultSig</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#InjectivityAnn"><span class="hs-identifier">InjectivityAnn</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LInjectivityAnn"><span class="hs-identifier">LInjectivityAnn</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Grouping</span></span><span>
</span><span id="line-88"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsGroup"><span class="hs-identifier">HsGroup</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#hsGroupInstDecls"><span class="hs-identifier">hsGroupInstDecls</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-89"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="hs-comment">-- friends:</span><span>
</span><span id="line-92"></span><span class="hs-keyword">import</span><span> </span><span class="hs-pragma">{-# SOURCE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html"><span class="hs-identifier">Language.Haskell.Syntax.Expr</span></a></span><span>
</span><span id="line-93"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier">HsExpr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSplice"><span class="hs-identifier">HsUntypedSplice</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-94"></span><span>        </span><span class="hs-comment">-- Because Expr imports Decls via HsBracket</span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html"><span class="hs-identifier">Language.Haskell.Syntax.Binds</span></a></span><span>
</span><span id="line-97"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html"><span class="hs-identifier">Language.Haskell.Syntax.Concrete</span></a></span><span>
</span><span id="line-98"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html"><span class="hs-identifier">Language.Haskell.Syntax.Extension</span></a></span><span>
</span><span id="line-99"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html"><span class="hs-identifier">Language.Haskell.Syntax.Type</span></a></span><span>
</span><span id="line-100"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html"><span class="hs-identifier">Language.Haskell.Syntax.Basic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html#Role"><span class="hs-identifier">Role</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-101"></span><span>
</span><span id="line-102"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html"><span class="hs-identifier">GHC.Types.Basic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Basic.html#TopLevelFlag"><span class="hs-identifier">TopLevelFlag</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#OverlapMode"><span class="hs-identifier">OverlapMode</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#RuleName"><span class="hs-identifier">RuleName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#Activation"><span class="hs-identifier">Activation</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-103"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html"><span class="hs-identifier">GHC.Types.ForeignCall</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.ForeignCall.html#CType"><span class="hs-identifier">CType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#CCallConv"><span class="hs-identifier">CCallConv</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#Safety"><span class="hs-identifier">Safety</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#Header"><span class="hs-identifier">Header</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#CLabelString"><span class="hs-identifier">CLabelString</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#CCallTarget"><span class="hs-identifier">CCallTarget</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#CExportSpec"><span class="hs-identifier">CExportSpec</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-104"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html"><span class="hs-identifier">GHC.Types.Fixity</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier">LexicalFixity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Type.html"><span class="hs-identifier">GHC.Core.Type</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Var.html#Specificity"><span class="hs-identifier">Specificity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Unit.Module.Warnings.html"><span class="hs-identifier">GHC.Unit.Module.Warnings</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Unit.Module.Warnings.html#WarningTxt"><span class="hs-identifier">WarningTxt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-108"></span><span>
</span><span id="line-109"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Doc.html"><span class="hs-identifier">GHC.Hs.Doc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier">LHsDoc</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ROMES:TODO Discuss in #21592 whether this is parsed AST or base AST</span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Control.Monad.html#/Control.Monad.html"><span class="hs-identifier">Control.Monad</span></a></span><span>
</span><span id="line-112"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Data.html#/Data.Data.html"><span class="hs-identifier">Data.Data</span></a></span><span>        </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">TyCon</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Data.html#Fixity/Data.Data.html#Fixity"><span class="hs-identifier">Fixity</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Data.html#Infix/Data.Data.html#Infix"><span class="hs-identifier">Infix</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Void.html#/Data.Void.html"><span class="hs-identifier">Data.Void</span></a></span><span>
</span><span id="line-114"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Maybe.html#/Data.Maybe.html"><span class="hs-identifier">Data.Maybe</span></a></span><span>
</span><span id="line-115"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.String.html#/Data.String.html"><span class="hs-identifier">Data.String</span></a></span><span>
</span><span id="line-116"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Function.html#/Data.Function.html"><span class="hs-identifier">Data.Function</span></a></span><span>
</span><span id="line-117"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Eq.html#/Data.Eq.html"><span class="hs-identifier">Data.Eq</span></a></span><span>
</span><span id="line-118"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Int.html#/Data.Int.html"><span class="hs-identifier">Data.Int</span></a></span><span>
</span><span id="line-119"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Bool.html#/Data.Bool.html"><span class="hs-identifier">Data.Bool</span></a></span><span>
</span><span id="line-120"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Prelude.html#/Prelude.html"><span class="hs-identifier">Prelude</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Show.html#Show/GHC.Show.html#Show"><span class="hs-identifier">Show</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-121"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.List.html#/Data.List.html"><span class="hs-identifier">Data.List</span></a></span><span>
</span><span id="line-122"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Foldable.html#/Data.Foldable.html"><span class="hs-identifier">Data.Foldable</span></a></span><span>
</span><span id="line-123"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Traversable.html#/Data.Traversable.html"><span class="hs-identifier">Data.Traversable</span></a></span><span>
</span><span id="line-124"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.List.NonEmpty.html#/Data.List.NonEmpty.html"><span class="hs-identifier">Data.List.NonEmpty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#NonEmpty/GHC.Base.html#NonEmpty"><span class="hs-identifier">NonEmpty</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection[HsDecl]{Declarations}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-133"></span><span>
</span><span id="line-134"></span><span class="hs-keyword">type</span><span> </span><span id="LHsDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LHsDecl"><span class="hs-identifier hs-var">LHsDecl</span></a></span></span><span> </span><span id="local-6989586621681596909"><span class="annot"><a href="#local-6989586621681596909"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596909"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDecl"><span class="hs-identifier hs-type">HsDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596909"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-135"></span><span>        </span><span class="hs-comment">-- ^ When in a list this may have</span><span>
</span><span id="line-136"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-137"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi'</span><span>
</span><span id="line-138"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="annot"><span class="hs-comment">-- | A Haskell Declaration</span></span><span>
</span><span id="line-143"></span><span class="hs-keyword">data</span><span> </span><span id="HsDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDecl"><span class="hs-identifier hs-var">HsDecl</span></a></span></span><span> </span><span id="local-6989586621681596910"><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-144"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="TyClD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClD"><span class="hs-identifier hs-var">TyClD</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTyClD"><span class="hs-identifier hs-type">XTyClD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier hs-type">TyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>      </span><span class="annot"><span class="hs-comment">-- ^ Type or Class Declaration</span></span><span>
</span><span id="line-145"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InstD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#InstD"><span class="hs-identifier hs-var">InstD</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XInstD"><span class="hs-identifier hs-type">XInstD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#InstDecl"><span class="hs-identifier hs-type">InstDecl</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Instance declaration</span></span><span>
</span><span id="line-146"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DerivD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivD"><span class="hs-identifier hs-var">DerivD</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDerivD"><span class="hs-identifier hs-type">XDerivD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivDecl"><span class="hs-identifier hs-type">DerivDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Deriving declaration</span></span><span>
</span><span id="line-147"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ValD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ValD"><span class="hs-identifier hs-var">ValD</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XValD"><span class="hs-identifier hs-type">XValD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBind"><span class="hs-identifier hs-type">HsBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>        </span><span class="annot"><span class="hs-comment">-- ^ Value declaration</span></span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SigD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SigD"><span class="hs-identifier hs-var">SigD</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigD"><span class="hs-identifier hs-type">XSigD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#Sig"><span class="hs-identifier hs-type">Sig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>           </span><span class="annot"><span class="hs-comment">-- ^ Signature declaration</span></span><span>
</span><span id="line-149"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="KindSigD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#KindSigD"><span class="hs-identifier hs-var">KindSigD</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XKindSigD"><span class="hs-identifier hs-type">XKindSigD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#StandaloneKindSig"><span class="hs-identifier hs-type">StandaloneKindSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Standalone kind signature</span></span><span>
</span><span id="line-150"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DefD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DefD"><span class="hs-identifier hs-var">DefD</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDefD"><span class="hs-identifier hs-type">XDefD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DefaultDecl"><span class="hs-identifier hs-type">DefaultDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ 'default' declaration</span></span><span>
</span><span id="line-151"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ForD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForD"><span class="hs-identifier hs-var">ForD</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XForD"><span class="hs-identifier hs-type">XForD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignDecl"><span class="hs-identifier hs-type">ForeignDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ Foreign declaration</span></span><span>
</span><span id="line-152"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="WarningD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#WarningD"><span class="hs-identifier hs-var">WarningD</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWarningD"><span class="hs-identifier hs-type">XWarningD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#WarnDecls"><span class="hs-identifier hs-type">WarnDecls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Warning declaration</span></span><span>
</span><span id="line-153"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="AnnD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#AnnD"><span class="hs-identifier hs-var">AnnD</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAnnD"><span class="hs-identifier hs-type">XAnnD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#AnnDecl"><span class="hs-identifier hs-type">AnnDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="annot"><span class="hs-comment">-- ^ Annotation declaration</span></span><span>
</span><span id="line-154"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RuleD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleD"><span class="hs-identifier hs-var">RuleD</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRuleD"><span class="hs-identifier hs-type">XRuleD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleDecls"><span class="hs-identifier hs-type">RuleDecls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Rule declaration</span></span><span>
</span><span id="line-155"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SpliceD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SpliceD"><span class="hs-identifier hs-var">SpliceD</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSpliceD"><span class="hs-identifier hs-type">XSpliceD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SpliceDecl"><span class="hs-identifier hs-type">SpliceDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ Splice declaration</span><span>
</span><span id="line-156"></span><span>                                                 </span><span class="hs-comment">-- (Includes quasi-quotes)</span><span>
</span><span id="line-157"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DocD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocD"><span class="hs-identifier hs-var">DocD</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDocD"><span class="hs-identifier hs-type">XDocD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocDecl"><span class="hs-identifier hs-type">DocDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- ^ Documentation comment</span><span>
</span><span id="line-158"></span><span>                                                 </span><span class="hs-comment">-- declaration</span><span>
</span><span id="line-159"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RoleAnnotD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RoleAnnotD"><span class="hs-identifier hs-var">RoleAnnotD</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRoleAnnotD"><span class="hs-identifier hs-type">XRoleAnnotD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RoleAnnotDecl"><span class="hs-identifier hs-type">RoleAnnotDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^Role annotation declaration</span></span><span>
</span><span id="line-160"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XHsDecl"><span class="hs-identifier hs-var">XHsDecl</span></a></span></span><span>    </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsDecl"><span class="hs-identifier hs-type">XXHsDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596910"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span>
</span><span id="line-162"></span><span class="hs-comment">{-
Note [Top-level fixity signatures in an HsGroup]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
An `HsGroup p` stores every top-level fixity declarations in one of two places:

1. hs_fixds :: [LFixitySig p]

   This stores fixity signatures for top-level declarations (e.g., functions,
   data constructors, classes, type families, etc.) as well as fixity
   signatures for class methods written outside of the class, as in this
   example:

     infixl 4 `m1`
     class C1 a where
       m1 :: a -&gt; a -&gt; a

2. hs_tyclds :: [TyClGroup p]

   Each type class can be found in a TyClDecl inside a TyClGroup, and that
   TyClDecl stores the fixity signatures for its methods written inside of the
   class, as in this example:

     class C2 a where
       infixl 4 `m2`
       m2 :: a -&gt; a -&gt; a

The story for fixity signatures for class methods is made slightly complicated
by the fact that they can appear both inside and outside of the class itself,
and both forms of fixity signatures are considered top-level. This matters
in `GHC.Rename.Module.rnSrcDecls`, which must create a fixity environment out
of all top-level fixity signatures before doing anything else. Therefore,
`rnSrcDecls` must be aware of both (1) and (2) above. The
`hsGroupTopLevelFixitySigs` function is responsible for collecting this
information from an `HsGroup`.

One might wonder why we even bother separating top-level fixity signatures
into two places at all. That is, why not just take the fixity signatures
from `hs_tyclds` and put them into `hs_fixds` so that they are all in one
location? This ends up causing problems for `GHC.HsToCore.Quote.repTopDs`,
which translates each fixity signature in `hs_fixds` and `hs_tyclds` into a
Template Haskell `Dec`. If there are any duplicate signatures between the two
fields, this will result in an error (#17608).
-}</span><span>
</span><span id="line-205"></span><span>
</span><span id="line-206"></span><span class="hs-comment">-- | Haskell Group</span><span>
</span><span id="line-207"></span><span class="hs-comment">--</span><span>
</span><span id="line-208"></span><span class="hs-comment">-- A 'HsDecl' is categorised into a 'HsGroup' before being</span><span>
</span><span id="line-209"></span><span class="hs-comment">-- fed to the renamer.</span><span>
</span><span id="line-210"></span><span class="hs-keyword">data</span><span> </span><span id="HsGroup"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsGroup"><span class="hs-identifier hs-var">HsGroup</span></a></span></span><span> </span><span id="local-6989586621681596333"><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-211"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsGroup"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsGroup"><span class="hs-identifier hs-var">HsGroup</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-212"></span><span>        </span><span id="hs_ext"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; XCHsGroup p
</span><a href="Language.Haskell.Syntax.Decls.html#hs_ext"><span class="hs-identifier hs-var hs-var">hs_ext</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCHsGroup"><span class="hs-identifier hs-type">XCHsGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-213"></span><span>        </span><span id="hs_valds"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; HsValBinds p
</span><a href="Language.Haskell.Syntax.Decls.html#hs_valds"><span class="hs-identifier hs-var hs-var">hs_valds</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBinds"><span class="hs-identifier hs-type">HsValBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-214"></span><span>        </span><span id="hs_splcds"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; [LSpliceDecl p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_splcds"><span class="hs-identifier hs-var hs-var">hs_splcds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LSpliceDecl"><span class="hs-identifier hs-type">LSpliceDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-215"></span><span>
</span><span id="line-216"></span><span>        </span><span id="hs_tyclds"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; [TyClGroup p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_tyclds"><span class="hs-identifier hs-var hs-var">hs_tyclds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClGroup"><span class="hs-identifier hs-type">TyClGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-217"></span><span>                </span><span class="hs-comment">-- A list of mutually-recursive groups;</span><span>
</span><span id="line-218"></span><span>                </span><span class="hs-comment">-- This includes `InstDecl`s as well;</span><span>
</span><span id="line-219"></span><span>                </span><span class="hs-comment">-- Parser generates a singleton list;</span><span>
</span><span id="line-220"></span><span>                </span><span class="hs-comment">-- renamer does dependency analysis</span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span>        </span><span id="hs_derivds"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; [LDerivDecl p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_derivds"><span class="hs-identifier hs-var hs-var">hs_derivds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDerivDecl"><span class="hs-identifier hs-type">LDerivDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-223"></span><span>
</span><span id="line-224"></span><span>        </span><span id="hs_fixds"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; [LFixitySig p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_fixds"><span class="hs-identifier hs-var hs-var">hs_fixds</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LFixitySig"><span class="hs-identifier hs-type">LFixitySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-225"></span><span>                </span><span class="hs-comment">-- A list of fixity signatures defined for top-level</span><span>
</span><span id="line-226"></span><span>                </span><span class="hs-comment">-- declarations and class methods (defined outside of the class</span><span>
</span><span id="line-227"></span><span>                </span><span class="hs-comment">-- itself).</span><span>
</span><span id="line-228"></span><span>                </span><span class="hs-comment">-- See Note [Top-level fixity signatures in an HsGroup]</span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span>        </span><span id="hs_defds"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; [LDefaultDecl p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_defds"><span class="hs-identifier hs-var hs-var">hs_defds</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDefaultDecl"><span class="hs-identifier hs-type">LDefaultDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-231"></span><span>        </span><span id="hs_fords"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; [LForeignDecl p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_fords"><span class="hs-identifier hs-var hs-var">hs_fords</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LForeignDecl"><span class="hs-identifier hs-type">LForeignDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-232"></span><span>        </span><span id="hs_warnds"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; [LWarnDecls p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_warnds"><span class="hs-identifier hs-var hs-var">hs_warnds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LWarnDecls"><span class="hs-identifier hs-type">LWarnDecls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-233"></span><span>        </span><span id="hs_annds"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; [LAnnDecl p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_annds"><span class="hs-identifier hs-var hs-var">hs_annds</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LAnnDecl"><span class="hs-identifier hs-type">LAnnDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-234"></span><span>        </span><span id="hs_ruleds"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; [LRuleDecls p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_ruleds"><span class="hs-identifier hs-var hs-var">hs_ruleds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRuleDecls"><span class="hs-identifier hs-type">LRuleDecls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-235"></span><span>
</span><span id="line-236"></span><span>        </span><span id="hs_docs"><span class="annot"><span class="annottext">forall p. HsGroup p -&gt; [LDocDecl p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_docs"><span class="hs-identifier hs-var hs-var">hs_docs</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDocDecl"><span class="hs-identifier hs-type">LDocDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-237"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-238"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsGroup"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XHsGroup"><span class="hs-identifier hs-var">XHsGroup</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsGroup"><span class="hs-identifier hs-type">XXHsGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596333"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-239"></span><span>
</span><span id="line-240"></span><span>
</span><span id="line-241"></span><span id="local-6989586621681596359"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#hsGroupInstDecls"><span class="hs-identifier hs-type">hsGroupInstDecls</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsGroup"><span class="hs-identifier hs-type">HsGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596359"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LInstDecl"><span class="hs-identifier hs-type">LInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596359"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-242"></span><span id="hsGroupInstDecls"><span class="annot"><span class="annottext">hsGroupInstDecls :: forall id. HsGroup id -&gt; [LInstDecl id]
</span><a href="Language.Haskell.Syntax.Decls.html#hsGroupInstDecls"><span class="hs-identifier hs-var hs-var">hsGroupInstDecls</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyClGroup id -&gt; [XRec id (InstDecl id)])
-&gt; [TyClGroup id] -&gt; [XRec id (InstDecl id)]
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%3D%3C%3C/GHC.Base.html#%3D%3C%3C"><span class="hs-operator hs-var">(=&lt;&lt;)</span></a></span><span> </span><span class="annot"><span class="annottext">TyClGroup id -&gt; [XRec id (InstDecl id)]
forall pass. TyClGroup pass -&gt; [LInstDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#group_instds"><span class="hs-identifier hs-var">group_instds</span></a></span><span> </span><span class="annot"><span class="annottext">([TyClGroup id] -&gt; [XRec id (InstDecl id)])
-&gt; (HsGroup id -&gt; [TyClGroup id])
-&gt; HsGroup id
-&gt; [XRec id (InstDecl id)]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">HsGroup id -&gt; [TyClGroup id]
forall p. HsGroup p -&gt; [TyClGroup p]
</span><a href="Language.Haskell.Syntax.Decls.html#hs_tyclds"><span class="hs-identifier hs-var">hs_tyclds</span></a></span><span>
</span><span id="line-243"></span><span>
</span><span id="line-244"></span><span class="annot"><span class="hs-comment">-- | Located Splice Declaration</span></span><span>
</span><span id="line-245"></span><span class="hs-keyword">type</span><span> </span><span id="LSpliceDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LSpliceDecl"><span class="hs-identifier hs-var">LSpliceDecl</span></a></span></span><span> </span><span id="local-6989586621681596963"><span class="annot"><a href="#local-6989586621681596963"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596963"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SpliceDecl"><span class="hs-identifier hs-type">SpliceDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596963"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-246"></span><span>
</span><span id="line-247"></span><span class="annot"><span class="hs-comment">-- | Splice Declaration</span></span><span>
</span><span id="line-248"></span><span class="hs-keyword">data</span><span> </span><span id="SpliceDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SpliceDecl"><span class="hs-identifier hs-var">SpliceDecl</span></a></span></span><span> </span><span id="local-6989586621681596964"><span class="annot"><a href="#local-6989586621681596964"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-249"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="SpliceDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SpliceDecl"><span class="hs-identifier hs-var">SpliceDecl</span></a></span></span><span>                  </span><span class="hs-comment">-- Top level splice</span><span>
</span><span id="line-250"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSpliceDecl"><span class="hs-identifier hs-type">XSpliceDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596964"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-251"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596964"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSplice"><span class="hs-identifier hs-type">HsUntypedSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596964"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-252"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SpliceDecoration"><span class="hs-identifier hs-type">SpliceDecoration</span></a></span><span> </span><span class="hs-comment">-- Whether $( ) variant found, for pretty printing</span><span>
</span><span id="line-253"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XSpliceDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XSpliceDecl"><span class="hs-identifier hs-var">XSpliceDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXSpliceDecl"><span class="hs-identifier hs-type">XXSpliceDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596964"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-254"></span><span>
</span><span id="line-255"></span><span class="hs-comment">-- | A splice can appear with various decorations wrapped around it. This data</span><span>
</span><span id="line-256"></span><span class="hs-comment">-- type captures explicitly how it was originally written, for use in the pretty</span><span>
</span><span id="line-257"></span><span class="hs-comment">-- printer.</span><span>
</span><span id="line-258"></span><span class="hs-keyword">data</span><span> </span><span id="SpliceDecoration"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SpliceDecoration"><span class="hs-identifier hs-var">SpliceDecoration</span></a></span></span><span>
</span><span id="line-259"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DollarSplice"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DollarSplice"><span class="hs-identifier hs-var">DollarSplice</span></a></span></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ $splice</span></span><span>
</span><span id="line-260"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BareSplice"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#BareSplice"><span class="hs-identifier hs-var">BareSplice</span></a></span></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ bare splice</span></span><span>
</span><span id="line-261"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621681596974"><span id="local-6989586621681596976"><span id="local-6989586621681596978"><span id="local-6989586621681596980"><span id="local-6989586621681596982"><span id="local-6989586621681596988"><span id="local-6989586621681596993"><span id="local-6989586621681596996"><span id="local-6989586621681596999"><span id="local-6989586621681597002"><span id="local-6989586621681597005"><span id="local-6989586621681597008"><span id="local-6989586621681597013"><span id="local-6989586621681597018"><span class="annot"><span class="annottext">Typeable SpliceDecoration
Typeable SpliceDecoration =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; SpliceDecoration -&gt; c SpliceDecoration)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SpliceDecoration)
-&gt; (SpliceDecoration -&gt; Constr)
-&gt; (SpliceDecoration -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SpliceDecoration))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c SpliceDecoration))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; SpliceDecoration -&gt; SpliceDecoration)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; SpliceDecoration -&gt; m SpliceDecoration)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; SpliceDecoration -&gt; m SpliceDecoration)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; SpliceDecoration -&gt; m SpliceDecoration)
-&gt; Data SpliceDecoration
SpliceDecoration -&gt; Constr
SpliceDecoration -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; SpliceDecoration -&gt; SpliceDecoration
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SpliceDecoration
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SpliceDecoration -&gt; c SpliceDecoration
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SpliceDecoration)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SpliceDecoration)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SpliceDecoration -&gt; c SpliceDecoration
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SpliceDecoration -&gt; c SpliceDecoration
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SpliceDecoration
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SpliceDecoration
$ctoConstr :: SpliceDecoration -&gt; Constr
toConstr :: SpliceDecoration -&gt; Constr
$cdataTypeOf :: SpliceDecoration -&gt; DataType
dataTypeOf :: SpliceDecoration -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SpliceDecoration)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SpliceDecoration)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SpliceDecoration)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SpliceDecoration)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; SpliceDecoration -&gt; SpliceDecoration
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; SpliceDecoration -&gt; SpliceDecoration
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
</span><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681597024"><span id="local-6989586621681597026"><span class="annot"><span class="annottext">SpliceDecoration -&gt; SpliceDecoration -&gt; Bool
(SpliceDecoration -&gt; SpliceDecoration -&gt; Bool)
-&gt; (SpliceDecoration -&gt; SpliceDecoration -&gt; Bool)
-&gt; Eq SpliceDecoration
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: SpliceDecoration -&gt; SpliceDecoration -&gt; Bool
== :: SpliceDecoration -&gt; SpliceDecoration -&gt; Bool
$c/= :: SpliceDecoration -&gt; SpliceDecoration -&gt; Bool
/= :: SpliceDecoration -&gt; SpliceDecoration -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681597031"><span id="local-6989586621681597033"><span id="local-6989586621681597037"><span class="annot"><span class="annottext">Int -&gt; SpliceDecoration -&gt; ShowS
[SpliceDecoration] -&gt; ShowS
SpliceDecoration -&gt; String
(Int -&gt; SpliceDecoration -&gt; ShowS)
-&gt; (SpliceDecoration -&gt; String)
-&gt; ([SpliceDecoration] -&gt; ShowS)
-&gt; Show SpliceDecoration
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; SpliceDecoration -&gt; ShowS
showsPrec :: Int -&gt; SpliceDecoration -&gt; ShowS
$cshow :: SpliceDecoration -&gt; String
show :: SpliceDecoration -&gt; String
$cshowList :: [SpliceDecoration] -&gt; ShowS
showList :: [SpliceDecoration] -&gt; ShowS
</span><a href="../../base-4.18.2.1/src/GHC.Show.html#Show/GHC.Show.html#Show"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></a></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-262"></span><span>
</span><span id="line-263"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
            Type and class declarations
*                                                                      *
************************************************************************

Note [The Naming story]
~~~~~~~~~~~~~~~~~~~~~~~
Here is the story about the implicit names that go with type, class,
and instance decls.  It's a bit tricky, so pay attention!

&quot;Implicit&quot; (or &quot;system&quot;) binders
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Each data type decl defines
        a worker name for each constructor
        to-T and from-T convertors
  Each class decl defines
        a tycon for the class
        a data constructor for that tycon
        the worker for that constructor
        a selector for each superclass

All have occurrence names that are derived uniquely from their parent
declaration.

None of these get separate definitions in an interface file; they are
fully defined by the data or class decl.  But they may *occur* in
interface files, of course.  Any such occurrence must haul in the
relevant type or class decl.

Plan of attack:
 - Ensure they &quot;point to&quot; the parent data/class decl
   when loading that decl from an interface file
   (See RnHiFiles.getSysBinders)

 - When typechecking the decl, we build the implicit TyCons and Ids.
   When doing so we look them up in the name cache (GHC.Rename.Env.lookupSysName),
   to ensure correct module and provenance is set

These are the two places that we have to conjure up the magic derived
names.  (The actual magic is in GHC.Types.Name.Occurrence.mkWorkerOcc, etc.)

Default methods
~~~~~~~~~~~~~~~
 - Occurrence name is derived uniquely from the method name
   E.g. $dmmax

 - If there is a default method name at all, it's recorded in
   the ClassOpSig (in GHC.Hs.Binds), in the DefMethInfo field.
   (DefMethInfo is defined in GHC.Core.Class)

Source-code class decls and interface-code class decls are treated subtly
differently, which has given me a great deal of confusion over the years.
Here's the deal.  (We distinguish the two cases because source-code decls
have (Just binds) in the tcdMeths field, whereas interface decls have Nothing.

In *source-code* class declarations:

 - When parsing, every ClassOpSig gets a DefMeth with a suitable RdrName
   This is done by GHC.Parser.PostProcess.mkClassOpSigDM

 - The renamer renames it to a Name

 - During typechecking, we generate a binding for each $dm for
   which there's a programmer-supplied default method:
        class Foo a where
          op1 :: &lt;type&gt;
          op2 :: &lt;type&gt;
          op1 = ...
   We generate a binding for $dmop1 but not for $dmop2.
   The Class for Foo has a Nothing for op2 and
                         a Just ($dm_op1, VanillaDM) for op1.
   The Name for $dmop2 is simply discarded.

In *interface-file* class declarations:
  - When parsing, we see if there's an explicit programmer-supplied default method
    because there's an '=' sign to indicate it:
        class Foo a where
          op1 = :: &lt;type&gt;       -- NB the '='
          op2   :: &lt;type&gt;
    We use this info to generate a DefMeth with a suitable RdrName for op1,
    and a NoDefMeth for op2
  - The interface file has a separate definition for $dmop1, with unfolding etc.
  - The renamer renames it to a Name.
  - The renamer treats $dmop1 as a free variable of the declaration, so that
    the binding for $dmop1 will be sucked in.  (See RnHsSyn.tyClDeclFVs)
    This doesn't happen for source code class decls, because they *bind* the default method.

Dictionary functions
~~~~~~~~~~~~~~~~~~~~
Each instance declaration gives rise to one dictionary function binding.

The type checker makes up new source-code instance declarations
(e.g. from 'deriving' or generic default methods --- see
GHC.Tc.TyCl.Instance.tcInstDecls1).  So we can't generate the names for
dictionary functions in advance (we don't know how many we need).

On the other hand for interface-file instance declarations, the decl
specifies the name of the dictionary function, and it has a binding elsewhere
in the interface file:
        instance {Eq Int} = dEqInt
        dEqInt :: {Eq Int} &lt;pragma info&gt;

So again we treat source code and interface file code slightly differently.

Source code:
  - Source code instance decls have a Nothing in the (Maybe name) field
    (see data InstDecl below)

  - The typechecker makes up a Local name for the dict fun for any source-code
    instance decl, whether it comes from a source-code instance decl, or whether
    the instance decl is derived from some other construct (e.g. 'deriving').

  - The occurrence name it chooses is derived from the instance decl (just for
    documentation really) --- e.g. dNumInt.  Two dict funs may share a common
    occurrence name, but will have different uniques.  E.g.
        instance Foo [Int]  where ...
        instance Foo [Bool] where ...
    These might both be dFooList

  - The CoreTidy phase externalises the name, and ensures the occurrence name is
    unique (this isn't special to dict funs).  So we'd get dFooList and dFooList1.

  - We can take this relaxed approach (changing the occurrence name later)
    because dict fun Ids are not captured in a TyCon or Class (unlike default
    methods, say).  Instead, they are kept separately in the InstEnv.  This
    makes it easy to adjust them after compiling a module.  (Once we've finished
    compiling that module, they don't change any more.)


Interface file code:
  - The instance decl gives the dict fun name, so the InstDecl has a (Just name)
    in the (Maybe name) field.

  - RnHsSyn.instDeclFVs treats the dict fun name as free in the decl, so that we
    suck in the dfun binding
-}</span><span>
</span><span id="line-401"></span><span>
</span><span id="line-402"></span><span class="annot"><span class="hs-comment">-- | Located Declaration of a Type or Class</span></span><span>
</span><span id="line-403"></span><span class="hs-keyword">type</span><span> </span><span id="LTyClDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyClDecl"><span class="hs-identifier hs-var">LTyClDecl</span></a></span></span><span> </span><span id="local-6989586621681597040"><span class="annot"><a href="#local-6989586621681597040"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597040"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier hs-type">TyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597040"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-404"></span><span>
</span><span id="line-405"></span><span class="annot"><span class="hs-comment">-- | A type or class declaration.</span></span><span>
</span><span id="line-406"></span><span class="hs-keyword">data</span><span> </span><span id="TyClDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier hs-var">TyClDecl</span></a></span></span><span> </span><span id="local-6989586621681596412"><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-407"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | @type/data family T :: *-&gt;*@</span><span>
</span><span id="line-408"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-409"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnType',</span><span>
</span><span id="line-410"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnData',</span><span>
</span><span id="line-411"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnFamily','GHC.Parser.Annotation.AnnDcolon',</span><span>
</span><span id="line-412"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnWhere','GHC.Parser.Annotation.AnnOpenP',</span><span>
</span><span id="line-413"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnDcolon','GHC.Parser.Annotation.AnnCloseP',</span><span>
</span><span id="line-414"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnRarrow',</span><span>
</span><span id="line-415"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnVbar'</span><span>
</span><span id="line-416"></span><span>
</span><span id="line-417"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-418"></span><span>    </span><span id="FamDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamDecl"><span class="hs-identifier hs-var">FamDecl</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="tcdFExt"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; XFamDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdFExt"><span class="hs-identifier hs-var hs-var">tcdFExt</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XFamDecl"><span class="hs-identifier hs-type">XFamDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">,</span><span> </span><span id="tcdFam"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; FamilyDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdFam"><span class="hs-identifier hs-var hs-var">tcdFam</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyDecl"><span class="hs-identifier hs-type">FamilyDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-419"></span><span>
</span><span id="line-420"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | @type@ declaration</span><span>
</span><span id="line-421"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-422"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnType',</span><span>
</span><span id="line-423"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnEqual',</span><span>
</span><span id="line-424"></span><span>
</span><span id="line-425"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-426"></span><span>    </span><span id="SynDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SynDecl"><span class="hs-identifier hs-var">SynDecl</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="tcdSExt"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; XSynDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdSExt"><span class="hs-identifier hs-var hs-var">tcdSExt</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSynDecl"><span class="hs-identifier hs-type">XSynDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span>          </span><span class="annot"><span class="hs-comment">-- ^ Post renamer, FVs</span></span><span>
</span><span id="line-427"></span><span>            </span><span class="hs-special">,</span><span> </span><span id="tcdLName"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; LIdP pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdLName"><span class="hs-identifier hs-var hs-var">tcdLName</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ Type constructor</span></span><span>
</span><span id="line-428"></span><span>            </span><span class="hs-special">,</span><span> </span><span id="tcdTyVars"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; LHsQTyVars pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdTyVars"><span class="hs-identifier hs-var hs-var">tcdTyVars</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsQTyVars"><span class="hs-identifier hs-type">LHsQTyVars</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span>        </span><span class="hs-comment">-- ^ Type variables; for an</span><span>
</span><span id="line-429"></span><span>                                                  </span><span class="hs-comment">-- associated type these</span><span>
</span><span id="line-430"></span><span>                                                  </span><span class="hs-comment">-- include outer binders</span><span>
</span><span id="line-431"></span><span>            </span><span class="hs-special">,</span><span> </span><span id="tcdFixity"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; LexicalFixity
</span><a href="Language.Haskell.Syntax.Decls.html#tcdFixity"><span class="hs-identifier hs-var hs-var">tcdFixity</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier hs-type">LexicalFixity</span></a></span><span>          </span><span class="annot"><span class="hs-comment">-- ^ Fixity used in the declaration</span></span><span>
</span><span id="line-432"></span><span>            </span><span class="hs-special">,</span><span> </span><span id="tcdRhs"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; LHsType pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdRhs"><span class="hs-identifier hs-var hs-var">tcdRhs</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">}</span><span>         </span><span class="annot"><span class="hs-comment">-- ^ RHS of type declaration</span></span><span>
</span><span id="line-433"></span><span>
</span><span id="line-434"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | @data@ declaration</span><span>
</span><span id="line-435"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-436"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnData',</span><span>
</span><span id="line-437"></span><span>    </span><span class="hs-comment">--              'GHC.Parser.Annotation.AnnFamily',</span><span>
</span><span id="line-438"></span><span>    </span><span class="hs-comment">--              'GHC.Parser.Annotation.AnnNewType',</span><span>
</span><span id="line-439"></span><span>    </span><span class="hs-comment">--              'GHC.Parser.Annotation.AnnNewType','GHC.Parser.Annotation.AnnDcolon'</span><span>
</span><span id="line-440"></span><span>    </span><span class="hs-comment">--              'GHC.Parser.Annotation.AnnWhere',</span><span>
</span><span id="line-441"></span><span>
</span><span id="line-442"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-443"></span><span>    </span><span id="DataDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataDecl"><span class="hs-identifier hs-var">DataDecl</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="tcdDExt"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; XDataDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdDExt"><span class="hs-identifier hs-var hs-var">tcdDExt</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDataDecl"><span class="hs-identifier hs-type">XDataDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ Post renamer, CUSK flag, FVs</span></span><span>
</span><span id="line-444"></span><span>             </span><span class="hs-special">,</span><span> </span><span id="tcdLName"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tcdLName"><span class="hs-identifier hs-var">tcdLName</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span>             </span><span class="annot"><span class="hs-comment">-- ^ Type constructor</span></span><span>
</span><span id="line-445"></span><span>             </span><span class="hs-special">,</span><span> </span><span id="tcdTyVars"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tcdTyVars"><span class="hs-identifier hs-var">tcdTyVars</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsQTyVars"><span class="hs-identifier hs-type">LHsQTyVars</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span>      </span><span class="hs-comment">-- ^ Type variables</span><span>
</span><span id="line-446"></span><span>                              </span><span class="hs-comment">-- See Note [TyVar binders for associated decls]</span><span>
</span><span id="line-447"></span><span>             </span><span class="hs-special">,</span><span> </span><span id="tcdFixity"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tcdFixity"><span class="hs-identifier hs-var">tcdFixity</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier hs-type">LexicalFixity</span></a></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ Fixity used in the declaration</span></span><span>
</span><span id="line-448"></span><span>             </span><span class="hs-special">,</span><span> </span><span id="tcdDataDefn"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; HsDataDefn pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdDataDefn"><span class="hs-identifier hs-var hs-var">tcdDataDefn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDataDefn"><span class="hs-identifier hs-type">HsDataDefn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-449"></span><span>
</span><span id="line-450"></span><span>    </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnClass',</span><span>
</span><span id="line-451"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnWhere','GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-452"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-453"></span><span>    </span><span class="hs-comment">--   - The tcdFDs will have 'GHC.Parser.Annotation.AnnVbar',</span><span>
</span><span id="line-454"></span><span>    </span><span class="hs-comment">--                          'GHC.Parser.Annotation.AnnComma'</span><span>
</span><span id="line-455"></span><span>    </span><span class="hs-comment">--                          'GHC.Parser.Annotation.AnnRarrow'</span><span>
</span><span id="line-456"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-457"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ClassDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClassDecl"><span class="hs-identifier hs-var">ClassDecl</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="tcdCExt"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; XClassDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdCExt"><span class="hs-identifier hs-var hs-var">tcdCExt</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XClassDecl"><span class="hs-identifier hs-type">XClassDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">,</span><span>         </span><span class="annot"><span class="hs-comment">-- ^ Post renamer, FVs</span></span><span>
</span><span id="line-458"></span><span>                </span><span id="tcdLayout"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; LayoutInfo pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdLayout"><span class="hs-identifier hs-var hs-var">tcdLayout</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LayoutInfo"><span class="hs-identifier hs-type">LayoutInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>      </span><span class="hs-comment">-- ^ Explicit or virtual braces</span><span>
</span><span id="line-459"></span><span>                              </span><span class="hs-comment">-- See Note [Class LayoutInfo]</span><span>
</span><span id="line-460"></span><span>                </span><span id="tcdCtxt"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; Maybe (LHsContext pass)
</span><a href="Language.Haskell.Syntax.Decls.html#tcdCtxt"><span class="hs-identifier hs-var hs-var">tcdCtxt</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsContext"><span class="hs-identifier hs-type">LHsContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Context...</span></span><span>
</span><span id="line-461"></span><span>                </span><span id="tcdLName"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tcdLName"><span class="hs-identifier hs-var">tcdLName</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">,</span><span>               </span><span class="annot"><span class="hs-comment">-- ^ Name of the class</span></span><span>
</span><span id="line-462"></span><span>                </span><span id="tcdTyVars"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tcdTyVars"><span class="hs-identifier hs-var">tcdTyVars</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsQTyVars"><span class="hs-identifier hs-type">LHsQTyVars</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">,</span><span>         </span><span class="annot"><span class="hs-comment">-- ^ Class type variables</span></span><span>
</span><span id="line-463"></span><span>                </span><span id="tcdFixity"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tcdFixity"><span class="hs-identifier hs-var">tcdFixity</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier hs-type">LexicalFixity</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Fixity used in the declaration</span></span><span>
</span><span id="line-464"></span><span>                </span><span id="tcdFDs"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; [LHsFunDep pass]
</span><a href="Language.Haskell.Syntax.Decls.html#tcdFDs"><span class="hs-identifier hs-var hs-var">tcdFDs</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LHsFunDep"><span class="hs-identifier hs-type">LHsFunDep</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>         </span><span class="annot"><span class="hs-comment">-- ^ Functional deps</span></span><span>
</span><span id="line-465"></span><span>                </span><span id="tcdSigs"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; [LSig pass]
</span><a href="Language.Haskell.Syntax.Decls.html#tcdSigs"><span class="hs-identifier hs-var hs-var">tcdSigs</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>              </span><span class="annot"><span class="hs-comment">-- ^ Methods' signatures</span></span><span>
</span><span id="line-466"></span><span>                </span><span id="tcdMeths"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; LHsBinds pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdMeths"><span class="hs-identifier hs-var hs-var">tcdMeths</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBinds"><span class="hs-identifier hs-type">LHsBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">,</span><span>            </span><span class="annot"><span class="hs-comment">-- ^ Default methods</span></span><span>
</span><span id="line-467"></span><span>                </span><span id="tcdATs"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; [LFamilyDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#tcdATs"><span class="hs-identifier hs-var hs-var">tcdATs</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LFamilyDecl"><span class="hs-identifier hs-type">LFamilyDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>       </span><span class="annot"><span class="hs-comment">-- ^ Associated types;</span></span><span>
</span><span id="line-468"></span><span>                </span><span id="tcdATDefs"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; [LTyFamDefltDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#tcdATDefs"><span class="hs-identifier hs-var hs-var">tcdATDefs</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyFamDefltDecl"><span class="hs-identifier hs-type">LTyFamDefltDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ Associated type defaults</span></span><span>
</span><span id="line-469"></span><span>                </span><span id="tcdDocs"><span class="annot"><span class="annottext">forall pass. TyClDecl pass -&gt; [LDocDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#tcdDocs"><span class="hs-identifier hs-var hs-var">tcdDocs</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDocDecl"><span class="hs-identifier hs-type">LDocDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>           </span><span class="annot"><span class="hs-comment">-- ^ Haddock docs</span></span><span>
</span><span id="line-470"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-471"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XTyClDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XTyClDecl"><span class="hs-identifier hs-var">XTyClDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXTyClDecl"><span class="hs-identifier hs-type">XXTyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596412"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-472"></span><span>
</span><span id="line-473"></span><span class="hs-keyword">data</span><span> </span><span id="FunDep"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FunDep"><span class="hs-identifier hs-var">FunDep</span></a></span></span><span> </span><span id="local-6989586621681597065"><span class="annot"><a href="#local-6989586621681597065"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-474"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="FunDep"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FunDep"><span class="hs-identifier hs-var">FunDep</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCFunDep"><span class="hs-identifier hs-type">XCFunDep</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597065"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-475"></span><span>           </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597065"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-476"></span><span>           </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597065"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-477"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XFunDep"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XFunDep"><span class="hs-identifier hs-var">XFunDep</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXFunDep"><span class="hs-identifier hs-type">XXFunDep</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597065"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-478"></span><span>
</span><span id="line-479"></span><span class="hs-keyword">type</span><span> </span><span id="LHsFunDep"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LHsFunDep"><span class="hs-identifier hs-var">LHsFunDep</span></a></span></span><span> </span><span id="local-6989586621681597070"><span class="annot"><a href="#local-6989586621681597070"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597070"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FunDep"><span class="hs-identifier hs-type">FunDep</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597070"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-480"></span><span>
</span><span id="line-481"></span><span class="hs-comment">{- Note [TyVar binders for associated decls]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For an /associated/ data, newtype, or type-family decl, the LHsQTyVars
/includes/ outer binders.  For example
    class T a where
       data D a c
       type F a b :: *
       type F a b = a -&gt; a
Here the data decl for 'D', and type-family decl for 'F', both include 'a'
in their LHsQTyVars (tcdTyVars and fdTyVars resp).

Ditto any implicit binders in the hsq_implicit field of the LHSQTyVars.

The idea is that the associated type is really a top-level decl in its
own right.  However we are careful to use the same name 'a', so that
we can match things up.

c.f. Note [Associated type tyvar names] in GHC.Core.Class
     Note [Family instance declaration binders]
-}</span><span>
</span><span id="line-501"></span><span>
</span><span id="line-502"></span><span class="hs-comment">{- Note [Class LayoutInfo]
~~~~~~~~~~~~~~~~~~~~~~~~~~
The LayoutInfo is used to associate Haddock comments with parts of the declaration.
Compare the following examples:

    class C a where
      f :: a -&gt; Int
      -- ^ comment on f

    class C a where
      f :: a -&gt; Int
    -- ^ comment on C

Notice how &quot;comment on f&quot; and &quot;comment on C&quot; differ only by indentation level.
Thus we have to record the indentation level of the class declarations.

See also Note [Adding Haddock comments to the syntax tree] in GHC.Parser.PostProcess.Haddock
-}</span><span>
</span><span id="line-520"></span><span>
</span><span id="line-521"></span><span class="hs-comment">-- Simple classifiers for TyClDecl</span><span>
</span><span id="line-522"></span><span class="hs-comment">-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><span>
</span><span id="line-523"></span><span>
</span><span id="line-524"></span><span class="hs-comment">-- | @True@ &lt;=&gt; argument is a @data@\/@newtype@</span><span>
</span><span id="line-525"></span><span class="hs-comment">-- declaration.</span><span>
</span><span id="line-526"></span><span id="local-6989586621681596449"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isDataDecl"><span class="hs-identifier hs-type">isDataDecl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier hs-type">TyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596449"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-527"></span><span id="isDataDecl"><span class="annot"><span class="annottext">isDataDecl :: forall pass. TyClDecl pass -&gt; Bool
</span><a href="Language.Haskell.Syntax.Decls.html#isDataDecl"><span class="hs-identifier hs-var hs-var">isDataDecl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataDecl"><span class="hs-identifier hs-type">DataDecl</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-528"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isDataDecl"><span class="hs-identifier hs-var">isDataDecl</span></a></span><span> </span><span id="local-6989586621681597071"><span class="annot"><span class="annottext">TyClDecl pass
</span><a href="#local-6989586621681597071"><span class="hs-identifier hs-var">_other</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-529"></span><span>
</span><span id="line-530"></span><span class="annot"><span class="hs-comment">-- | type or type instance declaration</span></span><span>
</span><span id="line-531"></span><span id="local-6989586621681597072"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isSynDecl"><span class="hs-identifier hs-type">isSynDecl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier hs-type">TyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597072"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-532"></span><span id="isSynDecl"><span class="annot"><span class="annottext">isSynDecl :: forall pass. TyClDecl pass -&gt; Bool
</span><a href="Language.Haskell.Syntax.Decls.html#isSynDecl"><span class="hs-identifier hs-var hs-var">isSynDecl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#SynDecl"><span class="hs-identifier hs-type">SynDecl</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-533"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isSynDecl"><span class="hs-identifier hs-var">isSynDecl</span></a></span><span> </span><span id="local-6989586621681597073"><span class="annot"><span class="annottext">TyClDecl pass
</span><a href="#local-6989586621681597073"><span class="hs-identifier hs-var">_other</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-534"></span><span>
</span><span id="line-535"></span><span class="annot"><span class="hs-comment">-- | type class</span></span><span>
</span><span id="line-536"></span><span id="local-6989586621681597074"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isClassDecl"><span class="hs-identifier hs-type">isClassDecl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier hs-type">TyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597074"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-537"></span><span id="isClassDecl"><span class="annot"><span class="annottext">isClassDecl :: forall pass. TyClDecl pass -&gt; Bool
</span><a href="Language.Haskell.Syntax.Decls.html#isClassDecl"><span class="hs-identifier hs-var hs-var">isClassDecl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClassDecl"><span class="hs-identifier hs-type">ClassDecl</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-538"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isClassDecl"><span class="hs-identifier hs-var">isClassDecl</span></a></span><span> </span><span class="annot"><span class="annottext">TyClDecl pass
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-539"></span><span>
</span><span id="line-540"></span><span class="annot"><span class="hs-comment">-- | type/data family declaration</span></span><span>
</span><span id="line-541"></span><span id="local-6989586621681597075"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isFamilyDecl"><span class="hs-identifier hs-type">isFamilyDecl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier hs-type">TyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597075"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-542"></span><span id="isFamilyDecl"><span class="annot"><span class="annottext">isFamilyDecl :: forall pass. TyClDecl pass -&gt; Bool
</span><a href="Language.Haskell.Syntax.Decls.html#isFamilyDecl"><span class="hs-identifier hs-var hs-var">isFamilyDecl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamDecl"><span class="hs-identifier hs-type">FamDecl</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-543"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isFamilyDecl"><span class="hs-identifier hs-var">isFamilyDecl</span></a></span><span> </span><span id="local-6989586621681597076"><span class="annot"><span class="annottext">TyClDecl pass
</span><a href="#local-6989586621681597076"><span class="hs-identifier hs-var">_other</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-544"></span><span>
</span><span id="line-545"></span><span class="annot"><span class="hs-comment">-- | type family declaration</span></span><span>
</span><span id="line-546"></span><span id="local-6989586621681597077"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isTypeFamilyDecl"><span class="hs-identifier hs-type">isTypeFamilyDecl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier hs-type">TyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597077"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-547"></span><span id="isTypeFamilyDecl"><span class="annot"><span class="annottext">isTypeFamilyDecl :: forall pass. TyClDecl pass -&gt; Bool
</span><a href="Language.Haskell.Syntax.Decls.html#isTypeFamilyDecl"><span class="hs-identifier hs-var hs-var">isTypeFamilyDecl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamDecl"><span class="hs-identifier hs-type">FamDecl</span></a></span><span> </span><span class="annot"><span class="annottext">XFamDecl pass
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyDecl"><span class="hs-identifier hs-type">FamilyDecl</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">fdInfo :: forall pass. FamilyDecl pass -&gt; FamilyInfo pass
</span><a href="Language.Haskell.Syntax.Decls.html#fdInfo"><span class="hs-identifier hs-var">fdInfo</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681597080"><span class="annot"><span class="annottext">FamilyInfo pass
</span><a href="#local-6989586621681597080"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">FamilyInfo pass
</span><a href="#local-6989586621681597080"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-548"></span><span>  </span><span class="annot"><span class="annottext">FamilyInfo pass
</span><a href="Language.Haskell.Syntax.Decls.html#OpenTypeFamily"><span class="hs-identifier hs-var">OpenTypeFamily</span></a></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-549"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClosedTypeFamily"><span class="hs-identifier hs-type">ClosedTypeFamily</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-550"></span><span>  </span><span class="annot"><span class="annottext">FamilyInfo pass
</span><span class="hs-identifier">_</span></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-551"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isTypeFamilyDecl"><span class="hs-identifier hs-var">isTypeFamilyDecl</span></a></span><span> </span><span class="annot"><span class="annottext">TyClDecl pass
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-552"></span><span>
</span><span id="line-553"></span><span class="annot"><span class="hs-comment">-- | open type family info</span></span><span>
</span><span id="line-554"></span><span id="local-6989586621681596457"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isOpenTypeFamilyInfo"><span class="hs-identifier hs-type">isOpenTypeFamilyInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyInfo"><span class="hs-identifier hs-type">FamilyInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596457"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-555"></span><span id="isOpenTypeFamilyInfo"><span class="annot"><span class="annottext">isOpenTypeFamilyInfo :: forall pass. FamilyInfo pass -&gt; Bool
</span><a href="Language.Haskell.Syntax.Decls.html#isOpenTypeFamilyInfo"><span class="hs-identifier hs-var hs-var">isOpenTypeFamilyInfo</span></a></span></span><span> </span><span class="annot"><span class="annottext">FamilyInfo pass
</span><a href="Language.Haskell.Syntax.Decls.html#OpenTypeFamily"><span class="hs-identifier hs-var">OpenTypeFamily</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-556"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isOpenTypeFamilyInfo"><span class="hs-identifier hs-var">isOpenTypeFamilyInfo</span></a></span><span> </span><span class="annot"><span class="annottext">FamilyInfo pass
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-557"></span><span>
</span><span id="line-558"></span><span class="annot"><span class="hs-comment">-- | closed type family info</span></span><span>
</span><span id="line-559"></span><span id="local-6989586621681597083"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isClosedTypeFamilyInfo"><span class="hs-identifier hs-type">isClosedTypeFamilyInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyInfo"><span class="hs-identifier hs-type">FamilyInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597083"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-560"></span><span id="isClosedTypeFamilyInfo"><span class="annot"><span class="annottext">isClosedTypeFamilyInfo :: forall pass. FamilyInfo pass -&gt; Bool
</span><a href="Language.Haskell.Syntax.Decls.html#isClosedTypeFamilyInfo"><span class="hs-identifier hs-var hs-var">isClosedTypeFamilyInfo</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClosedTypeFamily"><span class="hs-identifier hs-type">ClosedTypeFamily</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-561"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isClosedTypeFamilyInfo"><span class="hs-identifier hs-var">isClosedTypeFamilyInfo</span></a></span><span> </span><span class="annot"><span class="annottext">FamilyInfo pass
</span><span class="hs-identifier">_</span></span><span>                     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-562"></span><span>
</span><span id="line-563"></span><span class="annot"><span class="hs-comment">-- | data family declaration</span></span><span>
</span><span id="line-564"></span><span id="local-6989586621681597084"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isDataFamilyDecl"><span class="hs-identifier hs-type">isDataFamilyDecl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier hs-type">TyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597084"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-565"></span><span id="isDataFamilyDecl"><span class="annot"><span class="annottext">isDataFamilyDecl :: forall pass. TyClDecl pass -&gt; Bool
</span><a href="Language.Haskell.Syntax.Decls.html#isDataFamilyDecl"><span class="hs-identifier hs-var hs-var">isDataFamilyDecl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamDecl"><span class="hs-identifier hs-type">FamDecl</span></a></span><span> </span><span class="annot"><span class="annottext">XFamDecl pass
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyDecl"><span class="hs-identifier hs-type">FamilyDecl</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">fdInfo :: forall pass. FamilyDecl pass -&gt; FamilyInfo pass
</span><a href="Language.Haskell.Syntax.Decls.html#fdInfo"><span class="hs-identifier hs-var">fdInfo</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FamilyInfo pass
</span><a href="Language.Haskell.Syntax.Decls.html#DataFamily"><span class="hs-identifier hs-var">DataFamily</span></a></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-566"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isDataFamilyDecl"><span class="hs-identifier hs-var">isDataFamilyDecl</span></a></span><span> </span><span id="local-6989586621681597086"><span class="annot"><span class="annottext">TyClDecl pass
</span><a href="#local-6989586621681597086"><span class="hs-identifier hs-var">_other</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-567"></span><span>
</span><span id="line-568"></span><span class="hs-comment">-- Dealing with names</span><span>
</span><span id="line-569"></span><span>
</span><span id="line-570"></span><span id="local-6989586621681597087"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClDeclTyVars"><span class="hs-identifier hs-type">tyClDeclTyVars</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClDecl"><span class="hs-identifier hs-type">TyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597087"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsQTyVars"><span class="hs-identifier hs-type">LHsQTyVars</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597087"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-571"></span><span id="tyClDeclTyVars"><span class="annot"><span class="annottext">tyClDeclTyVars :: forall pass. TyClDecl pass -&gt; LHsQTyVars pass
</span><a href="Language.Haskell.Syntax.Decls.html#tyClDeclTyVars"><span class="hs-identifier hs-var hs-var">tyClDeclTyVars</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamDecl"><span class="hs-identifier hs-type">FamDecl</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">tcdFam :: forall pass. TyClDecl pass -&gt; FamilyDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdFam"><span class="hs-identifier hs-var">tcdFam</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyDecl"><span class="hs-identifier hs-type">FamilyDecl</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">fdTyVars :: forall pass. FamilyDecl pass -&gt; LHsQTyVars pass
</span><a href="Language.Haskell.Syntax.Decls.html#fdTyVars"><span class="hs-identifier hs-var">fdTyVars</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681597089"><span class="annot"><span class="annottext">LHsQTyVars pass
</span><a href="#local-6989586621681597089"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LHsQTyVars pass
</span><a href="#local-6989586621681597089"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-572"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClDeclTyVars"><span class="hs-identifier hs-var">tyClDeclTyVars</span></a></span><span> </span><span id="local-6989586621681597090"><span class="annot"><span class="annottext">TyClDecl pass
</span><a href="#local-6989586621681597090"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyClDecl pass -&gt; LHsQTyVars pass
forall pass. TyClDecl pass -&gt; LHsQTyVars pass
</span><a href="Language.Haskell.Syntax.Decls.html#tcdTyVars"><span class="hs-identifier hs-var">tcdTyVars</span></a></span><span> </span><span class="annot"><span class="annottext">TyClDecl pass
</span><a href="#local-6989586621681597090"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-573"></span><span>
</span><span id="line-574"></span><span>
</span><span id="line-575"></span><span class="hs-comment">{- Note [CUSKs: complete user-supplied kind signatures]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We kind-check declarations differently if they have a complete, user-supplied
kind signature (CUSK). This is because we can safely generalise a CUSKed
declaration before checking all of the others, supporting polymorphic recursion.
See https://gitlab.haskell.org/ghc/ghc/wikis/ghc-kinds/kind-inference#proposed-new-strategy
and #9200 for lots of discussion of how we got here.

The detection of CUSKs is enabled by the -XCUSKs extension, switched on by default.
Under -XNoCUSKs, all declarations are treated as if they have no CUSK.
See https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0036-kind-signatures.rst

PRINCIPLE:
  a type declaration has a CUSK iff we could produce a separate kind signature
  for it, just like a type signature for a function,
  looking only at the header of the declaration.

Examples:
  * data T1 (a :: *-&gt;*) (b :: *) = ....
    -- Has CUSK; equivalent to   T1 :: (*-&gt;*) -&gt; * -&gt; *

 * data T2 a b = ...
   -- No CUSK; we do not want to guess T2 :: * -&gt; * -&gt; *
   -- because the full decl might be   data T a b = MkT (a b)

  * data T3 (a :: k -&gt; *) (b :: *) = ...
    -- CUSK; equivalent to   T3 :: (k -&gt; *) -&gt; * -&gt; *
    -- We lexically generalise over k to get
    --    T3 :: forall k. (k -&gt; *) -&gt; * -&gt; *
    -- The generalisation is here is purely lexical, just like
    --    f3 :: a -&gt; a
    -- means
    --    f3 :: forall a. a -&gt; a

  * data T4 (a :: j k) = ...
     -- CUSK; equivalent to   T4 :: j k -&gt; *
     -- which we lexically generalise to  T4 :: forall j k. j k -&gt; *
     -- and then, if PolyKinds is on, we further generalise to
     --   T4 :: forall kk (j :: kk -&gt; *) (k :: kk). j k -&gt; *
     -- Again this is exactly like what happens as the term level
     -- when you write
     --    f4 :: forall a b. a b -&gt; Int

NOTE THAT
  * A CUSK does /not/ mean that everything about the kind signature is
    fully specified by the user.  Look at T4 and f4: we had to do kind
    inference to figure out the kind-quantification.  But in both cases
    (T4 and f4) that inference is done looking /only/ at the header of T4
    (or signature for f4), not at the definition thereof.

  * The CUSK completely fixes the kind of the type constructor, forever.

  * The precise rules, for each declaration form, for whether a declaration
    has a CUSK are given in the user manual section &quot;Complete user-supplied
    kind signatures and polymorphic recursion&quot;.  But they simply implement
    PRINCIPLE above.

  * Open type families are interesting:
      type family T5 a b :: *
    There simply /is/ no accompanying declaration, so that info is all
    we'll ever get.  So we it has a CUSK by definition, and we default
    any un-fixed kind variables to *.

  * Associated types are a bit tricker:
      class C6 a where
         type family T6 a b :: *
         op :: a Int -&gt; Int
    Here C6 does not have a CUSK (in fact we ultimately discover that
    a :: * -&gt; *).  And hence neither does T6, the associated family,
    because we can't fix its kind until we have settled C6.  Another
    way to say it: unlike a top-level, we /may/ discover more about
    a's kind from C6's definition.

  * A data definition with a top-level :: must explicitly bind all
    kind variables to the right of the ::. See test
    dependent/should_compile/KindLevels, which requires this
    case. (Naturally, any kind variable mentioned before the :: should
    not be bound after it.)

    This last point is much more debatable than the others; see
    #15142 comment:22

    Because this is fiddly to check, there is a field in the DataDeclRn
    structure (included in a DataDecl after the renamer) that stores whether
    or not the declaration has a CUSK.
-}</span><span>
</span><span id="line-661"></span><span>
</span><span id="line-662"></span><span>
</span><span id="line-663"></span><span class="annot"><span class="hs-comment">{- *********************************************************************
*                                                                      *
                         TyClGroup
        Strongly connected components of
      type, class, instance, and role declarations
*                                                                      *
********************************************************************* -}</span></span><span>
</span><span id="line-670"></span><span>
</span><span id="line-671"></span><span class="hs-comment">{- Note [TyClGroups and dependency analysis]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A TyClGroup represents a strongly connected components of type/class/instance
decls, together with the role annotations for the type/class declarations.

The hs_tyclds :: [TyClGroup] field of a HsGroup is a dependency-order
sequence of strongly-connected components.

Invariants
 * The type and class declarations, group_tyclds, may depend on each
   other, or earlier TyClGroups, but not on later ones

 * The role annotations, group_roles, are role-annotations for some or
   all of the types and classes in group_tyclds (only).

 * The instance declarations, group_instds, may (and usually will)
   depend on group_tyclds, or on earlier TyClGroups, but not on later
   ones.

See Note [Dependency analysis of type, class, and instance decls]
in GHC.Rename.Module for more info.
-}</span><span>
</span><span id="line-693"></span><span>
</span><span id="line-694"></span><span class="annot"><span class="hs-comment">-- | Type or Class Group</span></span><span>
</span><span id="line-695"></span><span class="hs-keyword">data</span><span> </span><span id="TyClGroup"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClGroup"><span class="hs-identifier hs-var">TyClGroup</span></a></span></span><span> </span><span id="local-6989586621681596367"><span class="annot"><a href="#local-6989586621681596367"><span class="hs-identifier hs-type">pass</span></a></span></span><span>  </span><span class="hs-comment">-- See Note [TyClGroups and dependency analysis]</span><span>
</span><span id="line-696"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="TyClGroup"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClGroup"><span class="hs-identifier hs-var">TyClGroup</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="group_ext"><span class="annot"><span class="annottext">forall pass. TyClGroup pass -&gt; XCTyClGroup pass
</span><a href="Language.Haskell.Syntax.Decls.html#group_ext"><span class="hs-identifier hs-var hs-var">group_ext</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCTyClGroup"><span class="hs-identifier hs-type">XCTyClGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596367"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-697"></span><span>              </span><span class="hs-special">,</span><span> </span><span id="group_tyclds"><span class="annot"><span class="annottext">forall pass. TyClGroup pass -&gt; [LTyClDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#group_tyclds"><span class="hs-identifier hs-var hs-var">group_tyclds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyClDecl"><span class="hs-identifier hs-type">LTyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596367"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-698"></span><span>              </span><span class="hs-special">,</span><span> </span><span id="group_roles"><span class="annot"><span class="annottext">forall pass. TyClGroup pass -&gt; [LRoleAnnotDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#group_roles"><span class="hs-identifier hs-var hs-var">group_roles</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRoleAnnotDecl"><span class="hs-identifier hs-type">LRoleAnnotDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596367"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-699"></span><span>              </span><span class="hs-special">,</span><span> </span><span id="group_kisigs"><span class="annot"><span class="annottext">forall pass. TyClGroup pass -&gt; [LStandaloneKindSig pass]
</span><a href="Language.Haskell.Syntax.Decls.html#group_kisigs"><span class="hs-identifier hs-var hs-var">group_kisigs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LStandaloneKindSig"><span class="hs-identifier hs-type">LStandaloneKindSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596367"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-700"></span><span>              </span><span class="hs-special">,</span><span> </span><span id="group_instds"><span class="annot"><span class="annottext">forall pass. TyClGroup pass -&gt; [LInstDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#group_instds"><span class="hs-identifier hs-var hs-var">group_instds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LInstDecl"><span class="hs-identifier hs-type">LInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596367"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-701"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XTyClGroup"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XTyClGroup"><span class="hs-identifier hs-var">XTyClGroup</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXTyClGroup"><span class="hs-identifier hs-type">XXTyClGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596367"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-702"></span><span>
</span><span id="line-703"></span><span>
</span><span id="line-704"></span><span id="local-6989586621681596471"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClGroupTyClDecls"><span class="hs-identifier hs-type">tyClGroupTyClDecls</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClGroup"><span class="hs-identifier hs-type">TyClGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596471"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyClDecl"><span class="hs-identifier hs-type">LTyClDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596471"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-705"></span><span id="tyClGroupTyClDecls"><span class="annot"><span class="annottext">tyClGroupTyClDecls :: forall pass. [TyClGroup pass] -&gt; [LTyClDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#tyClGroupTyClDecls"><span class="hs-identifier hs-var hs-var">tyClGroupTyClDecls</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyClGroup pass -&gt; [XRec pass (TyClDecl pass)])
-&gt; [TyClGroup pass] -&gt; [XRec pass (TyClDecl pass)]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><a href="../../base-4.18.2.1/src/Data.Foldable.html#concatMap/Data.Foldable.html#concatMap"><span class="hs-identifier hs-var">Data.List.concatMap</span></a></span><span> </span><span class="annot"><span class="annottext">TyClGroup pass -&gt; [XRec pass (TyClDecl pass)]
forall pass. TyClGroup pass -&gt; [LTyClDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#group_tyclds"><span class="hs-identifier hs-var">group_tyclds</span></a></span><span>
</span><span id="line-706"></span><span>
</span><span id="line-707"></span><span id="local-6989586621681596476"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClGroupInstDecls"><span class="hs-identifier hs-type">tyClGroupInstDecls</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClGroup"><span class="hs-identifier hs-type">TyClGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596476"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LInstDecl"><span class="hs-identifier hs-type">LInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596476"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-708"></span><span id="tyClGroupInstDecls"><span class="annot"><span class="annottext">tyClGroupInstDecls :: forall pass. [TyClGroup pass] -&gt; [LInstDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#tyClGroupInstDecls"><span class="hs-identifier hs-var hs-var">tyClGroupInstDecls</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyClGroup pass -&gt; [XRec pass (InstDecl pass)])
-&gt; [TyClGroup pass] -&gt; [XRec pass (InstDecl pass)]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><a href="../../base-4.18.2.1/src/Data.Foldable.html#concatMap/Data.Foldable.html#concatMap"><span class="hs-identifier hs-var">Data.List.concatMap</span></a></span><span> </span><span class="annot"><span class="annottext">TyClGroup pass -&gt; [XRec pass (InstDecl pass)]
forall pass. TyClGroup pass -&gt; [LInstDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#group_instds"><span class="hs-identifier hs-var">group_instds</span></a></span><span>
</span><span id="line-709"></span><span>
</span><span id="line-710"></span><span id="local-6989586621681596478"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClGroupRoleDecls"><span class="hs-identifier hs-type">tyClGroupRoleDecls</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClGroup"><span class="hs-identifier hs-type">TyClGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596478"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRoleAnnotDecl"><span class="hs-identifier hs-type">LRoleAnnotDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596478"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-711"></span><span id="tyClGroupRoleDecls"><span class="annot"><span class="annottext">tyClGroupRoleDecls :: forall pass. [TyClGroup pass] -&gt; [LRoleAnnotDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#tyClGroupRoleDecls"><span class="hs-identifier hs-var hs-var">tyClGroupRoleDecls</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyClGroup pass -&gt; [XRec pass (RoleAnnotDecl pass)])
-&gt; [TyClGroup pass] -&gt; [XRec pass (RoleAnnotDecl pass)]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><a href="../../base-4.18.2.1/src/Data.Foldable.html#concatMap/Data.Foldable.html#concatMap"><span class="hs-identifier hs-var">Data.List.concatMap</span></a></span><span> </span><span class="annot"><span class="annottext">TyClGroup pass -&gt; [XRec pass (RoleAnnotDecl pass)]
forall pass. TyClGroup pass -&gt; [LRoleAnnotDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#group_roles"><span class="hs-identifier hs-var">group_roles</span></a></span><span>
</span><span id="line-712"></span><span>
</span><span id="line-713"></span><span id="local-6989586621681596481"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#tyClGroupKindSigs"><span class="hs-identifier hs-type">tyClGroupKindSigs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyClGroup"><span class="hs-identifier hs-type">TyClGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596481"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LStandaloneKindSig"><span class="hs-identifier hs-type">LStandaloneKindSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596481"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-714"></span><span id="tyClGroupKindSigs"><span class="annot"><span class="annottext">tyClGroupKindSigs :: forall pass. [TyClGroup pass] -&gt; [LStandaloneKindSig pass]
</span><a href="Language.Haskell.Syntax.Decls.html#tyClGroupKindSigs"><span class="hs-identifier hs-var hs-var">tyClGroupKindSigs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyClGroup pass -&gt; [XRec pass (StandaloneKindSig pass)])
-&gt; [TyClGroup pass] -&gt; [XRec pass (StandaloneKindSig pass)]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><a href="../../base-4.18.2.1/src/Data.Foldable.html#concatMap/Data.Foldable.html#concatMap"><span class="hs-identifier hs-var">Data.List.concatMap</span></a></span><span> </span><span class="annot"><span class="annottext">TyClGroup pass -&gt; [XRec pass (StandaloneKindSig pass)]
forall pass. TyClGroup pass -&gt; [LStandaloneKindSig pass]
</span><a href="Language.Haskell.Syntax.Decls.html#group_kisigs"><span class="hs-identifier hs-var">group_kisigs</span></a></span><span>
</span><span id="line-715"></span><span>
</span><span id="line-716"></span><span>
</span><span id="line-717"></span><span class="annot"><span class="hs-comment">{- *********************************************************************
*                                                                      *
               Data and type family declarations
*                                                                      *
********************************************************************* -}</span></span><span>
</span><span id="line-722"></span><span>
</span><span id="line-723"></span><span class="hs-comment">{- Note [FamilyResultSig]
~~~~~~~~~~~~~~~~~~~~~~~~~

This data type represents the return signature of a type family.  Possible
values are:

 * NoSig - the user supplied no return signature:
      type family Id a where ...

 * KindSig - the user supplied the return kind:
      type family Id a :: * where ...

 * TyVarSig - user named the result with a type variable and possibly
   provided a kind signature for that variable:
      type family Id a = r where ...
      type family Id a = (r :: *) where ...

   Naming result of a type family is required if we want to provide
   injectivity annotation for a type family:
      type family Id a = r | r -&gt; a where ...

See also: Note [Injectivity annotation]

Note [Injectivity annotation]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A user can declare a type family to be injective:

   type family Id a = r | r -&gt; a where ...

 * The part after the &quot;|&quot; is called &quot;injectivity annotation&quot;.
 * &quot;r -&gt; a&quot; part is called &quot;injectivity condition&quot;; at the moment terms
   &quot;injectivity annotation&quot; and &quot;injectivity condition&quot; are synonymous
   because we only allow a single injectivity condition.
 * &quot;r&quot; is the &quot;LHS of injectivity condition&quot;. LHS can only contain the
   variable naming the result of a type family.

 * &quot;a&quot; is the &quot;RHS of injectivity condition&quot;. RHS contains space-separated
   type and kind variables representing the arguments of a type
   family. Variables can be omitted if a type family is not injective in
   these arguments. Example:
         type family Foo a b c = d | d -&gt; a c where ...

Note that:
 (a) naming of type family result is required to provide injectivity
     annotation
 (b) for associated types if the result was named then injectivity annotation
     is mandatory. Otherwise result type variable is indistinguishable from
     associated type default.

It is possible that in the future this syntax will be extended to support
more complicated injectivity annotations. For example we could declare that
if we know the result of Plus and one of its arguments we can determine the
other argument:

   type family Plus a b = (r :: Nat) | r a -&gt; b, r b -&gt; a where ...

Here injectivity annotation would consist of two comma-separated injectivity
conditions.

See also Note [Injective type families] in GHC.Core.TyCon
-}</span><span>
</span><span id="line-785"></span><span>
</span><span id="line-786"></span><span class="annot"><span class="hs-comment">-- | Located type Family Result Signature</span></span><span>
</span><span id="line-787"></span><span class="hs-keyword">type</span><span> </span><span id="LFamilyResultSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LFamilyResultSig"><span class="hs-identifier hs-var">LFamilyResultSig</span></a></span></span><span> </span><span id="local-6989586621681597104"><span class="annot"><a href="#local-6989586621681597104"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597104"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyResultSig"><span class="hs-identifier hs-type">FamilyResultSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597104"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-788"></span><span>
</span><span id="line-789"></span><span class="annot"><span class="hs-comment">-- | type Family Result Signature</span></span><span>
</span><span id="line-790"></span><span class="hs-keyword">data</span><span> </span><span id="FamilyResultSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyResultSig"><span class="hs-identifier hs-var">FamilyResultSig</span></a></span></span><span> </span><span id="local-6989586621681597105"><span class="annot"><a href="#local-6989586621681597105"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- see Note [FamilyResultSig]</span><span>
</span><span id="line-791"></span><span>    </span><span id="NoSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#NoSig"><span class="hs-identifier hs-var">NoSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNoSig"><span class="hs-identifier hs-type">XNoSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597105"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-792"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' :</span></span><span>
</span><span id="line-793"></span><span>
</span><span id="line-794"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-795"></span><span>
</span><span id="line-796"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="KindSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#KindSig"><span class="hs-identifier hs-var">KindSig</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCKindSig"><span class="hs-identifier hs-type">XCKindSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597105"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsKind"><span class="hs-identifier hs-type">LHsKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597105"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-797"></span><span>  </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' :</span><span>
</span><span id="line-798"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnOpenP','GHC.Parser.Annotation.AnnDcolon',</span><span>
</span><span id="line-799"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnCloseP'</span><span>
</span><span id="line-800"></span><span>
</span><span id="line-801"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-802"></span><span>
</span><span id="line-803"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TyVarSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyVarSig"><span class="hs-identifier hs-var">TyVarSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTyVarSig"><span class="hs-identifier hs-type">XTyVarSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597105"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTyVarBndr"><span class="hs-identifier hs-type">LHsTyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681597105"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-804"></span><span>  </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' :</span><span>
</span><span id="line-805"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnOpenP','GHC.Parser.Annotation.AnnDcolon',</span><span>
</span><span id="line-806"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnCloseP', 'GHC.Parser.Annotation.AnnEqual'</span><span>
</span><span id="line-807"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XFamilyResultSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XFamilyResultSig"><span class="hs-identifier hs-var">XFamilyResultSig</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXFamilyResultSig"><span class="hs-identifier hs-type">XXFamilyResultSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597105"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-808"></span><span>
</span><span id="line-809"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-810"></span><span>
</span><span id="line-811"></span><span>
</span><span id="line-812"></span><span class="annot"><span class="hs-comment">-- | Located type Family Declaration</span></span><span>
</span><span id="line-813"></span><span class="hs-keyword">type</span><span> </span><span id="LFamilyDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LFamilyDecl"><span class="hs-identifier hs-var">LFamilyDecl</span></a></span></span><span> </span><span id="local-6989586621681597114"><span class="annot"><a href="#local-6989586621681597114"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597114"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyDecl"><span class="hs-identifier hs-type">FamilyDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597114"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-814"></span><span>
</span><span id="line-815"></span><span class="annot"><span class="hs-comment">-- | type Family Declaration</span></span><span>
</span><span id="line-816"></span><span class="hs-keyword">data</span><span> </span><span id="FamilyDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyDecl"><span class="hs-identifier hs-var">FamilyDecl</span></a></span></span><span> </span><span id="local-6989586621681596455"><span class="annot"><a href="#local-6989586621681596455"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="FamilyDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyDecl"><span class="hs-identifier hs-var">FamilyDecl</span></a></span></span><span>
</span><span id="line-817"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="fdExt"><span class="annot"><span class="annottext">forall pass. FamilyDecl pass -&gt; XCFamilyDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#fdExt"><span class="hs-identifier hs-var hs-var">fdExt</span></a></span></span><span>            </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCFamilyDecl"><span class="hs-identifier hs-type">XCFamilyDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596455"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-818"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="fdInfo"><span class="annot"><span class="annottext">forall pass. FamilyDecl pass -&gt; FamilyInfo pass
</span><a href="Language.Haskell.Syntax.Decls.html#fdInfo"><span class="hs-identifier hs-var hs-var">fdInfo</span></a></span></span><span>           </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyInfo"><span class="hs-identifier hs-type">FamilyInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596455"><span class="hs-identifier hs-type">pass</span></a></span><span>              </span><span class="hs-comment">-- type/data, closed/open</span><span>
</span><span id="line-819"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="fdTopLevel"><span class="annot"><span class="annottext">forall pass. FamilyDecl pass -&gt; TopLevelFlag
</span><a href="Language.Haskell.Syntax.Decls.html#fdTopLevel"><span class="hs-identifier hs-var hs-var">fdTopLevel</span></a></span></span><span>       </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#TopLevelFlag"><span class="hs-identifier hs-type">TopLevelFlag</span></a></span><span>                 </span><span class="hs-comment">-- used for printing only</span><span>
</span><span id="line-820"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="fdLName"><span class="annot"><span class="annottext">forall pass. FamilyDecl pass -&gt; LIdP pass
</span><a href="Language.Haskell.Syntax.Decls.html#fdLName"><span class="hs-identifier hs-var hs-var">fdLName</span></a></span></span><span>          </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596455"><span class="hs-identifier hs-type">pass</span></a></span><span>                    </span><span class="hs-comment">-- type constructor</span><span>
</span><span id="line-821"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="fdTyVars"><span class="annot"><span class="annottext">forall pass. FamilyDecl pass -&gt; LHsQTyVars pass
</span><a href="Language.Haskell.Syntax.Decls.html#fdTyVars"><span class="hs-identifier hs-var hs-var">fdTyVars</span></a></span></span><span>         </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsQTyVars"><span class="hs-identifier hs-type">LHsQTyVars</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596455"><span class="hs-identifier hs-type">pass</span></a></span><span>              </span><span class="hs-comment">-- type variables</span><span>
</span><span id="line-822"></span><span>                       </span><span class="hs-comment">-- See Note [TyVar binders for associated decls]</span><span>
</span><span id="line-823"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="fdFixity"><span class="annot"><span class="annottext">forall pass. FamilyDecl pass -&gt; LexicalFixity
</span><a href="Language.Haskell.Syntax.Decls.html#fdFixity"><span class="hs-identifier hs-var hs-var">fdFixity</span></a></span></span><span>         </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier hs-type">LexicalFixity</span></a></span><span>                </span><span class="hs-comment">-- Fixity used in the declaration</span><span>
</span><span id="line-824"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="fdResultSig"><span class="annot"><span class="annottext">forall pass. FamilyDecl pass -&gt; LFamilyResultSig pass
</span><a href="Language.Haskell.Syntax.Decls.html#fdResultSig"><span class="hs-identifier hs-var hs-var">fdResultSig</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LFamilyResultSig"><span class="hs-identifier hs-type">LFamilyResultSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596455"><span class="hs-identifier hs-type">pass</span></a></span><span>        </span><span class="hs-comment">-- result signature</span><span>
</span><span id="line-825"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="fdInjectivityAnn"><span class="annot"><span class="annottext">forall pass. FamilyDecl pass -&gt; Maybe (LInjectivityAnn pass)
</span><a href="Language.Haskell.Syntax.Decls.html#fdInjectivityAnn"><span class="hs-identifier hs-var hs-var">fdInjectivityAnn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LInjectivityAnn"><span class="hs-identifier hs-type">LInjectivityAnn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596455"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- optional injectivity ann</span><span>
</span><span id="line-826"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-827"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XFamilyDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XFamilyDecl"><span class="hs-identifier hs-var">XFamilyDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXFamilyDecl"><span class="hs-identifier hs-type">XXFamilyDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596455"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-828"></span><span>  </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnType',</span><span>
</span><span id="line-829"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnData', 'GHC.Parser.Annotation.AnnFamily',</span><span>
</span><span id="line-830"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnWhere', 'GHC.Parser.Annotation.AnnOpenP',</span><span>
</span><span id="line-831"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnDcolon', 'GHC.Parser.Annotation.AnnCloseP',</span><span>
</span><span id="line-832"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnEqual', 'GHC.Parser.Annotation.AnnRarrow',</span><span>
</span><span id="line-833"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnVbar'</span><span>
</span><span id="line-834"></span><span>
</span><span id="line-835"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-836"></span><span>
</span><span id="line-837"></span><span>
</span><span id="line-838"></span><span class="annot"><span class="hs-comment">-- | Located Injectivity Annotation</span></span><span>
</span><span id="line-839"></span><span class="hs-keyword">type</span><span> </span><span id="LInjectivityAnn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LInjectivityAnn"><span class="hs-identifier hs-var">LInjectivityAnn</span></a></span></span><span> </span><span id="local-6989586621681597123"><span class="annot"><a href="#local-6989586621681597123"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597123"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#InjectivityAnn"><span class="hs-identifier hs-type">InjectivityAnn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597123"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-840"></span><span>
</span><span id="line-841"></span><span class="hs-comment">-- | If the user supplied an injectivity annotation it is represented using</span><span>
</span><span id="line-842"></span><span class="hs-comment">-- InjectivityAnn. At the moment this is a single injectivity condition - see</span><span>
</span><span id="line-843"></span><span class="hs-comment">-- Note [Injectivity annotation]. `Located name` stores the LHS of injectivity</span><span>
</span><span id="line-844"></span><span class="hs-comment">-- condition. `[Located name]` stores the RHS of injectivity condition. Example:</span><span>
</span><span id="line-845"></span><span class="hs-comment">--</span><span>
</span><span id="line-846"></span><span class="hs-comment">--   type family Foo a b c = r | r -&gt; a c where ...</span><span>
</span><span id="line-847"></span><span class="hs-comment">--</span><span>
</span><span id="line-848"></span><span class="hs-comment">-- This will be represented as &quot;InjectivityAnn `r` [`a`, `c`]&quot;</span><span>
</span><span id="line-849"></span><span class="hs-keyword">data</span><span> </span><span id="InjectivityAnn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#InjectivityAnn"><span class="hs-identifier hs-var">InjectivityAnn</span></a></span></span><span> </span><span id="local-6989586621681597124"><span class="annot"><a href="#local-6989586621681597124"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-850"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="InjectivityAnn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#InjectivityAnn"><span class="hs-identifier hs-var">InjectivityAnn</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCInjectivityAnn"><span class="hs-identifier hs-type">XCInjectivityAnn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597124"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-851"></span><span>                   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597124"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597124"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-852"></span><span>  </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' :</span><span>
</span><span id="line-853"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnRarrow', 'GHC.Parser.Annotation.AnnVbar'</span><span>
</span><span id="line-854"></span><span>
</span><span id="line-855"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-856"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XInjectivityAnn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XInjectivityAnn"><span class="hs-identifier hs-var">XInjectivityAnn</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXInjectivityAnn"><span class="hs-identifier hs-type">XXInjectivityAnn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597124"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-857"></span><span>
</span><span id="line-858"></span><span class="hs-keyword">data</span><span> </span><span id="FamilyInfo"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamilyInfo"><span class="hs-identifier hs-var">FamilyInfo</span></a></span></span><span> </span><span id="local-6989586621681597129"><span class="annot"><a href="#local-6989586621681597129"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-859"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DataFamily"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataFamily"><span class="hs-identifier hs-var">DataFamily</span></a></span></span><span>
</span><span id="line-860"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="OpenTypeFamily"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#OpenTypeFamily"><span class="hs-identifier hs-var">OpenTypeFamily</span></a></span></span><span>
</span><span id="line-861"></span><span>     </span><span class="hs-comment">-- | 'Nothing' if we're in an hs-boot file and the user</span><span>
</span><span id="line-862"></span><span>     </span><span class="hs-comment">-- said &quot;type family Foo x where ..&quot;</span><span>
</span><span id="line-863"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ClosedTypeFamily"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClosedTypeFamily"><span class="hs-identifier hs-var">ClosedTypeFamily</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyFamInstEqn"><span class="hs-identifier hs-type">LTyFamInstEqn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597129"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-864"></span><span>
</span><span id="line-865"></span><span>
</span><span id="line-866"></span><span class="annot"><span class="hs-comment">{- *********************************************************************
*                                                                      *
               Data types and data constructors
*                                                                      *
********************************************************************* -}</span></span><span>
</span><span id="line-871"></span><span>
</span><span id="line-872"></span><span class="annot"><span class="hs-comment">-- | Haskell Data type Definition</span></span><span>
</span><span id="line-873"></span><span class="hs-keyword">data</span><span> </span><span id="HsDataDefn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDataDefn"><span class="hs-identifier hs-var">HsDataDefn</span></a></span></span><span> </span><span id="local-6989586621681596496"><span class="annot"><a href="#local-6989586621681596496"><span class="hs-identifier hs-type">pass</span></a></span></span><span>   </span><span class="hs-comment">-- The payload of a data type defn</span><span>
</span><span id="line-874"></span><span>                       </span><span class="hs-comment">-- Used *both* for vanilla data declarations,</span><span>
</span><span id="line-875"></span><span>                       </span><span class="hs-comment">--       *and* for data family instances</span><span>
</span><span id="line-876"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | Declares a data type or newtype, giving its constructors</span><span>
</span><span id="line-877"></span><span>    </span><span class="hs-comment">-- @</span><span>
</span><span id="line-878"></span><span>    </span><span class="hs-comment">--  data/newtype T a = &lt;constrs&gt;</span><span>
</span><span id="line-879"></span><span>    </span><span class="hs-comment">--  data/newtype instance T [a] = &lt;constrs&gt;</span><span>
</span><span id="line-880"></span><span>    </span><span class="hs-comment">-- @</span><span>
</span><span id="line-881"></span><span>    </span><span id="HsDataDefn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDataDefn"><span class="hs-identifier hs-var">HsDataDefn</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="dd_ext"><span class="annot"><span class="annottext">forall pass. HsDataDefn pass -&gt; XCHsDataDefn pass
</span><a href="Language.Haskell.Syntax.Decls.html#dd_ext"><span class="hs-identifier hs-var hs-var">dd_ext</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCHsDataDefn"><span class="hs-identifier hs-type">XCHsDataDefn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596496"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-882"></span><span>                 </span><span id="dd_ctxt"><span class="annot"><span class="annottext">forall pass. HsDataDefn pass -&gt; Maybe (LHsContext pass)
</span><a href="Language.Haskell.Syntax.Decls.html#dd_ctxt"><span class="hs-identifier hs-var hs-var">dd_ctxt</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsContext"><span class="hs-identifier hs-type">LHsContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596496"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Context</span></span><span>
</span><span id="line-883"></span><span>                 </span><span id="dd_cType"><span class="annot"><span class="annottext">forall pass. HsDataDefn pass -&gt; Maybe (XRec pass CType)
</span><a href="Language.Haskell.Syntax.Decls.html#dd_cType"><span class="hs-identifier hs-var hs-var">dd_cType</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596496"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#CType"><span class="hs-identifier hs-type">CType</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-884"></span><span>                 </span><span id="dd_kindSig"><span class="annot"><span class="annottext">forall pass. HsDataDefn pass -&gt; Maybe (LHsKind pass)
</span><a href="Language.Haskell.Syntax.Decls.html#dd_kindSig"><span class="hs-identifier hs-var hs-var">dd_kindSig</span></a></span></span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsKind"><span class="hs-identifier hs-type">LHsKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596496"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-885"></span><span>                     </span><span class="hs-comment">-- ^ Optional kind signature.</span><span>
</span><span id="line-886"></span><span>                     </span><span class="hs-comment">--</span><span>
</span><span id="line-887"></span><span>                     </span><span class="hs-comment">-- @(Just k)@ for a GADT-style @data@,</span><span>
</span><span id="line-888"></span><span>                     </span><span class="hs-comment">-- or @data instance@ decl, with explicit kind sig</span><span>
</span><span id="line-889"></span><span>                     </span><span class="hs-comment">--</span><span>
</span><span id="line-890"></span><span>                     </span><span class="hs-comment">-- Always @Nothing@ for H98-syntax decls</span><span>
</span><span id="line-891"></span><span>
</span><span id="line-892"></span><span>                 </span><span id="dd_cons"><span class="annot"><span class="annottext">forall pass. HsDataDefn pass -&gt; DataDefnCons (LConDecl pass)
</span><a href="Language.Haskell.Syntax.Decls.html#dd_cons"><span class="hs-identifier hs-var hs-var">dd_cons</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataDefnCons"><span class="hs-identifier hs-type">DataDefnCons</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LConDecl"><span class="hs-identifier hs-type">LConDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596496"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-893"></span><span>                     </span><span class="hs-comment">-- ^ Data constructors</span><span>
</span><span id="line-894"></span><span>                     </span><span class="hs-comment">--</span><span>
</span><span id="line-895"></span><span>                     </span><span class="hs-comment">-- For @data T a = T1 | T2 a@</span><span>
</span><span id="line-896"></span><span>                     </span><span class="hs-comment">--   the 'LConDecl's all have 'ConDeclH98'.</span><span>
</span><span id="line-897"></span><span>                     </span><span class="hs-comment">-- For @data T a where { T1 :: T a }@</span><span>
</span><span id="line-898"></span><span>                     </span><span class="hs-comment">--   the 'LConDecls' all have 'ConDeclGADT'.</span><span>
</span><span id="line-899"></span><span>
</span><span id="line-900"></span><span>                 </span><span id="dd_derivs"><span class="annot"><span class="annottext">forall pass. HsDataDefn pass -&gt; HsDeriving pass
</span><a href="Language.Haskell.Syntax.Decls.html#dd_derivs"><span class="hs-identifier hs-var hs-var">dd_derivs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDeriving"><span class="hs-identifier hs-type">HsDeriving</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596496"><span class="hs-identifier hs-type">pass</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ Optional 'deriving' clause</span></span><span>
</span><span id="line-901"></span><span>
</span><span id="line-902"></span><span>             </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-903"></span><span>   </span><span class="hs-special">}</span><span>
</span><span id="line-904"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsDataDefn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XHsDataDefn"><span class="hs-identifier hs-var">XHsDataDefn</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsDataDefn"><span class="hs-identifier hs-type">XXHsDataDefn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596496"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-905"></span><span>
</span><span id="line-906"></span><span class="annot"><span class="hs-comment">-- | Haskell Deriving clause</span></span><span>
</span><span id="line-907"></span><span class="hs-keyword">type</span><span> </span><span id="HsDeriving"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDeriving"><span class="hs-identifier hs-var">HsDeriving</span></a></span></span><span> </span><span id="local-6989586621681597141"><span class="annot"><a href="#local-6989586621681597141"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LHsDerivingClause"><span class="hs-identifier hs-type">LHsDerivingClause</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597141"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-908"></span><span>  </span><span class="hs-comment">-- ^ The optional @deriving@ clauses of a data declaration. &quot;Clauses&quot; is</span><span>
</span><span id="line-909"></span><span>  </span><span class="hs-comment">-- plural because one can specify multiple deriving clauses using the</span><span>
</span><span id="line-910"></span><span>  </span><span class="hs-comment">-- @-XDerivingStrategies@ language extension.</span><span>
</span><span id="line-911"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-912"></span><span>  </span><span class="hs-comment">-- The list of 'LHsDerivingClause's corresponds to exactly what the user</span><span>
</span><span id="line-913"></span><span>  </span><span class="hs-comment">-- requested to derive, in order. If no deriving clauses were specified,</span><span>
</span><span id="line-914"></span><span>  </span><span class="hs-comment">-- the list is empty.</span><span>
</span><span id="line-915"></span><span>
</span><span id="line-916"></span><span class="hs-keyword">type</span><span> </span><span id="LHsDerivingClause"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LHsDerivingClause"><span class="hs-identifier hs-var">LHsDerivingClause</span></a></span></span><span> </span><span id="local-6989586621681597142"><span class="annot"><a href="#local-6989586621681597142"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597142"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDerivingClause"><span class="hs-identifier hs-type">HsDerivingClause</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597142"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-917"></span><span>
</span><span id="line-918"></span><span class="hs-comment">-- | A single @deriving@ clause of a data declaration.</span><span>
</span><span id="line-919"></span><span class="hs-comment">--</span><span>
</span><span id="line-920"></span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' :</span><span>
</span><span id="line-921"></span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnDeriving', 'GHC.Parser.Annotation.AnnStock',</span><span>
</span><span id="line-922"></span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnAnyClass', 'GHC.Parser.Annotation.AnnNewtype',</span><span>
</span><span id="line-923"></span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-924"></span><span class="hs-keyword">data</span><span> </span><span id="HsDerivingClause"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDerivingClause"><span class="hs-identifier hs-var">HsDerivingClause</span></a></span></span><span> </span><span id="local-6989586621681596509"><span class="annot"><a href="#local-6989586621681596509"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-925"></span><span>  </span><span class="hs-comment">-- See Note [Deriving strategies] in GHC.Tc.Deriv</span><span>
</span><span id="line-926"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsDerivingClause"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDerivingClause"><span class="hs-identifier hs-var">HsDerivingClause</span></a></span></span><span>
</span><span id="line-927"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="deriv_clause_ext"><span class="annot"><span class="annottext">forall pass. HsDerivingClause pass -&gt; XCHsDerivingClause pass
</span><a href="Language.Haskell.Syntax.Decls.html#deriv_clause_ext"><span class="hs-identifier hs-var hs-var">deriv_clause_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCHsDerivingClause"><span class="hs-identifier hs-type">XCHsDerivingClause</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596509"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-928"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="deriv_clause_strategy"><span class="annot"><span class="annottext">forall pass. HsDerivingClause pass -&gt; Maybe (LDerivStrategy pass)
</span><a href="Language.Haskell.Syntax.Decls.html#deriv_clause_strategy"><span class="hs-identifier hs-var hs-var">deriv_clause_strategy</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDerivStrategy"><span class="hs-identifier hs-type">LDerivStrategy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596509"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-929"></span><span>      </span><span class="hs-comment">-- ^ The user-specified strategy (if any) to use when deriving</span><span>
</span><span id="line-930"></span><span>      </span><span class="hs-comment">-- 'deriv_clause_tys'.</span><span>
</span><span id="line-931"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="deriv_clause_tys"><span class="annot"><span class="annottext">forall pass. HsDerivingClause pass -&gt; LDerivClauseTys pass
</span><a href="Language.Haskell.Syntax.Decls.html#deriv_clause_tys"><span class="hs-identifier hs-var hs-var">deriv_clause_tys</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDerivClauseTys"><span class="hs-identifier hs-type">LDerivClauseTys</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596509"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-932"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ The types to derive.</span></span><span>
</span><span id="line-933"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-934"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsDerivingClause"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XHsDerivingClause"><span class="hs-identifier hs-var">XHsDerivingClause</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsDerivingClause"><span class="hs-identifier hs-type">XXHsDerivingClause</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596509"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-935"></span><span>
</span><span id="line-936"></span><span class="hs-keyword">type</span><span> </span><span id="LDerivClauseTys"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDerivClauseTys"><span class="hs-identifier hs-var">LDerivClauseTys</span></a></span></span><span> </span><span id="local-6989586621681597149"><span class="annot"><a href="#local-6989586621681597149"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597149"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivClauseTys"><span class="hs-identifier hs-type">DerivClauseTys</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597149"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-937"></span><span>
</span><span id="line-938"></span><span class="hs-comment">-- | The types mentioned in a single @deriving@ clause. This can come in two</span><span>
</span><span id="line-939"></span><span class="hs-comment">-- forms, 'DctSingle' or 'DctMulti', depending on whether the types are</span><span>
</span><span id="line-940"></span><span class="hs-comment">-- surrounded by enclosing parentheses or not. These parentheses are</span><span>
</span><span id="line-941"></span><span class="hs-comment">-- semantically different than 'HsParTy'. For example, @deriving ()@ means</span><span>
</span><span id="line-942"></span><span class="hs-comment">-- \&quot;derive zero classes\&quot; rather than \&quot;derive an instance of the 0-tuple\&quot;.</span><span>
</span><span id="line-943"></span><span class="hs-comment">--</span><span>
</span><span id="line-944"></span><span class="hs-comment">-- 'DerivClauseTys' use 'LHsSigType' because @deriving@ clauses can mention</span><span>
</span><span id="line-945"></span><span class="hs-comment">-- type variables that aren't bound by the datatype, e.g.</span><span>
</span><span id="line-946"></span><span class="hs-comment">--</span><span>
</span><span id="line-947"></span><span class="hs-comment">-- &gt; data T b = ... deriving (C [a])</span><span>
</span><span id="line-948"></span><span class="hs-comment">--</span><span>
</span><span id="line-949"></span><span class="hs-comment">-- should produce a derived instance for @C [a] (T b)@.</span><span>
</span><span id="line-950"></span><span class="hs-keyword">data</span><span> </span><span id="DerivClauseTys"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivClauseTys"><span class="hs-identifier hs-var">DerivClauseTys</span></a></span></span><span> </span><span id="local-6989586621681597153"><span class="annot"><a href="#local-6989586621681597153"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-951"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | A @deriving@ clause with a single type. Moreover, that type can only</span><span>
</span><span id="line-952"></span><span>    </span><span class="hs-comment">-- be a type constructor without any arguments.</span><span>
</span><span id="line-953"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-954"></span><span>    </span><span class="hs-comment">-- Example: @deriving Eq@</span><span>
</span><span id="line-955"></span><span>    </span><span id="DctSingle"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DctSingle"><span class="hs-identifier hs-var">DctSingle</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDctSingle"><span class="hs-identifier hs-type">XDctSingle</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597153"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597153"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-956"></span><span>
</span><span id="line-957"></span><span>    </span><span class="hs-comment">-- | A @deriving@ clause with a comma-separated list of types, surrounded</span><span>
</span><span id="line-958"></span><span>    </span><span class="hs-comment">-- by enclosing parentheses.</span><span>
</span><span id="line-959"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-960"></span><span>    </span><span class="hs-comment">-- Example: @deriving (Eq, C a)@</span><span>
</span><span id="line-961"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DctMulti"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DctMulti"><span class="hs-identifier hs-var">DctMulti</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDctMulti"><span class="hs-identifier hs-type">XDctMulti</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597153"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597153"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-962"></span><span>
</span><span id="line-963"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XDerivClauseTys"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XDerivClauseTys"><span class="hs-identifier hs-var">XDerivClauseTys</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXDerivClauseTys"><span class="hs-identifier hs-type">XXDerivClauseTys</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597153"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-964"></span><span>
</span><span id="line-965"></span><span class="annot"><span class="hs-comment">-- | Located Standalone Kind Signature</span></span><span>
</span><span id="line-966"></span><span class="hs-keyword">type</span><span> </span><span id="LStandaloneKindSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LStandaloneKindSig"><span class="hs-identifier hs-var">LStandaloneKindSig</span></a></span></span><span> </span><span id="local-6989586621681597158"><span class="annot"><a href="#local-6989586621681597158"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597158"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#StandaloneKindSig"><span class="hs-identifier hs-type">StandaloneKindSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597158"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-967"></span><span>
</span><span id="line-968"></span><span class="hs-keyword">data</span><span> </span><span id="StandaloneKindSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#StandaloneKindSig"><span class="hs-identifier hs-var">StandaloneKindSig</span></a></span></span><span> </span><span id="local-6989586621681597159"><span class="annot"><a href="#local-6989586621681597159"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-969"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="StandaloneKindSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#StandaloneKindSig"><span class="hs-identifier hs-var">StandaloneKindSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XStandaloneKindSig"><span class="hs-identifier hs-type">XStandaloneKindSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597159"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-970"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597159"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- Why a single binder? See #16754</span><span>
</span><span id="line-971"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597159"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- Why not LHsSigWcType? See Note [Wildcards in standalone kind signatures]</span><span>
</span><span id="line-972"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XStandaloneKindSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XStandaloneKindSig"><span class="hs-identifier hs-var">XStandaloneKindSig</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXStandaloneKindSig"><span class="hs-identifier hs-type">XXStandaloneKindSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597159"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-973"></span><span>
</span><span id="line-974"></span><span class="hs-comment">{- Note [Wildcards in standalone kind signatures]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Standalone kind signatures enable polymorphic recursion, and it is unclear how
to reconcile this with partial type signatures, so we disallow wildcards in
them.

We reject wildcards in 'rnStandaloneKindSignature' by returning False for
'StandaloneKindSigCtx' in 'wildCardsAllowed'.

The alternative design is to have special treatment for partial standalone kind
signatures, much like we have special treatment for partial type signatures in
terms. However, partial standalone kind signatures are not a proper replacement
for CUSKs, so this would be a separate feature.
-}</span><span>
</span><span id="line-988"></span><span>
</span><span id="line-989"></span><span class="annot"><span class="hs-comment">-- | When we only care whether a data-type declaration is `data` or `newtype`, but not what constructors it has</span></span><span>
</span><span id="line-990"></span><span class="hs-keyword">data</span><span> </span><span id="NewOrData"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#NewOrData"><span class="hs-identifier hs-var">NewOrData</span></a></span></span><span>
</span><span id="line-991"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="NewType"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#NewType"><span class="hs-identifier hs-var">NewType</span></a></span></span><span>                     </span><span class="annot"><span class="hs-comment">-- ^ @newtype Blah ...@</span></span><span>
</span><span id="line-992"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataType"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataType"><span class="hs-identifier hs-var">DataType</span></a></span></span><span>                    </span><span class="annot"><span class="hs-comment">-- ^ @data Blah ...@</span></span><span>
</span><span id="line-993"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span> </span><span id="local-6989586621681597167"><span id="local-6989586621681597169"><span class="annot"><span class="annottext">NewOrData -&gt; NewOrData -&gt; Bool
(NewOrData -&gt; NewOrData -&gt; Bool)
-&gt; (NewOrData -&gt; NewOrData -&gt; Bool) -&gt; Eq NewOrData
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: NewOrData -&gt; NewOrData -&gt; Bool
== :: NewOrData -&gt; NewOrData -&gt; Bool
$c/= :: NewOrData -&gt; NewOrData -&gt; Bool
/= :: NewOrData -&gt; NewOrData -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681597175"><span id="local-6989586621681597177"><span id="local-6989586621681597179"><span id="local-6989586621681597181"><span id="local-6989586621681597183"><span id="local-6989586621681597189"><span id="local-6989586621681597194"><span id="local-6989586621681597197"><span id="local-6989586621681597200"><span id="local-6989586621681597203"><span id="local-6989586621681597206"><span id="local-6989586621681597209"><span id="local-6989586621681597214"><span id="local-6989586621681597219"><span class="annot"><span class="annottext">Typeable NewOrData
Typeable NewOrData =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData)
-&gt; (NewOrData -&gt; Constr)
-&gt; (NewOrData -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData)
-&gt; Data NewOrData
NewOrData -&gt; Constr
NewOrData -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NewOrData -&gt; c NewOrData
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NewOrData
$ctoConstr :: NewOrData -&gt; Constr
toConstr :: NewOrData -&gt; Constr
$cdataTypeOf :: NewOrData -&gt; DataType
dataTypeOf :: NewOrData -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NewOrData)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NewOrData)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; NewOrData -&gt; NewOrData
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NewOrData -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NewOrData -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NewOrData -&gt; m NewOrData
</span><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-special">)</span><span>                </span><span class="hs-comment">-- Needed because Demand derives Eq</span><span>
</span><span id="line-994"></span><span>
</span><span id="line-995"></span><span class="annot"><span class="hs-comment">-- | Whether a data-type declaration is @data@ or @newtype@, and its constructors.</span></span><span>
</span><span id="line-996"></span><span class="hs-keyword">data</span><span> </span><span id="DataDefnCons"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataDefnCons"><span class="hs-identifier hs-var">DataDefnCons</span></a></span></span><span> </span><span id="local-6989586621681597223"><span class="annot"><a href="#local-6989586621681597223"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-997"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="NewTypeCon"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#NewTypeCon"><span class="hs-identifier hs-var">NewTypeCon</span></a></span></span><span>          </span><span class="hs-comment">-- @newtype N x = MkN blah@</span><span>
</span><span id="line-998"></span><span>      </span><span class="annot"><a href="#local-6989586621681597223"><span class="hs-identifier hs-type">a</span></a></span><span>      </span><span class="hs-comment">-- Info about the single data constructor @MkN@</span><span>
</span><span id="line-999"></span><span>
</span><span id="line-1000"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataTypeCons"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataTypeCons"><span class="hs-identifier hs-var">DataTypeCons</span></a></span></span><span>
</span><span id="line-1001"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>   </span><span class="hs-comment">-- True  &lt;=&gt; type data T x = ...</span><span>
</span><span id="line-1002"></span><span>             </span><span class="hs-comment">--           See Note [Type data declarations] in GHC.Rename.Module</span><span>
</span><span id="line-1003"></span><span>             </span><span class="hs-comment">-- False &lt;=&gt; data T x = ...</span><span>
</span><span id="line-1004"></span><span>      </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681597223"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>    </span><span class="hs-comment">-- The (possibly empty) list of data constructors</span><span>
</span><span id="line-1005"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span> </span><span id="local-6989586621681597228"><span id="local-6989586621681597235"><span class="annot"><span class="annottext">DataDefnCons a -&gt; DataDefnCons a -&gt; Bool
(DataDefnCons a -&gt; DataDefnCons a -&gt; Bool)
-&gt; (DataDefnCons a -&gt; DataDefnCons a -&gt; Bool)
-&gt; Eq (DataDefnCons a)
forall a. Eq a =&gt; DataDefnCons a -&gt; DataDefnCons a -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall a. Eq a =&gt; DataDefnCons a -&gt; DataDefnCons a -&gt; Bool
== :: DataDefnCons a -&gt; DataDefnCons a -&gt; Bool
$c/= :: forall a. Eq a =&gt; DataDefnCons a -&gt; DataDefnCons a -&gt; Bool
/= :: DataDefnCons a -&gt; DataDefnCons a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681597244"><span id="local-6989586621681597251"><span id="local-6989586621681597256"><span id="local-6989586621681597258"><span id="local-6989586621681597260"><span id="local-6989586621681597266"><span id="local-6989586621681597272"><span id="local-6989586621681597275"><span id="local-6989586621681597278"><span id="local-6989586621681597281"><span id="local-6989586621681597284"><span id="local-6989586621681597287"><span id="local-6989586621681597292"><span id="local-6989586621681597297"><span class="annot"><span class="annottext">Typeable (DataDefnCons a)
Typeable (DataDefnCons a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; DataDefnCons a -&gt; c (DataDefnCons a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DataDefnCons a))
-&gt; (DataDefnCons a -&gt; Constr)
-&gt; (DataDefnCons a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DataDefnCons a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (DataDefnCons a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; DataDefnCons a -&gt; DataDefnCons a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataDefnCons a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataDefnCons a -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; DataDefnCons a -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DataDefnCons a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DataDefnCons a -&gt; m (DataDefnCons a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DataDefnCons a -&gt; m (DataDefnCons a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DataDefnCons a -&gt; m (DataDefnCons a))
-&gt; Data (DataDefnCons a)
DataDefnCons a -&gt; Constr
DataDefnCons a -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; DataDefnCons a -&gt; DataDefnCons a
forall a. Data a =&gt; Typeable (DataDefnCons a)
forall a. Data a =&gt; DataDefnCons a -&gt; Constr
forall a. Data a =&gt; DataDefnCons a -&gt; DataType
forall a.
Data a =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; DataDefnCons a -&gt; DataDefnCons a
forall a u.
Data a =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DataDefnCons a -&gt; u
forall a u.
Data a =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; DataDefnCons a -&gt; [u]
forall a r r'.
Data a =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataDefnCons a -&gt; r
forall a r r'.
Data a =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataDefnCons a -&gt; r
forall a (m :: * -&gt; *).
(Data a, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DataDefnCons a -&gt; m (DataDefnCons a)
forall a (m :: * -&gt; *).
(Data a, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DataDefnCons a -&gt; m (DataDefnCons a)
forall a (c :: * -&gt; *).
Data a =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DataDefnCons a)
forall a (c :: * -&gt; *).
Data a =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DataDefnCons a -&gt; c (DataDefnCons a)
forall a (t :: * -&gt; *) (c :: * -&gt; *).
(Data a, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DataDefnCons a))
forall a (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data a, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DataDefnCons a))
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DataDefnCons a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DataDefnCons a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataDefnCons a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataDefnCons a -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DataDefnCons a -&gt; m (DataDefnCons a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DataDefnCons a -&gt; m (DataDefnCons a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DataDefnCons a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DataDefnCons a -&gt; c (DataDefnCons a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DataDefnCons a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DataDefnCons a))
$cgfoldl :: forall a (c :: * -&gt; *).
Data a =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DataDefnCons a -&gt; c (DataDefnCons a)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DataDefnCons a -&gt; c (DataDefnCons a)
$cgunfold :: forall a (c :: * -&gt; *).
Data a =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DataDefnCons a)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DataDefnCons a)
$ctoConstr :: forall a. Data a =&gt; DataDefnCons a -&gt; Constr
toConstr :: DataDefnCons a -&gt; Constr
$cdataTypeOf :: forall a. Data a =&gt; DataDefnCons a -&gt; DataType
dataTypeOf :: DataDefnCons a -&gt; DataType
$cdataCast1 :: forall a (t :: * -&gt; *) (c :: * -&gt; *).
(Data a, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DataDefnCons a))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DataDefnCons a))
$cdataCast2 :: forall a (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data a, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DataDefnCons a))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DataDefnCons a))
$cgmapT :: forall a.
Data a =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; DataDefnCons a -&gt; DataDefnCons a
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DataDefnCons a -&gt; DataDefnCons a
$cgmapQl :: forall a r r'.
Data a =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataDefnCons a -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataDefnCons a -&gt; r
$cgmapQr :: forall a r r'.
Data a =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataDefnCons a -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataDefnCons a -&gt; r
$cgmapQ :: forall a u.
Data a =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; DataDefnCons a -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DataDefnCons a -&gt; [u]
$cgmapQi :: forall a u.
Data a =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DataDefnCons a -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DataDefnCons a -&gt; u
$cgmapM :: forall a (m :: * -&gt; *).
(Data a, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DataDefnCons a -&gt; m (DataDefnCons a)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DataDefnCons a -&gt; m (DataDefnCons a)
$cgmapMp :: forall a (m :: * -&gt; *).
(Data a, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DataDefnCons a -&gt; m (DataDefnCons a)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DataDefnCons a -&gt; m (DataDefnCons a)
$cgmapMo :: forall a (m :: * -&gt; *).
(Data a, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DataDefnCons a -&gt; m (DataDefnCons a)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DataDefnCons a -&gt; m (DataDefnCons a)
</span><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681597303"><span id="local-6989586621681597309"><span id="local-6989586621681597314"><span id="local-6989586621681597319"><span id="local-6989586621681597322"><span id="local-6989586621681597325"><span id="local-6989586621681597328"><span id="local-6989586621681597331"><span id="local-6989586621681597334"><span id="local-6989586621681597337"><span id="local-6989586621681597340"><span id="local-6989586621681597343"><span id="local-6989586621681597346"><span id="local-6989586621681597351"><span id="local-6989586621681597356"><span id="local-6989586621681597361"><span id="local-6989586621681597366"><span class="annot"><span class="annottext">(forall m. Monoid m =&gt; DataDefnCons m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataDefnCons a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataDefnCons a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; DataDefnCons a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; DataDefnCons a -&gt; a)
-&gt; (forall a. DataDefnCons a -&gt; [a])
-&gt; (forall a. DataDefnCons a -&gt; Bool)
-&gt; (forall a. DataDefnCons a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; DataDefnCons a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; DataDefnCons a -&gt; a)
-&gt; (forall a. Ord a =&gt; DataDefnCons a -&gt; a)
-&gt; (forall a. Num a =&gt; DataDefnCons a -&gt; a)
-&gt; (forall a. Num a =&gt; DataDefnCons a -&gt; a)
-&gt; Foldable DataDefnCons
forall a. Eq a =&gt; a -&gt; DataDefnCons a -&gt; Bool
forall a. Num a =&gt; DataDefnCons a -&gt; a
forall a. Ord a =&gt; DataDefnCons a -&gt; a
forall m. Monoid m =&gt; DataDefnCons m -&gt; m
forall a. DataDefnCons a -&gt; Bool
forall a. DataDefnCons a -&gt; Int
forall a. DataDefnCons a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; DataDefnCons a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataDefnCons a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
$cfold :: forall m. Monoid m =&gt; DataDefnCons m -&gt; m
fold :: forall m. Monoid m =&gt; DataDefnCons m -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataDefnCons a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataDefnCons a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataDefnCons a -&gt; m
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataDefnCons a -&gt; m
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataDefnCons a -&gt; b
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; DataDefnCons a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; DataDefnCons a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; DataDefnCons a -&gt; a
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; DataDefnCons a -&gt; a
$ctoList :: forall a. DataDefnCons a -&gt; [a]
toList :: forall a. DataDefnCons a -&gt; [a]
$cnull :: forall a. DataDefnCons a -&gt; Bool
null :: forall a. DataDefnCons a -&gt; Bool
$clength :: forall a. DataDefnCons a -&gt; Int
length :: forall a. DataDefnCons a -&gt; Int
$celem :: forall a. Eq a =&gt; a -&gt; DataDefnCons a -&gt; Bool
elem :: forall a. Eq a =&gt; a -&gt; DataDefnCons a -&gt; Bool
$cmaximum :: forall a. Ord a =&gt; DataDefnCons a -&gt; a
maximum :: forall a. Ord a =&gt; DataDefnCons a -&gt; a
$cminimum :: forall a. Ord a =&gt; DataDefnCons a -&gt; a
minimum :: forall a. Ord a =&gt; DataDefnCons a -&gt; a
$csum :: forall a. Num a =&gt; DataDefnCons a -&gt; a
sum :: forall a. Num a =&gt; DataDefnCons a -&gt; a
$cproduct :: forall a. Num a =&gt; DataDefnCons a -&gt; a
product :: forall a. Num a =&gt; DataDefnCons a -&gt; a
</span><a href="../../base-4.18.2.1/src/Data.Foldable.html#Foldable/Data.Foldable.html#Foldable"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681597372"><span id="local-6989586621681597376"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; DataDefnCons a -&gt; DataDefnCons b)
-&gt; (forall a b. a -&gt; DataDefnCons b -&gt; DataDefnCons a)
-&gt; Functor DataDefnCons
forall a b. a -&gt; DataDefnCons b -&gt; DataDefnCons a
forall a b. (a -&gt; b) -&gt; DataDefnCons a -&gt; DataDefnCons b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall a b. (a -&gt; b) -&gt; DataDefnCons a -&gt; DataDefnCons b
fmap :: forall a b. (a -&gt; b) -&gt; DataDefnCons a -&gt; DataDefnCons b
$c&lt;$ :: forall a b. a -&gt; DataDefnCons b -&gt; DataDefnCons a
&lt;$ :: forall a b. a -&gt; DataDefnCons b -&gt; DataDefnCons a
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#Functor/GHC.Base.html#Functor"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681597385"><span id="local-6989586621681597394"><span id="local-6989586621681597400"><span id="local-6989586621681597405"><span class="annot"><span class="annottext">Functor DataDefnCons
Foldable DataDefnCons
(Functor DataDefnCons, Foldable DataDefnCons) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; DataDefnCons a -&gt; f (DataDefnCons b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    DataDefnCons (f a) -&gt; f (DataDefnCons a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; DataDefnCons a -&gt; m (DataDefnCons b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    DataDefnCons (m a) -&gt; m (DataDefnCons a))
-&gt; Traversable DataDefnCons
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
DataDefnCons (m a) -&gt; m (DataDefnCons a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
DataDefnCons (f a) -&gt; f (DataDefnCons a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DataDefnCons a -&gt; m (DataDefnCons b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DataDefnCons a -&gt; f (DataDefnCons b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DataDefnCons a -&gt; f (DataDefnCons b)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DataDefnCons a -&gt; f (DataDefnCons b)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
DataDefnCons (f a) -&gt; f (DataDefnCons a)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
DataDefnCons (f a) -&gt; f (DataDefnCons a)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DataDefnCons a -&gt; m (DataDefnCons b)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DataDefnCons a -&gt; m (DataDefnCons b)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
DataDefnCons (m a) -&gt; m (DataDefnCons a)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
DataDefnCons (m a) -&gt; m (DataDefnCons a)
</span><a href="../../base-4.18.2.1/src/Data.Traversable.html#Traversable/Data.Traversable.html#Traversable"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></a></span></span></span></span></span><span> </span><span class="hs-special">)</span><span>                </span><span class="hs-comment">-- Needed because Demand derives Eq</span><span>
</span><span id="line-1006"></span><span>
</span><span id="line-1007"></span><span id="local-6989586621681596578"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#dataDefnConsNewOrData"><span class="hs-identifier hs-type">dataDefnConsNewOrData</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataDefnCons"><span class="hs-identifier hs-type">DataDefnCons</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596578"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#NewOrData"><span class="hs-identifier hs-type">NewOrData</span></a></span></span><span>
</span><span id="line-1008"></span><span id="dataDefnConsNewOrData"><span class="annot"><span class="annottext">dataDefnConsNewOrData :: forall a. DataDefnCons a -&gt; NewOrData
</span><a href="Language.Haskell.Syntax.Decls.html#dataDefnConsNewOrData"><span class="hs-identifier hs-var hs-var">dataDefnConsNewOrData</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span> </span><span class="hs-glyph">case</span><span>
</span><span id="line-1009"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#NewTypeCon"><span class="hs-identifier hs-type">NewTypeCon</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NewOrData
</span><a href="Language.Haskell.Syntax.Decls.html#NewType"><span class="hs-identifier hs-var">NewType</span></a></span><span>
</span><span id="line-1010"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataTypeCons"><span class="hs-identifier hs-type">DataTypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NewOrData
</span><a href="Language.Haskell.Syntax.Decls.html#DataType"><span class="hs-identifier hs-var">DataType</span></a></span><span>
</span><span id="line-1011"></span><span>
</span><span id="line-1012"></span><span class="hs-comment">-- | Are the constructors within a @type data@ declaration?</span><span>
</span><span id="line-1013"></span><span class="hs-comment">-- See Note [Type data declarations] in GHC.Rename.Module.</span><span>
</span><span id="line-1014"></span><span id="local-6989586621681597411"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isTypeDataDefnCons"><span class="hs-identifier hs-type">isTypeDataDefnCons</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataDefnCons"><span class="hs-identifier hs-type">DataDefnCons</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597411"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1015"></span><span id="isTypeDataDefnCons"><span class="annot"><span class="annottext">isTypeDataDefnCons :: forall a. DataDefnCons a -&gt; Bool
</span><a href="Language.Haskell.Syntax.Decls.html#isTypeDataDefnCons"><span class="hs-identifier hs-var hs-var">isTypeDataDefnCons</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#NewTypeCon"><span class="hs-identifier hs-type">NewTypeCon</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1016"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#isTypeDataDefnCons"><span class="hs-identifier hs-var">isTypeDataDefnCons</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataTypeCons"><span class="hs-identifier hs-type">DataTypeCons</span></a></span><span> </span><span id="local-6989586621681597412"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681597412"><span class="hs-identifier hs-var">is_type_data</span></a></span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681597412"><span class="hs-identifier hs-var">is_type_data</span></a></span><span>
</span><span id="line-1017"></span><span>
</span><span id="line-1018"></span><span class="annot"><span class="hs-comment">-- | Located data Constructor Declaration</span></span><span>
</span><span id="line-1019"></span><span class="hs-keyword">type</span><span> </span><span id="LConDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LConDecl"><span class="hs-identifier hs-var">LConDecl</span></a></span></span><span> </span><span id="local-6989586621681597413"><span class="annot"><a href="#local-6989586621681597413"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597413"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ConDecl"><span class="hs-identifier hs-type">ConDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597413"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1020"></span><span>      </span><span class="hs-comment">-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when</span><span>
</span><span id="line-1021"></span><span>      </span><span class="hs-comment">--   in a GADT constructor list</span><span>
</span><span id="line-1022"></span><span>
</span><span id="line-1023"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1024"></span><span>
</span><span id="line-1025"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-1026"></span><span class="hs-comment">--</span><span>
</span><span id="line-1027"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1028"></span><span class="hs-comment">-- data T b = forall a. Eq a =&gt; MkT a b</span><span>
</span><span id="line-1029"></span><span class="hs-comment">--   MkT :: forall b a. Eq a =&gt; MkT a b</span><span>
</span><span id="line-1030"></span><span class="hs-comment">--</span><span>
</span><span id="line-1031"></span><span class="hs-comment">-- data T b where</span><span>
</span><span id="line-1032"></span><span class="hs-comment">--      MkT1 :: Int -&gt; T Int</span><span>
</span><span id="line-1033"></span><span class="hs-comment">--</span><span>
</span><span id="line-1034"></span><span class="hs-comment">-- data T = Int `MkT` Int</span><span>
</span><span id="line-1035"></span><span class="hs-comment">--        | MkT2</span><span>
</span><span id="line-1036"></span><span class="hs-comment">--</span><span>
</span><span id="line-1037"></span><span class="hs-comment">-- data T a where</span><span>
</span><span id="line-1038"></span><span class="hs-comment">--      Int `MkT` Int :: T Int</span><span>
</span><span id="line-1039"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1040"></span><span class="hs-comment">--</span><span>
</span><span id="line-1041"></span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId's : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-1042"></span><span class="hs-comment">--            'GHC.Parser.Annotation.AnnDotdot','GHC.Parser.Annotation.AnnCLose',</span><span>
</span><span id="line-1043"></span><span class="hs-comment">--            'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnVbar',</span><span>
</span><span id="line-1044"></span><span class="hs-comment">--            'GHC.Parser.Annotation.AnnDarrow','GHC.Parser.Annotation.AnnDarrow',</span><span>
</span><span id="line-1045"></span><span class="hs-comment">--            'GHC.Parser.Annotation.AnnForall','GHC.Parser.Annotation.AnnDot'</span><span>
</span><span id="line-1046"></span><span>
</span><span id="line-1047"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1048"></span><span>
</span><span id="line-1049"></span><span class="annot"><span class="hs-comment">-- | data Constructor Declaration</span></span><span>
</span><span id="line-1050"></span><span class="hs-keyword">data</span><span> </span><span id="ConDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ConDecl"><span class="hs-identifier hs-var">ConDecl</span></a></span></span><span> </span><span id="local-6989586621681596581"><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1051"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ConDeclGADT"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ConDeclGADT"><span class="hs-identifier hs-var">ConDeclGADT</span></a></span></span><span>
</span><span id="line-1052"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="con_g_ext"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; XConDeclGADT pass
</span><a href="Language.Haskell.Syntax.Decls.html#con_g_ext"><span class="hs-identifier hs-var hs-var">con_g_ext</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConDeclGADT"><span class="hs-identifier hs-type">XConDeclGADT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1053"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_names"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; NonEmpty (LIdP pass)
</span><a href="Language.Haskell.Syntax.Decls.html#con_names"><span class="hs-identifier hs-var hs-var">con_names</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#NonEmpty/GHC.Base.html#NonEmpty"><span class="hs-identifier hs-type">NonEmpty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1054"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_dcolon"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; LHsUniToken &quot;::&quot; &quot;\8759&quot; pass
</span><a href="Language.Haskell.Syntax.Decls.html#con_dcolon"><span class="hs-identifier hs-var hs-var">con_dcolon</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsUniToken"><span class="hs-identifier hs-type">LHsUniToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;::&quot;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;&#8759;&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1055"></span><span>      </span><span class="hs-comment">-- The following fields describe the type after the '::'</span><span>
</span><span id="line-1056"></span><span>      </span><span class="hs-comment">-- See Note [GADT abstract syntax]</span><span>
</span><span id="line-1057"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_bndrs"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; XRec pass (HsOuterSigTyVarBndrs pass)
</span><a href="Language.Haskell.Syntax.Decls.html#con_bndrs"><span class="hs-identifier hs-var hs-var">con_bndrs</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterSigTyVarBndrs"><span class="hs-identifier hs-type">HsOuterSigTyVarBndrs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1058"></span><span>        </span><span class="hs-comment">-- ^ The outermost type variable binders, be they explicit or</span><span>
</span><span id="line-1059"></span><span>        </span><span class="hs-comment">--   implicit.  The 'XRec' is used to anchor exact print</span><span>
</span><span id="line-1060"></span><span>        </span><span class="hs-comment">--   annotations, AnnForall and AnnDot.</span><span>
</span><span id="line-1061"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_mb_cxt"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; Maybe (LHsContext pass)
</span><a href="Language.Haskell.Syntax.Decls.html#con_mb_cxt"><span class="hs-identifier hs-var hs-var">con_mb_cxt</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsContext"><span class="hs-identifier hs-type">LHsContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ User-written context (if any)</span></span><span>
</span><span id="line-1062"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_g_args"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; HsConDeclGADTDetails pass
</span><a href="Language.Haskell.Syntax.Decls.html#con_g_args"><span class="hs-identifier hs-var hs-var">con_g_args</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsConDeclGADTDetails"><span class="hs-identifier hs-type">HsConDeclGADTDetails</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ Arguments; never infix</span></span><span>
</span><span id="line-1063"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_res_ty"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; LHsType pass
</span><a href="Language.Haskell.Syntax.Decls.html#con_res_ty"><span class="hs-identifier hs-var hs-var">con_res_ty</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ Result type</span></span><span>
</span><span id="line-1064"></span><span>
</span><span id="line-1065"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_doc"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; Maybe (LHsDoc pass)
</span><a href="Language.Haskell.Syntax.Decls.html#con_doc"><span class="hs-identifier hs-var hs-var">con_doc</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier hs-type">LHsDoc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ A possible Haddock</span><span>
</span><span id="line-1066"></span><span>                                                 </span><span class="hs-comment">-- comment.</span><span>
</span><span id="line-1067"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-1068"></span><span>
</span><span id="line-1069"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ConDeclH98"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ConDeclH98"><span class="hs-identifier hs-var">ConDeclH98</span></a></span></span><span>
</span><span id="line-1070"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="con_ext"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; XConDeclH98 pass
</span><a href="Language.Haskell.Syntax.Decls.html#con_ext"><span class="hs-identifier hs-var hs-var">con_ext</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConDeclH98"><span class="hs-identifier hs-type">XConDeclH98</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1071"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_name"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; LIdP pass
</span><a href="Language.Haskell.Syntax.Decls.html#con_name"><span class="hs-identifier hs-var hs-var">con_name</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1072"></span><span>
</span><span id="line-1073"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_forall"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; Bool
</span><a href="Language.Haskell.Syntax.Decls.html#con_forall"><span class="hs-identifier hs-var hs-var">con_forall</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1074"></span><span>                              </span><span class="hs-comment">-- ^ True &lt;=&gt; explicit user-written forall</span><span>
</span><span id="line-1075"></span><span>                              </span><span class="hs-comment">--     e.g. data T a = forall b. MkT b (b-&gt;a)</span><span>
</span><span id="line-1076"></span><span>                              </span><span class="hs-comment">--     con_ex_tvs = {b}</span><span>
</span><span id="line-1077"></span><span>                              </span><span class="hs-comment">-- False =&gt; con_ex_tvs is empty</span><span>
</span><span id="line-1078"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_ex_tvs"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; [LHsTyVarBndr Specificity pass]
</span><a href="Language.Haskell.Syntax.Decls.html#con_ex_tvs"><span class="hs-identifier hs-var hs-var">con_ex_tvs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTyVarBndr"><span class="hs-identifier hs-type">LHsTyVarBndr</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#Specificity"><span class="hs-identifier hs-type">Specificity</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Existentials only</span></span><span>
</span><span id="line-1079"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_mb_cxt"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#con_mb_cxt"><span class="hs-identifier hs-var">con_mb_cxt</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsContext"><span class="hs-identifier hs-type">LHsContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>         </span><span class="annot"><span class="hs-comment">-- ^ User-written context (if any)</span></span><span>
</span><span id="line-1080"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_args"><span class="annot"><span class="annottext">forall pass. ConDecl pass -&gt; HsConDeclH98Details pass
</span><a href="Language.Haskell.Syntax.Decls.html#con_args"><span class="hs-identifier hs-var hs-var">con_args</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsConDeclH98Details"><span class="hs-identifier hs-type">HsConDeclH98Details</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ Arguments; can be infix</span></span><span>
</span><span id="line-1081"></span><span>
</span><span id="line-1082"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="con_doc"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#con_doc"><span class="hs-identifier hs-var">con_doc</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier hs-type">LHsDoc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ A possible Haddock comment.</span></span><span>
</span><span id="line-1083"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-1084"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XConDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XConDecl"><span class="hs-identifier hs-var">XConDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXConDecl"><span class="hs-identifier hs-type">XXConDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596581"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1085"></span><span>
</span><span id="line-1086"></span><span class="hs-comment">{- Note [GADT abstract syntax]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The types of both forms of GADT constructors are very structured, as they
must consist of the quantified type variables (if provided), followed by the
context (if provided), followed by the argument types (if provided), followed
by the result type. (See &quot;Wrinkle: No nested foralls or contexts&quot; below for
more discussion on the restrictions imposed here.) As a result, instead of
storing the type of a GADT constructor as a single LHsType, we split it up
into its constituent components for easier access.

There are two broad ways to classify GADT constructors:

* Record-syntax constructors. For example:

    data T a where
      K :: forall a. Ord a =&gt; { x :: [a], ... } -&gt; T a

* Prefix constructors, which do not use record syntax. For example:

    data T a where
      K :: forall a. Ord a =&gt; [a] -&gt; ... -&gt; T a

This distinction is recorded in the `con_args :: HsConDetails pass`, which
tracks if we're dealing with a RecCon or PrefixCon. It is easy to distinguish
the two in the AST since record GADT constructors use HsRecTy. This distinction
is made in GHC.Parser.PostProcess.mkGadtDecl.

It is worth elaborating a bit more on the process of splitting the argument
types of a GADT constructor, since there are some non-obvious details involved.
While splitting the argument types of a record GADT constructor is easy (they
are stored in an HsRecTy), splitting the arguments of a prefix GADT constructor
is trickier. The basic idea is that we must split along the outermost function
arrows ((-&gt;) and (%1 -&gt;)) in the type, which GHC.Hs.Type.splitHsFunType
accomplishes. But what about type operators? Consider:

  C :: a :*: b -&gt; a :*: b -&gt; a :+: b

This could parse in many different ways depending on the precedences of each
type operator. In particular, if (:*:) were to have lower precedence than (-&gt;),
then it could very well parse like this:

  a :*: ((b -&gt; a) :*: ((b -&gt; a) :+: b)))

This would give the false impression that the whole type is part of one large
return type, with no arguments. Note that we do not fully resolve the exact
precedences of each user-defined type operator until the renamer, so this a
more difficult task for the parser.

Fortunately, there is no risk of the above happening. GHC's parser gives
special treatment to function arrows, and as a result, they are always parsed
with a lower precedence than any other type operator. As a result, the type
above is actually parsed like this:

  (a :*: b) -&gt; ((a :*: b) -&gt; (a :+: b))

While we won't know the exact precedences of (:*:) and (:+:) until the renamer,
all we are concerned about in the parser is identifying the overall shape of
the argument and result types, which we can accomplish by piggybacking on the
special treatment given to function arrows. In a future where function arrows
aren't given special status in the parser, we will likely have to modify
GHC.Parser.PostProcess.mkHsOpTyPV to preserve this trick.

-----
-- Wrinkle: No nested foralls or contexts
-----

GADT constructors provide some freedom to change the order of foralls in their
types (see Note [DataCon user type variable binders] in GHC.Core.DataCon), but
this freedom is still limited. GADTs still require that all quantification
occurs &quot;prenex&quot;. That is, any explicitly quantified type variables must occur
at the front of the GADT type, followed by any contexts, followed by the body of
the GADT type, in precisely that order. For instance:

  data T where
    MkT1 :: forall a b. (Eq a, Eq b) =&gt; a -&gt; b -&gt; T
      -- OK
    MkT2 :: forall a. Eq a =&gt; forall b. a -&gt; b -&gt; T
      -- Rejected, `forall b` is nested
    MkT3 :: forall a b. Eq a =&gt; Eq b =&gt; a -&gt; b -&gt; T
      -- Rejected, `Eq b` is nested
    MkT4 :: Int -&gt; forall a. a -&gt; T
      -- Rejected, `forall a` is nested
    MkT5 :: forall a. Int -&gt; Eq a =&gt; a -&gt; T
      -- Rejected, `Eq a` is nested
    MkT6 :: (forall a. a -&gt; T)
      -- Rejected, `forall a` is nested due to the surrounding parentheses
    MkT7 :: (Eq a =&gt; a -&gt; t)
      -- Rejected, `Eq a` is nested due to the surrounding parentheses

For the full details, see the &quot;Formal syntax for GADTs&quot; section of the GHC
User's Guide. GHC enforces that GADT constructors do not have nested `forall`s
or contexts in two parts:

1. GHC, in the process of splitting apart a GADT's type,
   extracts out the leading `forall` and context (if they are provided). To
   accomplish this splitting, the renamer uses the
   GHC.Hs.Type.splitLHsGADTPrefixTy function, which is careful not to remove
   parentheses surrounding the leading `forall` or context (as these
   parentheses can be syntactically significant). If the third result returned
   by splitLHsGADTPrefixTy contains any `forall`s or contexts, then they must
   be nested, so they will be rejected.

   Note that this step applies to both prefix and record GADTs alike, as they
   both have syntax which permits `forall`s and contexts. The difference is
   where this step happens:

   * For prefix GADTs, this happens in the renamer (in rnConDecl), as we cannot
     split until after the type operator fixities have been resolved.
   * For record GADTs, this happens in the parser (in mkGadtDecl).
2. If the GADT type is prefix, the renamer (in the ConDeclGADTPrefixPs case of
   rnConDecl) will then check for nested `forall`s/contexts in the body of a
   prefix GADT type, after it has determined what all of the argument types are.
   This step is necessary to catch examples like MkT4 above, where the nested
   quantification occurs after a visible argument type.
-}</span><span>
</span><span id="line-1201"></span><span>
</span><span id="line-1202"></span><span class="annot"><span class="hs-comment">-- | The arguments in a Haskell98-style data constructor.</span></span><span>
</span><span id="line-1203"></span><span class="hs-keyword">type</span><span> </span><span id="HsConDeclH98Details"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsConDeclH98Details"><span class="hs-identifier hs-var">HsConDeclH98Details</span></a></span></span><span> </span><span id="local-6989586621681597429"><span class="annot"><a href="#local-6989586621681597429"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1204"></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsConDetails"><span class="hs-identifier hs-type">HsConDetails</span></a></span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Void/GHC.Base.html#Void"><span class="hs-identifier hs-type">Void</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsScaled"><span class="hs-identifier hs-type">HsScaled</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597429"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LBangType"><span class="hs-identifier hs-type">LBangType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597429"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597429"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LConDeclField"><span class="hs-identifier hs-type">LConDeclField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597429"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1205"></span><span class="hs-comment">-- The Void argument to HsConDetails here is a reflection of the fact that</span><span>
</span><span id="line-1206"></span><span class="hs-comment">-- type applications are not allowed in data constructor declarations.</span><span>
</span><span id="line-1207"></span><span>
</span><span id="line-1208"></span><span class="hs-comment">-- | The arguments in a GADT constructor. Unlike Haskell98-style constructors,</span><span>
</span><span id="line-1209"></span><span class="hs-comment">-- GADT constructors cannot be declared with infix syntax. As a result, we do</span><span>
</span><span id="line-1210"></span><span class="hs-comment">-- not use 'HsConDetails' here, as 'InfixCon' would be an unrepresentable</span><span>
</span><span id="line-1211"></span><span class="hs-comment">-- state. (There is a notion of infix GADT constructors for the purposes of</span><span>
</span><span id="line-1212"></span><span class="hs-comment">-- derived Show instances&#8212;see Note [Infix GADT constructors] in</span><span>
</span><span id="line-1213"></span><span class="hs-comment">-- GHC.Tc.TyCl&#8212;but that is an orthogonal concern.)</span><span>
</span><span id="line-1214"></span><span class="hs-keyword">data</span><span> </span><span id="HsConDeclGADTDetails"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsConDeclGADTDetails"><span class="hs-identifier hs-var">HsConDeclGADTDetails</span></a></span></span><span> </span><span id="local-6989586621681597435"><span class="annot"><a href="#local-6989586621681597435"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1215"></span><span>   </span><span class="hs-glyph">=</span><span> </span><span id="PrefixConGADT"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#PrefixConGADT"><span class="hs-identifier hs-var">PrefixConGADT</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsScaled"><span class="hs-identifier hs-type">HsScaled</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597435"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LBangType"><span class="hs-identifier hs-type">LBangType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597435"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-1216"></span><span>   </span><span class="hs-glyph">|</span><span> </span><span id="RecConGADT"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RecConGADT"><span class="hs-identifier hs-var">RecConGADT</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597435"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LConDeclField"><span class="hs-identifier hs-type">LConDeclField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597435"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsUniToken"><span class="hs-identifier hs-type">LHsUniToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;-&gt;&quot;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;&#8594;&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681597435"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1217"></span><span>
</span><span id="line-1218"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                Instance declarations
*                                                                      *
************************************************************************

Note [Type family instance declarations in HsSyn]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The data type FamEqn represents one equation of a type family instance.
Aside from the pass, it is also parameterised over another field, feqn_rhs.
feqn_rhs is either an HsDataDefn (for data family instances) or an LHsType
(for type family instances).

Type family instances also include associated type family default equations.
That is because a default for a type family looks like this:

  class C a where
    type family F a b :: Type
    type F c d = (c,d)   -- Default instance

The default declaration is really just a `type instance` declaration, but one
with particularly simple patterns: they must all be distinct type variables.
That's because we will instantiate it (in an instance declaration for `C`) if
we don't give an explicit instance for `F`. Note that the names of the
variables don't need to match those of the class: it really is like a
free-standing `type instance` declaration.
-}</span><span>
</span><span id="line-1246"></span><span>
</span><span id="line-1247"></span><span class="hs-comment">----------------- Type synonym family instances -------------</span><span>
</span><span id="line-1248"></span><span>
</span><span id="line-1249"></span><span class="annot"><span class="hs-comment">-- | Located Type Family Instance Equation</span></span><span>
</span><span id="line-1250"></span><span class="hs-keyword">type</span><span> </span><span id="LTyFamInstEqn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyFamInstEqn"><span class="hs-identifier hs-var">LTyFamInstEqn</span></a></span></span><span> </span><span id="local-6989586621681597438"><span class="annot"><a href="#local-6989586621681597438"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597438"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstEqn"><span class="hs-identifier hs-type">TyFamInstEqn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597438"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1251"></span><span>  </span><span class="hs-comment">-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi'</span><span>
</span><span id="line-1252"></span><span>  </span><span class="hs-comment">--   when in a list</span><span>
</span><span id="line-1253"></span><span>
</span><span id="line-1254"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1255"></span><span>
</span><span id="line-1256"></span><span class="annot"><span class="hs-comment">-- | Haskell Type Patterns</span></span><span>
</span><span id="line-1257"></span><span class="hs-keyword">type</span><span> </span><span id="HsTyPats"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsTyPats"><span class="hs-identifier hs-var">HsTyPats</span></a></span></span><span> </span><span id="local-6989586621681597439"><span class="annot"><a href="#local-6989586621681597439"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTypeArg"><span class="hs-identifier hs-type">LHsTypeArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597439"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1258"></span><span>
</span><span id="line-1259"></span><span class="hs-comment">{- Note [Family instance declaration binders]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The feqn_pats field of FamEqn (family instance equation) stores the LHS type
(and kind) patterns. Any type (and kind) variables contained
in these type patterns are bound in the feqn_bndrs field.
Note that in particular:

* The feqn_bndrs *include* any anonymous wildcards.  For example
     type instance F a _ = a
  The feqn_bndrs will be HsOuterImplicit {a, _}.  Remember that each separate
  wildcard '_' gets its own unique.  In this context wildcards behave just like
  an ordinary type variable, only anonymous.

* The feqn_bndrs *include* type variables that are already in scope

   Eg   class C s t where
          type F t p :: *
        instance C w (a,b) where
          type F (a,b) x = x-&gt;a
   The feqn_bndrs of the F decl is HsOuterImplicit {a,b,x}, even though the
   F decl is nested inside the 'instance' decl.

   However after the renamer, the uniques will match up:
        instance C w7 (a8,b9) where
          type F (a8,b9) x10 = x10-&gt;a8
   so that we can compare the type pattern in the 'instance' decl and
   in the associated 'type' decl

c.f. Note [TyVar binders for associated decls]
-}</span><span>
</span><span id="line-1289"></span><span>
</span><span id="line-1290"></span><span class="annot"><span class="hs-comment">-- | Type Family Instance Equation</span></span><span>
</span><span id="line-1291"></span><span class="hs-keyword">type</span><span> </span><span id="TyFamInstEqn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstEqn"><span class="hs-identifier hs-var">TyFamInstEqn</span></a></span></span><span> </span><span id="local-6989586621681597441"><span class="annot"><a href="#local-6989586621681597441"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamEqn"><span class="hs-identifier hs-type">FamEqn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597441"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597441"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1292"></span><span>            </span><span class="hs-comment">-- Here, the @pats@ are type patterns (with kind and type bndrs).</span><span>
</span><span id="line-1293"></span><span>            </span><span class="hs-comment">-- See Note [Family instance declaration binders]</span><span>
</span><span id="line-1294"></span><span>
</span><span id="line-1295"></span><span class="hs-comment">-- | Type family default declarations.</span><span>
</span><span id="line-1296"></span><span class="hs-comment">-- A convenient synonym for 'TyFamInstDecl'.</span><span>
</span><span id="line-1297"></span><span class="hs-comment">-- See @Note [Type family instance declarations in HsSyn]@.</span><span>
</span><span id="line-1298"></span><span class="hs-keyword">type</span><span> </span><span id="TyFamDefltDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamDefltDecl"><span class="hs-identifier hs-var">TyFamDefltDecl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstDecl"><span class="hs-identifier hs-type">TyFamInstDecl</span></a></span><span>
</span><span id="line-1299"></span><span>
</span><span id="line-1300"></span><span class="annot"><span class="hs-comment">-- | Located type family default declarations.</span></span><span>
</span><span id="line-1301"></span><span class="hs-keyword">type</span><span> </span><span id="LTyFamDefltDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyFamDefltDecl"><span class="hs-identifier hs-var">LTyFamDefltDecl</span></a></span></span><span> </span><span id="local-6989586621681597443"><span class="annot"><a href="#local-6989586621681597443"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597443"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamDefltDecl"><span class="hs-identifier hs-type">TyFamDefltDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597443"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1302"></span><span>
</span><span id="line-1303"></span><span class="annot"><span class="hs-comment">-- | Located Type Family Instance Declaration</span></span><span>
</span><span id="line-1304"></span><span class="hs-keyword">type</span><span> </span><span id="LTyFamInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyFamInstDecl"><span class="hs-identifier hs-var">LTyFamInstDecl</span></a></span></span><span> </span><span id="local-6989586621681597444"><span class="annot"><a href="#local-6989586621681597444"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597444"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstDecl"><span class="hs-identifier hs-type">TyFamInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597444"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1305"></span><span>
</span><span id="line-1306"></span><span class="annot"><span class="hs-comment">-- | Type Family Instance Declaration</span></span><span>
</span><span id="line-1307"></span><span class="hs-keyword">data</span><span> </span><span id="TyFamInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstDecl"><span class="hs-identifier hs-var">TyFamInstDecl</span></a></span></span><span> </span><span id="local-6989586621681596605"><span class="annot"><a href="#local-6989586621681596605"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1308"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="TyFamInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstDecl"><span class="hs-identifier hs-var">TyFamInstDecl</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="tfid_xtn"><span class="annot"><span class="annottext">forall pass. TyFamInstDecl pass -&gt; XCTyFamInstDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#tfid_xtn"><span class="hs-identifier hs-var hs-var">tfid_xtn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCTyFamInstDecl"><span class="hs-identifier hs-type">XCTyFamInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596605"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1309"></span><span>                  </span><span class="hs-special">,</span><span> </span><span id="tfid_eqn"><span class="annot"><span class="annottext">forall pass. TyFamInstDecl pass -&gt; TyFamInstEqn pass
</span><a href="Language.Haskell.Syntax.Decls.html#tfid_eqn"><span class="hs-identifier hs-var hs-var">tfid_eqn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstEqn"><span class="hs-identifier hs-type">TyFamInstEqn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596605"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1310"></span><span>    </span><span class="hs-comment">-- ^</span><span>
</span><span id="line-1311"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnType',</span><span>
</span><span id="line-1312"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnInstance',</span><span>
</span><span id="line-1313"></span><span>
</span><span id="line-1314"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1315"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XTyFamInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XTyFamInstDecl"><span class="hs-identifier hs-var">XTyFamInstDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXTyFamInstDecl"><span class="hs-identifier hs-type">XXTyFamInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596605"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1316"></span><span>
</span><span id="line-1317"></span><span class="hs-comment">----------------- Data family instances -------------</span><span>
</span><span id="line-1318"></span><span>
</span><span id="line-1319"></span><span class="annot"><span class="hs-comment">-- | Located Data Family Instance Declaration</span></span><span>
</span><span id="line-1320"></span><span class="hs-keyword">type</span><span> </span><span id="LDataFamInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDataFamInstDecl"><span class="hs-identifier hs-var">LDataFamInstDecl</span></a></span></span><span> </span><span id="local-6989586621681597449"><span class="annot"><a href="#local-6989586621681597449"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597449"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataFamInstDecl"><span class="hs-identifier hs-type">DataFamInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597449"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1321"></span><span>
</span><span id="line-1322"></span><span class="annot"><span class="hs-comment">-- | Data Family Instance Declaration</span></span><span>
</span><span id="line-1323"></span><span class="hs-keyword">newtype</span><span> </span><span id="DataFamInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataFamInstDecl"><span class="hs-identifier hs-var">DataFamInstDecl</span></a></span></span><span> </span><span id="local-6989586621681596611"><span class="annot"><a href="#local-6989586621681596611"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1324"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DataFamInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataFamInstDecl"><span class="hs-identifier hs-var">DataFamInstDecl</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="dfid_eqn"><span class="annot"><span class="annottext">forall pass. DataFamInstDecl pass -&gt; FamEqn pass (HsDataDefn pass)
</span><a href="Language.Haskell.Syntax.Decls.html#dfid_eqn"><span class="hs-identifier hs-var hs-var">dfid_eqn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamEqn"><span class="hs-identifier hs-type">FamEqn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596611"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsDataDefn"><span class="hs-identifier hs-type">HsDataDefn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596611"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1325"></span><span>    </span><span class="hs-comment">-- ^</span><span>
</span><span id="line-1326"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnData',</span><span>
</span><span id="line-1327"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnNewType','GHC.Parser.Annotation.AnnInstance',</span><span>
</span><span id="line-1328"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnDcolon'</span><span>
</span><span id="line-1329"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnWhere','GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-1330"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-1331"></span><span>
</span><span id="line-1332"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1333"></span><span>
</span><span id="line-1334"></span><span class="hs-comment">----------------- Family instances (common types) -------------</span><span>
</span><span id="line-1335"></span><span>
</span><span id="line-1336"></span><span class="hs-comment">-- | Family Equation</span><span>
</span><span id="line-1337"></span><span class="hs-comment">--</span><span>
</span><span id="line-1338"></span><span class="hs-comment">-- One equation in a type family instance declaration, data family instance</span><span>
</span><span id="line-1339"></span><span class="hs-comment">-- declaration, or type family default.</span><span>
</span><span id="line-1340"></span><span class="hs-comment">-- See Note [Type family instance declarations in HsSyn]</span><span>
</span><span id="line-1341"></span><span class="hs-comment">-- See Note [Family instance declaration binders]</span><span>
</span><span id="line-1342"></span><span class="hs-keyword">data</span><span> </span><span id="FamEqn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamEqn"><span class="hs-identifier hs-var">FamEqn</span></a></span></span><span> </span><span id="local-6989586621681596615"><span class="annot"><a href="#local-6989586621681596615"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span id="local-6989586621681596616"><span class="annot"><a href="#local-6989586621681596616"><span class="hs-identifier hs-type">rhs</span></a></span></span><span>
</span><span id="line-1343"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="FamEqn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#FamEqn"><span class="hs-identifier hs-var">FamEqn</span></a></span></span><span>
</span><span id="line-1344"></span><span>       </span><span class="hs-special">{</span><span> </span><span id="feqn_ext"><span class="annot"><span class="annottext">forall pass rhs. FamEqn pass rhs -&gt; XCFamEqn pass rhs
</span><a href="Language.Haskell.Syntax.Decls.html#feqn_ext"><span class="hs-identifier hs-var hs-var">feqn_ext</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCFamEqn"><span class="hs-identifier hs-type">XCFamEqn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596615"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596616"><span class="hs-identifier hs-type">rhs</span></a></span><span>
</span><span id="line-1345"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="feqn_tycon"><span class="annot"><span class="annottext">forall pass rhs. FamEqn pass rhs -&gt; LIdP pass
</span><a href="Language.Haskell.Syntax.Decls.html#feqn_tycon"><span class="hs-identifier hs-var hs-var">feqn_tycon</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596615"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1346"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="feqn_bndrs"><span class="annot"><span class="annottext">forall pass rhs. FamEqn pass rhs -&gt; HsOuterFamEqnTyVarBndrs pass
</span><a href="Language.Haskell.Syntax.Decls.html#feqn_bndrs"><span class="hs-identifier hs-var hs-var">feqn_bndrs</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterFamEqnTyVarBndrs"><span class="hs-identifier hs-type">HsOuterFamEqnTyVarBndrs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596615"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ Optional quantified type vars</span></span><span>
</span><span id="line-1347"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="feqn_pats"><span class="annot"><span class="annottext">forall pass rhs. FamEqn pass rhs -&gt; HsTyPats pass
</span><a href="Language.Haskell.Syntax.Decls.html#feqn_pats"><span class="hs-identifier hs-var hs-var">feqn_pats</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsTyPats"><span class="hs-identifier hs-type">HsTyPats</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596615"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1348"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="feqn_fixity"><span class="annot"><span class="annottext">forall pass rhs. FamEqn pass rhs -&gt; LexicalFixity
</span><a href="Language.Haskell.Syntax.Decls.html#feqn_fixity"><span class="hs-identifier hs-var hs-var">feqn_fixity</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier hs-type">LexicalFixity</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ Fixity used in the declaration</span></span><span>
</span><span id="line-1349"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="feqn_rhs"><span class="annot"><span class="annottext">forall pass rhs. FamEqn pass rhs -&gt; rhs
</span><a href="Language.Haskell.Syntax.Decls.html#feqn_rhs"><span class="hs-identifier hs-var hs-var">feqn_rhs</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681596616"><span class="hs-identifier hs-type">rhs</span></a></span><span>
</span><span id="line-1350"></span><span>       </span><span class="hs-special">}</span><span>
</span><span id="line-1351"></span><span>    </span><span class="hs-comment">-- ^</span><span>
</span><span id="line-1352"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnEqual'</span><span>
</span><span id="line-1353"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XFamEqn"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XFamEqn"><span class="hs-identifier hs-var">XFamEqn</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXFamEqn"><span class="hs-identifier hs-type">XXFamEqn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596615"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596616"><span class="hs-identifier hs-type">rhs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1354"></span><span>
</span><span id="line-1355"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1356"></span><span>
</span><span id="line-1357"></span><span class="hs-comment">----------------- Class instances -------------</span><span>
</span><span id="line-1358"></span><span>
</span><span id="line-1359"></span><span class="annot"><span class="hs-comment">-- | Located Class Instance Declaration</span></span><span>
</span><span id="line-1360"></span><span class="hs-keyword">type</span><span> </span><span id="LClsInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LClsInstDecl"><span class="hs-identifier hs-var">LClsInstDecl</span></a></span></span><span> </span><span id="local-6989586621681597461"><span class="annot"><a href="#local-6989586621681597461"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597461"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClsInstDecl"><span class="hs-identifier hs-type">ClsInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597461"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1361"></span><span>
</span><span id="line-1362"></span><span class="hs-comment">-- | Class Instance Declaration</span><span>
</span><span id="line-1363"></span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnInstance',</span><span>
</span><span id="line-1364"></span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnWhere',</span><span>
</span><span id="line-1365"></span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose',</span><span>
</span><span id="line-1366"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1367"></span><span class="hs-keyword">data</span><span> </span><span id="ClsInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClsInstDecl"><span class="hs-identifier hs-var">ClsInstDecl</span></a></span></span><span> </span><span id="local-6989586621681596632"><span class="annot"><a href="#local-6989586621681596632"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1368"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ClsInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClsInstDecl"><span class="hs-identifier hs-var">ClsInstDecl</span></a></span></span><span>
</span><span id="line-1369"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="cid_ext"><span class="annot"><span class="annottext">forall pass. ClsInstDecl pass -&gt; XCClsInstDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#cid_ext"><span class="hs-identifier hs-var hs-var">cid_ext</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCClsInstDecl"><span class="hs-identifier hs-type">XCClsInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596632"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1370"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="cid_poly_ty"><span class="annot"><span class="annottext">forall pass. ClsInstDecl pass -&gt; LHsSigType pass
</span><a href="Language.Haskell.Syntax.Decls.html#cid_poly_ty"><span class="hs-identifier hs-var hs-var">cid_poly_ty</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596632"><span class="hs-identifier hs-type">pass</span></a></span><span>    </span><span class="hs-comment">-- Context =&gt; Class Instance-type</span><span>
</span><span id="line-1371"></span><span>                                          </span><span class="hs-comment">-- Using a polytype means that the renamer conveniently</span><span>
</span><span id="line-1372"></span><span>                                          </span><span class="hs-comment">-- figures out the quantified type variables for us.</span><span>
</span><span id="line-1373"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="cid_binds"><span class="annot"><span class="annottext">forall pass. ClsInstDecl pass -&gt; LHsBinds pass
</span><a href="Language.Haskell.Syntax.Decls.html#cid_binds"><span class="hs-identifier hs-var hs-var">cid_binds</span></a></span></span><span>         </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBinds"><span class="hs-identifier hs-type">LHsBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596632"><span class="hs-identifier hs-type">pass</span></a></span><span>       </span><span class="hs-comment">-- Class methods</span><span>
</span><span id="line-1374"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="cid_sigs"><span class="annot"><span class="annottext">forall pass. ClsInstDecl pass -&gt; [LSig pass]
</span><a href="Language.Haskell.Syntax.Decls.html#cid_sigs"><span class="hs-identifier hs-var hs-var">cid_sigs</span></a></span></span><span>          </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596632"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>         </span><span class="hs-comment">-- User-supplied pragmatic info</span><span>
</span><span id="line-1375"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="cid_tyfam_insts"><span class="annot"><span class="annottext">forall pass. ClsInstDecl pass -&gt; [LTyFamInstDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#cid_tyfam_insts"><span class="hs-identifier hs-var hs-var">cid_tyfam_insts</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LTyFamInstDecl"><span class="hs-identifier hs-type">LTyFamInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596632"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>   </span><span class="hs-comment">-- Type family instances</span><span>
</span><span id="line-1376"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="cid_datafam_insts"><span class="annot"><span class="annottext">forall pass. ClsInstDecl pass -&gt; [LDataFamInstDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#cid_datafam_insts"><span class="hs-identifier hs-var hs-var">cid_datafam_insts</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDataFamInstDecl"><span class="hs-identifier hs-type">LDataFamInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596632"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- Data family instances</span><span>
</span><span id="line-1377"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="cid_overlap_mode"><span class="annot"><span class="annottext">forall pass. ClsInstDecl pass -&gt; Maybe (XRec pass OverlapMode)
</span><a href="Language.Haskell.Syntax.Decls.html#cid_overlap_mode"><span class="hs-identifier hs-var hs-var">cid_overlap_mode</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596632"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#OverlapMode"><span class="hs-identifier hs-type">OverlapMode</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1378"></span><span>         </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-1379"></span><span>         </span><span class="hs-comment">--                                    'GHC.Parser.Annotation.AnnClose',</span><span>
</span><span id="line-1380"></span><span>
</span><span id="line-1381"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1382"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-1383"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XClsInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XClsInstDecl"><span class="hs-identifier hs-var">XClsInstDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXClsInstDecl"><span class="hs-identifier hs-type">XXClsInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596632"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1384"></span><span>
</span><span id="line-1385"></span><span class="hs-comment">----------------- Instances of all kinds -------------</span><span>
</span><span id="line-1386"></span><span>
</span><span id="line-1387"></span><span class="annot"><span class="hs-comment">-- | Located Instance Declaration</span></span><span>
</span><span id="line-1388"></span><span class="hs-keyword">type</span><span> </span><span id="LInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LInstDecl"><span class="hs-identifier hs-var">LInstDecl</span></a></span></span><span> </span><span id="local-6989586621681597472"><span class="annot"><a href="#local-6989586621681597472"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597472"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#InstDecl"><span class="hs-identifier hs-type">InstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597472"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1389"></span><span>
</span><span id="line-1390"></span><span class="annot"><span class="hs-comment">-- | Instance Declaration</span></span><span>
</span><span id="line-1391"></span><span class="hs-keyword">data</span><span> </span><span id="InstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#InstDecl"><span class="hs-identifier hs-var">InstDecl</span></a></span></span><span> </span><span id="local-6989586621681596646"><span class="annot"><a href="#local-6989586621681596646"><span class="hs-identifier hs-type">pass</span></a></span></span><span>  </span><span class="hs-comment">-- Both class and family instances</span><span>
</span><span id="line-1392"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ClsInstD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClsInstD"><span class="hs-identifier hs-var">ClsInstD</span></a></span></span><span>
</span><span id="line-1393"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="cid_d_ext"><span class="annot"><span class="annottext">forall pass. InstDecl pass -&gt; XClsInstD pass
</span><a href="Language.Haskell.Syntax.Decls.html#cid_d_ext"><span class="hs-identifier hs-var hs-var">cid_d_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XClsInstD"><span class="hs-identifier hs-type">XClsInstD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596646"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1394"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="cid_inst"><span class="annot"><span class="annottext">forall pass. InstDecl pass -&gt; ClsInstDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#cid_inst"><span class="hs-identifier hs-var hs-var">cid_inst</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ClsInstDecl"><span class="hs-identifier hs-type">ClsInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596646"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1395"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataFamInstD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataFamInstD"><span class="hs-identifier hs-var">DataFamInstD</span></a></span></span><span>              </span><span class="hs-comment">-- data family instance</span><span>
</span><span id="line-1396"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="dfid_ext"><span class="annot"><span class="annottext">forall pass. InstDecl pass -&gt; XDataFamInstD pass
</span><a href="Language.Haskell.Syntax.Decls.html#dfid_ext"><span class="hs-identifier hs-var hs-var">dfid_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDataFamInstD"><span class="hs-identifier hs-type">XDataFamInstD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596646"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1397"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="dfid_inst"><span class="annot"><span class="annottext">forall pass. InstDecl pass -&gt; DataFamInstDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#dfid_inst"><span class="hs-identifier hs-var hs-var">dfid_inst</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DataFamInstDecl"><span class="hs-identifier hs-type">DataFamInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596646"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1398"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TyFamInstD"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstD"><span class="hs-identifier hs-var">TyFamInstD</span></a></span></span><span>              </span><span class="hs-comment">-- type family instance</span><span>
</span><span id="line-1399"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="tfid_ext"><span class="annot"><span class="annottext">forall pass. InstDecl pass -&gt; XTyFamInstD pass
</span><a href="Language.Haskell.Syntax.Decls.html#tfid_ext"><span class="hs-identifier hs-var hs-var">tfid_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTyFamInstD"><span class="hs-identifier hs-type">XTyFamInstD</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596646"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1400"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="tfid_inst"><span class="annot"><span class="annottext">forall pass. InstDecl pass -&gt; TyFamInstDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#tfid_inst"><span class="hs-identifier hs-var hs-var">tfid_inst</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TyFamInstDecl"><span class="hs-identifier hs-type">TyFamInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596646"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1401"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XInstDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XInstDecl"><span class="hs-identifier hs-var">XInstDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXInstDecl"><span class="hs-identifier hs-type">XXInstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596646"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1402"></span><span>
</span><span id="line-1403"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection[DerivDecl]{A stand-alone instance deriving declaration}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1410"></span><span>
</span><span id="line-1411"></span><span class="annot"><span class="hs-comment">-- | Located stand-alone 'deriving instance' declaration</span></span><span>
</span><span id="line-1412"></span><span class="hs-keyword">type</span><span> </span><span id="LDerivDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDerivDecl"><span class="hs-identifier hs-var">LDerivDecl</span></a></span></span><span> </span><span id="local-6989586621681597484"><span class="annot"><a href="#local-6989586621681597484"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597484"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivDecl"><span class="hs-identifier hs-type">DerivDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597484"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1413"></span><span>
</span><span id="line-1414"></span><span class="annot"><span class="hs-comment">-- | Stand-alone 'deriving instance' declaration</span></span><span>
</span><span id="line-1415"></span><span class="hs-keyword">data</span><span> </span><span id="DerivDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivDecl"><span class="hs-identifier hs-var">DerivDecl</span></a></span></span><span> </span><span id="local-6989586621681596656"><span class="annot"><a href="#local-6989586621681596656"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DerivDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivDecl"><span class="hs-identifier hs-var">DerivDecl</span></a></span></span><span>
</span><span id="line-1416"></span><span>        </span><span class="hs-special">{</span><span> </span><span id="deriv_ext"><span class="annot"><span class="annottext">forall pass. DerivDecl pass -&gt; XCDerivDecl pass
</span><a href="Language.Haskell.Syntax.Decls.html#deriv_ext"><span class="hs-identifier hs-var hs-var">deriv_ext</span></a></span></span><span>          </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCDerivDecl"><span class="hs-identifier hs-type">XCDerivDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596656"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1417"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="deriv_type"><span class="annot"><span class="annottext">forall pass. DerivDecl pass -&gt; LHsSigWcType pass
</span><a href="Language.Haskell.Syntax.Decls.html#deriv_type"><span class="hs-identifier hs-var hs-var">deriv_type</span></a></span></span><span>         </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigWcType"><span class="hs-identifier hs-type">LHsSigWcType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596656"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1418"></span><span>          </span><span class="hs-comment">-- ^ The instance type to derive.</span><span>
</span><span id="line-1419"></span><span>          </span><span class="hs-comment">--</span><span>
</span><span id="line-1420"></span><span>          </span><span class="hs-comment">-- It uses an 'LHsSigWcType' because the context is allowed to be a</span><span>
</span><span id="line-1421"></span><span>          </span><span class="hs-comment">-- single wildcard:</span><span>
</span><span id="line-1422"></span><span>          </span><span class="hs-comment">--</span><span>
</span><span id="line-1423"></span><span>          </span><span class="hs-comment">-- &gt; deriving instance _ =&gt; Eq (Foo a)</span><span>
</span><span id="line-1424"></span><span>          </span><span class="hs-comment">--</span><span>
</span><span id="line-1425"></span><span>          </span><span class="hs-comment">-- Which signifies that the context should be inferred.</span><span>
</span><span id="line-1426"></span><span>
</span><span id="line-1427"></span><span>          </span><span class="hs-comment">-- See Note [Inferring the instance context] in GHC.Tc.Deriv.Infer.</span><span>
</span><span id="line-1428"></span><span>
</span><span id="line-1429"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="deriv_strategy"><span class="annot"><span class="annottext">forall pass. DerivDecl pass -&gt; Maybe (LDerivStrategy pass)
</span><a href="Language.Haskell.Syntax.Decls.html#deriv_strategy"><span class="hs-identifier hs-var hs-var">deriv_strategy</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDerivStrategy"><span class="hs-identifier hs-type">LDerivStrategy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596656"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1430"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="deriv_overlap_mode"><span class="annot"><span class="annottext">forall pass. DerivDecl pass -&gt; Maybe (XRec pass OverlapMode)
</span><a href="Language.Haskell.Syntax.Decls.html#deriv_overlap_mode"><span class="hs-identifier hs-var hs-var">deriv_overlap_mode</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596656"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#OverlapMode"><span class="hs-identifier hs-type">OverlapMode</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1431"></span><span>         </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDeriving',</span><span>
</span><span id="line-1432"></span><span>         </span><span class="hs-comment">--        'GHC.Parser.Annotation.AnnInstance', 'GHC.Parser.Annotation.AnnStock',</span><span>
</span><span id="line-1433"></span><span>         </span><span class="hs-comment">--        'GHC.Parser.Annotation.AnnAnyClass', 'GHC.Parser.Annotation.AnnNewtype',</span><span>
</span><span id="line-1434"></span><span>         </span><span class="hs-comment">--        'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-1435"></span><span>
</span><span id="line-1436"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1437"></span><span>        </span><span class="hs-special">}</span><span>
</span><span id="line-1438"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XDerivDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XDerivDecl"><span class="hs-identifier hs-var">XDerivDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXDerivDecl"><span class="hs-identifier hs-type">XXDerivDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596656"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1439"></span><span>
</span><span id="line-1440"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                Deriving strategies
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1447"></span><span>
</span><span id="line-1448"></span><span class="annot"><span class="hs-comment">-- | A 'Located' 'DerivStrategy'.</span></span><span>
</span><span id="line-1449"></span><span class="hs-keyword">type</span><span> </span><span id="LDerivStrategy"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDerivStrategy"><span class="hs-identifier hs-var">LDerivStrategy</span></a></span></span><span> </span><span id="local-6989586621681597492"><span class="annot"><a href="#local-6989586621681597492"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597492"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivStrategy"><span class="hs-identifier hs-type">DerivStrategy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597492"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1450"></span><span>
</span><span id="line-1451"></span><span class="annot"><span class="hs-comment">-- | Which technique the user explicitly requested when deriving an instance.</span></span><span>
</span><span id="line-1452"></span><span class="hs-keyword">data</span><span> </span><span id="DerivStrategy"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DerivStrategy"><span class="hs-identifier hs-var">DerivStrategy</span></a></span></span><span> </span><span id="local-6989586621681597493"><span class="annot"><a href="#local-6989586621681597493"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1453"></span><span>  </span><span class="hs-comment">-- See Note [Deriving strategies] in GHC.Tc.Deriv</span><span>
</span><span id="line-1454"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="StockStrategy"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#StockStrategy"><span class="hs-identifier hs-var">StockStrategy</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XStockStrategy"><span class="hs-identifier hs-type">XStockStrategy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597493"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1455"></span><span>                     </span><span class="hs-comment">-- ^ GHC's \&quot;standard\&quot; strategy, which is to implement a</span><span>
</span><span id="line-1456"></span><span>                     </span><span class="hs-comment">--   custom instance for the data type. This only works</span><span>
</span><span id="line-1457"></span><span>                     </span><span class="hs-comment">--   for certain types that GHC knows about (e.g., 'Eq',</span><span>
</span><span id="line-1458"></span><span>                     </span><span class="hs-comment">--   'Show', 'Functor' when @-XDeriveFunctor@ is enabled,</span><span>
</span><span id="line-1459"></span><span>                     </span><span class="hs-comment">--   etc.)</span><span>
</span><span id="line-1460"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="AnyclassStrategy"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#AnyclassStrategy"><span class="hs-identifier hs-var">AnyclassStrategy</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAnyClassStrategy"><span class="hs-identifier hs-type">XAnyClassStrategy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597493"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ @-XDeriveAnyClass@</span></span><span>
</span><span id="line-1461"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NewtypeStrategy"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#NewtypeStrategy"><span class="hs-identifier hs-var">NewtypeStrategy</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNewtypeStrategy"><span class="hs-identifier hs-type">XNewtypeStrategy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597493"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @-XGeneralizedNewtypeDeriving@</span></span><span>
</span><span id="line-1462"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ViaStrategy"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ViaStrategy"><span class="hs-identifier hs-var">ViaStrategy</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViaStrategy"><span class="hs-identifier hs-type">XViaStrategy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597493"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1463"></span><span>                     </span><span class="annot"><span class="hs-comment">-- ^ @-XDerivingVia@</span></span><span>
</span><span id="line-1464"></span><span>
</span><span id="line-1465"></span><span>
</span><span id="line-1466"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection[DefaultDecl]{A @default@ declaration}
*                                                                      *
************************************************************************

There can only be one default declaration per module, but it is hard
for the parser to check that; we pass them all through in the abstract
syntax, and that restriction must be checked in the front end.
-}</span><span>
</span><span id="line-1477"></span><span>
</span><span id="line-1478"></span><span class="annot"><span class="hs-comment">-- | Located Default Declaration</span></span><span>
</span><span id="line-1479"></span><span class="hs-keyword">type</span><span> </span><span id="LDefaultDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDefaultDecl"><span class="hs-identifier hs-var">LDefaultDecl</span></a></span></span><span> </span><span id="local-6989586621681597502"><span class="annot"><a href="#local-6989586621681597502"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597502"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DefaultDecl"><span class="hs-identifier hs-type">DefaultDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597502"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1480"></span><span>
</span><span id="line-1481"></span><span class="annot"><span class="hs-comment">-- | Default Declaration</span></span><span>
</span><span id="line-1482"></span><span class="hs-keyword">data</span><span> </span><span id="DefaultDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DefaultDecl"><span class="hs-identifier hs-var">DefaultDecl</span></a></span></span><span> </span><span id="local-6989586621681597503"><span class="annot"><a href="#local-6989586621681597503"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1483"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DefaultDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DefaultDecl"><span class="hs-identifier hs-var">DefaultDecl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCDefaultDecl"><span class="hs-identifier hs-type">XCDefaultDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597503"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597503"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1484"></span><span>        </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId's : 'GHC.Parser.Annotation.AnnDefault',</span><span>
</span><span id="line-1485"></span><span>        </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-1486"></span><span>
</span><span id="line-1487"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1488"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XDefaultDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XDefaultDecl"><span class="hs-identifier hs-var">XDefaultDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXDefaultDecl"><span class="hs-identifier hs-type">XXDefaultDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597503"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1489"></span><span>
</span><span id="line-1490"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Foreign function interface declaration}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1497"></span><span>
</span><span id="line-1498"></span><span class="hs-comment">-- foreign declarations are distinguished as to whether they define or use a</span><span>
</span><span id="line-1499"></span><span class="hs-comment">-- Haskell name</span><span>
</span><span id="line-1500"></span><span class="hs-comment">--</span><span>
</span><span id="line-1501"></span><span class="hs-comment">--  * the Boolean value indicates whether the pre-standard deprecated syntax</span><span>
</span><span id="line-1502"></span><span class="hs-comment">--   has been used</span><span>
</span><span id="line-1503"></span><span>
</span><span id="line-1504"></span><span class="annot"><span class="hs-comment">-- | Located Foreign Declaration</span></span><span>
</span><span id="line-1505"></span><span class="hs-keyword">type</span><span> </span><span id="LForeignDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LForeignDecl"><span class="hs-identifier hs-var">LForeignDecl</span></a></span></span><span> </span><span id="local-6989586621681597508"><span class="annot"><a href="#local-6989586621681597508"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597508"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignDecl"><span class="hs-identifier hs-type">ForeignDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597508"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1506"></span><span>
</span><span id="line-1507"></span><span class="annot"><span class="hs-comment">-- | Foreign Declaration</span></span><span>
</span><span id="line-1508"></span><span class="hs-keyword">data</span><span> </span><span id="ForeignDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignDecl"><span class="hs-identifier hs-var">ForeignDecl</span></a></span></span><span> </span><span id="local-6989586621681596664"><span class="annot"><a href="#local-6989586621681596664"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1509"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ForeignImport"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignImport"><span class="hs-identifier hs-var">ForeignImport</span></a></span></span><span>
</span><span id="line-1510"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="fd_i_ext"><span class="annot"><span class="annottext">forall pass. ForeignDecl pass -&gt; XForeignImport pass
</span><a href="Language.Haskell.Syntax.Decls.html#fd_i_ext"><span class="hs-identifier hs-var hs-var">fd_i_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XForeignImport"><span class="hs-identifier hs-type">XForeignImport</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596664"><span class="hs-identifier hs-type">pass</span></a></span><span>   </span><span class="hs-comment">-- Post typechecker, rep_ty ~ sig_ty</span><span>
</span><span id="line-1511"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="fd_name"><span class="annot"><span class="annottext">forall pass. ForeignDecl pass -&gt; LIdP pass
</span><a href="Language.Haskell.Syntax.Decls.html#fd_name"><span class="hs-identifier hs-var hs-var">fd_name</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596664"><span class="hs-identifier hs-type">pass</span></a></span><span>             </span><span class="hs-comment">-- defines this name</span><span>
</span><span id="line-1512"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="fd_sig_ty"><span class="annot"><span class="annottext">forall pass. ForeignDecl pass -&gt; LHsSigType pass
</span><a href="Language.Haskell.Syntax.Decls.html#fd_sig_ty"><span class="hs-identifier hs-var hs-var">fd_sig_ty</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596664"><span class="hs-identifier hs-type">pass</span></a></span><span>       </span><span class="hs-comment">-- sig_ty</span><span>
</span><span id="line-1513"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="fd_fi"><span class="annot"><span class="annottext">forall pass. ForeignDecl pass -&gt; ForeignImport pass
</span><a href="Language.Haskell.Syntax.Decls.html#fd_fi"><span class="hs-identifier hs-var hs-var">fd_fi</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignImport"><span class="hs-identifier hs-type">ForeignImport</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596664"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1514"></span><span>
</span><span id="line-1515"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ForeignExport"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignExport"><span class="hs-identifier hs-var">ForeignExport</span></a></span></span><span>
</span><span id="line-1516"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="fd_e_ext"><span class="annot"><span class="annottext">forall pass. ForeignDecl pass -&gt; XForeignExport pass
</span><a href="Language.Haskell.Syntax.Decls.html#fd_e_ext"><span class="hs-identifier hs-var hs-var">fd_e_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XForeignExport"><span class="hs-identifier hs-type">XForeignExport</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596664"><span class="hs-identifier hs-type">pass</span></a></span><span>   </span><span class="hs-comment">-- Post typechecker, rep_ty ~ sig_ty</span><span>
</span><span id="line-1517"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="fd_name"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#fd_name"><span class="hs-identifier hs-var">fd_name</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596664"><span class="hs-identifier hs-type">pass</span></a></span><span>             </span><span class="hs-comment">-- uses this name</span><span>
</span><span id="line-1518"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="fd_sig_ty"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#fd_sig_ty"><span class="hs-identifier hs-var">fd_sig_ty</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596664"><span class="hs-identifier hs-type">pass</span></a></span><span>       </span><span class="hs-comment">-- sig_ty</span><span>
</span><span id="line-1519"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="fd_fe"><span class="annot"><span class="annottext">forall pass. ForeignDecl pass -&gt; ForeignExport pass
</span><a href="Language.Haskell.Syntax.Decls.html#fd_fe"><span class="hs-identifier hs-var hs-var">fd_fe</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignExport"><span class="hs-identifier hs-type">ForeignExport</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596664"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1520"></span><span>        </span><span class="hs-comment">-- ^</span><span>
</span><span id="line-1521"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnForeign',</span><span>
</span><span id="line-1522"></span><span>        </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnImport','GHC.Parser.Annotation.AnnExport',</span><span>
</span><span id="line-1523"></span><span>        </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnDcolon'</span><span>
</span><span id="line-1524"></span><span>
</span><span id="line-1525"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1526"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XForeignDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XForeignDecl"><span class="hs-identifier hs-var">XForeignDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXForeignDecl"><span class="hs-identifier hs-type">XXForeignDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596664"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1527"></span><span>
</span><span id="line-1528"></span><span class="hs-comment">{-
    In both ForeignImport and ForeignExport:
        sig_ty is the type given in the Haskell code
        rep_ty is the representation for this type, i.e. with newtypes
               coerced away and type functions evaluated.
    Thus if the declaration is valid, then rep_ty will only use types
    such as Int and IO that we know how to make foreign calls with.
-}</span><span>
</span><span id="line-1536"></span><span>
</span><span id="line-1537"></span><span class="hs-comment">-- Specification Of an imported external entity in dependence on the calling</span><span>
</span><span id="line-1538"></span><span class="hs-comment">-- convention</span><span>
</span><span id="line-1539"></span><span class="hs-comment">--</span><span>
</span><span id="line-1540"></span><span class="hs-keyword">data</span><span> </span><span id="ForeignImport"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignImport"><span class="hs-identifier hs-var">ForeignImport</span></a></span></span><span> </span><span id="local-6989586621681597519"><span class="annot"><a href="#local-6989586621681597519"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- import of a C entity</span><span>
</span><span id="line-1541"></span><span>                          </span><span class="hs-comment">--</span><span>
</span><span id="line-1542"></span><span>                          </span><span class="hs-comment">--  * the two strings specifying a header file or library</span><span>
</span><span id="line-1543"></span><span>                          </span><span class="hs-comment">--   may be empty, which indicates the absence of a</span><span>
</span><span id="line-1544"></span><span>                          </span><span class="hs-comment">--   header or object specification (both are not used</span><span>
</span><span id="line-1545"></span><span>                          </span><span class="hs-comment">--   in the case of `CWrapper' and when `CFunction'</span><span>
</span><span id="line-1546"></span><span>                          </span><span class="hs-comment">--   has a dynamic target)</span><span>
</span><span id="line-1547"></span><span>                          </span><span class="hs-comment">--</span><span>
</span><span id="line-1548"></span><span>                          </span><span class="hs-comment">--  * the calling convention is irrelevant for code</span><span>
</span><span id="line-1549"></span><span>                          </span><span class="hs-comment">--   generation in the case of `CLabel', but is needed</span><span>
</span><span id="line-1550"></span><span>                          </span><span class="hs-comment">--   for pretty printing</span><span>
</span><span id="line-1551"></span><span>                          </span><span class="hs-comment">--</span><span>
</span><span id="line-1552"></span><span>                          </span><span class="hs-comment">--  * `Safety' is irrelevant for `CLabel' and `CWrapper'</span><span>
</span><span id="line-1553"></span><span>                          </span><span class="hs-comment">--</span><span>
</span><span id="line-1554"></span><span>                          </span><span id="CImport"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#CImport"><span class="hs-identifier hs-var">CImport</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCImport"><span class="hs-identifier hs-type">XCImport</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597519"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1555"></span><span>                                   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597519"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#CCallConv"><span class="hs-identifier hs-type">CCallConv</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ccall or stdcall</span><span>
</span><span id="line-1556"></span><span>                                   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597519"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#Safety"><span class="hs-identifier hs-type">Safety</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- interruptible, safe or unsafe</span><span>
</span><span id="line-1557"></span><span>                                   </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#Header"><span class="hs-identifier hs-type">Header</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- name of C header</span><span>
</span><span id="line-1558"></span><span>                                   </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#CImportSpec"><span class="hs-identifier hs-type">CImportSpec</span></a></span><span>          </span><span class="hs-comment">-- details of the C entity</span><span>
</span><span id="line-1559"></span><span>                        </span><span class="hs-glyph">|</span><span> </span><span id="XForeignImport"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XForeignImport"><span class="hs-identifier hs-var">XForeignImport</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXForeignImport"><span class="hs-identifier hs-type">XXForeignImport</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597519"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1560"></span><span>
</span><span id="line-1561"></span><span class="hs-comment">-- details of an external C entity</span><span>
</span><span id="line-1562"></span><span class="hs-comment">--</span><span>
</span><span id="line-1563"></span><span class="hs-keyword">data</span><span> </span><span id="CImportSpec"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#CImportSpec"><span class="hs-identifier hs-var">CImportSpec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="CLabel"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#CLabel"><span class="hs-identifier hs-var">CLabel</span></a></span></span><span>    </span><span class="annot"><a href="GHC.Types.ForeignCall.html#CLabelString"><span class="hs-identifier hs-type">CLabelString</span></a></span><span>     </span><span class="hs-comment">-- import address of a C label</span><span>
</span><span id="line-1564"></span><span>                 </span><span class="hs-glyph">|</span><span> </span><span id="CFunction"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#CFunction"><span class="hs-identifier hs-var">CFunction</span></a></span></span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#CCallTarget"><span class="hs-identifier hs-type">CCallTarget</span></a></span><span>      </span><span class="hs-comment">-- static or dynamic function</span><span>
</span><span id="line-1565"></span><span>                 </span><span class="hs-glyph">|</span><span> </span><span id="CWrapper"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#CWrapper"><span class="hs-identifier hs-var">CWrapper</span></a></span></span><span>                   </span><span class="hs-comment">-- wrapper to expose closures</span><span>
</span><span id="line-1566"></span><span>                                              </span><span class="hs-comment">-- (former f.e.d.)</span><span>
</span><span id="line-1567"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681597530"><span id="local-6989586621681597536"><span id="local-6989586621681597540"><span id="local-6989586621681597542"><span id="local-6989586621681597544"><span id="local-6989586621681597550"><span id="local-6989586621681597555"><span id="local-6989586621681597558"><span id="local-6989586621681597561"><span id="local-6989586621681597564"><span id="local-6989586621681597567"><span id="local-6989586621681597570"><span id="local-6989586621681597575"><span id="local-6989586621681597580"><span class="annot"><span class="annottext">Typeable CImportSpec
Typeable CImportSpec =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; CImportSpec -&gt; c CImportSpec)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c CImportSpec)
-&gt; (CImportSpec -&gt; Constr)
-&gt; (CImportSpec -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c CImportSpec))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c CImportSpec))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; CImportSpec -&gt; CImportSpec)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CImportSpec -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CImportSpec -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; CImportSpec -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; CImportSpec -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec)
-&gt; Data CImportSpec
CImportSpec -&gt; Constr
CImportSpec -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; CImportSpec -&gt; CImportSpec
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; CImportSpec -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; CImportSpec -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CImportSpec -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CImportSpec -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c CImportSpec
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CImportSpec -&gt; c CImportSpec
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c CImportSpec)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c CImportSpec)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CImportSpec -&gt; c CImportSpec
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CImportSpec -&gt; c CImportSpec
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c CImportSpec
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c CImportSpec
$ctoConstr :: CImportSpec -&gt; Constr
toConstr :: CImportSpec -&gt; Constr
$cdataTypeOf :: CImportSpec -&gt; DataType
dataTypeOf :: CImportSpec -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c CImportSpec)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c CImportSpec)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c CImportSpec)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c CImportSpec)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; CImportSpec -&gt; CImportSpec
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; CImportSpec -&gt; CImportSpec
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CImportSpec -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CImportSpec -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CImportSpec -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CImportSpec -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; CImportSpec -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; CImportSpec -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; CImportSpec -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; CImportSpec -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CImportSpec -&gt; m CImportSpec
</span><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-1568"></span><span>
</span><span id="line-1569"></span><span class="hs-comment">-- specification of an externally exported entity in dependence on the calling</span><span>
</span><span id="line-1570"></span><span class="hs-comment">-- convention</span><span>
</span><span id="line-1571"></span><span class="hs-comment">--</span><span>
</span><span id="line-1572"></span><span class="hs-keyword">data</span><span> </span><span id="ForeignExport"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ForeignExport"><span class="hs-identifier hs-var">ForeignExport</span></a></span></span><span> </span><span id="local-6989586621681597584"><span class="annot"><a href="#local-6989586621681597584"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="CExport"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#CExport"><span class="hs-identifier hs-var">CExport</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCExport"><span class="hs-identifier hs-type">XCExport</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597584"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597584"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.ForeignCall.html#CExportSpec"><span class="hs-identifier hs-type">CExportSpec</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- contains the calling convention</span><span>
</span><span id="line-1573"></span><span>                        </span><span class="hs-glyph">|</span><span> </span><span id="XForeignExport"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XForeignExport"><span class="hs-identifier hs-var">XForeignExport</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXForeignExport"><span class="hs-identifier hs-type">XXForeignExport</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597584"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1574"></span><span>
</span><span id="line-1575"></span><span>
</span><span id="line-1576"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Rewrite rules}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1583"></span><span>
</span><span id="line-1584"></span><span class="annot"><span class="hs-comment">-- | Located Rule Declarations</span></span><span>
</span><span id="line-1585"></span><span class="hs-keyword">type</span><span> </span><span id="LRuleDecls"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRuleDecls"><span class="hs-identifier hs-var">LRuleDecls</span></a></span></span><span> </span><span id="local-6989586621681597589"><span class="annot"><a href="#local-6989586621681597589"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597589"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleDecls"><span class="hs-identifier hs-type">RuleDecls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597589"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1586"></span><span>
</span><span id="line-1587"></span><span class="annot"><span class="hs-comment">-- | Rule Declarations</span></span><span>
</span><span id="line-1588"></span><span class="hs-keyword">data</span><span> </span><span id="RuleDecls"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleDecls"><span class="hs-identifier hs-var">RuleDecls</span></a></span></span><span> </span><span id="local-6989586621681596684"><span class="annot"><a href="#local-6989586621681596684"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="HsRules"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsRules"><span class="hs-identifier hs-var">HsRules</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="rds_ext"><span class="annot"><span class="annottext">forall pass. RuleDecls pass -&gt; XCRuleDecls pass
</span><a href="Language.Haskell.Syntax.Decls.html#rds_ext"><span class="hs-identifier hs-var hs-var">rds_ext</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCRuleDecls"><span class="hs-identifier hs-type">XCRuleDecls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596684"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1589"></span><span>                              </span><span class="hs-special">,</span><span> </span><span id="rds_rules"><span class="annot"><span class="annottext">forall pass. RuleDecls pass -&gt; [LRuleDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#rds_rules"><span class="hs-identifier hs-var hs-var">rds_rules</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRuleDecl"><span class="hs-identifier hs-type">LRuleDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596684"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1590"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XRuleDecls"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XRuleDecls"><span class="hs-identifier hs-var">XRuleDecls</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXRuleDecls"><span class="hs-identifier hs-type">XXRuleDecls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596684"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1591"></span><span>
</span><span id="line-1592"></span><span class="annot"><span class="hs-comment">-- | Located Rule Declaration</span></span><span>
</span><span id="line-1593"></span><span class="hs-keyword">type</span><span> </span><span id="LRuleDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRuleDecl"><span class="hs-identifier hs-var">LRuleDecl</span></a></span></span><span> </span><span id="local-6989586621681597595"><span class="annot"><a href="#local-6989586621681597595"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597595"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleDecl"><span class="hs-identifier hs-type">RuleDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597595"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1594"></span><span>
</span><span id="line-1595"></span><span class="annot"><span class="hs-comment">-- | Rule Declaration</span></span><span>
</span><span id="line-1596"></span><span class="hs-keyword">data</span><span> </span><span id="RuleDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleDecl"><span class="hs-identifier hs-var">RuleDecl</span></a></span></span><span> </span><span id="local-6989586621681596690"><span class="annot"><a href="#local-6989586621681596690"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1597"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsRule"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsRule"><span class="hs-identifier hs-var">HsRule</span></a></span></span><span> </span><span class="hs-comment">-- Source rule</span><span>
</span><span id="line-1598"></span><span>       </span><span class="hs-special">{</span><span> </span><span id="rd_ext"><span class="annot"><span class="annottext">forall pass. RuleDecl pass -&gt; XHsRule pass
</span><a href="Language.Haskell.Syntax.Decls.html#rd_ext"><span class="hs-identifier hs-var hs-var">rd_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsRule"><span class="hs-identifier hs-type">XHsRule</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596690"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1599"></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ After renamer, free-vars from the LHS and RHS</span></span><span>
</span><span id="line-1600"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="rd_name"><span class="annot"><span class="annottext">forall pass. RuleDecl pass -&gt; XRec pass CLabelString
</span><a href="Language.Haskell.Syntax.Decls.html#rd_name"><span class="hs-identifier hs-var hs-var">rd_name</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596690"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#RuleName"><span class="hs-identifier hs-type">RuleName</span></a></span><span>
</span><span id="line-1601"></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ Note [Pragma source text] in &quot;GHC.Types.Basic&quot;</span></span><span>
</span><span id="line-1602"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="rd_act"><span class="annot"><span class="annottext">forall pass. RuleDecl pass -&gt; Activation
</span><a href="Language.Haskell.Syntax.Decls.html#rd_act"><span class="hs-identifier hs-var hs-var">rd_act</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#Activation"><span class="hs-identifier hs-type">Activation</span></a></span><span>
</span><span id="line-1603"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="rd_tyvs"><span class="annot"><span class="annottext">forall pass.
RuleDecl pass -&gt; Maybe [LHsTyVarBndr () (NoGhcTc pass)]
</span><a href="Language.Haskell.Syntax.Decls.html#rd_tyvs"><span class="hs-identifier hs-var hs-var">rd_tyvs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTyVarBndr"><span class="hs-identifier hs-type">LHsTyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoGhcTc"><span class="hs-identifier hs-type">NoGhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596690"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-1604"></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ Forall'd type vars</span></span><span>
</span><span id="line-1605"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="rd_tmvs"><span class="annot"><span class="annottext">forall pass. RuleDecl pass -&gt; [LRuleBndr pass]
</span><a href="Language.Haskell.Syntax.Decls.html#rd_tmvs"><span class="hs-identifier hs-var hs-var">rd_tmvs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRuleBndr"><span class="hs-identifier hs-type">LRuleBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596690"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1606"></span><span>           </span><span class="hs-comment">-- ^ Forall'd term vars, before typechecking; after typechecking</span><span>
</span><span id="line-1607"></span><span>           </span><span class="hs-comment">--    this includes all forall'd vars</span><span>
</span><span id="line-1608"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="rd_lhs"><span class="annot"><span class="annottext">forall pass. RuleDecl pass -&gt; XRec pass (HsExpr pass)
</span><a href="Language.Haskell.Syntax.Decls.html#rd_lhs"><span class="hs-identifier hs-var hs-var">rd_lhs</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596690"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596690"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1609"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="rd_rhs"><span class="annot"><span class="annottext">forall pass. RuleDecl pass -&gt; XRec pass (HsExpr pass)
</span><a href="Language.Haskell.Syntax.Decls.html#rd_rhs"><span class="hs-identifier hs-var hs-var">rd_rhs</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596690"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596690"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1610"></span><span>       </span><span class="hs-special">}</span><span>
</span><span id="line-1611"></span><span>    </span><span class="hs-comment">-- ^</span><span>
</span><span id="line-1612"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' :</span><span>
</span><span id="line-1613"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnTilde',</span><span>
</span><span id="line-1614"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnVal',</span><span>
</span><span id="line-1615"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnClose',</span><span>
</span><span id="line-1616"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnForall','GHC.Parser.Annotation.AnnDot',</span><span>
</span><span id="line-1617"></span><span>    </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnEqual',</span><span>
</span><span id="line-1618"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XRuleDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XRuleDecl"><span class="hs-identifier hs-var">XRuleDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXRuleDecl"><span class="hs-identifier hs-type">XXRuleDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596690"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1619"></span><span>
</span><span id="line-1620"></span><span class="annot"><span class="hs-comment">-- | Located Rule Binder</span></span><span>
</span><span id="line-1621"></span><span class="hs-keyword">type</span><span> </span><span id="LRuleBndr"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRuleBndr"><span class="hs-identifier hs-var">LRuleBndr</span></a></span></span><span> </span><span id="local-6989586621681597606"><span class="annot"><a href="#local-6989586621681597606"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597606"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleBndr"><span class="hs-identifier hs-type">RuleBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597606"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1622"></span><span>
</span><span id="line-1623"></span><span class="annot"><span class="hs-comment">-- | Rule Binder</span></span><span>
</span><span id="line-1624"></span><span class="hs-keyword">data</span><span> </span><span id="RuleBndr"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleBndr"><span class="hs-identifier hs-var">RuleBndr</span></a></span></span><span> </span><span id="local-6989586621681597607"><span class="annot"><a href="#local-6989586621681597607"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1625"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="RuleBndr"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleBndr"><span class="hs-identifier hs-var">RuleBndr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCRuleBndr"><span class="hs-identifier hs-type">XCRuleBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597607"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597607"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1626"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RuleBndrSig"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleBndrSig"><span class="hs-identifier hs-var">RuleBndrSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRuleBndrSig"><span class="hs-identifier hs-type">XRuleBndrSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597607"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597607"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsPatSigType"><span class="hs-identifier hs-type">HsPatSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597607"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1627"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XRuleBndr"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XRuleBndr"><span class="hs-identifier hs-var">XRuleBndr</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXRuleBndr"><span class="hs-identifier hs-type">XXRuleBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597607"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1628"></span><span>        </span><span class="hs-comment">-- ^</span><span>
</span><span id="line-1629"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-1630"></span><span>        </span><span class="hs-comment">--     'GHC.Parser.Annotation.AnnDcolon','GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-1631"></span><span>
</span><span id="line-1632"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1633"></span><span>
</span><span id="line-1634"></span><span id="local-6989586621681596704"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#collectRuleBndrSigTys"><span class="hs-identifier hs-type">collectRuleBndrSigTys</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleBndr"><span class="hs-identifier hs-type">RuleBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596704"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsPatSigType"><span class="hs-identifier hs-type">HsPatSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596704"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-1635"></span><span id="collectRuleBndrSigTys"><span class="annot"><span class="annottext">collectRuleBndrSigTys :: forall pass. [RuleBndr pass] -&gt; [HsPatSigType pass]
</span><a href="Language.Haskell.Syntax.Decls.html#collectRuleBndrSigTys"><span class="hs-identifier hs-var hs-var">collectRuleBndrSigTys</span></a></span></span><span> </span><span id="local-6989586621681597613"><span class="annot"><span class="annottext">[RuleBndr pass]
</span><a href="#local-6989586621681597613"><span class="hs-identifier hs-var">bndrs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">HsPatSigType pass
</span><a href="#local-6989586621681597614"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RuleBndrSig"><span class="hs-identifier hs-type">RuleBndrSig</span></a></span><span> </span><span class="annot"><span class="annottext">XRuleBndrSig pass
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP pass
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681597614"><span class="annot"><span class="annottext">HsPatSigType pass
</span><a href="#local-6989586621681597614"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[RuleBndr pass]
</span><a href="#local-6989586621681597613"><span class="hs-identifier hs-var">bndrs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1636"></span><span>
</span><span id="line-1637"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection[DocDecl]{Document comments}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1644"></span><span>
</span><span id="line-1645"></span><span class="annot"><span class="hs-comment">-- | Located Documentation comment Declaration</span></span><span>
</span><span id="line-1646"></span><span class="hs-keyword">type</span><span> </span><span id="LDocDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LDocDecl"><span class="hs-identifier hs-var">LDocDecl</span></a></span></span><span> </span><span id="local-6989586621681597615"><span class="annot"><a href="#local-6989586621681597615"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597615"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocDecl"><span class="hs-identifier hs-type">DocDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597615"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1647"></span><span>
</span><span id="line-1648"></span><span class="annot"><span class="hs-comment">-- | Documentation comment Declaration</span></span><span>
</span><span id="line-1649"></span><span class="hs-keyword">data</span><span> </span><span id="DocDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocDecl"><span class="hs-identifier hs-var">DocDecl</span></a></span></span><span> </span><span id="local-6989586621681597616"><span class="annot"><a href="#local-6989586621681597616"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1650"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DocCommentNext"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocCommentNext"><span class="hs-identifier hs-var">DocCommentNext</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier hs-type">LHsDoc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597616"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1651"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DocCommentPrev"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocCommentPrev"><span class="hs-identifier hs-var">DocCommentPrev</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier hs-type">LHsDoc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597616"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1652"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DocCommentNamed"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocCommentNamed"><span class="hs-identifier hs-var">DocCommentNamed</span></a></span></span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#String/GHC.Base.html#String"><span class="hs-identifier hs-type">String</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier hs-type">LHsDoc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597616"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1653"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DocGroup"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocGroup"><span class="hs-identifier hs-var">DocGroup</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier hs-type">LHsDoc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597616"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1654"></span><span>
</span><span id="line-1655"></span><span id="local-6989586621681596725"><span id="local-6989586621681597628"><span id="local-6989586621681597641"><span id="local-6989586621681597652"><span id="local-6989586621681597654"><span id="local-6989586621681597656"><span id="local-6989586621681597662"><span id="local-6989586621681597668"><span id="local-6989586621681597671"><span id="local-6989586621681597674"><span id="local-6989586621681597677"><span id="local-6989586621681597680"><span id="local-6989586621681597683"><span id="local-6989586621681597688"><span id="local-6989586621681597693"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-type">Data</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596725"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-type">Data</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596725"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-type">Data</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocDecl"><span class="hs-identifier hs-type">DocDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596725"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-1656"></span><span>
</span><span id="line-1657"></span><span id="local-6989586621681596726"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#docDeclDoc"><span class="hs-identifier hs-type">docDeclDoc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocDecl"><span class="hs-identifier hs-type">DocDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596726"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier hs-type">LHsDoc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596726"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1658"></span><span id="docDeclDoc"><span class="annot"><span class="annottext">docDeclDoc :: forall pass. DocDecl pass -&gt; LHsDoc pass
</span><a href="Language.Haskell.Syntax.Decls.html#docDeclDoc"><span class="hs-identifier hs-var hs-var">docDeclDoc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocCommentNext"><span class="hs-identifier hs-type">DocCommentNext</span></a></span><span> </span><span id="local-6989586621681597703"><span class="annot"><span class="annottext">LHsDoc pass
</span><a href="#local-6989586621681597703"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LHsDoc pass
</span><a href="#local-6989586621681597703"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-1659"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#docDeclDoc"><span class="hs-identifier hs-var">docDeclDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocCommentPrev"><span class="hs-identifier hs-type">DocCommentPrev</span></a></span><span> </span><span id="local-6989586621681597704"><span class="annot"><span class="annottext">LHsDoc pass
</span><a href="#local-6989586621681597704"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LHsDoc pass
</span><a href="#local-6989586621681597704"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-1660"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#docDeclDoc"><span class="hs-identifier hs-var">docDeclDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocCommentNamed"><span class="hs-identifier hs-type">DocCommentNamed</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681597705"><span class="annot"><span class="annottext">LHsDoc pass
</span><a href="#local-6989586621681597705"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LHsDoc pass
</span><a href="#local-6989586621681597705"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-1661"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#docDeclDoc"><span class="hs-identifier hs-var">docDeclDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#DocGroup"><span class="hs-identifier hs-type">DocGroup</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681597706"><span class="annot"><span class="annottext">LHsDoc pass
</span><a href="#local-6989586621681597706"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LHsDoc pass
</span><a href="#local-6989586621681597706"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-1662"></span><span>
</span><span id="line-1663"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection[DeprecDecl]{Deprecations}
*                                                                      *
************************************************************************

We use exported entities for things to deprecate.
-}</span><span>
</span><span id="line-1672"></span><span>
</span><span id="line-1673"></span><span class="annot"><span class="hs-comment">-- | Located Warning Declarations</span></span><span>
</span><span id="line-1674"></span><span class="hs-keyword">type</span><span> </span><span id="LWarnDecls"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LWarnDecls"><span class="hs-identifier hs-var">LWarnDecls</span></a></span></span><span> </span><span id="local-6989586621681597707"><span class="annot"><a href="#local-6989586621681597707"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597707"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#WarnDecls"><span class="hs-identifier hs-type">WarnDecls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597707"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1675"></span><span>
</span><span id="line-1676"></span><span class="annot"><span class="hs-comment">-- | Warning pragma Declarations</span></span><span>
</span><span id="line-1677"></span><span class="hs-keyword">data</span><span> </span><span id="WarnDecls"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#WarnDecls"><span class="hs-identifier hs-var">WarnDecls</span></a></span></span><span> </span><span id="local-6989586621681596728"><span class="annot"><a href="#local-6989586621681596728"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Warnings"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#Warnings"><span class="hs-identifier hs-var">Warnings</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="wd_ext"><span class="annot"><span class="annottext">forall pass. WarnDecls pass -&gt; XWarnings pass
</span><a href="Language.Haskell.Syntax.Decls.html#wd_ext"><span class="hs-identifier hs-var hs-var">wd_ext</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWarnings"><span class="hs-identifier hs-type">XWarnings</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596728"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1678"></span><span>                               </span><span class="hs-special">,</span><span> </span><span id="wd_warnings"><span class="annot"><span class="annottext">forall pass. WarnDecls pass -&gt; [LWarnDecl pass]
</span><a href="Language.Haskell.Syntax.Decls.html#wd_warnings"><span class="hs-identifier hs-var hs-var">wd_warnings</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LWarnDecl"><span class="hs-identifier hs-type">LWarnDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596728"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1679"></span><span>                               </span><span class="hs-special">}</span><span>
</span><span id="line-1680"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XWarnDecls"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XWarnDecls"><span class="hs-identifier hs-var">XWarnDecls</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXWarnDecls"><span class="hs-identifier hs-type">XXWarnDecls</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596728"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1681"></span><span>
</span><span id="line-1682"></span><span class="annot"><span class="hs-comment">-- | Located Warning pragma Declaration</span></span><span>
</span><span id="line-1683"></span><span class="hs-keyword">type</span><span> </span><span id="LWarnDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LWarnDecl"><span class="hs-identifier hs-var">LWarnDecl</span></a></span></span><span> </span><span id="local-6989586621681597713"><span class="annot"><a href="#local-6989586621681597713"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597713"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#WarnDecl"><span class="hs-identifier hs-type">WarnDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597713"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1684"></span><span>
</span><span id="line-1685"></span><span class="annot"><span class="hs-comment">-- | Warning pragma Declaration</span></span><span>
</span><span id="line-1686"></span><span class="hs-keyword">data</span><span> </span><span id="WarnDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#WarnDecl"><span class="hs-identifier hs-var">WarnDecl</span></a></span></span><span> </span><span id="local-6989586621681597714"><span class="annot"><a href="#local-6989586621681597714"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Warning"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#Warning"><span class="hs-identifier hs-var">Warning</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWarning"><span class="hs-identifier hs-type">XWarning</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597714"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597714"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Unit.Module.Warnings.html#WarningTxt"><span class="hs-identifier hs-type">WarningTxt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597714"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1687"></span><span>                   </span><span class="hs-glyph">|</span><span> </span><span id="XWarnDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XWarnDecl"><span class="hs-identifier hs-var">XWarnDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXWarnDecl"><span class="hs-identifier hs-type">XXWarnDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597714"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1688"></span><span>
</span><span id="line-1689"></span><span>
</span><span id="line-1690"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection[AnnDecl]{Annotations}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1697"></span><span>
</span><span id="line-1698"></span><span class="annot"><span class="hs-comment">-- | Located Annotation Declaration</span></span><span>
</span><span id="line-1699"></span><span class="hs-keyword">type</span><span> </span><span id="LAnnDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LAnnDecl"><span class="hs-identifier hs-var">LAnnDecl</span></a></span></span><span> </span><span id="local-6989586621681597719"><span class="annot"><a href="#local-6989586621681597719"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597719"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#AnnDecl"><span class="hs-identifier hs-type">AnnDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597719"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1700"></span><span>
</span><span id="line-1701"></span><span class="annot"><span class="hs-comment">-- | Annotation Declaration</span></span><span>
</span><span id="line-1702"></span><span class="hs-keyword">data</span><span> </span><span id="AnnDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#AnnDecl"><span class="hs-identifier hs-var">AnnDecl</span></a></span></span><span> </span><span id="local-6989586621681597720"><span class="annot"><a href="#local-6989586621681597720"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="HsAnnotation"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsAnnotation"><span class="hs-identifier hs-var">HsAnnotation</span></a></span></span><span>
</span><span id="line-1703"></span><span>                      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsAnnotation"><span class="hs-identifier hs-type">XHsAnnotation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597720"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1704"></span><span>                      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#AnnProvenance"><span class="hs-identifier hs-type">AnnProvenance</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597720"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597720"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597720"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1705"></span><span>      </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-1706"></span><span>      </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnType'</span><span>
</span><span id="line-1707"></span><span>      </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnModule'</span><span>
</span><span id="line-1708"></span><span>      </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-1709"></span><span>
</span><span id="line-1710"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1711"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XAnnDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XAnnDecl"><span class="hs-identifier hs-var">XAnnDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXAnnDecl"><span class="hs-identifier hs-type">XXAnnDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597720"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1712"></span><span>
</span><span id="line-1713"></span><span class="annot"><span class="hs-comment">-- | Annotation Provenance</span></span><span>
</span><span id="line-1714"></span><span class="hs-keyword">data</span><span> </span><span id="AnnProvenance"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#AnnProvenance"><span class="hs-identifier hs-var">AnnProvenance</span></a></span></span><span> </span><span id="local-6989586621681597725"><span class="annot"><a href="#local-6989586621681597725"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ValueAnnProvenance"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ValueAnnProvenance"><span class="hs-identifier hs-var">ValueAnnProvenance</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597725"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1715"></span><span>                        </span><span class="hs-glyph">|</span><span> </span><span id="TypeAnnProvenance"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TypeAnnProvenance"><span class="hs-identifier hs-var">TypeAnnProvenance</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597725"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1716"></span><span>                        </span><span class="hs-glyph">|</span><span> </span><span id="ModuleAnnProvenance"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ModuleAnnProvenance"><span class="hs-identifier hs-var">ModuleAnnProvenance</span></a></span></span><span>
</span><span id="line-1717"></span><span class="hs-comment">-- deriving instance Functor     AnnProvenance</span><span>
</span><span id="line-1718"></span><span class="hs-comment">-- deriving instance Foldable    AnnProvenance</span><span>
</span><span id="line-1719"></span><span class="hs-comment">-- deriving instance Traversable AnnProvenance</span><span>
</span><span id="line-1720"></span><span class="hs-comment">-- deriving instance (Data pass) =&gt; Data (AnnProvenance pass)</span><span>
</span><span id="line-1721"></span><span>
</span><span id="line-1722"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#annProvenanceName_maybe"><span class="hs-identifier hs-type">annProvenanceName_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681596734"><span class="annot"><a href="#local-6989586621681596734"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596734"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#AnnProvenance"><span class="hs-identifier hs-type">AnnProvenance</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596734"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681596734"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1723"></span><span id="annProvenanceName_maybe"><span class="annot"><span class="annottext">annProvenanceName_maybe :: forall p. UnXRec p =&gt; AnnProvenance p -&gt; Maybe (IdP p)
</span><a href="Language.Haskell.Syntax.Decls.html#annProvenanceName_maybe"><span class="hs-identifier hs-var hs-var">annProvenanceName_maybe</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#ValueAnnProvenance"><span class="hs-identifier hs-type">ValueAnnProvenance</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681596734"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span id="local-6989586621681597733"><span class="annot"><span class="annottext">IdP p
</span><a href="#local-6989586621681597733"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IdP p -&gt; Maybe (IdP p)
forall a. a -&gt; Maybe a
</span><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">IdP p
</span><a href="#local-6989586621681597733"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1724"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#annProvenanceName_maybe"><span class="hs-identifier hs-var">annProvenanceName_maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#TypeAnnProvenance"><span class="hs-identifier hs-type">TypeAnnProvenance</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681596734"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span id="local-6989586621681597734"><span class="annot"><span class="annottext">IdP p
</span><a href="#local-6989586621681597734"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IdP p -&gt; Maybe (IdP p)
forall a. a -&gt; Maybe a
</span><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">IdP p
</span><a href="#local-6989586621681597734"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1725"></span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#annProvenanceName_maybe"><span class="hs-identifier hs-var">annProvenanceName_maybe</span></a></span><span> </span><span class="annot"><span class="annottext">AnnProvenance p
</span><a href="Language.Haskell.Syntax.Decls.html#ModuleAnnProvenance"><span class="hs-identifier hs-var">ModuleAnnProvenance</span></a></span><span>                      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (IdP p)
forall a. Maybe a
</span><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Nothing/GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-1726"></span><span>
</span><span id="line-1727"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection[RoleAnnot]{Role annotations}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1734"></span><span>
</span><span id="line-1735"></span><span class="annot"><span class="hs-comment">-- | Located Role Annotation Declaration</span></span><span>
</span><span id="line-1736"></span><span class="hs-keyword">type</span><span> </span><span id="LRoleAnnotDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LRoleAnnotDecl"><span class="hs-identifier hs-var">LRoleAnnotDecl</span></a></span></span><span> </span><span id="local-6989586621681597735"><span class="annot"><a href="#local-6989586621681597735"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597735"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RoleAnnotDecl"><span class="hs-identifier hs-type">RoleAnnotDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597735"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1737"></span><span>
</span><span id="line-1738"></span><span class="hs-comment">-- See #8185 for more info about why role annotations are</span><span>
</span><span id="line-1739"></span><span class="hs-comment">-- top-level declarations</span><span>
</span><span id="line-1740"></span><span class="annot"><span class="hs-comment">-- | Role Annotation Declaration</span></span><span>
</span><span id="line-1741"></span><span class="hs-keyword">data</span><span> </span><span id="RoleAnnotDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RoleAnnotDecl"><span class="hs-identifier hs-var">RoleAnnotDecl</span></a></span></span><span> </span><span id="local-6989586621681597736"><span class="annot"><a href="#local-6989586621681597736"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1742"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="RoleAnnotDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#RoleAnnotDecl"><span class="hs-identifier hs-var">RoleAnnotDecl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCRoleAnnotDecl"><span class="hs-identifier hs-type">XCRoleAnnotDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597736"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1743"></span><span>                  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597736"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>              </span><span class="hs-comment">-- type constructor</span><span>
</span><span id="line-1744"></span><span>                  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597736"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html#Role"><span class="hs-identifier hs-type">Role</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- optional annotations</span><span>
</span><span id="line-1745"></span><span>      </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnType',</span><span>
</span><span id="line-1746"></span><span>      </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnRole'</span><span>
</span><span id="line-1747"></span><span>
</span><span id="line-1748"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1749"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XRoleAnnotDecl"><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#XRoleAnnotDecl"><span class="hs-identifier hs-var">XRoleAnnotDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXRoleAnnotDecl"><span class="hs-identifier hs-type">XXRoleAnnotDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681597736"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1750"></span></pre></body></html>