<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621681595744"><span id="local-6989586621681595745"></span></span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE DeriveTraversable #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span> </span><span class="hs-comment">-- Wrinkle in Note [Trees That Grow]</span><span>
</span><span id="line-11"></span><span>                                      </span><span class="hs-comment">-- in module Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-12"></span><span class="hs-pragma">{-# LANGUAGE DataKinds #-}</span><span>
</span><span id="line-13"></span><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998

\section[PatSyntax]{Abstract Haskell syntax---patterns}
-}</span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span class="hs-comment">-- See Note [Language.Haskell.Syntax.* Hierarchy] for why not GHC.Hs.*</span><span>
</span><span id="line-21"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.Syntax.Pat</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-22"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier">Pat</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier">LPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-23"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier">ConLikeP</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-24"></span><span>
</span><span id="line-25"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier">HsConPatDetails</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier">hsConPatArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatTyArg"><span class="hs-identifier">HsConPatTyArg</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier">HsRecFields</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier">HsFieldBind</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsFieldBind"><span class="hs-identifier">LHsFieldBind</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier">HsRecField</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecField"><span class="hs-identifier">LHsRecField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecUpdField"><span class="hs-identifier">HsRecUpdField</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecUpdField"><span class="hs-identifier">LHsRecUpdField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier">RecFieldsDotDot</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFields"><span class="hs-identifier">hsRecFields</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldSel"><span class="hs-identifier">hsRecFieldSel</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldsArgs"><span class="hs-identifier">hsRecFieldsArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="hs-pragma">{-# SOURCE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html"><span class="hs-identifier">Language.Haskell.Syntax.Expr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier">SyntaxExpr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier">LHsExpr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSplice"><span class="hs-identifier">HsUntypedSplice</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span class="hs-comment">-- friends:</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html"><span class="hs-identifier">Language.Haskell.Syntax.Basic</span></a></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html"><span class="hs-identifier">Language.Haskell.Syntax.Lit</span></a></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html"><span class="hs-identifier">Language.Haskell.Syntax.Concrete</span></a></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html"><span class="hs-identifier">Language.Haskell.Syntax.Extension</span></a></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html"><span class="hs-identifier">Language.Haskell.Syntax.Type</span></a></span><span>
</span><span id="line-42"></span><span>
</span><span id="line-43"></span><span class="hs-comment">-- libraries:</span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Maybe.html#/Data.Maybe.html"><span class="hs-identifier">Data.Maybe</span></a></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Functor.html#/Data.Functor.html"><span class="hs-identifier">Data.Functor</span></a></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Foldable.html#/Data.Foldable.html"><span class="hs-identifier">Data.Foldable</span></a></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Traversable.html#/Data.Traversable.html"><span class="hs-identifier">Data.Traversable</span></a></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Bool.html#/Data.Bool.html"><span class="hs-identifier">Data.Bool</span></a></span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Data.html#/Data.Data.html"><span class="hs-identifier">Data.Data</span></a></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Eq.html#/Data.Eq.html"><span class="hs-identifier">Data.Eq</span></a></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Ord.html#/Data.Ord.html"><span class="hs-identifier">Data.Ord</span></a></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Int.html#/Data.Int.html"><span class="hs-identifier">Data.Int</span></a></span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Function.html#/Data.Function.html"><span class="hs-identifier">Data.Function</span></a></span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.List.html#/Data.List.html"><span class="hs-identifier">Data.List</span></a></span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="hs-keyword">type</span><span> </span><span id="LPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-var">LPat</span></a></span></span><span> </span><span id="local-6989586621681595756"><span class="annot"><a href="#local-6989586621681595756"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595756"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595756"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span class="hs-comment">-- | Pattern</span><span>
</span><span id="line-59"></span><span class="hs-comment">--</span><span>
</span><span id="line-60"></span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnBang'</span><span>
</span><span id="line-61"></span><span>
</span><span id="line-62"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-63"></span><span class="hs-keyword">data</span><span> </span><span id="Pat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-var">Pat</span></a></span></span><span> </span><span id="local-6989586621681595570"><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-64"></span><span>  </span><span class="hs-glyph">=</span><span>     </span><span class="hs-comment">------------ Simple patterns ---------------</span><span>
</span><span id="line-65"></span><span>    </span><span id="WildPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-var">WildPat</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildPat"><span class="hs-identifier hs-type">XWildPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- ^ Wildcard Pattern</span><span>
</span><span id="line-66"></span><span>        </span><span class="hs-comment">-- The sole reason for a type on a WildPat is to</span><span>
</span><span id="line-67"></span><span>        </span><span class="hs-comment">-- support hsPatType :: Pat Id -&gt; Type</span><span>
</span><span id="line-68"></span><span>
</span><span id="line-69"></span><span>       </span><span class="hs-comment">-- AZ:TODO above comment needs to be updated</span><span>
</span><span id="line-70"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="VarPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-var">VarPat</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XVarPat"><span class="hs-identifier hs-type">XVarPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-71"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Variable Pattern</span></span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span>                             </span><span class="hs-comment">-- See Note [Located RdrNames] in GHC.Hs.Expr</span><span>
</span><span id="line-74"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LazyPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-var">LazyPat</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLazyPat"><span class="hs-identifier hs-type">XLazyPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-75"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>                </span><span class="hs-comment">-- ^ Lazy Pattern</span><span>
</span><span id="line-76"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnTilde'</span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-79"></span><span>
</span><span id="line-80"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="AsPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-var">AsPat</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAsPat"><span class="hs-identifier hs-type">XAsPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-81"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-82"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;@&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-83"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ As pattern</span><span>
</span><span id="line-84"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnAt'</span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ParPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-var">ParPat</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParPat"><span class="hs-identifier hs-type">XParPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-89"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;(&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-90"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>                </span><span class="annot"><span class="hs-comment">-- ^ Parenthesised pattern</span></span><span>
</span><span id="line-91"></span><span>               </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;)&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-92"></span><span>                                        </span><span class="hs-comment">-- See Note [Parens in HsSyn] in GHC.Hs.Expr</span><span>
</span><span id="line-93"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span><span>
</span><span id="line-94"></span><span>    </span><span class="hs-comment">--                                    'GHC.Parser.Annotation.AnnClose' @')'@</span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-97"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BangPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-var">BangPat</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangPat"><span class="hs-identifier hs-type">XBangPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-98"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>                </span><span class="hs-comment">-- ^ Bang pattern</span><span>
</span><span id="line-99"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnBang'</span><span>
</span><span id="line-100"></span><span>
</span><span id="line-101"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span>        </span><span class="hs-comment">------------ Lists, tuples, arrays ---------------</span><span>
</span><span id="line-104"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ListPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-var">ListPat</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListPat"><span class="hs-identifier hs-type">XListPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span>                </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-106"></span><span>
</span><span id="line-107"></span><span>    </span><span class="hs-comment">-- ^ Syntactic List</span><span>
</span><span id="line-108"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-109"></span><span>    </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'['@,</span><span>
</span><span id="line-110"></span><span>    </span><span class="hs-comment">--                                    'GHC.Parser.Annotation.AnnClose' @']'@</span><span>
</span><span id="line-111"></span><span>
</span><span id="line-112"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TuplePat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-var">TuplePat</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTuplePat"><span class="hs-identifier hs-type">XTuplePat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-115"></span><span>                  </span><span class="hs-comment">-- after typechecking, holds the types of the tuple components</span><span>
</span><span id="line-116"></span><span>                </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>         </span><span class="hs-comment">-- Tuple sub-patterns</span><span>
</span><span id="line-117"></span><span>                </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html#Boxity"><span class="hs-identifier hs-type">Boxity</span></a></span><span>           </span><span class="hs-comment">-- UnitPat is TuplePat []</span><span>
</span><span id="line-118"></span><span>        </span><span class="hs-comment">-- You might think that the post typechecking Type was redundant,</span><span>
</span><span id="line-119"></span><span>        </span><span class="hs-comment">-- because we can get the pattern type by getting the types of the</span><span>
</span><span id="line-120"></span><span>        </span><span class="hs-comment">-- sub-patterns.</span><span>
</span><span id="line-121"></span><span>        </span><span class="hs-comment">-- But it's essential</span><span>
</span><span id="line-122"></span><span>        </span><span class="hs-comment">--      data T a where</span><span>
</span><span id="line-123"></span><span>        </span><span class="hs-comment">--        T1 :: Int -&gt; T Int</span><span>
</span><span id="line-124"></span><span>        </span><span class="hs-comment">--      f :: (T a, a) -&gt; Int</span><span>
</span><span id="line-125"></span><span>        </span><span class="hs-comment">--      f (T1 x, z) = z</span><span>
</span><span id="line-126"></span><span>        </span><span class="hs-comment">-- When desugaring, we must generate</span><span>
</span><span id="line-127"></span><span>        </span><span class="hs-comment">--      f = /\a. \v::a.  case v of (t::T a, w::a) -&gt;</span><span>
</span><span id="line-128"></span><span>        </span><span class="hs-comment">--                       case t of (T1 (x::Int)) -&gt;</span><span>
</span><span id="line-129"></span><span>        </span><span class="hs-comment">-- Note the (w::a), NOT (w::Int), because we have not yet</span><span>
</span><span id="line-130"></span><span>        </span><span class="hs-comment">-- refined 'a' to Int.  So we must know that the second component</span><span>
</span><span id="line-131"></span><span>        </span><span class="hs-comment">-- of the tuple is of type 'a' not Int.  See selectMatchVar</span><span>
</span><span id="line-132"></span><span>        </span><span class="hs-comment">-- (June 14: I'm not sure this comment is right; the sub-patterns</span><span>
</span><span id="line-133"></span><span>        </span><span class="hs-comment">--           will be wrapped in CoPats, no?)</span><span>
</span><span id="line-134"></span><span>    </span><span class="hs-comment">-- ^ Tuple sub-patterns</span><span>
</span><span id="line-135"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-136"></span><span>    </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' :</span><span>
</span><span id="line-137"></span><span>    </span><span class="hs-comment">--            'GHC.Parser.Annotation.AnnOpen' @'('@ or @'(#'@,</span><span>
</span><span id="line-138"></span><span>    </span><span class="hs-comment">--            'GHC.Parser.Annotation.AnnClose' @')'@ or  @'#)'@</span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SumPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-var">SumPat</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumPat"><span class="hs-identifier hs-type">XSumPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- after typechecker, types of the alternative</span><span>
</span><span id="line-141"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- Sum sub-pattern</span><span>
</span><span id="line-142"></span><span>                </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html#ConTag"><span class="hs-identifier hs-type">ConTag</span></a></span><span>             </span><span class="hs-comment">-- Alternative (one-based)</span><span>
</span><span id="line-143"></span><span>                </span><span class="annot"><a href="Language.Haskell.Syntax.Basic.html#SumWidth"><span class="hs-identifier hs-type">SumWidth</span></a></span><span>           </span><span class="hs-comment">-- Arity (INVARIANT: &#8805; 2)</span><span>
</span><span id="line-144"></span><span>    </span><span class="hs-comment">-- ^ Anonymous sum pattern</span><span>
</span><span id="line-145"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-146"></span><span>    </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' :</span><span>
</span><span id="line-147"></span><span>    </span><span class="hs-comment">--            'GHC.Parser.Annotation.AnnOpen' @'(#'@,</span><span>
</span><span id="line-148"></span><span>    </span><span class="hs-comment">--            'GHC.Parser.Annotation.AnnClose' @'#)'@</span><span>
</span><span id="line-149"></span><span>
</span><span id="line-150"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-151"></span><span>
</span><span id="line-152"></span><span>        </span><span class="hs-comment">------------ Constructor patterns ---------------</span><span>
</span><span id="line-153"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ConPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-var">ConPat</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-154"></span><span>        </span><span id="pat_con_ext"><span class="annot"><span class="annottext">forall p. Pat p -&gt; XConPat p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con_ext"><span class="hs-identifier hs-var hs-var">pat_con_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConPat"><span class="hs-identifier hs-type">XConPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-155"></span><span>        </span><span id="pat_con"><span class="annot"><span class="annottext">forall p. Pat p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var hs-var">pat_con</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-type">ConLikeP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-156"></span><span>        </span><span id="pat_args"><span class="annot"><span class="annottext">forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var hs-var">pat_args</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier hs-type">HsConPatDetails</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-157"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-158"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ Constructor Pattern</span></span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span>        </span><span class="hs-comment">------------ View patterns ---------------</span><span>
</span><span id="line-161"></span><span>  </span><span class="annot"><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnRarrow'</span></span><span>
</span><span id="line-162"></span><span>
</span><span id="line-163"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-164"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ViewPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-var">ViewPat</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViewPat"><span class="hs-identifier hs-type">XViewPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-165"></span><span>                  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-166"></span><span>                  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-167"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ View Pattern</span></span><span>
</span><span id="line-168"></span><span>
</span><span id="line-169"></span><span>        </span><span class="hs-comment">------------ Pattern splices ---------------</span><span>
</span><span id="line-170"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'$('@</span><span>
</span><span id="line-171"></span><span>  </span><span class="hs-comment">--        'GHC.Parser.Annotation.AnnClose' @')'@</span><span>
</span><span id="line-172"></span><span>
</span><span id="line-173"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-174"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SplicePat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-var">SplicePat</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSplicePat"><span class="hs-identifier hs-type">XSplicePat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-175"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSplice"><span class="hs-identifier hs-type">HsUntypedSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="annot"><span class="hs-comment">-- ^ Splice Pattern (Includes quasi-quotes)</span></span><span>
</span><span id="line-176"></span><span>
</span><span id="line-177"></span><span>        </span><span class="hs-comment">------------ Literal and n+k patterns ---------------</span><span>
</span><span id="line-178"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LitPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-var">LitPat</span></a></span></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLitPat"><span class="hs-identifier hs-type">XLitPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-179"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsLit"><span class="hs-identifier hs-type">HsLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- ^ Literal Pattern</span><span>
</span><span id="line-180"></span><span>                                        </span><span class="hs-comment">-- Used for *non-overloaded* literal patterns:</span><span>
</span><span id="line-181"></span><span>                                        </span><span class="hs-comment">-- Int#, Char#, Int, Char, String, etc.</span><span>
</span><span id="line-182"></span><span>
</span><span id="line-183"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-var">NPat</span></a></span></span><span>                </span><span class="hs-comment">-- Natural Pattern</span><span>
</span><span id="line-184"></span><span>                        </span><span class="hs-comment">-- Used for all overloaded literals,</span><span>
</span><span id="line-185"></span><span>                        </span><span class="hs-comment">-- including overloaded strings with -XOverloadedStrings</span><span>
</span><span id="line-186"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPat"><span class="hs-identifier hs-type">XNPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>            </span><span class="hs-comment">-- Overall type of pattern. Might be</span><span>
</span><span id="line-187"></span><span>                                         </span><span class="hs-comment">-- different than the literal's type</span><span>
</span><span id="line-188"></span><span>                                         </span><span class="hs-comment">-- if (==) or negate changes the type</span><span>
</span><span id="line-189"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsOverLit"><span class="hs-identifier hs-type">HsOverLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- ALWAYS positive</span><span>
</span><span id="line-190"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Just (Name of 'negate') for</span><span>
</span><span id="line-191"></span><span>                                           </span><span class="hs-comment">-- negative patterns, Nothing</span><span>
</span><span id="line-192"></span><span>                                           </span><span class="hs-comment">-- otherwise</span><span>
</span><span id="line-193"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- Equality checker, of type t-&gt;t-&gt;Bool</span><span>
</span><span id="line-194"></span><span>
</span><span id="line-195"></span><span>  </span><span class="hs-comment">-- ^ Natural Pattern</span><span>
</span><span id="line-196"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-197"></span><span>  </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnVal' @'+'@</span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-200"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NPlusKPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-var">NPlusKPat</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPlusKPat"><span class="hs-identifier hs-type">XNPlusKPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- Type of overall pattern</span><span>
</span><span id="line-201"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>                 </span><span class="hs-comment">-- n+k pattern</span><span>
</span><span id="line-202"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsOverLit"><span class="hs-identifier hs-type">HsOverLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- It'll always be an HsIntegral</span><span>
</span><span id="line-203"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsOverLit"><span class="hs-identifier hs-type">HsOverLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>            </span><span class="hs-comment">-- See Note [NPlusK patterns] in GHC.Tc.Gen.Pat</span><span>
</span><span id="line-204"></span><span>                     </span><span class="hs-comment">-- NB: This could be (PostTc ...), but that induced a</span><span>
</span><span id="line-205"></span><span>                     </span><span class="hs-comment">-- a new hs-boot file. Not worth it.</span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- (&gt;=) function, of type t1-&gt;t2-&gt;Bool</span><span>
</span><span id="line-208"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- Name of '-' (see GHC.Rename.Env.lookupSyntax)</span><span>
</span><span id="line-209"></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ n+k pattern</span></span><span>
</span><span id="line-210"></span><span>
</span><span id="line-211"></span><span>        </span><span class="hs-comment">------------ Pattern type signatures ---------------</span><span>
</span><span id="line-212"></span><span>  </span><span class="annot"><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span></span><span>
</span><span id="line-213"></span><span>
</span><span id="line-214"></span><span>  </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-215"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SigPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-var">SigPat</span></a></span></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigPat"><span class="hs-identifier hs-type">XSigPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- After typechecker: Type</span><span>
</span><span id="line-216"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>                </span><span class="hs-comment">-- Pattern with a type signature</span><span>
</span><span id="line-217"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsPatSigType"><span class="hs-identifier hs-type">HsPatSigType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoGhcTc"><span class="hs-identifier hs-type">NoGhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-comment">--  Signature can bind both</span><span>
</span><span id="line-218"></span><span>                                               </span><span class="hs-comment">--  kind and type vars</span><span>
</span><span id="line-219"></span><span>
</span><span id="line-220"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ Pattern with a type signature</span></span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span>  </span><span class="hs-comment">-- Extension point; see Note [Trees That Grow] in Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-223"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XPat"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-var">XPat</span></a></span></span><span>
</span><span id="line-224"></span><span>      </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPat"><span class="hs-identifier hs-type">XXPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595570"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-225"></span><span>
</span><span id="line-226"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="ConLikeP"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-var">ConLikeP</span></a></span></span><span> </span><span id="local-6989586621681595801"><span class="annot"><a href="#local-6989586621681595801"><span class="hs-identifier hs-type">x</span></a></span></span><span>
</span><span id="line-227"></span><span>
</span><span id="line-228"></span><span>
</span><span id="line-229"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span class="hs-comment">-- | Type argument in a data constructor pattern,</span><span>
</span><span id="line-232"></span><span class="hs-comment">--   e.g. the @\@a@ in @f (Just \@a x) = ...@.</span><span>
</span><span id="line-233"></span><span class="hs-keyword">data</span><span> </span><span id="HsConPatTyArg"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatTyArg"><span class="hs-identifier hs-var">HsConPatTyArg</span></a></span></span><span> </span><span id="local-6989586621681595802"><span class="annot"><a href="#local-6989586621681595802"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-234"></span><span>  </span><span id="HsConPatTyArg"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatTyArg"><span class="hs-identifier hs-var">HsConPatTyArg</span></a></span></span><span>
</span><span id="line-235"></span><span>    </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;@&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681595802"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-236"></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsPatSigType"><span class="hs-identifier hs-type">HsPatSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595802"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-237"></span><span>
</span><span id="line-238"></span><span class="annot"><span class="hs-comment">-- | Haskell Constructor Pattern Details</span></span><span>
</span><span id="line-239"></span><span class="hs-keyword">type</span><span> </span><span id="HsConPatDetails"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier hs-var">HsConPatDetails</span></a></span></span><span> </span><span id="local-6989586621681595804"><span class="annot"><a href="#local-6989586621681595804"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsConDetails"><span class="hs-identifier hs-type">HsConDetails</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatTyArg"><span class="hs-identifier hs-type">HsConPatTyArg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoGhcTc"><span class="hs-identifier hs-type">NoGhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595804"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595804"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595804"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595804"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-240"></span><span>
</span><span id="line-241"></span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-type">hsConPatArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681595579"><span class="annot"><a href="#local-6989586621681595579"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595579"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier hs-type">HsConPatDetails</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595579"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595579"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-242"></span><span id="hsConPatArgs"><span class="annot"><span class="annottext">hsConPatArgs :: forall p. UnXRec p =&gt; HsConPatDetails p -&gt; [LPat p]
</span><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-var hs-var">hsConPatArgs</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-type">PrefixCon</span></a></span><span> </span><span class="annot"><span class="annottext">[HsConPatTyArg (NoGhcTc p)]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681595808"><span class="annot"><span class="annottext">[LPat p]
</span><a href="#local-6989586621681595808"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[LPat p]
</span><a href="#local-6989586621681595808"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-243"></span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-var">hsConPatArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#RecCon"><span class="hs-identifier hs-type">RecCon</span></a></span><span> </span><span id="local-6989586621681595810"><span class="annot"><span class="annottext">HsRecFields p (LPat p)
</span><a href="#local-6989586621681595810"><span class="hs-identifier hs-var">fs</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(XRec p (HsFieldBind (XRec p (FieldOcc p)) (LPat p)) -&gt; LPat p)
-&gt; [XRec p (HsFieldBind (XRec p (FieldOcc p)) (LPat p))]
-&gt; [LPat p]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">Data.List.map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsFieldBind (XRec p (FieldOcc p)) (LPat p) -&gt; LPat p
forall lhs rhs. HsFieldBind lhs rhs -&gt; rhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbRHS"><span class="hs-identifier hs-var">hfbRHS</span></a></span><span> </span><span class="annot"><span class="annottext">(HsFieldBind (XRec p (FieldOcc p)) (LPat p) -&gt; LPat p)
-&gt; (XRec p (HsFieldBind (XRec p (FieldOcc p)) (LPat p))
    -&gt; HsFieldBind (XRec p (FieldOcc p)) (LPat p))
-&gt; XRec p (HsFieldBind (XRec p (FieldOcc p)) (LPat p))
-&gt; LPat p
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681595579"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsRecFields p (LPat p)
-&gt; [XRec p (HsFieldBind (XRec p (FieldOcc p)) (LPat p))]
forall p arg. HsRecFields p arg -&gt; [LHsRecField p arg]
</span><a href="Language.Haskell.Syntax.Pat.html#rec_flds"><span class="hs-identifier hs-var">rec_flds</span></a></span><span> </span><span class="annot"><span class="annottext">HsRecFields p (LPat p)
</span><a href="#local-6989586621681595810"><span class="hs-identifier hs-var">fs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-244"></span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-var">hsConPatArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-type">InfixCon</span></a></span><span> </span><span id="local-6989586621681595816"><span class="annot"><span class="annottext">LPat p
</span><a href="#local-6989586621681595816"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span id="local-6989586621681595817"><span class="annot"><span class="annottext">LPat p
</span><a href="#local-6989586621681595817"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat p
</span><a href="#local-6989586621681595816"><span class="hs-identifier hs-var">p1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LPat p
</span><a href="#local-6989586621681595817"><span class="hs-identifier hs-var">p2</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-245"></span><span>
</span><span id="line-246"></span><span class="hs-comment">-- | Haskell Record Fields</span><span>
</span><span id="line-247"></span><span class="hs-comment">--</span><span>
</span><span id="line-248"></span><span class="hs-comment">-- HsRecFields is used only for patterns and expressions (not data type</span><span>
</span><span id="line-249"></span><span class="hs-comment">-- declarations)</span><span>
</span><span id="line-250"></span><span class="hs-keyword">data</span><span> </span><span id="HsRecFields"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-var">HsRecFields</span></a></span></span><span> </span><span id="local-6989586621681595598"><span class="annot"><a href="#local-6989586621681595598"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681595599"><span class="annot"><a href="#local-6989586621681595599"><span class="hs-identifier hs-type">arg</span></a></span></span><span>         </span><span class="hs-comment">-- A bunch of record fields</span><span>
</span><span id="line-251"></span><span>                                </span><span class="hs-comment">--      { x = 3, y = True }</span><span>
</span><span id="line-252"></span><span>        </span><span class="hs-comment">-- Used for both expressions and patterns</span><span>
</span><span id="line-253"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsRecFields"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-var">HsRecFields</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="rec_flds"><span class="annot"><span class="annottext">forall p arg. HsRecFields p arg -&gt; [LHsRecField p arg]
</span><a href="Language.Haskell.Syntax.Pat.html#rec_flds"><span class="hs-identifier hs-var hs-var">rec_flds</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecField"><span class="hs-identifier hs-type">LHsRecField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595598"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595599"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-254"></span><span>                  </span><span id="rec_dotdot"><span class="annot"><span class="annottext">forall p arg. HsRecFields p arg -&gt; Maybe (XRec p RecFieldsDotDot)
</span><a href="Language.Haskell.Syntax.Pat.html#rec_dotdot"><span class="hs-identifier hs-var hs-var">rec_dotdot</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595598"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-type">RecFieldsDotDot</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>  </span><span class="hs-comment">-- Note [DotDot fields]</span><span>
</span><span id="line-255"></span><span>  </span><span class="hs-comment">-- AZ:The XRec for LHsRecField makes the derivings fail.</span><span>
</span><span id="line-256"></span><span>  </span><span class="hs-comment">-- deriving (Functor, Foldable, Traversable)</span><span>
</span><span id="line-257"></span><span>
</span><span id="line-258"></span><span class="annot"><span class="hs-comment">-- | Newtype to be able to have a specific XRec instance for the Int in `rec_dotdot`</span></span><span>
</span><span id="line-259"></span><span class="hs-keyword">newtype</span><span> </span><span id="RecFieldsDotDot"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-var">RecFieldsDotDot</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="RecFieldsDotDot"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#RecFieldsDotDot"><span class="hs-identifier hs-var">RecFieldsDotDot</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="unRecFieldsDotDot"><span class="annot"><span class="annottext">RecFieldsDotDot -&gt; Int
</span><a href="Language.Haskell.Syntax.Pat.html#unRecFieldsDotDot"><span class="hs-identifier hs-var hs-var">unRecFieldsDotDot</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-260"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621681595825"><span id="local-6989586621681595829"><span id="local-6989586621681595832"><span id="local-6989586621681595834"><span id="local-6989586621681595836"><span id="local-6989586621681595842"><span id="local-6989586621681595847"><span id="local-6989586621681595850"><span id="local-6989586621681595853"><span id="local-6989586621681595856"><span id="local-6989586621681595859"><span id="local-6989586621681595862"><span id="local-6989586621681595867"><span id="local-6989586621681595872"><span class="annot"><span class="annottext">Typeable RecFieldsDotDot
Typeable RecFieldsDotDot =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; RecFieldsDotDot -&gt; c RecFieldsDotDot)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RecFieldsDotDot)
-&gt; (RecFieldsDotDot -&gt; Constr)
-&gt; (RecFieldsDotDot -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RecFieldsDotDot))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c RecFieldsDotDot))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RecFieldsDotDot -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RecFieldsDotDot -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; RecFieldsDotDot -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RecFieldsDotDot -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot)
-&gt; Data RecFieldsDotDot
RecFieldsDotDot -&gt; Constr
RecFieldsDotDot -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RecFieldsDotDot -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RecFieldsDotDot -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RecFieldsDotDot -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RecFieldsDotDot -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RecFieldsDotDot
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RecFieldsDotDot -&gt; c RecFieldsDotDot
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RecFieldsDotDot)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c RecFieldsDotDot)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RecFieldsDotDot -&gt; c RecFieldsDotDot
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RecFieldsDotDot -&gt; c RecFieldsDotDot
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RecFieldsDotDot
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RecFieldsDotDot
$ctoConstr :: RecFieldsDotDot -&gt; Constr
toConstr :: RecFieldsDotDot -&gt; Constr
$cdataTypeOf :: RecFieldsDotDot -&gt; DataType
dataTypeOf :: RecFieldsDotDot -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RecFieldsDotDot)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RecFieldsDotDot)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c RecFieldsDotDot)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c RecFieldsDotDot)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RecFieldsDotDot -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RecFieldsDotDot -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RecFieldsDotDot -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RecFieldsDotDot -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RecFieldsDotDot -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RecFieldsDotDot -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RecFieldsDotDot -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RecFieldsDotDot -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; RecFieldsDotDot -&gt; m RecFieldsDotDot
</span><a href="../../base-4.18.2.1/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681595878"><span id="local-6989586621681595883"><span class="annot"><span class="annottext">RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
(RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool)
-&gt; (RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool)
-&gt; Eq RecFieldsDotDot
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
== :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
$c/= :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
/= :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681595891"><span id="local-6989586621681595896"><span id="local-6989586621681595900"><span id="local-6989586621681595904"><span id="local-6989586621681595908"><span id="local-6989586621681595912"><span id="local-6989586621681595916"><span class="annot"><span class="annottext">Eq RecFieldsDotDot
Eq RecFieldsDotDot =&gt;
(RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Ordering)
-&gt; (RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool)
-&gt; (RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool)
-&gt; (RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool)
-&gt; (RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool)
-&gt; (RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot)
-&gt; (RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot)
-&gt; Ord RecFieldsDotDot
RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Ordering
RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Ordering
compare :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Ordering
$c&lt; :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
&lt; :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
$c&lt;= :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
&lt;= :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
$c&gt; :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
&gt; :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
$c&gt;= :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
&gt;= :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; Bool
$cmax :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot
max :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot
$cmin :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot
min :: RecFieldsDotDot -&gt; RecFieldsDotDot -&gt; RecFieldsDotDot
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-261"></span><span>
</span><span id="line-262"></span><span class="hs-comment">-- Note [DotDot fields]</span><span>
</span><span id="line-263"></span><span class="hs-comment">-- ~~~~~~~~~~~~~~~~~~~~</span><span>
</span><span id="line-264"></span><span class="hs-comment">-- The rec_dotdot field means this:</span><span>
</span><span id="line-265"></span><span class="hs-comment">--   Nothing =&gt; the normal case</span><span>
</span><span id="line-266"></span><span class="hs-comment">--   Just n  =&gt; the group uses &quot;..&quot; notation,</span><span>
</span><span id="line-267"></span><span class="hs-comment">--</span><span>
</span><span id="line-268"></span><span class="hs-comment">-- In the latter case:</span><span>
</span><span id="line-269"></span><span class="hs-comment">--</span><span>
</span><span id="line-270"></span><span class="hs-comment">--   *before* renamer: rec_flds are exactly the n user-written fields</span><span>
</span><span id="line-271"></span><span class="hs-comment">--</span><span>
</span><span id="line-272"></span><span class="hs-comment">--   *after* renamer:  rec_flds includes *all* fields, with</span><span>
</span><span id="line-273"></span><span class="hs-comment">--                     the first 'n' being the user-written ones</span><span>
</span><span id="line-274"></span><span class="hs-comment">--                     and the remainder being 'filled in' implicitly</span><span>
</span><span id="line-275"></span><span>
</span><span id="line-276"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Record Field</span></span><span>
</span><span id="line-277"></span><span class="hs-keyword">type</span><span> </span><span id="LHsFieldBind"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsFieldBind"><span class="hs-identifier hs-var">LHsFieldBind</span></a></span></span><span> </span><span id="local-6989586621681595921"><span class="annot"><a href="#local-6989586621681595921"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681595922"><span class="annot"><a href="#local-6989586621681595922"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span id="local-6989586621681595923"><span class="annot"><a href="#local-6989586621681595923"><span class="hs-identifier hs-type">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595921"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595922"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595923"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-278"></span><span>
</span><span id="line-279"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Record Field</span></span><span>
</span><span id="line-280"></span><span class="hs-keyword">type</span><span> </span><span id="LHsRecField"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecField"><span class="hs-identifier hs-var">LHsRecField</span></a></span></span><span>  </span><span id="local-6989586621681595924"><span class="annot"><a href="#local-6989586621681595924"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681595925"><span class="annot"><a href="#local-6989586621681595925"><span class="hs-identifier hs-type">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595924"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier hs-type">HsRecField</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681595924"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595925"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-281"></span><span>
</span><span id="line-282"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Record Update Field</span></span><span>
</span><span id="line-283"></span><span class="hs-keyword">type</span><span> </span><span id="LHsRecUpdField"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecUpdField"><span class="hs-identifier hs-var">LHsRecUpdField</span></a></span></span><span> </span><span id="local-6989586621681595926"><span class="annot"><a href="#local-6989586621681595926"><span class="hs-identifier hs-type">p</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595926"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecUpdField"><span class="hs-identifier hs-type">HsRecUpdField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595926"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-284"></span><span>
</span><span id="line-285"></span><span class="annot"><span class="hs-comment">-- | Haskell Record Field</span></span><span>
</span><span id="line-286"></span><span class="hs-keyword">type</span><span> </span><span id="HsRecField"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier hs-var">HsRecField</span></a></span></span><span> </span><span id="local-6989586621681595927"><span class="annot"><a href="#local-6989586621681595927"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681595928"><span class="annot"><a href="#local-6989586621681595928"><span class="hs-identifier hs-type">arg</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LFieldOcc"><span class="hs-identifier hs-type">LFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595927"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681595928"><span class="hs-identifier hs-type">arg</span></a></span><span>
</span><span id="line-287"></span><span>
</span><span id="line-288"></span><span class="annot"><span class="hs-comment">-- | Haskell Record Update Field</span></span><span>
</span><span id="line-289"></span><span class="hs-keyword">type</span><span> </span><span id="HsRecUpdField"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecUpdField"><span class="hs-identifier hs-var">HsRecUpdField</span></a></span></span><span> </span><span id="local-6989586621681595930"><span class="annot"><a href="#local-6989586621681595930"><span class="hs-identifier hs-type">p</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-type">HsFieldBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LAmbiguousFieldOcc"><span class="hs-identifier hs-type">LAmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595930"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595930"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-290"></span><span>
</span><span id="line-291"></span><span class="hs-comment">-- | Haskell Field Binding</span><span>
</span><span id="line-292"></span><span class="hs-comment">--</span><span>
</span><span id="line-293"></span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnEqual',</span><span>
</span><span id="line-294"></span><span class="hs-comment">--</span><span>
</span><span id="line-295"></span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-296"></span><span class="hs-keyword">data</span><span> </span><span id="HsFieldBind"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-var">HsFieldBind</span></a></span></span><span> </span><span id="local-6989586621681595591"><span class="annot"><a href="#local-6989586621681595591"><span class="hs-identifier hs-type">lhs</span></a></span></span><span> </span><span id="local-6989586621681595592"><span class="annot"><a href="#local-6989586621681595592"><span class="hs-identifier hs-type">rhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="HsFieldBind"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsFieldBind"><span class="hs-identifier hs-var">HsFieldBind</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-297"></span><span>        </span><span id="hfbAnn"><span class="annot"><span class="annottext">forall lhs rhs. HsFieldBind lhs rhs -&gt; XHsFieldBind lhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbAnn"><span class="hs-identifier hs-var hs-var">hfbAnn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsFieldBind"><span class="hs-identifier hs-type">XHsFieldBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595591"><span class="hs-identifier hs-type">lhs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-298"></span><span>        </span><span id="hfbLHS"><span class="annot"><span class="annottext">forall lhs rhs. HsFieldBind lhs rhs -&gt; lhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbLHS"><span class="hs-identifier hs-var hs-var">hfbLHS</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681595591"><span class="hs-identifier hs-type">lhs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-299"></span><span>        </span><span id="hfbRHS"><span class="annot"><span class="annottext">forall lhs rhs. HsFieldBind lhs rhs -&gt; rhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbRHS"><span class="hs-identifier hs-var hs-var">hfbRHS</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681595592"><span class="hs-identifier hs-type">rhs</span></a></span><span class="hs-special">,</span><span>           </span><span class="annot"><span class="hs-comment">-- ^ Filled in by renamer when punning</span></span><span>
</span><span id="line-300"></span><span>        </span><span id="hfbPun"><span class="annot"><span class="annottext">forall lhs rhs. HsFieldBind lhs rhs -&gt; Bool
</span><a href="Language.Haskell.Syntax.Pat.html#hfbPun"><span class="hs-identifier hs-var hs-var">hfbPun</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ Note [Punning]</span></span><span>
</span><span id="line-301"></span><span>  </span><span class="hs-special">}</span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621681595937"><span id="local-6989586621681595939"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; HsFieldBind lhs a -&gt; HsFieldBind lhs b)
-&gt; (forall a b. a -&gt; HsFieldBind lhs b -&gt; HsFieldBind lhs a)
-&gt; Functor (HsFieldBind lhs)
forall a b. a -&gt; HsFieldBind lhs b -&gt; HsFieldBind lhs a
forall a b. (a -&gt; b) -&gt; HsFieldBind lhs a -&gt; HsFieldBind lhs b
forall lhs a b. a -&gt; HsFieldBind lhs b -&gt; HsFieldBind lhs a
forall lhs a b. (a -&gt; b) -&gt; HsFieldBind lhs a -&gt; HsFieldBind lhs b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall lhs a b. (a -&gt; b) -&gt; HsFieldBind lhs a -&gt; HsFieldBind lhs b
fmap :: forall a b. (a -&gt; b) -&gt; HsFieldBind lhs a -&gt; HsFieldBind lhs b
$c&lt;$ :: forall lhs a b. a -&gt; HsFieldBind lhs b -&gt; HsFieldBind lhs a
&lt;$ :: forall a b. a -&gt; HsFieldBind lhs b -&gt; HsFieldBind lhs a
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#Functor/GHC.Base.html#Functor"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681595943"><span id="local-6989586621681595949"><span id="local-6989586621681595952"><span id="local-6989586621681595957"><span id="local-6989586621681595959"><span id="local-6989586621681595962"><span id="local-6989586621681595965"><span id="local-6989586621681595968"><span id="local-6989586621681595971"><span id="local-6989586621681595974"><span id="local-6989586621681595977"><span id="local-6989586621681595979"><span id="local-6989586621681595982"><span id="local-6989586621681595987"><span id="local-6989586621681595992"><span id="local-6989586621681595997"><span id="local-6989586621681596002"><span class="annot"><span class="annottext">(forall m. Monoid m =&gt; HsFieldBind lhs m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; HsFieldBind lhs a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; HsFieldBind lhs a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; HsFieldBind lhs a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; HsFieldBind lhs a -&gt; a)
-&gt; (forall a. HsFieldBind lhs a -&gt; [a])
-&gt; (forall a. HsFieldBind lhs a -&gt; Bool)
-&gt; (forall a. HsFieldBind lhs a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; HsFieldBind lhs a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; HsFieldBind lhs a -&gt; a)
-&gt; (forall a. Ord a =&gt; HsFieldBind lhs a -&gt; a)
-&gt; (forall a. Num a =&gt; HsFieldBind lhs a -&gt; a)
-&gt; (forall a. Num a =&gt; HsFieldBind lhs a -&gt; a)
-&gt; Foldable (HsFieldBind lhs)
forall a. Eq a =&gt; a -&gt; HsFieldBind lhs a -&gt; Bool
forall a. Num a =&gt; HsFieldBind lhs a -&gt; a
forall a. Ord a =&gt; HsFieldBind lhs a -&gt; a
forall m. Monoid m =&gt; HsFieldBind lhs m -&gt; m
forall a. HsFieldBind lhs a -&gt; Bool
forall a. HsFieldBind lhs a -&gt; Int
forall a. HsFieldBind lhs a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; HsFieldBind lhs a -&gt; a
forall lhs a. Eq a =&gt; a -&gt; HsFieldBind lhs a -&gt; Bool
forall lhs a. Num a =&gt; HsFieldBind lhs a -&gt; a
forall lhs a. Ord a =&gt; HsFieldBind lhs a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; HsFieldBind lhs a -&gt; m
forall lhs m. Monoid m =&gt; HsFieldBind lhs m -&gt; m
forall lhs rhs. HsFieldBind lhs rhs -&gt; Bool
forall lhs a. HsFieldBind lhs a -&gt; Int
forall lhs a. HsFieldBind lhs a -&gt; [a]
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
forall lhs a. (a -&gt; a -&gt; a) -&gt; HsFieldBind lhs a -&gt; a
forall lhs m a. Monoid m =&gt; (a -&gt; m) -&gt; HsFieldBind lhs a -&gt; m
forall lhs b a. (b -&gt; a -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
forall lhs a b. (a -&gt; b -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
$cfold :: forall lhs m. Monoid m =&gt; HsFieldBind lhs m -&gt; m
fold :: forall m. Monoid m =&gt; HsFieldBind lhs m -&gt; m
$cfoldMap :: forall lhs m a. Monoid m =&gt; (a -&gt; m) -&gt; HsFieldBind lhs a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; HsFieldBind lhs a -&gt; m
$cfoldMap' :: forall lhs m a. Monoid m =&gt; (a -&gt; m) -&gt; HsFieldBind lhs a -&gt; m
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; HsFieldBind lhs a -&gt; m
$cfoldr :: forall lhs a b. (a -&gt; b -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
$cfoldr' :: forall lhs a b. (a -&gt; b -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
$cfoldl :: forall lhs b a. (b -&gt; a -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
$cfoldl' :: forall lhs b a. (b -&gt; a -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; HsFieldBind lhs a -&gt; b
$cfoldr1 :: forall lhs a. (a -&gt; a -&gt; a) -&gt; HsFieldBind lhs a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; HsFieldBind lhs a -&gt; a
$cfoldl1 :: forall lhs a. (a -&gt; a -&gt; a) -&gt; HsFieldBind lhs a -&gt; a
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; HsFieldBind lhs a -&gt; a
$ctoList :: forall lhs a. HsFieldBind lhs a -&gt; [a]
toList :: forall a. HsFieldBind lhs a -&gt; [a]
$cnull :: forall lhs rhs. HsFieldBind lhs rhs -&gt; Bool
null :: forall a. HsFieldBind lhs a -&gt; Bool
$clength :: forall lhs a. HsFieldBind lhs a -&gt; Int
length :: forall a. HsFieldBind lhs a -&gt; Int
$celem :: forall lhs a. Eq a =&gt; a -&gt; HsFieldBind lhs a -&gt; Bool
elem :: forall a. Eq a =&gt; a -&gt; HsFieldBind lhs a -&gt; Bool
$cmaximum :: forall lhs a. Ord a =&gt; HsFieldBind lhs a -&gt; a
maximum :: forall a. Ord a =&gt; HsFieldBind lhs a -&gt; a
$cminimum :: forall lhs a. Ord a =&gt; HsFieldBind lhs a -&gt; a
minimum :: forall a. Ord a =&gt; HsFieldBind lhs a -&gt; a
$csum :: forall lhs a. Num a =&gt; HsFieldBind lhs a -&gt; a
sum :: forall a. Num a =&gt; HsFieldBind lhs a -&gt; a
$cproduct :: forall lhs a. Num a =&gt; HsFieldBind lhs a -&gt; a
product :: forall a. Num a =&gt; HsFieldBind lhs a -&gt; a
</span><a href="../../base-4.18.2.1/src/Data.Foldable.html#Foldable/Data.Foldable.html#Foldable"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681596012"><span id="local-6989586621681596017"><span id="local-6989586621681596023"><span id="local-6989586621681596028"><span class="annot"><span class="annottext">Functor (HsFieldBind lhs)
Foldable (HsFieldBind lhs)
(Functor (HsFieldBind lhs), Foldable (HsFieldBind lhs)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; HsFieldBind lhs a -&gt; f (HsFieldBind lhs b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    HsFieldBind lhs (f a) -&gt; f (HsFieldBind lhs a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; HsFieldBind lhs a -&gt; m (HsFieldBind lhs b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    HsFieldBind lhs (m a) -&gt; m (HsFieldBind lhs a))
-&gt; Traversable (HsFieldBind lhs)
forall lhs. Functor (HsFieldBind lhs)
forall lhs. Foldable (HsFieldBind lhs)
forall lhs (m :: * -&gt; *) a.
Monad m =&gt;
HsFieldBind lhs (m a) -&gt; m (HsFieldBind lhs a)
forall lhs (f :: * -&gt; *) a.
Applicative f =&gt;
HsFieldBind lhs (f a) -&gt; f (HsFieldBind lhs a)
forall lhs (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; HsFieldBind lhs a -&gt; m (HsFieldBind lhs b)
forall lhs (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; HsFieldBind lhs a -&gt; f (HsFieldBind lhs b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
HsFieldBind lhs (m a) -&gt; m (HsFieldBind lhs a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
HsFieldBind lhs (f a) -&gt; f (HsFieldBind lhs a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; HsFieldBind lhs a -&gt; m (HsFieldBind lhs b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; HsFieldBind lhs a -&gt; f (HsFieldBind lhs b)
$ctraverse :: forall lhs (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; HsFieldBind lhs a -&gt; f (HsFieldBind lhs b)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; HsFieldBind lhs a -&gt; f (HsFieldBind lhs b)
$csequenceA :: forall lhs (f :: * -&gt; *) a.
Applicative f =&gt;
HsFieldBind lhs (f a) -&gt; f (HsFieldBind lhs a)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
HsFieldBind lhs (f a) -&gt; f (HsFieldBind lhs a)
$cmapM :: forall lhs (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; HsFieldBind lhs a -&gt; m (HsFieldBind lhs b)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; HsFieldBind lhs a -&gt; m (HsFieldBind lhs b)
$csequence :: forall lhs (m :: * -&gt; *) a.
Monad m =&gt;
HsFieldBind lhs (m a) -&gt; m (HsFieldBind lhs a)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
HsFieldBind lhs (m a) -&gt; m (HsFieldBind lhs a)
</span><a href="../../base-4.18.2.1/src/Data.Traversable.html#Traversable/Data.Traversable.html#Traversable"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></a></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-302"></span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span class="hs-comment">-- Note [Punning]</span><span>
</span><span id="line-305"></span><span class="hs-comment">-- ~~~~~~~~~~~~~~</span><span>
</span><span id="line-306"></span><span class="hs-comment">-- If you write T { x, y = v+1 }, the HsRecFields will be</span><span>
</span><span id="line-307"></span><span class="hs-comment">--      HsRecField x x True ...</span><span>
</span><span id="line-308"></span><span class="hs-comment">--      HsRecField y (v+1) False ...</span><span>
</span><span id="line-309"></span><span class="hs-comment">-- That is, for &quot;punned&quot; field x is expanded (in the renamer)</span><span>
</span><span id="line-310"></span><span class="hs-comment">-- to x=x; but with a punning flag so we can detect it later</span><span>
</span><span id="line-311"></span><span class="hs-comment">-- (e.g. when pretty printing)</span><span>
</span><span id="line-312"></span><span class="hs-comment">--</span><span>
</span><span id="line-313"></span><span class="hs-comment">-- If the original field was qualified, we un-qualify it, thus</span><span>
</span><span id="line-314"></span><span class="hs-comment">--    T { A.x } means T { A.x = x }</span><span>
</span><span id="line-315"></span><span>
</span><span id="line-316"></span><span>
</span><span id="line-317"></span><span class="hs-comment">-- Note [HsRecField and HsRecUpdField]</span><span>
</span><span id="line-318"></span><span class="hs-comment">-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><span>
</span><span id="line-319"></span><span>
</span><span id="line-320"></span><span class="hs-comment">-- A HsRecField (used for record construction and pattern matching)</span><span>
</span><span id="line-321"></span><span class="hs-comment">-- contains an unambiguous occurrence of a field (i.e. a FieldOcc).</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- We can't just store the Name, because thanks to</span><span>
</span><span id="line-323"></span><span class="hs-comment">-- DuplicateRecordFields this may not correspond to the label the user</span><span>
</span><span id="line-324"></span><span class="hs-comment">-- wrote.</span><span>
</span><span id="line-325"></span><span class="hs-comment">--</span><span>
</span><span id="line-326"></span><span class="hs-comment">-- A HsRecUpdField (used for record update) contains a potentially</span><span>
</span><span id="line-327"></span><span class="hs-comment">-- ambiguous occurrence of a field (an AmbiguousFieldOcc).  The</span><span>
</span><span id="line-328"></span><span class="hs-comment">-- renamer will fill in the selector function if it can, but if the</span><span>
</span><span id="line-329"></span><span class="hs-comment">-- selector is ambiguous the renamer will defer to the typechecker.</span><span>
</span><span id="line-330"></span><span class="hs-comment">-- After the typechecker, a unique selector will have been determined.</span><span>
</span><span id="line-331"></span><span class="hs-comment">--</span><span>
</span><span id="line-332"></span><span class="hs-comment">-- The renamer produces an Unambiguous result if it can, rather than</span><span>
</span><span id="line-333"></span><span class="hs-comment">-- just doing the lookup in the typechecker, so that completely</span><span>
</span><span id="line-334"></span><span class="hs-comment">-- unambiguous updates can be represented by 'GHC.HsToCore.Quote.repUpdFields'.</span><span>
</span><span id="line-335"></span><span class="hs-comment">--</span><span>
</span><span id="line-336"></span><span class="hs-comment">-- For example, suppose we have:</span><span>
</span><span id="line-337"></span><span class="hs-comment">--</span><span>
</span><span id="line-338"></span><span class="hs-comment">--     data S = MkS { x :: Int }</span><span>
</span><span id="line-339"></span><span class="hs-comment">--     data T = MkT { x :: Int }</span><span>
</span><span id="line-340"></span><span class="hs-comment">--</span><span>
</span><span id="line-341"></span><span class="hs-comment">--     f z = (z { x = 3 }) :: S</span><span>
</span><span id="line-342"></span><span class="hs-comment">--</span><span>
</span><span id="line-343"></span><span class="hs-comment">-- The parsed HsRecUpdField corresponding to the record update will have:</span><span>
</span><span id="line-344"></span><span class="hs-comment">--</span><span>
</span><span id="line-345"></span><span class="hs-comment">--     hfbLHS = Unambiguous &quot;x&quot; noExtField :: AmbiguousFieldOcc RdrName</span><span>
</span><span id="line-346"></span><span class="hs-comment">--</span><span>
</span><span id="line-347"></span><span class="hs-comment">-- After the renamer, this will become:</span><span>
</span><span id="line-348"></span><span class="hs-comment">--</span><span>
</span><span id="line-349"></span><span class="hs-comment">--     hfbLHS = Ambiguous   &quot;x&quot; noExtField :: AmbiguousFieldOcc Name</span><span>
</span><span id="line-350"></span><span class="hs-comment">--</span><span>
</span><span id="line-351"></span><span class="hs-comment">-- (note that the Unambiguous constructor is not type-correct here).</span><span>
</span><span id="line-352"></span><span class="hs-comment">-- The typechecker will determine the particular selector:</span><span>
</span><span id="line-353"></span><span class="hs-comment">--</span><span>
</span><span id="line-354"></span><span class="hs-comment">--     hfbLHS = Unambiguous &quot;x&quot; $sel:x:MkS  :: AmbiguousFieldOcc Id</span><span>
</span><span id="line-355"></span><span class="hs-comment">--</span><span>
</span><span id="line-356"></span><span class="hs-comment">-- See also Note [Disambiguating record fields] in GHC.Tc.Gen.Head.</span><span>
</span><span id="line-357"></span><span>
</span><span id="line-358"></span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFields"><span class="hs-identifier hs-type">hsRecFields</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681595707"><span class="annot"><a href="#local-6989586621681595707"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681595708"><span class="annot"><a href="#local-6989586621681595708"><span class="hs-identifier hs-type">arg</span></a></span></span><span class="hs-operator">.</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595707"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595707"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595708"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCFieldOcc"><span class="hs-identifier hs-type">XCFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595707"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-359"></span><span id="hsRecFields"><span class="annot"><span class="annottext">hsRecFields :: forall p arg. UnXRec p =&gt; HsRecFields p arg -&gt; [XCFieldOcc p]
</span><a href="Language.Haskell.Syntax.Pat.html#hsRecFields"><span class="hs-identifier hs-var hs-var">hsRecFields</span></a></span></span><span> </span><span id="local-6989586621681596037"><span class="annot"><span class="annottext">HsRecFields p arg
</span><a href="#local-6989586621681596037"><span class="hs-identifier hs-var">rbinds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(XRec p (HsFieldBind (XRec p (FieldOcc p)) arg) -&gt; XCFieldOcc p)
-&gt; [XRec p (HsFieldBind (XRec p (FieldOcc p)) arg)]
-&gt; [XCFieldOcc p]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">Data.List.map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsFieldBind (XRec p (FieldOcc p)) arg -&gt; XCFieldOcc p
forall p arg. UnXRec p =&gt; HsRecField p arg -&gt; XCFieldOcc p
</span><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldSel"><span class="hs-identifier hs-var">hsRecFieldSel</span></a></span><span> </span><span class="annot"><span class="annottext">(HsFieldBind (XRec p (FieldOcc p)) arg -&gt; XCFieldOcc p)
-&gt; (XRec p (HsFieldBind (XRec p (FieldOcc p)) arg)
    -&gt; HsFieldBind (XRec p (FieldOcc p)) arg)
-&gt; XRec p (HsFieldBind (XRec p (FieldOcc p)) arg)
-&gt; XCFieldOcc p
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681595707"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsRecFields p arg
-&gt; [XRec p (HsFieldBind (XRec p (FieldOcc p)) arg)]
forall p arg. HsRecFields p arg -&gt; [LHsRecField p arg]
</span><a href="Language.Haskell.Syntax.Pat.html#rec_flds"><span class="hs-identifier hs-var">rec_flds</span></a></span><span> </span><span class="annot"><span class="annottext">HsRecFields p arg
</span><a href="#local-6989586621681596037"><span class="hs-identifier hs-var">rbinds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-360"></span><span>
</span><span id="line-361"></span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldsArgs"><span class="hs-identifier hs-type">hsRecFieldsArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681595715"><span class="annot"><a href="#local-6989586621681595715"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681595716"><span class="annot"><a href="#local-6989586621681595716"><span class="hs-identifier hs-type">arg</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595715"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595715"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595716"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681595716"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-362"></span><span id="hsRecFieldsArgs"><span class="annot"><span class="annottext">hsRecFieldsArgs :: forall p arg. UnXRec p =&gt; HsRecFields p arg -&gt; [arg]
</span><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldsArgs"><span class="hs-identifier hs-var hs-var">hsRecFieldsArgs</span></a></span></span><span> </span><span id="local-6989586621681596040"><span class="annot"><span class="annottext">HsRecFields p arg
</span><a href="#local-6989586621681596040"><span class="hs-identifier hs-var">rbinds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(XRec p (HsFieldBind (XRec p (FieldOcc p)) arg) -&gt; arg)
-&gt; [XRec p (HsFieldBind (XRec p (FieldOcc p)) arg)] -&gt; [arg]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier hs-var">Data.List.map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsFieldBind (XRec p (FieldOcc p)) arg -&gt; arg
forall lhs rhs. HsFieldBind lhs rhs -&gt; rhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbRHS"><span class="hs-identifier hs-var">hfbRHS</span></a></span><span> </span><span class="annot"><span class="annottext">(HsFieldBind (XRec p (FieldOcc p)) arg -&gt; arg)
-&gt; (XRec p (HsFieldBind (XRec p (FieldOcc p)) arg)
    -&gt; HsFieldBind (XRec p (FieldOcc p)) arg)
-&gt; XRec p (HsFieldBind (XRec p (FieldOcc p)) arg)
-&gt; arg
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681595715"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HsRecFields p arg
-&gt; [XRec p (HsFieldBind (XRec p (FieldOcc p)) arg)]
forall p arg. HsRecFields p arg -&gt; [LHsRecField p arg]
</span><a href="Language.Haskell.Syntax.Pat.html#rec_flds"><span class="hs-identifier hs-var">rec_flds</span></a></span><span> </span><span class="annot"><span class="annottext">HsRecFields p arg
</span><a href="#local-6989586621681596040"><span class="hs-identifier hs-var">rbinds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-363"></span><span>
</span><span id="line-364"></span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldSel"><span class="hs-identifier hs-type">hsRecFieldSel</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681595712"><span class="annot"><a href="#local-6989586621681595712"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681595713"><span class="annot"><a href="#local-6989586621681595713"><span class="hs-identifier hs-type">arg</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595712"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier hs-type">HsRecField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595712"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595713"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCFieldOcc"><span class="hs-identifier hs-type">XCFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681595712"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-365"></span><span id="hsRecFieldSel"><span class="annot"><span class="annottext">hsRecFieldSel :: forall p arg. UnXRec p =&gt; HsRecField p arg -&gt; XCFieldOcc p
</span><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldSel"><span class="hs-identifier hs-var hs-var">hsRecFieldSel</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FieldOcc p -&gt; XCFieldOcc p
forall pass. FieldOcc pass -&gt; XCFieldOcc pass
</span><a href="Language.Haskell.Syntax.Type.html#foExt"><span class="hs-identifier hs-var">foExt</span></a></span><span> </span><span class="annot"><span class="annottext">(FieldOcc p -&gt; XCFieldOcc p)
-&gt; (HsFieldBind (XRec p (FieldOcc p)) arg -&gt; FieldOcc p)
-&gt; HsFieldBind (XRec p (FieldOcc p)) arg
-&gt; XCFieldOcc p
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681595712"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="annottext">(XRec p (FieldOcc p) -&gt; FieldOcc p)
-&gt; (HsFieldBind (XRec p (FieldOcc p)) arg -&gt; XRec p (FieldOcc p))
-&gt; HsFieldBind (XRec p (FieldOcc p)) arg
-&gt; FieldOcc p
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">HsFieldBind (XRec p (FieldOcc p)) arg -&gt; XRec p (FieldOcc p)
forall lhs rhs. HsFieldBind lhs rhs -&gt; lhs
</span><a href="Language.Haskell.Syntax.Pat.html#hfbLHS"><span class="hs-identifier hs-var">hfbLHS</span></a></span><span>
</span><span id="line-366"></span><span>
</span><span id="line-367"></span></pre></body></html>