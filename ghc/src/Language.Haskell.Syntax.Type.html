<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621681629446"><span id="local-6989586621681629447"><span id="local-6989586621681629448"><span id="local-6989586621681629449"><span id="local-6989586621681629450"><span id="local-6989586621681629451"><span id="local-6989586621681629452"><span id="local-6989586621681629453"><span id="local-6989586621681629454"><span id="local-6989586621681629455"><span id="local-6989586621681629456"><span id="local-6989586621681629457"></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE DataKinds #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span> </span><span class="hs-comment">-- Wrinkle in Note [Trees That Grow]</span><span>
</span><span id="line-11"></span><span>                                      </span><span class="hs-comment">-- in module Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-12"></span><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998


GHC.Hs.Type: Abstract syntax: user-defined types
-}</span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span class="hs-comment">-- See Note [Language.Haskell.Syntax.* Hierarchy] for why not GHC.Hs.*</span><span>
</span><span id="line-21"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.Syntax.Type</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-22"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsScaled"><span class="hs-identifier">HsScaled</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-23"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hsMult"><span class="hs-identifier">hsMult</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hsScaledThing"><span class="hs-identifier">hsScaledThing</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-24"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsArrow"><span class="hs-identifier">HsArrow</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsLinearArrowTokens"><span class="hs-identifier">HsLinearArrowTokens</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsType"><span class="hs-identifier">HsType</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier">LHsType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsKind"><span class="hs-identifier">HsKind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsKind"><span class="hs-identifier">LHsKind</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsForAllTelescope"><span class="hs-identifier">HsForAllTelescope</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTyVarBndr"><span class="hs-identifier">HsTyVarBndr</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTyVarBndr"><span class="hs-identifier">LHsTyVarBndr</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsQTyVars"><span class="hs-identifier">LHsQTyVars</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterTyVarBndrs"><span class="hs-identifier">HsOuterTyVarBndrs</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterFamEqnTyVarBndrs"><span class="hs-identifier">HsOuterFamEqnTyVarBndrs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterSigTyVarBndrs"><span class="hs-identifier">HsOuterSigTyVarBndrs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsWildCardBndrs"><span class="hs-identifier">HsWildCardBndrs</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsPatSigType"><span class="hs-identifier">HsPatSigType</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsSigType"><span class="hs-identifier">HsSigType</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier">LHsSigType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigWcType"><span class="hs-identifier">LHsSigWcType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsWcType"><span class="hs-identifier">LHsWcType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTupleSort"><span class="hs-identifier">HsTupleSort</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-35"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsContext"><span class="hs-identifier">HsContext</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsContext"><span class="hs-identifier">LHsContext</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-36"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTyLit"><span class="hs-identifier">HsTyLit</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-37"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier">HsIPName</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hsIPNameFS"><span class="hs-identifier">hsIPNameFS</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsArg"><span class="hs-identifier">HsArg</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTypeArg"><span class="hs-identifier">LHsTypeArg</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-40"></span><span>
</span><span id="line-41"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LBangType"><span class="hs-identifier">LBangType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#BangType"><span class="hs-identifier">BangType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-42"></span><span>        </span><span class="annot"><a href="GHC.Core.DataCon.html#HsSrcBang"><span class="hs-identifier">HsSrcBang</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PromotionFlag"><span class="hs-identifier">PromotionFlag</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#isPromoted"><span class="hs-identifier">isPromoted</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-44"></span><span>
</span><span id="line-45"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#ConDeclField"><span class="hs-identifier">ConDeclField</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LConDeclField"><span class="hs-identifier">LConDeclField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-46"></span><span>
</span><span id="line-47"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsConDetails"><span class="hs-identifier">HsConDetails</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#noTypeArgs"><span class="hs-identifier">noTypeArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#FieldOcc"><span class="hs-identifier">FieldOcc</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LFieldOcc"><span class="hs-identifier">LFieldOcc</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-50"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#AmbiguousFieldOcc"><span class="hs-identifier">AmbiguousFieldOcc</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LAmbiguousFieldOcc"><span class="hs-identifier">LAmbiguousFieldOcc</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#mapHsOuterImplicit"><span class="hs-identifier">mapHsOuterImplicit</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-53"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hsQTvExplicit"><span class="hs-identifier">hsQTvExplicit</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-54"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#isHsKindedTyVar"><span class="hs-identifier">isHsKindedTyVar</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-55"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hsPatSigType"><span class="hs-identifier">hsPatSigType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-56"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="hs-pragma">{-# SOURCE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html"><span class="hs-identifier">Language.Haskell.Syntax.Expr</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSplice"><span class="hs-identifier">HsUntypedSplice</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html"><span class="hs-identifier">Language.Haskell.Syntax.Concrete</span></a></span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html"><span class="hs-identifier">Language.Haskell.Syntax.Extension</span></a></span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html"><span class="hs-identifier">GHC.Types.Name.Reader</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier">RdrName</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-64"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html"><span class="hs-identifier">GHC.Core.DataCon</span></a></span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#HsSrcBang"><span class="hs-identifier">HsSrcBang</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-65"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Type.html"><span class="hs-identifier">GHC.Core.Type</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Var.html#Specificity"><span class="hs-identifier">Specificity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-66"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html"><span class="hs-identifier">GHC.Types.SrcLoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SrcLoc.html#SrcSpan"><span class="hs-identifier">SrcSpan</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-67"></span><span>
</span><span id="line-68"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Doc.html"><span class="hs-identifier">GHC.Hs.Doc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier">LHsDoc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-69"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.FastString.html"><span class="hs-identifier">GHC.Data.FastString</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Data.FastString.html#FastString"><span class="hs-identifier">FastString</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-70"></span><span>
</span><span id="line-71"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Data.html#/Data.Data.html"><span class="hs-identifier">Data.Data</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Data.html#Fixity/Data.Data.html#Fixity"><span class="hs-identifier">Fixity</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Data.html#Prefix/Data.Data.html#Prefix"><span class="hs-identifier">Prefix</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Data.html#Infix/Data.Data.html#Infix"><span class="hs-identifier">Infix</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-72"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Void.html#/Data.Void.html"><span class="hs-identifier">Data.Void</span></a></span><span>
</span><span id="line-73"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Maybe.html#/Data.Maybe.html"><span class="hs-identifier">Data.Maybe</span></a></span><span>
</span><span id="line-74"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Eq.html#/Data.Eq.html"><span class="hs-identifier">Data.Eq</span></a></span><span>
</span><span id="line-75"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Bool.html#/Data.Bool.html"><span class="hs-identifier">Data.Bool</span></a></span><span>
</span><span id="line-76"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Data.Char.html#/Data.Char.html"><span class="hs-identifier">Data.Char</span></a></span><span>
</span><span id="line-77"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/Prelude.html#/Prelude.html"><span class="hs-identifier">Prelude</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Integer</span></span><span class="hs-special">)</span><span>
</span><span id="line-78"></span><span>
</span><span id="line-79"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Promotion flag}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span class="annot"><span class="hs-comment">-- | Is a TyCon a promoted data constructor or just a normal type constructor?</span></span><span>
</span><span id="line-88"></span><span class="hs-keyword">data</span><span> </span><span id="PromotionFlag"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PromotionFlag"><span class="hs-identifier hs-var">PromotionFlag</span></a></span></span><span>
</span><span id="line-89"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="NotPromoted"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#NotPromoted"><span class="hs-identifier hs-var">NotPromoted</span></a></span></span><span>
</span><span id="line-90"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="IsPromoted"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#IsPromoted"><span class="hs-identifier hs-var">IsPromoted</span></a></span></span><span>
</span><span id="line-91"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span> </span><span id="local-6989586621681629491"><span id="local-6989586621681629493"><span class="annot"><span class="annottext">PromotionFlag -&gt; PromotionFlag -&gt; Bool
(PromotionFlag -&gt; PromotionFlag -&gt; Bool)
-&gt; (PromotionFlag -&gt; PromotionFlag -&gt; Bool) -&gt; Eq PromotionFlag
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: PromotionFlag -&gt; PromotionFlag -&gt; Bool
== :: PromotionFlag -&gt; PromotionFlag -&gt; Bool
$c/= :: PromotionFlag -&gt; PromotionFlag -&gt; Bool
/= :: PromotionFlag -&gt; PromotionFlag -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681629500"><span id="local-6989586621681629502"><span id="local-6989586621681629504"><span id="local-6989586621681629506"><span id="local-6989586621681629508"><span id="local-6989586621681629514"><span id="local-6989586621681629519"><span id="local-6989586621681629522"><span id="local-6989586621681629525"><span id="local-6989586621681629528"><span id="local-6989586621681629531"><span id="local-6989586621681629534"><span id="local-6989586621681629539"><span id="local-6989586621681629544"><span class="annot"><span class="annottext">Typeable PromotionFlag
Typeable PromotionFlag =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; PromotionFlag -&gt; c PromotionFlag)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PromotionFlag)
-&gt; (PromotionFlag -&gt; Constr)
-&gt; (PromotionFlag -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PromotionFlag))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c PromotionFlag))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; PromotionFlag -&gt; PromotionFlag)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PromotionFlag -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PromotionFlag -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PromotionFlag -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PromotionFlag -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag)
-&gt; Data PromotionFlag
PromotionFlag -&gt; Constr
PromotionFlag -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; PromotionFlag -&gt; PromotionFlag
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PromotionFlag -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PromotionFlag -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PromotionFlag -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PromotionFlag -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PromotionFlag
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PromotionFlag -&gt; c PromotionFlag
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PromotionFlag)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c PromotionFlag)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PromotionFlag -&gt; c PromotionFlag
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PromotionFlag -&gt; c PromotionFlag
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PromotionFlag
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PromotionFlag
$ctoConstr :: PromotionFlag -&gt; Constr
toConstr :: PromotionFlag -&gt; Constr
$cdataTypeOf :: PromotionFlag -&gt; DataType
dataTypeOf :: PromotionFlag -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PromotionFlag)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PromotionFlag)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c PromotionFlag)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c PromotionFlag)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; PromotionFlag -&gt; PromotionFlag
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; PromotionFlag -&gt; PromotionFlag
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PromotionFlag -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PromotionFlag -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PromotionFlag -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PromotionFlag -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PromotionFlag -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PromotionFlag -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PromotionFlag -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PromotionFlag -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PromotionFlag -&gt; m PromotionFlag
</span><a href="../../base-4.18.3.0/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-92"></span><span>
</span><span id="line-93"></span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#isPromoted"><span class="hs-identifier hs-type">isPromoted</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PromotionFlag"><span class="hs-identifier hs-type">PromotionFlag</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-94"></span><span id="isPromoted"><span class="annot"><span class="annottext">isPromoted :: PromotionFlag -&gt; Bool
</span><a href="Language.Haskell.Syntax.Type.html#isPromoted"><span class="hs-identifier hs-var hs-var">isPromoted</span></a></span></span><span> </span><span class="annot"><span class="annottext">PromotionFlag
</span><a href="Language.Haskell.Syntax.Type.html#IsPromoted"><span class="hs-identifier hs-var">IsPromoted</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-95"></span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#isPromoted"><span class="hs-identifier hs-var">isPromoted</span></a></span><span> </span><span class="annot"><span class="annottext">PromotionFlag
</span><a href="Language.Haskell.Syntax.Type.html#NotPromoted"><span class="hs-identifier hs-var">NotPromoted</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Bang annotations}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-104"></span><span>
</span><span id="line-105"></span><span class="annot"><span class="hs-comment">-- | Located Bang Type</span></span><span>
</span><span id="line-106"></span><span class="hs-keyword">type</span><span> </span><span id="LBangType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LBangType"><span class="hs-identifier hs-var">LBangType</span></a></span></span><span> </span><span id="local-6989586621681629549"><span class="annot"><a href="#local-6989586621681629549"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629549"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#BangType"><span class="hs-identifier hs-type">BangType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629549"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span class="hs-comment">-- | Bang Type</span><span>
</span><span id="line-109"></span><span class="hs-comment">--</span><span>
</span><span id="line-110"></span><span class="hs-comment">-- In the parser, strictness and packedness annotations bind more tightly</span><span>
</span><span id="line-111"></span><span class="hs-comment">-- than docstrings. This means that when consuming a 'BangType' (and looking</span><span>
</span><span id="line-112"></span><span class="hs-comment">-- for 'HsBangTy') we must be ready to peer behind a potential layer of</span><span>
</span><span id="line-113"></span><span class="hs-comment">-- 'HsDocTy'. See #15206 for motivation and 'getBangType' for an example.</span><span>
</span><span id="line-114"></span><span class="hs-keyword">type</span><span> </span><span id="BangType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#BangType"><span class="hs-identifier hs-var">BangType</span></a></span></span><span> </span><span id="local-6989586621681629552"><span class="annot"><a href="#local-6989586621681629552"><span class="hs-identifier hs-type">pass</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsType"><span class="hs-identifier hs-type">HsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629552"><span class="hs-identifier hs-type">pass</span></a></span><span>       </span><span class="hs-comment">-- Bangs are in the HsType data type</span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Data types}
*                                                                      *
************************************************************************

This is the syntax for types as seen in type signatures.

Note [HsBSig binder lists]
~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider a binder (or pattern) decorated with a type or kind,
   \ (x :: a -&gt; a). blah
   forall (a :: k -&gt; *) (b :: k). blah
Then we use a LHsBndrSig on the binder, so that the
renamer can decorate it with the variables bound
by the pattern ('a' in the first example, 'k' in the second),
assuming that neither of them is in scope already
See also Note [Kind and type-variable binders] in GHC.Rename.HsType

Note [HsType binders]
~~~~~~~~~~~~~~~~~~~~~
The system for recording type and kind-variable binders in HsTypes
is a bit complicated.  Here's how it works.

* In a HsType,
     HsForAllTy   represents an /explicit, user-written/ 'forall' that
                  is nested within another HsType
                   e.g.   forall a b.   {...} or
                          forall a b -&gt; {...}

                  Note that top-level 'forall's are represented with a
                  different AST form. See the description of HsOuterTyVarBndrs
                  below.
     HsQualTy     represents an /explicit, user-written/ context
                   e.g.   (Eq a, Show a) =&gt; ...
                  The context can be empty if that's what the user wrote
  These constructors represent what the user wrote, no more
  and no less.

* The ForAllTelescope field of HsForAllTy represents whether a forall is
  invisible (e.g., forall a b. {...}, with a dot) or visible
  (e.g., forall a b -&gt; {...}, with an arrow).

* HsTyVarBndr describes a quantified type variable written by the
  user.  For example
     f :: forall a (b :: *).  blah
  here 'a' and '(b::*)' are each a HsTyVarBndr.  A HsForAllTy has
  a list of LHsTyVarBndrs.

* HsOuterTyVarBndrs is used to represent the outermost quantified type
  variables in a type that obeys the forall-or-nothing rule. An
  HsOuterTyVarBndrs can be one of the following:

    HsOuterImplicit (implicit quantification, added by renamer)
          f :: a -&gt; a     -- Desugars to f :: forall {a}. a -&gt; a
    HsOuterExplicit (explicit user quantification):
          f :: forall a. a -&gt; a

  See Note [forall-or-nothing rule].

* An HsSigType is an LHsType with an accompanying HsOuterTyVarBndrs that
  represents the presence (or absence) of its outermost 'forall'.
  See Note [Representing type signatures].

* HsWildCardBndrs is a wrapper that binds the wildcard variables
  of the wrapped thing.  It is filled in by the renamer
     f :: _a -&gt; _
  The enclosing HsWildCardBndrs binds the wildcards _a and _.

* HsSigPatType describes types that appear in pattern signatures and
  the signatures of term-level binders in RULES. Like
  HsWildCardBndrs/HsOuterTyVarBndrs, they track the names of wildcard
  variables and implicitly bound type variables. Unlike
  HsOuterTyVarBndrs, however, HsSigPatTypes do not obey the
  forall-or-nothing rule. See Note [Pattern signature binders and scoping].

* The explicit presence of these wrappers specifies, in the HsSyn,
  exactly where implicit quantification is allowed, and where
  wildcards are allowed.

* LHsQTyVars is used in data/class declarations, where the user gives
  explicit *type* variable bindings, but we need to implicitly bind
  *kind* variables.  For example
      class C (a :: k -&gt; *) where ...
  The 'k' is implicitly bound in the hsq_tvs field of LHsQTyVars

Note [The wildcard story for types]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Types can have wildcards in them, to support partial type signatures,
like       f :: Int -&gt; (_ , _a) -&gt; _a

A wildcard in a type can be

  * An anonymous wildcard,
        written '_'
    In HsType this is represented by HsWildCardTy.
    The renamer leaves it untouched, and it is later given a fresh
    meta tyvar in the typechecker.

  * A named wildcard,
        written '_a', '_foo', etc
    In HsType this is represented by (HsTyVar &quot;_a&quot;)
    i.e. a perfectly ordinary type variable that happens
         to start with an underscore

Note carefully:

* When NamedWildCards is off, type variables that start with an
  underscore really /are/ ordinary type variables.  And indeed, even
  when NamedWildCards is on you can bind _a explicitly as an ordinary
  type variable:
        data T _a _b = MkT _b _a
  Or even:
        f :: forall _a. _a -&gt; _b
  Here _a is an ordinary forall'd binder, but (With NamedWildCards)
  _b is a named wildcard.  (See the comments in #10982)

* Named wildcards are bound by the HsWildCardBndrs (for types that obey the
  forall-or-nothing rule) and HsPatSigType (for type signatures in patterns
  and term-level binders in RULES), which wrap types that are allowed to have
  wildcards. Unnamed wildcards, however are left unchanged until typechecking,
  where we give them fresh wild tyvars and determine whether or not to emit
  hole constraints on each wildcard (we don't if it's a visible type/kind
  argument or a type family pattern). See related notes
  Note [Wildcards in visible kind application] and
  Note [Wildcards in visible type application] in GHC.Tc.Gen.HsType.

* After type checking is done, we report what types the wildcards
  got unified with.

Note [Ordering of implicit variables]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Since the advent of -XTypeApplications, GHC makes promises about the ordering
of implicit variable quantification. Specifically, we offer that implicitly
quantified variables (such as those in const :: a -&gt; b -&gt; a, without a `forall`)
will occur in left-to-right order of first occurrence. Here are a few examples:

  const :: a -&gt; b -&gt; a       -- forall a b. ...
  f :: Eq a =&gt; b -&gt; a -&gt; a   -- forall a b. ...  contexts are included

  type a &lt;-&lt; b = b -&gt; a
  g :: a &lt;-&lt; b               -- forall a b. ...  type synonyms matter

  class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b   -- forall f a b. ...
    -- The f is quantified by the class, so only a and b are considered in fmap

This simple story is complicated by the possibility of dependency: all variables
must come after any variables mentioned in their kinds.

  typeRep :: Typeable a =&gt; TypeRep (a :: k)   -- forall k a. ...

The k comes first because a depends on k, even though the k appears later than
the a in the code. Thus, GHC does a *stable topological sort* on the variables.
By &quot;stable&quot;, we mean that any two variables who do not depend on each other
preserve their existing left-to-right ordering.

Implicitly bound variables are collected by the extract- family of functions
(extractHsTysRdrTyVars, extractHsTyVarBndrsKVs, etc.) in GHC.Rename.HsType.
These functions thus promise to keep left-to-right ordering.
Look for pointers to this note to see the places where the action happens.

Note that we also maintain this ordering in kind signatures. Even though
there's no visible kind application (yet), having implicit variables be
quantified in left-to-right order in kind signatures is nice since:

* It's consistent with the treatment for type signatures.
* It can affect how types are displayed with -fprint-explicit-kinds (see
  #15568 for an example), which is a situation where knowing the order in
  which implicit variables are quantified can be useful.
* In the event that visible kind application is implemented, the order in
  which we would expect implicit variables to be ordered in kinds will have
  already been established.
-}</span><span>
</span><span id="line-291"></span><span>
</span><span id="line-292"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Context</span></span><span>
</span><span id="line-293"></span><span class="hs-keyword">type</span><span> </span><span id="LHsContext"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsContext"><span class="hs-identifier hs-var">LHsContext</span></a></span></span><span> </span><span id="local-6989586621681629553"><span class="annot"><a href="#local-6989586621681629553"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629553"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsContext"><span class="hs-identifier hs-type">HsContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629553"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-294"></span><span>      </span><span class="hs-comment">-- ^ 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnUnit'</span><span>
</span><span id="line-295"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-296"></span><span>
</span><span id="line-297"></span><span class="annot"><span class="hs-comment">-- | Haskell Context</span></span><span>
</span><span id="line-298"></span><span class="hs-keyword">type</span><span> </span><span id="HsContext"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsContext"><span class="hs-identifier hs-var">HsContext</span></a></span></span><span> </span><span id="local-6989586621681629554"><span class="annot"><a href="#local-6989586621681629554"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629554"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-299"></span><span>
</span><span id="line-300"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Type</span></span><span>
</span><span id="line-301"></span><span class="hs-keyword">type</span><span> </span><span id="LHsType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-var">LHsType</span></a></span></span><span> </span><span id="local-6989586621681629555"><span class="annot"><a href="#local-6989586621681629555"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629555"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsType"><span class="hs-identifier hs-type">HsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629555"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-302"></span><span>      </span><span class="hs-comment">-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when</span><span>
</span><span id="line-303"></span><span>      </span><span class="hs-comment">--   in a list</span><span>
</span><span id="line-304"></span><span>
</span><span id="line-305"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-306"></span><span>
</span><span id="line-307"></span><span class="annot"><span class="hs-comment">-- | Haskell Kind</span></span><span>
</span><span id="line-308"></span><span class="hs-keyword">type</span><span> </span><span id="HsKind"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsKind"><span class="hs-identifier hs-var">HsKind</span></a></span></span><span> </span><span id="local-6989586621681629556"><span class="annot"><a href="#local-6989586621681629556"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsType"><span class="hs-identifier hs-type">HsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629556"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-309"></span><span>
</span><span id="line-310"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Kind</span></span><span>
</span><span id="line-311"></span><span class="hs-keyword">type</span><span> </span><span id="LHsKind"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsKind"><span class="hs-identifier hs-var">LHsKind</span></a></span></span><span> </span><span id="local-6989586621681629557"><span class="annot"><a href="#local-6989586621681629557"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629557"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsKind"><span class="hs-identifier hs-type">HsKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629557"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-312"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span></span><span>
</span><span id="line-313"></span><span>
</span><span id="line-314"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-315"></span><span>
</span><span id="line-316"></span><span class="hs-comment">--------------------------------------------------</span><span>
</span><span id="line-317"></span><span class="hs-comment">--             LHsQTyVars</span><span>
</span><span id="line-318"></span><span class="hs-comment">--  The explicitly-quantified binders in a data/type declaration</span><span>
</span><span id="line-319"></span><span>
</span><span id="line-320"></span><span class="hs-comment">-- | The type variable binders in an 'HsForAllTy'.</span><span>
</span><span id="line-321"></span><span class="hs-comment">-- See also @Note [Variable Specificity and Forall Visibility]@ in</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- &quot;GHC.Tc.Gen.HsType&quot;.</span><span>
</span><span id="line-323"></span><span class="hs-keyword">data</span><span> </span><span id="HsForAllTelescope"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsForAllTelescope"><span class="hs-identifier hs-var">HsForAllTelescope</span></a></span></span><span> </span><span id="local-6989586621681629230"><span class="annot"><a href="#local-6989586621681629230"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-324"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsForAllVis"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsForAllVis"><span class="hs-identifier hs-var">HsForAllVis</span></a></span></span><span> </span><span class="hs-comment">-- ^ A visible @forall@ (e.g., @forall a -&gt; {...}@).</span><span>
</span><span id="line-325"></span><span>                </span><span class="hs-comment">--   These do not have any notion of specificity, so we use</span><span>
</span><span id="line-326"></span><span>                </span><span class="hs-comment">--   '()' as a placeholder value.</span><span>
</span><span id="line-327"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="hsf_xvis"><span class="annot"><span class="annottext">forall pass. HsForAllTelescope pass -&gt; XHsForAllVis pass
</span><a href="Language.Haskell.Syntax.Type.html#hsf_xvis"><span class="hs-identifier hs-var hs-var">hsf_xvis</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsForAllVis"><span class="hs-identifier hs-type">XHsForAllVis</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629230"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-328"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="hsf_vis_bndrs"><span class="annot"><span class="annottext">forall pass. HsForAllTelescope pass -&gt; [LHsTyVarBndr () pass]
</span><a href="Language.Haskell.Syntax.Type.html#hsf_vis_bndrs"><span class="hs-identifier hs-var hs-var">hsf_vis_bndrs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTyVarBndr"><span class="hs-identifier hs-type">LHsTyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681629230"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-329"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-330"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsForAllInvis"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsForAllInvis"><span class="hs-identifier hs-var">HsForAllInvis</span></a></span></span><span> </span><span class="hs-comment">-- ^ An invisible @forall@ (e.g., @forall a {b} c. {...}@),</span><span>
</span><span id="line-331"></span><span>                  </span><span class="hs-comment">--   where each binder has a 'Specificity'.</span><span>
</span><span id="line-332"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="hsf_xinvis"><span class="annot"><span class="annottext">forall pass. HsForAllTelescope pass -&gt; XHsForAllInvis pass
</span><a href="Language.Haskell.Syntax.Type.html#hsf_xinvis"><span class="hs-identifier hs-var hs-var">hsf_xinvis</span></a></span></span><span>       </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsForAllInvis"><span class="hs-identifier hs-type">XHsForAllInvis</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629230"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-333"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="hsf_invis_bndrs"><span class="annot"><span class="annottext">forall pass.
HsForAllTelescope pass -&gt; [LHsTyVarBndr Specificity pass]
</span><a href="Language.Haskell.Syntax.Type.html#hsf_invis_bndrs"><span class="hs-identifier hs-var hs-var">hsf_invis_bndrs</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTyVarBndr"><span class="hs-identifier hs-type">LHsTyVarBndr</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#Specificity"><span class="hs-identifier hs-type">Specificity</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629230"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-334"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-335"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsForAllTelescope"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XHsForAllTelescope"><span class="hs-identifier hs-var">XHsForAllTelescope</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsForAllTelescope"><span class="hs-identifier hs-type">XXHsForAllTelescope</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629230"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-336"></span><span>
</span><span id="line-337"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Type Variable Binder</span></span><span>
</span><span id="line-338"></span><span class="hs-keyword">type</span><span> </span><span id="LHsTyVarBndr"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTyVarBndr"><span class="hs-identifier hs-var">LHsTyVarBndr</span></a></span></span><span> </span><span id="local-6989586621681629567"><span class="annot"><a href="#local-6989586621681629567"><span class="hs-identifier hs-type">flag</span></a></span></span><span> </span><span id="local-6989586621681629568"><span class="annot"><a href="#local-6989586621681629568"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629568"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTyVarBndr"><span class="hs-identifier hs-type">HsTyVarBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629567"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629568"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-339"></span><span>                         </span><span class="hs-comment">-- See Note [HsType binders]</span><span>
</span><span id="line-340"></span><span>
</span><span id="line-341"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Quantified Type Variables</span></span><span>
</span><span id="line-342"></span><span class="hs-keyword">data</span><span> </span><span id="LHsQTyVars"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsQTyVars"><span class="hs-identifier hs-var">LHsQTyVars</span></a></span></span><span> </span><span id="local-6989586621681629240"><span class="annot"><a href="#local-6989586621681629240"><span class="hs-identifier hs-type">pass</span></a></span></span><span>   </span><span class="hs-comment">-- See Note [HsType binders]</span><span>
</span><span id="line-343"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsQTvs"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsQTvs"><span class="hs-identifier hs-var">HsQTvs</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="hsq_ext"><span class="annot"><span class="annottext">forall pass. LHsQTyVars pass -&gt; XHsQTvs pass
</span><a href="Language.Haskell.Syntax.Type.html#hsq_ext"><span class="hs-identifier hs-var hs-var">hsq_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsQTvs"><span class="hs-identifier hs-type">XHsQTvs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629240"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-344"></span><span>
</span><span id="line-345"></span><span>           </span><span class="hs-special">,</span><span> </span><span id="hsq_explicit"><span class="annot"><span class="annottext">forall pass. LHsQTyVars pass -&gt; [LHsTyVarBndr () pass]
</span><a href="Language.Haskell.Syntax.Type.html#hsq_explicit"><span class="hs-identifier hs-var hs-var">hsq_explicit</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTyVarBndr"><span class="hs-identifier hs-type">LHsTyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681629240"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-346"></span><span>                </span><span class="hs-comment">-- Explicit variables, written by the user</span><span>
</span><span id="line-347"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-348"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XLHsQTyVars"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XLHsQTyVars"><span class="hs-identifier hs-var">XLHsQTyVars</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXLHsQTyVars"><span class="hs-identifier hs-type">XXLHsQTyVars</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629240"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-349"></span><span>
</span><span id="line-350"></span><span id="local-6989586621681629574"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hsQTvExplicit"><span class="hs-identifier hs-type">hsQTvExplicit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsQTyVars"><span class="hs-identifier hs-type">LHsQTyVars</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629574"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTyVarBndr"><span class="hs-identifier hs-type">LHsTyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681629574"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-351"></span><span id="hsQTvExplicit"><span class="annot"><span class="annottext">hsQTvExplicit :: forall pass. LHsQTyVars pass -&gt; [LHsTyVarBndr () pass]
</span><a href="Language.Haskell.Syntax.Type.html#hsQTvExplicit"><span class="hs-identifier hs-var hs-var">hsQTvExplicit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LHsQTyVars pass -&gt; [LHsTyVarBndr () pass]
forall pass. LHsQTyVars pass -&gt; [LHsTyVarBndr () pass]
</span><a href="Language.Haskell.Syntax.Type.html#hsq_explicit"><span class="hs-identifier hs-var">hsq_explicit</span></a></span><span>
</span><span id="line-352"></span><span>
</span><span id="line-353"></span><span class="hs-comment">------------------------------------------------</span><span>
</span><span id="line-354"></span><span class="hs-comment">--            HsOuterTyVarBndrs</span><span>
</span><span id="line-355"></span><span class="hs-comment">-- Used to quantify the outermost type variable binders of a type that obeys</span><span>
</span><span id="line-356"></span><span class="hs-comment">-- the forall-or-nothing rule. These are used to represent the outermost</span><span>
</span><span id="line-357"></span><span class="hs-comment">-- quantification in:</span><span>
</span><span id="line-358"></span><span class="hs-comment">--    * Type signatures (LHsSigType/LHsSigWcType)</span><span>
</span><span id="line-359"></span><span class="hs-comment">--    * Patterns in a type/data family instance (HsTyPats)</span><span>
</span><span id="line-360"></span><span class="hs-comment">--</span><span>
</span><span id="line-361"></span><span class="hs-comment">-- We support two forms:</span><span>
</span><span id="line-362"></span><span class="hs-comment">--   HsOuterImplicit (implicit quantification, added by renamer)</span><span>
</span><span id="line-363"></span><span class="hs-comment">--         f :: a -&gt; a     -- Desugars to f :: forall {a}. a -&gt; a</span><span>
</span><span id="line-364"></span><span class="hs-comment">--         type instance F (a,b) = a-&gt;b</span><span>
</span><span id="line-365"></span><span class="hs-comment">--   HsOuterExplicit (explicit user quantification):</span><span>
</span><span id="line-366"></span><span class="hs-comment">--         f :: forall a. a -&gt; a</span><span>
</span><span id="line-367"></span><span class="hs-comment">--         type instance forall a b. F (a,b) = a-&gt;b</span><span>
</span><span id="line-368"></span><span class="hs-comment">--</span><span>
</span><span id="line-369"></span><span class="hs-comment">-- In constrast, when the user writes /visible/ quanitification</span><span>
</span><span id="line-370"></span><span class="hs-comment">--         T :: forall k -&gt; k -&gt; Type</span><span>
</span><span id="line-371"></span><span class="hs-comment">-- we use use HsOuterImplicit, wrapped around a HsForAllTy</span><span>
</span><span id="line-372"></span><span class="hs-comment">-- for the visible quantification</span><span>
</span><span id="line-373"></span><span class="hs-comment">--</span><span>
</span><span id="line-374"></span><span class="hs-comment">-- See Note [forall-or-nothing rule]</span><span>
</span><span id="line-375"></span><span>
</span><span id="line-376"></span><span class="hs-comment">-- | The outermost type variables in a type that obeys the @forall@-or-nothing</span><span>
</span><span id="line-377"></span><span class="hs-comment">-- rule. See @Note [forall-or-nothing rule]@.</span><span>
</span><span id="line-378"></span><span class="hs-keyword">data</span><span> </span><span id="HsOuterTyVarBndrs"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterTyVarBndrs"><span class="hs-identifier hs-var">HsOuterTyVarBndrs</span></a></span></span><span> </span><span id="local-6989586621681629246"><span class="annot"><a href="#local-6989586621681629246"><span class="hs-identifier hs-type">flag</span></a></span></span><span> </span><span id="local-6989586621681629247"><span class="annot"><a href="#local-6989586621681629247"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-379"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsOuterImplicit"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterImplicit"><span class="hs-identifier hs-var">HsOuterImplicit</span></a></span></span><span> </span><span class="hs-comment">-- ^ Implicit forall, e.g.,</span><span>
</span><span id="line-380"></span><span>                    </span><span class="hs-comment">--    @f :: a -&gt; b -&gt; b@</span><span>
</span><span id="line-381"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="hso_ximplicit"><span class="annot"><span class="annottext">forall flag pass.
HsOuterTyVarBndrs flag pass -&gt; XHsOuterImplicit pass
</span><a href="Language.Haskell.Syntax.Type.html#hso_ximplicit"><span class="hs-identifier hs-var hs-var">hso_ximplicit</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsOuterImplicit"><span class="hs-identifier hs-type">XHsOuterImplicit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629247"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-382"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-383"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsOuterExplicit"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterExplicit"><span class="hs-identifier hs-var">HsOuterExplicit</span></a></span></span><span> </span><span class="hs-comment">-- ^ Explicit forall, e.g.,</span><span>
</span><span id="line-384"></span><span>                    </span><span class="hs-comment">--    @f :: forall a b. a -&gt; b -&gt; b@</span><span>
</span><span id="line-385"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="hso_xexplicit"><span class="annot"><span class="annottext">forall flag pass.
HsOuterTyVarBndrs flag pass -&gt; XHsOuterExplicit pass flag
</span><a href="Language.Haskell.Syntax.Type.html#hso_xexplicit"><span class="hs-identifier hs-var hs-var">hso_xexplicit</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsOuterExplicit"><span class="hs-identifier hs-type">XHsOuterExplicit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629247"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629246"><span class="hs-identifier hs-type">flag</span></a></span><span>
</span><span id="line-386"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="hso_bndrs"><span class="annot"><span class="annottext">forall flag pass.
HsOuterTyVarBndrs flag pass -&gt; [LHsTyVarBndr flag (NoGhcTc pass)]
</span><a href="Language.Haskell.Syntax.Type.html#hso_bndrs"><span class="hs-identifier hs-var hs-var">hso_bndrs</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTyVarBndr"><span class="hs-identifier hs-type">LHsTyVarBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629246"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoGhcTc"><span class="hs-identifier hs-type">NoGhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629247"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-387"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-388"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsOuterTyVarBndrs"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XHsOuterTyVarBndrs"><span class="hs-identifier hs-var">XHsOuterTyVarBndrs</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsOuterTyVarBndrs"><span class="hs-identifier hs-type">XXHsOuterTyVarBndrs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629247"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-389"></span><span>
</span><span id="line-390"></span><span class="hs-comment">-- | Used for signatures, e.g.,</span><span>
</span><span id="line-391"></span><span class="hs-comment">--</span><span>
</span><span id="line-392"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-393"></span><span class="hs-comment">-- f :: forall a {b}. blah</span><span>
</span><span id="line-394"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-395"></span><span class="hs-comment">--</span><span>
</span><span id="line-396"></span><span class="hs-comment">-- We use 'Specificity' for the 'HsOuterTyVarBndrs' @flag@ to allow</span><span>
</span><span id="line-397"></span><span class="hs-comment">-- distinguishing between specified and inferred type variables.</span><span>
</span><span id="line-398"></span><span class="hs-keyword">type</span><span> </span><span id="HsOuterSigTyVarBndrs"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterSigTyVarBndrs"><span class="hs-identifier hs-var">HsOuterSigTyVarBndrs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterTyVarBndrs"><span class="hs-identifier hs-type">HsOuterTyVarBndrs</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#Specificity"><span class="hs-identifier hs-type">Specificity</span></a></span><span>
</span><span id="line-399"></span><span>
</span><span id="line-400"></span><span class="hs-comment">-- | Used for type-family instance equations, e.g.,</span><span>
</span><span id="line-401"></span><span class="hs-comment">--</span><span>
</span><span id="line-402"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-403"></span><span class="hs-comment">-- type instance forall a. F [a] = Tree a</span><span>
</span><span id="line-404"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-405"></span><span class="hs-comment">--</span><span>
</span><span id="line-406"></span><span class="hs-comment">-- The notion of specificity is irrelevant in type family equations, so we use</span><span>
</span><span id="line-407"></span><span class="hs-comment">-- @()@ for the 'HsOuterTyVarBndrs' @flag@.</span><span>
</span><span id="line-408"></span><span class="hs-keyword">type</span><span> </span><span id="HsOuterFamEqnTyVarBndrs"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterFamEqnTyVarBndrs"><span class="hs-identifier hs-var">HsOuterFamEqnTyVarBndrs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterTyVarBndrs"><span class="hs-identifier hs-type">HsOuterTyVarBndrs</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-409"></span><span>
</span><span id="line-410"></span><span class="annot"><span class="hs-comment">-- | Haskell Wildcard Binders</span></span><span>
</span><span id="line-411"></span><span class="hs-keyword">data</span><span> </span><span id="HsWildCardBndrs"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsWildCardBndrs"><span class="hs-identifier hs-var">HsWildCardBndrs</span></a></span></span><span> </span><span id="local-6989586621681629258"><span class="annot"><a href="#local-6989586621681629258"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span id="local-6989586621681629259"><span class="annot"><a href="#local-6989586621681629259"><span class="hs-identifier hs-type">thing</span></a></span></span><span>
</span><span id="line-412"></span><span>    </span><span class="hs-comment">-- See Note [HsType binders]</span><span>
</span><span id="line-413"></span><span>    </span><span class="hs-comment">-- See Note [The wildcard story for types]</span><span>
</span><span id="line-414"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsWC"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsWC"><span class="hs-identifier hs-var">HsWC</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="hswc_ext"><span class="annot"><span class="annottext">forall pass thing. HsWildCardBndrs pass thing -&gt; XHsWC pass thing
</span><a href="Language.Haskell.Syntax.Type.html#hswc_ext"><span class="hs-identifier hs-var hs-var">hswc_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsWC"><span class="hs-identifier hs-type">XHsWC</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629258"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629259"><span class="hs-identifier hs-type">thing</span></a></span><span>
</span><span id="line-415"></span><span>                </span><span class="hs-comment">-- after the renamer</span><span>
</span><span id="line-416"></span><span>                </span><span class="hs-comment">-- Wild cards, only named</span><span>
</span><span id="line-417"></span><span>                </span><span class="hs-comment">-- See Note [Wildcards in visible kind application]</span><span>
</span><span id="line-418"></span><span>
</span><span id="line-419"></span><span>         </span><span class="hs-special">,</span><span> </span><span id="hswc_body"><span class="annot"><span class="annottext">forall pass thing. HsWildCardBndrs pass thing -&gt; thing
</span><a href="Language.Haskell.Syntax.Type.html#hswc_body"><span class="hs-identifier hs-var hs-var">hswc_body</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681629259"><span class="hs-identifier hs-type">thing</span></a></span><span>
</span><span id="line-420"></span><span>                </span><span class="hs-comment">-- Main payload (type or list of types)</span><span>
</span><span id="line-421"></span><span>                </span><span class="hs-comment">-- If there is an extra-constraints wildcard,</span><span>
</span><span id="line-422"></span><span>                </span><span class="hs-comment">-- it's still there in the hsc_body.</span><span>
</span><span id="line-423"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-424"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsWildCardBndrs"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XHsWildCardBndrs"><span class="hs-identifier hs-var">XHsWildCardBndrs</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsWildCardBndrs"><span class="hs-identifier hs-type">XXHsWildCardBndrs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629258"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629259"><span class="hs-identifier hs-type">thing</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-425"></span><span>
</span><span id="line-426"></span><span class="hs-comment">-- | Types that can appear in pattern signatures, as well as the signatures for</span><span>
</span><span id="line-427"></span><span class="hs-comment">-- term-level binders in RULES.</span><span>
</span><span id="line-428"></span><span class="hs-comment">-- See @Note [Pattern signature binders and scoping]@.</span><span>
</span><span id="line-429"></span><span class="hs-comment">--</span><span>
</span><span id="line-430"></span><span class="hs-comment">-- This is very similar to 'HsSigWcType', but with</span><span>
</span><span id="line-431"></span><span class="hs-comment">-- slightly different semantics: see @Note [HsType binders]@.</span><span>
</span><span id="line-432"></span><span class="hs-comment">-- See also @Note [The wildcard story for types]@.</span><span>
</span><span id="line-433"></span><span class="hs-keyword">data</span><span> </span><span id="HsPatSigType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsPatSigType"><span class="hs-identifier hs-var">HsPatSigType</span></a></span></span><span> </span><span id="local-6989586621681629266"><span class="annot"><a href="#local-6989586621681629266"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-434"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsPS"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsPS"><span class="hs-identifier hs-var">HsPS</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="hsps_ext"><span class="annot"><span class="annottext">forall pass. HsPatSigType pass -&gt; XHsPS pass
</span><a href="Language.Haskell.Syntax.Type.html#hsps_ext"><span class="hs-identifier hs-var hs-var">hsps_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsPS"><span class="hs-identifier hs-type">XHsPS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629266"><span class="hs-identifier hs-type">pass</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ After renamer: 'HsPSRn'</span></span><span>
</span><span id="line-435"></span><span>         </span><span class="hs-special">,</span><span> </span><span id="hsps_body"><span class="annot"><span class="annottext">forall pass. HsPatSigType pass -&gt; LHsType pass
</span><a href="Language.Haskell.Syntax.Type.html#hsps_body"><span class="hs-identifier hs-var hs-var">hsps_body</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629266"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ Main payload (the type itself)</span></span><span>
</span><span id="line-436"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-437"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsPatSigType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XHsPatSigType"><span class="hs-identifier hs-var">XHsPatSigType</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsPatSigType"><span class="hs-identifier hs-type">XXHsPatSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629266"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-438"></span><span>
</span><span id="line-439"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Signature Type</span></span><span>
</span><span id="line-440"></span><span class="hs-keyword">type</span><span> </span><span id="LHsSigType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-var">LHsSigType</span></a></span></span><span>   </span><span id="local-6989586621681629592"><span class="annot"><a href="#local-6989586621681629592"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629592"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsSigType"><span class="hs-identifier hs-type">HsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629592"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>               </span><span class="hs-comment">-- Implicit only</span><span>
</span><span id="line-441"></span><span>
</span><span id="line-442"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Wildcard Type</span></span><span>
</span><span id="line-443"></span><span class="hs-keyword">type</span><span> </span><span id="LHsWcType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsWcType"><span class="hs-identifier hs-var">LHsWcType</span></a></span></span><span>    </span><span id="local-6989586621681629593"><span class="annot"><a href="#local-6989586621681629593"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsWildCardBndrs"><span class="hs-identifier hs-type">HsWildCardBndrs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629593"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629593"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- Wildcard only</span><span>
</span><span id="line-444"></span><span>
</span><span id="line-445"></span><span class="annot"><span class="hs-comment">-- | Located Haskell Signature Wildcard Type</span></span><span>
</span><span id="line-446"></span><span class="hs-keyword">type</span><span> </span><span id="LHsSigWcType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigWcType"><span class="hs-identifier hs-var">LHsSigWcType</span></a></span></span><span> </span><span id="local-6989586621681629594"><span class="annot"><a href="#local-6989586621681629594"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsWildCardBndrs"><span class="hs-identifier hs-type">HsWildCardBndrs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629594"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629594"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Both</span><span>
</span><span id="line-447"></span><span>
</span><span id="line-448"></span><span class="hs-comment">-- | A type signature that obeys the @forall@-or-nothing rule. In other</span><span>
</span><span id="line-449"></span><span class="hs-comment">-- words, an 'LHsType' that uses an 'HsOuterSigTyVarBndrs' to represent its</span><span>
</span><span id="line-450"></span><span class="hs-comment">-- outermost type variable quantification.</span><span>
</span><span id="line-451"></span><span class="hs-comment">-- See @Note [Representing type signatures]@.</span><span>
</span><span id="line-452"></span><span class="hs-keyword">data</span><span> </span><span id="HsSigType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsSigType"><span class="hs-identifier hs-var">HsSigType</span></a></span></span><span> </span><span id="local-6989586621681629272"><span class="annot"><a href="#local-6989586621681629272"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-453"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsSig"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsSig"><span class="hs-identifier hs-var">HsSig</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="sig_ext"><span class="annot"><span class="annottext">forall pass. HsSigType pass -&gt; XHsSig pass
</span><a href="Language.Haskell.Syntax.Type.html#sig_ext"><span class="hs-identifier hs-var hs-var">sig_ext</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsSig"><span class="hs-identifier hs-type">XHsSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629272"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-454"></span><span>          </span><span class="hs-special">,</span><span> </span><span id="sig_bndrs"><span class="annot"><span class="annottext">forall pass. HsSigType pass -&gt; HsOuterSigTyVarBndrs pass
</span><a href="Language.Haskell.Syntax.Type.html#sig_bndrs"><span class="hs-identifier hs-var hs-var">sig_bndrs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterSigTyVarBndrs"><span class="hs-identifier hs-type">HsOuterSigTyVarBndrs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629272"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-455"></span><span>          </span><span class="hs-special">,</span><span> </span><span id="sig_body"><span class="annot"><span class="annottext">forall pass. HsSigType pass -&gt; LHsType pass
</span><a href="Language.Haskell.Syntax.Type.html#sig_body"><span class="hs-identifier hs-var hs-var">sig_body</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629272"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-456"></span><span>          </span><span class="hs-special">}</span><span>
</span><span id="line-457"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsSigType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XHsSigType"><span class="hs-identifier hs-var">XHsSigType</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsSigType"><span class="hs-identifier hs-type">XXHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629272"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-458"></span><span>
</span><span id="line-459"></span><span id="local-6989586621681629601"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hsPatSigType"><span class="hs-identifier hs-type">hsPatSigType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsPatSigType"><span class="hs-identifier hs-type">HsPatSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629601"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629601"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-460"></span><span id="hsPatSigType"><span class="annot"><span class="annottext">hsPatSigType :: forall pass. HsPatSigType pass -&gt; LHsType pass
</span><a href="Language.Haskell.Syntax.Type.html#hsPatSigType"><span class="hs-identifier hs-var hs-var">hsPatSigType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsPatSigType pass -&gt; LHsType pass
forall pass. HsPatSigType pass -&gt; LHsType pass
</span><a href="Language.Haskell.Syntax.Type.html#hsps_body"><span class="hs-identifier hs-var">hsps_body</span></a></span><span>
</span><span id="line-461"></span><span>
</span><span id="line-462"></span><span class="hs-comment">{-
Note [forall-or-nothing rule]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Free variables in signatures are usually bound in an implicit 'forall' at the
beginning of user-written signatures. However, if the signature has an
explicit, invisible forall at the beginning, this is disabled. This is referred
to as the forall-or-nothing rule.

The idea is nested foralls express something which is only expressible
explicitly, while a top level forall could (usually) be replaced with an
implicit binding. Top-level foralls alone (&quot;forall.&quot;) are therefore an
indication that the user is trying to be fastidious, so we don't implicitly
bind any variables.

Note that this rule only applies to outermost /in/visible 'forall's, and not
outermost visible 'forall's. See #18660 for more on this point.

Here are some concrete examples to demonstrate the forall-or-nothing rule in
action:

  type F1 :: a -&gt; b -&gt; b                    -- Legal; a,b are implicitly quantified.
                                            -- Equivalently: forall a b. a -&gt; b -&gt; b

  type F2 :: forall a b. a -&gt; b -&gt; b        -- Legal; explicitly quantified

  type F3 :: forall a. a -&gt; b -&gt; b          -- Illegal; the forall-or-nothing rule says that
                                            -- if you quantify a, you must also quantify b

  type F4 :: forall a -&gt; b -&gt; b             -- Legal; the top quantifier (forall a) is a /visible/
                                            -- quantifier, so the &quot;nothing&quot; part of the forall-or-nothing
                                            -- rule applies, and b is therefore implicitly quantified.
                                            -- Equivalently: forall b. forall a -&gt; b -&gt; b

  type F5 :: forall b. forall a -&gt; b -&gt; c   -- Illegal; the forall-or-nothing rule says that
                                            -- if you quantify b, you must also quantify c

  type F6 :: forall a -&gt; forall b. b -&gt; c   -- Legal: just like F4.

For a complete list of all places where the forall-or-nothing rule applies, see
&quot;The `forall`-or-nothing rule&quot; section of the GHC User's Guide.

Any type that obeys the forall-or-nothing rule is represented in the AST with
an HsOuterTyVarBndrs:

* If the type has an outermost, invisible 'forall', it uses HsOuterExplicit,
  which contains a list of the explicitly quantified type variable binders in
  `hso_bndrs`. After typechecking, HsOuterExplicit also stores a list of the
  explicitly quantified `InvisTVBinder`s in
  `hso_xexplicit :: XHsOuterExplicit GhcTc`.

* Otherwise, it uses HsOuterImplicit. HsOuterImplicit is used for different
  things depending on the phase:

  * After parsing, it does not store anything in particular.
  * After renaming, it stores the implicitly bound type variable `Name`s in
    `hso_ximplicit :: XHsOuterImplicit GhcRn`.
  * After typechecking, it stores the implicitly bound `TyVar`s in
    `hso_ximplicit :: XHsOuterImplicit GhcTc`.

  NB: this implicit quantification is purely lexical: we bind any
      type or kind variables that are not in scope. The type checker
      may subsequently quantify over further kind variables.
      See Note [Binding scoped type variables] in GHC.Tc.Gen.Sig.

HsOuterTyVarBndrs GhcTc is used in the typechecker as an intermediate data type
for storing the outermost TyVars/InvisTVBinders in a type.
See GHC.Tc.Gen.HsType.bindOuterTKBndrsX for an example of this.

Note [Representing type signatures]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HsSigType is used to represent an explicit user type signature. These are
used in a variety of places. Some examples include:

* Type signatures (e.g., f :: a -&gt; a)
* Standalone kind signatures (e.g., type G :: a -&gt; a)
* GADT constructor types (e.g., data T where MkT :: a -&gt; T)

A HsSigType is the combination of an HsOuterSigTyVarBndrs and an LHsType:

* The HsOuterSigTyVarBndrs binds the /explicitly/ quantified type variables
  when the type signature has an outermost, user-written 'forall' (i.e,
  the HsOuterExplicit constructor is used). If there is no outermost 'forall',
  then it binds the /implicitly/ quantified type variables instead (i.e.,
  the HsOuterImplicit constructor is used).
* The LHsType represents the rest of the type.

E.g. For a signature like
   f :: forall k (a::k). blah
we get
   HsSig { sig_bndrs = HsOuterExplicit { hso_bndrs = [k, (a :: k)] }
         , sig_body  = blah }

Note [Pattern signature binders and scoping]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider the pattern signatures like those on `t` and `g` in:

   f = let h = \(t :: (b, b) -&gt;
               \(g :: forall a. a -&gt; b) -&gt;
               ...(t :: (Int,Int))...
       in woggle

* The `b` in t's pattern signature is implicitly bound and scopes over
  the signature and the body of the lambda.  It stands for a type (any type);
  indeed we subsequently discover that b=Int.
  (See Note [TyVarTv] in GHC.Tc.Utils.TcMType for more on this point.)
* The `b` in g's pattern signature is an /occurrence/ of the `b` bound by
  t's pattern signature.
* The `a` in `forall a` scopes only over the type `a -&gt; b`, not over the body
  of the lambda.
* There is no forall-or-nothing rule for pattern signatures, which is why the
  type `forall a. a -&gt; b` is permitted in `g`'s pattern signature, even though
  `b` is not explicitly bound. See Note [forall-or-nothing rule].

Similar scoping rules apply to term variable binders in RULES, like in the
following example:

   {-# RULES &quot;h&quot; forall (t :: (b, b)) (g :: forall a. a -&gt; b). h t g = ... #-}

Just like in pattern signatures, the `b` in t's signature is implicitly bound
and scopes over the remainder of the RULE. As a result, the `b` in g's
signature is an occurrence. Moreover, the `a` in `forall a` scopes only over
the type `a -&gt; b`, and the forall-or-nothing rule does not apply.

While quite similar, RULE term binder signatures behave slightly differently
from pattern signatures in two ways:

1. Unlike in pattern signatures, where type variables can stand for any type,
   type variables in RULE term binder signatures are skolems.
   See Note [Typechecking pattern signature binders] in GHC.Tc.Gen.HsType for
   more on this point.

   In this sense, type variables in pattern signatures are quite similar to
   named wildcards, as both can refer to arbitrary types. The main difference
   lies in error reporting: if a named wildcard `_a` in a pattern signature
   stands for Int, then by default GHC will emit a warning stating as much.
   Changing `_a` to `a`, on the other hand, will cause it not to be reported.
2. In the `h` RULE above, only term variables are explicitly bound, so any free
   type variables in the term variables' signatures are implicitly bound.
   This is just like how the free type variables in pattern signatures are
   implicitly bound. If a RULE explicitly binds both term and type variables,
   however, then free type variables in term signatures are /not/ implicitly
   bound. For example, this RULE would be ill scoped:

     {-# RULES &quot;h2&quot; forall b. forall (t :: (b, c)) (g :: forall a. a -&gt; b).
                    h2 t g = ... #-}

   This is because `b` and `c` occur free in the signature for `t`, but only
   `b` was explicitly bound, leaving `c` out of scope. If the RULE had started
   with `forall b c.`, then it would have been accepted.

The types in pattern signatures and RULE term binder signatures are represented
in the AST by HsSigPatType. From the renamer onward, the hsps_ext field (of
type HsPSRn) tracks the names of named wildcards and implicitly bound type
variables so that they can be brought into scope during renaming and
typechecking.

Note [Lexically scoped type variables]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The ScopedTypeVariables extension does two things:

* It allows the use of type signatures in patterns
  (e.g., `f (x :: a -&gt; a) = ...`). See
  Note [Pattern signature binders and scoping] for more on this point.
* It brings lexically scoped type variables into scope for certain type
  signatures with outermost invisible 'forall's.

This Note concerns the latter bullet point. Per the
&quot;Lexically scoped type variables&quot; section of the GHC User's Guide, the
following forms of type signatures can have lexically scoped type variables:

* In declarations with type signatures, e.g.,

    f :: forall a. a -&gt; a
    f x = e @a

  Here, the 'forall a' brings 'a' into scope over the body of 'f'.

  Note that ScopedTypeVariables does /not/ interact with standalone kind
  signatures, only type signatures.

* In explicit type annotations in expressions, e.g.,

    id @a :: forall a. a -&gt; a

* In instance declarations, e.g.,

    instance forall a. C [a] where
      m = e @a

  Note that unlike the examples above, the use of an outermost 'forall' isn't
  required to bring 'a' into scope. That is, the following would also work:

    instance forall a. C [a] where
      m = e @a

Note that all of the types above obey the forall-or-nothing rule. As a result,
the places in the AST that can have lexically scoped type variables are a
subset of the places that use HsOuterTyVarBndrs
(See Note [forall-or-nothing rule].)

Some other observations about lexically scoped type variables:

* Only type variables bound by an /invisible/ forall can be lexically scoped.
  See Note [hsScopedTvs and visible foralls].
* The lexically scoped type variables may be a strict subset of the type
  variables brought into scope by a type signature.
  See Note [Binding scoped type variables] in GHC.Tc.Gen.Sig.
-}</span><span>
</span><span id="line-670"></span><span>
</span><span id="line-671"></span><span id="local-6989586621681629280"><span id="local-6989586621681629281"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#mapHsOuterImplicit"><span class="hs-identifier hs-type">mapHsOuterImplicit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsOuterImplicit"><span class="hs-identifier hs-type">XHsOuterImplicit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629280"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsOuterImplicit"><span class="hs-identifier hs-type">XHsOuterImplicit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629280"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-672"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterTyVarBndrs"><span class="hs-identifier hs-type">HsOuterTyVarBndrs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629281"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629280"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-673"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterTyVarBndrs"><span class="hs-identifier hs-type">HsOuterTyVarBndrs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629281"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629280"><span class="hs-identifier hs-type">pass</span></a></span></span></span><span>
</span><span id="line-674"></span><span id="mapHsOuterImplicit"><span class="annot"><span class="annottext">mapHsOuterImplicit :: forall pass flag.
(XHsOuterImplicit pass -&gt; XHsOuterImplicit pass)
-&gt; HsOuterTyVarBndrs flag pass -&gt; HsOuterTyVarBndrs flag pass
</span><a href="Language.Haskell.Syntax.Type.html#mapHsOuterImplicit"><span class="hs-identifier hs-var hs-var">mapHsOuterImplicit</span></a></span></span><span> </span><span id="local-6989586621681629602"><span class="annot"><span class="annottext">XHsOuterImplicit pass -&gt; XHsOuterImplicit pass
</span><a href="#local-6989586621681629602"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterImplicit"><span class="hs-identifier hs-type">HsOuterImplicit</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">hso_ximplicit :: forall flag pass.
HsOuterTyVarBndrs flag pass -&gt; XHsOuterImplicit pass
</span><a href="Language.Haskell.Syntax.Type.html#hso_ximplicit"><span class="hs-identifier hs-var">hso_ximplicit</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681629603"><span class="annot"><span class="annottext">XHsOuterImplicit pass
</span><a href="#local-6989586621681629603"><span class="hs-identifier hs-var">imp</span></a></span></span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-675"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterImplicit"><span class="hs-identifier hs-type">HsOuterImplicit</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">hso_ximplicit :: XHsOuterImplicit pass
</span><a href="Language.Haskell.Syntax.Type.html#hso_ximplicit"><span class="hs-identifier hs-var">hso_ximplicit</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">XHsOuterImplicit pass -&gt; XHsOuterImplicit pass
</span><a href="#local-6989586621681629602"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">XHsOuterImplicit pass
</span><a href="#local-6989586621681629603"><span class="hs-identifier hs-var">imp</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-676"></span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#mapHsOuterImplicit"><span class="hs-identifier hs-var">mapHsOuterImplicit</span></a></span><span> </span><span class="annot"><span class="annottext">XHsOuterImplicit pass -&gt; XHsOuterImplicit pass
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681629604"><span class="annot"><span class="annottext">hso :: HsOuterTyVarBndrs flag pass
</span><a href="#local-6989586621681629604"><span class="hs-identifier hs-var">hso</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOuterExplicit"><span class="hs-identifier hs-type">HsOuterExplicit</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsOuterTyVarBndrs flag pass
</span><a href="#local-6989586621681629604"><span class="hs-identifier hs-var">hso</span></a></span><span>
</span><span id="line-677"></span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#mapHsOuterImplicit"><span class="hs-identifier hs-var">mapHsOuterImplicit</span></a></span><span> </span><span class="annot"><span class="annottext">XHsOuterImplicit pass -&gt; XHsOuterImplicit pass
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681629605"><span class="annot"><span class="annottext">hso :: HsOuterTyVarBndrs flag pass
</span><a href="#local-6989586621681629605"><span class="hs-identifier hs-var">hso</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XHsOuterTyVarBndrs"><span class="hs-identifier hs-type">XHsOuterTyVarBndrs</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsOuterTyVarBndrs flag pass
</span><a href="#local-6989586621681629605"><span class="hs-identifier hs-var">hso</span></a></span><span>
</span><span id="line-678"></span><span>
</span><span id="line-679"></span><span>
</span><span id="line-680"></span><span class="hs-comment">--------------------------------------------------</span><span>
</span><span id="line-681"></span><span class="hs-comment">-- | These names are used early on to store the names of implicit</span><span>
</span><span id="line-682"></span><span class="hs-comment">-- parameters.  They completely disappear after type-checking.</span><span>
</span><span id="line-683"></span><span class="hs-keyword">newtype</span><span> </span><span id="HsIPName"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier hs-var">HsIPName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="HsIPName"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier hs-var">HsIPName</span></a></span></span><span> </span><span class="annot"><a href="GHC.Data.FastString.html#FastString"><span class="hs-identifier hs-type">FastString</span></a></span><span>
</span><span id="line-684"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621681629608"><span id="local-6989586621681629613"><span class="annot"><span class="annottext">HsIPName -&gt; HsIPName -&gt; Bool
(HsIPName -&gt; HsIPName -&gt; Bool)
-&gt; (HsIPName -&gt; HsIPName -&gt; Bool) -&gt; Eq HsIPName
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: HsIPName -&gt; HsIPName -&gt; Bool
== :: HsIPName -&gt; HsIPName -&gt; Bool
$c/= :: HsIPName -&gt; HsIPName -&gt; Bool
/= :: HsIPName -&gt; HsIPName -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681629620"><span id="local-6989586621681629624"><span id="local-6989586621681629627"><span id="local-6989586621681629629"><span id="local-6989586621681629631"><span id="local-6989586621681629637"><span id="local-6989586621681629642"><span id="local-6989586621681629645"><span id="local-6989586621681629648"><span id="local-6989586621681629651"><span id="local-6989586621681629654"><span id="local-6989586621681629657"><span id="local-6989586621681629662"><span id="local-6989586621681629667"><span class="annot"><span class="annottext">Typeable HsIPName
Typeable HsIPName =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; HsIPName -&gt; c HsIPName)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsIPName)
-&gt; (HsIPName -&gt; Constr)
-&gt; (HsIPName -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsIPName))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c HsIPName))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; HsIPName -&gt; HsIPName)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsIPName -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsIPName -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsIPName -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsIPName -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName)
-&gt; Data HsIPName
HsIPName -&gt; Constr
HsIPName -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; HsIPName -&gt; HsIPName
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsIPName -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsIPName -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsIPName -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsIPName -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsIPName
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsIPName -&gt; c HsIPName
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsIPName)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c HsIPName)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsIPName -&gt; c HsIPName
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsIPName -&gt; c HsIPName
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsIPName
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsIPName
$ctoConstr :: HsIPName -&gt; Constr
toConstr :: HsIPName -&gt; Constr
$cdataTypeOf :: HsIPName -&gt; DataType
dataTypeOf :: HsIPName -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsIPName)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsIPName)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c HsIPName)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c HsIPName)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; HsIPName -&gt; HsIPName
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; HsIPName -&gt; HsIPName
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsIPName -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsIPName -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsIPName -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsIPName -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsIPName -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsIPName -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsIPName -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsIPName -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsIPName -&gt; m HsIPName
</span><a href="../../base-4.18.3.0/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-685"></span><span>
</span><span id="line-686"></span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hsIPNameFS"><span class="hs-identifier hs-type">hsIPNameFS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier hs-type">HsIPName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Data.FastString.html#FastString"><span class="hs-identifier hs-type">FastString</span></a></span><span>
</span><span id="line-687"></span><span id="hsIPNameFS"><span class="annot"><span class="annottext">hsIPNameFS :: HsIPName -&gt; FastString
</span><a href="Language.Haskell.Syntax.Type.html#hsIPNameFS"><span class="hs-identifier hs-var hs-var">hsIPNameFS</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier hs-type">HsIPName</span></a></span><span> </span><span id="local-6989586621681629671"><span class="annot"><span class="annottext">FastString
</span><a href="#local-6989586621681629671"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FastString
</span><a href="#local-6989586621681629671"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-688"></span><span>
</span><span id="line-689"></span><span class="hs-comment">--------------------------------------------------</span><span>
</span><span id="line-690"></span><span>
</span><span id="line-691"></span><span class="hs-comment">-- | Haskell Type Variable Binder</span><span>
</span><span id="line-692"></span><span class="hs-comment">-- The flag annotates the binder. It is 'Specificity' in places where</span><span>
</span><span id="line-693"></span><span class="hs-comment">-- explicit specificity is allowed (e.g. x :: forall {a} b. ...) or</span><span>
</span><span id="line-694"></span><span class="hs-comment">-- '()' in other places.</span><span>
</span><span id="line-695"></span><span class="hs-keyword">data</span><span> </span><span id="HsTyVarBndr"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTyVarBndr"><span class="hs-identifier hs-var">HsTyVarBndr</span></a></span></span><span> </span><span id="local-6989586621681629672"><span class="annot"><a href="#local-6989586621681629672"><span class="hs-identifier hs-type">flag</span></a></span></span><span> </span><span id="local-6989586621681629673"><span class="annot"><a href="#local-6989586621681629673"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-696"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="UserTyVar"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#UserTyVar"><span class="hs-identifier hs-var">UserTyVar</span></a></span></span><span>        </span><span class="hs-comment">-- no explicit kinding</span><span>
</span><span id="line-697"></span><span>         </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XUserTyVar"><span class="hs-identifier hs-type">XUserTyVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629673"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-698"></span><span>         </span><span class="annot"><a href="#local-6989586621681629672"><span class="hs-identifier hs-type">flag</span></a></span><span>
</span><span id="line-699"></span><span>         </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629673"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-700"></span><span>        </span><span class="hs-comment">-- See Note [Located RdrNames] in GHC.Hs.Expr</span><span>
</span><span id="line-701"></span><span>
</span><span id="line-702"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="KindedTyVar"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#KindedTyVar"><span class="hs-identifier hs-var">KindedTyVar</span></a></span></span><span>
</span><span id="line-703"></span><span>         </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XKindedTyVar"><span class="hs-identifier hs-type">XKindedTyVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629673"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-704"></span><span>         </span><span class="annot"><a href="#local-6989586621681629672"><span class="hs-identifier hs-type">flag</span></a></span><span>
</span><span id="line-705"></span><span>         </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629673"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-706"></span><span>         </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsKind"><span class="hs-identifier hs-type">LHsKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629673"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- The user-supplied kind signature</span><span>
</span><span id="line-707"></span><span>        </span><span class="hs-comment">-- ^</span><span>
</span><span id="line-708"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-709"></span><span>        </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnDcolon', 'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-710"></span><span>
</span><span id="line-711"></span><span>        </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-712"></span><span>
</span><span id="line-713"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XTyVarBndr"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XTyVarBndr"><span class="hs-identifier hs-var">XTyVarBndr</span></a></span></span><span>
</span><span id="line-714"></span><span>      </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXTyVarBndr"><span class="hs-identifier hs-type">XXTyVarBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629673"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-715"></span><span>
</span><span id="line-716"></span><span class="annot"><span class="hs-comment">-- | Does this 'HsTyVarBndr' come with an explicit kind annotation?</span></span><span>
</span><span id="line-717"></span><span id="local-6989586621681629294"><span id="local-6989586621681629295"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#isHsKindedTyVar"><span class="hs-identifier hs-type">isHsKindedTyVar</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTyVarBndr"><span class="hs-identifier hs-type">HsTyVarBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629294"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629295"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-718"></span><span id="isHsKindedTyVar"><span class="annot"><span class="annottext">isHsKindedTyVar :: forall flag pass. HsTyVarBndr flag pass -&gt; Bool
</span><a href="Language.Haskell.Syntax.Type.html#isHsKindedTyVar"><span class="hs-identifier hs-var hs-var">isHsKindedTyVar</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#UserTyVar"><span class="hs-identifier hs-type">UserTyVar</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-719"></span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#isHsKindedTyVar"><span class="hs-identifier hs-var">isHsKindedTyVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#KindedTyVar"><span class="hs-identifier hs-type">KindedTyVar</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-720"></span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#isHsKindedTyVar"><span class="hs-identifier hs-var">isHsKindedTyVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XTyVarBndr"><span class="hs-identifier hs-type">XTyVarBndr</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-721"></span><span>
</span><span id="line-722"></span><span class="annot"><span class="hs-comment">-- | Haskell Type</span></span><span>
</span><span id="line-723"></span><span class="hs-keyword">data</span><span> </span><span id="HsType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsType"><span class="hs-identifier hs-var">HsType</span></a></span></span><span> </span><span id="local-6989586621681629299"><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-724"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsForAllTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsForAllTy"><span class="hs-identifier hs-var">HsForAllTy</span></a></span></span><span>   </span><span class="hs-comment">-- See Note [HsType binders]</span><span>
</span><span id="line-725"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="hst_xforall"><span class="annot"><span class="annottext">forall pass. HsType pass -&gt; XForAllTy pass
</span><a href="Language.Haskell.Syntax.Type.html#hst_xforall"><span class="hs-identifier hs-var hs-var">hst_xforall</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XForAllTy"><span class="hs-identifier hs-type">XForAllTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-726"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="hst_tele"><span class="annot"><span class="annottext">forall pass. HsType pass -&gt; HsForAllTelescope pass
</span><a href="Language.Haskell.Syntax.Type.html#hst_tele"><span class="hs-identifier hs-var hs-var">hst_tele</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsForAllTelescope"><span class="hs-identifier hs-type">HsForAllTelescope</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-727"></span><span>                                     </span><span class="hs-comment">-- Explicit, user-supplied 'forall a {b} c'</span><span>
</span><span id="line-728"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="hst_body"><span class="annot"><span class="annottext">forall pass. HsType pass -&gt; LHsType pass
</span><a href="Language.Haskell.Syntax.Type.html#hst_body"><span class="hs-identifier hs-var hs-var">hst_body</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span>  </span><span class="hs-comment">-- body type</span><span>
</span><span id="line-729"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-730"></span><span>      </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnForall',</span><span>
</span><span id="line-731"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnDot','GHC.Parser.Annotation.AnnDarrow'</span><span>
</span><span id="line-732"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in &quot;GHC.Parser.Annotation&quot;</span><span>
</span><span id="line-733"></span><span>
</span><span id="line-734"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsQualTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsQualTy"><span class="hs-identifier hs-var">HsQualTy</span></a></span></span><span>   </span><span class="hs-comment">-- See Note [HsType binders]</span><span>
</span><span id="line-735"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="hst_xqual"><span class="annot"><span class="annottext">forall pass. HsType pass -&gt; XQualTy pass
</span><a href="Language.Haskell.Syntax.Type.html#hst_xqual"><span class="hs-identifier hs-var hs-var">hst_xqual</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XQualTy"><span class="hs-identifier hs-type">XQualTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-736"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="hst_ctxt"><span class="annot"><span class="annottext">forall pass. HsType pass -&gt; LHsContext pass
</span><a href="Language.Haskell.Syntax.Type.html#hst_ctxt"><span class="hs-identifier hs-var hs-var">hst_ctxt</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsContext"><span class="hs-identifier hs-type">LHsContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span>  </span><span class="hs-comment">-- Context C =&gt; blah</span><span>
</span><span id="line-737"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="hst_body"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hst_body"><span class="hs-identifier hs-var">hst_body</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-738"></span><span>
</span><span id="line-739"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsTyVar"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTyVar"><span class="hs-identifier hs-var">HsTyVar</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTyVar"><span class="hs-identifier hs-type">XTyVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-740"></span><span>              </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PromotionFlag"><span class="hs-identifier hs-type">PromotionFlag</span></a></span><span>    </span><span class="hs-comment">-- Whether explicitly promoted,</span><span>
</span><span id="line-741"></span><span>                               </span><span class="hs-comment">-- for the pretty printer</span><span>
</span><span id="line-742"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-743"></span><span>                  </span><span class="hs-comment">-- Type variable, type constructor, or data constructor</span><span>
</span><span id="line-744"></span><span>                  </span><span class="hs-comment">-- see Note [Promotions (HsTyVar)]</span><span>
</span><span id="line-745"></span><span>                  </span><span class="hs-comment">-- See Note [Located RdrNames] in GHC.Hs.Expr</span><span>
</span><span id="line-746"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span></span><span>
</span><span id="line-747"></span><span>
</span><span id="line-748"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-749"></span><span>
</span><span id="line-750"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsAppTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsAppTy"><span class="hs-identifier hs-var">HsAppTy</span></a></span></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAppTy"><span class="hs-identifier hs-type">XAppTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-751"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-752"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-753"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span></span><span>
</span><span id="line-754"></span><span>
</span><span id="line-755"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-756"></span><span>
</span><span id="line-757"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsAppKindTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsAppKindTy"><span class="hs-identifier hs-var">HsAppKindTy</span></a></span></span><span>         </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAppKindTy"><span class="hs-identifier hs-type">XAppKindTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- type level type app</span><span>
</span><span id="line-758"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-759"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsKind"><span class="hs-identifier hs-type">LHsKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-760"></span><span>
</span><span id="line-761"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsFunTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsFunTy"><span class="hs-identifier hs-var">HsFunTy</span></a></span></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XFunTy"><span class="hs-identifier hs-type">XFunTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-762"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsArrow"><span class="hs-identifier hs-type">HsArrow</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-763"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- function type</span><span>
</span><span id="line-764"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-765"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnRarrow',</span></span><span>
</span><span id="line-766"></span><span>
</span><span id="line-767"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-768"></span><span>
</span><span id="line-769"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsListTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsListTy"><span class="hs-identifier hs-var">HsListTy</span></a></span></span><span>            </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListTy"><span class="hs-identifier hs-type">XListTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-770"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- Element type</span><span>
</span><span id="line-771"></span><span>      </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'['@,</span><span>
</span><span id="line-772"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' @']'@</span><span>
</span><span id="line-773"></span><span>
</span><span id="line-774"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-775"></span><span>
</span><span id="line-776"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsTupleTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTupleTy"><span class="hs-identifier hs-var">HsTupleTy</span></a></span></span><span>           </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTupleTy"><span class="hs-identifier hs-type">XTupleTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-777"></span><span>                        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTupleSort"><span class="hs-identifier hs-type">HsTupleSort</span></a></span><span>
</span><span id="line-778"></span><span>                        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- Element types (length gives arity)</span><span>
</span><span id="line-779"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'(' or '(#'@,</span><span>
</span><span id="line-780"></span><span>    </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' @')' or '#)'@</span><span>
</span><span id="line-781"></span><span>
</span><span id="line-782"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-783"></span><span>
</span><span id="line-784"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsSumTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsSumTy"><span class="hs-identifier hs-var">HsSumTy</span></a></span></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumTy"><span class="hs-identifier hs-type">XSumTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-785"></span><span>                        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- Element types (length gives arity)</span><span>
</span><span id="line-786"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'(#'@,</span><span>
</span><span id="line-787"></span><span>    </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' '#)'@</span><span>
</span><span id="line-788"></span><span>
</span><span id="line-789"></span><span>    </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-790"></span><span>
</span><span id="line-791"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsOpTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsOpTy"><span class="hs-identifier hs-var">HsOpTy</span></a></span></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XOpTy"><span class="hs-identifier hs-type">XOpTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-792"></span><span>                        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PromotionFlag"><span class="hs-identifier hs-type">PromotionFlag</span></a></span><span>    </span><span class="hs-comment">-- Whether explicitly promoted,</span><span>
</span><span id="line-793"></span><span>                                         </span><span class="hs-comment">-- for the pretty printer</span><span>
</span><span id="line-794"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-795"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span></span><span>
</span><span id="line-796"></span><span>
</span><span id="line-797"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-798"></span><span>
</span><span id="line-799"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsParTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsParTy"><span class="hs-identifier hs-var">HsParTy</span></a></span></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParTy"><span class="hs-identifier hs-type">XParTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-800"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- See Note [Parens in HsSyn] in GHC.Hs.Expr</span><span>
</span><span id="line-801"></span><span>        </span><span class="hs-comment">-- Parenthesis preserved for the precedence re-arrangement in</span><span>
</span><span id="line-802"></span><span>        </span><span class="hs-comment">-- GHC.Rename.HsType</span><span>
</span><span id="line-803"></span><span>        </span><span class="hs-comment">-- It's important that a * (b + c) doesn't get rearranged to (a*b) + c!</span><span>
</span><span id="line-804"></span><span>      </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span><span>
</span><span id="line-805"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' @')'@</span><span>
</span><span id="line-806"></span><span>
</span><span id="line-807"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-808"></span><span>
</span><span id="line-809"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsIParamTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIParamTy"><span class="hs-identifier hs-var">HsIParamTy</span></a></span></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XIParamTy"><span class="hs-identifier hs-type">XIParamTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-810"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier hs-type">HsIPName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- (?x :: ty)</span><span>
</span><span id="line-811"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- Implicit parameters as they occur in</span><span>
</span><span id="line-812"></span><span>                                         </span><span class="hs-comment">-- contexts</span><span>
</span><span id="line-813"></span><span>      </span><span class="hs-comment">-- ^</span><span>
</span><span id="line-814"></span><span>      </span><span class="hs-comment">-- &gt; (?x :: ty)</span><span>
</span><span id="line-815"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-816"></span><span>      </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span><span>
</span><span id="line-817"></span><span>
</span><span id="line-818"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-819"></span><span>
</span><span id="line-820"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsStarTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsStarTy"><span class="hs-identifier hs-var">HsStarTy</span></a></span></span><span>            </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XStarTy"><span class="hs-identifier hs-type">XStarTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-821"></span><span>                        </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>             </span><span class="hs-comment">-- Is this the Unicode variant?</span><span>
</span><span id="line-822"></span><span>                                         </span><span class="hs-comment">-- Note [HsStarTy]</span><span>
</span><span id="line-823"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span></span><span>
</span><span id="line-824"></span><span>
</span><span id="line-825"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsKindSig"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsKindSig"><span class="hs-identifier hs-var">HsKindSig</span></a></span></span><span>           </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XKindSig"><span class="hs-identifier hs-type">XKindSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-826"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- (ty :: kind)</span><span>
</span><span id="line-827"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsKind"><span class="hs-identifier hs-type">LHsKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- A type with a kind signature</span><span>
</span><span id="line-828"></span><span>      </span><span class="hs-comment">-- ^</span><span>
</span><span id="line-829"></span><span>      </span><span class="hs-comment">-- &gt; (ty :: kind)</span><span>
</span><span id="line-830"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-831"></span><span>      </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span><span>
</span><span id="line-832"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnDcolon','GHC.Parser.Annotation.AnnClose' @')'@</span><span>
</span><span id="line-833"></span><span>
</span><span id="line-834"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-835"></span><span>
</span><span id="line-836"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsSpliceTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsSpliceTy"><span class="hs-identifier hs-var">HsSpliceTy</span></a></span></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSpliceTy"><span class="hs-identifier hs-type">XSpliceTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-837"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSplice"><span class="hs-identifier hs-type">HsUntypedSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- Includes quasi-quotes</span><span>
</span><span id="line-838"></span><span>      </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'$('@,</span><span>
</span><span id="line-839"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' @')'@</span><span>
</span><span id="line-840"></span><span>
</span><span id="line-841"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-842"></span><span>
</span><span id="line-843"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsDocTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsDocTy"><span class="hs-identifier hs-var">HsDocTy</span></a></span></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDocTy"><span class="hs-identifier hs-type">XDocTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-844"></span><span>                        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier hs-type">LHsDoc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- A documented type</span><span>
</span><span id="line-845"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span></span><span>
</span><span id="line-846"></span><span>
</span><span id="line-847"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-848"></span><span>
</span><span id="line-849"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsBangTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsBangTy"><span class="hs-identifier hs-var">HsBangTy</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangTy"><span class="hs-identifier hs-type">XBangTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-850"></span><span>                </span><span class="annot"><a href="GHC.Core.DataCon.html#HsSrcBang"><span class="hs-identifier hs-type">HsSrcBang</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- Bang-style type annotations</span><span>
</span><span id="line-851"></span><span>      </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' :</span><span>
</span><span id="line-852"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnOpen' @'{-\# UNPACK' or '{-\# NOUNPACK'@,</span><span>
</span><span id="line-853"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' @'#-}'@</span><span>
</span><span id="line-854"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnBang' @\'!\'@</span><span>
</span><span id="line-855"></span><span>
</span><span id="line-856"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-857"></span><span>
</span><span id="line-858"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsRecTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsRecTy"><span class="hs-identifier hs-var">HsRecTy</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRecTy"><span class="hs-identifier hs-type">XRecTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-859"></span><span>                </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LConDeclField"><span class="hs-identifier hs-type">LConDeclField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>    </span><span class="hs-comment">-- Only in data type declarations</span><span>
</span><span id="line-860"></span><span>      </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-861"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-862"></span><span>
</span><span id="line-863"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-864"></span><span>
</span><span id="line-865"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsExplicitListTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsExplicitListTy"><span class="hs-identifier hs-var">HsExplicitListTy</span></a></span></span><span>       </span><span class="hs-comment">-- A promoted explicit list</span><span>
</span><span id="line-866"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExplicitListTy"><span class="hs-identifier hs-type">XExplicitListTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-867"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PromotionFlag"><span class="hs-identifier hs-type">PromotionFlag</span></a></span><span>      </span><span class="hs-comment">-- whether explicitly promoted, for pretty printer</span><span>
</span><span id="line-868"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-869"></span><span>      </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @&quot;'[&quot;@,</span><span>
</span><span id="line-870"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' @']'@</span><span>
</span><span id="line-871"></span><span>
</span><span id="line-872"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-873"></span><span>
</span><span id="line-874"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsExplicitTupleTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsExplicitTupleTy"><span class="hs-identifier hs-var">HsExplicitTupleTy</span></a></span></span><span>      </span><span class="hs-comment">-- A promoted explicit tuple</span><span>
</span><span id="line-875"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExplicitTupleTy"><span class="hs-identifier hs-type">XExplicitTupleTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-876"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-877"></span><span>      </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @&quot;'(&quot;@,</span><span>
</span><span id="line-878"></span><span>      </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' @')'@</span><span>
</span><span id="line-879"></span><span>
</span><span id="line-880"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-881"></span><span>
</span><span id="line-882"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsTyLit"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTyLit"><span class="hs-identifier hs-var">HsTyLit</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTyLit"><span class="hs-identifier hs-type">XTyLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTyLit"><span class="hs-identifier hs-type">HsTyLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- A promoted numeric literal.</span><span>
</span><span id="line-883"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span></span><span>
</span><span id="line-884"></span><span>
</span><span id="line-885"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-886"></span><span>
</span><span id="line-887"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsWildCardTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsWildCardTy"><span class="hs-identifier hs-var">HsWildCardTy</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildCardTy"><span class="hs-identifier hs-type">XWildCardTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- A type wildcard</span><span>
</span><span id="line-888"></span><span>      </span><span class="hs-comment">-- See Note [The wildcard story for types]</span><span>
</span><span id="line-889"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : None</span></span><span>
</span><span id="line-890"></span><span>
</span><span id="line-891"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-892"></span><span>
</span><span id="line-893"></span><span>  </span><span class="hs-comment">-- Extension point; see Note [Trees That Grow] in Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-894"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsType"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XHsType"><span class="hs-identifier hs-var">XHsType</span></a></span></span><span>
</span><span id="line-895"></span><span>      </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXType"><span class="hs-identifier hs-type">XXType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629299"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-896"></span><span>
</span><span id="line-897"></span><span>
</span><span id="line-898"></span><span class="annot"><span class="hs-comment">-- | Haskell Type Literal</span></span><span>
</span><span id="line-899"></span><span class="hs-keyword">data</span><span> </span><span id="HsTyLit"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTyLit"><span class="hs-identifier hs-var">HsTyLit</span></a></span></span><span> </span><span id="local-6989586621681629727"><span class="annot"><a href="#local-6989586621681629727"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-900"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsNumTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsNumTy"><span class="hs-identifier hs-var">HsNumTy</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNumTy"><span class="hs-identifier hs-type">XNumTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629727"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>
</span><span id="line-901"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsStrTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsStrTy"><span class="hs-identifier hs-var">HsStrTy</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XStrTy"><span class="hs-identifier hs-type">XStrTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629727"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="GHC.Data.FastString.html#FastString"><span class="hs-identifier hs-type">FastString</span></a></span><span>
</span><span id="line-902"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCharTy"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsCharTy"><span class="hs-identifier hs-var">HsCharTy</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCharTy"><span class="hs-identifier hs-type">XCharTy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629727"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-903"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XTyLit"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XTyLit"><span class="hs-identifier hs-var">XTyLit</span></a></span></span><span>   </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXTyLit"><span class="hs-identifier hs-type">XXTyLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629727"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-904"></span><span>
</span><span id="line-905"></span><span class="annot"><span class="hs-comment">-- | Denotes the type of arrows in the surface language</span></span><span>
</span><span id="line-906"></span><span class="hs-keyword">data</span><span> </span><span id="HsArrow"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsArrow"><span class="hs-identifier hs-var">HsArrow</span></a></span></span><span> </span><span id="local-6989586621681629736"><span class="annot"><a href="#local-6989586621681629736"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-907"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsUnrestrictedArrow"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsUnrestrictedArrow"><span class="hs-identifier hs-var">HsUnrestrictedArrow</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsUniToken"><span class="hs-identifier hs-type">LHsUniToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;-&gt;&quot;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;&#8594;&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681629736"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-908"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ a -&gt; b or a &#8594; b</span></span><span>
</span><span id="line-909"></span><span>
</span><span id="line-910"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsLinearArrow"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsLinearArrow"><span class="hs-identifier hs-var">HsLinearArrow</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsLinearArrowTokens"><span class="hs-identifier hs-type">HsLinearArrowTokens</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629736"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-911"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ a %1 -&gt; b or a %1 &#8594; b, or a &#8888; b</span></span><span>
</span><span id="line-912"></span><span>
</span><span id="line-913"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsExplicitMult"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsExplicitMult"><span class="hs-identifier hs-var">HsExplicitMult</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;%&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681629736"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629736"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsUniToken"><span class="hs-identifier hs-type">LHsUniToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;-&gt;&quot;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;&#8594;&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681629736"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-914"></span><span>    </span><span class="hs-comment">-- ^ a %m -&gt; b or a %m &#8594; b (very much including `a %Many -&gt; b`!</span><span>
</span><span id="line-915"></span><span>    </span><span class="hs-comment">-- This is how the programmer wrote it). It is stored as an</span><span>
</span><span id="line-916"></span><span>    </span><span class="hs-comment">-- `HsType` so as to preserve the syntax as written in the</span><span>
</span><span id="line-917"></span><span>    </span><span class="hs-comment">-- program.</span><span>
</span><span id="line-918"></span><span>
</span><span id="line-919"></span><span class="hs-keyword">data</span><span> </span><span id="HsLinearArrowTokens"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsLinearArrowTokens"><span class="hs-identifier hs-var">HsLinearArrowTokens</span></a></span></span><span> </span><span id="local-6989586621681629742"><span class="annot"><a href="#local-6989586621681629742"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-920"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsPct1"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsPct1"><span class="hs-identifier hs-var">HsPct1</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;%1&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681629742"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsUniToken"><span class="hs-identifier hs-type">LHsUniToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;-&gt;&quot;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;&#8594;&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681629742"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-921"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsLolly"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsLolly"><span class="hs-identifier hs-var">HsLolly</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Concrete.html#LHsToken"><span class="hs-identifier hs-type">LHsToken</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;&#8888;&quot;</span></span><span> </span><span class="annot"><a href="#local-6989586621681629742"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-922"></span><span>
</span><span id="line-923"></span><span class="hs-comment">-- | This is used in the syntax. In constructor declaration. It must keep the</span><span>
</span><span id="line-924"></span><span class="hs-comment">-- arrow representation.</span><span>
</span><span id="line-925"></span><span class="hs-keyword">data</span><span> </span><span id="HsScaled"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsScaled"><span class="hs-identifier hs-var">HsScaled</span></a></span></span><span> </span><span id="local-6989586621681629745"><span class="annot"><a href="#local-6989586621681629745"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span id="local-6989586621681629746"><span class="annot"><a href="#local-6989586621681629746"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="HsScaled"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsScaled"><span class="hs-identifier hs-var">HsScaled</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsArrow"><span class="hs-identifier hs-type">HsArrow</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629745"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681629746"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-926"></span><span>
</span><span id="line-927"></span><span id="local-6989586621681629309"><span id="local-6989586621681629310"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hsMult"><span class="hs-identifier hs-type">hsMult</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsScaled"><span class="hs-identifier hs-type">HsScaled</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629309"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629310"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsArrow"><span class="hs-identifier hs-type">HsArrow</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629309"><span class="hs-identifier hs-type">pass</span></a></span></span></span><span>
</span><span id="line-928"></span><span id="hsMult"><span class="annot"><span class="annottext">hsMult :: forall pass a. HsScaled pass a -&gt; HsArrow pass
</span><a href="Language.Haskell.Syntax.Type.html#hsMult"><span class="hs-identifier hs-var hs-var">hsMult</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsScaled"><span class="hs-identifier hs-type">HsScaled</span></a></span><span> </span><span id="local-6989586621681629748"><span class="annot"><span class="annottext">HsArrow pass
</span><a href="#local-6989586621681629748"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsArrow pass
</span><a href="#local-6989586621681629748"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-929"></span><span>
</span><span id="line-930"></span><span id="local-6989586621681629315"><span id="local-6989586621681629316"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#hsScaledThing"><span class="hs-identifier hs-type">hsScaledThing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsScaled"><span class="hs-identifier hs-type">HsScaled</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629315"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629316"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681629316"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-931"></span><span id="hsScaledThing"><span class="annot"><span class="annottext">hsScaledThing :: forall pass a. HsScaled pass a -&gt; a
</span><a href="Language.Haskell.Syntax.Type.html#hsScaledThing"><span class="hs-identifier hs-var hs-var">hsScaledThing</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsScaled"><span class="hs-identifier hs-type">HsScaled</span></a></span><span> </span><span class="annot"><span class="annottext">HsArrow pass
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681629749"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681629749"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681629749"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-932"></span><span>
</span><span id="line-933"></span><span class="hs-comment">{-
Note [Unit tuples]
~~~~~~~~~~~~~~~~~~
Consider the type
    type instance F Int = ()
We want to parse that &quot;()&quot;
    as HsTupleTy HsBoxedOrConstraintTuple [],
NOT as HsTyVar unitTyCon

Why? Because F might have kind (* -&gt; Constraint), so we when parsing we
don't know if that tuple is going to be a constraint tuple or an ordinary
unit tuple.  The HsTupleSort flag is specifically designed to deal with
that, but it has to work for unit tuples too.

Note [Promotions (HsTyVar)]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
HsTyVar: A name in a type or kind.
  Here are the allowed namespaces for the name.
    In a type:
      Var: not allowed
      Data: promoted data constructor
      Tv: type variable
      TcCls before renamer: type constructor, class constructor, or promoted data constructor
      TcCls after renamer: type constructor or class constructor
    In a kind:
      Var, Data: not allowed
      Tv: kind variable
      TcCls: kind constructor or promoted type constructor

  The 'Promoted' field in an HsTyVar captures whether the type was promoted in
  the source code by prefixing an apostrophe.

Note [HsStarTy]
~~~~~~~~~~~~~~~
When the StarIsType extension is enabled, we want to treat '*' and its Unicode
variant identically to 'Data.Kind.Type'. Unfortunately, doing so in the parser
would mean that when we pretty-print it back, we don't know whether the user
wrote '*' or 'Type', and lose the parse/ppr roundtrip property.

As a workaround, we parse '*' as HsStarTy (if it stands for 'Data.Kind.Type')
and then desugar it to 'Data.Kind.Type' in the typechecker (see tc_hs_type).
When '*' is a regular type operator (StarIsType is disabled), HsStarTy is not
involved.


Note [Promoted lists and tuples]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Notice the difference between
   HsListTy    HsExplicitListTy
   HsTupleTy   HsExplicitListTupleTy

E.g.    f :: [Int]                      HsListTy

        g3  :: T '[]                   All these use
        g2  :: T '[True]                  HsExplicitListTy
        g1  :: T '[True,False]
        g1a :: T [True,False]             (can omit ' where unambiguous)

  kind of T :: [Bool] -&gt; *        This kind uses HsListTy!

E.g.    h :: (Int,Bool)                 HsTupleTy; f is a pair
        k :: S '(True,False)            HsExplicitTypleTy; S is indexed by
                                           a type-level pair of booleans
        kind of S :: (Bool,Bool) -&gt; *   This kind uses HsExplicitTupleTy

Note [Distinguishing tuple kinds]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Apart from promotion, tuples can have one of three different kinds:

        x :: (Int, Bool)                -- Regular boxed tuples
        f :: Int# -&gt; (# Int#, Int# #)   -- Unboxed tuples
        g :: (Eq a, Ord a) =&gt; a         -- Constraint tuples

For convenience, internally we use a single constructor for all of these,
namely HsTupleTy, but keep track of the tuple kind (in the first argument to
HsTupleTy, a HsTupleSort). We can tell if a tuple is unboxed while parsing,
because of the #. However, with -XConstraintKinds we can only distinguish
between constraint and boxed tuples during type checking, in general. Hence the
two constructors of HsTupleSort:

        HsUnboxedTuple                  -&gt; Produced by the parser
        HsBoxedOrConstraintTuple        -&gt; Could be a boxed or a constraint
                                        tuple. Produced by the parser only,
                                        disappears after type checking

After typechecking, we use TupleSort (which clearly distinguishes between
constraint tuples and boxed tuples) rather than HsTupleSort.
-}</span><span>
</span><span id="line-1022"></span><span>
</span><span id="line-1023"></span><span class="annot"><span class="hs-comment">-- | Haskell Tuple Sort</span></span><span>
</span><span id="line-1024"></span><span class="hs-keyword">data</span><span> </span><span id="HsTupleSort"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTupleSort"><span class="hs-identifier hs-var">HsTupleSort</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="HsUnboxedTuple"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsUnboxedTuple"><span class="hs-identifier hs-var">HsUnboxedTuple</span></a></span></span><span>
</span><span id="line-1025"></span><span>                 </span><span class="hs-glyph">|</span><span> </span><span id="HsBoxedOrConstraintTuple"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsBoxedOrConstraintTuple"><span class="hs-identifier hs-var">HsBoxedOrConstraintTuple</span></a></span></span><span>
</span><span id="line-1026"></span><span>                 </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681629755"><span id="local-6989586621681629757"><span id="local-6989586621681629759"><span id="local-6989586621681629761"><span id="local-6989586621681629763"><span id="local-6989586621681629769"><span id="local-6989586621681629774"><span id="local-6989586621681629777"><span id="local-6989586621681629780"><span id="local-6989586621681629783"><span id="local-6989586621681629786"><span id="local-6989586621681629789"><span id="local-6989586621681629794"><span id="local-6989586621681629799"><span class="annot"><span class="annottext">Typeable HsTupleSort
Typeable HsTupleSort =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; HsTupleSort -&gt; c HsTupleSort)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsTupleSort)
-&gt; (HsTupleSort -&gt; Constr)
-&gt; (HsTupleSort -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsTupleSort))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c HsTupleSort))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; HsTupleSort -&gt; HsTupleSort)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsTupleSort -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsTupleSort -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsTupleSort -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsTupleSort -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort)
-&gt; Data HsTupleSort
HsTupleSort -&gt; Constr
HsTupleSort -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; HsTupleSort -&gt; HsTupleSort
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsTupleSort -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsTupleSort -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsTupleSort -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsTupleSort -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsTupleSort
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsTupleSort -&gt; c HsTupleSort
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsTupleSort)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c HsTupleSort)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsTupleSort -&gt; c HsTupleSort
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsTupleSort -&gt; c HsTupleSort
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsTupleSort
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsTupleSort
$ctoConstr :: HsTupleSort -&gt; Constr
toConstr :: HsTupleSort -&gt; Constr
$cdataTypeOf :: HsTupleSort -&gt; DataType
dataTypeOf :: HsTupleSort -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsTupleSort)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsTupleSort)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c HsTupleSort)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c HsTupleSort)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; HsTupleSort -&gt; HsTupleSort
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; HsTupleSort -&gt; HsTupleSort
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsTupleSort -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsTupleSort -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsTupleSort -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsTupleSort -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsTupleSort -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsTupleSort -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsTupleSort -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsTupleSort -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsTupleSort -&gt; m HsTupleSort
</span><a href="../../base-4.18.3.0/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-1027"></span><span>
</span><span id="line-1028"></span><span class="annot"><span class="hs-comment">-- | Located Constructor Declaration Field</span></span><span>
</span><span id="line-1029"></span><span class="hs-keyword">type</span><span> </span><span id="LConDeclField"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LConDeclField"><span class="hs-identifier hs-var">LConDeclField</span></a></span></span><span> </span><span id="local-6989586621681629803"><span class="annot"><a href="#local-6989586621681629803"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629803"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#ConDeclField"><span class="hs-identifier hs-type">ConDeclField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629803"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1030"></span><span>      </span><span class="hs-comment">-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when</span><span>
</span><span id="line-1031"></span><span>      </span><span class="hs-comment">--   in a list</span><span>
</span><span id="line-1032"></span><span>
</span><span id="line-1033"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1034"></span><span>
</span><span id="line-1035"></span><span class="annot"><span class="hs-comment">-- | Constructor Declaration Field</span></span><span>
</span><span id="line-1036"></span><span class="hs-keyword">data</span><span> </span><span id="ConDeclField"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#ConDeclField"><span class="hs-identifier hs-var">ConDeclField</span></a></span></span><span> </span><span id="local-6989586621681629325"><span class="annot"><a href="#local-6989586621681629325"><span class="hs-identifier hs-type">pass</span></a></span></span><span>  </span><span class="hs-comment">-- Record fields have Haddock docs on them</span><span>
</span><span id="line-1037"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ConDeclField"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#ConDeclField"><span class="hs-identifier hs-var">ConDeclField</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="cd_fld_ext"><span class="annot"><span class="annottext">forall pass. ConDeclField pass -&gt; XConDeclField pass
</span><a href="Language.Haskell.Syntax.Type.html#cd_fld_ext"><span class="hs-identifier hs-var hs-var">cd_fld_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConDeclField"><span class="hs-identifier hs-type">XConDeclField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629325"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1038"></span><span>                   </span><span id="cd_fld_names"><span class="annot"><span class="annottext">forall pass. ConDeclField pass -&gt; [LFieldOcc pass]
</span><a href="Language.Haskell.Syntax.Type.html#cd_fld_names"><span class="hs-identifier hs-var hs-var">cd_fld_names</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LFieldOcc"><span class="hs-identifier hs-type">LFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629325"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-1039"></span><span>                                   </span><span class="annot"><span class="hs-comment">-- ^ See Note [ConDeclField pass]</span></span><span>
</span><span id="line-1040"></span><span>                   </span><span id="cd_fld_type"><span class="annot"><span class="annottext">forall pass. ConDeclField pass -&gt; LBangType pass
</span><a href="Language.Haskell.Syntax.Type.html#cd_fld_type"><span class="hs-identifier hs-var hs-var">cd_fld_type</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LBangType"><span class="hs-identifier hs-type">LBangType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629325"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1041"></span><span>                   </span><span id="cd_fld_doc"><span class="annot"><span class="annottext">forall pass. ConDeclField pass -&gt; Maybe (LHsDoc pass)
</span><a href="Language.Haskell.Syntax.Type.html#cd_fld_doc"><span class="hs-identifier hs-var hs-var">cd_fld_doc</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.3.0/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Doc.html#LHsDoc"><span class="hs-identifier hs-type">LHsDoc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629325"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">}</span><span>
</span><span id="line-1042"></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span></span><span>
</span><span id="line-1043"></span><span>
</span><span id="line-1044"></span><span>      </span><span class="hs-comment">-- For details on above see Note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1045"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XConDeclField"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XConDeclField"><span class="hs-identifier hs-var">XConDeclField</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXConDeclField"><span class="hs-identifier hs-type">XXConDeclField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629325"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1046"></span><span>
</span><span id="line-1047"></span><span class="hs-comment">-- | Describes the arguments to a data constructor. This is a common</span><span>
</span><span id="line-1048"></span><span class="hs-comment">-- representation for several constructor-related concepts, including:</span><span>
</span><span id="line-1049"></span><span class="hs-comment">--</span><span>
</span><span id="line-1050"></span><span class="hs-comment">-- * The arguments in a Haskell98-style constructor declaration</span><span>
</span><span id="line-1051"></span><span class="hs-comment">--   (see 'HsConDeclH98Details' in &quot;GHC.Hs.Decls&quot;).</span><span>
</span><span id="line-1052"></span><span class="hs-comment">--</span><span>
</span><span id="line-1053"></span><span class="hs-comment">-- * The arguments in constructor patterns in @case@/function definitions</span><span>
</span><span id="line-1054"></span><span class="hs-comment">--   (see 'HsConPatDetails' in &quot;GHC.Hs.Pat&quot;).</span><span>
</span><span id="line-1055"></span><span class="hs-comment">--</span><span>
</span><span id="line-1056"></span><span class="hs-comment">-- * The left-hand side arguments in a pattern synonym binding</span><span>
</span><span id="line-1057"></span><span class="hs-comment">--   (see 'HsPatSynDetails' in &quot;GHC.Hs.Binds&quot;).</span><span>
</span><span id="line-1058"></span><span class="hs-comment">--</span><span>
</span><span id="line-1059"></span><span class="hs-comment">-- One notable exception is the arguments in a GADT constructor, which uses</span><span>
</span><span id="line-1060"></span><span class="hs-comment">-- a separate data type entirely (see 'HsConDeclGADTDetails' in</span><span>
</span><span id="line-1061"></span><span class="hs-comment">-- &quot;GHC.Hs.Decls&quot;). This is because GADT constructors cannot be declared with</span><span>
</span><span id="line-1062"></span><span class="hs-comment">-- infix syntax, unlike the concepts above (#18844).</span><span>
</span><span id="line-1063"></span><span class="hs-keyword">data</span><span> </span><span id="HsConDetails"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsConDetails"><span class="hs-identifier hs-var">HsConDetails</span></a></span></span><span> </span><span id="local-6989586621681629811"><span class="annot"><a href="#local-6989586621681629811"><span class="hs-identifier hs-type">tyarg</span></a></span></span><span> </span><span id="local-6989586621681629812"><span class="annot"><a href="#local-6989586621681629812"><span class="hs-identifier hs-type">arg</span></a></span></span><span> </span><span id="local-6989586621681629813"><span class="annot"><a href="#local-6989586621681629813"><span class="hs-identifier hs-type">rec</span></a></span></span><span>
</span><span id="line-1064"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="PrefixCon"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-var">PrefixCon</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681629811"><span class="hs-identifier hs-type">tyarg</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681629812"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">-- C @t1 @t2 p1 p2 p3</span><span>
</span><span id="line-1065"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecCon"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#RecCon"><span class="hs-identifier hs-var">RecCon</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621681629813"><span class="hs-identifier hs-type">rec</span></a></span><span>               </span><span class="hs-comment">-- C { x = p1, y = p2 }</span><span>
</span><span id="line-1066"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InfixCon"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-var">InfixCon</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621681629812"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629812"><span class="hs-identifier hs-type">arg</span></a></span><span>           </span><span class="hs-comment">-- p1 `C` p2</span><span>
</span><span id="line-1067"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681629825"><span id="local-6989586621681629833"><span id="local-6989586621681629840"><span id="local-6989586621681629842"><span id="local-6989586621681629844"><span id="local-6989586621681629850"><span id="local-6989586621681629855"><span id="local-6989586621681629858"><span id="local-6989586621681629861"><span id="local-6989586621681629864"><span id="local-6989586621681629867"><span id="local-6989586621681629870"><span id="local-6989586621681629875"><span id="local-6989586621681629880"><span class="annot"><span class="annottext">Typeable (HsConDetails tyarg arg rec)
Typeable (HsConDetails tyarg arg rec) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; HsConDetails tyarg arg rec
 -&gt; c (HsConDetails tyarg arg rec))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r)
    -&gt; Constr
    -&gt; c (HsConDetails tyarg arg rec))
-&gt; (HsConDetails tyarg arg rec -&gt; Constr)
-&gt; (HsConDetails tyarg arg rec -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d))
    -&gt; Maybe (c (HsConDetails tyarg arg rec)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (HsConDetails tyarg arg rec)))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; HsConDetails tyarg arg rec -&gt; HsConDetails tyarg arg rec)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; HsConDetails tyarg arg rec
    -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r
    -&gt; (forall d. Data d =&gt; d -&gt; r')
    -&gt; HsConDetails tyarg arg rec
    -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; HsConDetails tyarg arg rec -&gt; [u])
-&gt; (forall u.
    Int
    -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsConDetails tyarg arg rec -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec))
-&gt; Data (HsConDetails tyarg arg rec)
HsConDetails tyarg arg rec -&gt; Constr
HsConDetails tyarg arg rec -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; HsConDetails tyarg arg rec -&gt; HsConDetails tyarg arg rec
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsConDetails tyarg arg rec -&gt; u
forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; HsConDetails tyarg arg rec -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; HsConDetails tyarg arg rec
-&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; HsConDetails tyarg arg rec
-&gt; r
forall tyarg arg rec.
(Data tyarg, Data rec, Data arg) =&gt;
Typeable (HsConDetails tyarg arg rec)
forall tyarg arg rec.
(Data tyarg, Data rec, Data arg) =&gt;
HsConDetails tyarg arg rec -&gt; Constr
forall tyarg arg rec.
(Data tyarg, Data rec, Data arg) =&gt;
HsConDetails tyarg arg rec -&gt; DataType
forall tyarg arg rec.
(Data tyarg, Data rec, Data arg) =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; HsConDetails tyarg arg rec -&gt; HsConDetails tyarg arg rec
forall tyarg arg rec u.
(Data tyarg, Data rec, Data arg) =&gt;
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsConDetails tyarg arg rec -&gt; u
forall tyarg arg rec u.
(Data tyarg, Data rec, Data arg) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; HsConDetails tyarg arg rec -&gt; [u]
forall tyarg arg rec r r'.
(Data tyarg, Data rec, Data arg) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; HsConDetails tyarg arg rec
-&gt; r
forall tyarg arg rec r r'.
(Data tyarg, Data rec, Data arg) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; HsConDetails tyarg arg rec
-&gt; r
forall tyarg arg rec (m :: * -&gt; *).
(Data tyarg, Data rec, Data arg, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec)
forall tyarg arg rec (m :: * -&gt; *).
(Data tyarg, Data rec, Data arg, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec)
forall tyarg arg rec (c :: * -&gt; *).
(Data tyarg, Data rec, Data arg) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsConDetails tyarg arg rec)
forall tyarg arg rec (c :: * -&gt; *).
(Data tyarg, Data rec, Data arg) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsConDetails tyarg arg rec
-&gt; c (HsConDetails tyarg arg rec)
forall tyarg arg rec (t :: * -&gt; *) (c :: * -&gt; *).
(Data tyarg, Data rec, Data arg, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (HsConDetails tyarg arg rec))
forall tyarg arg rec (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data tyarg, Data rec, Data arg, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsConDetails tyarg arg rec))
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsConDetails tyarg arg rec)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsConDetails tyarg arg rec
-&gt; c (HsConDetails tyarg arg rec)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (HsConDetails tyarg arg rec))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsConDetails tyarg arg rec))
$cgfoldl :: forall tyarg arg rec (c :: * -&gt; *).
(Data tyarg, Data rec, Data arg) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsConDetails tyarg arg rec
-&gt; c (HsConDetails tyarg arg rec)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; HsConDetails tyarg arg rec
-&gt; c (HsConDetails tyarg arg rec)
$cgunfold :: forall tyarg arg rec (c :: * -&gt; *).
(Data tyarg, Data rec, Data arg) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsConDetails tyarg arg rec)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (HsConDetails tyarg arg rec)
$ctoConstr :: forall tyarg arg rec.
(Data tyarg, Data rec, Data arg) =&gt;
HsConDetails tyarg arg rec -&gt; Constr
toConstr :: HsConDetails tyarg arg rec -&gt; Constr
$cdataTypeOf :: forall tyarg arg rec.
(Data tyarg, Data rec, Data arg) =&gt;
HsConDetails tyarg arg rec -&gt; DataType
dataTypeOf :: HsConDetails tyarg arg rec -&gt; DataType
$cdataCast1 :: forall tyarg arg rec (t :: * -&gt; *) (c :: * -&gt; *).
(Data tyarg, Data rec, Data arg, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (HsConDetails tyarg arg rec))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d))
-&gt; Maybe (c (HsConDetails tyarg arg rec))
$cdataCast2 :: forall tyarg arg rec (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data tyarg, Data rec, Data arg, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsConDetails tyarg arg rec))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (HsConDetails tyarg arg rec))
$cgmapT :: forall tyarg arg rec.
(Data tyarg, Data rec, Data arg) =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; HsConDetails tyarg arg rec -&gt; HsConDetails tyarg arg rec
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; HsConDetails tyarg arg rec -&gt; HsConDetails tyarg arg rec
$cgmapQl :: forall tyarg arg rec r r'.
(Data tyarg, Data rec, Data arg) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; HsConDetails tyarg arg rec
-&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; HsConDetails tyarg arg rec
-&gt; r
$cgmapQr :: forall tyarg arg rec r r'.
(Data tyarg, Data rec, Data arg) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; HsConDetails tyarg arg rec
-&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r
-&gt; (forall d. Data d =&gt; d -&gt; r')
-&gt; HsConDetails tyarg arg rec
-&gt; r
$cgmapQ :: forall tyarg arg rec u.
(Data tyarg, Data rec, Data arg) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; HsConDetails tyarg arg rec -&gt; [u]
gmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; HsConDetails tyarg arg rec -&gt; [u]
$cgmapQi :: forall tyarg arg rec u.
(Data tyarg, Data rec, Data arg) =&gt;
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsConDetails tyarg arg rec -&gt; u
gmapQi :: forall u.
Int
-&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsConDetails tyarg arg rec -&gt; u
$cgmapM :: forall tyarg arg rec (m :: * -&gt; *).
(Data tyarg, Data rec, Data arg, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec)
$cgmapMp :: forall tyarg arg rec (m :: * -&gt; *).
(Data tyarg, Data rec, Data arg, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec)
$cgmapMo :: forall tyarg arg rec (m :: * -&gt; *).
(Data tyarg, Data rec, Data arg, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; HsConDetails tyarg arg rec -&gt; m (HsConDetails tyarg arg rec)
</span><a href="../../base-4.18.3.0/src/Data.Data.html#Data/Data.Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-1068"></span><span>
</span><span id="line-1069"></span><span class="hs-comment">-- | An empty list that can be used to indicate that there are no</span><span>
</span><span id="line-1070"></span><span class="hs-comment">-- type arguments allowed in cases where HsConDetails is applied to Void.</span><span>
</span><span id="line-1071"></span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#noTypeArgs"><span class="hs-identifier hs-type">noTypeArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="../../base-4.18.3.0/src/GHC.Base.html#Void/GHC.Base.html#Void"><span class="hs-identifier hs-type">Void</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1072"></span><span id="noTypeArgs"><span class="annot"><span class="annottext">noTypeArgs :: [Void]
</span><a href="Language.Haskell.Syntax.Type.html#noTypeArgs"><span class="hs-identifier hs-var hs-var">noTypeArgs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1073"></span><span>
</span><span id="line-1074"></span><span class="hs-comment">{-
Note [ConDeclField pass]
~~~~~~~~~~~~~~~~~~~~~~~~~

A ConDeclField contains a list of field occurrences: these always
include the field label as the user wrote it.  After the renamer, it
will additionally contain the identity of the selector function in the
second component.

Due to DuplicateRecordFields, the OccName of the selector function
may have been mangled, which is why we keep the original field label
separately.  For example, when DuplicateRecordFields is enabled

    data T = MkT { x :: Int }

gives

    ConDeclField { cd_fld_names = [L _ (FieldOcc &quot;x&quot; $sel:x:MkT)], ... }.
-}</span><span>
</span><span id="line-1093"></span><span>
</span><span id="line-1094"></span><span class="hs-comment">-----------------------</span><span>
</span><span id="line-1095"></span><span class="hs-comment">-- A valid type must have a for-all at the top of the type, or of the fn arg</span><span>
</span><span id="line-1096"></span><span class="hs-comment">-- types</span><span>
</span><span id="line-1097"></span><span>
</span><span id="line-1098"></span><span class="hs-comment">---------------------</span><span>
</span><span id="line-1099"></span><span>
</span><span id="line-1100"></span><span class="hs-comment">{- Note [Scoping of named wildcards]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider
  f :: _a -&gt; _a
  f x = let g :: _a -&gt; _a
            g = ...
        in ...

Currently, for better or worse, the &quot;_a&quot; variables are all the same. So
although there is no explicit forall, the &quot;_a&quot; scopes over the definition.
I don't know if this is a good idea, but there it is.
-}</span><span>
</span><span id="line-1112"></span><span>
</span><span id="line-1113"></span><span class="hs-comment">{- Note [hsScopedTvs and visible foralls]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-XScopedTypeVariables can be defined in terms of a desugaring to
-XTypeAbstractions (GHC Proposal #50):

    fn :: forall a b c. tau(a,b,c)            fn :: forall a b c. tau(a,b,c)
    fn = defn(a,b,c)                   ==&gt;    fn @x @y @z = defn(x,y,z)

That is, for every type variable of the leading 'forall' in the type signature,
we add an invisible binder at term level.

This model does not extend to visible forall, as discussed here:

* https://gitlab.haskell.org/ghc/ghc/issues/16734#note_203412
* https://github.com/ghc-proposals/ghc-proposals/pull/238

The conclusion of these discussions can be summarized as follows:

  &gt; Assuming support for visible 'forall' in terms, consider this example:
  &gt;
  &gt;     vfn :: forall x y -&gt; tau(x,y)
  &gt;     vfn = \a b -&gt; ...
  &gt;
  &gt; The user has written their own binders 'a' and 'b' to stand for 'x' and
  &gt; 'y', and we definitely should not desugar this into:
  &gt;
  &gt;     vfn :: forall x y -&gt; tau(x,y)
  &gt;     vfn x y = \a b -&gt; ...         -- bad!

This design choice is reflected in the design of HsOuterSigTyVarBndrs, which are
used in every place that ScopedTypeVariables takes effect:

  data HsOuterTyVarBndrs flag pass
    = HsOuterImplicit { ... }
    | HsOuterExplicit { ..., hso_bndrs :: [LHsTyVarBndr flag pass] }
    | ...
  type HsOuterSigTyVarBndrs = HsOuterTyVarBndrs Specificity

The HsOuterExplicit constructor is only used in type signatures with outermost,
/invisible/ 'forall's. Any other type&#8212;including those with outermost,
/visible/ 'forall's&#8212;will use HsOuterImplicit. Therefore, when we determine
which type variables to bring into scope over the body of a function
(in hsScopedTvs), we /only/ bring the type variables bound by the hso_bndrs in
an HsOuterExplicit into scope. If we have an HsOuterImplicit instead, then we
do not bring any type variables into scope over the body of a function at all.

At the moment, GHC does not support visible 'forall' in terms. Nevertheless,
it is still possible to write erroneous programs that use visible 'forall's in
terms, such as this example:

    x :: forall a -&gt; a -&gt; a
    x = x

Previous versions of GHC would bring `a` into scope over the body of `x` in the
hopes that the typechecker would error out later
(see `GHC.Tc.Validity.vdqAllowed`). However, this can wreak havoc in the
renamer before GHC gets to that point (see #17687 for an example of this).
Bottom line: nip problems in the bud by refraining from bringing any type
variables in an HsOuterImplicit into scope over the body of a function, even
if they correspond to a visible 'forall'.
-}</span><span>
</span><span id="line-1174"></span><span>
</span><span id="line-1175"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                Decomposing HsTypes
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1182"></span><span>
</span><span id="line-1183"></span><span class="annot"><span class="hs-comment">-- | Arguments in an expression/type after splitting</span></span><span>
</span><span id="line-1184"></span><span class="hs-keyword">data</span><span> </span><span id="HsArg"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsArg"><span class="hs-identifier hs-var">HsArg</span></a></span></span><span> </span><span id="local-6989586621681629889"><span class="annot"><a href="#local-6989586621681629889"><span class="hs-identifier hs-type">tm</span></a></span></span><span> </span><span id="local-6989586621681629890"><span class="annot"><a href="#local-6989586621681629890"><span class="hs-identifier hs-type">ty</span></a></span></span><span>
</span><span id="line-1185"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsValArg"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsValArg"><span class="hs-identifier hs-var">HsValArg</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621681629889"><span class="hs-identifier hs-type">tm</span></a></span><span>   </span><span class="hs-comment">-- Argument is an ordinary expression     (f arg)</span><span>
</span><span id="line-1186"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsTypeArg"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsTypeArg"><span class="hs-identifier hs-var">HsTypeArg</span></a></span></span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#SrcSpan"><span class="hs-identifier hs-type">SrcSpan</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629890"><span class="hs-identifier hs-type">ty</span></a></span><span> </span><span class="hs-comment">-- Argument is a visible type application (f @ty)</span><span>
</span><span id="line-1187"></span><span>                         </span><span class="hs-comment">-- SrcSpan is location of the `@`</span><span>
</span><span id="line-1188"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsArgPar"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsArgPar"><span class="hs-identifier hs-var">HsArgPar</span></a></span></span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#SrcSpan"><span class="hs-identifier hs-type">SrcSpan</span></a></span><span> </span><span class="hs-comment">-- See Note [HsArgPar]</span><span>
</span><span id="line-1189"></span><span>
</span><span id="line-1190"></span><span class="hs-comment">-- type level equivalent</span><span>
</span><span id="line-1191"></span><span class="hs-keyword">type</span><span> </span><span id="LHsTypeArg"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsTypeArg"><span class="hs-identifier hs-var">LHsTypeArg</span></a></span></span><span> </span><span id="local-6989586621681629894"><span class="annot"><a href="#local-6989586621681629894"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsArg"><span class="hs-identifier hs-type">HsArg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629894"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsKind"><span class="hs-identifier hs-type">LHsKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629894"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1192"></span><span>
</span><span id="line-1193"></span><span class="hs-comment">{-
Note [HsArgPar]
~~~~~~~~~~~~~~~
A HsArgPar indicates that everything to the left of this in the argument list is
enclosed in parentheses together with the function itself. It is necessary so
that we can recreate the parenthesis structure in the original source after
typechecking the arguments.

The SrcSpan is the span of the original HsPar

((f arg1) arg2 arg3) results in an input argument list of
[HsValArg arg1, HsArgPar span1, HsValArg arg2, HsValArg arg3, HsArgPar span2]

-}</span><span>
</span><span id="line-1207"></span><span>
</span><span id="line-1208"></span><span>
</span><span id="line-1209"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                FieldOcc
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1216"></span><span>
</span><span id="line-1217"></span><span class="annot"><span class="hs-comment">-- | Located Field Occurrence</span></span><span>
</span><span id="line-1218"></span><span class="hs-keyword">type</span><span> </span><span id="LFieldOcc"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LFieldOcc"><span class="hs-identifier hs-var">LFieldOcc</span></a></span></span><span> </span><span id="local-6989586621681629895"><span class="annot"><a href="#local-6989586621681629895"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629895"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#FieldOcc"><span class="hs-identifier hs-type">FieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629895"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1219"></span><span>
</span><span id="line-1220"></span><span class="hs-comment">-- | Field Occurrence</span><span>
</span><span id="line-1221"></span><span class="hs-comment">--</span><span>
</span><span id="line-1222"></span><span class="hs-comment">-- Represents an *occurrence* of a field. This may or may not be a</span><span>
</span><span id="line-1223"></span><span class="hs-comment">-- binding occurrence (e.g. this type is used in 'ConDeclField' and</span><span>
</span><span id="line-1224"></span><span class="hs-comment">-- 'RecordPatSynField' which bind their fields, but also in</span><span>
</span><span id="line-1225"></span><span class="hs-comment">-- 'HsRecField' for record construction and patterns, which do not).</span><span>
</span><span id="line-1226"></span><span class="hs-comment">--</span><span>
</span><span id="line-1227"></span><span class="hs-comment">-- We store both the 'RdrName' the user originally wrote, and after</span><span>
</span><span id="line-1228"></span><span class="hs-comment">-- the renamer we use the extension field to store the selector</span><span>
</span><span id="line-1229"></span><span class="hs-comment">-- function.</span><span>
</span><span id="line-1230"></span><span class="hs-keyword">data</span><span> </span><span id="FieldOcc"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#FieldOcc"><span class="hs-identifier hs-var">FieldOcc</span></a></span></span><span> </span><span id="local-6989586621681629348"><span class="annot"><a href="#local-6989586621681629348"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1231"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="FieldOcc"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#FieldOcc"><span class="hs-identifier hs-var">FieldOcc</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-1232"></span><span>        </span><span id="foExt"><span class="annot"><span class="annottext">forall pass. FieldOcc pass -&gt; XCFieldOcc pass
</span><a href="Language.Haskell.Syntax.Type.html#foExt"><span class="hs-identifier hs-var hs-var">foExt</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCFieldOcc"><span class="hs-identifier hs-type">XCFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629348"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-1233"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="foLabel"><span class="annot"><span class="annottext">forall pass. FieldOcc pass -&gt; XRec pass RdrName
</span><a href="Language.Haskell.Syntax.Type.html#foLabel"><span class="hs-identifier hs-var hs-var">foLabel</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629348"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span> </span><span class="hs-comment">-- See Note [Located RdrNames] in Language.Haskell.Syntax.Expr</span><span>
</span><span id="line-1234"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-1235"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XFieldOcc"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XFieldOcc"><span class="hs-identifier hs-var">XFieldOcc</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXFieldOcc"><span class="hs-identifier hs-type">XXFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629348"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1236"></span><span id="local-6989586621681629357"><span id="local-6989586621681629904"><span id="local-6989586621681629909"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-1237"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629357"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1238"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCFieldOcc"><span class="hs-identifier hs-type">XCFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629357"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1239"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXFieldOcc"><span class="hs-identifier hs-type">XXFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629357"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1240"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#FieldOcc"><span class="hs-identifier hs-type">FieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629357"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-1241"></span><span>
</span><span id="line-1242"></span><span class="annot"><span class="hs-comment">-- | Located Ambiguous Field Occurence</span></span><span>
</span><span id="line-1243"></span><span class="hs-keyword">type</span><span> </span><span id="LAmbiguousFieldOcc"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LAmbiguousFieldOcc"><span class="hs-identifier hs-var">LAmbiguousFieldOcc</span></a></span></span><span> </span><span id="local-6989586621681629912"><span class="annot"><a href="#local-6989586621681629912"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629912"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#AmbiguousFieldOcc"><span class="hs-identifier hs-type">AmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629912"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1244"></span><span>
</span><span id="line-1245"></span><span class="hs-comment">-- | Ambiguous Field Occurrence</span><span>
</span><span id="line-1246"></span><span class="hs-comment">--</span><span>
</span><span id="line-1247"></span><span class="hs-comment">-- Represents an *occurrence* of a field that is potentially</span><span>
</span><span id="line-1248"></span><span class="hs-comment">-- ambiguous after the renamer, with the ambiguity resolved by the</span><span>
</span><span id="line-1249"></span><span class="hs-comment">-- typechecker.  We always store the 'RdrName' that the user</span><span>
</span><span id="line-1250"></span><span class="hs-comment">-- originally wrote, and store the selector function after the renamer</span><span>
</span><span id="line-1251"></span><span class="hs-comment">-- (for unambiguous occurrences) or the typechecker (for ambiguous</span><span>
</span><span id="line-1252"></span><span class="hs-comment">-- occurrences).</span><span>
</span><span id="line-1253"></span><span class="hs-comment">--</span><span>
</span><span id="line-1254"></span><span class="hs-comment">-- See Note [HsRecField and HsRecUpdField] in &quot;GHC.Hs.Pat&quot;.</span><span>
</span><span id="line-1255"></span><span class="hs-comment">-- See Note [Located RdrNames] in &quot;GHC.Hs.Expr&quot;.</span><span>
</span><span id="line-1256"></span><span class="hs-keyword">data</span><span> </span><span id="AmbiguousFieldOcc"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#AmbiguousFieldOcc"><span class="hs-identifier hs-var">AmbiguousFieldOcc</span></a></span></span><span> </span><span id="local-6989586621681629913"><span class="annot"><a href="#local-6989586621681629913"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-1257"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Unambiguous"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#Unambiguous"><span class="hs-identifier hs-var">Unambiguous</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XUnambiguous"><span class="hs-identifier hs-type">XUnambiguous</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629913"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629913"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1258"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Ambiguous"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#Ambiguous"><span class="hs-identifier hs-var">Ambiguous</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAmbiguous"><span class="hs-identifier hs-type">XAmbiguous</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629913"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629913"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1259"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XAmbiguousFieldOcc"><span class="annot"><a href="Language.Haskell.Syntax.Type.html#XAmbiguousFieldOcc"><span class="hs-identifier hs-var">XAmbiguousFieldOcc</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXAmbiguousFieldOcc"><span class="hs-identifier hs-type">XXAmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681629913"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1260"></span><span>
</span><span id="line-1261"></span><span>
</span><span id="line-1262"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Pretty printing}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1269"></span></pre></body></html>